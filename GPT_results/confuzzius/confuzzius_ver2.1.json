[
    {
        "code_segment": "contract StorageUtils is IStorageUtils {\n    struct Template {\n        bytes32 endpointId;\n        bytes parameters;\n    }\n\n    struct Subscription {\n        uint256 chainId;\n        address airnode;\n        bytes32 templateId;\n        bytes parameters;\n        bytes conditions;\n        address relayer;\n        address sponsor;\n        address requester;\n        bytes4 fulfillFunctionId;\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    uint256 public constant override MAXIMUM_PARAMETER_LENGTH = 4096;\n\n    \n    mapping(bytes32 => Template) public override templates;\n\n    \n    mapping(bytes32 => Subscription) public override subscriptions;\n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    function storeTemplate(bytes32 endpointId, bytes calldata parameters)\n        external\n        override\n        returns (bytes32 templateId)\n    {\n        require(\n            parameters.length <= MAXIMUM_PARAMETER_LENGTH,\n            \"Parameters too long\"\n        );\n        templateId = keccak256(abi.encodePacked(endpointId, parameters));\n        templates[templateId] = Template({\n            endpointId: endpointId,\n            parameters: parameters\n        });\n        emit StoredTemplate(templateId, endpointId, parameters);\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    function storeSubscription(\n        uint256 chainId,\n        address airnode,\n        bytes32 templateId,\n        bytes calldata parameters,\n        bytes calldata conditions,\n        address relayer,\n        address sponsor,\n        address requester,\n        bytes4 fulfillFunctionId\n    ) external override returns (bytes32 subscriptionId) {\n        require(chainId != 0, \"Chain ID zero\");\n        require(airnode != address(0), \"Airnode address zero\");\n        require(\n            parameters.length <= MAXIMUM_PARAMETER_LENGTH,\n            \"Parameters too long\"\n        );\n        require(\n            conditions.length <= MAXIMUM_PARAMETER_LENGTH,\n            \"Conditions too long\"\n        );\n        require(relayer != address(0), \"Relayer address zero\");\n        require(sponsor != address(0), \"Sponsor address zero\");\n        require(requester != address(0), \"Requester address zero\");\n        require(fulfillFunctionId != bytes4(0), \"Fulfill function ID zero\");\n        subscriptionId = keccak256(\n            // SWC-133-Hash Collisions With Multiple Variable Length Arguments: L137-L147\n            abi.encodePacked(\n                chainId,\n                airnode,\n                templateId,\n                parameters,\n                conditions,\n                relayer,\n                sponsor,\n                requester,\n                fulfillFunctionId\n            )\n        );\n        subscriptions[subscriptionId] = Subscription({\n            chainId: chainId,\n            airnode: airnode,\n            templateId: templateId,\n            parameters: parameters,\n            conditions: conditions,\n            relayer: relayer,\n            sponsor: sponsor,\n            requester: requester,\n            fulfillFunctionId: fulfillFunctionId\n        });\n        emit StoredSubscription(\n            subscriptionId,\n            chainId,\n            airnode,\n            templateId,\n            parameters,\n            conditions,\n            relayer,\n            sponsor,\n            requester,\n            fulfillFunctionId\n        );\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-API3/airnode-991af4d69e82c1954a5c6c8e247cde8eb76101de/packages/airnode-protocol-v1/contracts/protocol/StorageUtils.sol",
        "vulnerability": "Arbitrary Memory Access",
        "check": "FP",
        "response": "Answer: No\nReason: The contract has appropriate checks and balances for parameters' lengths and doesn't give access to arbitrary memory slots."
    },
    {
        "code_segment": "contract StorageUtils is IStorageUtils {\n    struct Template {\n        bytes32 endpointId;\n        bytes parameters;\n    }\n\n    struct Subscription {\n        uint256 chainId;\n        address airnode;\n        bytes32 templateId;\n        bytes parameters;\n        bytes conditions;\n        address relayer;\n        address sponsor;\n        address requester;\n        bytes4 fulfillFunctionId;\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    uint256 public constant override MAXIMUM_PARAMETER_LENGTH = 4096;\n\n    \n    mapping(bytes32 => Template) public override templates;\n\n    \n    mapping(bytes32 => Subscription) public override subscriptions;\n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    function storeTemplate(bytes32 endpointId, bytes calldata parameters)\n        external\n        override\n        returns (bytes32 templateId)\n    {\n        require(\n            parameters.length <= MAXIMUM_PARAMETER_LENGTH,\n            \"Parameters too long\"\n        );\n        templateId = keccak256(abi.encodePacked(endpointId, parameters));\n        templates[templateId] = Template({\n            endpointId: endpointId,\n            parameters: parameters\n        });\n        emit StoredTemplate(templateId, endpointId, parameters);\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    function storeSubscription(\n        uint256 chainId,\n        address airnode,\n        bytes32 templateId,\n        bytes calldata parameters,\n        bytes calldata conditions,\n        address relayer,\n        address sponsor,\n        address requester,\n        bytes4 fulfillFunctionId\n    ) external override returns (bytes32 subscriptionId) {\n        require(chainId != 0, \"Chain ID zero\");\n        require(airnode != address(0), \"Airnode address zero\");\n        require(\n            parameters.length <= MAXIMUM_PARAMETER_LENGTH,\n            \"Parameters too long\"\n        );\n        require(\n            conditions.length <= MAXIMUM_PARAMETER_LENGTH,\n            \"Conditions too long\"\n        );\n        require(relayer != address(0), \"Relayer address zero\");\n        require(sponsor != address(0), \"Sponsor address zero\");\n        require(requester != address(0), \"Requester address zero\");\n        require(fulfillFunctionId != bytes4(0), \"Fulfill function ID zero\");\n        subscriptionId = keccak256(\n            // SWC-133-Hash Collisions With Multiple Variable Length Arguments: L137-L147\n            abi.encodePacked(\n                chainId,\n                airnode,\n                templateId,\n                parameters,\n                conditions,\n                relayer,\n                sponsor,\n                requester,\n                fulfillFunctionId\n            )\n        );\n        subscriptions[subscriptionId] = Subscription({\n            chainId: chainId,\n            airnode: airnode,\n            templateId: templateId,\n            parameters: parameters,\n            conditions: conditions,\n            relayer: relayer,\n            sponsor: sponsor,\n            requester: requester,\n            fulfillFunctionId: fulfillFunctionId\n        });\n        emit StoredSubscription(\n            subscriptionId,\n            chainId,\n            airnode,\n            templateId,\n            parameters,\n            conditions,\n            relayer,\n            sponsor,\n            requester,\n            fulfillFunctionId\n        );\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-API3/airnode-991af4d69e82c1954a5c6c8e247cde8eb76101de/packages/airnode-protocol-v1/contracts/protocol/StorageUtils.sol",
        "vulnerability": "Arbitrary Memory Access",
        "check": "FP",
        "response": "Answer: No\nReason: The code does not include raw memory manipulation (e.g., use of assembly) that would allow arbitrary memory access. It properly handles structured data using Solidity's high-level constructs."
    },
    {
        "code_segment": "contract StorageUtils is IStorageUtils {\n    struct Template {\n        bytes32 endpointId;\n        bytes parameters;\n    }\n\n    struct Subscription {\n        uint256 chainId;\n        address airnode;\n        bytes32 templateId;\n        bytes parameters;\n        bytes conditions;\n        address relayer;\n        address sponsor;\n        address requester;\n        bytes4 fulfillFunctionId;\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    uint256 public constant override MAXIMUM_PARAMETER_LENGTH = 4096;\n\n    \n    mapping(bytes32 => Template) public override templates;\n\n    \n    mapping(bytes32 => Subscription) public override subscriptions;\n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    function storeTemplate(bytes32 endpointId, bytes calldata parameters)\n        external\n        override\n        returns (bytes32 templateId)\n    {\n        require(\n            parameters.length <= MAXIMUM_PARAMETER_LENGTH,\n            \"Parameters too long\"\n        );\n        templateId = keccak256(abi.encodePacked(endpointId, parameters));\n        templates[templateId] = Template({\n            endpointId: endpointId,\n            parameters: parameters\n        });\n        emit StoredTemplate(templateId, endpointId, parameters);\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    function storeSubscription(\n        uint256 chainId,\n        address airnode,\n        bytes32 templateId,\n        bytes calldata parameters,\n        bytes calldata conditions,\n        address relayer,\n        address sponsor,\n        address requester,\n        bytes4 fulfillFunctionId\n    ) external override returns (bytes32 subscriptionId) {\n        require(chainId != 0, \"Chain ID zero\");\n        require(airnode != address(0), \"Airnode address zero\");\n        require(\n            parameters.length <= MAXIMUM_PARAMETER_LENGTH,\n            \"Parameters too long\"\n        );\n        require(\n            conditions.length <= MAXIMUM_PARAMETER_LENGTH,\n            \"Conditions too long\"\n        );\n        require(relayer != address(0), \"Relayer address zero\");\n        require(sponsor != address(0), \"Sponsor address zero\");\n        require(requester != address(0), \"Requester address zero\");\n        require(fulfillFunctionId != bytes4(0), \"Fulfill function ID zero\");\n        subscriptionId = keccak256(\n            // SWC-133-Hash Collisions With Multiple Variable Length Arguments: L137-L147\n            abi.encodePacked(\n                chainId,\n                airnode,\n                templateId,\n                parameters,\n                conditions,\n                relayer,\n                sponsor,\n                requester,\n                fulfillFunctionId\n            )\n        );\n        subscriptions[subscriptionId] = Subscription({\n            chainId: chainId,\n            airnode: airnode,\n            templateId: templateId,\n            parameters: parameters,\n            conditions: conditions,\n            relayer: relayer,\n            sponsor: sponsor,\n            requester: requester,\n            fulfillFunctionId: fulfillFunctionId\n        });\n        emit StoredSubscription(\n            subscriptionId,\n            chainId,\n            airnode,\n            templateId,\n            parameters,\n            conditions,\n            relayer,\n            sponsor,\n            requester,\n            fulfillFunctionId\n        );\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-API3/airnode-991af4d69e82c1954a5c6c8e247cde8eb76101de/packages/airnode-protocol-v1/contracts/protocol/StorageUtils.sol",
        "vulnerability": "Arbitrary Memory Access",
        "check": "FP",
        "response": "Answer: No\nReason: The contract code properly restricts the length of parameters and conditions and does not allow any form of direct low-level memory access, which typically causes arbitrary memory access vulnerabilities."
    },
    {
        "code_segment": "contract StorageUtils is IStorageUtils {\n    struct Template {\n        bytes32 endpointId;\n        bytes parameters;\n    }\n\n    struct Subscription {\n        uint256 chainId;\n        address airnode;\n        bytes32 templateId;\n        bytes parameters;\n        bytes conditions;\n        address relayer;\n        address sponsor;\n        address requester;\n        bytes4 fulfillFunctionId;\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    uint256 public constant override MAXIMUM_PARAMETER_LENGTH = 4096;\n\n    \n    mapping(bytes32 => Template) public override templates;\n\n    \n    mapping(bytes32 => Subscription) public override subscriptions;\n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    function storeTemplate(bytes32 endpointId, bytes calldata parameters)\n        external\n        override\n        returns (bytes32 templateId)\n    {\n        require(\n            parameters.length <= MAXIMUM_PARAMETER_LENGTH,\n            \"Parameters too long\"\n        );\n        templateId = keccak256(abi.encodePacked(endpointId, parameters));\n        templates[templateId] = Template({\n            endpointId: endpointId,\n            parameters: parameters\n        });\n        emit StoredTemplate(templateId, endpointId, parameters);\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    function storeSubscription(\n        uint256 chainId,\n        address airnode,\n        bytes32 templateId,\n        bytes calldata parameters,\n        bytes calldata conditions,\n        address relayer,\n        address sponsor,\n        address requester,\n        bytes4 fulfillFunctionId\n    ) external override returns (bytes32 subscriptionId) {\n        require(chainId != 0, \"Chain ID zero\");\n        require(airnode != address(0), \"Airnode address zero\");\n        require(\n            parameters.length <= MAXIMUM_PARAMETER_LENGTH,\n            \"Parameters too long\"\n        );\n        require(\n            conditions.length <= MAXIMUM_PARAMETER_LENGTH,\n            \"Conditions too long\"\n        );\n        require(relayer != address(0), \"Relayer address zero\");\n        require(sponsor != address(0), \"Sponsor address zero\");\n        require(requester != address(0), \"Requester address zero\");\n        require(fulfillFunctionId != bytes4(0), \"Fulfill function ID zero\");\n        subscriptionId = keccak256(\n            // SWC-133-Hash Collisions With Multiple Variable Length Arguments: L137-L147\n            abi.encodePacked(\n                chainId,\n                airnode,\n                templateId,\n                parameters,\n                conditions,\n                relayer,\n                sponsor,\n                requester,\n                fulfillFunctionId\n            )\n        );\n        subscriptions[subscriptionId] = Subscription({\n            chainId: chainId,\n            airnode: airnode,\n            templateId: templateId,\n            parameters: parameters,\n            conditions: conditions,\n            relayer: relayer,\n            sponsor: sponsor,\n            requester: requester,\n            fulfillFunctionId: fulfillFunctionId\n        });\n        emit StoredSubscription(\n            subscriptionId,\n            chainId,\n            airnode,\n            templateId,\n            parameters,\n            conditions,\n            relayer,\n            sponsor,\n            requester,\n            fulfillFunctionId\n        );\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-API3/airnode-991af4d69e82c1954a5c6c8e247cde8eb76101de/packages/airnode-protocol-v1/contracts/protocol/StorageUtils.sol",
        "vulnerability": "Arbitrary Memory Access",
        "check": "FP",
        "response": "Answer: No\nReason: There are no operations involving direct memory access, pointer arithmetic, or unchecked array indexing, which are typical causes of \"Arbitrary Memory Access\" vulnerabilities."
    },
    {
        "code_segment": "contract StorageUtils is IStorageUtils {\n    struct Template {\n        bytes32 endpointId;\n        bytes parameters;\n    }\n\n    struct Subscription {\n        uint256 chainId;\n        address airnode;\n        bytes32 templateId;\n        bytes parameters;\n        bytes conditions;\n        address relayer;\n        address sponsor;\n        address requester;\n        bytes4 fulfillFunctionId;\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    uint256 public constant override MAXIMUM_PARAMETER_LENGTH = 4096;\n\n    \n    mapping(bytes32 => Template) public override templates;\n\n    \n    mapping(bytes32 => Subscription) public override subscriptions;\n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    function storeTemplate(bytes32 endpointId, bytes calldata parameters)\n        external\n        override\n        returns (bytes32 templateId)\n    {\n        require(\n            parameters.length <= MAXIMUM_PARAMETER_LENGTH,\n            \"Parameters too long\"\n        );\n        templateId = keccak256(abi.encodePacked(endpointId, parameters));\n        templates[templateId] = Template({\n            endpointId: endpointId,\n            parameters: parameters\n        });\n        emit StoredTemplate(templateId, endpointId, parameters);\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    function storeSubscription(\n        uint256 chainId,\n        address airnode,\n        bytes32 templateId,\n        bytes calldata parameters,\n        bytes calldata conditions,\n        address relayer,\n        address sponsor,\n        address requester,\n        bytes4 fulfillFunctionId\n    ) external override returns (bytes32 subscriptionId) {\n        require(chainId != 0, \"Chain ID zero\");\n        require(airnode != address(0), \"Airnode address zero\");\n        require(\n            parameters.length <= MAXIMUM_PARAMETER_LENGTH,\n            \"Parameters too long\"\n        );\n        require(\n            conditions.length <= MAXIMUM_PARAMETER_LENGTH,\n            \"Conditions too long\"\n        );\n        require(relayer != address(0), \"Relayer address zero\");\n        require(sponsor != address(0), \"Sponsor address zero\");\n        require(requester != address(0), \"Requester address zero\");\n        require(fulfillFunctionId != bytes4(0), \"Fulfill function ID zero\");\n        subscriptionId = keccak256(\n            // SWC-133-Hash Collisions With Multiple Variable Length Arguments: L137-L147\n            abi.encodePacked(\n                chainId,\n                airnode,\n                templateId,\n                parameters,\n                conditions,\n                relayer,\n                sponsor,\n                requester,\n                fulfillFunctionId\n            )\n        );\n        subscriptions[subscriptionId] = Subscription({\n            chainId: chainId,\n            airnode: airnode,\n            templateId: templateId,\n            parameters: parameters,\n            conditions: conditions,\n            relayer: relayer,\n            sponsor: sponsor,\n            requester: requester,\n            fulfillFunctionId: fulfillFunctionId\n        });\n        emit StoredSubscription(\n            subscriptionId,\n            chainId,\n            airnode,\n            templateId,\n            parameters,\n            conditions,\n            relayer,\n            sponsor,\n            requester,\n            fulfillFunctionId\n        );\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-API3/airnode-991af4d69e82c1954a5c6c8e247cde8eb76101de/packages/airnode-protocol-v1/contracts/protocol/StorageUtils.sol",
        "vulnerability": "Arbitrary Memory Access",
        "check": "FP",
        "response": "Answer: No\nReason: The code does not perform any direct memory access operations or pointer arithmetic which are typically required for an \"Arbitrary Memory Access\" vulnerability."
    },
    {
        "code_segment": "contract TOKEN is Ownable {\n   // specify `cap_supply`, declare `minter` and `supply`\n    uint256 cap_supply = 500000000 ether ;\n    uint256 supply = 100000000 ether;\n    string symbol = \"TST\";\n        address private minter;\n\n        // burn tokens by updating senders's balance and total supply\n        function burn(uint256 amount) public onlyOwner{\n        require(balances[msg.sender] >= amount); // must have enough balance to burn\n        supply -= amount;\n        cap_supply -= amount;\n        transfer(address(0), amount); // burn tokens by sending tokens to `address(0)`\n        }\n\n        // mint tokens by updating receiver's balance and total supply\n        function mint(address receiver, uint256 amount) public onlyOwner  {\n        require((amount + supply) <= cap_supply, \"Cap Reached\"); // total supply must not exceed `cap_supply` \n        balances[receiver] += amount;\n        supply += amount;\n        emit Transfer(msg.sender, receiver, amount);\n        }\n\n         // transfer of tokens\n        function transfer(address _to, uint256 _value) public {\n        require((_value) <= balances[msg.sender]); // NOTE: sender needs to have enough tokens\n        if(_to == address(0)){\n            balances[_to] += _value;\n            balances[msg.sender] -= _value;\n            emit Transfer(msg.sender, address(0), _value);\n        }\n        else{balances[_to] += _value; // transfer `_value` tokens from sender to `_to`\n        balances[msg.sender] -= (_value); // NOTE: transfer value needs to be sufficient to cover fee\n        emit Transfer(msg.sender, _to, _value);\n        }\n    }\n\n    \n    // event to be emitted on transfer \n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    \n    // event to be emitted on approval\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n    \n    // create mapping for balances\n    mapping(address => uint256) public balances;\n    \n    // create mapping for allowances\n    mapping(address => mapping(address => uint)) public allowances;\n    \n    // return the balance of _owner \n    function balanceOf(address _owner) public view returns (uint256) {return balances[_owner];}\n\n    function allowance(address _owner, address _spender) public view returns (uint256 remaining)\n        {remaining = allowances[_owner][_spender]; \n        require(remaining <= balances[_owner]);\n        return remaining;} // return how much `_spender` is allowed to spend on behalf of `_owner` \n    \n    // if an allowance already exists, it should be overwritten\n    function approve(address _spender, uint256 _value) public {\n        allowances[msg.sender][_spender] = _value; // allow `_spender` to spend `_value` on sender's behalf \n        require(balances[msg.sender] >= _value);\n        emit Approval(msg.sender, _spender, _value);\n        }\n        \n    constructor(){balances[msg.sender] = supply; minter = msg.sender;} // sender's balance = total supply, sender is minter\n    \n    function totalSupply() public view returns (uint256) {return supply;} //return total supply\n   \n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/QuillAudits-AQEX Token Smart Contract/erc-20-token-3628abfa6ea2636866f7d5ad1f8cc570b0d5bb1b/Token.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No\nReason: The contract contains checks that prevent integer overflow when adding or subtracting amounts from `supply` and `balances`."
    },
    {
        "code_segment": "contract BNRG is IERC20, Ownable {\n\n    string private constant _name = \"Binamon Energy\";\n    string private constant _symbol = \"BNRG\";\n    uint8 private constant _decimals = 18;  \n    uint256 private _totalSupply = 10 * 10**6 * 10**18;\n    \n    mapping(address => uint256) private balances;\n    mapping(address => mapping (address => uint256)) private allowed;\n    mapping(address => address) private boosterBuyingAllowed;\n    address private stakingContractAddress;\n    \n    // listing restrictions\n    uint256 private restrictionLiftTime;\n    uint256 private maxRestrictionAmount = 300 * 10**6 * 10**18;\n    mapping (address => bool) private isBlacklisted;\n    mapping (address => uint256) private lastTx;\n    // end restrictions\n    \n    using SafeMath for uint256;\n    \n    enum State {\n        Locked,\n        Restricted, // Bot protection for liquidity pool\n        Unlocked\n    }\n    State public state;\n    \n    constructor() { \n        state = State.Locked;\n        balances[msg.sender] = _totalSupply;\n        emit Transfer(address(0), msg.sender, _totalSupply);\n    }\n    \n    function name() public pure returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public pure returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() public pure returns (uint8) {\n        return _decimals;\n    }\n    \n    function totalSupply() public override view returns (uint256) {\n\t    return _totalSupply;\n    }\n    \n    function balanceOf(address tokenOwner) public override view returns (uint256) {\n        return balances[tokenOwner];\n    }\n\n    function transfer(address receiver, uint256 numTokens) public override launchRestrict(msg.sender, receiver, numTokens) returns (bool) {\n        require(numTokens > 0, \"Transfer amount must be greater than zero\");\n        require(numTokens <= balances[msg.sender]);\n        balances[msg.sender] = balances[msg.sender].sub(numTokens);\n        balances[receiver] = balances[receiver].add(numTokens);\n        emit Transfer(msg.sender, receiver, numTokens);\n        return true;\n    }\n//SWC-100-Function Default Visibility: L105\n    function approve(address delegate, uint256 numTokens) public override returns (bool) {\n        allowed[msg.sender][delegate] = numTokens;\n        emit Approval(msg.sender, delegate, numTokens);\n        return true;\n    }\n\n    function allowance(address owner, address delegate) public override view returns (uint256) {\n        return allowed[owner][delegate];\n    }\n\n    function transferFrom(address owner, address receiver, uint256 numTokens) public override launchRestrict(owner, receiver, numTokens) returns (bool) {\n        require(numTokens <= balances[owner]);    \n        require(boosterBuyingAllowed[owner] == msg.sender || numTokens <= allowed[owner][msg.sender]);\n    \n        balances[owner] = balances[owner].sub(numTokens);\n        if (boosterBuyingAllowed[owner] != msg.sender) {\n            allowed[owner][msg.sender] = allowed[owner][msg.sender].sub(numTokens);\n            balances[receiver] = balances[receiver].add(numTokens);\n            emit Transfer(owner, receiver, numTokens);\n        } else {\n            _totalSupply = _totalSupply.sub(numTokens);\n            emit Transfer(owner, address(0), numTokens);\n        }\n        return true;\n    }\n    \n    function boosterBuyingAllowance(address owner) public view returns (bool) {\n        return boosterBuyingAllowance(owner, msg.sender);\n    }\n    \n    function boosterBuyingAllowance(address owner, address delegate) public view returns (bool) {\n        if (boosterBuyingAllowed[owner] == delegate) return true;\n        else return false;\n    }\n    \n    function allowBuyingBoosters(address bmonc) public returns (bool) {\n        boosterBuyingAllowed[msg.sender] = bmonc;\n        return true;\n    }  \n    \n    function setStakingContract(address stakingContractAddress_) public onlyOwner {\n        stakingContractAddress = stakingContractAddress_;\n    }\n    \n    function deliver(address user, uint256 numTokens) public {\n        require(msg.sender == stakingContractAddress, \"Manual call not allowed\");\n        balances[user] = balances[user].add(numTokens);\n        _totalSupply = _totalSupply.add(numTokens);\n        emit Transfer(address(0), user, numTokens);\n    }\n    \n    function mint(uint256 numTokens) public onlyOwner returns(bool) {\n        balances[msg.sender] = balances[msg.sender].add(numTokens);\n        _totalSupply = _totalSupply.add(numTokens);\n        emit Transfer(address(0), msg.sender, numTokens);\n        return true;\n    }\n    \n    function burn(uint256 numTokens) public onlyOwner returns(bool) {\n        require(numTokens <= balances[msg.sender]);\n        balances[msg.sender] = balances[msg.sender].sub(numTokens);\n        _totalSupply = _totalSupply.sub(numTokens);\n        emit Transfer(msg.sender, address(0), numTokens);\n        return true;\n    }\n    \n    // Security from bots\n\n    // enable/disable works only once, token never returns to Locked\n    function setBotProtection(bool enable) public onlyOwner() {\n        if (enable && state == State.Locked) state = State.Restricted;\n        if (!enable) state = State.Unlocked;\n    }\n\n    function setRestrictionAmount(uint256 amount) public onlyOwner() {\n        maxRestrictionAmount = amount;\n    }\n\n    function blacklistAccount(address account, bool ban) public onlyOwner() {\n        isBlacklisted[account] = ban;\n    }\n\n    modifier launchRestrict(address sender, address recipient, uint256 amount) {\n        if (state == State.Locked) {\n            require(sender == owner(), \"Tokens are locked\");\n        }\n        if (state == State.Restricted) {\n            require(amount <= maxRestrictionAmount, \"BNRG: amount greater than max limit in restricted mode\");\n            require(lastTx[sender].add(60) <= block.timestamp && lastTx[recipient].add(60) <= block.timestamp, \"BMON: only one tx/min in restricted mode\");\n            lastTx[sender] = block.timestamp;\n            lastTx[recipient] = block.timestamp;\n        }\n        if (state == State.Unlocked) {\n            if (isBlacklisted[recipient]) {\n                require(lastTx[recipient] + 30 days <= block.timestamp, \"BNRG: only one tx/month in banned mode\");\n                lastTx[recipient] = block.timestamp;\n            } else if (isBlacklisted[sender]) {\n                require(lastTx[sender] + 30 days <= block.timestamp, \"BNRG: only one tx/month in banned mode\");\n                lastTx[sender] = block.timestamp;\n            }\n        }\n        _;\n    }\n\n    // Bot security end\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/QuillAudits-Binamon Energy Smart Contract/code/BNRG.sol",
        "vulnerability": "Block Dependency",
        "check": "FP",
        "response": "Answer: Yes\nDescription: The `launchRestrict` modifier depends on `block.timestamp`, which can be manipulated by miners, potentially leading to unintended consequences and vulnerabilities."
    },
    {
        "code_segment": "contract BNRG is IERC20, Ownable {\n\n    string private constant _name = \"Binamon Energy\";\n    string private constant _symbol = \"BNRG\";\n    uint8 private constant _decimals = 18;  \n    uint256 private _totalSupply = 10 * 10**6 * 10**18;\n    \n    mapping(address => uint256) private balances;\n    mapping(address => mapping (address => uint256)) private allowed;\n    mapping(address => address) private boosterBuyingAllowed;\n    address private stakingContractAddress;\n    \n    // listing restrictions\n    uint256 private restrictionLiftTime;\n    uint256 private maxRestrictionAmount = 300 * 10**6 * 10**18;\n    mapping (address => bool) private isBlacklisted;\n    mapping (address => uint256) private lastTx;\n    // end restrictions\n    \n    using SafeMath for uint256;\n    \n    enum State {\n        Locked,\n        Restricted, // Bot protection for liquidity pool\n        Unlocked\n    }\n    State public state;\n    \n    constructor() { \n        state = State.Locked;\n        balances[msg.sender] = _totalSupply;\n        emit Transfer(address(0), msg.sender, _totalSupply);\n    }\n    \n    function name() public pure returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public pure returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() public pure returns (uint8) {\n        return _decimals;\n    }\n    \n    function totalSupply() public override view returns (uint256) {\n\t    return _totalSupply;\n    }\n    \n    function balanceOf(address tokenOwner) public override view returns (uint256) {\n        return balances[tokenOwner];\n    }\n\n    function transfer(address receiver, uint256 numTokens) public override launchRestrict(msg.sender, receiver, numTokens) returns (bool) {\n        require(numTokens > 0, \"Transfer amount must be greater than zero\");\n        require(numTokens <= balances[msg.sender]);\n        balances[msg.sender] = balances[msg.sender].sub(numTokens);\n        balances[receiver] = balances[receiver].add(numTokens);\n        emit Transfer(msg.sender, receiver, numTokens);\n        return true;\n    }\n//SWC-100-Function Default Visibility: L105\n    function approve(address delegate, uint256 numTokens) public override returns (bool) {\n        allowed[msg.sender][delegate] = numTokens;\n        emit Approval(msg.sender, delegate, numTokens);\n        return true;\n    }\n\n    function allowance(address owner, address delegate) public override view returns (uint256) {\n        return allowed[owner][delegate];\n    }\n\n    function transferFrom(address owner, address receiver, uint256 numTokens) public override launchRestrict(owner, receiver, numTokens) returns (bool) {\n        require(numTokens <= balances[owner]);    \n        require(boosterBuyingAllowed[owner] == msg.sender || numTokens <= allowed[owner][msg.sender]);\n    \n        balances[owner] = balances[owner].sub(numTokens);\n        if (boosterBuyingAllowed[owner] != msg.sender) {\n            allowed[owner][msg.sender] = allowed[owner][msg.sender].sub(numTokens);\n            balances[receiver] = balances[receiver].add(numTokens);\n            emit Transfer(owner, receiver, numTokens);\n        } else {\n            _totalSupply = _totalSupply.sub(numTokens);\n            emit Transfer(owner, address(0), numTokens);\n        }\n        return true;\n    }\n    \n    function boosterBuyingAllowance(address owner) public view returns (bool) {\n        return boosterBuyingAllowance(owner, msg.sender);\n    }\n    \n    function boosterBuyingAllowance(address owner, address delegate) public view returns (bool) {\n        if (boosterBuyingAllowed[owner] == delegate) return true;\n        else return false;\n    }\n    \n    function allowBuyingBoosters(address bmonc) public returns (bool) {\n        boosterBuyingAllowed[msg.sender] = bmonc;\n        return true;\n    }  \n    \n    function setStakingContract(address stakingContractAddress_) public onlyOwner {\n        stakingContractAddress = stakingContractAddress_;\n    }\n    \n    function deliver(address user, uint256 numTokens) public {\n        require(msg.sender == stakingContractAddress, \"Manual call not allowed\");\n        balances[user] = balances[user].add(numTokens);\n        _totalSupply = _totalSupply.add(numTokens);\n        emit Transfer(address(0), user, numTokens);\n    }\n    \n    function mint(uint256 numTokens) public onlyOwner returns(bool) {\n        balances[msg.sender] = balances[msg.sender].add(numTokens);\n        _totalSupply = _totalSupply.add(numTokens);\n        emit Transfer(address(0), msg.sender, numTokens);\n        return true;\n    }\n    \n    function burn(uint256 numTokens) public onlyOwner returns(bool) {\n        require(numTokens <= balances[msg.sender]);\n        balances[msg.sender] = balances[msg.sender].sub(numTokens);\n        _totalSupply = _totalSupply.sub(numTokens);\n        emit Transfer(msg.sender, address(0), numTokens);\n        return true;\n    }\n    \n    // Security from bots\n\n    // enable/disable works only once, token never returns to Locked\n    function setBotProtection(bool enable) public onlyOwner() {\n        if (enable && state == State.Locked) state = State.Restricted;\n        if (!enable) state = State.Unlocked;\n    }\n\n    function setRestrictionAmount(uint256 amount) public onlyOwner() {\n        maxRestrictionAmount = amount;\n    }\n\n    function blacklistAccount(address account, bool ban) public onlyOwner() {\n        isBlacklisted[account] = ban;\n    }\n\n    modifier launchRestrict(address sender, address recipient, uint256 amount) {\n        if (state == State.Locked) {\n            require(sender == owner(), \"Tokens are locked\");\n        }\n        if (state == State.Restricted) {\n            require(amount <= maxRestrictionAmount, \"BNRG: amount greater than max limit in restricted mode\");\n            require(lastTx[sender].add(60) <= block.timestamp && lastTx[recipient].add(60) <= block.timestamp, \"BMON: only one tx/min in restricted mode\");\n            lastTx[sender] = block.timestamp;\n            lastTx[recipient] = block.timestamp;\n        }\n        if (state == State.Unlocked) {\n            if (isBlacklisted[recipient]) {\n                require(lastTx[recipient] + 30 days <= block.timestamp, \"BNRG: only one tx/month in banned mode\");\n                lastTx[recipient] = block.timestamp;\n            } else if (isBlacklisted[sender]) {\n                require(lastTx[sender] + 30 days <= block.timestamp, \"BNRG: only one tx/month in banned mode\");\n                lastTx[sender] = block.timestamp;\n            }\n        }\n        _;\n    }\n\n    // Bot security end\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/QuillAudits-Binamon Energy Smart Contract/code/BNRG.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No\nReason: The contract uses SafeMath for arithmetic operations which protects against integer overflow vulnerabilities."
    },
    {
        "code_segment": "contract BNRG is IERC20, Ownable {\n\n    string private constant _name = \"Binamon Energy\";\n    string private constant _symbol = \"BNRG\";\n    uint8 private constant _decimals = 18;  \n    uint256 private _totalSupply = 10 * 10**6 * 10**18;\n    \n    mapping(address => uint256) private balances;\n    mapping(address => mapping (address => uint256)) private allowed;\n    mapping(address => address) private boosterBuyingAllowed;\n    address private stakingContractAddress;\n    \n    // listing restrictions\n    uint256 private restrictionLiftTime;\n    uint256 private maxRestrictionAmount = 300 * 10**6 * 10**18;\n    mapping (address => bool) private isBlacklisted;\n    mapping (address => uint256) private lastTx;\n    // end restrictions\n    \n    using SafeMath for uint256;\n    \n    enum State {\n        Locked,\n        Restricted, // Bot protection for liquidity pool\n        Unlocked\n    }\n    State public state;\n    \n    constructor() { \n        state = State.Locked;\n        balances[msg.sender] = _totalSupply;\n        emit Transfer(address(0), msg.sender, _totalSupply);\n    }\n    \n    function name() public pure returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public pure returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() public pure returns (uint8) {\n        return _decimals;\n    }\n    \n    function totalSupply() public override view returns (uint256) {\n\t    return _totalSupply;\n    }\n    \n    function balanceOf(address tokenOwner) public override view returns (uint256) {\n        return balances[tokenOwner];\n    }\n\n    function transfer(address receiver, uint256 numTokens) public override launchRestrict(msg.sender, receiver, numTokens) returns (bool) {\n        require(numTokens > 0, \"Transfer amount must be greater than zero\");\n        require(numTokens <= balances[msg.sender]);\n        balances[msg.sender] = balances[msg.sender].sub(numTokens);\n        balances[receiver] = balances[receiver].add(numTokens);\n        emit Transfer(msg.sender, receiver, numTokens);\n        return true;\n    }\n//SWC-100-Function Default Visibility: L105\n    function approve(address delegate, uint256 numTokens) public override returns (bool) {\n        allowed[msg.sender][delegate] = numTokens;\n        emit Approval(msg.sender, delegate, numTokens);\n        return true;\n    }\n\n    function allowance(address owner, address delegate) public override view returns (uint256) {\n        return allowed[owner][delegate];\n    }\n\n    function transferFrom(address owner, address receiver, uint256 numTokens) public override launchRestrict(owner, receiver, numTokens) returns (bool) {\n        require(numTokens <= balances[owner]);    \n        require(boosterBuyingAllowed[owner] == msg.sender || numTokens <= allowed[owner][msg.sender]);\n    \n        balances[owner] = balances[owner].sub(numTokens);\n        if (boosterBuyingAllowed[owner] != msg.sender) {\n            allowed[owner][msg.sender] = allowed[owner][msg.sender].sub(numTokens);\n            balances[receiver] = balances[receiver].add(numTokens);\n            emit Transfer(owner, receiver, numTokens);\n        } else {\n            _totalSupply = _totalSupply.sub(numTokens);\n            emit Transfer(owner, address(0), numTokens);\n        }\n        return true;\n    }\n    \n    function boosterBuyingAllowance(address owner) public view returns (bool) {\n        return boosterBuyingAllowance(owner, msg.sender);\n    }\n    \n    function boosterBuyingAllowance(address owner, address delegate) public view returns (bool) {\n        if (boosterBuyingAllowed[owner] == delegate) return true;\n        else return false;\n    }\n    \n    function allowBuyingBoosters(address bmonc) public returns (bool) {\n        boosterBuyingAllowed[msg.sender] = bmonc;\n        return true;\n    }  \n    \n    function setStakingContract(address stakingContractAddress_) public onlyOwner {\n        stakingContractAddress = stakingContractAddress_;\n    }\n    \n    function deliver(address user, uint256 numTokens) public {\n        require(msg.sender == stakingContractAddress, \"Manual call not allowed\");\n        balances[user] = balances[user].add(numTokens);\n        _totalSupply = _totalSupply.add(numTokens);\n        emit Transfer(address(0), user, numTokens);\n    }\n    \n    function mint(uint256 numTokens) public onlyOwner returns(bool) {\n        balances[msg.sender] = balances[msg.sender].add(numTokens);\n        _totalSupply = _totalSupply.add(numTokens);\n        emit Transfer(address(0), msg.sender, numTokens);\n        return true;\n    }\n    \n    function burn(uint256 numTokens) public onlyOwner returns(bool) {\n        require(numTokens <= balances[msg.sender]);\n        balances[msg.sender] = balances[msg.sender].sub(numTokens);\n        _totalSupply = _totalSupply.sub(numTokens);\n        emit Transfer(msg.sender, address(0), numTokens);\n        return true;\n    }\n    \n    // Security from bots\n\n    // enable/disable works only once, token never returns to Locked\n    function setBotProtection(bool enable) public onlyOwner() {\n        if (enable && state == State.Locked) state = State.Restricted;\n        if (!enable) state = State.Unlocked;\n    }\n\n    function setRestrictionAmount(uint256 amount) public onlyOwner() {\n        maxRestrictionAmount = amount;\n    }\n\n    function blacklistAccount(address account, bool ban) public onlyOwner() {\n        isBlacklisted[account] = ban;\n    }\n\n    modifier launchRestrict(address sender, address recipient, uint256 amount) {\n        if (state == State.Locked) {\n            require(sender == owner(), \"Tokens are locked\");\n        }\n        if (state == State.Restricted) {\n            require(amount <= maxRestrictionAmount, \"BNRG: amount greater than max limit in restricted mode\");\n            require(lastTx[sender].add(60) <= block.timestamp && lastTx[recipient].add(60) <= block.timestamp, \"BMON: only one tx/min in restricted mode\");\n            lastTx[sender] = block.timestamp;\n            lastTx[recipient] = block.timestamp;\n        }\n        if (state == State.Unlocked) {\n            if (isBlacklisted[recipient]) {\n                require(lastTx[recipient] + 30 days <= block.timestamp, \"BNRG: only one tx/month in banned mode\");\n                lastTx[recipient] = block.timestamp;\n            } else if (isBlacklisted[sender]) {\n                require(lastTx[sender] + 30 days <= block.timestamp, \"BNRG: only one tx/month in banned mode\");\n                lastTx[sender] = block.timestamp;\n            }\n        }\n        _;\n    }\n\n    // Bot security end\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/QuillAudits-Binamon Energy Smart Contract/code/BNRG.sol",
        "vulnerability": "Assertion Failure",
        "check": "FP",
        "response": "Answer: Yes\nDescription: The function `boosterBuyingAllowance(address owner) public view returns (bool)` contains a call to an overloaded function with the same name `boosterBuyingAllowance(address owner, address delegate)`, leading to incorrect function resolution and potentially unintended behavior."
    },
    {
        "code_segment": "contract BNRG is IERC20, Ownable {\n\n    string private constant _name = \"Binamon Energy\";\n    string private constant _symbol = \"BNRG\";\n    uint8 private constant _decimals = 18;  \n    uint256 private _totalSupply = 10 * 10**6 * 10**18;\n    \n    mapping(address => uint256) private balances;\n    mapping(address => mapping (address => uint256)) private allowed;\n    mapping(address => address) private boosterBuyingAllowed;\n    address private stakingContractAddress;\n    \n    // listing restrictions\n    uint256 private restrictionLiftTime;\n    uint256 private maxRestrictionAmount = 300 * 10**6 * 10**18;\n    mapping (address => bool) private isBlacklisted;\n    mapping (address => uint256) private lastTx;\n    // end restrictions\n    \n    using SafeMath for uint256;\n    \n    enum State {\n        Locked,\n        Restricted, // Bot protection for liquidity pool\n        Unlocked\n    }\n    State public state;\n    \n    constructor() { \n        state = State.Locked;\n        balances[msg.sender] = _totalSupply;\n        emit Transfer(address(0), msg.sender, _totalSupply);\n    }\n    \n    function name() public pure returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public pure returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() public pure returns (uint8) {\n        return _decimals;\n    }\n    \n    function totalSupply() public override view returns (uint256) {\n\t    return _totalSupply;\n    }\n    \n    function balanceOf(address tokenOwner) public override view returns (uint256) {\n        return balances[tokenOwner];\n    }\n\n    function transfer(address receiver, uint256 numTokens) public override launchRestrict(msg.sender, receiver, numTokens) returns (bool) {\n        require(numTokens > 0, \"Transfer amount must be greater than zero\");\n        require(numTokens <= balances[msg.sender]);\n        balances[msg.sender] = balances[msg.sender].sub(numTokens);\n        balances[receiver] = balances[receiver].add(numTokens);\n        emit Transfer(msg.sender, receiver, numTokens);\n        return true;\n    }\n//SWC-100-Function Default Visibility: L105\n    function approve(address delegate, uint256 numTokens) public override returns (bool) {\n        allowed[msg.sender][delegate] = numTokens;\n        emit Approval(msg.sender, delegate, numTokens);\n        return true;\n    }\n\n    function allowance(address owner, address delegate) public override view returns (uint256) {\n        return allowed[owner][delegate];\n    }\n\n    function transferFrom(address owner, address receiver, uint256 numTokens) public override launchRestrict(owner, receiver, numTokens) returns (bool) {\n        require(numTokens <= balances[owner]);    \n        require(boosterBuyingAllowed[owner] == msg.sender || numTokens <= allowed[owner][msg.sender]);\n    \n        balances[owner] = balances[owner].sub(numTokens);\n        if (boosterBuyingAllowed[owner] != msg.sender) {\n            allowed[owner][msg.sender] = allowed[owner][msg.sender].sub(numTokens);\n            balances[receiver] = balances[receiver].add(numTokens);\n            emit Transfer(owner, receiver, numTokens);\n        } else {\n            _totalSupply = _totalSupply.sub(numTokens);\n            emit Transfer(owner, address(0), numTokens);\n        }\n        return true;\n    }\n    \n    function boosterBuyingAllowance(address owner) public view returns (bool) {\n        return boosterBuyingAllowance(owner, msg.sender);\n    }\n    \n    function boosterBuyingAllowance(address owner, address delegate) public view returns (bool) {\n        if (boosterBuyingAllowed[owner] == delegate) return true;\n        else return false;\n    }\n    \n    function allowBuyingBoosters(address bmonc) public returns (bool) {\n        boosterBuyingAllowed[msg.sender] = bmonc;\n        return true;\n    }  \n    \n    function setStakingContract(address stakingContractAddress_) public onlyOwner {\n        stakingContractAddress = stakingContractAddress_;\n    }\n    \n    function deliver(address user, uint256 numTokens) public {\n        require(msg.sender == stakingContractAddress, \"Manual call not allowed\");\n        balances[user] = balances[user].add(numTokens);\n        _totalSupply = _totalSupply.add(numTokens);\n        emit Transfer(address(0), user, numTokens);\n    }\n    \n    function mint(uint256 numTokens) public onlyOwner returns(bool) {\n        balances[msg.sender] = balances[msg.sender].add(numTokens);\n        _totalSupply = _totalSupply.add(numTokens);\n        emit Transfer(address(0), msg.sender, numTokens);\n        return true;\n    }\n    \n    function burn(uint256 numTokens) public onlyOwner returns(bool) {\n        require(numTokens <= balances[msg.sender]);\n        balances[msg.sender] = balances[msg.sender].sub(numTokens);\n        _totalSupply = _totalSupply.sub(numTokens);\n        emit Transfer(msg.sender, address(0), numTokens);\n        return true;\n    }\n    \n    // Security from bots\n\n    // enable/disable works only once, token never returns to Locked\n    function setBotProtection(bool enable) public onlyOwner() {\n        if (enable && state == State.Locked) state = State.Restricted;\n        if (!enable) state = State.Unlocked;\n    }\n\n    function setRestrictionAmount(uint256 amount) public onlyOwner() {\n        maxRestrictionAmount = amount;\n    }\n\n    function blacklistAccount(address account, bool ban) public onlyOwner() {\n        isBlacklisted[account] = ban;\n    }\n\n    modifier launchRestrict(address sender, address recipient, uint256 amount) {\n        if (state == State.Locked) {\n            require(sender == owner(), \"Tokens are locked\");\n        }\n        if (state == State.Restricted) {\n            require(amount <= maxRestrictionAmount, \"BNRG: amount greater than max limit in restricted mode\");\n            require(lastTx[sender].add(60) <= block.timestamp && lastTx[recipient].add(60) <= block.timestamp, \"BMON: only one tx/min in restricted mode\");\n            lastTx[sender] = block.timestamp;\n            lastTx[recipient] = block.timestamp;\n        }\n        if (state == State.Unlocked) {\n            if (isBlacklisted[recipient]) {\n                require(lastTx[recipient] + 30 days <= block.timestamp, \"BNRG: only one tx/month in banned mode\");\n                lastTx[recipient] = block.timestamp;\n            } else if (isBlacklisted[sender]) {\n                require(lastTx[sender] + 30 days <= block.timestamp, \"BNRG: only one tx/month in banned mode\");\n                lastTx[sender] = block.timestamp;\n            }\n        }\n        _;\n    }\n\n    // Bot security end\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/QuillAudits-Binamon Energy Smart Contract/code/BNRG.sol",
        "vulnerability": "Block Dependency",
        "check": "FP",
        "response": "Answer: Yes\nDescription: The `launchRestrict` modifier uses `block.timestamp` to enforce transaction restrictions, making the smart contract execution dependent on the block timestamp, which can be manipulated by miners."
    },
    {
        "code_segment": "contract BNRG is IERC20, Ownable {\n\n    string private constant _name = \"Binamon Energy\";\n    string private constant _symbol = \"BNRG\";\n    uint8 private constant _decimals = 18;  \n    uint256 private _totalSupply = 10 * 10**6 * 10**18;\n    \n    mapping(address => uint256) private balances;\n    mapping(address => mapping (address => uint256)) private allowed;\n    mapping(address => address) private boosterBuyingAllowed;\n    address private stakingContractAddress;\n    \n    // listing restrictions\n    uint256 private restrictionLiftTime;\n    uint256 private maxRestrictionAmount = 300 * 10**6 * 10**18;\n    mapping (address => bool) private isBlacklisted;\n    mapping (address => uint256) private lastTx;\n    // end restrictions\n    \n    using SafeMath for uint256;\n    \n    enum State {\n        Locked,\n        Restricted, // Bot protection for liquidity pool\n        Unlocked\n    }\n    State public state;\n    \n    constructor() { \n        state = State.Locked;\n        balances[msg.sender] = _totalSupply;\n        emit Transfer(address(0), msg.sender, _totalSupply);\n    }\n    \n    function name() public pure returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public pure returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() public pure returns (uint8) {\n        return _decimals;\n    }\n    \n    function totalSupply() public override view returns (uint256) {\n\t    return _totalSupply;\n    }\n    \n    function balanceOf(address tokenOwner) public override view returns (uint256) {\n        return balances[tokenOwner];\n    }\n\n    function transfer(address receiver, uint256 numTokens) public override launchRestrict(msg.sender, receiver, numTokens) returns (bool) {\n        require(numTokens > 0, \"Transfer amount must be greater than zero\");\n        require(numTokens <= balances[msg.sender]);\n        balances[msg.sender] = balances[msg.sender].sub(numTokens);\n        balances[receiver] = balances[receiver].add(numTokens);\n        emit Transfer(msg.sender, receiver, numTokens);\n        return true;\n    }\n//SWC-100-Function Default Visibility: L105\n    function approve(address delegate, uint256 numTokens) public override returns (bool) {\n        allowed[msg.sender][delegate] = numTokens;\n        emit Approval(msg.sender, delegate, numTokens);\n        return true;\n    }\n\n    function allowance(address owner, address delegate) public override view returns (uint256) {\n        return allowed[owner][delegate];\n    }\n\n    function transferFrom(address owner, address receiver, uint256 numTokens) public override launchRestrict(owner, receiver, numTokens) returns (bool) {\n        require(numTokens <= balances[owner]);    \n        require(boosterBuyingAllowed[owner] == msg.sender || numTokens <= allowed[owner][msg.sender]);\n    \n        balances[owner] = balances[owner].sub(numTokens);\n        if (boosterBuyingAllowed[owner] != msg.sender) {\n            allowed[owner][msg.sender] = allowed[owner][msg.sender].sub(numTokens);\n            balances[receiver] = balances[receiver].add(numTokens);\n            emit Transfer(owner, receiver, numTokens);\n        } else {\n            _totalSupply = _totalSupply.sub(numTokens);\n            emit Transfer(owner, address(0), numTokens);\n        }\n        return true;\n    }\n    \n    function boosterBuyingAllowance(address owner) public view returns (bool) {\n        return boosterBuyingAllowance(owner, msg.sender);\n    }\n    \n    function boosterBuyingAllowance(address owner, address delegate) public view returns (bool) {\n        if (boosterBuyingAllowed[owner] == delegate) return true;\n        else return false;\n    }\n    \n    function allowBuyingBoosters(address bmonc) public returns (bool) {\n        boosterBuyingAllowed[msg.sender] = bmonc;\n        return true;\n    }  \n    \n    function setStakingContract(address stakingContractAddress_) public onlyOwner {\n        stakingContractAddress = stakingContractAddress_;\n    }\n    \n    function deliver(address user, uint256 numTokens) public {\n        require(msg.sender == stakingContractAddress, \"Manual call not allowed\");\n        balances[user] = balances[user].add(numTokens);\n        _totalSupply = _totalSupply.add(numTokens);\n        emit Transfer(address(0), user, numTokens);\n    }\n    \n    function mint(uint256 numTokens) public onlyOwner returns(bool) {\n        balances[msg.sender] = balances[msg.sender].add(numTokens);\n        _totalSupply = _totalSupply.add(numTokens);\n        emit Transfer(address(0), msg.sender, numTokens);\n        return true;\n    }\n    \n    function burn(uint256 numTokens) public onlyOwner returns(bool) {\n        require(numTokens <= balances[msg.sender]);\n        balances[msg.sender] = balances[msg.sender].sub(numTokens);\n        _totalSupply = _totalSupply.sub(numTokens);\n        emit Transfer(msg.sender, address(0), numTokens);\n        return true;\n    }\n    \n    // Security from bots\n\n    // enable/disable works only once, token never returns to Locked\n    function setBotProtection(bool enable) public onlyOwner() {\n        if (enable && state == State.Locked) state = State.Restricted;\n        if (!enable) state = State.Unlocked;\n    }\n\n    function setRestrictionAmount(uint256 amount) public onlyOwner() {\n        maxRestrictionAmount = amount;\n    }\n\n    function blacklistAccount(address account, bool ban) public onlyOwner() {\n        isBlacklisted[account] = ban;\n    }\n\n    modifier launchRestrict(address sender, address recipient, uint256 amount) {\n        if (state == State.Locked) {\n            require(sender == owner(), \"Tokens are locked\");\n        }\n        if (state == State.Restricted) {\n            require(amount <= maxRestrictionAmount, \"BNRG: amount greater than max limit in restricted mode\");\n            require(lastTx[sender].add(60) <= block.timestamp && lastTx[recipient].add(60) <= block.timestamp, \"BMON: only one tx/min in restricted mode\");\n            lastTx[sender] = block.timestamp;\n            lastTx[recipient] = block.timestamp;\n        }\n        if (state == State.Unlocked) {\n            if (isBlacklisted[recipient]) {\n                require(lastTx[recipient] + 30 days <= block.timestamp, \"BNRG: only one tx/month in banned mode\");\n                lastTx[recipient] = block.timestamp;\n            } else if (isBlacklisted[sender]) {\n                require(lastTx[sender] + 30 days <= block.timestamp, \"BNRG: only one tx/month in banned mode\");\n                lastTx[sender] = block.timestamp;\n            }\n        }\n        _;\n    }\n\n    // Bot security end\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/QuillAudits-Binamon Energy Smart Contract/code/BNRG.sol",
        "vulnerability": "Block Dependency",
        "check": "FP",
        "response": "Answer: Yes\nDescription: Block timestamp used in `launchRestrict` function can be manipulated by miners to affect the transaction execution."
    },
    {
        "code_segment": "contract GameZilla is BEP20 {\n    \n    /**\n     * @dev Sets symbol, name, decimals and totalSupply of the token\n     * \n     * - Sets msg.sender as the owner of the contract\n     * - Transfers totalSupply to owner\n     */ \n    constructor()   {\n        symbol = \"GZILA\";\n        name = \"GameZilla\";\n        decimals = 18;                                    \n        totalSupply = 1175000000 * 10**18;\n        change = false;\n        percent = 30;\n       \n        owner = msg.sender;\n        balances[owner] = totalSupply;\n    }\n    \n    \n    /**\n     * @dev Calls mint function from BEP20 contract\n     * \n     * Requirements:\n     * \n     * - only owner can call this function\n     * - 'to' address cannot be zero address\n     */\n    function mint(address to, uint amount) external onlyOwner {\n        require(to != address(0), \"No mint to zero address\");\n        _mint(to, amount);\n    }\n    \n    /**\n     * @dev Calls burn function from BEP20 contract\n     * \n     */\n    function burn(uint amount) external {\n        _burn(msg.sender, amount);\n    }\n    \n    \n   \n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/QuillAudits-GameZilla Token Smart Contract/code/GameZilla.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No\nReason: The code does not perform any arithmetic operations that would cause integer overflow."
    },
    {
        "code_segment": "library BasicMathLib {\n  \n  \n  \n  \n  \n  \n  function times(uint256 a, uint256 b) public pure returns (bool err,uint256 res) {\n    assembly{\n      res := mul(a,b)\n      switch or(iszero(b), eq(div(res,b), a))\n      case 0 {\n        err := 1\n        res := 0\n      }\n    }\n  }\n\n  \n  \n  \n  \n  \n  \n  function dividedBy(uint256 a, uint256 b) public pure returns (bool err,uint256 i) {\n    uint256 res;\n    assembly{\n      switch iszero(b)\n      case 0 {\n        res := div(a,b)\n        let loc := mload(0x40)\n        mstore(add(loc,0x20),res)\n        i := mload(add(loc,0x20))\n      }\n      default {\n        err := 1\n        i := 0\n      }\n    }\n  }\n\n  \n  \n  \n  \n  \n  \n  function plus(uint256 a, uint256 b) public pure returns (bool err, uint256 res) {\n    assembly{\n      res := add(a,b)\n      switch and(eq(sub(res,b), a), or(gt(res,b),eq(res,b)))\n      case 0 {\n        err := 1\n        res := 0\n      }\n    }\n  }\n\n  \n  \n  \n  \n  \n  \n  function minus(uint256 a, uint256 b) public pure returns (bool err,uint256 res) {\n    assembly{\n      res := sub(a,b)\n      switch eq(and(eq(add(res,b), a), or(lt(res,a), eq(res,a))), 1)\n      case 0 {\n        err := 1\n        res := 0\n      }\n    }\n  }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/consensys-Modular_Interactive_Crowdsale/ethereum-libraries-73abc22623e0841b8ea67a5089002f4867102672/BasicMathLib/BasicMathLib.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No\nReason: The contract uses inline assembly checks to ensure that operations do not result in overflows or division by zero."
    },
    {
        "code_segment": "library BasicMathLib {\n  \n  \n  \n  \n  \n  \n  function times(uint256 a, uint256 b) public pure returns (bool err,uint256 res) {\n    assembly{\n      res := mul(a,b)\n      switch or(iszero(b), eq(div(res,b), a))\n      case 0 {\n        err := 1\n        res := 0\n      }\n    }\n  }\n\n  \n  \n  \n  \n  \n  \n  function dividedBy(uint256 a, uint256 b) public pure returns (bool err,uint256 i) {\n    uint256 res;\n    assembly{\n      switch iszero(b)\n      case 0 {\n        res := div(a,b)\n        let loc := mload(0x40)\n        mstore(add(loc,0x20),res)\n        i := mload(add(loc,0x20))\n      }\n      default {\n        err := 1\n        i := 0\n      }\n    }\n  }\n\n  \n  \n  \n  \n  \n  \n  function plus(uint256 a, uint256 b) public pure returns (bool err, uint256 res) {\n    assembly{\n      res := add(a,b)\n      switch and(eq(sub(res,b), a), or(gt(res,b),eq(res,b)))\n      case 0 {\n        err := 1\n        res := 0\n      }\n    }\n  }\n\n  \n  \n  \n  \n  \n  \n  function minus(uint256 a, uint256 b) public pure returns (bool err,uint256 res) {\n    assembly{\n      res := sub(a,b)\n      switch eq(and(eq(add(res,b), a), or(lt(res,a), eq(res,a))), 1)\n      case 0 {\n        err := 1\n        res := 0\n      }\n    }\n  }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/consensys-Modular_Interactive_Crowdsale/ethereum-libraries-73abc22623e0841b8ea67a5089002f4867102672/BasicMathLib/BasicMathLib.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No\nReason: Proper assembly checks are in place to handle overflows/underflows in operations."
    },
    {
        "code_segment": "library BasicMathLib {\n  \n  \n  \n  \n  \n  \n  function times(uint256 a, uint256 b) public pure returns (bool err,uint256 res) {\n    assembly{\n      res := mul(a,b)\n      switch or(iszero(b), eq(div(res,b), a))\n      case 0 {\n        err := 1\n        res := 0\n      }\n    }\n  }\n\n  \n  \n  \n  \n  \n  \n  function dividedBy(uint256 a, uint256 b) public pure returns (bool err,uint256 i) {\n    uint256 res;\n    assembly{\n      switch iszero(b)\n      case 0 {\n        res := div(a,b)\n        let loc := mload(0x40)\n        mstore(add(loc,0x20),res)\n        i := mload(add(loc,0x20))\n      }\n      default {\n        err := 1\n        i := 0\n      }\n    }\n  }\n\n  \n  \n  \n  \n  \n  \n  function plus(uint256 a, uint256 b) public pure returns (bool err, uint256 res) {\n    assembly{\n      res := add(a,b)\n      switch and(eq(sub(res,b), a), or(gt(res,b),eq(res,b)))\n      case 0 {\n        err := 1\n        res := 0\n      }\n    }\n  }\n\n  \n  \n  \n  \n  \n  \n  function minus(uint256 a, uint256 b) public pure returns (bool err,uint256 res) {\n    assembly{\n      res := sub(a,b)\n      switch eq(and(eq(add(res,b), a), or(lt(res,a), eq(res,a))), 1)\n      case 0 {\n        err := 1\n        res := 0\n      }\n    }\n  }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/consensys-Modular_Interactive_Crowdsale/ethereum-libraries-73abc22623e0841b8ea67a5089002f4867102672/BasicMathLib/BasicMathLib.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No\nReason: The code uses inline assembly with logic and safety checks to handle arithmetic operations correctly, preventing integer overflow."
    },
    {
        "code_segment": "library BasicMathLib {\n  \n  \n  \n  \n  \n  \n  function times(uint256 a, uint256 b) public pure returns (bool err,uint256 res) {\n    assembly{\n      res := mul(a,b)\n      switch or(iszero(b), eq(div(res,b), a))\n      case 0 {\n        err := 1\n        res := 0\n      }\n    }\n  }\n\n  \n  \n  \n  \n  \n  \n  function dividedBy(uint256 a, uint256 b) public pure returns (bool err,uint256 i) {\n    uint256 res;\n    assembly{\n      switch iszero(b)\n      case 0 {\n        res := div(a,b)\n        let loc := mload(0x40)\n        mstore(add(loc,0x20),res)\n        i := mload(add(loc,0x20))\n      }\n      default {\n        err := 1\n        i := 0\n      }\n    }\n  }\n\n  \n  \n  \n  \n  \n  \n  function plus(uint256 a, uint256 b) public pure returns (bool err, uint256 res) {\n    assembly{\n      res := add(a,b)\n      switch and(eq(sub(res,b), a), or(gt(res,b),eq(res,b)))\n      case 0 {\n        err := 1\n        res := 0\n      }\n    }\n  }\n\n  \n  \n  \n  \n  \n  \n  function minus(uint256 a, uint256 b) public pure returns (bool err,uint256 res) {\n    assembly{\n      res := sub(a,b)\n      switch eq(and(eq(add(res,b), a), or(lt(res,a), eq(res,a))), 1)\n      case 0 {\n        err := 1\n        res := 0\n      }\n    }\n  }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/consensys-Modular_Interactive_Crowdsale/ethereum-libraries-73abc22623e0841b8ea67a5089002f4867102672/BasicMathLib/BasicMathLib.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: Yes\nDescription: The function \"plus\" does not handle cases where the sum of `a` and `b` exceeds the maximum uint256 value, causing a wraparound (overflow)."
    },
    {
        "code_segment": "library BasicMathLib {\n  \n  \n  \n  \n  \n  \n  function times(uint256 a, uint256 b) public pure returns (bool err,uint256 res) {\n    assembly{\n      res := mul(a,b)\n      switch or(iszero(b), eq(div(res,b), a))\n      case 0 {\n        err := 1\n        res := 0\n      }\n    }\n  }\n\n  \n  \n  \n  \n  \n  \n  function dividedBy(uint256 a, uint256 b) public pure returns (bool err,uint256 i) {\n    uint256 res;\n    assembly{\n      switch iszero(b)\n      case 0 {\n        res := div(a,b)\n        let loc := mload(0x40)\n        mstore(add(loc,0x20),res)\n        i := mload(add(loc,0x20))\n      }\n      default {\n        err := 1\n        i := 0\n      }\n    }\n  }\n\n  \n  \n  \n  \n  \n  \n  function plus(uint256 a, uint256 b) public pure returns (bool err, uint256 res) {\n    assembly{\n      res := add(a,b)\n      switch and(eq(sub(res,b), a), or(gt(res,b),eq(res,b)))\n      case 0 {\n        err := 1\n        res := 0\n      }\n    }\n  }\n\n  \n  \n  \n  \n  \n  \n  function minus(uint256 a, uint256 b) public pure returns (bool err,uint256 res) {\n    assembly{\n      res := sub(a,b)\n      switch eq(and(eq(add(res,b), a), or(lt(res,a), eq(res,a))), 1)\n      case 0 {\n        err := 1\n        res := 0\n      }\n    }\n  }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/consensys-Modular_Interactive_Crowdsale/ethereum-libraries-73abc22623e0841b8ea67a5089002f4867102672/CrowdsaleLib/IICOLib/truffle/contracts/InteractiveCrowdsaleLib.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No\nReason: The code uses inline assembly with explicit checks for overflow and underflow conditions."
    },
    {
        "code_segment": "library BasicMathLib {\n  \n  \n  \n  \n  \n  \n  function times(uint256 a, uint256 b) public pure returns (bool err,uint256 res) {\n    assembly{\n      res := mul(a,b)\n      switch or(iszero(b), eq(div(res,b), a))\n      case 0 {\n        err := 1\n        res := 0\n      }\n    }\n  }\n\n  \n  \n  \n  \n  \n  \n  function dividedBy(uint256 a, uint256 b) public pure returns (bool err,uint256 i) {\n    uint256 res;\n    assembly{\n      switch iszero(b)\n      case 0 {\n        res := div(a,b)\n        let loc := mload(0x40)\n        mstore(add(loc,0x20),res)\n        i := mload(add(loc,0x20))\n      }\n      default {\n        err := 1\n        i := 0\n      }\n    }\n  }\n\n  \n  \n  \n  \n  \n  \n  function plus(uint256 a, uint256 b) public pure returns (bool err, uint256 res) {\n    assembly{\n      res := add(a,b)\n      switch and(eq(sub(res,b), a), or(gt(res,b),eq(res,b)))\n      case 0 {\n        err := 1\n        res := 0\n      }\n    }\n  }\n\n  \n  \n  \n  \n  \n  \n  function minus(uint256 a, uint256 b) public pure returns (bool err,uint256 res) {\n    assembly{\n      res := sub(a,b)\n      switch eq(and(eq(add(res,b), a), or(lt(res,a), eq(res,a))), 1)\n      case 0 {\n        err := 1\n        res := 0\n      }\n    }\n  }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/consensys-Modular_Interactive_Crowdsale/ethereum-libraries-73abc22623e0841b8ea67a5089002f4867102672/CrowdsaleLib/IICOLib/truffle/contracts/InteractiveCrowdsaleLib.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No\nReason: The code uses inline assembly to handle mathematical operations with specific checks to prevent integer overflow and underflow. This indicates appropriate measures are taken to avoid such vulnerabilities."
    },
    {
        "code_segment": "library BasicMathLib {\n  \n  \n  \n  \n  \n  \n  function times(uint256 a, uint256 b) public pure returns (bool err,uint256 res) {\n    assembly{\n      res := mul(a,b)\n      switch or(iszero(b), eq(div(res,b), a))\n      case 0 {\n        err := 1\n        res := 0\n      }\n    }\n  }\n\n  \n  \n  \n  \n  \n  \n  function dividedBy(uint256 a, uint256 b) public pure returns (bool err,uint256 i) {\n    uint256 res;\n    assembly{\n      switch iszero(b)\n      case 0 {\n        res := div(a,b)\n        let loc := mload(0x40)\n        mstore(add(loc,0x20),res)\n        i := mload(add(loc,0x20))\n      }\n      default {\n        err := 1\n        i := 0\n      }\n    }\n  }\n\n  \n  \n  \n  \n  \n  \n  function plus(uint256 a, uint256 b) public pure returns (bool err, uint256 res) {\n    assembly{\n      res := add(a,b)\n      switch and(eq(sub(res,b), a), or(gt(res,b),eq(res,b)))\n      case 0 {\n        err := 1\n        res := 0\n      }\n    }\n  }\n\n  \n  \n  \n  \n  \n  \n  function minus(uint256 a, uint256 b) public pure returns (bool err,uint256 res) {\n    assembly{\n      res := sub(a,b)\n      switch eq(and(eq(add(res,b), a), or(lt(res,a), eq(res,a))), 1)\n      case 0 {\n        err := 1\n        res := 0\n      }\n    }\n  }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/consensys-Modular_Interactive_Crowdsale/ethereum-libraries-73abc22623e0841b8ea67a5089002f4867102672/CrowdsaleLib/IICOLib/truffle/contracts/InteractiveCrowdsaleLib.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No\nReason: The contract employs inline assembly to check arithmetic operations for overflow and underflow conditions adequately."
    },
    {
        "code_segment": "library BasicMathLib {\n  \n  \n  \n  \n  \n  \n  function times(uint256 a, uint256 b) public pure returns (bool err,uint256 res) {\n    assembly{\n      res := mul(a,b)\n      switch or(iszero(b), eq(div(res,b), a))\n      case 0 {\n        err := 1\n        res := 0\n      }\n    }\n  }\n\n  \n  \n  \n  \n  \n  \n  function dividedBy(uint256 a, uint256 b) public pure returns (bool err,uint256 i) {\n    uint256 res;\n    assembly{\n      switch iszero(b)\n      case 0 {\n        res := div(a,b)\n        let loc := mload(0x40)\n        mstore(add(loc,0x20),res)\n        i := mload(add(loc,0x20))\n      }\n      default {\n        err := 1\n        i := 0\n      }\n    }\n  }\n\n  \n  \n  \n  \n  \n  \n  function plus(uint256 a, uint256 b) public pure returns (bool err, uint256 res) {\n    assembly{\n      res := add(a,b)\n      switch and(eq(sub(res,b), a), or(gt(res,b),eq(res,b)))\n      case 0 {\n        err := 1\n        res := 0\n      }\n    }\n  }\n\n  \n  \n  \n  \n  \n  \n  function minus(uint256 a, uint256 b) public pure returns (bool err,uint256 res) {\n    assembly{\n      res := sub(a,b)\n      switch eq(and(eq(add(res,b), a), or(lt(res,a), eq(res,a))), 1)\n      case 0 {\n        err := 1\n        res := 0\n      }\n    }\n  }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/consensys-Modular_Interactive_Crowdsale/ethereum-libraries-73abc22623e0841b8ea67a5089002f4867102672/CrowdsaleLib/IICOLib/truffle/contracts/InteractiveCrowdsaleLib.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No\nReason: The assembly code includes checks that prevent failures related to overflows and divisions by zero."
    },
    {
        "code_segment": "contract NanoLoanEngine is ERC721, Engine, Ownable, TokenLockable {\n    uint256 public constant VERSION = 202;\n    string public constant VERSION_NAME = \"Basalt\";\n\n    uint256 private activeLoans = 0;\n    mapping(address => uint256) private lendersBalance;\n\n    function name() constant returns (string _name) {\n        _name = \"RCN - Nano loan engine - Basalt 202\";\n    }\n\n    function symbol() constant returns (string _symbol) {\n        _symbol = \"RCN-NLE-202\";\n    }\n\n    function totalSupply() constant returns (uint _totalSupply) {\n        _totalSupply = activeLoans;\n    }\n\n    function balanceOf(address _owner) constant returns (uint _balance) {\n        _balance = lendersBalance[_owner];\n    }\n\n    function tokenOfOwnerByIndex(address _owner, uint256 _index) constant returns (uint tokenId) {\n        uint256 tokenCount = balanceOf(_owner);\n\n        if (tokenCount == 0 || _index >= tokenCount) {\n            // Fail transaction\n            revert();\n        } else {\n            uint256 totalLoans = totalSupply();\n            uint256 resultIndex = 0;\n\n            uint256 loanId;\n            // SWC-128-DoS With Block Gas Limit: L46\n            for (loanId = 0; loanId <= totalLoans; loanId++) {\n                if (loans[loanId].lender == _owner && loans[loanId].status == Status.lent) {\n                    if (resultIndex == _index) {\n                        return loanId;\n                    }\n                    resultIndex++;\n                }\n            }\n\n            revert();\n        }\n    }\n\n    function tokensOfOwner(address _owner) external constant returns(uint256[] ownerTokens) {\n        uint256 tokenCount = balanceOf(_owner);\n\n        if (tokenCount == 0) {\n            // Return an empty array\n            return new uint256[](0);\n        } else {\n            uint256[] memory result = new uint256[](tokenCount);\n            uint256 totalLoans = totalSupply();\n            uint256 resultIndex = 0;\n\n            uint256 loanId;\n\n            for (loanId = 0; loanId <= totalLoans; loanId++) {\n                if (loans[loanId].lender == _owner && loans[loanId].status == Status.lent) {\n                    result[resultIndex] = loanId;\n                    resultIndex++;\n                }\n            }\n\n            return result;\n        }\n    }\n    \n    Token public rcn;\n    bool public deprecated;\n\n    event CreatedLoan(uint _index, address _borrower, address _creator);\n    event ApprovedBy(uint _index, address _address);\n    event Lent(uint _index, address _lender, address _cosigner);\n    event DestroyedBy(uint _index, address _address);\n    event PartialPayment(uint _index, address _sender, address _from, uint256 _amount);\n    event TotalPayment(uint _index);\n\n    function NanoLoanEngine(Token _rcn) public {\n        owner = msg.sender;\n        rcn = _rcn;\n    }\n\n    struct Loan {\n        Status status;\n        Oracle oracle;\n\n        address borrower;\n        address lender;\n        address creator;\n        address cosigner;\n        \n        uint256 amount;\n        uint256 interest;\n        uint256 punitoryInterest;\n        uint256 interestTimestamp;\n        uint256 paid;\n        uint256 interestRate;\n        uint256 interestRatePunitory;\n        uint256 dueTime;\n        uint256 duesIn;\n\n        bytes32 currency;\n        uint256 cancelableAt;\n        uint256 lenderBalance;\n\n        address approvedTransfer;\n        uint256 expirationRequest;\n\n        mapping(address => bool) approbations;\n    }\n\n    Loan[] private loans;\n\n    /**\n        @dev Creates a loan request, the loan can be generated with any borrower, cosigner, and conditions; if the \n        cosigner and borrower agree they must call the \"approve\" function.\n\n        The creator of the loan is the caller of this function; this is useful to track which wallet created the loan.\n\n        @param _oracleContract Address of the Oracle contract, if the loan does not use any oracle, this field should be 0x0.\n        @param _borrower Address of the borrower\n        @param _currency The currency to use with the oracle, the currency code is generated with the following formula,\n            keccak256(ticker,decimals).\n        @param _amount The requested amount; currency and unit are defined by the Oracle, if there is no Oracle present\n            the currency is RCN, and the unit is wei.\n        @param _interestRate The non-punitory interest rate by second, defined as a denominator of 10 000 000.\n        @param _interestRatePunitory The punitory interest rate by second, defined as a denominator of 10 000 000.\n            Ej: interestRate 11108571428571 = 28% Anual interest\n        @param _duesIn The time in seconds that the borrower has in order to pay the debt after the lender lends the money.\n        @param _cancelableAt Delta in seconds specifying how much interest should be added in advance, if the borrower pays \n        entirely or partially the loan before this term, no extra interest will be deducted.\n        @param _expirationRequest Timestamp of when the loan request expires, if the loan is not filled before this date, \n            the request is no longer valid.\n    */\n    function createLoan(Oracle _oracleContract, address _borrower, bytes32 _currency, uint256 _amount, uint256 _interestRate,\n        uint256 _interestRatePunitory, uint256 _duesIn, uint256 _cancelableAt, uint256 _expirationRequest) returns (uint256) {\n\n        require(!deprecated);\n        require(_cancelableAt <= _duesIn);\n        require(_oracleContract != address(0) || _currency == 0x0);\n        require(_borrower != address(0));\n        require(_amount != 0);\n        require(_interestRatePunitory != 0);\n        require(_interestRate != 0);\n        require(_expirationRequest > block.timestamp);\n\n        var loan = Loan(Status.initial, _oracleContract, _borrower, 0x0, msg.sender, 0x0, _amount, 0, 0, 0, 0, _interestRate,\n            _interestRatePunitory, 0, _duesIn, _currency, _cancelableAt, 0, 0x0, _expirationRequest);\n        uint index = loans.push(loan) - 1;\n        CreatedLoan(index, _borrower, msg.sender);\n\n        if (msg.sender == _borrower) {\n            approveLoan(index);\n        }\n\n        return index;\n    }\n    \n    function ownerOf(uint256 index) constant returns (address owner) { owner = loans[index].lender; }\n    function getTotalLoans() constant returns (uint256) { return loans.length; }\n    function getOracle(uint index) constant returns (Oracle) { return loans[index].oracle; }\n    function getBorrower(uint index) constant returns (address) { return loans[index].borrower; }\n    function getCosigner(uint index) constant returns (address) { return loans[index].cosigner; }\n    function getCreator(uint index) constant returns (address) { return loans[index].creator; }\n    function getAmount(uint index) constant returns (uint256) { return loans[index].amount; }\n    function getPunitoryInterest(uint index) constant returns (uint256) { return loans[index].punitoryInterest; }\n    function getInterestTimestamp(uint index) constant returns (uint256) { return loans[index].interestTimestamp; }\n    function getPaid(uint index) constant returns (uint256) { return loans[index].paid; }\n    function getInterestRate(uint index) constant returns (uint256) { return loans[index].interestRate; }\n    function getInterestRatePunitory(uint index) constant returns (uint256) { return loans[index].interestRatePunitory; }\n    function getDueTime(uint index) constant returns (uint256) { return loans[index].dueTime; }\n    function getDuesIn(uint index) constant returns (uint256) { return loans[index].duesIn; }\n    function getCancelableAt(uint index) constant returns (uint256) { return loans[index].cancelableAt; }\n    function getApprobation(uint index, address _address) constant returns (bool) { return loans[index].approbations[_address]; }\n    function getStatus(uint index) constant returns (Status) { return loans[index].status; }\n    function getLenderBalance(uint index) constant returns (uint256) { return loans[index].lenderBalance; }\n    function getApprovedTransfer(uint index) constant returns (address) {return loans[index].approvedTransfer; }\n    function getCurrency(uint index) constant returns (bytes32) { return loans[index].currency; }\n    function getExpirationRequest(uint index) constant returns (uint256) { return loans[index].expirationRequest; }\n    function getInterest(uint index) constant returns (uint256) { return loans[index].interest; }\n\n    /**\n        @param index Index of the loan\n\n        @return true if the loan has been approved by the borrower and cosigner.\n    */\n    function isApproved(uint index) constant returns (bool) {\n        Loan storage loan = loans[index];\n        return loan.approbations[loan.borrower];\n    }\n\n    /**\n        @dev Called by the members of the loan to show that they agree with the terms of the loan; the borrower\n        must call this method before any lender could call the method \"lend\".\n            \n        Any address can call this method to be added to the \"approbations\" mapping.\n\n        @param index Index of the loan\n\n        @return true if the approve was done successfully\n    */\n    function approveLoan(uint index) public returns(bool) {\n        Loan storage loan = loans[index];\n        require(loan.status == Status.initial);\n        loan.approbations[msg.sender] = true;\n        ApprovedBy(index, msg.sender);\n        return true;\n    }\n\n    /**\n        @dev Performs the lend of the RCN equivalent to the requested amount, and transforms the msg.sender in the new lender.\n\n        The loan must be previously approved by the borrower; before calling this function, the lender candidate must \n        call the \"approve\" function on the RCN Token, specifying an amount sufficient enough to pay the equivalent of\n        the requested amount, and the cosigner fee.\n        \n        @param index Index of the loan\n        @param oracleData Data required by the oracle to return the rate, the content of this field must be provided\n            by the url exposed in the url() method of the oracle.\n        @param cosigner Address of the cosigner, 0x0 for lending without cosigner.\n        @param cosignerData Data required by the cosigner to process the request.\n\n        @return true if the lend was done successfully\n    */\n    function lend(uint index, bytes oracleData, Cosigner cosigner, bytes cosignerData) public returns (bool) {\n        Loan storage loan = loans[index];\n\n        require(loan.status == Status.initial);\n        require(isApproved(index));\n        require(block.timestamp <= loan.expirationRequest);\n\n        loan.lender = msg.sender;\n        loan.dueTime = safeAdd(block.timestamp, loan.duesIn);\n        loan.interestTimestamp = block.timestamp;\n        loan.status = Status.lent;\n        \n        if (loan.cancelableAt > 0)\n            internalAddInterest(loan, safeAdd(block.timestamp, loan.cancelableAt));\n\n        uint256 rate = getRate(loan, oracleData);\n\n        if (cosigner != address(0)) {\n            // The cosigner it's temporary set to the next address (cosigner + 2), it's expected that the cosigner will\n            // call the method \"cosign\" to accept the conditions; that method also sets the cosigner to the right\n            // address. If that does not happen, the transaction fails.\n            loan.cosigner = address(uint256(cosigner) + 2);\n            require(cosigner.requestCosign(this, index, cosignerData, oracleData));\n            require(loan.cosigner == address(cosigner));\n        }\n        \n        require(rcn.transferFrom(msg.sender, loan.borrower, safeMult(loan.amount, rate)));\n        \n        // ERC721, create new loan and transfer it to the lender\n        Transfer(0x0, loan.lender, index);\n        activeLoans += 1;\n        lendersBalance[loan.lender] += 1;\n        Lent(index, loan.lender, cosigner);\n\n        return true;\n    }\n\n    /**\n        @dev The cosigner must call this method to accept the conditions of a loan, this method pays the cosigner his fee\n\n        @param index Index of the loan\n        @param cost Fee set by the cosigner\n\n        @return true If the cosign was successfull\n    */\n    function cosign(uint index, uint256 cost) external returns (bool) {\n        Loan storage loan = loans[index];\n        require(loan.status == Status.lent && (loan.dueTime - loan.duesIn) == block.timestamp);\n        require(loan.cosigner != address(0));\n        require(loan.cosigner == address(uint256(msg.sender) + 2));\n        loan.cosigner = msg.sender;\n        require(rcn.transferFrom(loan.lender, msg.sender, cost));\n        return true;\n    }\n\n    /**\n        @dev Destroys a loan, the borrower could call this method if they performed an accidental or regretted \n        \"approve\" of the loan, this method only works for them if the loan is in \"pending\" status.\n\n        The lender can call this method at any moment, in case of a loan with status \"lent\" the lender is pardoning \n        the debt. \n\n        @param index Index of the loan\n\n        @return true if the destroy was done successfully\n    */\n    function destroy(uint index) public returns (bool) {\n        Loan storage loan = loans[index];\n        require(loan.status != Status.destroyed);\n        require(msg.sender == loan.lender || (msg.sender == loan.borrower && loan.status == Status.initial));\n        DestroyedBy(index, msg.sender);\n\n        // ERC721, remove loan from circulation\n        if (loan.status != Status.initial) {\n            lendersBalance[loan.lender] -= 1;\n            activeLoans -= 1;\n            Transfer(loan.lender, 0x0, index);\n        }\n\n        loan.status = Status.destroyed;\n        return true;\n    }\n\n    /**\n        @dev Transfers a loan to a different lender, the caller must be the current lender or previously being\n        approved with the method \"approveTransfer\"; only loans with the Status.lent status can be transfered.\n\n        @param index Index of the loan\n        @param to New lender\n\n        @return true if the transfer was done successfully\n    */\n    function transfer(address to, uint256 index) public returns (bool) {\n        Loan storage loan = loans[index];\n        \n        require(loan.status != Status.destroyed && loan.status != Status.paid);\n        require(msg.sender == loan.lender || msg.sender == loan.approvedTransfer);\n        require(to != address(0));\n        loan.lender = to;\n        loan.approvedTransfer = address(0);\n\n        // ERC721, transfer loan to another address\n        lendersBalance[msg.sender] -= 1;\n        lendersBalance[to] += 1;\n        Transfer(loan.lender, to, index);\n\n        return true;\n    }\n\n    /**\n        @dev ERC721 method, transfers the loan to the msg.sender, the msg.sender must be approved using the \n        \"approve\" method.\n\n        @return true if the transfer was successfull\n    */\n    function takeOwnership(uint256 _index) public returns (bool) {\n        return transfer(msg.sender, _index);\n    }\n\n    /**\n        @dev Approves the transfer of a given loan in the name of the lender, the behavior of this function is similar to\n        \"approve\" in the ERC20 standard, but only one approved address is allowed at a time.\n\n        The same method can be called passing 0x0 as parameter \"to\" to erase a previously approved address.\n\n        @param to Address allowed to transfer the loan or 0x0 to delete\n        @param index Index of the loan\n\n        @return true if the approve was done successfully\n    */\n    function approve(address to, uint256 index) public returns (bool) {\n        Loan storage loan = loans[index];\n        require(msg.sender == loan.lender);\n        loan.approvedTransfer = to;\n        Approval(msg.sender, to, index);\n        return true;\n    }\n\n    /**\n        @dev Returns the pending amount to complete de payment of the loan, keep in mind that this number increases \n        every second.\n\n        @param index Index of the loan\n\n        @return Aprox pending payment amount\n    */\n    function getPendingAmount(uint index) public constant returns (uint256) {\n        Loan storage loan = loans[index];\n        addInterest(index);\n        return getRawPendingAmount(loan);\n    }\n\n    function getRawPendingAmount(Loan loan) internal returns (uint256) {\n        return safeSubtract(safeAdd(safeAdd(loan.amount, loan.interest), loan.punitoryInterest), loan.paid);\n    }\n\n    /**\n        @dev Calculates the interest of a given amount, interest rate and delta time.\n\n        @param timeDelta Elapsed time\n        @param interestRate Interest rate expressed as the denominator of 10 000 000.\n        @param amount Amount to apply interest\n\n        @return realDelta The real timeDelta applied\n        @return interest The interest gained in the realDelta time\n    */\n    function calculateInterest(uint256 timeDelta, uint256 interestRate, uint256 amount) public constant returns (uint256 realDelta, uint256 interest) {\n        if (amount == 0) {\n            interest = 0;\n            realDelta = timeDelta;\n        } else {\n            interest = safeMult(safeMult(100000, amount), timeDelta) / interestRate;\n            realDelta = safeMult(interest, interestRate) / (amount * 100000);\n        }\n    }\n\n    /**\n        @dev Computes loan interest\n\n        Computes the punitory and non-punitory interest of a given loan and only applies the change.\n        \n        @param loan Loan to compute interest\n        @param timestamp Target absolute unix time to calculate interest.\n    */\n    function internalAddInterest(Loan storage loan, uint256 timestamp) internal {\n        if (timestamp > loan.interestTimestamp) {\n            uint256 newInterest = loan.interest;\n            uint256 newPunitoryInterest = loan.punitoryInterest;\n\n            uint256 newTimestamp;\n            uint256 realDelta;\n            uint256 calculatedInterest;\n\n            uint256 deltaTime;\n            uint256 pending;\n\n            uint256 endNonPunitory = min(timestamp, loan.dueTime);\n            if (endNonPunitory > loan.interestTimestamp) {\n                deltaTime = endNonPunitory - loan.interestTimestamp;\n\n                if (loan.paid < loan.amount) {\n                    pending = loan.amount - loan.paid;\n                } else {\n                    pending = 0;\n                }\n\n                (realDelta, calculatedInterest) = calculateInterest(deltaTime, loan.interestRate, pending);\n                newInterest = safeAdd(calculatedInterest, newInterest);\n                newTimestamp = loan.interestTimestamp + realDelta;\n            }\n\n            if (timestamp > loan.dueTime) {\n                uint256 startPunitory = max(loan.dueTime, loan.interestTimestamp);\n                deltaTime = timestamp - startPunitory;\n\n                uint256 debt = safeAdd(loan.amount, newInterest);\n                pending = min(debt, safeSubtract(safeAdd(debt, newPunitoryInterest), loan.paid));\n\n                (realDelta, calculatedInterest) = calculateInterest(deltaTime, loan.interestRatePunitory, pending);\n                newPunitoryInterest = safeAdd(newPunitoryInterest, calculatedInterest);\n                newTimestamp = startPunitory + realDelta;\n            }\n            \n            if (newInterest != loan.interest || newPunitoryInterest != loan.punitoryInterest) {\n                loan.interestTimestamp = newTimestamp;\n                loan.interest = newInterest;\n                loan.punitoryInterest = newPunitoryInterest;\n            }\n        }\n    }\n\n    /**\n        @dev Computes loan interest only up to current unix time\n\n        @param timestamp Target absolute unix time to calculate interest.\n    */\n    function addInterestUpTo(Loan storage loan, uint256 timestamp) internal {\n        require(loan.status == Status.lent);\n        if (timestamp <= block.timestamp) {\n            internalAddInterest(loan, timestamp);\n        }\n    }\n\n    /**\n        @dev Updates the loan accumulated interests up to the current Unix time.\n        \n        @param index Index of the loan\n    */\n    function addInterest(uint index) public {\n        Loan storage loan = loans[index];\n        addInterestUpTo(loan, block.timestamp);\n    }\n    \n    /**\n        @dev Pay loan\n\n        Realizes a payment of a given Loan, before performing the payment the accumulated\n        interest is computed and added to the total pending amount.\n\n        Before calling this function, the msg.sender must call the \"approve\" function on the RCN Token, specifying an amount\n        sufficient enough to pay the equivalent of the desired payment and the oracle fee.\n\n        Because it is difficult or even impossible to know in advance how much RCN are going to be spent on the\n        transaction*, we recommend performing the \"approve\" using an amount 5% superior to the wallet estimated\n        spending. If the RCN spent results to be less, the extra tokens are never debited from the msg.sender.\n\n        * The RCN rate can fluctuate on the same block, and it is impossible to know in advance the exact time of the\n        confirmation of the transaction. \n\n        If the paid pending amount equals zero, the loan changes status to \"paid\" and it is considered closed.\n\n        @param index Index of the loan\n        @param _amount Amount to pay, specified in the loan currency; or in RCN if the loan has no oracle\n        @param _from The identity of the payer\n        @param oracleData Data required by the oracle to return the rate, the content of this field must be provided\n            by the url exposed in the url() method of the oracle.\n            \n        @return true if the payment was executed successfully\n    */\n    function pay(uint index, uint256 _amount, address _from, bytes oracleData) public returns (bool) {\n        Loan storage loan = loans[index];\n\n        require(loan.status == Status.lent);\n        addInterest(index);\n        uint256 toPay = min(getPendingAmount(index), _amount);\n        PartialPayment(index, msg.sender, _from, toPay);\n\n        loan.paid = safeAdd(loan.paid, toPay);\n\n        if (getRawPendingAmount(loan) == 0) {\n            TotalPayment(index);\n            loan.status = Status.paid;\n\n            // ERC721, remove loan from circulation\n            lendersBalance[loan.lender] -= 1;\n            activeLoans -= 1;\n            Transfer(loan.lender, 0x0, index);\n        }\n\n        uint256 rate = getRate(loan, oracleData);\n        uint256 transferValue = safeMult(toPay, rate);\n        lockTokens(rcn, transferValue);\n        require(rcn.transferFrom(msg.sender, this, transferValue));\n        loan.lenderBalance = safeAdd(transferValue, loan.lenderBalance);\n\n        return true;\n    }\n\n    /**\n        @dev Retrieves the rate corresponding of the loan oracle, if the loan has no oracle the rate is 1\n\n        @param loan The loan with the cosigner\n        @param data Data required by the oracle\n\n        @return The rate of the oracle\n    */\n    function getRate(Loan loan, bytes data) internal returns (uint256) {\n        if (loan.oracle == address(0)) {\n            return 1;\n        } else {\n            return loan.oracle.getRate(loan.currency, data);\n        }\n    }\n\n    /**\n        @dev Withdraw lender funds\n\n        When a loan is paid, the funds are not transferred automatically to the lender, the funds are stored on the\n        engine contract, and the lender must call this function specifying the amount desired to transfer and the \n        destination.\n\n        This behavior is defined to allow the temporary transfer of the loan to a smart contract, without worrying that\n        the contract will receive tokens that are not traceable; and it allows the development of decentralized \n        autonomous organizations.\n\n        @param index Index of the loan\n        @param to Destination of the wiwthdraw funds\n        @param amount Amount to withdraw, in RCN\n\n        @return true if the withdraw was executed successfully\n    */\n    function withdrawal(uint index, address to, uint256 amount) public returns (bool) {\n        Loan storage loan = loans[index];\n        require(msg.sender == loan.lender);\n        loan.lenderBalance = safeSubtract(loan.lenderBalance, amount);\n        require(rcn.transfer(to, amount));\n        unlockTokens(rcn, amount);\n        return true;\n    }\n\n    function withdrawalRange(uint256 fromIndex, uint256 toIndex, address to) public returns (uint256) {\n        uint256 loanId;\n        uint256 totalWithdraw = 0;\n\n        for (loanId = fromIndex; loanId <= toIndex; loanId++) {\n            Loan storage loan = loans[loanId];\n            if (loan.lender == msg.sender) {\n                totalWithdraw += loan.lenderBalance;\n                loan.lenderBalance = 0;\n            }\n        }\n\n        require(rcn.transfer(to, totalWithdraw));\n        unlockTokens(rcn, totalWithdraw);\n        \n        return totalWithdraw;\n    }\n\n    function withdrawalList(uint256[] memory loanIds, address to) public returns (uint256) {\n        uint256 inputId;\n        uint256 totalWithdraw = 0;\n\n        for (inputId = 0; inputId < loanIds.length; inputId++) {\n            Loan storage loan = loans[loanIds[inputId]];\n            if (loan.lender == msg.sender) {\n                totalWithdraw += loan.lenderBalance;\n                loan.lenderBalance = 0;\n            }\n        }\n\n        require(rcn.transfer(to, totalWithdraw));\n        unlockTokens(rcn, totalWithdraw);\n\n        return totalWithdraw;\n    }\n\n    /**\n        @dev Deprecates the engine, locks the creation of new loans.\n    */\n    function setDeprecated(bool _deprecated) public onlyOwner {\n        deprecated = _deprecated;\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinfabrik-RCN Network Smart Contract Audit/rcn-network-3ded36151ad55543d16c354e70161852de4061d0/contracts/NanoLoanEngine.sol",
        "vulnerability": "Assertion Failure",
        "check": "FP",
        "response": "Answer: No\nReason: No assert statements present that would cause an \"Assertion Failure\"."
    },
    {
        "code_segment": "contract NanoLoanEngine is ERC721, Engine, Ownable, TokenLockable {\n    uint256 public constant VERSION = 202;\n    string public constant VERSION_NAME = \"Basalt\";\n\n    uint256 private activeLoans = 0;\n    mapping(address => uint256) private lendersBalance;\n\n    function name() constant returns (string _name) {\n        _name = \"RCN - Nano loan engine - Basalt 202\";\n    }\n\n    function symbol() constant returns (string _symbol) {\n        _symbol = \"RCN-NLE-202\";\n    }\n\n    function totalSupply() constant returns (uint _totalSupply) {\n        _totalSupply = activeLoans;\n    }\n\n    function balanceOf(address _owner) constant returns (uint _balance) {\n        _balance = lendersBalance[_owner];\n    }\n\n    function tokenOfOwnerByIndex(address _owner, uint256 _index) constant returns (uint tokenId) {\n        uint256 tokenCount = balanceOf(_owner);\n\n        if (tokenCount == 0 || _index >= tokenCount) {\n            // Fail transaction\n            revert();\n        } else {\n            uint256 totalLoans = totalSupply();\n            uint256 resultIndex = 0;\n\n            uint256 loanId;\n            // SWC-128-DoS With Block Gas Limit: L46\n            for (loanId = 0; loanId <= totalLoans; loanId++) {\n                if (loans[loanId].lender == _owner && loans[loanId].status == Status.lent) {\n                    if (resultIndex == _index) {\n                        return loanId;\n                    }\n                    resultIndex++;\n                }\n            }\n\n            revert();\n        }\n    }\n\n    function tokensOfOwner(address _owner) external constant returns(uint256[] ownerTokens) {\n        uint256 tokenCount = balanceOf(_owner);\n\n        if (tokenCount == 0) {\n            // Return an empty array\n            return new uint256[](0);\n        } else {\n            uint256[] memory result = new uint256[](tokenCount);\n            uint256 totalLoans = totalSupply();\n            uint256 resultIndex = 0;\n\n            uint256 loanId;\n\n            for (loanId = 0; loanId <= totalLoans; loanId++) {\n                if (loans[loanId].lender == _owner && loans[loanId].status == Status.lent) {\n                    result[resultIndex] = loanId;\n                    resultIndex++;\n                }\n            }\n\n            return result;\n        }\n    }\n    \n    Token public rcn;\n    bool public deprecated;\n\n    event CreatedLoan(uint _index, address _borrower, address _creator);\n    event ApprovedBy(uint _index, address _address);\n    event Lent(uint _index, address _lender, address _cosigner);\n    event DestroyedBy(uint _index, address _address);\n    event PartialPayment(uint _index, address _sender, address _from, uint256 _amount);\n    event TotalPayment(uint _index);\n\n    function NanoLoanEngine(Token _rcn) public {\n        owner = msg.sender;\n        rcn = _rcn;\n    }\n\n    struct Loan {\n        Status status;\n        Oracle oracle;\n\n        address borrower;\n        address lender;\n        address creator;\n        address cosigner;\n        \n        uint256 amount;\n        uint256 interest;\n        uint256 punitoryInterest;\n        uint256 interestTimestamp;\n        uint256 paid;\n        uint256 interestRate;\n        uint256 interestRatePunitory;\n        uint256 dueTime;\n        uint256 duesIn;\n\n        bytes32 currency;\n        uint256 cancelableAt;\n        uint256 lenderBalance;\n\n        address approvedTransfer;\n        uint256 expirationRequest;\n\n        mapping(address => bool) approbations;\n    }\n\n    Loan[] private loans;\n\n    /**\n        @dev Creates a loan request, the loan can be generated with any borrower, cosigner, and conditions; if the \n        cosigner and borrower agree they must call the \"approve\" function.\n\n        The creator of the loan is the caller of this function; this is useful to track which wallet created the loan.\n\n        @param _oracleContract Address of the Oracle contract, if the loan does not use any oracle, this field should be 0x0.\n        @param _borrower Address of the borrower\n        @param _currency The currency to use with the oracle, the currency code is generated with the following formula,\n            keccak256(ticker,decimals).\n        @param _amount The requested amount; currency and unit are defined by the Oracle, if there is no Oracle present\n            the currency is RCN, and the unit is wei.\n        @param _interestRate The non-punitory interest rate by second, defined as a denominator of 10 000 000.\n        @param _interestRatePunitory The punitory interest rate by second, defined as a denominator of 10 000 000.\n            Ej: interestRate 11108571428571 = 28% Anual interest\n        @param _duesIn The time in seconds that the borrower has in order to pay the debt after the lender lends the money.\n        @param _cancelableAt Delta in seconds specifying how much interest should be added in advance, if the borrower pays \n        entirely or partially the loan before this term, no extra interest will be deducted.\n        @param _expirationRequest Timestamp of when the loan request expires, if the loan is not filled before this date, \n            the request is no longer valid.\n    */\n    function createLoan(Oracle _oracleContract, address _borrower, bytes32 _currency, uint256 _amount, uint256 _interestRate,\n        uint256 _interestRatePunitory, uint256 _duesIn, uint256 _cancelableAt, uint256 _expirationRequest) returns (uint256) {\n\n        require(!deprecated);\n        require(_cancelableAt <= _duesIn);\n        require(_oracleContract != address(0) || _currency == 0x0);\n        require(_borrower != address(0));\n        require(_amount != 0);\n        require(_interestRatePunitory != 0);\n        require(_interestRate != 0);\n        require(_expirationRequest > block.timestamp);\n\n        var loan = Loan(Status.initial, _oracleContract, _borrower, 0x0, msg.sender, 0x0, _amount, 0, 0, 0, 0, _interestRate,\n            _interestRatePunitory, 0, _duesIn, _currency, _cancelableAt, 0, 0x0, _expirationRequest);\n        uint index = loans.push(loan) - 1;\n        CreatedLoan(index, _borrower, msg.sender);\n\n        if (msg.sender == _borrower) {\n            approveLoan(index);\n        }\n\n        return index;\n    }\n    \n    function ownerOf(uint256 index) constant returns (address owner) { owner = loans[index].lender; }\n    function getTotalLoans() constant returns (uint256) { return loans.length; }\n    function getOracle(uint index) constant returns (Oracle) { return loans[index].oracle; }\n    function getBorrower(uint index) constant returns (address) { return loans[index].borrower; }\n    function getCosigner(uint index) constant returns (address) { return loans[index].cosigner; }\n    function getCreator(uint index) constant returns (address) { return loans[index].creator; }\n    function getAmount(uint index) constant returns (uint256) { return loans[index].amount; }\n    function getPunitoryInterest(uint index) constant returns (uint256) { return loans[index].punitoryInterest; }\n    function getInterestTimestamp(uint index) constant returns (uint256) { return loans[index].interestTimestamp; }\n    function getPaid(uint index) constant returns (uint256) { return loans[index].paid; }\n    function getInterestRate(uint index) constant returns (uint256) { return loans[index].interestRate; }\n    function getInterestRatePunitory(uint index) constant returns (uint256) { return loans[index].interestRatePunitory; }\n    function getDueTime(uint index) constant returns (uint256) { return loans[index].dueTime; }\n    function getDuesIn(uint index) constant returns (uint256) { return loans[index].duesIn; }\n    function getCancelableAt(uint index) constant returns (uint256) { return loans[index].cancelableAt; }\n    function getApprobation(uint index, address _address) constant returns (bool) { return loans[index].approbations[_address]; }\n    function getStatus(uint index) constant returns (Status) { return loans[index].status; }\n    function getLenderBalance(uint index) constant returns (uint256) { return loans[index].lenderBalance; }\n    function getApprovedTransfer(uint index) constant returns (address) {return loans[index].approvedTransfer; }\n    function getCurrency(uint index) constant returns (bytes32) { return loans[index].currency; }\n    function getExpirationRequest(uint index) constant returns (uint256) { return loans[index].expirationRequest; }\n    function getInterest(uint index) constant returns (uint256) { return loans[index].interest; }\n\n    /**\n        @param index Index of the loan\n\n        @return true if the loan has been approved by the borrower and cosigner.\n    */\n    function isApproved(uint index) constant returns (bool) {\n        Loan storage loan = loans[index];\n        return loan.approbations[loan.borrower];\n    }\n\n    /**\n        @dev Called by the members of the loan to show that they agree with the terms of the loan; the borrower\n        must call this method before any lender could call the method \"lend\".\n            \n        Any address can call this method to be added to the \"approbations\" mapping.\n\n        @param index Index of the loan\n\n        @return true if the approve was done successfully\n    */\n    function approveLoan(uint index) public returns(bool) {\n        Loan storage loan = loans[index];\n        require(loan.status == Status.initial);\n        loan.approbations[msg.sender] = true;\n        ApprovedBy(index, msg.sender);\n        return true;\n    }\n\n    /**\n        @dev Performs the lend of the RCN equivalent to the requested amount, and transforms the msg.sender in the new lender.\n\n        The loan must be previously approved by the borrower; before calling this function, the lender candidate must \n        call the \"approve\" function on the RCN Token, specifying an amount sufficient enough to pay the equivalent of\n        the requested amount, and the cosigner fee.\n        \n        @param index Index of the loan\n        @param oracleData Data required by the oracle to return the rate, the content of this field must be provided\n            by the url exposed in the url() method of the oracle.\n        @param cosigner Address of the cosigner, 0x0 for lending without cosigner.\n        @param cosignerData Data required by the cosigner to process the request.\n\n        @return true if the lend was done successfully\n    */\n    function lend(uint index, bytes oracleData, Cosigner cosigner, bytes cosignerData) public returns (bool) {\n        Loan storage loan = loans[index];\n\n        require(loan.status == Status.initial);\n        require(isApproved(index));\n        require(block.timestamp <= loan.expirationRequest);\n\n        loan.lender = msg.sender;\n        loan.dueTime = safeAdd(block.timestamp, loan.duesIn);\n        loan.interestTimestamp = block.timestamp;\n        loan.status = Status.lent;\n        \n        if (loan.cancelableAt > 0)\n            internalAddInterest(loan, safeAdd(block.timestamp, loan.cancelableAt));\n\n        uint256 rate = getRate(loan, oracleData);\n\n        if (cosigner != address(0)) {\n            // The cosigner it's temporary set to the next address (cosigner + 2), it's expected that the cosigner will\n            // call the method \"cosign\" to accept the conditions; that method also sets the cosigner to the right\n            // address. If that does not happen, the transaction fails.\n            loan.cosigner = address(uint256(cosigner) + 2);\n            require(cosigner.requestCosign(this, index, cosignerData, oracleData));\n            require(loan.cosigner == address(cosigner));\n        }\n        \n        require(rcn.transferFrom(msg.sender, loan.borrower, safeMult(loan.amount, rate)));\n        \n        // ERC721, create new loan and transfer it to the lender\n        Transfer(0x0, loan.lender, index);\n        activeLoans += 1;\n        lendersBalance[loan.lender] += 1;\n        Lent(index, loan.lender, cosigner);\n\n        return true;\n    }\n\n    /**\n        @dev The cosigner must call this method to accept the conditions of a loan, this method pays the cosigner his fee\n\n        @param index Index of the loan\n        @param cost Fee set by the cosigner\n\n        @return true If the cosign was successfull\n    */\n    function cosign(uint index, uint256 cost) external returns (bool) {\n        Loan storage loan = loans[index];\n        require(loan.status == Status.lent && (loan.dueTime - loan.duesIn) == block.timestamp);\n        require(loan.cosigner != address(0));\n        require(loan.cosigner == address(uint256(msg.sender) + 2));\n        loan.cosigner = msg.sender;\n        require(rcn.transferFrom(loan.lender, msg.sender, cost));\n        return true;\n    }\n\n    /**\n        @dev Destroys a loan, the borrower could call this method if they performed an accidental or regretted \n        \"approve\" of the loan, this method only works for them if the loan is in \"pending\" status.\n\n        The lender can call this method at any moment, in case of a loan with status \"lent\" the lender is pardoning \n        the debt. \n\n        @param index Index of the loan\n\n        @return true if the destroy was done successfully\n    */\n    function destroy(uint index) public returns (bool) {\n        Loan storage loan = loans[index];\n        require(loan.status != Status.destroyed);\n        require(msg.sender == loan.lender || (msg.sender == loan.borrower && loan.status == Status.initial));\n        DestroyedBy(index, msg.sender);\n\n        // ERC721, remove loan from circulation\n        if (loan.status != Status.initial) {\n            lendersBalance[loan.lender] -= 1;\n            activeLoans -= 1;\n            Transfer(loan.lender, 0x0, index);\n        }\n\n        loan.status = Status.destroyed;\n        return true;\n    }\n\n    /**\n        @dev Transfers a loan to a different lender, the caller must be the current lender or previously being\n        approved with the method \"approveTransfer\"; only loans with the Status.lent status can be transfered.\n\n        @param index Index of the loan\n        @param to New lender\n\n        @return true if the transfer was done successfully\n    */\n    function transfer(address to, uint256 index) public returns (bool) {\n        Loan storage loan = loans[index];\n        \n        require(loan.status != Status.destroyed && loan.status != Status.paid);\n        require(msg.sender == loan.lender || msg.sender == loan.approvedTransfer);\n        require(to != address(0));\n        loan.lender = to;\n        loan.approvedTransfer = address(0);\n\n        // ERC721, transfer loan to another address\n        lendersBalance[msg.sender] -= 1;\n        lendersBalance[to] += 1;\n        Transfer(loan.lender, to, index);\n\n        return true;\n    }\n\n    /**\n        @dev ERC721 method, transfers the loan to the msg.sender, the msg.sender must be approved using the \n        \"approve\" method.\n\n        @return true if the transfer was successfull\n    */\n    function takeOwnership(uint256 _index) public returns (bool) {\n        return transfer(msg.sender, _index);\n    }\n\n    /**\n        @dev Approves the transfer of a given loan in the name of the lender, the behavior of this function is similar to\n        \"approve\" in the ERC20 standard, but only one approved address is allowed at a time.\n\n        The same method can be called passing 0x0 as parameter \"to\" to erase a previously approved address.\n\n        @param to Address allowed to transfer the loan or 0x0 to delete\n        @param index Index of the loan\n\n        @return true if the approve was done successfully\n    */\n    function approve(address to, uint256 index) public returns (bool) {\n        Loan storage loan = loans[index];\n        require(msg.sender == loan.lender);\n        loan.approvedTransfer = to;\n        Approval(msg.sender, to, index);\n        return true;\n    }\n\n    /**\n        @dev Returns the pending amount to complete de payment of the loan, keep in mind that this number increases \n        every second.\n\n        @param index Index of the loan\n\n        @return Aprox pending payment amount\n    */\n    function getPendingAmount(uint index) public constant returns (uint256) {\n        Loan storage loan = loans[index];\n        addInterest(index);\n        return getRawPendingAmount(loan);\n    }\n\n    function getRawPendingAmount(Loan loan) internal returns (uint256) {\n        return safeSubtract(safeAdd(safeAdd(loan.amount, loan.interest), loan.punitoryInterest), loan.paid);\n    }\n\n    /**\n        @dev Calculates the interest of a given amount, interest rate and delta time.\n\n        @param timeDelta Elapsed time\n        @param interestRate Interest rate expressed as the denominator of 10 000 000.\n        @param amount Amount to apply interest\n\n        @return realDelta The real timeDelta applied\n        @return interest The interest gained in the realDelta time\n    */\n    function calculateInterest(uint256 timeDelta, uint256 interestRate, uint256 amount) public constant returns (uint256 realDelta, uint256 interest) {\n        if (amount == 0) {\n            interest = 0;\n            realDelta = timeDelta;\n        } else {\n            interest = safeMult(safeMult(100000, amount), timeDelta) / interestRate;\n            realDelta = safeMult(interest, interestRate) / (amount * 100000);\n        }\n    }\n\n    /**\n        @dev Computes loan interest\n\n        Computes the punitory and non-punitory interest of a given loan and only applies the change.\n        \n        @param loan Loan to compute interest\n        @param timestamp Target absolute unix time to calculate interest.\n    */\n    function internalAddInterest(Loan storage loan, uint256 timestamp) internal {\n        if (timestamp > loan.interestTimestamp) {\n            uint256 newInterest = loan.interest;\n            uint256 newPunitoryInterest = loan.punitoryInterest;\n\n            uint256 newTimestamp;\n            uint256 realDelta;\n            uint256 calculatedInterest;\n\n            uint256 deltaTime;\n            uint256 pending;\n\n            uint256 endNonPunitory = min(timestamp, loan.dueTime);\n            if (endNonPunitory > loan.interestTimestamp) {\n                deltaTime = endNonPunitory - loan.interestTimestamp;\n\n                if (loan.paid < loan.amount) {\n                    pending = loan.amount - loan.paid;\n                } else {\n                    pending = 0;\n                }\n\n                (realDelta, calculatedInterest) = calculateInterest(deltaTime, loan.interestRate, pending);\n                newInterest = safeAdd(calculatedInterest, newInterest);\n                newTimestamp = loan.interestTimestamp + realDelta;\n            }\n\n            if (timestamp > loan.dueTime) {\n                uint256 startPunitory = max(loan.dueTime, loan.interestTimestamp);\n                deltaTime = timestamp - startPunitory;\n\n                uint256 debt = safeAdd(loan.amount, newInterest);\n                pending = min(debt, safeSubtract(safeAdd(debt, newPunitoryInterest), loan.paid));\n\n                (realDelta, calculatedInterest) = calculateInterest(deltaTime, loan.interestRatePunitory, pending);\n                newPunitoryInterest = safeAdd(newPunitoryInterest, calculatedInterest);\n                newTimestamp = startPunitory + realDelta;\n            }\n            \n            if (newInterest != loan.interest || newPunitoryInterest != loan.punitoryInterest) {\n                loan.interestTimestamp = newTimestamp;\n                loan.interest = newInterest;\n                loan.punitoryInterest = newPunitoryInterest;\n            }\n        }\n    }\n\n    /**\n        @dev Computes loan interest only up to current unix time\n\n        @param timestamp Target absolute unix time to calculate interest.\n    */\n    function addInterestUpTo(Loan storage loan, uint256 timestamp) internal {\n        require(loan.status == Status.lent);\n        if (timestamp <= block.timestamp) {\n            internalAddInterest(loan, timestamp);\n        }\n    }\n\n    /**\n        @dev Updates the loan accumulated interests up to the current Unix time.\n        \n        @param index Index of the loan\n    */\n    function addInterest(uint index) public {\n        Loan storage loan = loans[index];\n        addInterestUpTo(loan, block.timestamp);\n    }\n    \n    /**\n        @dev Pay loan\n\n        Realizes a payment of a given Loan, before performing the payment the accumulated\n        interest is computed and added to the total pending amount.\n\n        Before calling this function, the msg.sender must call the \"approve\" function on the RCN Token, specifying an amount\n        sufficient enough to pay the equivalent of the desired payment and the oracle fee.\n\n        Because it is difficult or even impossible to know in advance how much RCN are going to be spent on the\n        transaction*, we recommend performing the \"approve\" using an amount 5% superior to the wallet estimated\n        spending. If the RCN spent results to be less, the extra tokens are never debited from the msg.sender.\n\n        * The RCN rate can fluctuate on the same block, and it is impossible to know in advance the exact time of the\n        confirmation of the transaction. \n\n        If the paid pending amount equals zero, the loan changes status to \"paid\" and it is considered closed.\n\n        @param index Index of the loan\n        @param _amount Amount to pay, specified in the loan currency; or in RCN if the loan has no oracle\n        @param _from The identity of the payer\n        @param oracleData Data required by the oracle to return the rate, the content of this field must be provided\n            by the url exposed in the url() method of the oracle.\n            \n        @return true if the payment was executed successfully\n    */\n    function pay(uint index, uint256 _amount, address _from, bytes oracleData) public returns (bool) {\n        Loan storage loan = loans[index];\n\n        require(loan.status == Status.lent);\n        addInterest(index);\n        uint256 toPay = min(getPendingAmount(index), _amount);\n        PartialPayment(index, msg.sender, _from, toPay);\n\n        loan.paid = safeAdd(loan.paid, toPay);\n\n        if (getRawPendingAmount(loan) == 0) {\n            TotalPayment(index);\n            loan.status = Status.paid;\n\n            // ERC721, remove loan from circulation\n            lendersBalance[loan.lender] -= 1;\n            activeLoans -= 1;\n            Transfer(loan.lender, 0x0, index);\n        }\n\n        uint256 rate = getRate(loan, oracleData);\n        uint256 transferValue = safeMult(toPay, rate);\n        lockTokens(rcn, transferValue);\n        require(rcn.transferFrom(msg.sender, this, transferValue));\n        loan.lenderBalance = safeAdd(transferValue, loan.lenderBalance);\n\n        return true;\n    }\n\n    /**\n        @dev Retrieves the rate corresponding of the loan oracle, if the loan has no oracle the rate is 1\n\n        @param loan The loan with the cosigner\n        @param data Data required by the oracle\n\n        @return The rate of the oracle\n    */\n    function getRate(Loan loan, bytes data) internal returns (uint256) {\n        if (loan.oracle == address(0)) {\n            return 1;\n        } else {\n            return loan.oracle.getRate(loan.currency, data);\n        }\n    }\n\n    /**\n        @dev Withdraw lender funds\n\n        When a loan is paid, the funds are not transferred automatically to the lender, the funds are stored on the\n        engine contract, and the lender must call this function specifying the amount desired to transfer and the \n        destination.\n\n        This behavior is defined to allow the temporary transfer of the loan to a smart contract, without worrying that\n        the contract will receive tokens that are not traceable; and it allows the development of decentralized \n        autonomous organizations.\n\n        @param index Index of the loan\n        @param to Destination of the wiwthdraw funds\n        @param amount Amount to withdraw, in RCN\n\n        @return true if the withdraw was executed successfully\n    */\n    function withdrawal(uint index, address to, uint256 amount) public returns (bool) {\n        Loan storage loan = loans[index];\n        require(msg.sender == loan.lender);\n        loan.lenderBalance = safeSubtract(loan.lenderBalance, amount);\n        require(rcn.transfer(to, amount));\n        unlockTokens(rcn, amount);\n        return true;\n    }\n\n    function withdrawalRange(uint256 fromIndex, uint256 toIndex, address to) public returns (uint256) {\n        uint256 loanId;\n        uint256 totalWithdraw = 0;\n\n        for (loanId = fromIndex; loanId <= toIndex; loanId++) {\n            Loan storage loan = loans[loanId];\n            if (loan.lender == msg.sender) {\n                totalWithdraw += loan.lenderBalance;\n                loan.lenderBalance = 0;\n            }\n        }\n\n        require(rcn.transfer(to, totalWithdraw));\n        unlockTokens(rcn, totalWithdraw);\n        \n        return totalWithdraw;\n    }\n\n    function withdrawalList(uint256[] memory loanIds, address to) public returns (uint256) {\n        uint256 inputId;\n        uint256 totalWithdraw = 0;\n\n        for (inputId = 0; inputId < loanIds.length; inputId++) {\n            Loan storage loan = loans[loanIds[inputId]];\n            if (loan.lender == msg.sender) {\n                totalWithdraw += loan.lenderBalance;\n                loan.lenderBalance = 0;\n            }\n        }\n\n        require(rcn.transfer(to, totalWithdraw));\n        unlockTokens(rcn, totalWithdraw);\n\n        return totalWithdraw;\n    }\n\n    /**\n        @dev Deprecates the engine, locks the creation of new loans.\n    */\n    function setDeprecated(bool _deprecated) public onlyOwner {\n        deprecated = _deprecated;\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinfabrik-RCN Network Smart Contract Audit/rcn-network-3ded36151ad55543d16c354e70161852de4061d0/contracts/NanoLoanEngine.sol",
        "vulnerability": "Assertion Failure",
        "check": "FP",
        "response": "Answer: Yes\nDescription: The `assert` function is not used in the code, but the extensive use of `require` and manual error handling could lead to more subtle logical issues causing unexpected reverts."
    },
    {
        "code_segment": "contract NanoLoanEngine is ERC721, Engine, Ownable, TokenLockable {\n    uint256 public constant VERSION = 202;\n    string public constant VERSION_NAME = \"Basalt\";\n\n    uint256 private activeLoans = 0;\n    mapping(address => uint256) private lendersBalance;\n\n    function name() constant returns (string _name) {\n        _name = \"RCN - Nano loan engine - Basalt 202\";\n    }\n\n    function symbol() constant returns (string _symbol) {\n        _symbol = \"RCN-NLE-202\";\n    }\n\n    function totalSupply() constant returns (uint _totalSupply) {\n        _totalSupply = activeLoans;\n    }\n\n    function balanceOf(address _owner) constant returns (uint _balance) {\n        _balance = lendersBalance[_owner];\n    }\n\n    function tokenOfOwnerByIndex(address _owner, uint256 _index) constant returns (uint tokenId) {\n        uint256 tokenCount = balanceOf(_owner);\n\n        if (tokenCount == 0 || _index >= tokenCount) {\n            // Fail transaction\n            revert();\n        } else {\n            uint256 totalLoans = totalSupply();\n            uint256 resultIndex = 0;\n\n            uint256 loanId;\n            // SWC-128-DoS With Block Gas Limit: L46\n            for (loanId = 0; loanId <= totalLoans; loanId++) {\n                if (loans[loanId].lender == _owner && loans[loanId].status == Status.lent) {\n                    if (resultIndex == _index) {\n                        return loanId;\n                    }\n                    resultIndex++;\n                }\n            }\n\n            revert();\n        }\n    }\n\n    function tokensOfOwner(address _owner) external constant returns(uint256[] ownerTokens) {\n        uint256 tokenCount = balanceOf(_owner);\n\n        if (tokenCount == 0) {\n            // Return an empty array\n            return new uint256[](0);\n        } else {\n            uint256[] memory result = new uint256[](tokenCount);\n            uint256 totalLoans = totalSupply();\n            uint256 resultIndex = 0;\n\n            uint256 loanId;\n\n            for (loanId = 0; loanId <= totalLoans; loanId++) {\n                if (loans[loanId].lender == _owner && loans[loanId].status == Status.lent) {\n                    result[resultIndex] = loanId;\n                    resultIndex++;\n                }\n            }\n\n            return result;\n        }\n    }\n    \n    Token public rcn;\n    bool public deprecated;\n\n    event CreatedLoan(uint _index, address _borrower, address _creator);\n    event ApprovedBy(uint _index, address _address);\n    event Lent(uint _index, address _lender, address _cosigner);\n    event DestroyedBy(uint _index, address _address);\n    event PartialPayment(uint _index, address _sender, address _from, uint256 _amount);\n    event TotalPayment(uint _index);\n\n    function NanoLoanEngine(Token _rcn) public {\n        owner = msg.sender;\n        rcn = _rcn;\n    }\n\n    struct Loan {\n        Status status;\n        Oracle oracle;\n\n        address borrower;\n        address lender;\n        address creator;\n        address cosigner;\n        \n        uint256 amount;\n        uint256 interest;\n        uint256 punitoryInterest;\n        uint256 interestTimestamp;\n        uint256 paid;\n        uint256 interestRate;\n        uint256 interestRatePunitory;\n        uint256 dueTime;\n        uint256 duesIn;\n\n        bytes32 currency;\n        uint256 cancelableAt;\n        uint256 lenderBalance;\n\n        address approvedTransfer;\n        uint256 expirationRequest;\n\n        mapping(address => bool) approbations;\n    }\n\n    Loan[] private loans;\n\n    /**\n        @dev Creates a loan request, the loan can be generated with any borrower, cosigner, and conditions; if the \n        cosigner and borrower agree they must call the \"approve\" function.\n\n        The creator of the loan is the caller of this function; this is useful to track which wallet created the loan.\n\n        @param _oracleContract Address of the Oracle contract, if the loan does not use any oracle, this field should be 0x0.\n        @param _borrower Address of the borrower\n        @param _currency The currency to use with the oracle, the currency code is generated with the following formula,\n            keccak256(ticker,decimals).\n        @param _amount The requested amount; currency and unit are defined by the Oracle, if there is no Oracle present\n            the currency is RCN, and the unit is wei.\n        @param _interestRate The non-punitory interest rate by second, defined as a denominator of 10 000 000.\n        @param _interestRatePunitory The punitory interest rate by second, defined as a denominator of 10 000 000.\n            Ej: interestRate 11108571428571 = 28% Anual interest\n        @param _duesIn The time in seconds that the borrower has in order to pay the debt after the lender lends the money.\n        @param _cancelableAt Delta in seconds specifying how much interest should be added in advance, if the borrower pays \n        entirely or partially the loan before this term, no extra interest will be deducted.\n        @param _expirationRequest Timestamp of when the loan request expires, if the loan is not filled before this date, \n            the request is no longer valid.\n    */\n    function createLoan(Oracle _oracleContract, address _borrower, bytes32 _currency, uint256 _amount, uint256 _interestRate,\n        uint256 _interestRatePunitory, uint256 _duesIn, uint256 _cancelableAt, uint256 _expirationRequest) returns (uint256) {\n\n        require(!deprecated);\n        require(_cancelableAt <= _duesIn);\n        require(_oracleContract != address(0) || _currency == 0x0);\n        require(_borrower != address(0));\n        require(_amount != 0);\n        require(_interestRatePunitory != 0);\n        require(_interestRate != 0);\n        require(_expirationRequest > block.timestamp);\n\n        var loan = Loan(Status.initial, _oracleContract, _borrower, 0x0, msg.sender, 0x0, _amount, 0, 0, 0, 0, _interestRate,\n            _interestRatePunitory, 0, _duesIn, _currency, _cancelableAt, 0, 0x0, _expirationRequest);\n        uint index = loans.push(loan) - 1;\n        CreatedLoan(index, _borrower, msg.sender);\n\n        if (msg.sender == _borrower) {\n            approveLoan(index);\n        }\n\n        return index;\n    }\n    \n    function ownerOf(uint256 index) constant returns (address owner) { owner = loans[index].lender; }\n    function getTotalLoans() constant returns (uint256) { return loans.length; }\n    function getOracle(uint index) constant returns (Oracle) { return loans[index].oracle; }\n    function getBorrower(uint index) constant returns (address) { return loans[index].borrower; }\n    function getCosigner(uint index) constant returns (address) { return loans[index].cosigner; }\n    function getCreator(uint index) constant returns (address) { return loans[index].creator; }\n    function getAmount(uint index) constant returns (uint256) { return loans[index].amount; }\n    function getPunitoryInterest(uint index) constant returns (uint256) { return loans[index].punitoryInterest; }\n    function getInterestTimestamp(uint index) constant returns (uint256) { return loans[index].interestTimestamp; }\n    function getPaid(uint index) constant returns (uint256) { return loans[index].paid; }\n    function getInterestRate(uint index) constant returns (uint256) { return loans[index].interestRate; }\n    function getInterestRatePunitory(uint index) constant returns (uint256) { return loans[index].interestRatePunitory; }\n    function getDueTime(uint index) constant returns (uint256) { return loans[index].dueTime; }\n    function getDuesIn(uint index) constant returns (uint256) { return loans[index].duesIn; }\n    function getCancelableAt(uint index) constant returns (uint256) { return loans[index].cancelableAt; }\n    function getApprobation(uint index, address _address) constant returns (bool) { return loans[index].approbations[_address]; }\n    function getStatus(uint index) constant returns (Status) { return loans[index].status; }\n    function getLenderBalance(uint index) constant returns (uint256) { return loans[index].lenderBalance; }\n    function getApprovedTransfer(uint index) constant returns (address) {return loans[index].approvedTransfer; }\n    function getCurrency(uint index) constant returns (bytes32) { return loans[index].currency; }\n    function getExpirationRequest(uint index) constant returns (uint256) { return loans[index].expirationRequest; }\n    function getInterest(uint index) constant returns (uint256) { return loans[index].interest; }\n\n    /**\n        @param index Index of the loan\n\n        @return true if the loan has been approved by the borrower and cosigner.\n    */\n    function isApproved(uint index) constant returns (bool) {\n        Loan storage loan = loans[index];\n        return loan.approbations[loan.borrower];\n    }\n\n    /**\n        @dev Called by the members of the loan to show that they agree with the terms of the loan; the borrower\n        must call this method before any lender could call the method \"lend\".\n            \n        Any address can call this method to be added to the \"approbations\" mapping.\n\n        @param index Index of the loan\n\n        @return true if the approve was done successfully\n    */\n    function approveLoan(uint index) public returns(bool) {\n        Loan storage loan = loans[index];\n        require(loan.status == Status.initial);\n        loan.approbations[msg.sender] = true;\n        ApprovedBy(index, msg.sender);\n        return true;\n    }\n\n    /**\n        @dev Performs the lend of the RCN equivalent to the requested amount, and transforms the msg.sender in the new lender.\n\n        The loan must be previously approved by the borrower; before calling this function, the lender candidate must \n        call the \"approve\" function on the RCN Token, specifying an amount sufficient enough to pay the equivalent of\n        the requested amount, and the cosigner fee.\n        \n        @param index Index of the loan\n        @param oracleData Data required by the oracle to return the rate, the content of this field must be provided\n            by the url exposed in the url() method of the oracle.\n        @param cosigner Address of the cosigner, 0x0 for lending without cosigner.\n        @param cosignerData Data required by the cosigner to process the request.\n\n        @return true if the lend was done successfully\n    */\n    function lend(uint index, bytes oracleData, Cosigner cosigner, bytes cosignerData) public returns (bool) {\n        Loan storage loan = loans[index];\n\n        require(loan.status == Status.initial);\n        require(isApproved(index));\n        require(block.timestamp <= loan.expirationRequest);\n\n        loan.lender = msg.sender;\n        loan.dueTime = safeAdd(block.timestamp, loan.duesIn);\n        loan.interestTimestamp = block.timestamp;\n        loan.status = Status.lent;\n        \n        if (loan.cancelableAt > 0)\n            internalAddInterest(loan, safeAdd(block.timestamp, loan.cancelableAt));\n\n        uint256 rate = getRate(loan, oracleData);\n\n        if (cosigner != address(0)) {\n            // The cosigner it's temporary set to the next address (cosigner + 2), it's expected that the cosigner will\n            // call the method \"cosign\" to accept the conditions; that method also sets the cosigner to the right\n            // address. If that does not happen, the transaction fails.\n            loan.cosigner = address(uint256(cosigner) + 2);\n            require(cosigner.requestCosign(this, index, cosignerData, oracleData));\n            require(loan.cosigner == address(cosigner));\n        }\n        \n        require(rcn.transferFrom(msg.sender, loan.borrower, safeMult(loan.amount, rate)));\n        \n        // ERC721, create new loan and transfer it to the lender\n        Transfer(0x0, loan.lender, index);\n        activeLoans += 1;\n        lendersBalance[loan.lender] += 1;\n        Lent(index, loan.lender, cosigner);\n\n        return true;\n    }\n\n    /**\n        @dev The cosigner must call this method to accept the conditions of a loan, this method pays the cosigner his fee\n\n        @param index Index of the loan\n        @param cost Fee set by the cosigner\n\n        @return true If the cosign was successfull\n    */\n    function cosign(uint index, uint256 cost) external returns (bool) {\n        Loan storage loan = loans[index];\n        require(loan.status == Status.lent && (loan.dueTime - loan.duesIn) == block.timestamp);\n        require(loan.cosigner != address(0));\n        require(loan.cosigner == address(uint256(msg.sender) + 2));\n        loan.cosigner = msg.sender;\n        require(rcn.transferFrom(loan.lender, msg.sender, cost));\n        return true;\n    }\n\n    /**\n        @dev Destroys a loan, the borrower could call this method if they performed an accidental or regretted \n        \"approve\" of the loan, this method only works for them if the loan is in \"pending\" status.\n\n        The lender can call this method at any moment, in case of a loan with status \"lent\" the lender is pardoning \n        the debt. \n\n        @param index Index of the loan\n\n        @return true if the destroy was done successfully\n    */\n    function destroy(uint index) public returns (bool) {\n        Loan storage loan = loans[index];\n        require(loan.status != Status.destroyed);\n        require(msg.sender == loan.lender || (msg.sender == loan.borrower && loan.status == Status.initial));\n        DestroyedBy(index, msg.sender);\n\n        // ERC721, remove loan from circulation\n        if (loan.status != Status.initial) {\n            lendersBalance[loan.lender] -= 1;\n            activeLoans -= 1;\n            Transfer(loan.lender, 0x0, index);\n        }\n\n        loan.status = Status.destroyed;\n        return true;\n    }\n\n    /**\n        @dev Transfers a loan to a different lender, the caller must be the current lender or previously being\n        approved with the method \"approveTransfer\"; only loans with the Status.lent status can be transfered.\n\n        @param index Index of the loan\n        @param to New lender\n\n        @return true if the transfer was done successfully\n    */\n    function transfer(address to, uint256 index) public returns (bool) {\n        Loan storage loan = loans[index];\n        \n        require(loan.status != Status.destroyed && loan.status != Status.paid);\n        require(msg.sender == loan.lender || msg.sender == loan.approvedTransfer);\n        require(to != address(0));\n        loan.lender = to;\n        loan.approvedTransfer = address(0);\n\n        // ERC721, transfer loan to another address\n        lendersBalance[msg.sender] -= 1;\n        lendersBalance[to] += 1;\n        Transfer(loan.lender, to, index);\n\n        return true;\n    }\n\n    /**\n        @dev ERC721 method, transfers the loan to the msg.sender, the msg.sender must be approved using the \n        \"approve\" method.\n\n        @return true if the transfer was successfull\n    */\n    function takeOwnership(uint256 _index) public returns (bool) {\n        return transfer(msg.sender, _index);\n    }\n\n    /**\n        @dev Approves the transfer of a given loan in the name of the lender, the behavior of this function is similar to\n        \"approve\" in the ERC20 standard, but only one approved address is allowed at a time.\n\n        The same method can be called passing 0x0 as parameter \"to\" to erase a previously approved address.\n\n        @param to Address allowed to transfer the loan or 0x0 to delete\n        @param index Index of the loan\n\n        @return true if the approve was done successfully\n    */\n    function approve(address to, uint256 index) public returns (bool) {\n        Loan storage loan = loans[index];\n        require(msg.sender == loan.lender);\n        loan.approvedTransfer = to;\n        Approval(msg.sender, to, index);\n        return true;\n    }\n\n    /**\n        @dev Returns the pending amount to complete de payment of the loan, keep in mind that this number increases \n        every second.\n\n        @param index Index of the loan\n\n        @return Aprox pending payment amount\n    */\n    function getPendingAmount(uint index) public constant returns (uint256) {\n        Loan storage loan = loans[index];\n        addInterest(index);\n        return getRawPendingAmount(loan);\n    }\n\n    function getRawPendingAmount(Loan loan) internal returns (uint256) {\n        return safeSubtract(safeAdd(safeAdd(loan.amount, loan.interest), loan.punitoryInterest), loan.paid);\n    }\n\n    /**\n        @dev Calculates the interest of a given amount, interest rate and delta time.\n\n        @param timeDelta Elapsed time\n        @param interestRate Interest rate expressed as the denominator of 10 000 000.\n        @param amount Amount to apply interest\n\n        @return realDelta The real timeDelta applied\n        @return interest The interest gained in the realDelta time\n    */\n    function calculateInterest(uint256 timeDelta, uint256 interestRate, uint256 amount) public constant returns (uint256 realDelta, uint256 interest) {\n        if (amount == 0) {\n            interest = 0;\n            realDelta = timeDelta;\n        } else {\n            interest = safeMult(safeMult(100000, amount), timeDelta) / interestRate;\n            realDelta = safeMult(interest, interestRate) / (amount * 100000);\n        }\n    }\n\n    /**\n        @dev Computes loan interest\n\n        Computes the punitory and non-punitory interest of a given loan and only applies the change.\n        \n        @param loan Loan to compute interest\n        @param timestamp Target absolute unix time to calculate interest.\n    */\n    function internalAddInterest(Loan storage loan, uint256 timestamp) internal {\n        if (timestamp > loan.interestTimestamp) {\n            uint256 newInterest = loan.interest;\n            uint256 newPunitoryInterest = loan.punitoryInterest;\n\n            uint256 newTimestamp;\n            uint256 realDelta;\n            uint256 calculatedInterest;\n\n            uint256 deltaTime;\n            uint256 pending;\n\n            uint256 endNonPunitory = min(timestamp, loan.dueTime);\n            if (endNonPunitory > loan.interestTimestamp) {\n                deltaTime = endNonPunitory - loan.interestTimestamp;\n\n                if (loan.paid < loan.amount) {\n                    pending = loan.amount - loan.paid;\n                } else {\n                    pending = 0;\n                }\n\n                (realDelta, calculatedInterest) = calculateInterest(deltaTime, loan.interestRate, pending);\n                newInterest = safeAdd(calculatedInterest, newInterest);\n                newTimestamp = loan.interestTimestamp + realDelta;\n            }\n\n            if (timestamp > loan.dueTime) {\n                uint256 startPunitory = max(loan.dueTime, loan.interestTimestamp);\n                deltaTime = timestamp - startPunitory;\n\n                uint256 debt = safeAdd(loan.amount, newInterest);\n                pending = min(debt, safeSubtract(safeAdd(debt, newPunitoryInterest), loan.paid));\n\n                (realDelta, calculatedInterest) = calculateInterest(deltaTime, loan.interestRatePunitory, pending);\n                newPunitoryInterest = safeAdd(newPunitoryInterest, calculatedInterest);\n                newTimestamp = startPunitory + realDelta;\n            }\n            \n            if (newInterest != loan.interest || newPunitoryInterest != loan.punitoryInterest) {\n                loan.interestTimestamp = newTimestamp;\n                loan.interest = newInterest;\n                loan.punitoryInterest = newPunitoryInterest;\n            }\n        }\n    }\n\n    /**\n        @dev Computes loan interest only up to current unix time\n\n        @param timestamp Target absolute unix time to calculate interest.\n    */\n    function addInterestUpTo(Loan storage loan, uint256 timestamp) internal {\n        require(loan.status == Status.lent);\n        if (timestamp <= block.timestamp) {\n            internalAddInterest(loan, timestamp);\n        }\n    }\n\n    /**\n        @dev Updates the loan accumulated interests up to the current Unix time.\n        \n        @param index Index of the loan\n    */\n    function addInterest(uint index) public {\n        Loan storage loan = loans[index];\n        addInterestUpTo(loan, block.timestamp);\n    }\n    \n    /**\n        @dev Pay loan\n\n        Realizes a payment of a given Loan, before performing the payment the accumulated\n        interest is computed and added to the total pending amount.\n\n        Before calling this function, the msg.sender must call the \"approve\" function on the RCN Token, specifying an amount\n        sufficient enough to pay the equivalent of the desired payment and the oracle fee.\n\n        Because it is difficult or even impossible to know in advance how much RCN are going to be spent on the\n        transaction*, we recommend performing the \"approve\" using an amount 5% superior to the wallet estimated\n        spending. If the RCN spent results to be less, the extra tokens are never debited from the msg.sender.\n\n        * The RCN rate can fluctuate on the same block, and it is impossible to know in advance the exact time of the\n        confirmation of the transaction. \n\n        If the paid pending amount equals zero, the loan changes status to \"paid\" and it is considered closed.\n\n        @param index Index of the loan\n        @param _amount Amount to pay, specified in the loan currency; or in RCN if the loan has no oracle\n        @param _from The identity of the payer\n        @param oracleData Data required by the oracle to return the rate, the content of this field must be provided\n            by the url exposed in the url() method of the oracle.\n            \n        @return true if the payment was executed successfully\n    */\n    function pay(uint index, uint256 _amount, address _from, bytes oracleData) public returns (bool) {\n        Loan storage loan = loans[index];\n\n        require(loan.status == Status.lent);\n        addInterest(index);\n        uint256 toPay = min(getPendingAmount(index), _amount);\n        PartialPayment(index, msg.sender, _from, toPay);\n\n        loan.paid = safeAdd(loan.paid, toPay);\n\n        if (getRawPendingAmount(loan) == 0) {\n            TotalPayment(index);\n            loan.status = Status.paid;\n\n            // ERC721, remove loan from circulation\n            lendersBalance[loan.lender] -= 1;\n            activeLoans -= 1;\n            Transfer(loan.lender, 0x0, index);\n        }\n\n        uint256 rate = getRate(loan, oracleData);\n        uint256 transferValue = safeMult(toPay, rate);\n        lockTokens(rcn, transferValue);\n        require(rcn.transferFrom(msg.sender, this, transferValue));\n        loan.lenderBalance = safeAdd(transferValue, loan.lenderBalance);\n\n        return true;\n    }\n\n    /**\n        @dev Retrieves the rate corresponding of the loan oracle, if the loan has no oracle the rate is 1\n\n        @param loan The loan with the cosigner\n        @param data Data required by the oracle\n\n        @return The rate of the oracle\n    */\n    function getRate(Loan loan, bytes data) internal returns (uint256) {\n        if (loan.oracle == address(0)) {\n            return 1;\n        } else {\n            return loan.oracle.getRate(loan.currency, data);\n        }\n    }\n\n    /**\n        @dev Withdraw lender funds\n\n        When a loan is paid, the funds are not transferred automatically to the lender, the funds are stored on the\n        engine contract, and the lender must call this function specifying the amount desired to transfer and the \n        destination.\n\n        This behavior is defined to allow the temporary transfer of the loan to a smart contract, without worrying that\n        the contract will receive tokens that are not traceable; and it allows the development of decentralized \n        autonomous organizations.\n\n        @param index Index of the loan\n        @param to Destination of the wiwthdraw funds\n        @param amount Amount to withdraw, in RCN\n\n        @return true if the withdraw was executed successfully\n    */\n    function withdrawal(uint index, address to, uint256 amount) public returns (bool) {\n        Loan storage loan = loans[index];\n        require(msg.sender == loan.lender);\n        loan.lenderBalance = safeSubtract(loan.lenderBalance, amount);\n        require(rcn.transfer(to, amount));\n        unlockTokens(rcn, amount);\n        return true;\n    }\n\n    function withdrawalRange(uint256 fromIndex, uint256 toIndex, address to) public returns (uint256) {\n        uint256 loanId;\n        uint256 totalWithdraw = 0;\n\n        for (loanId = fromIndex; loanId <= toIndex; loanId++) {\n            Loan storage loan = loans[loanId];\n            if (loan.lender == msg.sender) {\n                totalWithdraw += loan.lenderBalance;\n                loan.lenderBalance = 0;\n            }\n        }\n\n        require(rcn.transfer(to, totalWithdraw));\n        unlockTokens(rcn, totalWithdraw);\n        \n        return totalWithdraw;\n    }\n\n    function withdrawalList(uint256[] memory loanIds, address to) public returns (uint256) {\n        uint256 inputId;\n        uint256 totalWithdraw = 0;\n\n        for (inputId = 0; inputId < loanIds.length; inputId++) {\n            Loan storage loan = loans[loanIds[inputId]];\n            if (loan.lender == msg.sender) {\n                totalWithdraw += loan.lenderBalance;\n                loan.lenderBalance = 0;\n            }\n        }\n\n        require(rcn.transfer(to, totalWithdraw));\n        unlockTokens(rcn, totalWithdraw);\n\n        return totalWithdraw;\n    }\n\n    /**\n        @dev Deprecates the engine, locks the creation of new loans.\n    */\n    function setDeprecated(bool _deprecated) public onlyOwner {\n        deprecated = _deprecated;\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinfabrik-RCN Network Smart Contract Audit/rcn-network-3ded36151ad55543d16c354e70161852de4061d0/contracts/NanoLoanEngine.sol",
        "vulnerability": "Assertion Failure",
        "check": "FP",
        "response": "Answer: No\nReason: The code does not use Solidity's `assert` statement that could lead to assertion failures. Instead, it uses `require` and `revert` to ensure conditions are met, which mitigates the risk of assertion failures."
    },
    {
        "code_segment": "contract NanoLoanEngine is ERC721, Engine, Ownable, TokenLockable {\n    uint256 public constant VERSION = 202;\n    string public constant VERSION_NAME = \"Basalt\";\n\n    uint256 private activeLoans = 0;\n    mapping(address => uint256) private lendersBalance;\n\n    function name() constant returns (string _name) {\n        _name = \"RCN - Nano loan engine - Basalt 202\";\n    }\n\n    function symbol() constant returns (string _symbol) {\n        _symbol = \"RCN-NLE-202\";\n    }\n\n    function totalSupply() constant returns (uint _totalSupply) {\n        _totalSupply = activeLoans;\n    }\n\n    function balanceOf(address _owner) constant returns (uint _balance) {\n        _balance = lendersBalance[_owner];\n    }\n\n    function tokenOfOwnerByIndex(address _owner, uint256 _index) constant returns (uint tokenId) {\n        uint256 tokenCount = balanceOf(_owner);\n\n        if (tokenCount == 0 || _index >= tokenCount) {\n            // Fail transaction\n            revert();\n        } else {\n            uint256 totalLoans = totalSupply();\n            uint256 resultIndex = 0;\n\n            uint256 loanId;\n            // SWC-128-DoS With Block Gas Limit: L46\n            for (loanId = 0; loanId <= totalLoans; loanId++) {\n                if (loans[loanId].lender == _owner && loans[loanId].status == Status.lent) {\n                    if (resultIndex == _index) {\n                        return loanId;\n                    }\n                    resultIndex++;\n                }\n            }\n\n            revert();\n        }\n    }\n\n    function tokensOfOwner(address _owner) external constant returns(uint256[] ownerTokens) {\n        uint256 tokenCount = balanceOf(_owner);\n\n        if (tokenCount == 0) {\n            // Return an empty array\n            return new uint256[](0);\n        } else {\n            uint256[] memory result = new uint256[](tokenCount);\n            uint256 totalLoans = totalSupply();\n            uint256 resultIndex = 0;\n\n            uint256 loanId;\n\n            for (loanId = 0; loanId <= totalLoans; loanId++) {\n                if (loans[loanId].lender == _owner && loans[loanId].status == Status.lent) {\n                    result[resultIndex] = loanId;\n                    resultIndex++;\n                }\n            }\n\n            return result;\n        }\n    }\n    \n    Token public rcn;\n    bool public deprecated;\n\n    event CreatedLoan(uint _index, address _borrower, address _creator);\n    event ApprovedBy(uint _index, address _address);\n    event Lent(uint _index, address _lender, address _cosigner);\n    event DestroyedBy(uint _index, address _address);\n    event PartialPayment(uint _index, address _sender, address _from, uint256 _amount);\n    event TotalPayment(uint _index);\n\n    function NanoLoanEngine(Token _rcn) public {\n        owner = msg.sender;\n        rcn = _rcn;\n    }\n\n    struct Loan {\n        Status status;\n        Oracle oracle;\n\n        address borrower;\n        address lender;\n        address creator;\n        address cosigner;\n        \n        uint256 amount;\n        uint256 interest;\n        uint256 punitoryInterest;\n        uint256 interestTimestamp;\n        uint256 paid;\n        uint256 interestRate;\n        uint256 interestRatePunitory;\n        uint256 dueTime;\n        uint256 duesIn;\n\n        bytes32 currency;\n        uint256 cancelableAt;\n        uint256 lenderBalance;\n\n        address approvedTransfer;\n        uint256 expirationRequest;\n\n        mapping(address => bool) approbations;\n    }\n\n    Loan[] private loans;\n\n    /**\n        @dev Creates a loan request, the loan can be generated with any borrower, cosigner, and conditions; if the \n        cosigner and borrower agree they must call the \"approve\" function.\n\n        The creator of the loan is the caller of this function; this is useful to track which wallet created the loan.\n\n        @param _oracleContract Address of the Oracle contract, if the loan does not use any oracle, this field should be 0x0.\n        @param _borrower Address of the borrower\n        @param _currency The currency to use with the oracle, the currency code is generated with the following formula,\n            keccak256(ticker,decimals).\n        @param _amount The requested amount; currency and unit are defined by the Oracle, if there is no Oracle present\n            the currency is RCN, and the unit is wei.\n        @param _interestRate The non-punitory interest rate by second, defined as a denominator of 10 000 000.\n        @param _interestRatePunitory The punitory interest rate by second, defined as a denominator of 10 000 000.\n            Ej: interestRate 11108571428571 = 28% Anual interest\n        @param _duesIn The time in seconds that the borrower has in order to pay the debt after the lender lends the money.\n        @param _cancelableAt Delta in seconds specifying how much interest should be added in advance, if the borrower pays \n        entirely or partially the loan before this term, no extra interest will be deducted.\n        @param _expirationRequest Timestamp of when the loan request expires, if the loan is not filled before this date, \n            the request is no longer valid.\n    */\n    function createLoan(Oracle _oracleContract, address _borrower, bytes32 _currency, uint256 _amount, uint256 _interestRate,\n        uint256 _interestRatePunitory, uint256 _duesIn, uint256 _cancelableAt, uint256 _expirationRequest) returns (uint256) {\n\n        require(!deprecated);\n        require(_cancelableAt <= _duesIn);\n        require(_oracleContract != address(0) || _currency == 0x0);\n        require(_borrower != address(0));\n        require(_amount != 0);\n        require(_interestRatePunitory != 0);\n        require(_interestRate != 0);\n        require(_expirationRequest > block.timestamp);\n\n        var loan = Loan(Status.initial, _oracleContract, _borrower, 0x0, msg.sender, 0x0, _amount, 0, 0, 0, 0, _interestRate,\n            _interestRatePunitory, 0, _duesIn, _currency, _cancelableAt, 0, 0x0, _expirationRequest);\n        uint index = loans.push(loan) - 1;\n        CreatedLoan(index, _borrower, msg.sender);\n\n        if (msg.sender == _borrower) {\n            approveLoan(index);\n        }\n\n        return index;\n    }\n    \n    function ownerOf(uint256 index) constant returns (address owner) { owner = loans[index].lender; }\n    function getTotalLoans() constant returns (uint256) { return loans.length; }\n    function getOracle(uint index) constant returns (Oracle) { return loans[index].oracle; }\n    function getBorrower(uint index) constant returns (address) { return loans[index].borrower; }\n    function getCosigner(uint index) constant returns (address) { return loans[index].cosigner; }\n    function getCreator(uint index) constant returns (address) { return loans[index].creator; }\n    function getAmount(uint index) constant returns (uint256) { return loans[index].amount; }\n    function getPunitoryInterest(uint index) constant returns (uint256) { return loans[index].punitoryInterest; }\n    function getInterestTimestamp(uint index) constant returns (uint256) { return loans[index].interestTimestamp; }\n    function getPaid(uint index) constant returns (uint256) { return loans[index].paid; }\n    function getInterestRate(uint index) constant returns (uint256) { return loans[index].interestRate; }\n    function getInterestRatePunitory(uint index) constant returns (uint256) { return loans[index].interestRatePunitory; }\n    function getDueTime(uint index) constant returns (uint256) { return loans[index].dueTime; }\n    function getDuesIn(uint index) constant returns (uint256) { return loans[index].duesIn; }\n    function getCancelableAt(uint index) constant returns (uint256) { return loans[index].cancelableAt; }\n    function getApprobation(uint index, address _address) constant returns (bool) { return loans[index].approbations[_address]; }\n    function getStatus(uint index) constant returns (Status) { return loans[index].status; }\n    function getLenderBalance(uint index) constant returns (uint256) { return loans[index].lenderBalance; }\n    function getApprovedTransfer(uint index) constant returns (address) {return loans[index].approvedTransfer; }\n    function getCurrency(uint index) constant returns (bytes32) { return loans[index].currency; }\n    function getExpirationRequest(uint index) constant returns (uint256) { return loans[index].expirationRequest; }\n    function getInterest(uint index) constant returns (uint256) { return loans[index].interest; }\n\n    /**\n        @param index Index of the loan\n\n        @return true if the loan has been approved by the borrower and cosigner.\n    */\n    function isApproved(uint index) constant returns (bool) {\n        Loan storage loan = loans[index];\n        return loan.approbations[loan.borrower];\n    }\n\n    /**\n        @dev Called by the members of the loan to show that they agree with the terms of the loan; the borrower\n        must call this method before any lender could call the method \"lend\".\n            \n        Any address can call this method to be added to the \"approbations\" mapping.\n\n        @param index Index of the loan\n\n        @return true if the approve was done successfully\n    */\n    function approveLoan(uint index) public returns(bool) {\n        Loan storage loan = loans[index];\n        require(loan.status == Status.initial);\n        loan.approbations[msg.sender] = true;\n        ApprovedBy(index, msg.sender);\n        return true;\n    }\n\n    /**\n        @dev Performs the lend of the RCN equivalent to the requested amount, and transforms the msg.sender in the new lender.\n\n        The loan must be previously approved by the borrower; before calling this function, the lender candidate must \n        call the \"approve\" function on the RCN Token, specifying an amount sufficient enough to pay the equivalent of\n        the requested amount, and the cosigner fee.\n        \n        @param index Index of the loan\n        @param oracleData Data required by the oracle to return the rate, the content of this field must be provided\n            by the url exposed in the url() method of the oracle.\n        @param cosigner Address of the cosigner, 0x0 for lending without cosigner.\n        @param cosignerData Data required by the cosigner to process the request.\n\n        @return true if the lend was done successfully\n    */\n    function lend(uint index, bytes oracleData, Cosigner cosigner, bytes cosignerData) public returns (bool) {\n        Loan storage loan = loans[index];\n\n        require(loan.status == Status.initial);\n        require(isApproved(index));\n        require(block.timestamp <= loan.expirationRequest);\n\n        loan.lender = msg.sender;\n        loan.dueTime = safeAdd(block.timestamp, loan.duesIn);\n        loan.interestTimestamp = block.timestamp;\n        loan.status = Status.lent;\n        \n        if (loan.cancelableAt > 0)\n            internalAddInterest(loan, safeAdd(block.timestamp, loan.cancelableAt));\n\n        uint256 rate = getRate(loan, oracleData);\n\n        if (cosigner != address(0)) {\n            // The cosigner it's temporary set to the next address (cosigner + 2), it's expected that the cosigner will\n            // call the method \"cosign\" to accept the conditions; that method also sets the cosigner to the right\n            // address. If that does not happen, the transaction fails.\n            loan.cosigner = address(uint256(cosigner) + 2);\n            require(cosigner.requestCosign(this, index, cosignerData, oracleData));\n            require(loan.cosigner == address(cosigner));\n        }\n        \n        require(rcn.transferFrom(msg.sender, loan.borrower, safeMult(loan.amount, rate)));\n        \n        // ERC721, create new loan and transfer it to the lender\n        Transfer(0x0, loan.lender, index);\n        activeLoans += 1;\n        lendersBalance[loan.lender] += 1;\n        Lent(index, loan.lender, cosigner);\n\n        return true;\n    }\n\n    /**\n        @dev The cosigner must call this method to accept the conditions of a loan, this method pays the cosigner his fee\n\n        @param index Index of the loan\n        @param cost Fee set by the cosigner\n\n        @return true If the cosign was successfull\n    */\n    function cosign(uint index, uint256 cost) external returns (bool) {\n        Loan storage loan = loans[index];\n        require(loan.status == Status.lent && (loan.dueTime - loan.duesIn) == block.timestamp);\n        require(loan.cosigner != address(0));\n        require(loan.cosigner == address(uint256(msg.sender) + 2));\n        loan.cosigner = msg.sender;\n        require(rcn.transferFrom(loan.lender, msg.sender, cost));\n        return true;\n    }\n\n    /**\n        @dev Destroys a loan, the borrower could call this method if they performed an accidental or regretted \n        \"approve\" of the loan, this method only works for them if the loan is in \"pending\" status.\n\n        The lender can call this method at any moment, in case of a loan with status \"lent\" the lender is pardoning \n        the debt. \n\n        @param index Index of the loan\n\n        @return true if the destroy was done successfully\n    */\n    function destroy(uint index) public returns (bool) {\n        Loan storage loan = loans[index];\n        require(loan.status != Status.destroyed);\n        require(msg.sender == loan.lender || (msg.sender == loan.borrower && loan.status == Status.initial));\n        DestroyedBy(index, msg.sender);\n\n        // ERC721, remove loan from circulation\n        if (loan.status != Status.initial) {\n            lendersBalance[loan.lender] -= 1;\n            activeLoans -= 1;\n            Transfer(loan.lender, 0x0, index);\n        }\n\n        loan.status = Status.destroyed;\n        return true;\n    }\n\n    /**\n        @dev Transfers a loan to a different lender, the caller must be the current lender or previously being\n        approved with the method \"approveTransfer\"; only loans with the Status.lent status can be transfered.\n\n        @param index Index of the loan\n        @param to New lender\n\n        @return true if the transfer was done successfully\n    */\n    function transfer(address to, uint256 index) public returns (bool) {\n        Loan storage loan = loans[index];\n        \n        require(loan.status != Status.destroyed && loan.status != Status.paid);\n        require(msg.sender == loan.lender || msg.sender == loan.approvedTransfer);\n        require(to != address(0));\n        loan.lender = to;\n        loan.approvedTransfer = address(0);\n\n        // ERC721, transfer loan to another address\n        lendersBalance[msg.sender] -= 1;\n        lendersBalance[to] += 1;\n        Transfer(loan.lender, to, index);\n\n        return true;\n    }\n\n    /**\n        @dev ERC721 method, transfers the loan to the msg.sender, the msg.sender must be approved using the \n        \"approve\" method.\n\n        @return true if the transfer was successfull\n    */\n    function takeOwnership(uint256 _index) public returns (bool) {\n        return transfer(msg.sender, _index);\n    }\n\n    /**\n        @dev Approves the transfer of a given loan in the name of the lender, the behavior of this function is similar to\n        \"approve\" in the ERC20 standard, but only one approved address is allowed at a time.\n\n        The same method can be called passing 0x0 as parameter \"to\" to erase a previously approved address.\n\n        @param to Address allowed to transfer the loan or 0x0 to delete\n        @param index Index of the loan\n\n        @return true if the approve was done successfully\n    */\n    function approve(address to, uint256 index) public returns (bool) {\n        Loan storage loan = loans[index];\n        require(msg.sender == loan.lender);\n        loan.approvedTransfer = to;\n        Approval(msg.sender, to, index);\n        return true;\n    }\n\n    /**\n        @dev Returns the pending amount to complete de payment of the loan, keep in mind that this number increases \n        every second.\n\n        @param index Index of the loan\n\n        @return Aprox pending payment amount\n    */\n    function getPendingAmount(uint index) public constant returns (uint256) {\n        Loan storage loan = loans[index];\n        addInterest(index);\n        return getRawPendingAmount(loan);\n    }\n\n    function getRawPendingAmount(Loan loan) internal returns (uint256) {\n        return safeSubtract(safeAdd(safeAdd(loan.amount, loan.interest), loan.punitoryInterest), loan.paid);\n    }\n\n    /**\n        @dev Calculates the interest of a given amount, interest rate and delta time.\n\n        @param timeDelta Elapsed time\n        @param interestRate Interest rate expressed as the denominator of 10 000 000.\n        @param amount Amount to apply interest\n\n        @return realDelta The real timeDelta applied\n        @return interest The interest gained in the realDelta time\n    */\n    function calculateInterest(uint256 timeDelta, uint256 interestRate, uint256 amount) public constant returns (uint256 realDelta, uint256 interest) {\n        if (amount == 0) {\n            interest = 0;\n            realDelta = timeDelta;\n        } else {\n            interest = safeMult(safeMult(100000, amount), timeDelta) / interestRate;\n            realDelta = safeMult(interest, interestRate) / (amount * 100000);\n        }\n    }\n\n    /**\n        @dev Computes loan interest\n\n        Computes the punitory and non-punitory interest of a given loan and only applies the change.\n        \n        @param loan Loan to compute interest\n        @param timestamp Target absolute unix time to calculate interest.\n    */\n    function internalAddInterest(Loan storage loan, uint256 timestamp) internal {\n        if (timestamp > loan.interestTimestamp) {\n            uint256 newInterest = loan.interest;\n            uint256 newPunitoryInterest = loan.punitoryInterest;\n\n            uint256 newTimestamp;\n            uint256 realDelta;\n            uint256 calculatedInterest;\n\n            uint256 deltaTime;\n            uint256 pending;\n\n            uint256 endNonPunitory = min(timestamp, loan.dueTime);\n            if (endNonPunitory > loan.interestTimestamp) {\n                deltaTime = endNonPunitory - loan.interestTimestamp;\n\n                if (loan.paid < loan.amount) {\n                    pending = loan.amount - loan.paid;\n                } else {\n                    pending = 0;\n                }\n\n                (realDelta, calculatedInterest) = calculateInterest(deltaTime, loan.interestRate, pending);\n                newInterest = safeAdd(calculatedInterest, newInterest);\n                newTimestamp = loan.interestTimestamp + realDelta;\n            }\n\n            if (timestamp > loan.dueTime) {\n                uint256 startPunitory = max(loan.dueTime, loan.interestTimestamp);\n                deltaTime = timestamp - startPunitory;\n\n                uint256 debt = safeAdd(loan.amount, newInterest);\n                pending = min(debt, safeSubtract(safeAdd(debt, newPunitoryInterest), loan.paid));\n\n                (realDelta, calculatedInterest) = calculateInterest(deltaTime, loan.interestRatePunitory, pending);\n                newPunitoryInterest = safeAdd(newPunitoryInterest, calculatedInterest);\n                newTimestamp = startPunitory + realDelta;\n            }\n            \n            if (newInterest != loan.interest || newPunitoryInterest != loan.punitoryInterest) {\n                loan.interestTimestamp = newTimestamp;\n                loan.interest = newInterest;\n                loan.punitoryInterest = newPunitoryInterest;\n            }\n        }\n    }\n\n    /**\n        @dev Computes loan interest only up to current unix time\n\n        @param timestamp Target absolute unix time to calculate interest.\n    */\n    function addInterestUpTo(Loan storage loan, uint256 timestamp) internal {\n        require(loan.status == Status.lent);\n        if (timestamp <= block.timestamp) {\n            internalAddInterest(loan, timestamp);\n        }\n    }\n\n    /**\n        @dev Updates the loan accumulated interests up to the current Unix time.\n        \n        @param index Index of the loan\n    */\n    function addInterest(uint index) public {\n        Loan storage loan = loans[index];\n        addInterestUpTo(loan, block.timestamp);\n    }\n    \n    /**\n        @dev Pay loan\n\n        Realizes a payment of a given Loan, before performing the payment the accumulated\n        interest is computed and added to the total pending amount.\n\n        Before calling this function, the msg.sender must call the \"approve\" function on the RCN Token, specifying an amount\n        sufficient enough to pay the equivalent of the desired payment and the oracle fee.\n\n        Because it is difficult or even impossible to know in advance how much RCN are going to be spent on the\n        transaction*, we recommend performing the \"approve\" using an amount 5% superior to the wallet estimated\n        spending. If the RCN spent results to be less, the extra tokens are never debited from the msg.sender.\n\n        * The RCN rate can fluctuate on the same block, and it is impossible to know in advance the exact time of the\n        confirmation of the transaction. \n\n        If the paid pending amount equals zero, the loan changes status to \"paid\" and it is considered closed.\n\n        @param index Index of the loan\n        @param _amount Amount to pay, specified in the loan currency; or in RCN if the loan has no oracle\n        @param _from The identity of the payer\n        @param oracleData Data required by the oracle to return the rate, the content of this field must be provided\n            by the url exposed in the url() method of the oracle.\n            \n        @return true if the payment was executed successfully\n    */\n    function pay(uint index, uint256 _amount, address _from, bytes oracleData) public returns (bool) {\n        Loan storage loan = loans[index];\n\n        require(loan.status == Status.lent);\n        addInterest(index);\n        uint256 toPay = min(getPendingAmount(index), _amount);\n        PartialPayment(index, msg.sender, _from, toPay);\n\n        loan.paid = safeAdd(loan.paid, toPay);\n\n        if (getRawPendingAmount(loan) == 0) {\n            TotalPayment(index);\n            loan.status = Status.paid;\n\n            // ERC721, remove loan from circulation\n            lendersBalance[loan.lender] -= 1;\n            activeLoans -= 1;\n            Transfer(loan.lender, 0x0, index);\n        }\n\n        uint256 rate = getRate(loan, oracleData);\n        uint256 transferValue = safeMult(toPay, rate);\n        lockTokens(rcn, transferValue);\n        require(rcn.transferFrom(msg.sender, this, transferValue));\n        loan.lenderBalance = safeAdd(transferValue, loan.lenderBalance);\n\n        return true;\n    }\n\n    /**\n        @dev Retrieves the rate corresponding of the loan oracle, if the loan has no oracle the rate is 1\n\n        @param loan The loan with the cosigner\n        @param data Data required by the oracle\n\n        @return The rate of the oracle\n    */\n    function getRate(Loan loan, bytes data) internal returns (uint256) {\n        if (loan.oracle == address(0)) {\n            return 1;\n        } else {\n            return loan.oracle.getRate(loan.currency, data);\n        }\n    }\n\n    /**\n        @dev Withdraw lender funds\n\n        When a loan is paid, the funds are not transferred automatically to the lender, the funds are stored on the\n        engine contract, and the lender must call this function specifying the amount desired to transfer and the \n        destination.\n\n        This behavior is defined to allow the temporary transfer of the loan to a smart contract, without worrying that\n        the contract will receive tokens that are not traceable; and it allows the development of decentralized \n        autonomous organizations.\n\n        @param index Index of the loan\n        @param to Destination of the wiwthdraw funds\n        @param amount Amount to withdraw, in RCN\n\n        @return true if the withdraw was executed successfully\n    */\n    function withdrawal(uint index, address to, uint256 amount) public returns (bool) {\n        Loan storage loan = loans[index];\n        require(msg.sender == loan.lender);\n        loan.lenderBalance = safeSubtract(loan.lenderBalance, amount);\n        require(rcn.transfer(to, amount));\n        unlockTokens(rcn, amount);\n        return true;\n    }\n\n    function withdrawalRange(uint256 fromIndex, uint256 toIndex, address to) public returns (uint256) {\n        uint256 loanId;\n        uint256 totalWithdraw = 0;\n\n        for (loanId = fromIndex; loanId <= toIndex; loanId++) {\n            Loan storage loan = loans[loanId];\n            if (loan.lender == msg.sender) {\n                totalWithdraw += loan.lenderBalance;\n                loan.lenderBalance = 0;\n            }\n        }\n\n        require(rcn.transfer(to, totalWithdraw));\n        unlockTokens(rcn, totalWithdraw);\n        \n        return totalWithdraw;\n    }\n\n    function withdrawalList(uint256[] memory loanIds, address to) public returns (uint256) {\n        uint256 inputId;\n        uint256 totalWithdraw = 0;\n\n        for (inputId = 0; inputId < loanIds.length; inputId++) {\n            Loan storage loan = loans[loanIds[inputId]];\n            if (loan.lender == msg.sender) {\n                totalWithdraw += loan.lenderBalance;\n                loan.lenderBalance = 0;\n            }\n        }\n\n        require(rcn.transfer(to, totalWithdraw));\n        unlockTokens(rcn, totalWithdraw);\n\n        return totalWithdraw;\n    }\n\n    /**\n        @dev Deprecates the engine, locks the creation of new loans.\n    */\n    function setDeprecated(bool _deprecated) public onlyOwner {\n        deprecated = _deprecated;\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinfabrik-RCN Network Smart Contract Audit/rcn-network-3ded36151ad55543d16c354e70161852de4061d0/contracts/NanoLoanEngine.sol",
        "vulnerability": "Assertion Failure",
        "check": "FP",
        "response": "**Answer:** No  \n**Reason:** The code does not contain any assert statements that could fail and cause an assertion failure. Reverts and requires are used for error handling."
    },
    {
        "code_segment": "contract NanoLoanEngine is ERC721, Engine, Ownable, TokenLockable {\n    uint256 public constant VERSION = 202;\n    string public constant VERSION_NAME = \"Basalt\";\n\n    uint256 private activeLoans = 0;\n    mapping(address => uint256) private lendersBalance;\n\n    function name() constant returns (string _name) {\n        _name = \"RCN - Nano loan engine - Basalt 202\";\n    }\n\n    function symbol() constant returns (string _symbol) {\n        _symbol = \"RCN-NLE-202\";\n    }\n\n    function totalSupply() constant returns (uint _totalSupply) {\n        _totalSupply = activeLoans;\n    }\n\n    function balanceOf(address _owner) constant returns (uint _balance) {\n        _balance = lendersBalance[_owner];\n    }\n\n    function tokenOfOwnerByIndex(address _owner, uint256 _index) constant returns (uint tokenId) {\n        uint256 tokenCount = balanceOf(_owner);\n\n        if (tokenCount == 0 || _index >= tokenCount) {\n            // Fail transaction\n            revert();\n        } else {\n            uint256 totalLoans = totalSupply();\n            uint256 resultIndex = 0;\n\n            uint256 loanId;\n            // SWC-128-DoS With Block Gas Limit: L46\n            for (loanId = 0; loanId <= totalLoans; loanId++) {\n                if (loans[loanId].lender == _owner && loans[loanId].status == Status.lent) {\n                    if (resultIndex == _index) {\n                        return loanId;\n                    }\n                    resultIndex++;\n                }\n            }\n\n            revert();\n        }\n    }\n\n    function tokensOfOwner(address _owner) external constant returns(uint256[] ownerTokens) {\n        uint256 tokenCount = balanceOf(_owner);\n\n        if (tokenCount == 0) {\n            // Return an empty array\n            return new uint256[](0);\n        } else {\n            uint256[] memory result = new uint256[](tokenCount);\n            uint256 totalLoans = totalSupply();\n            uint256 resultIndex = 0;\n\n            uint256 loanId;\n\n            for (loanId = 0; loanId <= totalLoans; loanId++) {\n                if (loans[loanId].lender == _owner && loans[loanId].status == Status.lent) {\n                    result[resultIndex] = loanId;\n                    resultIndex++;\n                }\n            }\n\n            return result;\n        }\n    }\n    \n    Token public rcn;\n    bool public deprecated;\n\n    event CreatedLoan(uint _index, address _borrower, address _creator);\n    event ApprovedBy(uint _index, address _address);\n    event Lent(uint _index, address _lender, address _cosigner);\n    event DestroyedBy(uint _index, address _address);\n    event PartialPayment(uint _index, address _sender, address _from, uint256 _amount);\n    event TotalPayment(uint _index);\n\n    function NanoLoanEngine(Token _rcn) public {\n        owner = msg.sender;\n        rcn = _rcn;\n    }\n\n    struct Loan {\n        Status status;\n        Oracle oracle;\n\n        address borrower;\n        address lender;\n        address creator;\n        address cosigner;\n        \n        uint256 amount;\n        uint256 interest;\n        uint256 punitoryInterest;\n        uint256 interestTimestamp;\n        uint256 paid;\n        uint256 interestRate;\n        uint256 interestRatePunitory;\n        uint256 dueTime;\n        uint256 duesIn;\n\n        bytes32 currency;\n        uint256 cancelableAt;\n        uint256 lenderBalance;\n\n        address approvedTransfer;\n        uint256 expirationRequest;\n\n        mapping(address => bool) approbations;\n    }\n\n    Loan[] private loans;\n\n    /**\n        @dev Creates a loan request, the loan can be generated with any borrower, cosigner, and conditions; if the \n        cosigner and borrower agree they must call the \"approve\" function.\n\n        The creator of the loan is the caller of this function; this is useful to track which wallet created the loan.\n\n        @param _oracleContract Address of the Oracle contract, if the loan does not use any oracle, this field should be 0x0.\n        @param _borrower Address of the borrower\n        @param _currency The currency to use with the oracle, the currency code is generated with the following formula,\n            keccak256(ticker,decimals).\n        @param _amount The requested amount; currency and unit are defined by the Oracle, if there is no Oracle present\n            the currency is RCN, and the unit is wei.\n        @param _interestRate The non-punitory interest rate by second, defined as a denominator of 10 000 000.\n        @param _interestRatePunitory The punitory interest rate by second, defined as a denominator of 10 000 000.\n            Ej: interestRate 11108571428571 = 28% Anual interest\n        @param _duesIn The time in seconds that the borrower has in order to pay the debt after the lender lends the money.\n        @param _cancelableAt Delta in seconds specifying how much interest should be added in advance, if the borrower pays \n        entirely or partially the loan before this term, no extra interest will be deducted.\n        @param _expirationRequest Timestamp of when the loan request expires, if the loan is not filled before this date, \n            the request is no longer valid.\n    */\n    function createLoan(Oracle _oracleContract, address _borrower, bytes32 _currency, uint256 _amount, uint256 _interestRate,\n        uint256 _interestRatePunitory, uint256 _duesIn, uint256 _cancelableAt, uint256 _expirationRequest) returns (uint256) {\n\n        require(!deprecated);\n        require(_cancelableAt <= _duesIn);\n        require(_oracleContract != address(0) || _currency == 0x0);\n        require(_borrower != address(0));\n        require(_amount != 0);\n        require(_interestRatePunitory != 0);\n        require(_interestRate != 0);\n        require(_expirationRequest > block.timestamp);\n\n        var loan = Loan(Status.initial, _oracleContract, _borrower, 0x0, msg.sender, 0x0, _amount, 0, 0, 0, 0, _interestRate,\n            _interestRatePunitory, 0, _duesIn, _currency, _cancelableAt, 0, 0x0, _expirationRequest);\n        uint index = loans.push(loan) - 1;\n        CreatedLoan(index, _borrower, msg.sender);\n\n        if (msg.sender == _borrower) {\n            approveLoan(index);\n        }\n\n        return index;\n    }\n    \n    function ownerOf(uint256 index) constant returns (address owner) { owner = loans[index].lender; }\n    function getTotalLoans() constant returns (uint256) { return loans.length; }\n    function getOracle(uint index) constant returns (Oracle) { return loans[index].oracle; }\n    function getBorrower(uint index) constant returns (address) { return loans[index].borrower; }\n    function getCosigner(uint index) constant returns (address) { return loans[index].cosigner; }\n    function getCreator(uint index) constant returns (address) { return loans[index].creator; }\n    function getAmount(uint index) constant returns (uint256) { return loans[index].amount; }\n    function getPunitoryInterest(uint index) constant returns (uint256) { return loans[index].punitoryInterest; }\n    function getInterestTimestamp(uint index) constant returns (uint256) { return loans[index].interestTimestamp; }\n    function getPaid(uint index) constant returns (uint256) { return loans[index].paid; }\n    function getInterestRate(uint index) constant returns (uint256) { return loans[index].interestRate; }\n    function getInterestRatePunitory(uint index) constant returns (uint256) { return loans[index].interestRatePunitory; }\n    function getDueTime(uint index) constant returns (uint256) { return loans[index].dueTime; }\n    function getDuesIn(uint index) constant returns (uint256) { return loans[index].duesIn; }\n    function getCancelableAt(uint index) constant returns (uint256) { return loans[index].cancelableAt; }\n    function getApprobation(uint index, address _address) constant returns (bool) { return loans[index].approbations[_address]; }\n    function getStatus(uint index) constant returns (Status) { return loans[index].status; }\n    function getLenderBalance(uint index) constant returns (uint256) { return loans[index].lenderBalance; }\n    function getApprovedTransfer(uint index) constant returns (address) {return loans[index].approvedTransfer; }\n    function getCurrency(uint index) constant returns (bytes32) { return loans[index].currency; }\n    function getExpirationRequest(uint index) constant returns (uint256) { return loans[index].expirationRequest; }\n    function getInterest(uint index) constant returns (uint256) { return loans[index].interest; }\n\n    /**\n        @param index Index of the loan\n\n        @return true if the loan has been approved by the borrower and cosigner.\n    */\n    function isApproved(uint index) constant returns (bool) {\n        Loan storage loan = loans[index];\n        return loan.approbations[loan.borrower];\n    }\n\n    /**\n        @dev Called by the members of the loan to show that they agree with the terms of the loan; the borrower\n        must call this method before any lender could call the method \"lend\".\n            \n        Any address can call this method to be added to the \"approbations\" mapping.\n\n        @param index Index of the loan\n\n        @return true if the approve was done successfully\n    */\n    function approveLoan(uint index) public returns(bool) {\n        Loan storage loan = loans[index];\n        require(loan.status == Status.initial);\n        loan.approbations[msg.sender] = true;\n        ApprovedBy(index, msg.sender);\n        return true;\n    }\n\n    /**\n        @dev Performs the lend of the RCN equivalent to the requested amount, and transforms the msg.sender in the new lender.\n\n        The loan must be previously approved by the borrower; before calling this function, the lender candidate must \n        call the \"approve\" function on the RCN Token, specifying an amount sufficient enough to pay the equivalent of\n        the requested amount, and the cosigner fee.\n        \n        @param index Index of the loan\n        @param oracleData Data required by the oracle to return the rate, the content of this field must be provided\n            by the url exposed in the url() method of the oracle.\n        @param cosigner Address of the cosigner, 0x0 for lending without cosigner.\n        @param cosignerData Data required by the cosigner to process the request.\n\n        @return true if the lend was done successfully\n    */\n    function lend(uint index, bytes oracleData, Cosigner cosigner, bytes cosignerData) public returns (bool) {\n        Loan storage loan = loans[index];\n\n        require(loan.status == Status.initial);\n        require(isApproved(index));\n        require(block.timestamp <= loan.expirationRequest);\n\n        loan.lender = msg.sender;\n        loan.dueTime = safeAdd(block.timestamp, loan.duesIn);\n        loan.interestTimestamp = block.timestamp;\n        loan.status = Status.lent;\n        \n        if (loan.cancelableAt > 0)\n            internalAddInterest(loan, safeAdd(block.timestamp, loan.cancelableAt));\n\n        uint256 rate = getRate(loan, oracleData);\n\n        if (cosigner != address(0)) {\n            // The cosigner it's temporary set to the next address (cosigner + 2), it's expected that the cosigner will\n            // call the method \"cosign\" to accept the conditions; that method also sets the cosigner to the right\n            // address. If that does not happen, the transaction fails.\n            loan.cosigner = address(uint256(cosigner) + 2);\n            require(cosigner.requestCosign(this, index, cosignerData, oracleData));\n            require(loan.cosigner == address(cosigner));\n        }\n        \n        require(rcn.transferFrom(msg.sender, loan.borrower, safeMult(loan.amount, rate)));\n        \n        // ERC721, create new loan and transfer it to the lender\n        Transfer(0x0, loan.lender, index);\n        activeLoans += 1;\n        lendersBalance[loan.lender] += 1;\n        Lent(index, loan.lender, cosigner);\n\n        return true;\n    }\n\n    /**\n        @dev The cosigner must call this method to accept the conditions of a loan, this method pays the cosigner his fee\n\n        @param index Index of the loan\n        @param cost Fee set by the cosigner\n\n        @return true If the cosign was successfull\n    */\n    function cosign(uint index, uint256 cost) external returns (bool) {\n        Loan storage loan = loans[index];\n        require(loan.status == Status.lent && (loan.dueTime - loan.duesIn) == block.timestamp);\n        require(loan.cosigner != address(0));\n        require(loan.cosigner == address(uint256(msg.sender) + 2));\n        loan.cosigner = msg.sender;\n        require(rcn.transferFrom(loan.lender, msg.sender, cost));\n        return true;\n    }\n\n    /**\n        @dev Destroys a loan, the borrower could call this method if they performed an accidental or regretted \n        \"approve\" of the loan, this method only works for them if the loan is in \"pending\" status.\n\n        The lender can call this method at any moment, in case of a loan with status \"lent\" the lender is pardoning \n        the debt. \n\n        @param index Index of the loan\n\n        @return true if the destroy was done successfully\n    */\n    function destroy(uint index) public returns (bool) {\n        Loan storage loan = loans[index];\n        require(loan.status != Status.destroyed);\n        require(msg.sender == loan.lender || (msg.sender == loan.borrower && loan.status == Status.initial));\n        DestroyedBy(index, msg.sender);\n\n        // ERC721, remove loan from circulation\n        if (loan.status != Status.initial) {\n            lendersBalance[loan.lender] -= 1;\n            activeLoans -= 1;\n            Transfer(loan.lender, 0x0, index);\n        }\n\n        loan.status = Status.destroyed;\n        return true;\n    }\n\n    /**\n        @dev Transfers a loan to a different lender, the caller must be the current lender or previously being\n        approved with the method \"approveTransfer\"; only loans with the Status.lent status can be transfered.\n\n        @param index Index of the loan\n        @param to New lender\n\n        @return true if the transfer was done successfully\n    */\n    function transfer(address to, uint256 index) public returns (bool) {\n        Loan storage loan = loans[index];\n        \n        require(loan.status != Status.destroyed && loan.status != Status.paid);\n        require(msg.sender == loan.lender || msg.sender == loan.approvedTransfer);\n        require(to != address(0));\n        loan.lender = to;\n        loan.approvedTransfer = address(0);\n\n        // ERC721, transfer loan to another address\n        lendersBalance[msg.sender] -= 1;\n        lendersBalance[to] += 1;\n        Transfer(loan.lender, to, index);\n\n        return true;\n    }\n\n    /**\n        @dev ERC721 method, transfers the loan to the msg.sender, the msg.sender must be approved using the \n        \"approve\" method.\n\n        @return true if the transfer was successfull\n    */\n    function takeOwnership(uint256 _index) public returns (bool) {\n        return transfer(msg.sender, _index);\n    }\n\n    /**\n        @dev Approves the transfer of a given loan in the name of the lender, the behavior of this function is similar to\n        \"approve\" in the ERC20 standard, but only one approved address is allowed at a time.\n\n        The same method can be called passing 0x0 as parameter \"to\" to erase a previously approved address.\n\n        @param to Address allowed to transfer the loan or 0x0 to delete\n        @param index Index of the loan\n\n        @return true if the approve was done successfully\n    */\n    function approve(address to, uint256 index) public returns (bool) {\n        Loan storage loan = loans[index];\n        require(msg.sender == loan.lender);\n        loan.approvedTransfer = to;\n        Approval(msg.sender, to, index);\n        return true;\n    }\n\n    /**\n        @dev Returns the pending amount to complete de payment of the loan, keep in mind that this number increases \n        every second.\n\n        @param index Index of the loan\n\n        @return Aprox pending payment amount\n    */\n    function getPendingAmount(uint index) public constant returns (uint256) {\n        Loan storage loan = loans[index];\n        addInterest(index);\n        return getRawPendingAmount(loan);\n    }\n\n    function getRawPendingAmount(Loan loan) internal returns (uint256) {\n        return safeSubtract(safeAdd(safeAdd(loan.amount, loan.interest), loan.punitoryInterest), loan.paid);\n    }\n\n    /**\n        @dev Calculates the interest of a given amount, interest rate and delta time.\n\n        @param timeDelta Elapsed time\n        @param interestRate Interest rate expressed as the denominator of 10 000 000.\n        @param amount Amount to apply interest\n\n        @return realDelta The real timeDelta applied\n        @return interest The interest gained in the realDelta time\n    */\n    function calculateInterest(uint256 timeDelta, uint256 interestRate, uint256 amount) public constant returns (uint256 realDelta, uint256 interest) {\n        if (amount == 0) {\n            interest = 0;\n            realDelta = timeDelta;\n        } else {\n            interest = safeMult(safeMult(100000, amount), timeDelta) / interestRate;\n            realDelta = safeMult(interest, interestRate) / (amount * 100000);\n        }\n    }\n\n    /**\n        @dev Computes loan interest\n\n        Computes the punitory and non-punitory interest of a given loan and only applies the change.\n        \n        @param loan Loan to compute interest\n        @param timestamp Target absolute unix time to calculate interest.\n    */\n    function internalAddInterest(Loan storage loan, uint256 timestamp) internal {\n        if (timestamp > loan.interestTimestamp) {\n            uint256 newInterest = loan.interest;\n            uint256 newPunitoryInterest = loan.punitoryInterest;\n\n            uint256 newTimestamp;\n            uint256 realDelta;\n            uint256 calculatedInterest;\n\n            uint256 deltaTime;\n            uint256 pending;\n\n            uint256 endNonPunitory = min(timestamp, loan.dueTime);\n            if (endNonPunitory > loan.interestTimestamp) {\n                deltaTime = endNonPunitory - loan.interestTimestamp;\n\n                if (loan.paid < loan.amount) {\n                    pending = loan.amount - loan.paid;\n                } else {\n                    pending = 0;\n                }\n\n                (realDelta, calculatedInterest) = calculateInterest(deltaTime, loan.interestRate, pending);\n                newInterest = safeAdd(calculatedInterest, newInterest);\n                newTimestamp = loan.interestTimestamp + realDelta;\n            }\n\n            if (timestamp > loan.dueTime) {\n                uint256 startPunitory = max(loan.dueTime, loan.interestTimestamp);\n                deltaTime = timestamp - startPunitory;\n\n                uint256 debt = safeAdd(loan.amount, newInterest);\n                pending = min(debt, safeSubtract(safeAdd(debt, newPunitoryInterest), loan.paid));\n\n                (realDelta, calculatedInterest) = calculateInterest(deltaTime, loan.interestRatePunitory, pending);\n                newPunitoryInterest = safeAdd(newPunitoryInterest, calculatedInterest);\n                newTimestamp = startPunitory + realDelta;\n            }\n            \n            if (newInterest != loan.interest || newPunitoryInterest != loan.punitoryInterest) {\n                loan.interestTimestamp = newTimestamp;\n                loan.interest = newInterest;\n                loan.punitoryInterest = newPunitoryInterest;\n            }\n        }\n    }\n\n    /**\n        @dev Computes loan interest only up to current unix time\n\n        @param timestamp Target absolute unix time to calculate interest.\n    */\n    function addInterestUpTo(Loan storage loan, uint256 timestamp) internal {\n        require(loan.status == Status.lent);\n        if (timestamp <= block.timestamp) {\n            internalAddInterest(loan, timestamp);\n        }\n    }\n\n    /**\n        @dev Updates the loan accumulated interests up to the current Unix time.\n        \n        @param index Index of the loan\n    */\n    function addInterest(uint index) public {\n        Loan storage loan = loans[index];\n        addInterestUpTo(loan, block.timestamp);\n    }\n    \n    /**\n        @dev Pay loan\n\n        Realizes a payment of a given Loan, before performing the payment the accumulated\n        interest is computed and added to the total pending amount.\n\n        Before calling this function, the msg.sender must call the \"approve\" function on the RCN Token, specifying an amount\n        sufficient enough to pay the equivalent of the desired payment and the oracle fee.\n\n        Because it is difficult or even impossible to know in advance how much RCN are going to be spent on the\n        transaction*, we recommend performing the \"approve\" using an amount 5% superior to the wallet estimated\n        spending. If the RCN spent results to be less, the extra tokens are never debited from the msg.sender.\n\n        * The RCN rate can fluctuate on the same block, and it is impossible to know in advance the exact time of the\n        confirmation of the transaction. \n\n        If the paid pending amount equals zero, the loan changes status to \"paid\" and it is considered closed.\n\n        @param index Index of the loan\n        @param _amount Amount to pay, specified in the loan currency; or in RCN if the loan has no oracle\n        @param _from The identity of the payer\n        @param oracleData Data required by the oracle to return the rate, the content of this field must be provided\n            by the url exposed in the url() method of the oracle.\n            \n        @return true if the payment was executed successfully\n    */\n    function pay(uint index, uint256 _amount, address _from, bytes oracleData) public returns (bool) {\n        Loan storage loan = loans[index];\n\n        require(loan.status == Status.lent);\n        addInterest(index);\n        uint256 toPay = min(getPendingAmount(index), _amount);\n        PartialPayment(index, msg.sender, _from, toPay);\n\n        loan.paid = safeAdd(loan.paid, toPay);\n\n        if (getRawPendingAmount(loan) == 0) {\n            TotalPayment(index);\n            loan.status = Status.paid;\n\n            // ERC721, remove loan from circulation\n            lendersBalance[loan.lender] -= 1;\n            activeLoans -= 1;\n            Transfer(loan.lender, 0x0, index);\n        }\n\n        uint256 rate = getRate(loan, oracleData);\n        uint256 transferValue = safeMult(toPay, rate);\n        lockTokens(rcn, transferValue);\n        require(rcn.transferFrom(msg.sender, this, transferValue));\n        loan.lenderBalance = safeAdd(transferValue, loan.lenderBalance);\n\n        return true;\n    }\n\n    /**\n        @dev Retrieves the rate corresponding of the loan oracle, if the loan has no oracle the rate is 1\n\n        @param loan The loan with the cosigner\n        @param data Data required by the oracle\n\n        @return The rate of the oracle\n    */\n    function getRate(Loan loan, bytes data) internal returns (uint256) {\n        if (loan.oracle == address(0)) {\n            return 1;\n        } else {\n            return loan.oracle.getRate(loan.currency, data);\n        }\n    }\n\n    /**\n        @dev Withdraw lender funds\n\n        When a loan is paid, the funds are not transferred automatically to the lender, the funds are stored on the\n        engine contract, and the lender must call this function specifying the amount desired to transfer and the \n        destination.\n\n        This behavior is defined to allow the temporary transfer of the loan to a smart contract, without worrying that\n        the contract will receive tokens that are not traceable; and it allows the development of decentralized \n        autonomous organizations.\n\n        @param index Index of the loan\n        @param to Destination of the wiwthdraw funds\n        @param amount Amount to withdraw, in RCN\n\n        @return true if the withdraw was executed successfully\n    */\n    function withdrawal(uint index, address to, uint256 amount) public returns (bool) {\n        Loan storage loan = loans[index];\n        require(msg.sender == loan.lender);\n        loan.lenderBalance = safeSubtract(loan.lenderBalance, amount);\n        require(rcn.transfer(to, amount));\n        unlockTokens(rcn, amount);\n        return true;\n    }\n\n    function withdrawalRange(uint256 fromIndex, uint256 toIndex, address to) public returns (uint256) {\n        uint256 loanId;\n        uint256 totalWithdraw = 0;\n\n        for (loanId = fromIndex; loanId <= toIndex; loanId++) {\n            Loan storage loan = loans[loanId];\n            if (loan.lender == msg.sender) {\n                totalWithdraw += loan.lenderBalance;\n                loan.lenderBalance = 0;\n            }\n        }\n\n        require(rcn.transfer(to, totalWithdraw));\n        unlockTokens(rcn, totalWithdraw);\n        \n        return totalWithdraw;\n    }\n\n    function withdrawalList(uint256[] memory loanIds, address to) public returns (uint256) {\n        uint256 inputId;\n        uint256 totalWithdraw = 0;\n\n        for (inputId = 0; inputId < loanIds.length; inputId++) {\n            Loan storage loan = loans[loanIds[inputId]];\n            if (loan.lender == msg.sender) {\n                totalWithdraw += loan.lenderBalance;\n                loan.lenderBalance = 0;\n            }\n        }\n\n        require(rcn.transfer(to, totalWithdraw));\n        unlockTokens(rcn, totalWithdraw);\n\n        return totalWithdraw;\n    }\n\n    /**\n        @dev Deprecates the engine, locks the creation of new loans.\n    */\n    function setDeprecated(bool _deprecated) public onlyOwner {\n        deprecated = _deprecated;\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinfabrik-RCN Network Smart Contract Audit/rcn-network-3ded36151ad55543d16c354e70161852de4061d0/contracts/NanoLoanEngine.sol",
        "vulnerability": "Assertion Failure",
        "check": "FP",
        "response": "Answer: No\nReason: The smart contract does not contain any \"assert\" statements. Assertion failures occur when an assert() statement fails, but there are no such statements in the provided code."
    },
    {
        "code_segment": "contract NanoLoanEngine is ERC721, Engine, Ownable, TokenLockable {\n    uint256 public constant VERSION = 202;\n    string public constant VERSION_NAME = \"Basalt\";\n\n    uint256 private activeLoans = 0;\n    mapping(address => uint256) private lendersBalance;\n\n    function name() constant returns (string _name) {\n        _name = \"RCN - Nano loan engine - Basalt 202\";\n    }\n\n    function symbol() constant returns (string _symbol) {\n        _symbol = \"RCN-NLE-202\";\n    }\n\n    function totalSupply() constant returns (uint _totalSupply) {\n        _totalSupply = activeLoans;\n    }\n\n    function balanceOf(address _owner) constant returns (uint _balance) {\n        _balance = lendersBalance[_owner];\n    }\n\n    function tokenOfOwnerByIndex(address _owner, uint256 _index) constant returns (uint tokenId) {\n        uint256 tokenCount = balanceOf(_owner);\n\n        if (tokenCount == 0 || _index >= tokenCount) {\n            // Fail transaction\n            revert();\n        } else {\n            uint256 totalLoans = totalSupply();\n            uint256 resultIndex = 0;\n\n            uint256 loanId;\n            // SWC-128-DoS With Block Gas Limit: L46\n            for (loanId = 0; loanId <= totalLoans; loanId++) {\n                if (loans[loanId].lender == _owner && loans[loanId].status == Status.lent) {\n                    if (resultIndex == _index) {\n                        return loanId;\n                    }\n                    resultIndex++;\n                }\n            }\n\n            revert();\n        }\n    }\n\n    function tokensOfOwner(address _owner) external constant returns(uint256[] ownerTokens) {\n        uint256 tokenCount = balanceOf(_owner);\n\n        if (tokenCount == 0) {\n            // Return an empty array\n            return new uint256[](0);\n        } else {\n            uint256[] memory result = new uint256[](tokenCount);\n            uint256 totalLoans = totalSupply();\n            uint256 resultIndex = 0;\n\n            uint256 loanId;\n\n            for (loanId = 0; loanId <= totalLoans; loanId++) {\n                if (loans[loanId].lender == _owner && loans[loanId].status == Status.lent) {\n                    result[resultIndex] = loanId;\n                    resultIndex++;\n                }\n            }\n\n            return result;\n        }\n    }\n    \n    Token public rcn;\n    bool public deprecated;\n\n    event CreatedLoan(uint _index, address _borrower, address _creator);\n    event ApprovedBy(uint _index, address _address);\n    event Lent(uint _index, address _lender, address _cosigner);\n    event DestroyedBy(uint _index, address _address);\n    event PartialPayment(uint _index, address _sender, address _from, uint256 _amount);\n    event TotalPayment(uint _index);\n\n    function NanoLoanEngine(Token _rcn) public {\n        owner = msg.sender;\n        rcn = _rcn;\n    }\n\n    struct Loan {\n        Status status;\n        Oracle oracle;\n\n        address borrower;\n        address lender;\n        address creator;\n        address cosigner;\n        \n        uint256 amount;\n        uint256 interest;\n        uint256 punitoryInterest;\n        uint256 interestTimestamp;\n        uint256 paid;\n        uint256 interestRate;\n        uint256 interestRatePunitory;\n        uint256 dueTime;\n        uint256 duesIn;\n\n        bytes32 currency;\n        uint256 cancelableAt;\n        uint256 lenderBalance;\n\n        address approvedTransfer;\n        uint256 expirationRequest;\n\n        mapping(address => bool) approbations;\n    }\n\n    Loan[] private loans;\n\n    /**\n        @dev Creates a loan request, the loan can be generated with any borrower, cosigner, and conditions; if the \n        cosigner and borrower agree they must call the \"approve\" function.\n\n        The creator of the loan is the caller of this function; this is useful to track which wallet created the loan.\n\n        @param _oracleContract Address of the Oracle contract, if the loan does not use any oracle, this field should be 0x0.\n        @param _borrower Address of the borrower\n        @param _currency The currency to use with the oracle, the currency code is generated with the following formula,\n            keccak256(ticker,decimals).\n        @param _amount The requested amount; currency and unit are defined by the Oracle, if there is no Oracle present\n            the currency is RCN, and the unit is wei.\n        @param _interestRate The non-punitory interest rate by second, defined as a denominator of 10 000 000.\n        @param _interestRatePunitory The punitory interest rate by second, defined as a denominator of 10 000 000.\n            Ej: interestRate 11108571428571 = 28% Anual interest\n        @param _duesIn The time in seconds that the borrower has in order to pay the debt after the lender lends the money.\n        @param _cancelableAt Delta in seconds specifying how much interest should be added in advance, if the borrower pays \n        entirely or partially the loan before this term, no extra interest will be deducted.\n        @param _expirationRequest Timestamp of when the loan request expires, if the loan is not filled before this date, \n            the request is no longer valid.\n    */\n    function createLoan(Oracle _oracleContract, address _borrower, bytes32 _currency, uint256 _amount, uint256 _interestRate,\n        uint256 _interestRatePunitory, uint256 _duesIn, uint256 _cancelableAt, uint256 _expirationRequest) returns (uint256) {\n\n        require(!deprecated);\n        require(_cancelableAt <= _duesIn);\n        require(_oracleContract != address(0) || _currency == 0x0);\n        require(_borrower != address(0));\n        require(_amount != 0);\n        require(_interestRatePunitory != 0);\n        require(_interestRate != 0);\n        require(_expirationRequest > block.timestamp);\n\n        var loan = Loan(Status.initial, _oracleContract, _borrower, 0x0, msg.sender, 0x0, _amount, 0, 0, 0, 0, _interestRate,\n            _interestRatePunitory, 0, _duesIn, _currency, _cancelableAt, 0, 0x0, _expirationRequest);\n        uint index = loans.push(loan) - 1;\n        CreatedLoan(index, _borrower, msg.sender);\n\n        if (msg.sender == _borrower) {\n            approveLoan(index);\n        }\n\n        return index;\n    }\n    \n    function ownerOf(uint256 index) constant returns (address owner) { owner = loans[index].lender; }\n    function getTotalLoans() constant returns (uint256) { return loans.length; }\n    function getOracle(uint index) constant returns (Oracle) { return loans[index].oracle; }\n    function getBorrower(uint index) constant returns (address) { return loans[index].borrower; }\n    function getCosigner(uint index) constant returns (address) { return loans[index].cosigner; }\n    function getCreator(uint index) constant returns (address) { return loans[index].creator; }\n    function getAmount(uint index) constant returns (uint256) { return loans[index].amount; }\n    function getPunitoryInterest(uint index) constant returns (uint256) { return loans[index].punitoryInterest; }\n    function getInterestTimestamp(uint index) constant returns (uint256) { return loans[index].interestTimestamp; }\n    function getPaid(uint index) constant returns (uint256) { return loans[index].paid; }\n    function getInterestRate(uint index) constant returns (uint256) { return loans[index].interestRate; }\n    function getInterestRatePunitory(uint index) constant returns (uint256) { return loans[index].interestRatePunitory; }\n    function getDueTime(uint index) constant returns (uint256) { return loans[index].dueTime; }\n    function getDuesIn(uint index) constant returns (uint256) { return loans[index].duesIn; }\n    function getCancelableAt(uint index) constant returns (uint256) { return loans[index].cancelableAt; }\n    function getApprobation(uint index, address _address) constant returns (bool) { return loans[index].approbations[_address]; }\n    function getStatus(uint index) constant returns (Status) { return loans[index].status; }\n    function getLenderBalance(uint index) constant returns (uint256) { return loans[index].lenderBalance; }\n    function getApprovedTransfer(uint index) constant returns (address) {return loans[index].approvedTransfer; }\n    function getCurrency(uint index) constant returns (bytes32) { return loans[index].currency; }\n    function getExpirationRequest(uint index) constant returns (uint256) { return loans[index].expirationRequest; }\n    function getInterest(uint index) constant returns (uint256) { return loans[index].interest; }\n\n    /**\n        @param index Index of the loan\n\n        @return true if the loan has been approved by the borrower and cosigner.\n    */\n    function isApproved(uint index) constant returns (bool) {\n        Loan storage loan = loans[index];\n        return loan.approbations[loan.borrower];\n    }\n\n    /**\n        @dev Called by the members of the loan to show that they agree with the terms of the loan; the borrower\n        must call this method before any lender could call the method \"lend\".\n            \n        Any address can call this method to be added to the \"approbations\" mapping.\n\n        @param index Index of the loan\n\n        @return true if the approve was done successfully\n    */\n    function approveLoan(uint index) public returns(bool) {\n        Loan storage loan = loans[index];\n        require(loan.status == Status.initial);\n        loan.approbations[msg.sender] = true;\n        ApprovedBy(index, msg.sender);\n        return true;\n    }\n\n    /**\n        @dev Performs the lend of the RCN equivalent to the requested amount, and transforms the msg.sender in the new lender.\n\n        The loan must be previously approved by the borrower; before calling this function, the lender candidate must \n        call the \"approve\" function on the RCN Token, specifying an amount sufficient enough to pay the equivalent of\n        the requested amount, and the cosigner fee.\n        \n        @param index Index of the loan\n        @param oracleData Data required by the oracle to return the rate, the content of this field must be provided\n            by the url exposed in the url() method of the oracle.\n        @param cosigner Address of the cosigner, 0x0 for lending without cosigner.\n        @param cosignerData Data required by the cosigner to process the request.\n\n        @return true if the lend was done successfully\n    */\n    function lend(uint index, bytes oracleData, Cosigner cosigner, bytes cosignerData) public returns (bool) {\n        Loan storage loan = loans[index];\n\n        require(loan.status == Status.initial);\n        require(isApproved(index));\n        require(block.timestamp <= loan.expirationRequest);\n\n        loan.lender = msg.sender;\n        loan.dueTime = safeAdd(block.timestamp, loan.duesIn);\n        loan.interestTimestamp = block.timestamp;\n        loan.status = Status.lent;\n        \n        if (loan.cancelableAt > 0)\n            internalAddInterest(loan, safeAdd(block.timestamp, loan.cancelableAt));\n\n        uint256 rate = getRate(loan, oracleData);\n\n        if (cosigner != address(0)) {\n            // The cosigner it's temporary set to the next address (cosigner + 2), it's expected that the cosigner will\n            // call the method \"cosign\" to accept the conditions; that method also sets the cosigner to the right\n            // address. If that does not happen, the transaction fails.\n            loan.cosigner = address(uint256(cosigner) + 2);\n            require(cosigner.requestCosign(this, index, cosignerData, oracleData));\n            require(loan.cosigner == address(cosigner));\n        }\n        \n        require(rcn.transferFrom(msg.sender, loan.borrower, safeMult(loan.amount, rate)));\n        \n        // ERC721, create new loan and transfer it to the lender\n        Transfer(0x0, loan.lender, index);\n        activeLoans += 1;\n        lendersBalance[loan.lender] += 1;\n        Lent(index, loan.lender, cosigner);\n\n        return true;\n    }\n\n    /**\n        @dev The cosigner must call this method to accept the conditions of a loan, this method pays the cosigner his fee\n\n        @param index Index of the loan\n        @param cost Fee set by the cosigner\n\n        @return true If the cosign was successfull\n    */\n    function cosign(uint index, uint256 cost) external returns (bool) {\n        Loan storage loan = loans[index];\n        require(loan.status == Status.lent && (loan.dueTime - loan.duesIn) == block.timestamp);\n        require(loan.cosigner != address(0));\n        require(loan.cosigner == address(uint256(msg.sender) + 2));\n        loan.cosigner = msg.sender;\n        require(rcn.transferFrom(loan.lender, msg.sender, cost));\n        return true;\n    }\n\n    /**\n        @dev Destroys a loan, the borrower could call this method if they performed an accidental or regretted \n        \"approve\" of the loan, this method only works for them if the loan is in \"pending\" status.\n\n        The lender can call this method at any moment, in case of a loan with status \"lent\" the lender is pardoning \n        the debt. \n\n        @param index Index of the loan\n\n        @return true if the destroy was done successfully\n    */\n    function destroy(uint index) public returns (bool) {\n        Loan storage loan = loans[index];\n        require(loan.status != Status.destroyed);\n        require(msg.sender == loan.lender || (msg.sender == loan.borrower && loan.status == Status.initial));\n        DestroyedBy(index, msg.sender);\n\n        // ERC721, remove loan from circulation\n        if (loan.status != Status.initial) {\n            lendersBalance[loan.lender] -= 1;\n            activeLoans -= 1;\n            Transfer(loan.lender, 0x0, index);\n        }\n\n        loan.status = Status.destroyed;\n        return true;\n    }\n\n    /**\n        @dev Transfers a loan to a different lender, the caller must be the current lender or previously being\n        approved with the method \"approveTransfer\"; only loans with the Status.lent status can be transfered.\n\n        @param index Index of the loan\n        @param to New lender\n\n        @return true if the transfer was done successfully\n    */\n    function transfer(address to, uint256 index) public returns (bool) {\n        Loan storage loan = loans[index];\n        \n        require(loan.status != Status.destroyed && loan.status != Status.paid);\n        require(msg.sender == loan.lender || msg.sender == loan.approvedTransfer);\n        require(to != address(0));\n        loan.lender = to;\n        loan.approvedTransfer = address(0);\n\n        // ERC721, transfer loan to another address\n        lendersBalance[msg.sender] -= 1;\n        lendersBalance[to] += 1;\n        Transfer(loan.lender, to, index);\n\n        return true;\n    }\n\n    /**\n        @dev ERC721 method, transfers the loan to the msg.sender, the msg.sender must be approved using the \n        \"approve\" method.\n\n        @return true if the transfer was successfull\n    */\n    function takeOwnership(uint256 _index) public returns (bool) {\n        return transfer(msg.sender, _index);\n    }\n\n    /**\n        @dev Approves the transfer of a given loan in the name of the lender, the behavior of this function is similar to\n        \"approve\" in the ERC20 standard, but only one approved address is allowed at a time.\n\n        The same method can be called passing 0x0 as parameter \"to\" to erase a previously approved address.\n\n        @param to Address allowed to transfer the loan or 0x0 to delete\n        @param index Index of the loan\n\n        @return true if the approve was done successfully\n    */\n    function approve(address to, uint256 index) public returns (bool) {\n        Loan storage loan = loans[index];\n        require(msg.sender == loan.lender);\n        loan.approvedTransfer = to;\n        Approval(msg.sender, to, index);\n        return true;\n    }\n\n    /**\n        @dev Returns the pending amount to complete de payment of the loan, keep in mind that this number increases \n        every second.\n\n        @param index Index of the loan\n\n        @return Aprox pending payment amount\n    */\n    function getPendingAmount(uint index) public constant returns (uint256) {\n        Loan storage loan = loans[index];\n        addInterest(index);\n        return getRawPendingAmount(loan);\n    }\n\n    function getRawPendingAmount(Loan loan) internal returns (uint256) {\n        return safeSubtract(safeAdd(safeAdd(loan.amount, loan.interest), loan.punitoryInterest), loan.paid);\n    }\n\n    /**\n        @dev Calculates the interest of a given amount, interest rate and delta time.\n\n        @param timeDelta Elapsed time\n        @param interestRate Interest rate expressed as the denominator of 10 000 000.\n        @param amount Amount to apply interest\n\n        @return realDelta The real timeDelta applied\n        @return interest The interest gained in the realDelta time\n    */\n    function calculateInterest(uint256 timeDelta, uint256 interestRate, uint256 amount) public constant returns (uint256 realDelta, uint256 interest) {\n        if (amount == 0) {\n            interest = 0;\n            realDelta = timeDelta;\n        } else {\n            interest = safeMult(safeMult(100000, amount), timeDelta) / interestRate;\n            realDelta = safeMult(interest, interestRate) / (amount * 100000);\n        }\n    }\n\n    /**\n        @dev Computes loan interest\n\n        Computes the punitory and non-punitory interest of a given loan and only applies the change.\n        \n        @param loan Loan to compute interest\n        @param timestamp Target absolute unix time to calculate interest.\n    */\n    function internalAddInterest(Loan storage loan, uint256 timestamp) internal {\n        if (timestamp > loan.interestTimestamp) {\n            uint256 newInterest = loan.interest;\n            uint256 newPunitoryInterest = loan.punitoryInterest;\n\n            uint256 newTimestamp;\n            uint256 realDelta;\n            uint256 calculatedInterest;\n\n            uint256 deltaTime;\n            uint256 pending;\n\n            uint256 endNonPunitory = min(timestamp, loan.dueTime);\n            if (endNonPunitory > loan.interestTimestamp) {\n                deltaTime = endNonPunitory - loan.interestTimestamp;\n\n                if (loan.paid < loan.amount) {\n                    pending = loan.amount - loan.paid;\n                } else {\n                    pending = 0;\n                }\n\n                (realDelta, calculatedInterest) = calculateInterest(deltaTime, loan.interestRate, pending);\n                newInterest = safeAdd(calculatedInterest, newInterest);\n                newTimestamp = loan.interestTimestamp + realDelta;\n            }\n\n            if (timestamp > loan.dueTime) {\n                uint256 startPunitory = max(loan.dueTime, loan.interestTimestamp);\n                deltaTime = timestamp - startPunitory;\n\n                uint256 debt = safeAdd(loan.amount, newInterest);\n                pending = min(debt, safeSubtract(safeAdd(debt, newPunitoryInterest), loan.paid));\n\n                (realDelta, calculatedInterest) = calculateInterest(deltaTime, loan.interestRatePunitory, pending);\n                newPunitoryInterest = safeAdd(newPunitoryInterest, calculatedInterest);\n                newTimestamp = startPunitory + realDelta;\n            }\n            \n            if (newInterest != loan.interest || newPunitoryInterest != loan.punitoryInterest) {\n                loan.interestTimestamp = newTimestamp;\n                loan.interest = newInterest;\n                loan.punitoryInterest = newPunitoryInterest;\n            }\n        }\n    }\n\n    /**\n        @dev Computes loan interest only up to current unix time\n\n        @param timestamp Target absolute unix time to calculate interest.\n    */\n    function addInterestUpTo(Loan storage loan, uint256 timestamp) internal {\n        require(loan.status == Status.lent);\n        if (timestamp <= block.timestamp) {\n            internalAddInterest(loan, timestamp);\n        }\n    }\n\n    /**\n        @dev Updates the loan accumulated interests up to the current Unix time.\n        \n        @param index Index of the loan\n    */\n    function addInterest(uint index) public {\n        Loan storage loan = loans[index];\n        addInterestUpTo(loan, block.timestamp);\n    }\n    \n    /**\n        @dev Pay loan\n\n        Realizes a payment of a given Loan, before performing the payment the accumulated\n        interest is computed and added to the total pending amount.\n\n        Before calling this function, the msg.sender must call the \"approve\" function on the RCN Token, specifying an amount\n        sufficient enough to pay the equivalent of the desired payment and the oracle fee.\n\n        Because it is difficult or even impossible to know in advance how much RCN are going to be spent on the\n        transaction*, we recommend performing the \"approve\" using an amount 5% superior to the wallet estimated\n        spending. If the RCN spent results to be less, the extra tokens are never debited from the msg.sender.\n\n        * The RCN rate can fluctuate on the same block, and it is impossible to know in advance the exact time of the\n        confirmation of the transaction. \n\n        If the paid pending amount equals zero, the loan changes status to \"paid\" and it is considered closed.\n\n        @param index Index of the loan\n        @param _amount Amount to pay, specified in the loan currency; or in RCN if the loan has no oracle\n        @param _from The identity of the payer\n        @param oracleData Data required by the oracle to return the rate, the content of this field must be provided\n            by the url exposed in the url() method of the oracle.\n            \n        @return true if the payment was executed successfully\n    */\n    function pay(uint index, uint256 _amount, address _from, bytes oracleData) public returns (bool) {\n        Loan storage loan = loans[index];\n\n        require(loan.status == Status.lent);\n        addInterest(index);\n        uint256 toPay = min(getPendingAmount(index), _amount);\n        PartialPayment(index, msg.sender, _from, toPay);\n\n        loan.paid = safeAdd(loan.paid, toPay);\n\n        if (getRawPendingAmount(loan) == 0) {\n            TotalPayment(index);\n            loan.status = Status.paid;\n\n            // ERC721, remove loan from circulation\n            lendersBalance[loan.lender] -= 1;\n            activeLoans -= 1;\n            Transfer(loan.lender, 0x0, index);\n        }\n\n        uint256 rate = getRate(loan, oracleData);\n        uint256 transferValue = safeMult(toPay, rate);\n        lockTokens(rcn, transferValue);\n        require(rcn.transferFrom(msg.sender, this, transferValue));\n        loan.lenderBalance = safeAdd(transferValue, loan.lenderBalance);\n\n        return true;\n    }\n\n    /**\n        @dev Retrieves the rate corresponding of the loan oracle, if the loan has no oracle the rate is 1\n\n        @param loan The loan with the cosigner\n        @param data Data required by the oracle\n\n        @return The rate of the oracle\n    */\n    function getRate(Loan loan, bytes data) internal returns (uint256) {\n        if (loan.oracle == address(0)) {\n            return 1;\n        } else {\n            return loan.oracle.getRate(loan.currency, data);\n        }\n    }\n\n    /**\n        @dev Withdraw lender funds\n\n        When a loan is paid, the funds are not transferred automatically to the lender, the funds are stored on the\n        engine contract, and the lender must call this function specifying the amount desired to transfer and the \n        destination.\n\n        This behavior is defined to allow the temporary transfer of the loan to a smart contract, without worrying that\n        the contract will receive tokens that are not traceable; and it allows the development of decentralized \n        autonomous organizations.\n\n        @param index Index of the loan\n        @param to Destination of the wiwthdraw funds\n        @param amount Amount to withdraw, in RCN\n\n        @return true if the withdraw was executed successfully\n    */\n    function withdrawal(uint index, address to, uint256 amount) public returns (bool) {\n        Loan storage loan = loans[index];\n        require(msg.sender == loan.lender);\n        loan.lenderBalance = safeSubtract(loan.lenderBalance, amount);\n        require(rcn.transfer(to, amount));\n        unlockTokens(rcn, amount);\n        return true;\n    }\n\n    function withdrawalRange(uint256 fromIndex, uint256 toIndex, address to) public returns (uint256) {\n        uint256 loanId;\n        uint256 totalWithdraw = 0;\n\n        for (loanId = fromIndex; loanId <= toIndex; loanId++) {\n            Loan storage loan = loans[loanId];\n            if (loan.lender == msg.sender) {\n                totalWithdraw += loan.lenderBalance;\n                loan.lenderBalance = 0;\n            }\n        }\n\n        require(rcn.transfer(to, totalWithdraw));\n        unlockTokens(rcn, totalWithdraw);\n        \n        return totalWithdraw;\n    }\n\n    function withdrawalList(uint256[] memory loanIds, address to) public returns (uint256) {\n        uint256 inputId;\n        uint256 totalWithdraw = 0;\n\n        for (inputId = 0; inputId < loanIds.length; inputId++) {\n            Loan storage loan = loans[loanIds[inputId]];\n            if (loan.lender == msg.sender) {\n                totalWithdraw += loan.lenderBalance;\n                loan.lenderBalance = 0;\n            }\n        }\n\n        require(rcn.transfer(to, totalWithdraw));\n        unlockTokens(rcn, totalWithdraw);\n\n        return totalWithdraw;\n    }\n\n    /**\n        @dev Deprecates the engine, locks the creation of new loans.\n    */\n    function setDeprecated(bool _deprecated) public onlyOwner {\n        deprecated = _deprecated;\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinfabrik-RCN Network Smart Contract Audit/rcn-network-3ded36151ad55543d16c354e70161852de4061d0/contracts/NanoLoanEngine.sol",
        "vulnerability": "Assertion Failure",
        "check": "FP",
        "response": "Answer: Yes\nDescription: Assertion failure can occur during the loop (for (loanId = 0; loanId <= totalLoans; loanId++)) in the `tokenOfOwnerByIndex` function if totalLoans is greater than the actual size of the loans array, causing an out-of-bounds access."
    },
    {
        "code_segment": "contract NanoLoanEngine is ERC721, Engine, Ownable, TokenLockable {\n    uint256 public constant VERSION = 202;\n    string public constant VERSION_NAME = \"Basalt\";\n\n    uint256 private activeLoans = 0;\n    mapping(address => uint256) private lendersBalance;\n\n    function name() constant returns (string _name) {\n        _name = \"RCN - Nano loan engine - Basalt 202\";\n    }\n\n    function symbol() constant returns (string _symbol) {\n        _symbol = \"RCN-NLE-202\";\n    }\n\n    function totalSupply() constant returns (uint _totalSupply) {\n        _totalSupply = activeLoans;\n    }\n\n    function balanceOf(address _owner) constant returns (uint _balance) {\n        _balance = lendersBalance[_owner];\n    }\n\n    function tokenOfOwnerByIndex(address _owner, uint256 _index) constant returns (uint tokenId) {\n        uint256 tokenCount = balanceOf(_owner);\n\n        if (tokenCount == 0 || _index >= tokenCount) {\n            // Fail transaction\n            revert();\n        } else {\n            uint256 totalLoans = totalSupply();\n            uint256 resultIndex = 0;\n\n            uint256 loanId;\n            // SWC-128-DoS With Block Gas Limit: L46\n            for (loanId = 0; loanId <= totalLoans; loanId++) {\n                if (loans[loanId].lender == _owner && loans[loanId].status == Status.lent) {\n                    if (resultIndex == _index) {\n                        return loanId;\n                    }\n                    resultIndex++;\n                }\n            }\n\n            revert();\n        }\n    }\n\n    function tokensOfOwner(address _owner) external constant returns(uint256[] ownerTokens) {\n        uint256 tokenCount = balanceOf(_owner);\n\n        if (tokenCount == 0) {\n            // Return an empty array\n            return new uint256[](0);\n        } else {\n            uint256[] memory result = new uint256[](tokenCount);\n            uint256 totalLoans = totalSupply();\n            uint256 resultIndex = 0;\n\n            uint256 loanId;\n\n            for (loanId = 0; loanId <= totalLoans; loanId++) {\n                if (loans[loanId].lender == _owner && loans[loanId].status == Status.lent) {\n                    result[resultIndex] = loanId;\n                    resultIndex++;\n                }\n            }\n\n            return result;\n        }\n    }\n    \n    Token public rcn;\n    bool public deprecated;\n\n    event CreatedLoan(uint _index, address _borrower, address _creator);\n    event ApprovedBy(uint _index, address _address);\n    event Lent(uint _index, address _lender, address _cosigner);\n    event DestroyedBy(uint _index, address _address);\n    event PartialPayment(uint _index, address _sender, address _from, uint256 _amount);\n    event TotalPayment(uint _index);\n\n    function NanoLoanEngine(Token _rcn) public {\n        owner = msg.sender;\n        rcn = _rcn;\n    }\n\n    struct Loan {\n        Status status;\n        Oracle oracle;\n\n        address borrower;\n        address lender;\n        address creator;\n        address cosigner;\n        \n        uint256 amount;\n        uint256 interest;\n        uint256 punitoryInterest;\n        uint256 interestTimestamp;\n        uint256 paid;\n        uint256 interestRate;\n        uint256 interestRatePunitory;\n        uint256 dueTime;\n        uint256 duesIn;\n\n        bytes32 currency;\n        uint256 cancelableAt;\n        uint256 lenderBalance;\n\n        address approvedTransfer;\n        uint256 expirationRequest;\n\n        mapping(address => bool) approbations;\n    }\n\n    Loan[] private loans;\n\n    /**\n        @dev Creates a loan request, the loan can be generated with any borrower, cosigner, and conditions; if the \n        cosigner and borrower agree they must call the \"approve\" function.\n\n        The creator of the loan is the caller of this function; this is useful to track which wallet created the loan.\n\n        @param _oracleContract Address of the Oracle contract, if the loan does not use any oracle, this field should be 0x0.\n        @param _borrower Address of the borrower\n        @param _currency The currency to use with the oracle, the currency code is generated with the following formula,\n            keccak256(ticker,decimals).\n        @param _amount The requested amount; currency and unit are defined by the Oracle, if there is no Oracle present\n            the currency is RCN, and the unit is wei.\n        @param _interestRate The non-punitory interest rate by second, defined as a denominator of 10 000 000.\n        @param _interestRatePunitory The punitory interest rate by second, defined as a denominator of 10 000 000.\n            Ej: interestRate 11108571428571 = 28% Anual interest\n        @param _duesIn The time in seconds that the borrower has in order to pay the debt after the lender lends the money.\n        @param _cancelableAt Delta in seconds specifying how much interest should be added in advance, if the borrower pays \n        entirely or partially the loan before this term, no extra interest will be deducted.\n        @param _expirationRequest Timestamp of when the loan request expires, if the loan is not filled before this date, \n            the request is no longer valid.\n    */\n    function createLoan(Oracle _oracleContract, address _borrower, bytes32 _currency, uint256 _amount, uint256 _interestRate,\n        uint256 _interestRatePunitory, uint256 _duesIn, uint256 _cancelableAt, uint256 _expirationRequest) returns (uint256) {\n\n        require(!deprecated);\n        require(_cancelableAt <= _duesIn);\n        require(_oracleContract != address(0) || _currency == 0x0);\n        require(_borrower != address(0));\n        require(_amount != 0);\n        require(_interestRatePunitory != 0);\n        require(_interestRate != 0);\n        require(_expirationRequest > block.timestamp);\n\n        var loan = Loan(Status.initial, _oracleContract, _borrower, 0x0, msg.sender, 0x0, _amount, 0, 0, 0, 0, _interestRate,\n            _interestRatePunitory, 0, _duesIn, _currency, _cancelableAt, 0, 0x0, _expirationRequest);\n        uint index = loans.push(loan) - 1;\n        CreatedLoan(index, _borrower, msg.sender);\n\n        if (msg.sender == _borrower) {\n            approveLoan(index);\n        }\n\n        return index;\n    }\n    \n    function ownerOf(uint256 index) constant returns (address owner) { owner = loans[index].lender; }\n    function getTotalLoans() constant returns (uint256) { return loans.length; }\n    function getOracle(uint index) constant returns (Oracle) { return loans[index].oracle; }\n    function getBorrower(uint index) constant returns (address) { return loans[index].borrower; }\n    function getCosigner(uint index) constant returns (address) { return loans[index].cosigner; }\n    function getCreator(uint index) constant returns (address) { return loans[index].creator; }\n    function getAmount(uint index) constant returns (uint256) { return loans[index].amount; }\n    function getPunitoryInterest(uint index) constant returns (uint256) { return loans[index].punitoryInterest; }\n    function getInterestTimestamp(uint index) constant returns (uint256) { return loans[index].interestTimestamp; }\n    function getPaid(uint index) constant returns (uint256) { return loans[index].paid; }\n    function getInterestRate(uint index) constant returns (uint256) { return loans[index].interestRate; }\n    function getInterestRatePunitory(uint index) constant returns (uint256) { return loans[index].interestRatePunitory; }\n    function getDueTime(uint index) constant returns (uint256) { return loans[index].dueTime; }\n    function getDuesIn(uint index) constant returns (uint256) { return loans[index].duesIn; }\n    function getCancelableAt(uint index) constant returns (uint256) { return loans[index].cancelableAt; }\n    function getApprobation(uint index, address _address) constant returns (bool) { return loans[index].approbations[_address]; }\n    function getStatus(uint index) constant returns (Status) { return loans[index].status; }\n    function getLenderBalance(uint index) constant returns (uint256) { return loans[index].lenderBalance; }\n    function getApprovedTransfer(uint index) constant returns (address) {return loans[index].approvedTransfer; }\n    function getCurrency(uint index) constant returns (bytes32) { return loans[index].currency; }\n    function getExpirationRequest(uint index) constant returns (uint256) { return loans[index].expirationRequest; }\n    function getInterest(uint index) constant returns (uint256) { return loans[index].interest; }\n\n    /**\n        @param index Index of the loan\n\n        @return true if the loan has been approved by the borrower and cosigner.\n    */\n    function isApproved(uint index) constant returns (bool) {\n        Loan storage loan = loans[index];\n        return loan.approbations[loan.borrower];\n    }\n\n    /**\n        @dev Called by the members of the loan to show that they agree with the terms of the loan; the borrower\n        must call this method before any lender could call the method \"lend\".\n            \n        Any address can call this method to be added to the \"approbations\" mapping.\n\n        @param index Index of the loan\n\n        @return true if the approve was done successfully\n    */\n    function approveLoan(uint index) public returns(bool) {\n        Loan storage loan = loans[index];\n        require(loan.status == Status.initial);\n        loan.approbations[msg.sender] = true;\n        ApprovedBy(index, msg.sender);\n        return true;\n    }\n\n    /**\n        @dev Performs the lend of the RCN equivalent to the requested amount, and transforms the msg.sender in the new lender.\n\n        The loan must be previously approved by the borrower; before calling this function, the lender candidate must \n        call the \"approve\" function on the RCN Token, specifying an amount sufficient enough to pay the equivalent of\n        the requested amount, and the cosigner fee.\n        \n        @param index Index of the loan\n        @param oracleData Data required by the oracle to return the rate, the content of this field must be provided\n            by the url exposed in the url() method of the oracle.\n        @param cosigner Address of the cosigner, 0x0 for lending without cosigner.\n        @param cosignerData Data required by the cosigner to process the request.\n\n        @return true if the lend was done successfully\n    */\n    function lend(uint index, bytes oracleData, Cosigner cosigner, bytes cosignerData) public returns (bool) {\n        Loan storage loan = loans[index];\n\n        require(loan.status == Status.initial);\n        require(isApproved(index));\n        require(block.timestamp <= loan.expirationRequest);\n\n        loan.lender = msg.sender;\n        loan.dueTime = safeAdd(block.timestamp, loan.duesIn);\n        loan.interestTimestamp = block.timestamp;\n        loan.status = Status.lent;\n        \n        if (loan.cancelableAt > 0)\n            internalAddInterest(loan, safeAdd(block.timestamp, loan.cancelableAt));\n\n        uint256 rate = getRate(loan, oracleData);\n\n        if (cosigner != address(0)) {\n            // The cosigner it's temporary set to the next address (cosigner + 2), it's expected that the cosigner will\n            // call the method \"cosign\" to accept the conditions; that method also sets the cosigner to the right\n            // address. If that does not happen, the transaction fails.\n            loan.cosigner = address(uint256(cosigner) + 2);\n            require(cosigner.requestCosign(this, index, cosignerData, oracleData));\n            require(loan.cosigner == address(cosigner));\n        }\n        \n        require(rcn.transferFrom(msg.sender, loan.borrower, safeMult(loan.amount, rate)));\n        \n        // ERC721, create new loan and transfer it to the lender\n        Transfer(0x0, loan.lender, index);\n        activeLoans += 1;\n        lendersBalance[loan.lender] += 1;\n        Lent(index, loan.lender, cosigner);\n\n        return true;\n    }\n\n    /**\n        @dev The cosigner must call this method to accept the conditions of a loan, this method pays the cosigner his fee\n\n        @param index Index of the loan\n        @param cost Fee set by the cosigner\n\n        @return true If the cosign was successfull\n    */\n    function cosign(uint index, uint256 cost) external returns (bool) {\n        Loan storage loan = loans[index];\n        require(loan.status == Status.lent && (loan.dueTime - loan.duesIn) == block.timestamp);\n        require(loan.cosigner != address(0));\n        require(loan.cosigner == address(uint256(msg.sender) + 2));\n        loan.cosigner = msg.sender;\n        require(rcn.transferFrom(loan.lender, msg.sender, cost));\n        return true;\n    }\n\n    /**\n        @dev Destroys a loan, the borrower could call this method if they performed an accidental or regretted \n        \"approve\" of the loan, this method only works for them if the loan is in \"pending\" status.\n\n        The lender can call this method at any moment, in case of a loan with status \"lent\" the lender is pardoning \n        the debt. \n\n        @param index Index of the loan\n\n        @return true if the destroy was done successfully\n    */\n    function destroy(uint index) public returns (bool) {\n        Loan storage loan = loans[index];\n        require(loan.status != Status.destroyed);\n        require(msg.sender == loan.lender || (msg.sender == loan.borrower && loan.status == Status.initial));\n        DestroyedBy(index, msg.sender);\n\n        // ERC721, remove loan from circulation\n        if (loan.status != Status.initial) {\n            lendersBalance[loan.lender] -= 1;\n            activeLoans -= 1;\n            Transfer(loan.lender, 0x0, index);\n        }\n\n        loan.status = Status.destroyed;\n        return true;\n    }\n\n    /**\n        @dev Transfers a loan to a different lender, the caller must be the current lender or previously being\n        approved with the method \"approveTransfer\"; only loans with the Status.lent status can be transfered.\n\n        @param index Index of the loan\n        @param to New lender\n\n        @return true if the transfer was done successfully\n    */\n    function transfer(address to, uint256 index) public returns (bool) {\n        Loan storage loan = loans[index];\n        \n        require(loan.status != Status.destroyed && loan.status != Status.paid);\n        require(msg.sender == loan.lender || msg.sender == loan.approvedTransfer);\n        require(to != address(0));\n        loan.lender = to;\n        loan.approvedTransfer = address(0);\n\n        // ERC721, transfer loan to another address\n        lendersBalance[msg.sender] -= 1;\n        lendersBalance[to] += 1;\n        Transfer(loan.lender, to, index);\n\n        return true;\n    }\n\n    /**\n        @dev ERC721 method, transfers the loan to the msg.sender, the msg.sender must be approved using the \n        \"approve\" method.\n\n        @return true if the transfer was successfull\n    */\n    function takeOwnership(uint256 _index) public returns (bool) {\n        return transfer(msg.sender, _index);\n    }\n\n    /**\n        @dev Approves the transfer of a given loan in the name of the lender, the behavior of this function is similar to\n        \"approve\" in the ERC20 standard, but only one approved address is allowed at a time.\n\n        The same method can be called passing 0x0 as parameter \"to\" to erase a previously approved address.\n\n        @param to Address allowed to transfer the loan or 0x0 to delete\n        @param index Index of the loan\n\n        @return true if the approve was done successfully\n    */\n    function approve(address to, uint256 index) public returns (bool) {\n        Loan storage loan = loans[index];\n        require(msg.sender == loan.lender);\n        loan.approvedTransfer = to;\n        Approval(msg.sender, to, index);\n        return true;\n    }\n\n    /**\n        @dev Returns the pending amount to complete de payment of the loan, keep in mind that this number increases \n        every second.\n\n        @param index Index of the loan\n\n        @return Aprox pending payment amount\n    */\n    function getPendingAmount(uint index) public constant returns (uint256) {\n        Loan storage loan = loans[index];\n        addInterest(index);\n        return getRawPendingAmount(loan);\n    }\n\n    function getRawPendingAmount(Loan loan) internal returns (uint256) {\n        return safeSubtract(safeAdd(safeAdd(loan.amount, loan.interest), loan.punitoryInterest), loan.paid);\n    }\n\n    /**\n        @dev Calculates the interest of a given amount, interest rate and delta time.\n\n        @param timeDelta Elapsed time\n        @param interestRate Interest rate expressed as the denominator of 10 000 000.\n        @param amount Amount to apply interest\n\n        @return realDelta The real timeDelta applied\n        @return interest The interest gained in the realDelta time\n    */\n    function calculateInterest(uint256 timeDelta, uint256 interestRate, uint256 amount) public constant returns (uint256 realDelta, uint256 interest) {\n        if (amount == 0) {\n            interest = 0;\n            realDelta = timeDelta;\n        } else {\n            interest = safeMult(safeMult(100000, amount), timeDelta) / interestRate;\n            realDelta = safeMult(interest, interestRate) / (amount * 100000);\n        }\n    }\n\n    /**\n        @dev Computes loan interest\n\n        Computes the punitory and non-punitory interest of a given loan and only applies the change.\n        \n        @param loan Loan to compute interest\n        @param timestamp Target absolute unix time to calculate interest.\n    */\n    function internalAddInterest(Loan storage loan, uint256 timestamp) internal {\n        if (timestamp > loan.interestTimestamp) {\n            uint256 newInterest = loan.interest;\n            uint256 newPunitoryInterest = loan.punitoryInterest;\n\n            uint256 newTimestamp;\n            uint256 realDelta;\n            uint256 calculatedInterest;\n\n            uint256 deltaTime;\n            uint256 pending;\n\n            uint256 endNonPunitory = min(timestamp, loan.dueTime);\n            if (endNonPunitory > loan.interestTimestamp) {\n                deltaTime = endNonPunitory - loan.interestTimestamp;\n\n                if (loan.paid < loan.amount) {\n                    pending = loan.amount - loan.paid;\n                } else {\n                    pending = 0;\n                }\n\n                (realDelta, calculatedInterest) = calculateInterest(deltaTime, loan.interestRate, pending);\n                newInterest = safeAdd(calculatedInterest, newInterest);\n                newTimestamp = loan.interestTimestamp + realDelta;\n            }\n\n            if (timestamp > loan.dueTime) {\n                uint256 startPunitory = max(loan.dueTime, loan.interestTimestamp);\n                deltaTime = timestamp - startPunitory;\n\n                uint256 debt = safeAdd(loan.amount, newInterest);\n                pending = min(debt, safeSubtract(safeAdd(debt, newPunitoryInterest), loan.paid));\n\n                (realDelta, calculatedInterest) = calculateInterest(deltaTime, loan.interestRatePunitory, pending);\n                newPunitoryInterest = safeAdd(newPunitoryInterest, calculatedInterest);\n                newTimestamp = startPunitory + realDelta;\n            }\n            \n            if (newInterest != loan.interest || newPunitoryInterest != loan.punitoryInterest) {\n                loan.interestTimestamp = newTimestamp;\n                loan.interest = newInterest;\n                loan.punitoryInterest = newPunitoryInterest;\n            }\n        }\n    }\n\n    /**\n        @dev Computes loan interest only up to current unix time\n\n        @param timestamp Target absolute unix time to calculate interest.\n    */\n    function addInterestUpTo(Loan storage loan, uint256 timestamp) internal {\n        require(loan.status == Status.lent);\n        if (timestamp <= block.timestamp) {\n            internalAddInterest(loan, timestamp);\n        }\n    }\n\n    /**\n        @dev Updates the loan accumulated interests up to the current Unix time.\n        \n        @param index Index of the loan\n    */\n    function addInterest(uint index) public {\n        Loan storage loan = loans[index];\n        addInterestUpTo(loan, block.timestamp);\n    }\n    \n    /**\n        @dev Pay loan\n\n        Realizes a payment of a given Loan, before performing the payment the accumulated\n        interest is computed and added to the total pending amount.\n\n        Before calling this function, the msg.sender must call the \"approve\" function on the RCN Token, specifying an amount\n        sufficient enough to pay the equivalent of the desired payment and the oracle fee.\n\n        Because it is difficult or even impossible to know in advance how much RCN are going to be spent on the\n        transaction*, we recommend performing the \"approve\" using an amount 5% superior to the wallet estimated\n        spending. If the RCN spent results to be less, the extra tokens are never debited from the msg.sender.\n\n        * The RCN rate can fluctuate on the same block, and it is impossible to know in advance the exact time of the\n        confirmation of the transaction. \n\n        If the paid pending amount equals zero, the loan changes status to \"paid\" and it is considered closed.\n\n        @param index Index of the loan\n        @param _amount Amount to pay, specified in the loan currency; or in RCN if the loan has no oracle\n        @param _from The identity of the payer\n        @param oracleData Data required by the oracle to return the rate, the content of this field must be provided\n            by the url exposed in the url() method of the oracle.\n            \n        @return true if the payment was executed successfully\n    */\n    function pay(uint index, uint256 _amount, address _from, bytes oracleData) public returns (bool) {\n        Loan storage loan = loans[index];\n\n        require(loan.status == Status.lent);\n        addInterest(index);\n        uint256 toPay = min(getPendingAmount(index), _amount);\n        PartialPayment(index, msg.sender, _from, toPay);\n\n        loan.paid = safeAdd(loan.paid, toPay);\n\n        if (getRawPendingAmount(loan) == 0) {\n            TotalPayment(index);\n            loan.status = Status.paid;\n\n            // ERC721, remove loan from circulation\n            lendersBalance[loan.lender] -= 1;\n            activeLoans -= 1;\n            Transfer(loan.lender, 0x0, index);\n        }\n\n        uint256 rate = getRate(loan, oracleData);\n        uint256 transferValue = safeMult(toPay, rate);\n        lockTokens(rcn, transferValue);\n        require(rcn.transferFrom(msg.sender, this, transferValue));\n        loan.lenderBalance = safeAdd(transferValue, loan.lenderBalance);\n\n        return true;\n    }\n\n    /**\n        @dev Retrieves the rate corresponding of the loan oracle, if the loan has no oracle the rate is 1\n\n        @param loan The loan with the cosigner\n        @param data Data required by the oracle\n\n        @return The rate of the oracle\n    */\n    function getRate(Loan loan, bytes data) internal returns (uint256) {\n        if (loan.oracle == address(0)) {\n            return 1;\n        } else {\n            return loan.oracle.getRate(loan.currency, data);\n        }\n    }\n\n    /**\n        @dev Withdraw lender funds\n\n        When a loan is paid, the funds are not transferred automatically to the lender, the funds are stored on the\n        engine contract, and the lender must call this function specifying the amount desired to transfer and the \n        destination.\n\n        This behavior is defined to allow the temporary transfer of the loan to a smart contract, without worrying that\n        the contract will receive tokens that are not traceable; and it allows the development of decentralized \n        autonomous organizations.\n\n        @param index Index of the loan\n        @param to Destination of the wiwthdraw funds\n        @param amount Amount to withdraw, in RCN\n\n        @return true if the withdraw was executed successfully\n    */\n    function withdrawal(uint index, address to, uint256 amount) public returns (bool) {\n        Loan storage loan = loans[index];\n        require(msg.sender == loan.lender);\n        loan.lenderBalance = safeSubtract(loan.lenderBalance, amount);\n        require(rcn.transfer(to, amount));\n        unlockTokens(rcn, amount);\n        return true;\n    }\n\n    function withdrawalRange(uint256 fromIndex, uint256 toIndex, address to) public returns (uint256) {\n        uint256 loanId;\n        uint256 totalWithdraw = 0;\n\n        for (loanId = fromIndex; loanId <= toIndex; loanId++) {\n            Loan storage loan = loans[loanId];\n            if (loan.lender == msg.sender) {\n                totalWithdraw += loan.lenderBalance;\n                loan.lenderBalance = 0;\n            }\n        }\n\n        require(rcn.transfer(to, totalWithdraw));\n        unlockTokens(rcn, totalWithdraw);\n        \n        return totalWithdraw;\n    }\n\n    function withdrawalList(uint256[] memory loanIds, address to) public returns (uint256) {\n        uint256 inputId;\n        uint256 totalWithdraw = 0;\n\n        for (inputId = 0; inputId < loanIds.length; inputId++) {\n            Loan storage loan = loans[loanIds[inputId]];\n            if (loan.lender == msg.sender) {\n                totalWithdraw += loan.lenderBalance;\n                loan.lenderBalance = 0;\n            }\n        }\n\n        require(rcn.transfer(to, totalWithdraw));\n        unlockTokens(rcn, totalWithdraw);\n\n        return totalWithdraw;\n    }\n\n    /**\n        @dev Deprecates the engine, locks the creation of new loans.\n    */\n    function setDeprecated(bool _deprecated) public onlyOwner {\n        deprecated = _deprecated;\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinfabrik-RCN Network Smart Contract Audit/rcn-network-3ded36151ad55543d16c354e70161852de4061d0/contracts/NanoLoanEngine.sol",
        "vulnerability": "Assertion Failure",
        "check": "FP",
        "response": "Answer: No\nReason: The contract does not contain any explicit assert statements causing assertion failures."
    },
    {
        "code_segment": "contract NanoLoanEngine is ERC721, Engine, Ownable, TokenLockable {\n    uint256 public constant VERSION = 202;\n    string public constant VERSION_NAME = \"Basalt\";\n\n    uint256 private activeLoans = 0;\n    mapping(address => uint256) private lendersBalance;\n\n    function name() constant returns (string _name) {\n        _name = \"RCN - Nano loan engine - Basalt 202\";\n    }\n\n    function symbol() constant returns (string _symbol) {\n        _symbol = \"RCN-NLE-202\";\n    }\n\n    function totalSupply() constant returns (uint _totalSupply) {\n        _totalSupply = activeLoans;\n    }\n\n    function balanceOf(address _owner) constant returns (uint _balance) {\n        _balance = lendersBalance[_owner];\n    }\n\n    function tokenOfOwnerByIndex(address _owner, uint256 _index) constant returns (uint tokenId) {\n        uint256 tokenCount = balanceOf(_owner);\n\n        if (tokenCount == 0 || _index >= tokenCount) {\n            // Fail transaction\n            revert();\n        } else {\n            uint256 totalLoans = totalSupply();\n            uint256 resultIndex = 0;\n\n            uint256 loanId;\n            // SWC-128-DoS With Block Gas Limit: L46\n            for (loanId = 0; loanId <= totalLoans; loanId++) {\n                if (loans[loanId].lender == _owner && loans[loanId].status == Status.lent) {\n                    if (resultIndex == _index) {\n                        return loanId;\n                    }\n                    resultIndex++;\n                }\n            }\n\n            revert();\n        }\n    }\n\n    function tokensOfOwner(address _owner) external constant returns(uint256[] ownerTokens) {\n        uint256 tokenCount = balanceOf(_owner);\n\n        if (tokenCount == 0) {\n            // Return an empty array\n            return new uint256[](0);\n        } else {\n            uint256[] memory result = new uint256[](tokenCount);\n            uint256 totalLoans = totalSupply();\n            uint256 resultIndex = 0;\n\n            uint256 loanId;\n\n            for (loanId = 0; loanId <= totalLoans; loanId++) {\n                if (loans[loanId].lender == _owner && loans[loanId].status == Status.lent) {\n                    result[resultIndex] = loanId;\n                    resultIndex++;\n                }\n            }\n\n            return result;\n        }\n    }\n    \n    Token public rcn;\n    bool public deprecated;\n\n    event CreatedLoan(uint _index, address _borrower, address _creator);\n    event ApprovedBy(uint _index, address _address);\n    event Lent(uint _index, address _lender, address _cosigner);\n    event DestroyedBy(uint _index, address _address);\n    event PartialPayment(uint _index, address _sender, address _from, uint256 _amount);\n    event TotalPayment(uint _index);\n\n    function NanoLoanEngine(Token _rcn) public {\n        owner = msg.sender;\n        rcn = _rcn;\n    }\n\n    struct Loan {\n        Status status;\n        Oracle oracle;\n\n        address borrower;\n        address lender;\n        address creator;\n        address cosigner;\n        \n        uint256 amount;\n        uint256 interest;\n        uint256 punitoryInterest;\n        uint256 interestTimestamp;\n        uint256 paid;\n        uint256 interestRate;\n        uint256 interestRatePunitory;\n        uint256 dueTime;\n        uint256 duesIn;\n\n        bytes32 currency;\n        uint256 cancelableAt;\n        uint256 lenderBalance;\n\n        address approvedTransfer;\n        uint256 expirationRequest;\n\n        mapping(address => bool) approbations;\n    }\n\n    Loan[] private loans;\n\n    /**\n        @dev Creates a loan request, the loan can be generated with any borrower, cosigner, and conditions; if the \n        cosigner and borrower agree they must call the \"approve\" function.\n\n        The creator of the loan is the caller of this function; this is useful to track which wallet created the loan.\n\n        @param _oracleContract Address of the Oracle contract, if the loan does not use any oracle, this field should be 0x0.\n        @param _borrower Address of the borrower\n        @param _currency The currency to use with the oracle, the currency code is generated with the following formula,\n            keccak256(ticker,decimals).\n        @param _amount The requested amount; currency and unit are defined by the Oracle, if there is no Oracle present\n            the currency is RCN, and the unit is wei.\n        @param _interestRate The non-punitory interest rate by second, defined as a denominator of 10 000 000.\n        @param _interestRatePunitory The punitory interest rate by second, defined as a denominator of 10 000 000.\n            Ej: interestRate 11108571428571 = 28% Anual interest\n        @param _duesIn The time in seconds that the borrower has in order to pay the debt after the lender lends the money.\n        @param _cancelableAt Delta in seconds specifying how much interest should be added in advance, if the borrower pays \n        entirely or partially the loan before this term, no extra interest will be deducted.\n        @param _expirationRequest Timestamp of when the loan request expires, if the loan is not filled before this date, \n            the request is no longer valid.\n    */\n    function createLoan(Oracle _oracleContract, address _borrower, bytes32 _currency, uint256 _amount, uint256 _interestRate,\n        uint256 _interestRatePunitory, uint256 _duesIn, uint256 _cancelableAt, uint256 _expirationRequest) returns (uint256) {\n\n        require(!deprecated);\n        require(_cancelableAt <= _duesIn);\n        require(_oracleContract != address(0) || _currency == 0x0);\n        require(_borrower != address(0));\n        require(_amount != 0);\n        require(_interestRatePunitory != 0);\n        require(_interestRate != 0);\n        require(_expirationRequest > block.timestamp);\n\n        var loan = Loan(Status.initial, _oracleContract, _borrower, 0x0, msg.sender, 0x0, _amount, 0, 0, 0, 0, _interestRate,\n            _interestRatePunitory, 0, _duesIn, _currency, _cancelableAt, 0, 0x0, _expirationRequest);\n        uint index = loans.push(loan) - 1;\n        CreatedLoan(index, _borrower, msg.sender);\n\n        if (msg.sender == _borrower) {\n            approveLoan(index);\n        }\n\n        return index;\n    }\n    \n    function ownerOf(uint256 index) constant returns (address owner) { owner = loans[index].lender; }\n    function getTotalLoans() constant returns (uint256) { return loans.length; }\n    function getOracle(uint index) constant returns (Oracle) { return loans[index].oracle; }\n    function getBorrower(uint index) constant returns (address) { return loans[index].borrower; }\n    function getCosigner(uint index) constant returns (address) { return loans[index].cosigner; }\n    function getCreator(uint index) constant returns (address) { return loans[index].creator; }\n    function getAmount(uint index) constant returns (uint256) { return loans[index].amount; }\n    function getPunitoryInterest(uint index) constant returns (uint256) { return loans[index].punitoryInterest; }\n    function getInterestTimestamp(uint index) constant returns (uint256) { return loans[index].interestTimestamp; }\n    function getPaid(uint index) constant returns (uint256) { return loans[index].paid; }\n    function getInterestRate(uint index) constant returns (uint256) { return loans[index].interestRate; }\n    function getInterestRatePunitory(uint index) constant returns (uint256) { return loans[index].interestRatePunitory; }\n    function getDueTime(uint index) constant returns (uint256) { return loans[index].dueTime; }\n    function getDuesIn(uint index) constant returns (uint256) { return loans[index].duesIn; }\n    function getCancelableAt(uint index) constant returns (uint256) { return loans[index].cancelableAt; }\n    function getApprobation(uint index, address _address) constant returns (bool) { return loans[index].approbations[_address]; }\n    function getStatus(uint index) constant returns (Status) { return loans[index].status; }\n    function getLenderBalance(uint index) constant returns (uint256) { return loans[index].lenderBalance; }\n    function getApprovedTransfer(uint index) constant returns (address) {return loans[index].approvedTransfer; }\n    function getCurrency(uint index) constant returns (bytes32) { return loans[index].currency; }\n    function getExpirationRequest(uint index) constant returns (uint256) { return loans[index].expirationRequest; }\n    function getInterest(uint index) constant returns (uint256) { return loans[index].interest; }\n\n    /**\n        @param index Index of the loan\n\n        @return true if the loan has been approved by the borrower and cosigner.\n    */\n    function isApproved(uint index) constant returns (bool) {\n        Loan storage loan = loans[index];\n        return loan.approbations[loan.borrower];\n    }\n\n    /**\n        @dev Called by the members of the loan to show that they agree with the terms of the loan; the borrower\n        must call this method before any lender could call the method \"lend\".\n            \n        Any address can call this method to be added to the \"approbations\" mapping.\n\n        @param index Index of the loan\n\n        @return true if the approve was done successfully\n    */\n    function approveLoan(uint index) public returns(bool) {\n        Loan storage loan = loans[index];\n        require(loan.status == Status.initial);\n        loan.approbations[msg.sender] = true;\n        ApprovedBy(index, msg.sender);\n        return true;\n    }\n\n    /**\n        @dev Performs the lend of the RCN equivalent to the requested amount, and transforms the msg.sender in the new lender.\n\n        The loan must be previously approved by the borrower; before calling this function, the lender candidate must \n        call the \"approve\" function on the RCN Token, specifying an amount sufficient enough to pay the equivalent of\n        the requested amount, and the cosigner fee.\n        \n        @param index Index of the loan\n        @param oracleData Data required by the oracle to return the rate, the content of this field must be provided\n            by the url exposed in the url() method of the oracle.\n        @param cosigner Address of the cosigner, 0x0 for lending without cosigner.\n        @param cosignerData Data required by the cosigner to process the request.\n\n        @return true if the lend was done successfully\n    */\n    function lend(uint index, bytes oracleData, Cosigner cosigner, bytes cosignerData) public returns (bool) {\n        Loan storage loan = loans[index];\n\n        require(loan.status == Status.initial);\n        require(isApproved(index));\n        require(block.timestamp <= loan.expirationRequest);\n\n        loan.lender = msg.sender;\n        loan.dueTime = safeAdd(block.timestamp, loan.duesIn);\n        loan.interestTimestamp = block.timestamp;\n        loan.status = Status.lent;\n        \n        if (loan.cancelableAt > 0)\n            internalAddInterest(loan, safeAdd(block.timestamp, loan.cancelableAt));\n\n        uint256 rate = getRate(loan, oracleData);\n\n        if (cosigner != address(0)) {\n            // The cosigner it's temporary set to the next address (cosigner + 2), it's expected that the cosigner will\n            // call the method \"cosign\" to accept the conditions; that method also sets the cosigner to the right\n            // address. If that does not happen, the transaction fails.\n            loan.cosigner = address(uint256(cosigner) + 2);\n            require(cosigner.requestCosign(this, index, cosignerData, oracleData));\n            require(loan.cosigner == address(cosigner));\n        }\n        \n        require(rcn.transferFrom(msg.sender, loan.borrower, safeMult(loan.amount, rate)));\n        \n        // ERC721, create new loan and transfer it to the lender\n        Transfer(0x0, loan.lender, index);\n        activeLoans += 1;\n        lendersBalance[loan.lender] += 1;\n        Lent(index, loan.lender, cosigner);\n\n        return true;\n    }\n\n    /**\n        @dev The cosigner must call this method to accept the conditions of a loan, this method pays the cosigner his fee\n\n        @param index Index of the loan\n        @param cost Fee set by the cosigner\n\n        @return true If the cosign was successfull\n    */\n    function cosign(uint index, uint256 cost) external returns (bool) {\n        Loan storage loan = loans[index];\n        require(loan.status == Status.lent && (loan.dueTime - loan.duesIn) == block.timestamp);\n        require(loan.cosigner != address(0));\n        require(loan.cosigner == address(uint256(msg.sender) + 2));\n        loan.cosigner = msg.sender;\n        require(rcn.transferFrom(loan.lender, msg.sender, cost));\n        return true;\n    }\n\n    /**\n        @dev Destroys a loan, the borrower could call this method if they performed an accidental or regretted \n        \"approve\" of the loan, this method only works for them if the loan is in \"pending\" status.\n\n        The lender can call this method at any moment, in case of a loan with status \"lent\" the lender is pardoning \n        the debt. \n\n        @param index Index of the loan\n\n        @return true if the destroy was done successfully\n    */\n    function destroy(uint index) public returns (bool) {\n        Loan storage loan = loans[index];\n        require(loan.status != Status.destroyed);\n        require(msg.sender == loan.lender || (msg.sender == loan.borrower && loan.status == Status.initial));\n        DestroyedBy(index, msg.sender);\n\n        // ERC721, remove loan from circulation\n        if (loan.status != Status.initial) {\n            lendersBalance[loan.lender] -= 1;\n            activeLoans -= 1;\n            Transfer(loan.lender, 0x0, index);\n        }\n\n        loan.status = Status.destroyed;\n        return true;\n    }\n\n    /**\n        @dev Transfers a loan to a different lender, the caller must be the current lender or previously being\n        approved with the method \"approveTransfer\"; only loans with the Status.lent status can be transfered.\n\n        @param index Index of the loan\n        @param to New lender\n\n        @return true if the transfer was done successfully\n    */\n    function transfer(address to, uint256 index) public returns (bool) {\n        Loan storage loan = loans[index];\n        \n        require(loan.status != Status.destroyed && loan.status != Status.paid);\n        require(msg.sender == loan.lender || msg.sender == loan.approvedTransfer);\n        require(to != address(0));\n        loan.lender = to;\n        loan.approvedTransfer = address(0);\n\n        // ERC721, transfer loan to another address\n        lendersBalance[msg.sender] -= 1;\n        lendersBalance[to] += 1;\n        Transfer(loan.lender, to, index);\n\n        return true;\n    }\n\n    /**\n        @dev ERC721 method, transfers the loan to the msg.sender, the msg.sender must be approved using the \n        \"approve\" method.\n\n        @return true if the transfer was successfull\n    */\n    function takeOwnership(uint256 _index) public returns (bool) {\n        return transfer(msg.sender, _index);\n    }\n\n    /**\n        @dev Approves the transfer of a given loan in the name of the lender, the behavior of this function is similar to\n        \"approve\" in the ERC20 standard, but only one approved address is allowed at a time.\n\n        The same method can be called passing 0x0 as parameter \"to\" to erase a previously approved address.\n\n        @param to Address allowed to transfer the loan or 0x0 to delete\n        @param index Index of the loan\n\n        @return true if the approve was done successfully\n    */\n    function approve(address to, uint256 index) public returns (bool) {\n        Loan storage loan = loans[index];\n        require(msg.sender == loan.lender);\n        loan.approvedTransfer = to;\n        Approval(msg.sender, to, index);\n        return true;\n    }\n\n    /**\n        @dev Returns the pending amount to complete de payment of the loan, keep in mind that this number increases \n        every second.\n\n        @param index Index of the loan\n\n        @return Aprox pending payment amount\n    */\n    function getPendingAmount(uint index) public constant returns (uint256) {\n        Loan storage loan = loans[index];\n        addInterest(index);\n        return getRawPendingAmount(loan);\n    }\n\n    function getRawPendingAmount(Loan loan) internal returns (uint256) {\n        return safeSubtract(safeAdd(safeAdd(loan.amount, loan.interest), loan.punitoryInterest), loan.paid);\n    }\n\n    /**\n        @dev Calculates the interest of a given amount, interest rate and delta time.\n\n        @param timeDelta Elapsed time\n        @param interestRate Interest rate expressed as the denominator of 10 000 000.\n        @param amount Amount to apply interest\n\n        @return realDelta The real timeDelta applied\n        @return interest The interest gained in the realDelta time\n    */\n    function calculateInterest(uint256 timeDelta, uint256 interestRate, uint256 amount) public constant returns (uint256 realDelta, uint256 interest) {\n        if (amount == 0) {\n            interest = 0;\n            realDelta = timeDelta;\n        } else {\n            interest = safeMult(safeMult(100000, amount), timeDelta) / interestRate;\n            realDelta = safeMult(interest, interestRate) / (amount * 100000);\n        }\n    }\n\n    /**\n        @dev Computes loan interest\n\n        Computes the punitory and non-punitory interest of a given loan and only applies the change.\n        \n        @param loan Loan to compute interest\n        @param timestamp Target absolute unix time to calculate interest.\n    */\n    function internalAddInterest(Loan storage loan, uint256 timestamp) internal {\n        if (timestamp > loan.interestTimestamp) {\n            uint256 newInterest = loan.interest;\n            uint256 newPunitoryInterest = loan.punitoryInterest;\n\n            uint256 newTimestamp;\n            uint256 realDelta;\n            uint256 calculatedInterest;\n\n            uint256 deltaTime;\n            uint256 pending;\n\n            uint256 endNonPunitory = min(timestamp, loan.dueTime);\n            if (endNonPunitory > loan.interestTimestamp) {\n                deltaTime = endNonPunitory - loan.interestTimestamp;\n\n                if (loan.paid < loan.amount) {\n                    pending = loan.amount - loan.paid;\n                } else {\n                    pending = 0;\n                }\n\n                (realDelta, calculatedInterest) = calculateInterest(deltaTime, loan.interestRate, pending);\n                newInterest = safeAdd(calculatedInterest, newInterest);\n                newTimestamp = loan.interestTimestamp + realDelta;\n            }\n\n            if (timestamp > loan.dueTime) {\n                uint256 startPunitory = max(loan.dueTime, loan.interestTimestamp);\n                deltaTime = timestamp - startPunitory;\n\n                uint256 debt = safeAdd(loan.amount, newInterest);\n                pending = min(debt, safeSubtract(safeAdd(debt, newPunitoryInterest), loan.paid));\n\n                (realDelta, calculatedInterest) = calculateInterest(deltaTime, loan.interestRatePunitory, pending);\n                newPunitoryInterest = safeAdd(newPunitoryInterest, calculatedInterest);\n                newTimestamp = startPunitory + realDelta;\n            }\n            \n            if (newInterest != loan.interest || newPunitoryInterest != loan.punitoryInterest) {\n                loan.interestTimestamp = newTimestamp;\n                loan.interest = newInterest;\n                loan.punitoryInterest = newPunitoryInterest;\n            }\n        }\n    }\n\n    /**\n        @dev Computes loan interest only up to current unix time\n\n        @param timestamp Target absolute unix time to calculate interest.\n    */\n    function addInterestUpTo(Loan storage loan, uint256 timestamp) internal {\n        require(loan.status == Status.lent);\n        if (timestamp <= block.timestamp) {\n            internalAddInterest(loan, timestamp);\n        }\n    }\n\n    /**\n        @dev Updates the loan accumulated interests up to the current Unix time.\n        \n        @param index Index of the loan\n    */\n    function addInterest(uint index) public {\n        Loan storage loan = loans[index];\n        addInterestUpTo(loan, block.timestamp);\n    }\n    \n    /**\n        @dev Pay loan\n\n        Realizes a payment of a given Loan, before performing the payment the accumulated\n        interest is computed and added to the total pending amount.\n\n        Before calling this function, the msg.sender must call the \"approve\" function on the RCN Token, specifying an amount\n        sufficient enough to pay the equivalent of the desired payment and the oracle fee.\n\n        Because it is difficult or even impossible to know in advance how much RCN are going to be spent on the\n        transaction*, we recommend performing the \"approve\" using an amount 5% superior to the wallet estimated\n        spending. If the RCN spent results to be less, the extra tokens are never debited from the msg.sender.\n\n        * The RCN rate can fluctuate on the same block, and it is impossible to know in advance the exact time of the\n        confirmation of the transaction. \n\n        If the paid pending amount equals zero, the loan changes status to \"paid\" and it is considered closed.\n\n        @param index Index of the loan\n        @param _amount Amount to pay, specified in the loan currency; or in RCN if the loan has no oracle\n        @param _from The identity of the payer\n        @param oracleData Data required by the oracle to return the rate, the content of this field must be provided\n            by the url exposed in the url() method of the oracle.\n            \n        @return true if the payment was executed successfully\n    */\n    function pay(uint index, uint256 _amount, address _from, bytes oracleData) public returns (bool) {\n        Loan storage loan = loans[index];\n\n        require(loan.status == Status.lent);\n        addInterest(index);\n        uint256 toPay = min(getPendingAmount(index), _amount);\n        PartialPayment(index, msg.sender, _from, toPay);\n\n        loan.paid = safeAdd(loan.paid, toPay);\n\n        if (getRawPendingAmount(loan) == 0) {\n            TotalPayment(index);\n            loan.status = Status.paid;\n\n            // ERC721, remove loan from circulation\n            lendersBalance[loan.lender] -= 1;\n            activeLoans -= 1;\n            Transfer(loan.lender, 0x0, index);\n        }\n\n        uint256 rate = getRate(loan, oracleData);\n        uint256 transferValue = safeMult(toPay, rate);\n        lockTokens(rcn, transferValue);\n        require(rcn.transferFrom(msg.sender, this, transferValue));\n        loan.lenderBalance = safeAdd(transferValue, loan.lenderBalance);\n\n        return true;\n    }\n\n    /**\n        @dev Retrieves the rate corresponding of the loan oracle, if the loan has no oracle the rate is 1\n\n        @param loan The loan with the cosigner\n        @param data Data required by the oracle\n\n        @return The rate of the oracle\n    */\n    function getRate(Loan loan, bytes data) internal returns (uint256) {\n        if (loan.oracle == address(0)) {\n            return 1;\n        } else {\n            return loan.oracle.getRate(loan.currency, data);\n        }\n    }\n\n    /**\n        @dev Withdraw lender funds\n\n        When a loan is paid, the funds are not transferred automatically to the lender, the funds are stored on the\n        engine contract, and the lender must call this function specifying the amount desired to transfer and the \n        destination.\n\n        This behavior is defined to allow the temporary transfer of the loan to a smart contract, without worrying that\n        the contract will receive tokens that are not traceable; and it allows the development of decentralized \n        autonomous organizations.\n\n        @param index Index of the loan\n        @param to Destination of the wiwthdraw funds\n        @param amount Amount to withdraw, in RCN\n\n        @return true if the withdraw was executed successfully\n    */\n    function withdrawal(uint index, address to, uint256 amount) public returns (bool) {\n        Loan storage loan = loans[index];\n        require(msg.sender == loan.lender);\n        loan.lenderBalance = safeSubtract(loan.lenderBalance, amount);\n        require(rcn.transfer(to, amount));\n        unlockTokens(rcn, amount);\n        return true;\n    }\n\n    function withdrawalRange(uint256 fromIndex, uint256 toIndex, address to) public returns (uint256) {\n        uint256 loanId;\n        uint256 totalWithdraw = 0;\n\n        for (loanId = fromIndex; loanId <= toIndex; loanId++) {\n            Loan storage loan = loans[loanId];\n            if (loan.lender == msg.sender) {\n                totalWithdraw += loan.lenderBalance;\n                loan.lenderBalance = 0;\n            }\n        }\n\n        require(rcn.transfer(to, totalWithdraw));\n        unlockTokens(rcn, totalWithdraw);\n        \n        return totalWithdraw;\n    }\n\n    function withdrawalList(uint256[] memory loanIds, address to) public returns (uint256) {\n        uint256 inputId;\n        uint256 totalWithdraw = 0;\n\n        for (inputId = 0; inputId < loanIds.length; inputId++) {\n            Loan storage loan = loans[loanIds[inputId]];\n            if (loan.lender == msg.sender) {\n                totalWithdraw += loan.lenderBalance;\n                loan.lenderBalance = 0;\n            }\n        }\n\n        require(rcn.transfer(to, totalWithdraw));\n        unlockTokens(rcn, totalWithdraw);\n\n        return totalWithdraw;\n    }\n\n    /**\n        @dev Deprecates the engine, locks the creation of new loans.\n    */\n    function setDeprecated(bool _deprecated) public onlyOwner {\n        deprecated = _deprecated;\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinfabrik-RCN Network Smart Contract Audit/rcn-network-3ded36151ad55543d16c354e70161852de4061d0/contracts/NanoLoanEngine.sol",
        "vulnerability": "Assertion Failure",
        "check": "FP",
        "response": "Answer: No  \nReason: The code does not contain `assert` statements, which are required to have an assertion failure vulnerability."
    },
    {
        "code_segment": "contract NanoLoanEngine is ERC721, Engine, Ownable, TokenLockable {\n    uint256 public constant VERSION = 202;\n    string public constant VERSION_NAME = \"Basalt\";\n\n    uint256 private activeLoans = 0;\n    mapping(address => uint256) private lendersBalance;\n\n    function name() constant returns (string _name) {\n        _name = \"RCN - Nano loan engine - Basalt 202\";\n    }\n\n    function symbol() constant returns (string _symbol) {\n        _symbol = \"RCN-NLE-202\";\n    }\n\n    function totalSupply() constant returns (uint _totalSupply) {\n        _totalSupply = activeLoans;\n    }\n\n    function balanceOf(address _owner) constant returns (uint _balance) {\n        _balance = lendersBalance[_owner];\n    }\n\n    function tokenOfOwnerByIndex(address _owner, uint256 _index) constant returns (uint tokenId) {\n        uint256 tokenCount = balanceOf(_owner);\n\n        if (tokenCount == 0 || _index >= tokenCount) {\n            // Fail transaction\n            revert();\n        } else {\n            uint256 totalLoans = totalSupply();\n            uint256 resultIndex = 0;\n\n            uint256 loanId;\n            // SWC-128-DoS With Block Gas Limit: L46\n            for (loanId = 0; loanId <= totalLoans; loanId++) {\n                if (loans[loanId].lender == _owner && loans[loanId].status == Status.lent) {\n                    if (resultIndex == _index) {\n                        return loanId;\n                    }\n                    resultIndex++;\n                }\n            }\n\n            revert();\n        }\n    }\n\n    function tokensOfOwner(address _owner) external constant returns(uint256[] ownerTokens) {\n        uint256 tokenCount = balanceOf(_owner);\n\n        if (tokenCount == 0) {\n            // Return an empty array\n            return new uint256[](0);\n        } else {\n            uint256[] memory result = new uint256[](tokenCount);\n            uint256 totalLoans = totalSupply();\n            uint256 resultIndex = 0;\n\n            uint256 loanId;\n\n            for (loanId = 0; loanId <= totalLoans; loanId++) {\n                if (loans[loanId].lender == _owner && loans[loanId].status == Status.lent) {\n                    result[resultIndex] = loanId;\n                    resultIndex++;\n                }\n            }\n\n            return result;\n        }\n    }\n    \n    Token public rcn;\n    bool public deprecated;\n\n    event CreatedLoan(uint _index, address _borrower, address _creator);\n    event ApprovedBy(uint _index, address _address);\n    event Lent(uint _index, address _lender, address _cosigner);\n    event DestroyedBy(uint _index, address _address);\n    event PartialPayment(uint _index, address _sender, address _from, uint256 _amount);\n    event TotalPayment(uint _index);\n\n    function NanoLoanEngine(Token _rcn) public {\n        owner = msg.sender;\n        rcn = _rcn;\n    }\n\n    struct Loan {\n        Status status;\n        Oracle oracle;\n\n        address borrower;\n        address lender;\n        address creator;\n        address cosigner;\n        \n        uint256 amount;\n        uint256 interest;\n        uint256 punitoryInterest;\n        uint256 interestTimestamp;\n        uint256 paid;\n        uint256 interestRate;\n        uint256 interestRatePunitory;\n        uint256 dueTime;\n        uint256 duesIn;\n\n        bytes32 currency;\n        uint256 cancelableAt;\n        uint256 lenderBalance;\n\n        address approvedTransfer;\n        uint256 expirationRequest;\n\n        mapping(address => bool) approbations;\n    }\n\n    Loan[] private loans;\n\n    /**\n        @dev Creates a loan request, the loan can be generated with any borrower, cosigner, and conditions; if the \n        cosigner and borrower agree they must call the \"approve\" function.\n\n        The creator of the loan is the caller of this function; this is useful to track which wallet created the loan.\n\n        @param _oracleContract Address of the Oracle contract, if the loan does not use any oracle, this field should be 0x0.\n        @param _borrower Address of the borrower\n        @param _currency The currency to use with the oracle, the currency code is generated with the following formula,\n            keccak256(ticker,decimals).\n        @param _amount The requested amount; currency and unit are defined by the Oracle, if there is no Oracle present\n            the currency is RCN, and the unit is wei.\n        @param _interestRate The non-punitory interest rate by second, defined as a denominator of 10 000 000.\n        @param _interestRatePunitory The punitory interest rate by second, defined as a denominator of 10 000 000.\n            Ej: interestRate 11108571428571 = 28% Anual interest\n        @param _duesIn The time in seconds that the borrower has in order to pay the debt after the lender lends the money.\n        @param _cancelableAt Delta in seconds specifying how much interest should be added in advance, if the borrower pays \n        entirely or partially the loan before this term, no extra interest will be deducted.\n        @param _expirationRequest Timestamp of when the loan request expires, if the loan is not filled before this date, \n            the request is no longer valid.\n    */\n    function createLoan(Oracle _oracleContract, address _borrower, bytes32 _currency, uint256 _amount, uint256 _interestRate,\n        uint256 _interestRatePunitory, uint256 _duesIn, uint256 _cancelableAt, uint256 _expirationRequest) returns (uint256) {\n\n        require(!deprecated);\n        require(_cancelableAt <= _duesIn);\n        require(_oracleContract != address(0) || _currency == 0x0);\n        require(_borrower != address(0));\n        require(_amount != 0);\n        require(_interestRatePunitory != 0);\n        require(_interestRate != 0);\n        require(_expirationRequest > block.timestamp);\n\n        var loan = Loan(Status.initial, _oracleContract, _borrower, 0x0, msg.sender, 0x0, _amount, 0, 0, 0, 0, _interestRate,\n            _interestRatePunitory, 0, _duesIn, _currency, _cancelableAt, 0, 0x0, _expirationRequest);\n        uint index = loans.push(loan) - 1;\n        CreatedLoan(index, _borrower, msg.sender);\n\n        if (msg.sender == _borrower) {\n            approveLoan(index);\n        }\n\n        return index;\n    }\n    \n    function ownerOf(uint256 index) constant returns (address owner) { owner = loans[index].lender; }\n    function getTotalLoans() constant returns (uint256) { return loans.length; }\n    function getOracle(uint index) constant returns (Oracle) { return loans[index].oracle; }\n    function getBorrower(uint index) constant returns (address) { return loans[index].borrower; }\n    function getCosigner(uint index) constant returns (address) { return loans[index].cosigner; }\n    function getCreator(uint index) constant returns (address) { return loans[index].creator; }\n    function getAmount(uint index) constant returns (uint256) { return loans[index].amount; }\n    function getPunitoryInterest(uint index) constant returns (uint256) { return loans[index].punitoryInterest; }\n    function getInterestTimestamp(uint index) constant returns (uint256) { return loans[index].interestTimestamp; }\n    function getPaid(uint index) constant returns (uint256) { return loans[index].paid; }\n    function getInterestRate(uint index) constant returns (uint256) { return loans[index].interestRate; }\n    function getInterestRatePunitory(uint index) constant returns (uint256) { return loans[index].interestRatePunitory; }\n    function getDueTime(uint index) constant returns (uint256) { return loans[index].dueTime; }\n    function getDuesIn(uint index) constant returns (uint256) { return loans[index].duesIn; }\n    function getCancelableAt(uint index) constant returns (uint256) { return loans[index].cancelableAt; }\n    function getApprobation(uint index, address _address) constant returns (bool) { return loans[index].approbations[_address]; }\n    function getStatus(uint index) constant returns (Status) { return loans[index].status; }\n    function getLenderBalance(uint index) constant returns (uint256) { return loans[index].lenderBalance; }\n    function getApprovedTransfer(uint index) constant returns (address) {return loans[index].approvedTransfer; }\n    function getCurrency(uint index) constant returns (bytes32) { return loans[index].currency; }\n    function getExpirationRequest(uint index) constant returns (uint256) { return loans[index].expirationRequest; }\n    function getInterest(uint index) constant returns (uint256) { return loans[index].interest; }\n\n    /**\n        @param index Index of the loan\n\n        @return true if the loan has been approved by the borrower and cosigner.\n    */\n    function isApproved(uint index) constant returns (bool) {\n        Loan storage loan = loans[index];\n        return loan.approbations[loan.borrower];\n    }\n\n    /**\n        @dev Called by the members of the loan to show that they agree with the terms of the loan; the borrower\n        must call this method before any lender could call the method \"lend\".\n            \n        Any address can call this method to be added to the \"approbations\" mapping.\n\n        @param index Index of the loan\n\n        @return true if the approve was done successfully\n    */\n    function approveLoan(uint index) public returns(bool) {\n        Loan storage loan = loans[index];\n        require(loan.status == Status.initial);\n        loan.approbations[msg.sender] = true;\n        ApprovedBy(index, msg.sender);\n        return true;\n    }\n\n    /**\n        @dev Performs the lend of the RCN equivalent to the requested amount, and transforms the msg.sender in the new lender.\n\n        The loan must be previously approved by the borrower; before calling this function, the lender candidate must \n        call the \"approve\" function on the RCN Token, specifying an amount sufficient enough to pay the equivalent of\n        the requested amount, and the cosigner fee.\n        \n        @param index Index of the loan\n        @param oracleData Data required by the oracle to return the rate, the content of this field must be provided\n            by the url exposed in the url() method of the oracle.\n        @param cosigner Address of the cosigner, 0x0 for lending without cosigner.\n        @param cosignerData Data required by the cosigner to process the request.\n\n        @return true if the lend was done successfully\n    */\n    function lend(uint index, bytes oracleData, Cosigner cosigner, bytes cosignerData) public returns (bool) {\n        Loan storage loan = loans[index];\n\n        require(loan.status == Status.initial);\n        require(isApproved(index));\n        require(block.timestamp <= loan.expirationRequest);\n\n        loan.lender = msg.sender;\n        loan.dueTime = safeAdd(block.timestamp, loan.duesIn);\n        loan.interestTimestamp = block.timestamp;\n        loan.status = Status.lent;\n        \n        if (loan.cancelableAt > 0)\n            internalAddInterest(loan, safeAdd(block.timestamp, loan.cancelableAt));\n\n        uint256 rate = getRate(loan, oracleData);\n\n        if (cosigner != address(0)) {\n            // The cosigner it's temporary set to the next address (cosigner + 2), it's expected that the cosigner will\n            // call the method \"cosign\" to accept the conditions; that method also sets the cosigner to the right\n            // address. If that does not happen, the transaction fails.\n            loan.cosigner = address(uint256(cosigner) + 2);\n            require(cosigner.requestCosign(this, index, cosignerData, oracleData));\n            require(loan.cosigner == address(cosigner));\n        }\n        \n        require(rcn.transferFrom(msg.sender, loan.borrower, safeMult(loan.amount, rate)));\n        \n        // ERC721, create new loan and transfer it to the lender\n        Transfer(0x0, loan.lender, index);\n        activeLoans += 1;\n        lendersBalance[loan.lender] += 1;\n        Lent(index, loan.lender, cosigner);\n\n        return true;\n    }\n\n    /**\n        @dev The cosigner must call this method to accept the conditions of a loan, this method pays the cosigner his fee\n\n        @param index Index of the loan\n        @param cost Fee set by the cosigner\n\n        @return true If the cosign was successfull\n    */\n    function cosign(uint index, uint256 cost) external returns (bool) {\n        Loan storage loan = loans[index];\n        require(loan.status == Status.lent && (loan.dueTime - loan.duesIn) == block.timestamp);\n        require(loan.cosigner != address(0));\n        require(loan.cosigner == address(uint256(msg.sender) + 2));\n        loan.cosigner = msg.sender;\n        require(rcn.transferFrom(loan.lender, msg.sender, cost));\n        return true;\n    }\n\n    /**\n        @dev Destroys a loan, the borrower could call this method if they performed an accidental or regretted \n        \"approve\" of the loan, this method only works for them if the loan is in \"pending\" status.\n\n        The lender can call this method at any moment, in case of a loan with status \"lent\" the lender is pardoning \n        the debt. \n\n        @param index Index of the loan\n\n        @return true if the destroy was done successfully\n    */\n    function destroy(uint index) public returns (bool) {\n        Loan storage loan = loans[index];\n        require(loan.status != Status.destroyed);\n        require(msg.sender == loan.lender || (msg.sender == loan.borrower && loan.status == Status.initial));\n        DestroyedBy(index, msg.sender);\n\n        // ERC721, remove loan from circulation\n        if (loan.status != Status.initial) {\n            lendersBalance[loan.lender] -= 1;\n            activeLoans -= 1;\n            Transfer(loan.lender, 0x0, index);\n        }\n\n        loan.status = Status.destroyed;\n        return true;\n    }\n\n    /**\n        @dev Transfers a loan to a different lender, the caller must be the current lender or previously being\n        approved with the method \"approveTransfer\"; only loans with the Status.lent status can be transfered.\n\n        @param index Index of the loan\n        @param to New lender\n\n        @return true if the transfer was done successfully\n    */\n    function transfer(address to, uint256 index) public returns (bool) {\n        Loan storage loan = loans[index];\n        \n        require(loan.status != Status.destroyed && loan.status != Status.paid);\n        require(msg.sender == loan.lender || msg.sender == loan.approvedTransfer);\n        require(to != address(0));\n        loan.lender = to;\n        loan.approvedTransfer = address(0);\n\n        // ERC721, transfer loan to another address\n        lendersBalance[msg.sender] -= 1;\n        lendersBalance[to] += 1;\n        Transfer(loan.lender, to, index);\n\n        return true;\n    }\n\n    /**\n        @dev ERC721 method, transfers the loan to the msg.sender, the msg.sender must be approved using the \n        \"approve\" method.\n\n        @return true if the transfer was successfull\n    */\n    function takeOwnership(uint256 _index) public returns (bool) {\n        return transfer(msg.sender, _index);\n    }\n\n    /**\n        @dev Approves the transfer of a given loan in the name of the lender, the behavior of this function is similar to\n        \"approve\" in the ERC20 standard, but only one approved address is allowed at a time.\n\n        The same method can be called passing 0x0 as parameter \"to\" to erase a previously approved address.\n\n        @param to Address allowed to transfer the loan or 0x0 to delete\n        @param index Index of the loan\n\n        @return true if the approve was done successfully\n    */\n    function approve(address to, uint256 index) public returns (bool) {\n        Loan storage loan = loans[index];\n        require(msg.sender == loan.lender);\n        loan.approvedTransfer = to;\n        Approval(msg.sender, to, index);\n        return true;\n    }\n\n    /**\n        @dev Returns the pending amount to complete de payment of the loan, keep in mind that this number increases \n        every second.\n\n        @param index Index of the loan\n\n        @return Aprox pending payment amount\n    */\n    function getPendingAmount(uint index) public constant returns (uint256) {\n        Loan storage loan = loans[index];\n        addInterest(index);\n        return getRawPendingAmount(loan);\n    }\n\n    function getRawPendingAmount(Loan loan) internal returns (uint256) {\n        return safeSubtract(safeAdd(safeAdd(loan.amount, loan.interest), loan.punitoryInterest), loan.paid);\n    }\n\n    /**\n        @dev Calculates the interest of a given amount, interest rate and delta time.\n\n        @param timeDelta Elapsed time\n        @param interestRate Interest rate expressed as the denominator of 10 000 000.\n        @param amount Amount to apply interest\n\n        @return realDelta The real timeDelta applied\n        @return interest The interest gained in the realDelta time\n    */\n    function calculateInterest(uint256 timeDelta, uint256 interestRate, uint256 amount) public constant returns (uint256 realDelta, uint256 interest) {\n        if (amount == 0) {\n            interest = 0;\n            realDelta = timeDelta;\n        } else {\n            interest = safeMult(safeMult(100000, amount), timeDelta) / interestRate;\n            realDelta = safeMult(interest, interestRate) / (amount * 100000);\n        }\n    }\n\n    /**\n        @dev Computes loan interest\n\n        Computes the punitory and non-punitory interest of a given loan and only applies the change.\n        \n        @param loan Loan to compute interest\n        @param timestamp Target absolute unix time to calculate interest.\n    */\n    function internalAddInterest(Loan storage loan, uint256 timestamp) internal {\n        if (timestamp > loan.interestTimestamp) {\n            uint256 newInterest = loan.interest;\n            uint256 newPunitoryInterest = loan.punitoryInterest;\n\n            uint256 newTimestamp;\n            uint256 realDelta;\n            uint256 calculatedInterest;\n\n            uint256 deltaTime;\n            uint256 pending;\n\n            uint256 endNonPunitory = min(timestamp, loan.dueTime);\n            if (endNonPunitory > loan.interestTimestamp) {\n                deltaTime = endNonPunitory - loan.interestTimestamp;\n\n                if (loan.paid < loan.amount) {\n                    pending = loan.amount - loan.paid;\n                } else {\n                    pending = 0;\n                }\n\n                (realDelta, calculatedInterest) = calculateInterest(deltaTime, loan.interestRate, pending);\n                newInterest = safeAdd(calculatedInterest, newInterest);\n                newTimestamp = loan.interestTimestamp + realDelta;\n            }\n\n            if (timestamp > loan.dueTime) {\n                uint256 startPunitory = max(loan.dueTime, loan.interestTimestamp);\n                deltaTime = timestamp - startPunitory;\n\n                uint256 debt = safeAdd(loan.amount, newInterest);\n                pending = min(debt, safeSubtract(safeAdd(debt, newPunitoryInterest), loan.paid));\n\n                (realDelta, calculatedInterest) = calculateInterest(deltaTime, loan.interestRatePunitory, pending);\n                newPunitoryInterest = safeAdd(newPunitoryInterest, calculatedInterest);\n                newTimestamp = startPunitory + realDelta;\n            }\n            \n            if (newInterest != loan.interest || newPunitoryInterest != loan.punitoryInterest) {\n                loan.interestTimestamp = newTimestamp;\n                loan.interest = newInterest;\n                loan.punitoryInterest = newPunitoryInterest;\n            }\n        }\n    }\n\n    /**\n        @dev Computes loan interest only up to current unix time\n\n        @param timestamp Target absolute unix time to calculate interest.\n    */\n    function addInterestUpTo(Loan storage loan, uint256 timestamp) internal {\n        require(loan.status == Status.lent);\n        if (timestamp <= block.timestamp) {\n            internalAddInterest(loan, timestamp);\n        }\n    }\n\n    /**\n        @dev Updates the loan accumulated interests up to the current Unix time.\n        \n        @param index Index of the loan\n    */\n    function addInterest(uint index) public {\n        Loan storage loan = loans[index];\n        addInterestUpTo(loan, block.timestamp);\n    }\n    \n    /**\n        @dev Pay loan\n\n        Realizes a payment of a given Loan, before performing the payment the accumulated\n        interest is computed and added to the total pending amount.\n\n        Before calling this function, the msg.sender must call the \"approve\" function on the RCN Token, specifying an amount\n        sufficient enough to pay the equivalent of the desired payment and the oracle fee.\n\n        Because it is difficult or even impossible to know in advance how much RCN are going to be spent on the\n        transaction*, we recommend performing the \"approve\" using an amount 5% superior to the wallet estimated\n        spending. If the RCN spent results to be less, the extra tokens are never debited from the msg.sender.\n\n        * The RCN rate can fluctuate on the same block, and it is impossible to know in advance the exact time of the\n        confirmation of the transaction. \n\n        If the paid pending amount equals zero, the loan changes status to \"paid\" and it is considered closed.\n\n        @param index Index of the loan\n        @param _amount Amount to pay, specified in the loan currency; or in RCN if the loan has no oracle\n        @param _from The identity of the payer\n        @param oracleData Data required by the oracle to return the rate, the content of this field must be provided\n            by the url exposed in the url() method of the oracle.\n            \n        @return true if the payment was executed successfully\n    */\n    function pay(uint index, uint256 _amount, address _from, bytes oracleData) public returns (bool) {\n        Loan storage loan = loans[index];\n\n        require(loan.status == Status.lent);\n        addInterest(index);\n        uint256 toPay = min(getPendingAmount(index), _amount);\n        PartialPayment(index, msg.sender, _from, toPay);\n\n        loan.paid = safeAdd(loan.paid, toPay);\n\n        if (getRawPendingAmount(loan) == 0) {\n            TotalPayment(index);\n            loan.status = Status.paid;\n\n            // ERC721, remove loan from circulation\n            lendersBalance[loan.lender] -= 1;\n            activeLoans -= 1;\n            Transfer(loan.lender, 0x0, index);\n        }\n\n        uint256 rate = getRate(loan, oracleData);\n        uint256 transferValue = safeMult(toPay, rate);\n        lockTokens(rcn, transferValue);\n        require(rcn.transferFrom(msg.sender, this, transferValue));\n        loan.lenderBalance = safeAdd(transferValue, loan.lenderBalance);\n\n        return true;\n    }\n\n    /**\n        @dev Retrieves the rate corresponding of the loan oracle, if the loan has no oracle the rate is 1\n\n        @param loan The loan with the cosigner\n        @param data Data required by the oracle\n\n        @return The rate of the oracle\n    */\n    function getRate(Loan loan, bytes data) internal returns (uint256) {\n        if (loan.oracle == address(0)) {\n            return 1;\n        } else {\n            return loan.oracle.getRate(loan.currency, data);\n        }\n    }\n\n    /**\n        @dev Withdraw lender funds\n\n        When a loan is paid, the funds are not transferred automatically to the lender, the funds are stored on the\n        engine contract, and the lender must call this function specifying the amount desired to transfer and the \n        destination.\n\n        This behavior is defined to allow the temporary transfer of the loan to a smart contract, without worrying that\n        the contract will receive tokens that are not traceable; and it allows the development of decentralized \n        autonomous organizations.\n\n        @param index Index of the loan\n        @param to Destination of the wiwthdraw funds\n        @param amount Amount to withdraw, in RCN\n\n        @return true if the withdraw was executed successfully\n    */\n    function withdrawal(uint index, address to, uint256 amount) public returns (bool) {\n        Loan storage loan = loans[index];\n        require(msg.sender == loan.lender);\n        loan.lenderBalance = safeSubtract(loan.lenderBalance, amount);\n        require(rcn.transfer(to, amount));\n        unlockTokens(rcn, amount);\n        return true;\n    }\n\n    function withdrawalRange(uint256 fromIndex, uint256 toIndex, address to) public returns (uint256) {\n        uint256 loanId;\n        uint256 totalWithdraw = 0;\n\n        for (loanId = fromIndex; loanId <= toIndex; loanId++) {\n            Loan storage loan = loans[loanId];\n            if (loan.lender == msg.sender) {\n                totalWithdraw += loan.lenderBalance;\n                loan.lenderBalance = 0;\n            }\n        }\n\n        require(rcn.transfer(to, totalWithdraw));\n        unlockTokens(rcn, totalWithdraw);\n        \n        return totalWithdraw;\n    }\n\n    function withdrawalList(uint256[] memory loanIds, address to) public returns (uint256) {\n        uint256 inputId;\n        uint256 totalWithdraw = 0;\n\n        for (inputId = 0; inputId < loanIds.length; inputId++) {\n            Loan storage loan = loans[loanIds[inputId]];\n            if (loan.lender == msg.sender) {\n                totalWithdraw += loan.lenderBalance;\n                loan.lenderBalance = 0;\n            }\n        }\n\n        require(rcn.transfer(to, totalWithdraw));\n        unlockTokens(rcn, totalWithdraw);\n\n        return totalWithdraw;\n    }\n\n    /**\n        @dev Deprecates the engine, locks the creation of new loans.\n    */\n    function setDeprecated(bool _deprecated) public onlyOwner {\n        deprecated = _deprecated;\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinfabrik-RCN Network Smart Contract Audit/rcn-network-3ded36151ad55543d16c354e70161852de4061d0/contracts/NanoLoanEngine.sol",
        "vulnerability": "Assertion Failure",
        "check": "FP",
        "response": "Answer: No\nReason: The code does not contain any assert statements that could directly cause an assertion failure."
    },
    {
        "code_segment": "contract NanoLoanEngine is ERC721, Engine, Ownable, TokenLockable {\n    uint256 public constant VERSION = 202;\n    string public constant VERSION_NAME = \"Basalt\";\n\n    uint256 private activeLoans = 0;\n    mapping(address => uint256) private lendersBalance;\n\n    function name() constant returns (string _name) {\n        _name = \"RCN - Nano loan engine - Basalt 202\";\n    }\n\n    function symbol() constant returns (string _symbol) {\n        _symbol = \"RCN-NLE-202\";\n    }\n\n    function totalSupply() constant returns (uint _totalSupply) {\n        _totalSupply = activeLoans;\n    }\n\n    function balanceOf(address _owner) constant returns (uint _balance) {\n        _balance = lendersBalance[_owner];\n    }\n\n    function tokenOfOwnerByIndex(address _owner, uint256 _index) constant returns (uint tokenId) {\n        uint256 tokenCount = balanceOf(_owner);\n\n        if (tokenCount == 0 || _index >= tokenCount) {\n            // Fail transaction\n            revert();\n        } else {\n            uint256 totalLoans = totalSupply();\n            uint256 resultIndex = 0;\n\n            uint256 loanId;\n            // SWC-128-DoS With Block Gas Limit: L46\n            for (loanId = 0; loanId <= totalLoans; loanId++) {\n                if (loans[loanId].lender == _owner && loans[loanId].status == Status.lent) {\n                    if (resultIndex == _index) {\n                        return loanId;\n                    }\n                    resultIndex++;\n                }\n            }\n\n            revert();\n        }\n    }\n\n    function tokensOfOwner(address _owner) external constant returns(uint256[] ownerTokens) {\n        uint256 tokenCount = balanceOf(_owner);\n\n        if (tokenCount == 0) {\n            // Return an empty array\n            return new uint256[](0);\n        } else {\n            uint256[] memory result = new uint256[](tokenCount);\n            uint256 totalLoans = totalSupply();\n            uint256 resultIndex = 0;\n\n            uint256 loanId;\n\n            for (loanId = 0; loanId <= totalLoans; loanId++) {\n                if (loans[loanId].lender == _owner && loans[loanId].status == Status.lent) {\n                    result[resultIndex] = loanId;\n                    resultIndex++;\n                }\n            }\n\n            return result;\n        }\n    }\n    \n    Token public rcn;\n    bool public deprecated;\n\n    event CreatedLoan(uint _index, address _borrower, address _creator);\n    event ApprovedBy(uint _index, address _address);\n    event Lent(uint _index, address _lender, address _cosigner);\n    event DestroyedBy(uint _index, address _address);\n    event PartialPayment(uint _index, address _sender, address _from, uint256 _amount);\n    event TotalPayment(uint _index);\n\n    function NanoLoanEngine(Token _rcn) public {\n        owner = msg.sender;\n        rcn = _rcn;\n    }\n\n    struct Loan {\n        Status status;\n        Oracle oracle;\n\n        address borrower;\n        address lender;\n        address creator;\n        address cosigner;\n        \n        uint256 amount;\n        uint256 interest;\n        uint256 punitoryInterest;\n        uint256 interestTimestamp;\n        uint256 paid;\n        uint256 interestRate;\n        uint256 interestRatePunitory;\n        uint256 dueTime;\n        uint256 duesIn;\n\n        bytes32 currency;\n        uint256 cancelableAt;\n        uint256 lenderBalance;\n\n        address approvedTransfer;\n        uint256 expirationRequest;\n\n        mapping(address => bool) approbations;\n    }\n\n    Loan[] private loans;\n\n    /**\n        @dev Creates a loan request, the loan can be generated with any borrower, cosigner, and conditions; if the \n        cosigner and borrower agree they must call the \"approve\" function.\n\n        The creator of the loan is the caller of this function; this is useful to track which wallet created the loan.\n\n        @param _oracleContract Address of the Oracle contract, if the loan does not use any oracle, this field should be 0x0.\n        @param _borrower Address of the borrower\n        @param _currency The currency to use with the oracle, the currency code is generated with the following formula,\n            keccak256(ticker,decimals).\n        @param _amount The requested amount; currency and unit are defined by the Oracle, if there is no Oracle present\n            the currency is RCN, and the unit is wei.\n        @param _interestRate The non-punitory interest rate by second, defined as a denominator of 10 000 000.\n        @param _interestRatePunitory The punitory interest rate by second, defined as a denominator of 10 000 000.\n            Ej: interestRate 11108571428571 = 28% Anual interest\n        @param _duesIn The time in seconds that the borrower has in order to pay the debt after the lender lends the money.\n        @param _cancelableAt Delta in seconds specifying how much interest should be added in advance, if the borrower pays \n        entirely or partially the loan before this term, no extra interest will be deducted.\n        @param _expirationRequest Timestamp of when the loan request expires, if the loan is not filled before this date, \n            the request is no longer valid.\n    */\n    function createLoan(Oracle _oracleContract, address _borrower, bytes32 _currency, uint256 _amount, uint256 _interestRate,\n        uint256 _interestRatePunitory, uint256 _duesIn, uint256 _cancelableAt, uint256 _expirationRequest) returns (uint256) {\n\n        require(!deprecated);\n        require(_cancelableAt <= _duesIn);\n        require(_oracleContract != address(0) || _currency == 0x0);\n        require(_borrower != address(0));\n        require(_amount != 0);\n        require(_interestRatePunitory != 0);\n        require(_interestRate != 0);\n        require(_expirationRequest > block.timestamp);\n\n        var loan = Loan(Status.initial, _oracleContract, _borrower, 0x0, msg.sender, 0x0, _amount, 0, 0, 0, 0, _interestRate,\n            _interestRatePunitory, 0, _duesIn, _currency, _cancelableAt, 0, 0x0, _expirationRequest);\n        uint index = loans.push(loan) - 1;\n        CreatedLoan(index, _borrower, msg.sender);\n\n        if (msg.sender == _borrower) {\n            approveLoan(index);\n        }\n\n        return index;\n    }\n    \n    function ownerOf(uint256 index) constant returns (address owner) { owner = loans[index].lender; }\n    function getTotalLoans() constant returns (uint256) { return loans.length; }\n    function getOracle(uint index) constant returns (Oracle) { return loans[index].oracle; }\n    function getBorrower(uint index) constant returns (address) { return loans[index].borrower; }\n    function getCosigner(uint index) constant returns (address) { return loans[index].cosigner; }\n    function getCreator(uint index) constant returns (address) { return loans[index].creator; }\n    function getAmount(uint index) constant returns (uint256) { return loans[index].amount; }\n    function getPunitoryInterest(uint index) constant returns (uint256) { return loans[index].punitoryInterest; }\n    function getInterestTimestamp(uint index) constant returns (uint256) { return loans[index].interestTimestamp; }\n    function getPaid(uint index) constant returns (uint256) { return loans[index].paid; }\n    function getInterestRate(uint index) constant returns (uint256) { return loans[index].interestRate; }\n    function getInterestRatePunitory(uint index) constant returns (uint256) { return loans[index].interestRatePunitory; }\n    function getDueTime(uint index) constant returns (uint256) { return loans[index].dueTime; }\n    function getDuesIn(uint index) constant returns (uint256) { return loans[index].duesIn; }\n    function getCancelableAt(uint index) constant returns (uint256) { return loans[index].cancelableAt; }\n    function getApprobation(uint index, address _address) constant returns (bool) { return loans[index].approbations[_address]; }\n    function getStatus(uint index) constant returns (Status) { return loans[index].status; }\n    function getLenderBalance(uint index) constant returns (uint256) { return loans[index].lenderBalance; }\n    function getApprovedTransfer(uint index) constant returns (address) {return loans[index].approvedTransfer; }\n    function getCurrency(uint index) constant returns (bytes32) { return loans[index].currency; }\n    function getExpirationRequest(uint index) constant returns (uint256) { return loans[index].expirationRequest; }\n    function getInterest(uint index) constant returns (uint256) { return loans[index].interest; }\n\n    /**\n        @param index Index of the loan\n\n        @return true if the loan has been approved by the borrower and cosigner.\n    */\n    function isApproved(uint index) constant returns (bool) {\n        Loan storage loan = loans[index];\n        return loan.approbations[loan.borrower];\n    }\n\n    /**\n        @dev Called by the members of the loan to show that they agree with the terms of the loan; the borrower\n        must call this method before any lender could call the method \"lend\".\n            \n        Any address can call this method to be added to the \"approbations\" mapping.\n\n        @param index Index of the loan\n\n        @return true if the approve was done successfully\n    */\n    function approveLoan(uint index) public returns(bool) {\n        Loan storage loan = loans[index];\n        require(loan.status == Status.initial);\n        loan.approbations[msg.sender] = true;\n        ApprovedBy(index, msg.sender);\n        return true;\n    }\n\n    /**\n        @dev Performs the lend of the RCN equivalent to the requested amount, and transforms the msg.sender in the new lender.\n\n        The loan must be previously approved by the borrower; before calling this function, the lender candidate must \n        call the \"approve\" function on the RCN Token, specifying an amount sufficient enough to pay the equivalent of\n        the requested amount, and the cosigner fee.\n        \n        @param index Index of the loan\n        @param oracleData Data required by the oracle to return the rate, the content of this field must be provided\n            by the url exposed in the url() method of the oracle.\n        @param cosigner Address of the cosigner, 0x0 for lending without cosigner.\n        @param cosignerData Data required by the cosigner to process the request.\n\n        @return true if the lend was done successfully\n    */\n    function lend(uint index, bytes oracleData, Cosigner cosigner, bytes cosignerData) public returns (bool) {\n        Loan storage loan = loans[index];\n\n        require(loan.status == Status.initial);\n        require(isApproved(index));\n        require(block.timestamp <= loan.expirationRequest);\n\n        loan.lender = msg.sender;\n        loan.dueTime = safeAdd(block.timestamp, loan.duesIn);\n        loan.interestTimestamp = block.timestamp;\n        loan.status = Status.lent;\n        \n        if (loan.cancelableAt > 0)\n            internalAddInterest(loan, safeAdd(block.timestamp, loan.cancelableAt));\n\n        uint256 rate = getRate(loan, oracleData);\n\n        if (cosigner != address(0)) {\n            // The cosigner it's temporary set to the next address (cosigner + 2), it's expected that the cosigner will\n            // call the method \"cosign\" to accept the conditions; that method also sets the cosigner to the right\n            // address. If that does not happen, the transaction fails.\n            loan.cosigner = address(uint256(cosigner) + 2);\n            require(cosigner.requestCosign(this, index, cosignerData, oracleData));\n            require(loan.cosigner == address(cosigner));\n        }\n        \n        require(rcn.transferFrom(msg.sender, loan.borrower, safeMult(loan.amount, rate)));\n        \n        // ERC721, create new loan and transfer it to the lender\n        Transfer(0x0, loan.lender, index);\n        activeLoans += 1;\n        lendersBalance[loan.lender] += 1;\n        Lent(index, loan.lender, cosigner);\n\n        return true;\n    }\n\n    /**\n        @dev The cosigner must call this method to accept the conditions of a loan, this method pays the cosigner his fee\n\n        @param index Index of the loan\n        @param cost Fee set by the cosigner\n\n        @return true If the cosign was successfull\n    */\n    function cosign(uint index, uint256 cost) external returns (bool) {\n        Loan storage loan = loans[index];\n        require(loan.status == Status.lent && (loan.dueTime - loan.duesIn) == block.timestamp);\n        require(loan.cosigner != address(0));\n        require(loan.cosigner == address(uint256(msg.sender) + 2));\n        loan.cosigner = msg.sender;\n        require(rcn.transferFrom(loan.lender, msg.sender, cost));\n        return true;\n    }\n\n    /**\n        @dev Destroys a loan, the borrower could call this method if they performed an accidental or regretted \n        \"approve\" of the loan, this method only works for them if the loan is in \"pending\" status.\n\n        The lender can call this method at any moment, in case of a loan with status \"lent\" the lender is pardoning \n        the debt. \n\n        @param index Index of the loan\n\n        @return true if the destroy was done successfully\n    */\n    function destroy(uint index) public returns (bool) {\n        Loan storage loan = loans[index];\n        require(loan.status != Status.destroyed);\n        require(msg.sender == loan.lender || (msg.sender == loan.borrower && loan.status == Status.initial));\n        DestroyedBy(index, msg.sender);\n\n        // ERC721, remove loan from circulation\n        if (loan.status != Status.initial) {\n            lendersBalance[loan.lender] -= 1;\n            activeLoans -= 1;\n            Transfer(loan.lender, 0x0, index);\n        }\n\n        loan.status = Status.destroyed;\n        return true;\n    }\n\n    /**\n        @dev Transfers a loan to a different lender, the caller must be the current lender or previously being\n        approved with the method \"approveTransfer\"; only loans with the Status.lent status can be transfered.\n\n        @param index Index of the loan\n        @param to New lender\n\n        @return true if the transfer was done successfully\n    */\n    function transfer(address to, uint256 index) public returns (bool) {\n        Loan storage loan = loans[index];\n        \n        require(loan.status != Status.destroyed && loan.status != Status.paid);\n        require(msg.sender == loan.lender || msg.sender == loan.approvedTransfer);\n        require(to != address(0));\n        loan.lender = to;\n        loan.approvedTransfer = address(0);\n\n        // ERC721, transfer loan to another address\n        lendersBalance[msg.sender] -= 1;\n        lendersBalance[to] += 1;\n        Transfer(loan.lender, to, index);\n\n        return true;\n    }\n\n    /**\n        @dev ERC721 method, transfers the loan to the msg.sender, the msg.sender must be approved using the \n        \"approve\" method.\n\n        @return true if the transfer was successfull\n    */\n    function takeOwnership(uint256 _index) public returns (bool) {\n        return transfer(msg.sender, _index);\n    }\n\n    /**\n        @dev Approves the transfer of a given loan in the name of the lender, the behavior of this function is similar to\n        \"approve\" in the ERC20 standard, but only one approved address is allowed at a time.\n\n        The same method can be called passing 0x0 as parameter \"to\" to erase a previously approved address.\n\n        @param to Address allowed to transfer the loan or 0x0 to delete\n        @param index Index of the loan\n\n        @return true if the approve was done successfully\n    */\n    function approve(address to, uint256 index) public returns (bool) {\n        Loan storage loan = loans[index];\n        require(msg.sender == loan.lender);\n        loan.approvedTransfer = to;\n        Approval(msg.sender, to, index);\n        return true;\n    }\n\n    /**\n        @dev Returns the pending amount to complete de payment of the loan, keep in mind that this number increases \n        every second.\n\n        @param index Index of the loan\n\n        @return Aprox pending payment amount\n    */\n    function getPendingAmount(uint index) public constant returns (uint256) {\n        Loan storage loan = loans[index];\n        addInterest(index);\n        return getRawPendingAmount(loan);\n    }\n\n    function getRawPendingAmount(Loan loan) internal returns (uint256) {\n        return safeSubtract(safeAdd(safeAdd(loan.amount, loan.interest), loan.punitoryInterest), loan.paid);\n    }\n\n    /**\n        @dev Calculates the interest of a given amount, interest rate and delta time.\n\n        @param timeDelta Elapsed time\n        @param interestRate Interest rate expressed as the denominator of 10 000 000.\n        @param amount Amount to apply interest\n\n        @return realDelta The real timeDelta applied\n        @return interest The interest gained in the realDelta time\n    */\n    function calculateInterest(uint256 timeDelta, uint256 interestRate, uint256 amount) public constant returns (uint256 realDelta, uint256 interest) {\n        if (amount == 0) {\n            interest = 0;\n            realDelta = timeDelta;\n        } else {\n            interest = safeMult(safeMult(100000, amount), timeDelta) / interestRate;\n            realDelta = safeMult(interest, interestRate) / (amount * 100000);\n        }\n    }\n\n    /**\n        @dev Computes loan interest\n\n        Computes the punitory and non-punitory interest of a given loan and only applies the change.\n        \n        @param loan Loan to compute interest\n        @param timestamp Target absolute unix time to calculate interest.\n    */\n    function internalAddInterest(Loan storage loan, uint256 timestamp) internal {\n        if (timestamp > loan.interestTimestamp) {\n            uint256 newInterest = loan.interest;\n            uint256 newPunitoryInterest = loan.punitoryInterest;\n\n            uint256 newTimestamp;\n            uint256 realDelta;\n            uint256 calculatedInterest;\n\n            uint256 deltaTime;\n            uint256 pending;\n\n            uint256 endNonPunitory = min(timestamp, loan.dueTime);\n            if (endNonPunitory > loan.interestTimestamp) {\n                deltaTime = endNonPunitory - loan.interestTimestamp;\n\n                if (loan.paid < loan.amount) {\n                    pending = loan.amount - loan.paid;\n                } else {\n                    pending = 0;\n                }\n\n                (realDelta, calculatedInterest) = calculateInterest(deltaTime, loan.interestRate, pending);\n                newInterest = safeAdd(calculatedInterest, newInterest);\n                newTimestamp = loan.interestTimestamp + realDelta;\n            }\n\n            if (timestamp > loan.dueTime) {\n                uint256 startPunitory = max(loan.dueTime, loan.interestTimestamp);\n                deltaTime = timestamp - startPunitory;\n\n                uint256 debt = safeAdd(loan.amount, newInterest);\n                pending = min(debt, safeSubtract(safeAdd(debt, newPunitoryInterest), loan.paid));\n\n                (realDelta, calculatedInterest) = calculateInterest(deltaTime, loan.interestRatePunitory, pending);\n                newPunitoryInterest = safeAdd(newPunitoryInterest, calculatedInterest);\n                newTimestamp = startPunitory + realDelta;\n            }\n            \n            if (newInterest != loan.interest || newPunitoryInterest != loan.punitoryInterest) {\n                loan.interestTimestamp = newTimestamp;\n                loan.interest = newInterest;\n                loan.punitoryInterest = newPunitoryInterest;\n            }\n        }\n    }\n\n    /**\n        @dev Computes loan interest only up to current unix time\n\n        @param timestamp Target absolute unix time to calculate interest.\n    */\n    function addInterestUpTo(Loan storage loan, uint256 timestamp) internal {\n        require(loan.status == Status.lent);\n        if (timestamp <= block.timestamp) {\n            internalAddInterest(loan, timestamp);\n        }\n    }\n\n    /**\n        @dev Updates the loan accumulated interests up to the current Unix time.\n        \n        @param index Index of the loan\n    */\n    function addInterest(uint index) public {\n        Loan storage loan = loans[index];\n        addInterestUpTo(loan, block.timestamp);\n    }\n    \n    /**\n        @dev Pay loan\n\n        Realizes a payment of a given Loan, before performing the payment the accumulated\n        interest is computed and added to the total pending amount.\n\n        Before calling this function, the msg.sender must call the \"approve\" function on the RCN Token, specifying an amount\n        sufficient enough to pay the equivalent of the desired payment and the oracle fee.\n\n        Because it is difficult or even impossible to know in advance how much RCN are going to be spent on the\n        transaction*, we recommend performing the \"approve\" using an amount 5% superior to the wallet estimated\n        spending. If the RCN spent results to be less, the extra tokens are never debited from the msg.sender.\n\n        * The RCN rate can fluctuate on the same block, and it is impossible to know in advance the exact time of the\n        confirmation of the transaction. \n\n        If the paid pending amount equals zero, the loan changes status to \"paid\" and it is considered closed.\n\n        @param index Index of the loan\n        @param _amount Amount to pay, specified in the loan currency; or in RCN if the loan has no oracle\n        @param _from The identity of the payer\n        @param oracleData Data required by the oracle to return the rate, the content of this field must be provided\n            by the url exposed in the url() method of the oracle.\n            \n        @return true if the payment was executed successfully\n    */\n    function pay(uint index, uint256 _amount, address _from, bytes oracleData) public returns (bool) {\n        Loan storage loan = loans[index];\n\n        require(loan.status == Status.lent);\n        addInterest(index);\n        uint256 toPay = min(getPendingAmount(index), _amount);\n        PartialPayment(index, msg.sender, _from, toPay);\n\n        loan.paid = safeAdd(loan.paid, toPay);\n\n        if (getRawPendingAmount(loan) == 0) {\n            TotalPayment(index);\n            loan.status = Status.paid;\n\n            // ERC721, remove loan from circulation\n            lendersBalance[loan.lender] -= 1;\n            activeLoans -= 1;\n            Transfer(loan.lender, 0x0, index);\n        }\n\n        uint256 rate = getRate(loan, oracleData);\n        uint256 transferValue = safeMult(toPay, rate);\n        lockTokens(rcn, transferValue);\n        require(rcn.transferFrom(msg.sender, this, transferValue));\n        loan.lenderBalance = safeAdd(transferValue, loan.lenderBalance);\n\n        return true;\n    }\n\n    /**\n        @dev Retrieves the rate corresponding of the loan oracle, if the loan has no oracle the rate is 1\n\n        @param loan The loan with the cosigner\n        @param data Data required by the oracle\n\n        @return The rate of the oracle\n    */\n    function getRate(Loan loan, bytes data) internal returns (uint256) {\n        if (loan.oracle == address(0)) {\n            return 1;\n        } else {\n            return loan.oracle.getRate(loan.currency, data);\n        }\n    }\n\n    /**\n        @dev Withdraw lender funds\n\n        When a loan is paid, the funds are not transferred automatically to the lender, the funds are stored on the\n        engine contract, and the lender must call this function specifying the amount desired to transfer and the \n        destination.\n\n        This behavior is defined to allow the temporary transfer of the loan to a smart contract, without worrying that\n        the contract will receive tokens that are not traceable; and it allows the development of decentralized \n        autonomous organizations.\n\n        @param index Index of the loan\n        @param to Destination of the wiwthdraw funds\n        @param amount Amount to withdraw, in RCN\n\n        @return true if the withdraw was executed successfully\n    */\n    function withdrawal(uint index, address to, uint256 amount) public returns (bool) {\n        Loan storage loan = loans[index];\n        require(msg.sender == loan.lender);\n        loan.lenderBalance = safeSubtract(loan.lenderBalance, amount);\n        require(rcn.transfer(to, amount));\n        unlockTokens(rcn, amount);\n        return true;\n    }\n\n    function withdrawalRange(uint256 fromIndex, uint256 toIndex, address to) public returns (uint256) {\n        uint256 loanId;\n        uint256 totalWithdraw = 0;\n\n        for (loanId = fromIndex; loanId <= toIndex; loanId++) {\n            Loan storage loan = loans[loanId];\n            if (loan.lender == msg.sender) {\n                totalWithdraw += loan.lenderBalance;\n                loan.lenderBalance = 0;\n            }\n        }\n\n        require(rcn.transfer(to, totalWithdraw));\n        unlockTokens(rcn, totalWithdraw);\n        \n        return totalWithdraw;\n    }\n\n    function withdrawalList(uint256[] memory loanIds, address to) public returns (uint256) {\n        uint256 inputId;\n        uint256 totalWithdraw = 0;\n\n        for (inputId = 0; inputId < loanIds.length; inputId++) {\n            Loan storage loan = loans[loanIds[inputId]];\n            if (loan.lender == msg.sender) {\n                totalWithdraw += loan.lenderBalance;\n                loan.lenderBalance = 0;\n            }\n        }\n\n        require(rcn.transfer(to, totalWithdraw));\n        unlockTokens(rcn, totalWithdraw);\n\n        return totalWithdraw;\n    }\n\n    /**\n        @dev Deprecates the engine, locks the creation of new loans.\n    */\n    function setDeprecated(bool _deprecated) public onlyOwner {\n        deprecated = _deprecated;\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinfabrik-RCN Network Smart Contract Audit/rcn-network-3ded36151ad55543d16c354e70161852de4061d0/contracts/NanoLoanEngine.sol",
        "vulnerability": "Assertion Failure",
        "check": "FP",
        "response": "Answer: Yes\nDescription: The for loop uses `loanId <= totalLoans` which can cause an assertion failure when accessing `loans[loanId]` if `loanId` exceeds the array length, leading to potential out-of-bounds access."
    },
    {
        "code_segment": "contract NanoLoanEngine is ERC721, Engine, Ownable, TokenLockable {\n    uint256 public constant VERSION = 202;\n    string public constant VERSION_NAME = \"Basalt\";\n\n    uint256 private activeLoans = 0;\n    mapping(address => uint256) private lendersBalance;\n\n    function name() constant returns (string _name) {\n        _name = \"RCN - Nano loan engine - Basalt 202\";\n    }\n\n    function symbol() constant returns (string _symbol) {\n        _symbol = \"RCN-NLE-202\";\n    }\n\n    function totalSupply() constant returns (uint _totalSupply) {\n        _totalSupply = activeLoans;\n    }\n\n    function balanceOf(address _owner) constant returns (uint _balance) {\n        _balance = lendersBalance[_owner];\n    }\n\n    function tokenOfOwnerByIndex(address _owner, uint256 _index) constant returns (uint tokenId) {\n        uint256 tokenCount = balanceOf(_owner);\n\n        if (tokenCount == 0 || _index >= tokenCount) {\n            // Fail transaction\n            revert();\n        } else {\n            uint256 totalLoans = totalSupply();\n            uint256 resultIndex = 0;\n\n            uint256 loanId;\n            // SWC-128-DoS With Block Gas Limit: L46\n            for (loanId = 0; loanId <= totalLoans; loanId++) {\n                if (loans[loanId].lender == _owner && loans[loanId].status == Status.lent) {\n                    if (resultIndex == _index) {\n                        return loanId;\n                    }\n                    resultIndex++;\n                }\n            }\n\n            revert();\n        }\n    }\n\n    function tokensOfOwner(address _owner) external constant returns(uint256[] ownerTokens) {\n        uint256 tokenCount = balanceOf(_owner);\n\n        if (tokenCount == 0) {\n            // Return an empty array\n            return new uint256[](0);\n        } else {\n            uint256[] memory result = new uint256[](tokenCount);\n            uint256 totalLoans = totalSupply();\n            uint256 resultIndex = 0;\n\n            uint256 loanId;\n\n            for (loanId = 0; loanId <= totalLoans; loanId++) {\n                if (loans[loanId].lender == _owner && loans[loanId].status == Status.lent) {\n                    result[resultIndex] = loanId;\n                    resultIndex++;\n                }\n            }\n\n            return result;\n        }\n    }\n    \n    Token public rcn;\n    bool public deprecated;\n\n    event CreatedLoan(uint _index, address _borrower, address _creator);\n    event ApprovedBy(uint _index, address _address);\n    event Lent(uint _index, address _lender, address _cosigner);\n    event DestroyedBy(uint _index, address _address);\n    event PartialPayment(uint _index, address _sender, address _from, uint256 _amount);\n    event TotalPayment(uint _index);\n\n    function NanoLoanEngine(Token _rcn) public {\n        owner = msg.sender;\n        rcn = _rcn;\n    }\n\n    struct Loan {\n        Status status;\n        Oracle oracle;\n\n        address borrower;\n        address lender;\n        address creator;\n        address cosigner;\n        \n        uint256 amount;\n        uint256 interest;\n        uint256 punitoryInterest;\n        uint256 interestTimestamp;\n        uint256 paid;\n        uint256 interestRate;\n        uint256 interestRatePunitory;\n        uint256 dueTime;\n        uint256 duesIn;\n\n        bytes32 currency;\n        uint256 cancelableAt;\n        uint256 lenderBalance;\n\n        address approvedTransfer;\n        uint256 expirationRequest;\n\n        mapping(address => bool) approbations;\n    }\n\n    Loan[] private loans;\n\n    /**\n        @dev Creates a loan request, the loan can be generated with any borrower, cosigner, and conditions; if the \n        cosigner and borrower agree they must call the \"approve\" function.\n\n        The creator of the loan is the caller of this function; this is useful to track which wallet created the loan.\n\n        @param _oracleContract Address of the Oracle contract, if the loan does not use any oracle, this field should be 0x0.\n        @param _borrower Address of the borrower\n        @param _currency The currency to use with the oracle, the currency code is generated with the following formula,\n            keccak256(ticker,decimals).\n        @param _amount The requested amount; currency and unit are defined by the Oracle, if there is no Oracle present\n            the currency is RCN, and the unit is wei.\n        @param _interestRate The non-punitory interest rate by second, defined as a denominator of 10 000 000.\n        @param _interestRatePunitory The punitory interest rate by second, defined as a denominator of 10 000 000.\n            Ej: interestRate 11108571428571 = 28% Anual interest\n        @param _duesIn The time in seconds that the borrower has in order to pay the debt after the lender lends the money.\n        @param _cancelableAt Delta in seconds specifying how much interest should be added in advance, if the borrower pays \n        entirely or partially the loan before this term, no extra interest will be deducted.\n        @param _expirationRequest Timestamp of when the loan request expires, if the loan is not filled before this date, \n            the request is no longer valid.\n    */\n    function createLoan(Oracle _oracleContract, address _borrower, bytes32 _currency, uint256 _amount, uint256 _interestRate,\n        uint256 _interestRatePunitory, uint256 _duesIn, uint256 _cancelableAt, uint256 _expirationRequest) returns (uint256) {\n\n        require(!deprecated);\n        require(_cancelableAt <= _duesIn);\n        require(_oracleContract != address(0) || _currency == 0x0);\n        require(_borrower != address(0));\n        require(_amount != 0);\n        require(_interestRatePunitory != 0);\n        require(_interestRate != 0);\n        require(_expirationRequest > block.timestamp);\n\n        var loan = Loan(Status.initial, _oracleContract, _borrower, 0x0, msg.sender, 0x0, _amount, 0, 0, 0, 0, _interestRate,\n            _interestRatePunitory, 0, _duesIn, _currency, _cancelableAt, 0, 0x0, _expirationRequest);\n        uint index = loans.push(loan) - 1;\n        CreatedLoan(index, _borrower, msg.sender);\n\n        if (msg.sender == _borrower) {\n            approveLoan(index);\n        }\n\n        return index;\n    }\n    \n    function ownerOf(uint256 index) constant returns (address owner) { owner = loans[index].lender; }\n    function getTotalLoans() constant returns (uint256) { return loans.length; }\n    function getOracle(uint index) constant returns (Oracle) { return loans[index].oracle; }\n    function getBorrower(uint index) constant returns (address) { return loans[index].borrower; }\n    function getCosigner(uint index) constant returns (address) { return loans[index].cosigner; }\n    function getCreator(uint index) constant returns (address) { return loans[index].creator; }\n    function getAmount(uint index) constant returns (uint256) { return loans[index].amount; }\n    function getPunitoryInterest(uint index) constant returns (uint256) { return loans[index].punitoryInterest; }\n    function getInterestTimestamp(uint index) constant returns (uint256) { return loans[index].interestTimestamp; }\n    function getPaid(uint index) constant returns (uint256) { return loans[index].paid; }\n    function getInterestRate(uint index) constant returns (uint256) { return loans[index].interestRate; }\n    function getInterestRatePunitory(uint index) constant returns (uint256) { return loans[index].interestRatePunitory; }\n    function getDueTime(uint index) constant returns (uint256) { return loans[index].dueTime; }\n    function getDuesIn(uint index) constant returns (uint256) { return loans[index].duesIn; }\n    function getCancelableAt(uint index) constant returns (uint256) { return loans[index].cancelableAt; }\n    function getApprobation(uint index, address _address) constant returns (bool) { return loans[index].approbations[_address]; }\n    function getStatus(uint index) constant returns (Status) { return loans[index].status; }\n    function getLenderBalance(uint index) constant returns (uint256) { return loans[index].lenderBalance; }\n    function getApprovedTransfer(uint index) constant returns (address) {return loans[index].approvedTransfer; }\n    function getCurrency(uint index) constant returns (bytes32) { return loans[index].currency; }\n    function getExpirationRequest(uint index) constant returns (uint256) { return loans[index].expirationRequest; }\n    function getInterest(uint index) constant returns (uint256) { return loans[index].interest; }\n\n    /**\n        @param index Index of the loan\n\n        @return true if the loan has been approved by the borrower and cosigner.\n    */\n    function isApproved(uint index) constant returns (bool) {\n        Loan storage loan = loans[index];\n        return loan.approbations[loan.borrower];\n    }\n\n    /**\n        @dev Called by the members of the loan to show that they agree with the terms of the loan; the borrower\n        must call this method before any lender could call the method \"lend\".\n            \n        Any address can call this method to be added to the \"approbations\" mapping.\n\n        @param index Index of the loan\n\n        @return true if the approve was done successfully\n    */\n    function approveLoan(uint index) public returns(bool) {\n        Loan storage loan = loans[index];\n        require(loan.status == Status.initial);\n        loan.approbations[msg.sender] = true;\n        ApprovedBy(index, msg.sender);\n        return true;\n    }\n\n    /**\n        @dev Performs the lend of the RCN equivalent to the requested amount, and transforms the msg.sender in the new lender.\n\n        The loan must be previously approved by the borrower; before calling this function, the lender candidate must \n        call the \"approve\" function on the RCN Token, specifying an amount sufficient enough to pay the equivalent of\n        the requested amount, and the cosigner fee.\n        \n        @param index Index of the loan\n        @param oracleData Data required by the oracle to return the rate, the content of this field must be provided\n            by the url exposed in the url() method of the oracle.\n        @param cosigner Address of the cosigner, 0x0 for lending without cosigner.\n        @param cosignerData Data required by the cosigner to process the request.\n\n        @return true if the lend was done successfully\n    */\n    function lend(uint index, bytes oracleData, Cosigner cosigner, bytes cosignerData) public returns (bool) {\n        Loan storage loan = loans[index];\n\n        require(loan.status == Status.initial);\n        require(isApproved(index));\n        require(block.timestamp <= loan.expirationRequest);\n\n        loan.lender = msg.sender;\n        loan.dueTime = safeAdd(block.timestamp, loan.duesIn);\n        loan.interestTimestamp = block.timestamp;\n        loan.status = Status.lent;\n        \n        if (loan.cancelableAt > 0)\n            internalAddInterest(loan, safeAdd(block.timestamp, loan.cancelableAt));\n\n        uint256 rate = getRate(loan, oracleData);\n\n        if (cosigner != address(0)) {\n            // The cosigner it's temporary set to the next address (cosigner + 2), it's expected that the cosigner will\n            // call the method \"cosign\" to accept the conditions; that method also sets the cosigner to the right\n            // address. If that does not happen, the transaction fails.\n            loan.cosigner = address(uint256(cosigner) + 2);\n            require(cosigner.requestCosign(this, index, cosignerData, oracleData));\n            require(loan.cosigner == address(cosigner));\n        }\n        \n        require(rcn.transferFrom(msg.sender, loan.borrower, safeMult(loan.amount, rate)));\n        \n        // ERC721, create new loan and transfer it to the lender\n        Transfer(0x0, loan.lender, index);\n        activeLoans += 1;\n        lendersBalance[loan.lender] += 1;\n        Lent(index, loan.lender, cosigner);\n\n        return true;\n    }\n\n    /**\n        @dev The cosigner must call this method to accept the conditions of a loan, this method pays the cosigner his fee\n\n        @param index Index of the loan\n        @param cost Fee set by the cosigner\n\n        @return true If the cosign was successfull\n    */\n    function cosign(uint index, uint256 cost) external returns (bool) {\n        Loan storage loan = loans[index];\n        require(loan.status == Status.lent && (loan.dueTime - loan.duesIn) == block.timestamp);\n        require(loan.cosigner != address(0));\n        require(loan.cosigner == address(uint256(msg.sender) + 2));\n        loan.cosigner = msg.sender;\n        require(rcn.transferFrom(loan.lender, msg.sender, cost));\n        return true;\n    }\n\n    /**\n        @dev Destroys a loan, the borrower could call this method if they performed an accidental or regretted \n        \"approve\" of the loan, this method only works for them if the loan is in \"pending\" status.\n\n        The lender can call this method at any moment, in case of a loan with status \"lent\" the lender is pardoning \n        the debt. \n\n        @param index Index of the loan\n\n        @return true if the destroy was done successfully\n    */\n    function destroy(uint index) public returns (bool) {\n        Loan storage loan = loans[index];\n        require(loan.status != Status.destroyed);\n        require(msg.sender == loan.lender || (msg.sender == loan.borrower && loan.status == Status.initial));\n        DestroyedBy(index, msg.sender);\n\n        // ERC721, remove loan from circulation\n        if (loan.status != Status.initial) {\n            lendersBalance[loan.lender] -= 1;\n            activeLoans -= 1;\n            Transfer(loan.lender, 0x0, index);\n        }\n\n        loan.status = Status.destroyed;\n        return true;\n    }\n\n    /**\n        @dev Transfers a loan to a different lender, the caller must be the current lender or previously being\n        approved with the method \"approveTransfer\"; only loans with the Status.lent status can be transfered.\n\n        @param index Index of the loan\n        @param to New lender\n\n        @return true if the transfer was done successfully\n    */\n    function transfer(address to, uint256 index) public returns (bool) {\n        Loan storage loan = loans[index];\n        \n        require(loan.status != Status.destroyed && loan.status != Status.paid);\n        require(msg.sender == loan.lender || msg.sender == loan.approvedTransfer);\n        require(to != address(0));\n        loan.lender = to;\n        loan.approvedTransfer = address(0);\n\n        // ERC721, transfer loan to another address\n        lendersBalance[msg.sender] -= 1;\n        lendersBalance[to] += 1;\n        Transfer(loan.lender, to, index);\n\n        return true;\n    }\n\n    /**\n        @dev ERC721 method, transfers the loan to the msg.sender, the msg.sender must be approved using the \n        \"approve\" method.\n\n        @return true if the transfer was successfull\n    */\n    function takeOwnership(uint256 _index) public returns (bool) {\n        return transfer(msg.sender, _index);\n    }\n\n    /**\n        @dev Approves the transfer of a given loan in the name of the lender, the behavior of this function is similar to\n        \"approve\" in the ERC20 standard, but only one approved address is allowed at a time.\n\n        The same method can be called passing 0x0 as parameter \"to\" to erase a previously approved address.\n\n        @param to Address allowed to transfer the loan or 0x0 to delete\n        @param index Index of the loan\n\n        @return true if the approve was done successfully\n    */\n    function approve(address to, uint256 index) public returns (bool) {\n        Loan storage loan = loans[index];\n        require(msg.sender == loan.lender);\n        loan.approvedTransfer = to;\n        Approval(msg.sender, to, index);\n        return true;\n    }\n\n    /**\n        @dev Returns the pending amount to complete de payment of the loan, keep in mind that this number increases \n        every second.\n\n        @param index Index of the loan\n\n        @return Aprox pending payment amount\n    */\n    function getPendingAmount(uint index) public constant returns (uint256) {\n        Loan storage loan = loans[index];\n        addInterest(index);\n        return getRawPendingAmount(loan);\n    }\n\n    function getRawPendingAmount(Loan loan) internal returns (uint256) {\n        return safeSubtract(safeAdd(safeAdd(loan.amount, loan.interest), loan.punitoryInterest), loan.paid);\n    }\n\n    /**\n        @dev Calculates the interest of a given amount, interest rate and delta time.\n\n        @param timeDelta Elapsed time\n        @param interestRate Interest rate expressed as the denominator of 10 000 000.\n        @param amount Amount to apply interest\n\n        @return realDelta The real timeDelta applied\n        @return interest The interest gained in the realDelta time\n    */\n    function calculateInterest(uint256 timeDelta, uint256 interestRate, uint256 amount) public constant returns (uint256 realDelta, uint256 interest) {\n        if (amount == 0) {\n            interest = 0;\n            realDelta = timeDelta;\n        } else {\n            interest = safeMult(safeMult(100000, amount), timeDelta) / interestRate;\n            realDelta = safeMult(interest, interestRate) / (amount * 100000);\n        }\n    }\n\n    /**\n        @dev Computes loan interest\n\n        Computes the punitory and non-punitory interest of a given loan and only applies the change.\n        \n        @param loan Loan to compute interest\n        @param timestamp Target absolute unix time to calculate interest.\n    */\n    function internalAddInterest(Loan storage loan, uint256 timestamp) internal {\n        if (timestamp > loan.interestTimestamp) {\n            uint256 newInterest = loan.interest;\n            uint256 newPunitoryInterest = loan.punitoryInterest;\n\n            uint256 newTimestamp;\n            uint256 realDelta;\n            uint256 calculatedInterest;\n\n            uint256 deltaTime;\n            uint256 pending;\n\n            uint256 endNonPunitory = min(timestamp, loan.dueTime);\n            if (endNonPunitory > loan.interestTimestamp) {\n                deltaTime = endNonPunitory - loan.interestTimestamp;\n\n                if (loan.paid < loan.amount) {\n                    pending = loan.amount - loan.paid;\n                } else {\n                    pending = 0;\n                }\n\n                (realDelta, calculatedInterest) = calculateInterest(deltaTime, loan.interestRate, pending);\n                newInterest = safeAdd(calculatedInterest, newInterest);\n                newTimestamp = loan.interestTimestamp + realDelta;\n            }\n\n            if (timestamp > loan.dueTime) {\n                uint256 startPunitory = max(loan.dueTime, loan.interestTimestamp);\n                deltaTime = timestamp - startPunitory;\n\n                uint256 debt = safeAdd(loan.amount, newInterest);\n                pending = min(debt, safeSubtract(safeAdd(debt, newPunitoryInterest), loan.paid));\n\n                (realDelta, calculatedInterest) = calculateInterest(deltaTime, loan.interestRatePunitory, pending);\n                newPunitoryInterest = safeAdd(newPunitoryInterest, calculatedInterest);\n                newTimestamp = startPunitory + realDelta;\n            }\n            \n            if (newInterest != loan.interest || newPunitoryInterest != loan.punitoryInterest) {\n                loan.interestTimestamp = newTimestamp;\n                loan.interest = newInterest;\n                loan.punitoryInterest = newPunitoryInterest;\n            }\n        }\n    }\n\n    /**\n        @dev Computes loan interest only up to current unix time\n\n        @param timestamp Target absolute unix time to calculate interest.\n    */\n    function addInterestUpTo(Loan storage loan, uint256 timestamp) internal {\n        require(loan.status == Status.lent);\n        if (timestamp <= block.timestamp) {\n            internalAddInterest(loan, timestamp);\n        }\n    }\n\n    /**\n        @dev Updates the loan accumulated interests up to the current Unix time.\n        \n        @param index Index of the loan\n    */\n    function addInterest(uint index) public {\n        Loan storage loan = loans[index];\n        addInterestUpTo(loan, block.timestamp);\n    }\n    \n    /**\n        @dev Pay loan\n\n        Realizes a payment of a given Loan, before performing the payment the accumulated\n        interest is computed and added to the total pending amount.\n\n        Before calling this function, the msg.sender must call the \"approve\" function on the RCN Token, specifying an amount\n        sufficient enough to pay the equivalent of the desired payment and the oracle fee.\n\n        Because it is difficult or even impossible to know in advance how much RCN are going to be spent on the\n        transaction*, we recommend performing the \"approve\" using an amount 5% superior to the wallet estimated\n        spending. If the RCN spent results to be less, the extra tokens are never debited from the msg.sender.\n\n        * The RCN rate can fluctuate on the same block, and it is impossible to know in advance the exact time of the\n        confirmation of the transaction. \n\n        If the paid pending amount equals zero, the loan changes status to \"paid\" and it is considered closed.\n\n        @param index Index of the loan\n        @param _amount Amount to pay, specified in the loan currency; or in RCN if the loan has no oracle\n        @param _from The identity of the payer\n        @param oracleData Data required by the oracle to return the rate, the content of this field must be provided\n            by the url exposed in the url() method of the oracle.\n            \n        @return true if the payment was executed successfully\n    */\n    function pay(uint index, uint256 _amount, address _from, bytes oracleData) public returns (bool) {\n        Loan storage loan = loans[index];\n\n        require(loan.status == Status.lent);\n        addInterest(index);\n        uint256 toPay = min(getPendingAmount(index), _amount);\n        PartialPayment(index, msg.sender, _from, toPay);\n\n        loan.paid = safeAdd(loan.paid, toPay);\n\n        if (getRawPendingAmount(loan) == 0) {\n            TotalPayment(index);\n            loan.status = Status.paid;\n\n            // ERC721, remove loan from circulation\n            lendersBalance[loan.lender] -= 1;\n            activeLoans -= 1;\n            Transfer(loan.lender, 0x0, index);\n        }\n\n        uint256 rate = getRate(loan, oracleData);\n        uint256 transferValue = safeMult(toPay, rate);\n        lockTokens(rcn, transferValue);\n        require(rcn.transferFrom(msg.sender, this, transferValue));\n        loan.lenderBalance = safeAdd(transferValue, loan.lenderBalance);\n\n        return true;\n    }\n\n    /**\n        @dev Retrieves the rate corresponding of the loan oracle, if the loan has no oracle the rate is 1\n\n        @param loan The loan with the cosigner\n        @param data Data required by the oracle\n\n        @return The rate of the oracle\n    */\n    function getRate(Loan loan, bytes data) internal returns (uint256) {\n        if (loan.oracle == address(0)) {\n            return 1;\n        } else {\n            return loan.oracle.getRate(loan.currency, data);\n        }\n    }\n\n    /**\n        @dev Withdraw lender funds\n\n        When a loan is paid, the funds are not transferred automatically to the lender, the funds are stored on the\n        engine contract, and the lender must call this function specifying the amount desired to transfer and the \n        destination.\n\n        This behavior is defined to allow the temporary transfer of the loan to a smart contract, without worrying that\n        the contract will receive tokens that are not traceable; and it allows the development of decentralized \n        autonomous organizations.\n\n        @param index Index of the loan\n        @param to Destination of the wiwthdraw funds\n        @param amount Amount to withdraw, in RCN\n\n        @return true if the withdraw was executed successfully\n    */\n    function withdrawal(uint index, address to, uint256 amount) public returns (bool) {\n        Loan storage loan = loans[index];\n        require(msg.sender == loan.lender);\n        loan.lenderBalance = safeSubtract(loan.lenderBalance, amount);\n        require(rcn.transfer(to, amount));\n        unlockTokens(rcn, amount);\n        return true;\n    }\n\n    function withdrawalRange(uint256 fromIndex, uint256 toIndex, address to) public returns (uint256) {\n        uint256 loanId;\n        uint256 totalWithdraw = 0;\n\n        for (loanId = fromIndex; loanId <= toIndex; loanId++) {\n            Loan storage loan = loans[loanId];\n            if (loan.lender == msg.sender) {\n                totalWithdraw += loan.lenderBalance;\n                loan.lenderBalance = 0;\n            }\n        }\n\n        require(rcn.transfer(to, totalWithdraw));\n        unlockTokens(rcn, totalWithdraw);\n        \n        return totalWithdraw;\n    }\n\n    function withdrawalList(uint256[] memory loanIds, address to) public returns (uint256) {\n        uint256 inputId;\n        uint256 totalWithdraw = 0;\n\n        for (inputId = 0; inputId < loanIds.length; inputId++) {\n            Loan storage loan = loans[loanIds[inputId]];\n            if (loan.lender == msg.sender) {\n                totalWithdraw += loan.lenderBalance;\n                loan.lenderBalance = 0;\n            }\n        }\n\n        require(rcn.transfer(to, totalWithdraw));\n        unlockTokens(rcn, totalWithdraw);\n\n        return totalWithdraw;\n    }\n\n    /**\n        @dev Deprecates the engine, locks the creation of new loans.\n    */\n    function setDeprecated(bool _deprecated) public onlyOwner {\n        deprecated = _deprecated;\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinfabrik-RCN Network Smart Contract Audit/rcn-network-3ded36151ad55543d16c354e70161852de4061d0/contracts/NanoLoanEngine.sol",
        "vulnerability": "Assertion Failure",
        "check": "FP",
        "response": "Answer: No  \nReason: The code does not contain assert statements, thus no assertion failures can occur."
    },
    {
        "code_segment": "contract NanoLoanEngine is ERC721, Engine, Ownable, TokenLockable {\n    uint256 public constant VERSION = 202;\n    string public constant VERSION_NAME = \"Basalt\";\n\n    uint256 private activeLoans = 0;\n    mapping(address => uint256) private lendersBalance;\n\n    function name() constant returns (string _name) {\n        _name = \"RCN - Nano loan engine - Basalt 202\";\n    }\n\n    function symbol() constant returns (string _symbol) {\n        _symbol = \"RCN-NLE-202\";\n    }\n\n    function totalSupply() constant returns (uint _totalSupply) {\n        _totalSupply = activeLoans;\n    }\n\n    function balanceOf(address _owner) constant returns (uint _balance) {\n        _balance = lendersBalance[_owner];\n    }\n\n    function tokenOfOwnerByIndex(address _owner, uint256 _index) constant returns (uint tokenId) {\n        uint256 tokenCount = balanceOf(_owner);\n\n        if (tokenCount == 0 || _index >= tokenCount) {\n            // Fail transaction\n            revert();\n        } else {\n            uint256 totalLoans = totalSupply();\n            uint256 resultIndex = 0;\n\n            uint256 loanId;\n            // SWC-128-DoS With Block Gas Limit: L46\n            for (loanId = 0; loanId <= totalLoans; loanId++) {\n                if (loans[loanId].lender == _owner && loans[loanId].status == Status.lent) {\n                    if (resultIndex == _index) {\n                        return loanId;\n                    }\n                    resultIndex++;\n                }\n            }\n\n            revert();\n        }\n    }\n\n    function tokensOfOwner(address _owner) external constant returns(uint256[] ownerTokens) {\n        uint256 tokenCount = balanceOf(_owner);\n\n        if (tokenCount == 0) {\n            // Return an empty array\n            return new uint256[](0);\n        } else {\n            uint256[] memory result = new uint256[](tokenCount);\n            uint256 totalLoans = totalSupply();\n            uint256 resultIndex = 0;\n\n            uint256 loanId;\n\n            for (loanId = 0; loanId <= totalLoans; loanId++) {\n                if (loans[loanId].lender == _owner && loans[loanId].status == Status.lent) {\n                    result[resultIndex] = loanId;\n                    resultIndex++;\n                }\n            }\n\n            return result;\n        }\n    }\n    \n    Token public rcn;\n    bool public deprecated;\n\n    event CreatedLoan(uint _index, address _borrower, address _creator);\n    event ApprovedBy(uint _index, address _address);\n    event Lent(uint _index, address _lender, address _cosigner);\n    event DestroyedBy(uint _index, address _address);\n    event PartialPayment(uint _index, address _sender, address _from, uint256 _amount);\n    event TotalPayment(uint _index);\n\n    function NanoLoanEngine(Token _rcn) public {\n        owner = msg.sender;\n        rcn = _rcn;\n    }\n\n    struct Loan {\n        Status status;\n        Oracle oracle;\n\n        address borrower;\n        address lender;\n        address creator;\n        address cosigner;\n        \n        uint256 amount;\n        uint256 interest;\n        uint256 punitoryInterest;\n        uint256 interestTimestamp;\n        uint256 paid;\n        uint256 interestRate;\n        uint256 interestRatePunitory;\n        uint256 dueTime;\n        uint256 duesIn;\n\n        bytes32 currency;\n        uint256 cancelableAt;\n        uint256 lenderBalance;\n\n        address approvedTransfer;\n        uint256 expirationRequest;\n\n        mapping(address => bool) approbations;\n    }\n\n    Loan[] private loans;\n\n    /**\n        @dev Creates a loan request, the loan can be generated with any borrower, cosigner, and conditions; if the \n        cosigner and borrower agree they must call the \"approve\" function.\n\n        The creator of the loan is the caller of this function; this is useful to track which wallet created the loan.\n\n        @param _oracleContract Address of the Oracle contract, if the loan does not use any oracle, this field should be 0x0.\n        @param _borrower Address of the borrower\n        @param _currency The currency to use with the oracle, the currency code is generated with the following formula,\n            keccak256(ticker,decimals).\n        @param _amount The requested amount; currency and unit are defined by the Oracle, if there is no Oracle present\n            the currency is RCN, and the unit is wei.\n        @param _interestRate The non-punitory interest rate by second, defined as a denominator of 10 000 000.\n        @param _interestRatePunitory The punitory interest rate by second, defined as a denominator of 10 000 000.\n            Ej: interestRate 11108571428571 = 28% Anual interest\n        @param _duesIn The time in seconds that the borrower has in order to pay the debt after the lender lends the money.\n        @param _cancelableAt Delta in seconds specifying how much interest should be added in advance, if the borrower pays \n        entirely or partially the loan before this term, no extra interest will be deducted.\n        @param _expirationRequest Timestamp of when the loan request expires, if the loan is not filled before this date, \n            the request is no longer valid.\n    */\n    function createLoan(Oracle _oracleContract, address _borrower, bytes32 _currency, uint256 _amount, uint256 _interestRate,\n        uint256 _interestRatePunitory, uint256 _duesIn, uint256 _cancelableAt, uint256 _expirationRequest) returns (uint256) {\n\n        require(!deprecated);\n        require(_cancelableAt <= _duesIn);\n        require(_oracleContract != address(0) || _currency == 0x0);\n        require(_borrower != address(0));\n        require(_amount != 0);\n        require(_interestRatePunitory != 0);\n        require(_interestRate != 0);\n        require(_expirationRequest > block.timestamp);\n\n        var loan = Loan(Status.initial, _oracleContract, _borrower, 0x0, msg.sender, 0x0, _amount, 0, 0, 0, 0, _interestRate,\n            _interestRatePunitory, 0, _duesIn, _currency, _cancelableAt, 0, 0x0, _expirationRequest);\n        uint index = loans.push(loan) - 1;\n        CreatedLoan(index, _borrower, msg.sender);\n\n        if (msg.sender == _borrower) {\n            approveLoan(index);\n        }\n\n        return index;\n    }\n    \n    function ownerOf(uint256 index) constant returns (address owner) { owner = loans[index].lender; }\n    function getTotalLoans() constant returns (uint256) { return loans.length; }\n    function getOracle(uint index) constant returns (Oracle) { return loans[index].oracle; }\n    function getBorrower(uint index) constant returns (address) { return loans[index].borrower; }\n    function getCosigner(uint index) constant returns (address) { return loans[index].cosigner; }\n    function getCreator(uint index) constant returns (address) { return loans[index].creator; }\n    function getAmount(uint index) constant returns (uint256) { return loans[index].amount; }\n    function getPunitoryInterest(uint index) constant returns (uint256) { return loans[index].punitoryInterest; }\n    function getInterestTimestamp(uint index) constant returns (uint256) { return loans[index].interestTimestamp; }\n    function getPaid(uint index) constant returns (uint256) { return loans[index].paid; }\n    function getInterestRate(uint index) constant returns (uint256) { return loans[index].interestRate; }\n    function getInterestRatePunitory(uint index) constant returns (uint256) { return loans[index].interestRatePunitory; }\n    function getDueTime(uint index) constant returns (uint256) { return loans[index].dueTime; }\n    function getDuesIn(uint index) constant returns (uint256) { return loans[index].duesIn; }\n    function getCancelableAt(uint index) constant returns (uint256) { return loans[index].cancelableAt; }\n    function getApprobation(uint index, address _address) constant returns (bool) { return loans[index].approbations[_address]; }\n    function getStatus(uint index) constant returns (Status) { return loans[index].status; }\n    function getLenderBalance(uint index) constant returns (uint256) { return loans[index].lenderBalance; }\n    function getApprovedTransfer(uint index) constant returns (address) {return loans[index].approvedTransfer; }\n    function getCurrency(uint index) constant returns (bytes32) { return loans[index].currency; }\n    function getExpirationRequest(uint index) constant returns (uint256) { return loans[index].expirationRequest; }\n    function getInterest(uint index) constant returns (uint256) { return loans[index].interest; }\n\n    /**\n        @param index Index of the loan\n\n        @return true if the loan has been approved by the borrower and cosigner.\n    */\n    function isApproved(uint index) constant returns (bool) {\n        Loan storage loan = loans[index];\n        return loan.approbations[loan.borrower];\n    }\n\n    /**\n        @dev Called by the members of the loan to show that they agree with the terms of the loan; the borrower\n        must call this method before any lender could call the method \"lend\".\n            \n        Any address can call this method to be added to the \"approbations\" mapping.\n\n        @param index Index of the loan\n\n        @return true if the approve was done successfully\n    */\n    function approveLoan(uint index) public returns(bool) {\n        Loan storage loan = loans[index];\n        require(loan.status == Status.initial);\n        loan.approbations[msg.sender] = true;\n        ApprovedBy(index, msg.sender);\n        return true;\n    }\n\n    /**\n        @dev Performs the lend of the RCN equivalent to the requested amount, and transforms the msg.sender in the new lender.\n\n        The loan must be previously approved by the borrower; before calling this function, the lender candidate must \n        call the \"approve\" function on the RCN Token, specifying an amount sufficient enough to pay the equivalent of\n        the requested amount, and the cosigner fee.\n        \n        @param index Index of the loan\n        @param oracleData Data required by the oracle to return the rate, the content of this field must be provided\n            by the url exposed in the url() method of the oracle.\n        @param cosigner Address of the cosigner, 0x0 for lending without cosigner.\n        @param cosignerData Data required by the cosigner to process the request.\n\n        @return true if the lend was done successfully\n    */\n    function lend(uint index, bytes oracleData, Cosigner cosigner, bytes cosignerData) public returns (bool) {\n        Loan storage loan = loans[index];\n\n        require(loan.status == Status.initial);\n        require(isApproved(index));\n        require(block.timestamp <= loan.expirationRequest);\n\n        loan.lender = msg.sender;\n        loan.dueTime = safeAdd(block.timestamp, loan.duesIn);\n        loan.interestTimestamp = block.timestamp;\n        loan.status = Status.lent;\n        \n        if (loan.cancelableAt > 0)\n            internalAddInterest(loan, safeAdd(block.timestamp, loan.cancelableAt));\n\n        uint256 rate = getRate(loan, oracleData);\n\n        if (cosigner != address(0)) {\n            // The cosigner it's temporary set to the next address (cosigner + 2), it's expected that the cosigner will\n            // call the method \"cosign\" to accept the conditions; that method also sets the cosigner to the right\n            // address. If that does not happen, the transaction fails.\n            loan.cosigner = address(uint256(cosigner) + 2);\n            require(cosigner.requestCosign(this, index, cosignerData, oracleData));\n            require(loan.cosigner == address(cosigner));\n        }\n        \n        require(rcn.transferFrom(msg.sender, loan.borrower, safeMult(loan.amount, rate)));\n        \n        // ERC721, create new loan and transfer it to the lender\n        Transfer(0x0, loan.lender, index);\n        activeLoans += 1;\n        lendersBalance[loan.lender] += 1;\n        Lent(index, loan.lender, cosigner);\n\n        return true;\n    }\n\n    /**\n        @dev The cosigner must call this method to accept the conditions of a loan, this method pays the cosigner his fee\n\n        @param index Index of the loan\n        @param cost Fee set by the cosigner\n\n        @return true If the cosign was successfull\n    */\n    function cosign(uint index, uint256 cost) external returns (bool) {\n        Loan storage loan = loans[index];\n        require(loan.status == Status.lent && (loan.dueTime - loan.duesIn) == block.timestamp);\n        require(loan.cosigner != address(0));\n        require(loan.cosigner == address(uint256(msg.sender) + 2));\n        loan.cosigner = msg.sender;\n        require(rcn.transferFrom(loan.lender, msg.sender, cost));\n        return true;\n    }\n\n    /**\n        @dev Destroys a loan, the borrower could call this method if they performed an accidental or regretted \n        \"approve\" of the loan, this method only works for them if the loan is in \"pending\" status.\n\n        The lender can call this method at any moment, in case of a loan with status \"lent\" the lender is pardoning \n        the debt. \n\n        @param index Index of the loan\n\n        @return true if the destroy was done successfully\n    */\n    function destroy(uint index) public returns (bool) {\n        Loan storage loan = loans[index];\n        require(loan.status != Status.destroyed);\n        require(msg.sender == loan.lender || (msg.sender == loan.borrower && loan.status == Status.initial));\n        DestroyedBy(index, msg.sender);\n\n        // ERC721, remove loan from circulation\n        if (loan.status != Status.initial) {\n            lendersBalance[loan.lender] -= 1;\n            activeLoans -= 1;\n            Transfer(loan.lender, 0x0, index);\n        }\n\n        loan.status = Status.destroyed;\n        return true;\n    }\n\n    /**\n        @dev Transfers a loan to a different lender, the caller must be the current lender or previously being\n        approved with the method \"approveTransfer\"; only loans with the Status.lent status can be transfered.\n\n        @param index Index of the loan\n        @param to New lender\n\n        @return true if the transfer was done successfully\n    */\n    function transfer(address to, uint256 index) public returns (bool) {\n        Loan storage loan = loans[index];\n        \n        require(loan.status != Status.destroyed && loan.status != Status.paid);\n        require(msg.sender == loan.lender || msg.sender == loan.approvedTransfer);\n        require(to != address(0));\n        loan.lender = to;\n        loan.approvedTransfer = address(0);\n\n        // ERC721, transfer loan to another address\n        lendersBalance[msg.sender] -= 1;\n        lendersBalance[to] += 1;\n        Transfer(loan.lender, to, index);\n\n        return true;\n    }\n\n    /**\n        @dev ERC721 method, transfers the loan to the msg.sender, the msg.sender must be approved using the \n        \"approve\" method.\n\n        @return true if the transfer was successfull\n    */\n    function takeOwnership(uint256 _index) public returns (bool) {\n        return transfer(msg.sender, _index);\n    }\n\n    /**\n        @dev Approves the transfer of a given loan in the name of the lender, the behavior of this function is similar to\n        \"approve\" in the ERC20 standard, but only one approved address is allowed at a time.\n\n        The same method can be called passing 0x0 as parameter \"to\" to erase a previously approved address.\n\n        @param to Address allowed to transfer the loan or 0x0 to delete\n        @param index Index of the loan\n\n        @return true if the approve was done successfully\n    */\n    function approve(address to, uint256 index) public returns (bool) {\n        Loan storage loan = loans[index];\n        require(msg.sender == loan.lender);\n        loan.approvedTransfer = to;\n        Approval(msg.sender, to, index);\n        return true;\n    }\n\n    /**\n        @dev Returns the pending amount to complete de payment of the loan, keep in mind that this number increases \n        every second.\n\n        @param index Index of the loan\n\n        @return Aprox pending payment amount\n    */\n    function getPendingAmount(uint index) public constant returns (uint256) {\n        Loan storage loan = loans[index];\n        addInterest(index);\n        return getRawPendingAmount(loan);\n    }\n\n    function getRawPendingAmount(Loan loan) internal returns (uint256) {\n        return safeSubtract(safeAdd(safeAdd(loan.amount, loan.interest), loan.punitoryInterest), loan.paid);\n    }\n\n    /**\n        @dev Calculates the interest of a given amount, interest rate and delta time.\n\n        @param timeDelta Elapsed time\n        @param interestRate Interest rate expressed as the denominator of 10 000 000.\n        @param amount Amount to apply interest\n\n        @return realDelta The real timeDelta applied\n        @return interest The interest gained in the realDelta time\n    */\n    function calculateInterest(uint256 timeDelta, uint256 interestRate, uint256 amount) public constant returns (uint256 realDelta, uint256 interest) {\n        if (amount == 0) {\n            interest = 0;\n            realDelta = timeDelta;\n        } else {\n            interest = safeMult(safeMult(100000, amount), timeDelta) / interestRate;\n            realDelta = safeMult(interest, interestRate) / (amount * 100000);\n        }\n    }\n\n    /**\n        @dev Computes loan interest\n\n        Computes the punitory and non-punitory interest of a given loan and only applies the change.\n        \n        @param loan Loan to compute interest\n        @param timestamp Target absolute unix time to calculate interest.\n    */\n    function internalAddInterest(Loan storage loan, uint256 timestamp) internal {\n        if (timestamp > loan.interestTimestamp) {\n            uint256 newInterest = loan.interest;\n            uint256 newPunitoryInterest = loan.punitoryInterest;\n\n            uint256 newTimestamp;\n            uint256 realDelta;\n            uint256 calculatedInterest;\n\n            uint256 deltaTime;\n            uint256 pending;\n\n            uint256 endNonPunitory = min(timestamp, loan.dueTime);\n            if (endNonPunitory > loan.interestTimestamp) {\n                deltaTime = endNonPunitory - loan.interestTimestamp;\n\n                if (loan.paid < loan.amount) {\n                    pending = loan.amount - loan.paid;\n                } else {\n                    pending = 0;\n                }\n\n                (realDelta, calculatedInterest) = calculateInterest(deltaTime, loan.interestRate, pending);\n                newInterest = safeAdd(calculatedInterest, newInterest);\n                newTimestamp = loan.interestTimestamp + realDelta;\n            }\n\n            if (timestamp > loan.dueTime) {\n                uint256 startPunitory = max(loan.dueTime, loan.interestTimestamp);\n                deltaTime = timestamp - startPunitory;\n\n                uint256 debt = safeAdd(loan.amount, newInterest);\n                pending = min(debt, safeSubtract(safeAdd(debt, newPunitoryInterest), loan.paid));\n\n                (realDelta, calculatedInterest) = calculateInterest(deltaTime, loan.interestRatePunitory, pending);\n                newPunitoryInterest = safeAdd(newPunitoryInterest, calculatedInterest);\n                newTimestamp = startPunitory + realDelta;\n            }\n            \n            if (newInterest != loan.interest || newPunitoryInterest != loan.punitoryInterest) {\n                loan.interestTimestamp = newTimestamp;\n                loan.interest = newInterest;\n                loan.punitoryInterest = newPunitoryInterest;\n            }\n        }\n    }\n\n    /**\n        @dev Computes loan interest only up to current unix time\n\n        @param timestamp Target absolute unix time to calculate interest.\n    */\n    function addInterestUpTo(Loan storage loan, uint256 timestamp) internal {\n        require(loan.status == Status.lent);\n        if (timestamp <= block.timestamp) {\n            internalAddInterest(loan, timestamp);\n        }\n    }\n\n    /**\n        @dev Updates the loan accumulated interests up to the current Unix time.\n        \n        @param index Index of the loan\n    */\n    function addInterest(uint index) public {\n        Loan storage loan = loans[index];\n        addInterestUpTo(loan, block.timestamp);\n    }\n    \n    /**\n        @dev Pay loan\n\n        Realizes a payment of a given Loan, before performing the payment the accumulated\n        interest is computed and added to the total pending amount.\n\n        Before calling this function, the msg.sender must call the \"approve\" function on the RCN Token, specifying an amount\n        sufficient enough to pay the equivalent of the desired payment and the oracle fee.\n\n        Because it is difficult or even impossible to know in advance how much RCN are going to be spent on the\n        transaction*, we recommend performing the \"approve\" using an amount 5% superior to the wallet estimated\n        spending. If the RCN spent results to be less, the extra tokens are never debited from the msg.sender.\n\n        * The RCN rate can fluctuate on the same block, and it is impossible to know in advance the exact time of the\n        confirmation of the transaction. \n\n        If the paid pending amount equals zero, the loan changes status to \"paid\" and it is considered closed.\n\n        @param index Index of the loan\n        @param _amount Amount to pay, specified in the loan currency; or in RCN if the loan has no oracle\n        @param _from The identity of the payer\n        @param oracleData Data required by the oracle to return the rate, the content of this field must be provided\n            by the url exposed in the url() method of the oracle.\n            \n        @return true if the payment was executed successfully\n    */\n    function pay(uint index, uint256 _amount, address _from, bytes oracleData) public returns (bool) {\n        Loan storage loan = loans[index];\n\n        require(loan.status == Status.lent);\n        addInterest(index);\n        uint256 toPay = min(getPendingAmount(index), _amount);\n        PartialPayment(index, msg.sender, _from, toPay);\n\n        loan.paid = safeAdd(loan.paid, toPay);\n\n        if (getRawPendingAmount(loan) == 0) {\n            TotalPayment(index);\n            loan.status = Status.paid;\n\n            // ERC721, remove loan from circulation\n            lendersBalance[loan.lender] -= 1;\n            activeLoans -= 1;\n            Transfer(loan.lender, 0x0, index);\n        }\n\n        uint256 rate = getRate(loan, oracleData);\n        uint256 transferValue = safeMult(toPay, rate);\n        lockTokens(rcn, transferValue);\n        require(rcn.transferFrom(msg.sender, this, transferValue));\n        loan.lenderBalance = safeAdd(transferValue, loan.lenderBalance);\n\n        return true;\n    }\n\n    /**\n        @dev Retrieves the rate corresponding of the loan oracle, if the loan has no oracle the rate is 1\n\n        @param loan The loan with the cosigner\n        @param data Data required by the oracle\n\n        @return The rate of the oracle\n    */\n    function getRate(Loan loan, bytes data) internal returns (uint256) {\n        if (loan.oracle == address(0)) {\n            return 1;\n        } else {\n            return loan.oracle.getRate(loan.currency, data);\n        }\n    }\n\n    /**\n        @dev Withdraw lender funds\n\n        When a loan is paid, the funds are not transferred automatically to the lender, the funds are stored on the\n        engine contract, and the lender must call this function specifying the amount desired to transfer and the \n        destination.\n\n        This behavior is defined to allow the temporary transfer of the loan to a smart contract, without worrying that\n        the contract will receive tokens that are not traceable; and it allows the development of decentralized \n        autonomous organizations.\n\n        @param index Index of the loan\n        @param to Destination of the wiwthdraw funds\n        @param amount Amount to withdraw, in RCN\n\n        @return true if the withdraw was executed successfully\n    */\n    function withdrawal(uint index, address to, uint256 amount) public returns (bool) {\n        Loan storage loan = loans[index];\n        require(msg.sender == loan.lender);\n        loan.lenderBalance = safeSubtract(loan.lenderBalance, amount);\n        require(rcn.transfer(to, amount));\n        unlockTokens(rcn, amount);\n        return true;\n    }\n\n    function withdrawalRange(uint256 fromIndex, uint256 toIndex, address to) public returns (uint256) {\n        uint256 loanId;\n        uint256 totalWithdraw = 0;\n\n        for (loanId = fromIndex; loanId <= toIndex; loanId++) {\n            Loan storage loan = loans[loanId];\n            if (loan.lender == msg.sender) {\n                totalWithdraw += loan.lenderBalance;\n                loan.lenderBalance = 0;\n            }\n        }\n\n        require(rcn.transfer(to, totalWithdraw));\n        unlockTokens(rcn, totalWithdraw);\n        \n        return totalWithdraw;\n    }\n\n    function withdrawalList(uint256[] memory loanIds, address to) public returns (uint256) {\n        uint256 inputId;\n        uint256 totalWithdraw = 0;\n\n        for (inputId = 0; inputId < loanIds.length; inputId++) {\n            Loan storage loan = loans[loanIds[inputId]];\n            if (loan.lender == msg.sender) {\n                totalWithdraw += loan.lenderBalance;\n                loan.lenderBalance = 0;\n            }\n        }\n\n        require(rcn.transfer(to, totalWithdraw));\n        unlockTokens(rcn, totalWithdraw);\n\n        return totalWithdraw;\n    }\n\n    /**\n        @dev Deprecates the engine, locks the creation of new loans.\n    */\n    function setDeprecated(bool _deprecated) public onlyOwner {\n        deprecated = _deprecated;\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinfabrik-RCN Network Smart Contract Audit/rcn-network-3ded36151ad55543d16c354e70161852de4061d0/contracts/NanoLoanEngine.sol",
        "vulnerability": "Assertion Failure",
        "check": "FP",
        "response": "Answer: No\nReason: There are no assertions in the code, and each function includes proper require statements for necessary conditions."
    },
    {
        "code_segment": "contract NanoLoanEngine is ERC721, Engine, Ownable, TokenLockable {\n    uint256 public constant VERSION = 202;\n    string public constant VERSION_NAME = \"Basalt\";\n\n    uint256 private activeLoans = 0;\n    mapping(address => uint256) private lendersBalance;\n\n    function name() constant returns (string _name) {\n        _name = \"RCN - Nano loan engine - Basalt 202\";\n    }\n\n    function symbol() constant returns (string _symbol) {\n        _symbol = \"RCN-NLE-202\";\n    }\n\n    function totalSupply() constant returns (uint _totalSupply) {\n        _totalSupply = activeLoans;\n    }\n\n    function balanceOf(address _owner) constant returns (uint _balance) {\n        _balance = lendersBalance[_owner];\n    }\n\n    function tokenOfOwnerByIndex(address _owner, uint256 _index) constant returns (uint tokenId) {\n        uint256 tokenCount = balanceOf(_owner);\n\n        if (tokenCount == 0 || _index >= tokenCount) {\n            // Fail transaction\n            revert();\n        } else {\n            uint256 totalLoans = totalSupply();\n            uint256 resultIndex = 0;\n\n            uint256 loanId;\n            // SWC-128-DoS With Block Gas Limit: L46\n            for (loanId = 0; loanId <= totalLoans; loanId++) {\n                if (loans[loanId].lender == _owner && loans[loanId].status == Status.lent) {\n                    if (resultIndex == _index) {\n                        return loanId;\n                    }\n                    resultIndex++;\n                }\n            }\n\n            revert();\n        }\n    }\n\n    function tokensOfOwner(address _owner) external constant returns(uint256[] ownerTokens) {\n        uint256 tokenCount = balanceOf(_owner);\n\n        if (tokenCount == 0) {\n            // Return an empty array\n            return new uint256[](0);\n        } else {\n            uint256[] memory result = new uint256[](tokenCount);\n            uint256 totalLoans = totalSupply();\n            uint256 resultIndex = 0;\n\n            uint256 loanId;\n\n            for (loanId = 0; loanId <= totalLoans; loanId++) {\n                if (loans[loanId].lender == _owner && loans[loanId].status == Status.lent) {\n                    result[resultIndex] = loanId;\n                    resultIndex++;\n                }\n            }\n\n            return result;\n        }\n    }\n    \n    Token public rcn;\n    bool public deprecated;\n\n    event CreatedLoan(uint _index, address _borrower, address _creator);\n    event ApprovedBy(uint _index, address _address);\n    event Lent(uint _index, address _lender, address _cosigner);\n    event DestroyedBy(uint _index, address _address);\n    event PartialPayment(uint _index, address _sender, address _from, uint256 _amount);\n    event TotalPayment(uint _index);\n\n    function NanoLoanEngine(Token _rcn) public {\n        owner = msg.sender;\n        rcn = _rcn;\n    }\n\n    struct Loan {\n        Status status;\n        Oracle oracle;\n\n        address borrower;\n        address lender;\n        address creator;\n        address cosigner;\n        \n        uint256 amount;\n        uint256 interest;\n        uint256 punitoryInterest;\n        uint256 interestTimestamp;\n        uint256 paid;\n        uint256 interestRate;\n        uint256 interestRatePunitory;\n        uint256 dueTime;\n        uint256 duesIn;\n\n        bytes32 currency;\n        uint256 cancelableAt;\n        uint256 lenderBalance;\n\n        address approvedTransfer;\n        uint256 expirationRequest;\n\n        mapping(address => bool) approbations;\n    }\n\n    Loan[] private loans;\n\n    /**\n        @dev Creates a loan request, the loan can be generated with any borrower, cosigner, and conditions; if the \n        cosigner and borrower agree they must call the \"approve\" function.\n\n        The creator of the loan is the caller of this function; this is useful to track which wallet created the loan.\n\n        @param _oracleContract Address of the Oracle contract, if the loan does not use any oracle, this field should be 0x0.\n        @param _borrower Address of the borrower\n        @param _currency The currency to use with the oracle, the currency code is generated with the following formula,\n            keccak256(ticker,decimals).\n        @param _amount The requested amount; currency and unit are defined by the Oracle, if there is no Oracle present\n            the currency is RCN, and the unit is wei.\n        @param _interestRate The non-punitory interest rate by second, defined as a denominator of 10 000 000.\n        @param _interestRatePunitory The punitory interest rate by second, defined as a denominator of 10 000 000.\n            Ej: interestRate 11108571428571 = 28% Anual interest\n        @param _duesIn The time in seconds that the borrower has in order to pay the debt after the lender lends the money.\n        @param _cancelableAt Delta in seconds specifying how much interest should be added in advance, if the borrower pays \n        entirely or partially the loan before this term, no extra interest will be deducted.\n        @param _expirationRequest Timestamp of when the loan request expires, if the loan is not filled before this date, \n            the request is no longer valid.\n    */\n    function createLoan(Oracle _oracleContract, address _borrower, bytes32 _currency, uint256 _amount, uint256 _interestRate,\n        uint256 _interestRatePunitory, uint256 _duesIn, uint256 _cancelableAt, uint256 _expirationRequest) returns (uint256) {\n\n        require(!deprecated);\n        require(_cancelableAt <= _duesIn);\n        require(_oracleContract != address(0) || _currency == 0x0);\n        require(_borrower != address(0));\n        require(_amount != 0);\n        require(_interestRatePunitory != 0);\n        require(_interestRate != 0);\n        require(_expirationRequest > block.timestamp);\n\n        var loan = Loan(Status.initial, _oracleContract, _borrower, 0x0, msg.sender, 0x0, _amount, 0, 0, 0, 0, _interestRate,\n            _interestRatePunitory, 0, _duesIn, _currency, _cancelableAt, 0, 0x0, _expirationRequest);\n        uint index = loans.push(loan) - 1;\n        CreatedLoan(index, _borrower, msg.sender);\n\n        if (msg.sender == _borrower) {\n            approveLoan(index);\n        }\n\n        return index;\n    }\n    \n    function ownerOf(uint256 index) constant returns (address owner) { owner = loans[index].lender; }\n    function getTotalLoans() constant returns (uint256) { return loans.length; }\n    function getOracle(uint index) constant returns (Oracle) { return loans[index].oracle; }\n    function getBorrower(uint index) constant returns (address) { return loans[index].borrower; }\n    function getCosigner(uint index) constant returns (address) { return loans[index].cosigner; }\n    function getCreator(uint index) constant returns (address) { return loans[index].creator; }\n    function getAmount(uint index) constant returns (uint256) { return loans[index].amount; }\n    function getPunitoryInterest(uint index) constant returns (uint256) { return loans[index].punitoryInterest; }\n    function getInterestTimestamp(uint index) constant returns (uint256) { return loans[index].interestTimestamp; }\n    function getPaid(uint index) constant returns (uint256) { return loans[index].paid; }\n    function getInterestRate(uint index) constant returns (uint256) { return loans[index].interestRate; }\n    function getInterestRatePunitory(uint index) constant returns (uint256) { return loans[index].interestRatePunitory; }\n    function getDueTime(uint index) constant returns (uint256) { return loans[index].dueTime; }\n    function getDuesIn(uint index) constant returns (uint256) { return loans[index].duesIn; }\n    function getCancelableAt(uint index) constant returns (uint256) { return loans[index].cancelableAt; }\n    function getApprobation(uint index, address _address) constant returns (bool) { return loans[index].approbations[_address]; }\n    function getStatus(uint index) constant returns (Status) { return loans[index].status; }\n    function getLenderBalance(uint index) constant returns (uint256) { return loans[index].lenderBalance; }\n    function getApprovedTransfer(uint index) constant returns (address) {return loans[index].approvedTransfer; }\n    function getCurrency(uint index) constant returns (bytes32) { return loans[index].currency; }\n    function getExpirationRequest(uint index) constant returns (uint256) { return loans[index].expirationRequest; }\n    function getInterest(uint index) constant returns (uint256) { return loans[index].interest; }\n\n    /**\n        @param index Index of the loan\n\n        @return true if the loan has been approved by the borrower and cosigner.\n    */\n    function isApproved(uint index) constant returns (bool) {\n        Loan storage loan = loans[index];\n        return loan.approbations[loan.borrower];\n    }\n\n    /**\n        @dev Called by the members of the loan to show that they agree with the terms of the loan; the borrower\n        must call this method before any lender could call the method \"lend\".\n            \n        Any address can call this method to be added to the \"approbations\" mapping.\n\n        @param index Index of the loan\n\n        @return true if the approve was done successfully\n    */\n    function approveLoan(uint index) public returns(bool) {\n        Loan storage loan = loans[index];\n        require(loan.status == Status.initial);\n        loan.approbations[msg.sender] = true;\n        ApprovedBy(index, msg.sender);\n        return true;\n    }\n\n    /**\n        @dev Performs the lend of the RCN equivalent to the requested amount, and transforms the msg.sender in the new lender.\n\n        The loan must be previously approved by the borrower; before calling this function, the lender candidate must \n        call the \"approve\" function on the RCN Token, specifying an amount sufficient enough to pay the equivalent of\n        the requested amount, and the cosigner fee.\n        \n        @param index Index of the loan\n        @param oracleData Data required by the oracle to return the rate, the content of this field must be provided\n            by the url exposed in the url() method of the oracle.\n        @param cosigner Address of the cosigner, 0x0 for lending without cosigner.\n        @param cosignerData Data required by the cosigner to process the request.\n\n        @return true if the lend was done successfully\n    */\n    function lend(uint index, bytes oracleData, Cosigner cosigner, bytes cosignerData) public returns (bool) {\n        Loan storage loan = loans[index];\n\n        require(loan.status == Status.initial);\n        require(isApproved(index));\n        require(block.timestamp <= loan.expirationRequest);\n\n        loan.lender = msg.sender;\n        loan.dueTime = safeAdd(block.timestamp, loan.duesIn);\n        loan.interestTimestamp = block.timestamp;\n        loan.status = Status.lent;\n        \n        if (loan.cancelableAt > 0)\n            internalAddInterest(loan, safeAdd(block.timestamp, loan.cancelableAt));\n\n        uint256 rate = getRate(loan, oracleData);\n\n        if (cosigner != address(0)) {\n            // The cosigner it's temporary set to the next address (cosigner + 2), it's expected that the cosigner will\n            // call the method \"cosign\" to accept the conditions; that method also sets the cosigner to the right\n            // address. If that does not happen, the transaction fails.\n            loan.cosigner = address(uint256(cosigner) + 2);\n            require(cosigner.requestCosign(this, index, cosignerData, oracleData));\n            require(loan.cosigner == address(cosigner));\n        }\n        \n        require(rcn.transferFrom(msg.sender, loan.borrower, safeMult(loan.amount, rate)));\n        \n        // ERC721, create new loan and transfer it to the lender\n        Transfer(0x0, loan.lender, index);\n        activeLoans += 1;\n        lendersBalance[loan.lender] += 1;\n        Lent(index, loan.lender, cosigner);\n\n        return true;\n    }\n\n    /**\n        @dev The cosigner must call this method to accept the conditions of a loan, this method pays the cosigner his fee\n\n        @param index Index of the loan\n        @param cost Fee set by the cosigner\n\n        @return true If the cosign was successfull\n    */\n    function cosign(uint index, uint256 cost) external returns (bool) {\n        Loan storage loan = loans[index];\n        require(loan.status == Status.lent && (loan.dueTime - loan.duesIn) == block.timestamp);\n        require(loan.cosigner != address(0));\n        require(loan.cosigner == address(uint256(msg.sender) + 2));\n        loan.cosigner = msg.sender;\n        require(rcn.transferFrom(loan.lender, msg.sender, cost));\n        return true;\n    }\n\n    /**\n        @dev Destroys a loan, the borrower could call this method if they performed an accidental or regretted \n        \"approve\" of the loan, this method only works for them if the loan is in \"pending\" status.\n\n        The lender can call this method at any moment, in case of a loan with status \"lent\" the lender is pardoning \n        the debt. \n\n        @param index Index of the loan\n\n        @return true if the destroy was done successfully\n    */\n    function destroy(uint index) public returns (bool) {\n        Loan storage loan = loans[index];\n        require(loan.status != Status.destroyed);\n        require(msg.sender == loan.lender || (msg.sender == loan.borrower && loan.status == Status.initial));\n        DestroyedBy(index, msg.sender);\n\n        // ERC721, remove loan from circulation\n        if (loan.status != Status.initial) {\n            lendersBalance[loan.lender] -= 1;\n            activeLoans -= 1;\n            Transfer(loan.lender, 0x0, index);\n        }\n\n        loan.status = Status.destroyed;\n        return true;\n    }\n\n    /**\n        @dev Transfers a loan to a different lender, the caller must be the current lender or previously being\n        approved with the method \"approveTransfer\"; only loans with the Status.lent status can be transfered.\n\n        @param index Index of the loan\n        @param to New lender\n\n        @return true if the transfer was done successfully\n    */\n    function transfer(address to, uint256 index) public returns (bool) {\n        Loan storage loan = loans[index];\n        \n        require(loan.status != Status.destroyed && loan.status != Status.paid);\n        require(msg.sender == loan.lender || msg.sender == loan.approvedTransfer);\n        require(to != address(0));\n        loan.lender = to;\n        loan.approvedTransfer = address(0);\n\n        // ERC721, transfer loan to another address\n        lendersBalance[msg.sender] -= 1;\n        lendersBalance[to] += 1;\n        Transfer(loan.lender, to, index);\n\n        return true;\n    }\n\n    /**\n        @dev ERC721 method, transfers the loan to the msg.sender, the msg.sender must be approved using the \n        \"approve\" method.\n\n        @return true if the transfer was successfull\n    */\n    function takeOwnership(uint256 _index) public returns (bool) {\n        return transfer(msg.sender, _index);\n    }\n\n    /**\n        @dev Approves the transfer of a given loan in the name of the lender, the behavior of this function is similar to\n        \"approve\" in the ERC20 standard, but only one approved address is allowed at a time.\n\n        The same method can be called passing 0x0 as parameter \"to\" to erase a previously approved address.\n\n        @param to Address allowed to transfer the loan or 0x0 to delete\n        @param index Index of the loan\n\n        @return true if the approve was done successfully\n    */\n    function approve(address to, uint256 index) public returns (bool) {\n        Loan storage loan = loans[index];\n        require(msg.sender == loan.lender);\n        loan.approvedTransfer = to;\n        Approval(msg.sender, to, index);\n        return true;\n    }\n\n    /**\n        @dev Returns the pending amount to complete de payment of the loan, keep in mind that this number increases \n        every second.\n\n        @param index Index of the loan\n\n        @return Aprox pending payment amount\n    */\n    function getPendingAmount(uint index) public constant returns (uint256) {\n        Loan storage loan = loans[index];\n        addInterest(index);\n        return getRawPendingAmount(loan);\n    }\n\n    function getRawPendingAmount(Loan loan) internal returns (uint256) {\n        return safeSubtract(safeAdd(safeAdd(loan.amount, loan.interest), loan.punitoryInterest), loan.paid);\n    }\n\n    /**\n        @dev Calculates the interest of a given amount, interest rate and delta time.\n\n        @param timeDelta Elapsed time\n        @param interestRate Interest rate expressed as the denominator of 10 000 000.\n        @param amount Amount to apply interest\n\n        @return realDelta The real timeDelta applied\n        @return interest The interest gained in the realDelta time\n    */\n    function calculateInterest(uint256 timeDelta, uint256 interestRate, uint256 amount) public constant returns (uint256 realDelta, uint256 interest) {\n        if (amount == 0) {\n            interest = 0;\n            realDelta = timeDelta;\n        } else {\n            interest = safeMult(safeMult(100000, amount), timeDelta) / interestRate;\n            realDelta = safeMult(interest, interestRate) / (amount * 100000);\n        }\n    }\n\n    /**\n        @dev Computes loan interest\n\n        Computes the punitory and non-punitory interest of a given loan and only applies the change.\n        \n        @param loan Loan to compute interest\n        @param timestamp Target absolute unix time to calculate interest.\n    */\n    function internalAddInterest(Loan storage loan, uint256 timestamp) internal {\n        if (timestamp > loan.interestTimestamp) {\n            uint256 newInterest = loan.interest;\n            uint256 newPunitoryInterest = loan.punitoryInterest;\n\n            uint256 newTimestamp;\n            uint256 realDelta;\n            uint256 calculatedInterest;\n\n            uint256 deltaTime;\n            uint256 pending;\n\n            uint256 endNonPunitory = min(timestamp, loan.dueTime);\n            if (endNonPunitory > loan.interestTimestamp) {\n                deltaTime = endNonPunitory - loan.interestTimestamp;\n\n                if (loan.paid < loan.amount) {\n                    pending = loan.amount - loan.paid;\n                } else {\n                    pending = 0;\n                }\n\n                (realDelta, calculatedInterest) = calculateInterest(deltaTime, loan.interestRate, pending);\n                newInterest = safeAdd(calculatedInterest, newInterest);\n                newTimestamp = loan.interestTimestamp + realDelta;\n            }\n\n            if (timestamp > loan.dueTime) {\n                uint256 startPunitory = max(loan.dueTime, loan.interestTimestamp);\n                deltaTime = timestamp - startPunitory;\n\n                uint256 debt = safeAdd(loan.amount, newInterest);\n                pending = min(debt, safeSubtract(safeAdd(debt, newPunitoryInterest), loan.paid));\n\n                (realDelta, calculatedInterest) = calculateInterest(deltaTime, loan.interestRatePunitory, pending);\n                newPunitoryInterest = safeAdd(newPunitoryInterest, calculatedInterest);\n                newTimestamp = startPunitory + realDelta;\n            }\n            \n            if (newInterest != loan.interest || newPunitoryInterest != loan.punitoryInterest) {\n                loan.interestTimestamp = newTimestamp;\n                loan.interest = newInterest;\n                loan.punitoryInterest = newPunitoryInterest;\n            }\n        }\n    }\n\n    /**\n        @dev Computes loan interest only up to current unix time\n\n        @param timestamp Target absolute unix time to calculate interest.\n    */\n    function addInterestUpTo(Loan storage loan, uint256 timestamp) internal {\n        require(loan.status == Status.lent);\n        if (timestamp <= block.timestamp) {\n            internalAddInterest(loan, timestamp);\n        }\n    }\n\n    /**\n        @dev Updates the loan accumulated interests up to the current Unix time.\n        \n        @param index Index of the loan\n    */\n    function addInterest(uint index) public {\n        Loan storage loan = loans[index];\n        addInterestUpTo(loan, block.timestamp);\n    }\n    \n    /**\n        @dev Pay loan\n\n        Realizes a payment of a given Loan, before performing the payment the accumulated\n        interest is computed and added to the total pending amount.\n\n        Before calling this function, the msg.sender must call the \"approve\" function on the RCN Token, specifying an amount\n        sufficient enough to pay the equivalent of the desired payment and the oracle fee.\n\n        Because it is difficult or even impossible to know in advance how much RCN are going to be spent on the\n        transaction*, we recommend performing the \"approve\" using an amount 5% superior to the wallet estimated\n        spending. If the RCN spent results to be less, the extra tokens are never debited from the msg.sender.\n\n        * The RCN rate can fluctuate on the same block, and it is impossible to know in advance the exact time of the\n        confirmation of the transaction. \n\n        If the paid pending amount equals zero, the loan changes status to \"paid\" and it is considered closed.\n\n        @param index Index of the loan\n        @param _amount Amount to pay, specified in the loan currency; or in RCN if the loan has no oracle\n        @param _from The identity of the payer\n        @param oracleData Data required by the oracle to return the rate, the content of this field must be provided\n            by the url exposed in the url() method of the oracle.\n            \n        @return true if the payment was executed successfully\n    */\n    function pay(uint index, uint256 _amount, address _from, bytes oracleData) public returns (bool) {\n        Loan storage loan = loans[index];\n\n        require(loan.status == Status.lent);\n        addInterest(index);\n        uint256 toPay = min(getPendingAmount(index), _amount);\n        PartialPayment(index, msg.sender, _from, toPay);\n\n        loan.paid = safeAdd(loan.paid, toPay);\n\n        if (getRawPendingAmount(loan) == 0) {\n            TotalPayment(index);\n            loan.status = Status.paid;\n\n            // ERC721, remove loan from circulation\n            lendersBalance[loan.lender] -= 1;\n            activeLoans -= 1;\n            Transfer(loan.lender, 0x0, index);\n        }\n\n        uint256 rate = getRate(loan, oracleData);\n        uint256 transferValue = safeMult(toPay, rate);\n        lockTokens(rcn, transferValue);\n        require(rcn.transferFrom(msg.sender, this, transferValue));\n        loan.lenderBalance = safeAdd(transferValue, loan.lenderBalance);\n\n        return true;\n    }\n\n    /**\n        @dev Retrieves the rate corresponding of the loan oracle, if the loan has no oracle the rate is 1\n\n        @param loan The loan with the cosigner\n        @param data Data required by the oracle\n\n        @return The rate of the oracle\n    */\n    function getRate(Loan loan, bytes data) internal returns (uint256) {\n        if (loan.oracle == address(0)) {\n            return 1;\n        } else {\n            return loan.oracle.getRate(loan.currency, data);\n        }\n    }\n\n    /**\n        @dev Withdraw lender funds\n\n        When a loan is paid, the funds are not transferred automatically to the lender, the funds are stored on the\n        engine contract, and the lender must call this function specifying the amount desired to transfer and the \n        destination.\n\n        This behavior is defined to allow the temporary transfer of the loan to a smart contract, without worrying that\n        the contract will receive tokens that are not traceable; and it allows the development of decentralized \n        autonomous organizations.\n\n        @param index Index of the loan\n        @param to Destination of the wiwthdraw funds\n        @param amount Amount to withdraw, in RCN\n\n        @return true if the withdraw was executed successfully\n    */\n    function withdrawal(uint index, address to, uint256 amount) public returns (bool) {\n        Loan storage loan = loans[index];\n        require(msg.sender == loan.lender);\n        loan.lenderBalance = safeSubtract(loan.lenderBalance, amount);\n        require(rcn.transfer(to, amount));\n        unlockTokens(rcn, amount);\n        return true;\n    }\n\n    function withdrawalRange(uint256 fromIndex, uint256 toIndex, address to) public returns (uint256) {\n        uint256 loanId;\n        uint256 totalWithdraw = 0;\n\n        for (loanId = fromIndex; loanId <= toIndex; loanId++) {\n            Loan storage loan = loans[loanId];\n            if (loan.lender == msg.sender) {\n                totalWithdraw += loan.lenderBalance;\n                loan.lenderBalance = 0;\n            }\n        }\n\n        require(rcn.transfer(to, totalWithdraw));\n        unlockTokens(rcn, totalWithdraw);\n        \n        return totalWithdraw;\n    }\n\n    function withdrawalList(uint256[] memory loanIds, address to) public returns (uint256) {\n        uint256 inputId;\n        uint256 totalWithdraw = 0;\n\n        for (inputId = 0; inputId < loanIds.length; inputId++) {\n            Loan storage loan = loans[loanIds[inputId]];\n            if (loan.lender == msg.sender) {\n                totalWithdraw += loan.lenderBalance;\n                loan.lenderBalance = 0;\n            }\n        }\n\n        require(rcn.transfer(to, totalWithdraw));\n        unlockTokens(rcn, totalWithdraw);\n\n        return totalWithdraw;\n    }\n\n    /**\n        @dev Deprecates the engine, locks the creation of new loans.\n    */\n    function setDeprecated(bool _deprecated) public onlyOwner {\n        deprecated = _deprecated;\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinfabrik-RCN Network Smart Contract Audit/rcn-network-3ded36151ad55543d16c354e70161852de4061d0/contracts/NanoLoanEngine.sol",
        "vulnerability": "Assertion Failure",
        "check": "FP",
        "response": "Answer: No\nReason: The code does not use the `assert()` function which can trigger assertion failures."
    },
    {
        "code_segment": "contract NanoLoanEngine is ERC721, Engine, Ownable, TokenLockable {\n    uint256 public constant VERSION = 202;\n    string public constant VERSION_NAME = \"Basalt\";\n\n    uint256 private activeLoans = 0;\n    mapping(address => uint256) private lendersBalance;\n\n    function name() constant returns (string _name) {\n        _name = \"RCN - Nano loan engine - Basalt 202\";\n    }\n\n    function symbol() constant returns (string _symbol) {\n        _symbol = \"RCN-NLE-202\";\n    }\n\n    function totalSupply() constant returns (uint _totalSupply) {\n        _totalSupply = activeLoans;\n    }\n\n    function balanceOf(address _owner) constant returns (uint _balance) {\n        _balance = lendersBalance[_owner];\n    }\n\n    function tokenOfOwnerByIndex(address _owner, uint256 _index) constant returns (uint tokenId) {\n        uint256 tokenCount = balanceOf(_owner);\n\n        if (tokenCount == 0 || _index >= tokenCount) {\n            // Fail transaction\n            revert();\n        } else {\n            uint256 totalLoans = totalSupply();\n            uint256 resultIndex = 0;\n\n            uint256 loanId;\n            // SWC-128-DoS With Block Gas Limit: L46\n            for (loanId = 0; loanId <= totalLoans; loanId++) {\n                if (loans[loanId].lender == _owner && loans[loanId].status == Status.lent) {\n                    if (resultIndex == _index) {\n                        return loanId;\n                    }\n                    resultIndex++;\n                }\n            }\n\n            revert();\n        }\n    }\n\n    function tokensOfOwner(address _owner) external constant returns(uint256[] ownerTokens) {\n        uint256 tokenCount = balanceOf(_owner);\n\n        if (tokenCount == 0) {\n            // Return an empty array\n            return new uint256[](0);\n        } else {\n            uint256[] memory result = new uint256[](tokenCount);\n            uint256 totalLoans = totalSupply();\n            uint256 resultIndex = 0;\n\n            uint256 loanId;\n\n            for (loanId = 0; loanId <= totalLoans; loanId++) {\n                if (loans[loanId].lender == _owner && loans[loanId].status == Status.lent) {\n                    result[resultIndex] = loanId;\n                    resultIndex++;\n                }\n            }\n\n            return result;\n        }\n    }\n    \n    Token public rcn;\n    bool public deprecated;\n\n    event CreatedLoan(uint _index, address _borrower, address _creator);\n    event ApprovedBy(uint _index, address _address);\n    event Lent(uint _index, address _lender, address _cosigner);\n    event DestroyedBy(uint _index, address _address);\n    event PartialPayment(uint _index, address _sender, address _from, uint256 _amount);\n    event TotalPayment(uint _index);\n\n    function NanoLoanEngine(Token _rcn) public {\n        owner = msg.sender;\n        rcn = _rcn;\n    }\n\n    struct Loan {\n        Status status;\n        Oracle oracle;\n\n        address borrower;\n        address lender;\n        address creator;\n        address cosigner;\n        \n        uint256 amount;\n        uint256 interest;\n        uint256 punitoryInterest;\n        uint256 interestTimestamp;\n        uint256 paid;\n        uint256 interestRate;\n        uint256 interestRatePunitory;\n        uint256 dueTime;\n        uint256 duesIn;\n\n        bytes32 currency;\n        uint256 cancelableAt;\n        uint256 lenderBalance;\n\n        address approvedTransfer;\n        uint256 expirationRequest;\n\n        mapping(address => bool) approbations;\n    }\n\n    Loan[] private loans;\n\n    /**\n        @dev Creates a loan request, the loan can be generated with any borrower, cosigner, and conditions; if the \n        cosigner and borrower agree they must call the \"approve\" function.\n\n        The creator of the loan is the caller of this function; this is useful to track which wallet created the loan.\n\n        @param _oracleContract Address of the Oracle contract, if the loan does not use any oracle, this field should be 0x0.\n        @param _borrower Address of the borrower\n        @param _currency The currency to use with the oracle, the currency code is generated with the following formula,\n            keccak256(ticker,decimals).\n        @param _amount The requested amount; currency and unit are defined by the Oracle, if there is no Oracle present\n            the currency is RCN, and the unit is wei.\n        @param _interestRate The non-punitory interest rate by second, defined as a denominator of 10 000 000.\n        @param _interestRatePunitory The punitory interest rate by second, defined as a denominator of 10 000 000.\n            Ej: interestRate 11108571428571 = 28% Anual interest\n        @param _duesIn The time in seconds that the borrower has in order to pay the debt after the lender lends the money.\n        @param _cancelableAt Delta in seconds specifying how much interest should be added in advance, if the borrower pays \n        entirely or partially the loan before this term, no extra interest will be deducted.\n        @param _expirationRequest Timestamp of when the loan request expires, if the loan is not filled before this date, \n            the request is no longer valid.\n    */\n    function createLoan(Oracle _oracleContract, address _borrower, bytes32 _currency, uint256 _amount, uint256 _interestRate,\n        uint256 _interestRatePunitory, uint256 _duesIn, uint256 _cancelableAt, uint256 _expirationRequest) returns (uint256) {\n\n        require(!deprecated);\n        require(_cancelableAt <= _duesIn);\n        require(_oracleContract != address(0) || _currency == 0x0);\n        require(_borrower != address(0));\n        require(_amount != 0);\n        require(_interestRatePunitory != 0);\n        require(_interestRate != 0);\n        require(_expirationRequest > block.timestamp);\n\n        var loan = Loan(Status.initial, _oracleContract, _borrower, 0x0, msg.sender, 0x0, _amount, 0, 0, 0, 0, _interestRate,\n            _interestRatePunitory, 0, _duesIn, _currency, _cancelableAt, 0, 0x0, _expirationRequest);\n        uint index = loans.push(loan) - 1;\n        CreatedLoan(index, _borrower, msg.sender);\n\n        if (msg.sender == _borrower) {\n            approveLoan(index);\n        }\n\n        return index;\n    }\n    \n    function ownerOf(uint256 index) constant returns (address owner) { owner = loans[index].lender; }\n    function getTotalLoans() constant returns (uint256) { return loans.length; }\n    function getOracle(uint index) constant returns (Oracle) { return loans[index].oracle; }\n    function getBorrower(uint index) constant returns (address) { return loans[index].borrower; }\n    function getCosigner(uint index) constant returns (address) { return loans[index].cosigner; }\n    function getCreator(uint index) constant returns (address) { return loans[index].creator; }\n    function getAmount(uint index) constant returns (uint256) { return loans[index].amount; }\n    function getPunitoryInterest(uint index) constant returns (uint256) { return loans[index].punitoryInterest; }\n    function getInterestTimestamp(uint index) constant returns (uint256) { return loans[index].interestTimestamp; }\n    function getPaid(uint index) constant returns (uint256) { return loans[index].paid; }\n    function getInterestRate(uint index) constant returns (uint256) { return loans[index].interestRate; }\n    function getInterestRatePunitory(uint index) constant returns (uint256) { return loans[index].interestRatePunitory; }\n    function getDueTime(uint index) constant returns (uint256) { return loans[index].dueTime; }\n    function getDuesIn(uint index) constant returns (uint256) { return loans[index].duesIn; }\n    function getCancelableAt(uint index) constant returns (uint256) { return loans[index].cancelableAt; }\n    function getApprobation(uint index, address _address) constant returns (bool) { return loans[index].approbations[_address]; }\n    function getStatus(uint index) constant returns (Status) { return loans[index].status; }\n    function getLenderBalance(uint index) constant returns (uint256) { return loans[index].lenderBalance; }\n    function getApprovedTransfer(uint index) constant returns (address) {return loans[index].approvedTransfer; }\n    function getCurrency(uint index) constant returns (bytes32) { return loans[index].currency; }\n    function getExpirationRequest(uint index) constant returns (uint256) { return loans[index].expirationRequest; }\n    function getInterest(uint index) constant returns (uint256) { return loans[index].interest; }\n\n    /**\n        @param index Index of the loan\n\n        @return true if the loan has been approved by the borrower and cosigner.\n    */\n    function isApproved(uint index) constant returns (bool) {\n        Loan storage loan = loans[index];\n        return loan.approbations[loan.borrower];\n    }\n\n    /**\n        @dev Called by the members of the loan to show that they agree with the terms of the loan; the borrower\n        must call this method before any lender could call the method \"lend\".\n            \n        Any address can call this method to be added to the \"approbations\" mapping.\n\n        @param index Index of the loan\n\n        @return true if the approve was done successfully\n    */\n    function approveLoan(uint index) public returns(bool) {\n        Loan storage loan = loans[index];\n        require(loan.status == Status.initial);\n        loan.approbations[msg.sender] = true;\n        ApprovedBy(index, msg.sender);\n        return true;\n    }\n\n    /**\n        @dev Performs the lend of the RCN equivalent to the requested amount, and transforms the msg.sender in the new lender.\n\n        The loan must be previously approved by the borrower; before calling this function, the lender candidate must \n        call the \"approve\" function on the RCN Token, specifying an amount sufficient enough to pay the equivalent of\n        the requested amount, and the cosigner fee.\n        \n        @param index Index of the loan\n        @param oracleData Data required by the oracle to return the rate, the content of this field must be provided\n            by the url exposed in the url() method of the oracle.\n        @param cosigner Address of the cosigner, 0x0 for lending without cosigner.\n        @param cosignerData Data required by the cosigner to process the request.\n\n        @return true if the lend was done successfully\n    */\n    function lend(uint index, bytes oracleData, Cosigner cosigner, bytes cosignerData) public returns (bool) {\n        Loan storage loan = loans[index];\n\n        require(loan.status == Status.initial);\n        require(isApproved(index));\n        require(block.timestamp <= loan.expirationRequest);\n\n        loan.lender = msg.sender;\n        loan.dueTime = safeAdd(block.timestamp, loan.duesIn);\n        loan.interestTimestamp = block.timestamp;\n        loan.status = Status.lent;\n        \n        if (loan.cancelableAt > 0)\n            internalAddInterest(loan, safeAdd(block.timestamp, loan.cancelableAt));\n\n        uint256 rate = getRate(loan, oracleData);\n\n        if (cosigner != address(0)) {\n            // The cosigner it's temporary set to the next address (cosigner + 2), it's expected that the cosigner will\n            // call the method \"cosign\" to accept the conditions; that method also sets the cosigner to the right\n            // address. If that does not happen, the transaction fails.\n            loan.cosigner = address(uint256(cosigner) + 2);\n            require(cosigner.requestCosign(this, index, cosignerData, oracleData));\n            require(loan.cosigner == address(cosigner));\n        }\n        \n        require(rcn.transferFrom(msg.sender, loan.borrower, safeMult(loan.amount, rate)));\n        \n        // ERC721, create new loan and transfer it to the lender\n        Transfer(0x0, loan.lender, index);\n        activeLoans += 1;\n        lendersBalance[loan.lender] += 1;\n        Lent(index, loan.lender, cosigner);\n\n        return true;\n    }\n\n    /**\n        @dev The cosigner must call this method to accept the conditions of a loan, this method pays the cosigner his fee\n\n        @param index Index of the loan\n        @param cost Fee set by the cosigner\n\n        @return true If the cosign was successfull\n    */\n    function cosign(uint index, uint256 cost) external returns (bool) {\n        Loan storage loan = loans[index];\n        require(loan.status == Status.lent && (loan.dueTime - loan.duesIn) == block.timestamp);\n        require(loan.cosigner != address(0));\n        require(loan.cosigner == address(uint256(msg.sender) + 2));\n        loan.cosigner = msg.sender;\n        require(rcn.transferFrom(loan.lender, msg.sender, cost));\n        return true;\n    }\n\n    /**\n        @dev Destroys a loan, the borrower could call this method if they performed an accidental or regretted \n        \"approve\" of the loan, this method only works for them if the loan is in \"pending\" status.\n\n        The lender can call this method at any moment, in case of a loan with status \"lent\" the lender is pardoning \n        the debt. \n\n        @param index Index of the loan\n\n        @return true if the destroy was done successfully\n    */\n    function destroy(uint index) public returns (bool) {\n        Loan storage loan = loans[index];\n        require(loan.status != Status.destroyed);\n        require(msg.sender == loan.lender || (msg.sender == loan.borrower && loan.status == Status.initial));\n        DestroyedBy(index, msg.sender);\n\n        // ERC721, remove loan from circulation\n        if (loan.status != Status.initial) {\n            lendersBalance[loan.lender] -= 1;\n            activeLoans -= 1;\n            Transfer(loan.lender, 0x0, index);\n        }\n\n        loan.status = Status.destroyed;\n        return true;\n    }\n\n    /**\n        @dev Transfers a loan to a different lender, the caller must be the current lender or previously being\n        approved with the method \"approveTransfer\"; only loans with the Status.lent status can be transfered.\n\n        @param index Index of the loan\n        @param to New lender\n\n        @return true if the transfer was done successfully\n    */\n    function transfer(address to, uint256 index) public returns (bool) {\n        Loan storage loan = loans[index];\n        \n        require(loan.status != Status.destroyed && loan.status != Status.paid);\n        require(msg.sender == loan.lender || msg.sender == loan.approvedTransfer);\n        require(to != address(0));\n        loan.lender = to;\n        loan.approvedTransfer = address(0);\n\n        // ERC721, transfer loan to another address\n        lendersBalance[msg.sender] -= 1;\n        lendersBalance[to] += 1;\n        Transfer(loan.lender, to, index);\n\n        return true;\n    }\n\n    /**\n        @dev ERC721 method, transfers the loan to the msg.sender, the msg.sender must be approved using the \n        \"approve\" method.\n\n        @return true if the transfer was successfull\n    */\n    function takeOwnership(uint256 _index) public returns (bool) {\n        return transfer(msg.sender, _index);\n    }\n\n    /**\n        @dev Approves the transfer of a given loan in the name of the lender, the behavior of this function is similar to\n        \"approve\" in the ERC20 standard, but only one approved address is allowed at a time.\n\n        The same method can be called passing 0x0 as parameter \"to\" to erase a previously approved address.\n\n        @param to Address allowed to transfer the loan or 0x0 to delete\n        @param index Index of the loan\n\n        @return true if the approve was done successfully\n    */\n    function approve(address to, uint256 index) public returns (bool) {\n        Loan storage loan = loans[index];\n        require(msg.sender == loan.lender);\n        loan.approvedTransfer = to;\n        Approval(msg.sender, to, index);\n        return true;\n    }\n\n    /**\n        @dev Returns the pending amount to complete de payment of the loan, keep in mind that this number increases \n        every second.\n\n        @param index Index of the loan\n\n        @return Aprox pending payment amount\n    */\n    function getPendingAmount(uint index) public constant returns (uint256) {\n        Loan storage loan = loans[index];\n        addInterest(index);\n        return getRawPendingAmount(loan);\n    }\n\n    function getRawPendingAmount(Loan loan) internal returns (uint256) {\n        return safeSubtract(safeAdd(safeAdd(loan.amount, loan.interest), loan.punitoryInterest), loan.paid);\n    }\n\n    /**\n        @dev Calculates the interest of a given amount, interest rate and delta time.\n\n        @param timeDelta Elapsed time\n        @param interestRate Interest rate expressed as the denominator of 10 000 000.\n        @param amount Amount to apply interest\n\n        @return realDelta The real timeDelta applied\n        @return interest The interest gained in the realDelta time\n    */\n    function calculateInterest(uint256 timeDelta, uint256 interestRate, uint256 amount) public constant returns (uint256 realDelta, uint256 interest) {\n        if (amount == 0) {\n            interest = 0;\n            realDelta = timeDelta;\n        } else {\n            interest = safeMult(safeMult(100000, amount), timeDelta) / interestRate;\n            realDelta = safeMult(interest, interestRate) / (amount * 100000);\n        }\n    }\n\n    /**\n        @dev Computes loan interest\n\n        Computes the punitory and non-punitory interest of a given loan and only applies the change.\n        \n        @param loan Loan to compute interest\n        @param timestamp Target absolute unix time to calculate interest.\n    */\n    function internalAddInterest(Loan storage loan, uint256 timestamp) internal {\n        if (timestamp > loan.interestTimestamp) {\n            uint256 newInterest = loan.interest;\n            uint256 newPunitoryInterest = loan.punitoryInterest;\n\n            uint256 newTimestamp;\n            uint256 realDelta;\n            uint256 calculatedInterest;\n\n            uint256 deltaTime;\n            uint256 pending;\n\n            uint256 endNonPunitory = min(timestamp, loan.dueTime);\n            if (endNonPunitory > loan.interestTimestamp) {\n                deltaTime = endNonPunitory - loan.interestTimestamp;\n\n                if (loan.paid < loan.amount) {\n                    pending = loan.amount - loan.paid;\n                } else {\n                    pending = 0;\n                }\n\n                (realDelta, calculatedInterest) = calculateInterest(deltaTime, loan.interestRate, pending);\n                newInterest = safeAdd(calculatedInterest, newInterest);\n                newTimestamp = loan.interestTimestamp + realDelta;\n            }\n\n            if (timestamp > loan.dueTime) {\n                uint256 startPunitory = max(loan.dueTime, loan.interestTimestamp);\n                deltaTime = timestamp - startPunitory;\n\n                uint256 debt = safeAdd(loan.amount, newInterest);\n                pending = min(debt, safeSubtract(safeAdd(debt, newPunitoryInterest), loan.paid));\n\n                (realDelta, calculatedInterest) = calculateInterest(deltaTime, loan.interestRatePunitory, pending);\n                newPunitoryInterest = safeAdd(newPunitoryInterest, calculatedInterest);\n                newTimestamp = startPunitory + realDelta;\n            }\n            \n            if (newInterest != loan.interest || newPunitoryInterest != loan.punitoryInterest) {\n                loan.interestTimestamp = newTimestamp;\n                loan.interest = newInterest;\n                loan.punitoryInterest = newPunitoryInterest;\n            }\n        }\n    }\n\n    /**\n        @dev Computes loan interest only up to current unix time\n\n        @param timestamp Target absolute unix time to calculate interest.\n    */\n    function addInterestUpTo(Loan storage loan, uint256 timestamp) internal {\n        require(loan.status == Status.lent);\n        if (timestamp <= block.timestamp) {\n            internalAddInterest(loan, timestamp);\n        }\n    }\n\n    /**\n        @dev Updates the loan accumulated interests up to the current Unix time.\n        \n        @param index Index of the loan\n    */\n    function addInterest(uint index) public {\n        Loan storage loan = loans[index];\n        addInterestUpTo(loan, block.timestamp);\n    }\n    \n    /**\n        @dev Pay loan\n\n        Realizes a payment of a given Loan, before performing the payment the accumulated\n        interest is computed and added to the total pending amount.\n\n        Before calling this function, the msg.sender must call the \"approve\" function on the RCN Token, specifying an amount\n        sufficient enough to pay the equivalent of the desired payment and the oracle fee.\n\n        Because it is difficult or even impossible to know in advance how much RCN are going to be spent on the\n        transaction*, we recommend performing the \"approve\" using an amount 5% superior to the wallet estimated\n        spending. If the RCN spent results to be less, the extra tokens are never debited from the msg.sender.\n\n        * The RCN rate can fluctuate on the same block, and it is impossible to know in advance the exact time of the\n        confirmation of the transaction. \n\n        If the paid pending amount equals zero, the loan changes status to \"paid\" and it is considered closed.\n\n        @param index Index of the loan\n        @param _amount Amount to pay, specified in the loan currency; or in RCN if the loan has no oracle\n        @param _from The identity of the payer\n        @param oracleData Data required by the oracle to return the rate, the content of this field must be provided\n            by the url exposed in the url() method of the oracle.\n            \n        @return true if the payment was executed successfully\n    */\n    function pay(uint index, uint256 _amount, address _from, bytes oracleData) public returns (bool) {\n        Loan storage loan = loans[index];\n\n        require(loan.status == Status.lent);\n        addInterest(index);\n        uint256 toPay = min(getPendingAmount(index), _amount);\n        PartialPayment(index, msg.sender, _from, toPay);\n\n        loan.paid = safeAdd(loan.paid, toPay);\n\n        if (getRawPendingAmount(loan) == 0) {\n            TotalPayment(index);\n            loan.status = Status.paid;\n\n            // ERC721, remove loan from circulation\n            lendersBalance[loan.lender] -= 1;\n            activeLoans -= 1;\n            Transfer(loan.lender, 0x0, index);\n        }\n\n        uint256 rate = getRate(loan, oracleData);\n        uint256 transferValue = safeMult(toPay, rate);\n        lockTokens(rcn, transferValue);\n        require(rcn.transferFrom(msg.sender, this, transferValue));\n        loan.lenderBalance = safeAdd(transferValue, loan.lenderBalance);\n\n        return true;\n    }\n\n    /**\n        @dev Retrieves the rate corresponding of the loan oracle, if the loan has no oracle the rate is 1\n\n        @param loan The loan with the cosigner\n        @param data Data required by the oracle\n\n        @return The rate of the oracle\n    */\n    function getRate(Loan loan, bytes data) internal returns (uint256) {\n        if (loan.oracle == address(0)) {\n            return 1;\n        } else {\n            return loan.oracle.getRate(loan.currency, data);\n        }\n    }\n\n    /**\n        @dev Withdraw lender funds\n\n        When a loan is paid, the funds are not transferred automatically to the lender, the funds are stored on the\n        engine contract, and the lender must call this function specifying the amount desired to transfer and the \n        destination.\n\n        This behavior is defined to allow the temporary transfer of the loan to a smart contract, without worrying that\n        the contract will receive tokens that are not traceable; and it allows the development of decentralized \n        autonomous organizations.\n\n        @param index Index of the loan\n        @param to Destination of the wiwthdraw funds\n        @param amount Amount to withdraw, in RCN\n\n        @return true if the withdraw was executed successfully\n    */\n    function withdrawal(uint index, address to, uint256 amount) public returns (bool) {\n        Loan storage loan = loans[index];\n        require(msg.sender == loan.lender);\n        loan.lenderBalance = safeSubtract(loan.lenderBalance, amount);\n        require(rcn.transfer(to, amount));\n        unlockTokens(rcn, amount);\n        return true;\n    }\n\n    function withdrawalRange(uint256 fromIndex, uint256 toIndex, address to) public returns (uint256) {\n        uint256 loanId;\n        uint256 totalWithdraw = 0;\n\n        for (loanId = fromIndex; loanId <= toIndex; loanId++) {\n            Loan storage loan = loans[loanId];\n            if (loan.lender == msg.sender) {\n                totalWithdraw += loan.lenderBalance;\n                loan.lenderBalance = 0;\n            }\n        }\n\n        require(rcn.transfer(to, totalWithdraw));\n        unlockTokens(rcn, totalWithdraw);\n        \n        return totalWithdraw;\n    }\n\n    function withdrawalList(uint256[] memory loanIds, address to) public returns (uint256) {\n        uint256 inputId;\n        uint256 totalWithdraw = 0;\n\n        for (inputId = 0; inputId < loanIds.length; inputId++) {\n            Loan storage loan = loans[loanIds[inputId]];\n            if (loan.lender == msg.sender) {\n                totalWithdraw += loan.lenderBalance;\n                loan.lenderBalance = 0;\n            }\n        }\n\n        require(rcn.transfer(to, totalWithdraw));\n        unlockTokens(rcn, totalWithdraw);\n\n        return totalWithdraw;\n    }\n\n    /**\n        @dev Deprecates the engine, locks the creation of new loans.\n    */\n    function setDeprecated(bool _deprecated) public onlyOwner {\n        deprecated = _deprecated;\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinfabrik-RCN Network Smart Contract Audit/rcn-network-3ded36151ad55543d16c354e70161852de4061d0/contracts/NanoLoanEngine.sol",
        "vulnerability": "Assertion Failure",
        "check": "FP",
        "response": "Answer: No\nReason: There are no assertions in the code, hence no possibility of an Assertion Failure vulnerability."
    },
    {
        "code_segment": "contract NanoLoanEngine is ERC721, Engine, Ownable, TokenLockable {\n    uint256 public constant VERSION = 202;\n    string public constant VERSION_NAME = \"Basalt\";\n\n    uint256 private activeLoans = 0;\n    mapping(address => uint256) private lendersBalance;\n\n    function name() constant returns (string _name) {\n        _name = \"RCN - Nano loan engine - Basalt 202\";\n    }\n\n    function symbol() constant returns (string _symbol) {\n        _symbol = \"RCN-NLE-202\";\n    }\n\n    function totalSupply() constant returns (uint _totalSupply) {\n        _totalSupply = activeLoans;\n    }\n\n    function balanceOf(address _owner) constant returns (uint _balance) {\n        _balance = lendersBalance[_owner];\n    }\n\n    function tokenOfOwnerByIndex(address _owner, uint256 _index) constant returns (uint tokenId) {\n        uint256 tokenCount = balanceOf(_owner);\n\n        if (tokenCount == 0 || _index >= tokenCount) {\n            // Fail transaction\n            revert();\n        } else {\n            uint256 totalLoans = totalSupply();\n            uint256 resultIndex = 0;\n\n            uint256 loanId;\n            // SWC-128-DoS With Block Gas Limit: L46\n            for (loanId = 0; loanId <= totalLoans; loanId++) {\n                if (loans[loanId].lender == _owner && loans[loanId].status == Status.lent) {\n                    if (resultIndex == _index) {\n                        return loanId;\n                    }\n                    resultIndex++;\n                }\n            }\n\n            revert();\n        }\n    }\n\n    function tokensOfOwner(address _owner) external constant returns(uint256[] ownerTokens) {\n        uint256 tokenCount = balanceOf(_owner);\n\n        if (tokenCount == 0) {\n            // Return an empty array\n            return new uint256[](0);\n        } else {\n            uint256[] memory result = new uint256[](tokenCount);\n            uint256 totalLoans = totalSupply();\n            uint256 resultIndex = 0;\n\n            uint256 loanId;\n\n            for (loanId = 0; loanId <= totalLoans; loanId++) {\n                if (loans[loanId].lender == _owner && loans[loanId].status == Status.lent) {\n                    result[resultIndex] = loanId;\n                    resultIndex++;\n                }\n            }\n\n            return result;\n        }\n    }\n    \n    Token public rcn;\n    bool public deprecated;\n\n    event CreatedLoan(uint _index, address _borrower, address _creator);\n    event ApprovedBy(uint _index, address _address);\n    event Lent(uint _index, address _lender, address _cosigner);\n    event DestroyedBy(uint _index, address _address);\n    event PartialPayment(uint _index, address _sender, address _from, uint256 _amount);\n    event TotalPayment(uint _index);\n\n    function NanoLoanEngine(Token _rcn) public {\n        owner = msg.sender;\n        rcn = _rcn;\n    }\n\n    struct Loan {\n        Status status;\n        Oracle oracle;\n\n        address borrower;\n        address lender;\n        address creator;\n        address cosigner;\n        \n        uint256 amount;\n        uint256 interest;\n        uint256 punitoryInterest;\n        uint256 interestTimestamp;\n        uint256 paid;\n        uint256 interestRate;\n        uint256 interestRatePunitory;\n        uint256 dueTime;\n        uint256 duesIn;\n\n        bytes32 currency;\n        uint256 cancelableAt;\n        uint256 lenderBalance;\n\n        address approvedTransfer;\n        uint256 expirationRequest;\n\n        mapping(address => bool) approbations;\n    }\n\n    Loan[] private loans;\n\n    /**\n        @dev Creates a loan request, the loan can be generated with any borrower, cosigner, and conditions; if the \n        cosigner and borrower agree they must call the \"approve\" function.\n\n        The creator of the loan is the caller of this function; this is useful to track which wallet created the loan.\n\n        @param _oracleContract Address of the Oracle contract, if the loan does not use any oracle, this field should be 0x0.\n        @param _borrower Address of the borrower\n        @param _currency The currency to use with the oracle, the currency code is generated with the following formula,\n            keccak256(ticker,decimals).\n        @param _amount The requested amount; currency and unit are defined by the Oracle, if there is no Oracle present\n            the currency is RCN, and the unit is wei.\n        @param _interestRate The non-punitory interest rate by second, defined as a denominator of 10 000 000.\n        @param _interestRatePunitory The punitory interest rate by second, defined as a denominator of 10 000 000.\n            Ej: interestRate 11108571428571 = 28% Anual interest\n        @param _duesIn The time in seconds that the borrower has in order to pay the debt after the lender lends the money.\n        @param _cancelableAt Delta in seconds specifying how much interest should be added in advance, if the borrower pays \n        entirely or partially the loan before this term, no extra interest will be deducted.\n        @param _expirationRequest Timestamp of when the loan request expires, if the loan is not filled before this date, \n            the request is no longer valid.\n    */\n    function createLoan(Oracle _oracleContract, address _borrower, bytes32 _currency, uint256 _amount, uint256 _interestRate,\n        uint256 _interestRatePunitory, uint256 _duesIn, uint256 _cancelableAt, uint256 _expirationRequest) returns (uint256) {\n\n        require(!deprecated);\n        require(_cancelableAt <= _duesIn);\n        require(_oracleContract != address(0) || _currency == 0x0);\n        require(_borrower != address(0));\n        require(_amount != 0);\n        require(_interestRatePunitory != 0);\n        require(_interestRate != 0);\n        require(_expirationRequest > block.timestamp);\n\n        var loan = Loan(Status.initial, _oracleContract, _borrower, 0x0, msg.sender, 0x0, _amount, 0, 0, 0, 0, _interestRate,\n            _interestRatePunitory, 0, _duesIn, _currency, _cancelableAt, 0, 0x0, _expirationRequest);\n        uint index = loans.push(loan) - 1;\n        CreatedLoan(index, _borrower, msg.sender);\n\n        if (msg.sender == _borrower) {\n            approveLoan(index);\n        }\n\n        return index;\n    }\n    \n    function ownerOf(uint256 index) constant returns (address owner) { owner = loans[index].lender; }\n    function getTotalLoans() constant returns (uint256) { return loans.length; }\n    function getOracle(uint index) constant returns (Oracle) { return loans[index].oracle; }\n    function getBorrower(uint index) constant returns (address) { return loans[index].borrower; }\n    function getCosigner(uint index) constant returns (address) { return loans[index].cosigner; }\n    function getCreator(uint index) constant returns (address) { return loans[index].creator; }\n    function getAmount(uint index) constant returns (uint256) { return loans[index].amount; }\n    function getPunitoryInterest(uint index) constant returns (uint256) { return loans[index].punitoryInterest; }\n    function getInterestTimestamp(uint index) constant returns (uint256) { return loans[index].interestTimestamp; }\n    function getPaid(uint index) constant returns (uint256) { return loans[index].paid; }\n    function getInterestRate(uint index) constant returns (uint256) { return loans[index].interestRate; }\n    function getInterestRatePunitory(uint index) constant returns (uint256) { return loans[index].interestRatePunitory; }\n    function getDueTime(uint index) constant returns (uint256) { return loans[index].dueTime; }\n    function getDuesIn(uint index) constant returns (uint256) { return loans[index].duesIn; }\n    function getCancelableAt(uint index) constant returns (uint256) { return loans[index].cancelableAt; }\n    function getApprobation(uint index, address _address) constant returns (bool) { return loans[index].approbations[_address]; }\n    function getStatus(uint index) constant returns (Status) { return loans[index].status; }\n    function getLenderBalance(uint index) constant returns (uint256) { return loans[index].lenderBalance; }\n    function getApprovedTransfer(uint index) constant returns (address) {return loans[index].approvedTransfer; }\n    function getCurrency(uint index) constant returns (bytes32) { return loans[index].currency; }\n    function getExpirationRequest(uint index) constant returns (uint256) { return loans[index].expirationRequest; }\n    function getInterest(uint index) constant returns (uint256) { return loans[index].interest; }\n\n    /**\n        @param index Index of the loan\n\n        @return true if the loan has been approved by the borrower and cosigner.\n    */\n    function isApproved(uint index) constant returns (bool) {\n        Loan storage loan = loans[index];\n        return loan.approbations[loan.borrower];\n    }\n\n    /**\n        @dev Called by the members of the loan to show that they agree with the terms of the loan; the borrower\n        must call this method before any lender could call the method \"lend\".\n            \n        Any address can call this method to be added to the \"approbations\" mapping.\n\n        @param index Index of the loan\n\n        @return true if the approve was done successfully\n    */\n    function approveLoan(uint index) public returns(bool) {\n        Loan storage loan = loans[index];\n        require(loan.status == Status.initial);\n        loan.approbations[msg.sender] = true;\n        ApprovedBy(index, msg.sender);\n        return true;\n    }\n\n    /**\n        @dev Performs the lend of the RCN equivalent to the requested amount, and transforms the msg.sender in the new lender.\n\n        The loan must be previously approved by the borrower; before calling this function, the lender candidate must \n        call the \"approve\" function on the RCN Token, specifying an amount sufficient enough to pay the equivalent of\n        the requested amount, and the cosigner fee.\n        \n        @param index Index of the loan\n        @param oracleData Data required by the oracle to return the rate, the content of this field must be provided\n            by the url exposed in the url() method of the oracle.\n        @param cosigner Address of the cosigner, 0x0 for lending without cosigner.\n        @param cosignerData Data required by the cosigner to process the request.\n\n        @return true if the lend was done successfully\n    */\n    function lend(uint index, bytes oracleData, Cosigner cosigner, bytes cosignerData) public returns (bool) {\n        Loan storage loan = loans[index];\n\n        require(loan.status == Status.initial);\n        require(isApproved(index));\n        require(block.timestamp <= loan.expirationRequest);\n\n        loan.lender = msg.sender;\n        loan.dueTime = safeAdd(block.timestamp, loan.duesIn);\n        loan.interestTimestamp = block.timestamp;\n        loan.status = Status.lent;\n        \n        if (loan.cancelableAt > 0)\n            internalAddInterest(loan, safeAdd(block.timestamp, loan.cancelableAt));\n\n        uint256 rate = getRate(loan, oracleData);\n\n        if (cosigner != address(0)) {\n            // The cosigner it's temporary set to the next address (cosigner + 2), it's expected that the cosigner will\n            // call the method \"cosign\" to accept the conditions; that method also sets the cosigner to the right\n            // address. If that does not happen, the transaction fails.\n            loan.cosigner = address(uint256(cosigner) + 2);\n            require(cosigner.requestCosign(this, index, cosignerData, oracleData));\n            require(loan.cosigner == address(cosigner));\n        }\n        \n        require(rcn.transferFrom(msg.sender, loan.borrower, safeMult(loan.amount, rate)));\n        \n        // ERC721, create new loan and transfer it to the lender\n        Transfer(0x0, loan.lender, index);\n        activeLoans += 1;\n        lendersBalance[loan.lender] += 1;\n        Lent(index, loan.lender, cosigner);\n\n        return true;\n    }\n\n    /**\n        @dev The cosigner must call this method to accept the conditions of a loan, this method pays the cosigner his fee\n\n        @param index Index of the loan\n        @param cost Fee set by the cosigner\n\n        @return true If the cosign was successfull\n    */\n    function cosign(uint index, uint256 cost) external returns (bool) {\n        Loan storage loan = loans[index];\n        require(loan.status == Status.lent && (loan.dueTime - loan.duesIn) == block.timestamp);\n        require(loan.cosigner != address(0));\n        require(loan.cosigner == address(uint256(msg.sender) + 2));\n        loan.cosigner = msg.sender;\n        require(rcn.transferFrom(loan.lender, msg.sender, cost));\n        return true;\n    }\n\n    /**\n        @dev Destroys a loan, the borrower could call this method if they performed an accidental or regretted \n        \"approve\" of the loan, this method only works for them if the loan is in \"pending\" status.\n\n        The lender can call this method at any moment, in case of a loan with status \"lent\" the lender is pardoning \n        the debt. \n\n        @param index Index of the loan\n\n        @return true if the destroy was done successfully\n    */\n    function destroy(uint index) public returns (bool) {\n        Loan storage loan = loans[index];\n        require(loan.status != Status.destroyed);\n        require(msg.sender == loan.lender || (msg.sender == loan.borrower && loan.status == Status.initial));\n        DestroyedBy(index, msg.sender);\n\n        // ERC721, remove loan from circulation\n        if (loan.status != Status.initial) {\n            lendersBalance[loan.lender] -= 1;\n            activeLoans -= 1;\n            Transfer(loan.lender, 0x0, index);\n        }\n\n        loan.status = Status.destroyed;\n        return true;\n    }\n\n    /**\n        @dev Transfers a loan to a different lender, the caller must be the current lender or previously being\n        approved with the method \"approveTransfer\"; only loans with the Status.lent status can be transfered.\n\n        @param index Index of the loan\n        @param to New lender\n\n        @return true if the transfer was done successfully\n    */\n    function transfer(address to, uint256 index) public returns (bool) {\n        Loan storage loan = loans[index];\n        \n        require(loan.status != Status.destroyed && loan.status != Status.paid);\n        require(msg.sender == loan.lender || msg.sender == loan.approvedTransfer);\n        require(to != address(0));\n        loan.lender = to;\n        loan.approvedTransfer = address(0);\n\n        // ERC721, transfer loan to another address\n        lendersBalance[msg.sender] -= 1;\n        lendersBalance[to] += 1;\n        Transfer(loan.lender, to, index);\n\n        return true;\n    }\n\n    /**\n        @dev ERC721 method, transfers the loan to the msg.sender, the msg.sender must be approved using the \n        \"approve\" method.\n\n        @return true if the transfer was successfull\n    */\n    function takeOwnership(uint256 _index) public returns (bool) {\n        return transfer(msg.sender, _index);\n    }\n\n    /**\n        @dev Approves the transfer of a given loan in the name of the lender, the behavior of this function is similar to\n        \"approve\" in the ERC20 standard, but only one approved address is allowed at a time.\n\n        The same method can be called passing 0x0 as parameter \"to\" to erase a previously approved address.\n\n        @param to Address allowed to transfer the loan or 0x0 to delete\n        @param index Index of the loan\n\n        @return true if the approve was done successfully\n    */\n    function approve(address to, uint256 index) public returns (bool) {\n        Loan storage loan = loans[index];\n        require(msg.sender == loan.lender);\n        loan.approvedTransfer = to;\n        Approval(msg.sender, to, index);\n        return true;\n    }\n\n    /**\n        @dev Returns the pending amount to complete de payment of the loan, keep in mind that this number increases \n        every second.\n\n        @param index Index of the loan\n\n        @return Aprox pending payment amount\n    */\n    function getPendingAmount(uint index) public constant returns (uint256) {\n        Loan storage loan = loans[index];\n        addInterest(index);\n        return getRawPendingAmount(loan);\n    }\n\n    function getRawPendingAmount(Loan loan) internal returns (uint256) {\n        return safeSubtract(safeAdd(safeAdd(loan.amount, loan.interest), loan.punitoryInterest), loan.paid);\n    }\n\n    /**\n        @dev Calculates the interest of a given amount, interest rate and delta time.\n\n        @param timeDelta Elapsed time\n        @param interestRate Interest rate expressed as the denominator of 10 000 000.\n        @param amount Amount to apply interest\n\n        @return realDelta The real timeDelta applied\n        @return interest The interest gained in the realDelta time\n    */\n    function calculateInterest(uint256 timeDelta, uint256 interestRate, uint256 amount) public constant returns (uint256 realDelta, uint256 interest) {\n        if (amount == 0) {\n            interest = 0;\n            realDelta = timeDelta;\n        } else {\n            interest = safeMult(safeMult(100000, amount), timeDelta) / interestRate;\n            realDelta = safeMult(interest, interestRate) / (amount * 100000);\n        }\n    }\n\n    /**\n        @dev Computes loan interest\n\n        Computes the punitory and non-punitory interest of a given loan and only applies the change.\n        \n        @param loan Loan to compute interest\n        @param timestamp Target absolute unix time to calculate interest.\n    */\n    function internalAddInterest(Loan storage loan, uint256 timestamp) internal {\n        if (timestamp > loan.interestTimestamp) {\n            uint256 newInterest = loan.interest;\n            uint256 newPunitoryInterest = loan.punitoryInterest;\n\n            uint256 newTimestamp;\n            uint256 realDelta;\n            uint256 calculatedInterest;\n\n            uint256 deltaTime;\n            uint256 pending;\n\n            uint256 endNonPunitory = min(timestamp, loan.dueTime);\n            if (endNonPunitory > loan.interestTimestamp) {\n                deltaTime = endNonPunitory - loan.interestTimestamp;\n\n                if (loan.paid < loan.amount) {\n                    pending = loan.amount - loan.paid;\n                } else {\n                    pending = 0;\n                }\n\n                (realDelta, calculatedInterest) = calculateInterest(deltaTime, loan.interestRate, pending);\n                newInterest = safeAdd(calculatedInterest, newInterest);\n                newTimestamp = loan.interestTimestamp + realDelta;\n            }\n\n            if (timestamp > loan.dueTime) {\n                uint256 startPunitory = max(loan.dueTime, loan.interestTimestamp);\n                deltaTime = timestamp - startPunitory;\n\n                uint256 debt = safeAdd(loan.amount, newInterest);\n                pending = min(debt, safeSubtract(safeAdd(debt, newPunitoryInterest), loan.paid));\n\n                (realDelta, calculatedInterest) = calculateInterest(deltaTime, loan.interestRatePunitory, pending);\n                newPunitoryInterest = safeAdd(newPunitoryInterest, calculatedInterest);\n                newTimestamp = startPunitory + realDelta;\n            }\n            \n            if (newInterest != loan.interest || newPunitoryInterest != loan.punitoryInterest) {\n                loan.interestTimestamp = newTimestamp;\n                loan.interest = newInterest;\n                loan.punitoryInterest = newPunitoryInterest;\n            }\n        }\n    }\n\n    /**\n        @dev Computes loan interest only up to current unix time\n\n        @param timestamp Target absolute unix time to calculate interest.\n    */\n    function addInterestUpTo(Loan storage loan, uint256 timestamp) internal {\n        require(loan.status == Status.lent);\n        if (timestamp <= block.timestamp) {\n            internalAddInterest(loan, timestamp);\n        }\n    }\n\n    /**\n        @dev Updates the loan accumulated interests up to the current Unix time.\n        \n        @param index Index of the loan\n    */\n    function addInterest(uint index) public {\n        Loan storage loan = loans[index];\n        addInterestUpTo(loan, block.timestamp);\n    }\n    \n    /**\n        @dev Pay loan\n\n        Realizes a payment of a given Loan, before performing the payment the accumulated\n        interest is computed and added to the total pending amount.\n\n        Before calling this function, the msg.sender must call the \"approve\" function on the RCN Token, specifying an amount\n        sufficient enough to pay the equivalent of the desired payment and the oracle fee.\n\n        Because it is difficult or even impossible to know in advance how much RCN are going to be spent on the\n        transaction*, we recommend performing the \"approve\" using an amount 5% superior to the wallet estimated\n        spending. If the RCN spent results to be less, the extra tokens are never debited from the msg.sender.\n\n        * The RCN rate can fluctuate on the same block, and it is impossible to know in advance the exact time of the\n        confirmation of the transaction. \n\n        If the paid pending amount equals zero, the loan changes status to \"paid\" and it is considered closed.\n\n        @param index Index of the loan\n        @param _amount Amount to pay, specified in the loan currency; or in RCN if the loan has no oracle\n        @param _from The identity of the payer\n        @param oracleData Data required by the oracle to return the rate, the content of this field must be provided\n            by the url exposed in the url() method of the oracle.\n            \n        @return true if the payment was executed successfully\n    */\n    function pay(uint index, uint256 _amount, address _from, bytes oracleData) public returns (bool) {\n        Loan storage loan = loans[index];\n\n        require(loan.status == Status.lent);\n        addInterest(index);\n        uint256 toPay = min(getPendingAmount(index), _amount);\n        PartialPayment(index, msg.sender, _from, toPay);\n\n        loan.paid = safeAdd(loan.paid, toPay);\n\n        if (getRawPendingAmount(loan) == 0) {\n            TotalPayment(index);\n            loan.status = Status.paid;\n\n            // ERC721, remove loan from circulation\n            lendersBalance[loan.lender] -= 1;\n            activeLoans -= 1;\n            Transfer(loan.lender, 0x0, index);\n        }\n\n        uint256 rate = getRate(loan, oracleData);\n        uint256 transferValue = safeMult(toPay, rate);\n        lockTokens(rcn, transferValue);\n        require(rcn.transferFrom(msg.sender, this, transferValue));\n        loan.lenderBalance = safeAdd(transferValue, loan.lenderBalance);\n\n        return true;\n    }\n\n    /**\n        @dev Retrieves the rate corresponding of the loan oracle, if the loan has no oracle the rate is 1\n\n        @param loan The loan with the cosigner\n        @param data Data required by the oracle\n\n        @return The rate of the oracle\n    */\n    function getRate(Loan loan, bytes data) internal returns (uint256) {\n        if (loan.oracle == address(0)) {\n            return 1;\n        } else {\n            return loan.oracle.getRate(loan.currency, data);\n        }\n    }\n\n    /**\n        @dev Withdraw lender funds\n\n        When a loan is paid, the funds are not transferred automatically to the lender, the funds are stored on the\n        engine contract, and the lender must call this function specifying the amount desired to transfer and the \n        destination.\n\n        This behavior is defined to allow the temporary transfer of the loan to a smart contract, without worrying that\n        the contract will receive tokens that are not traceable; and it allows the development of decentralized \n        autonomous organizations.\n\n        @param index Index of the loan\n        @param to Destination of the wiwthdraw funds\n        @param amount Amount to withdraw, in RCN\n\n        @return true if the withdraw was executed successfully\n    */\n    function withdrawal(uint index, address to, uint256 amount) public returns (bool) {\n        Loan storage loan = loans[index];\n        require(msg.sender == loan.lender);\n        loan.lenderBalance = safeSubtract(loan.lenderBalance, amount);\n        require(rcn.transfer(to, amount));\n        unlockTokens(rcn, amount);\n        return true;\n    }\n\n    function withdrawalRange(uint256 fromIndex, uint256 toIndex, address to) public returns (uint256) {\n        uint256 loanId;\n        uint256 totalWithdraw = 0;\n\n        for (loanId = fromIndex; loanId <= toIndex; loanId++) {\n            Loan storage loan = loans[loanId];\n            if (loan.lender == msg.sender) {\n                totalWithdraw += loan.lenderBalance;\n                loan.lenderBalance = 0;\n            }\n        }\n\n        require(rcn.transfer(to, totalWithdraw));\n        unlockTokens(rcn, totalWithdraw);\n        \n        return totalWithdraw;\n    }\n\n    function withdrawalList(uint256[] memory loanIds, address to) public returns (uint256) {\n        uint256 inputId;\n        uint256 totalWithdraw = 0;\n\n        for (inputId = 0; inputId < loanIds.length; inputId++) {\n            Loan storage loan = loans[loanIds[inputId]];\n            if (loan.lender == msg.sender) {\n                totalWithdraw += loan.lenderBalance;\n                loan.lenderBalance = 0;\n            }\n        }\n\n        require(rcn.transfer(to, totalWithdraw));\n        unlockTokens(rcn, totalWithdraw);\n\n        return totalWithdraw;\n    }\n\n    /**\n        @dev Deprecates the engine, locks the creation of new loans.\n    */\n    function setDeprecated(bool _deprecated) public onlyOwner {\n        deprecated = _deprecated;\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinfabrik-RCN Network Smart Contract Audit/rcn-network-3ded36151ad55543d16c354e70161852de4061d0/contracts/NanoLoanEngine.sol",
        "vulnerability": "Assertion Failure",
        "check": "FP",
        "response": "Answer: No\nReason: There are no assertions present in the contract that could result in an assertion failure."
    },
    {
        "code_segment": "contract NanoLoanEngine is ERC721, Engine, Ownable, TokenLockable {\n    uint256 public constant VERSION = 202;\n    string public constant VERSION_NAME = \"Basalt\";\n\n    uint256 private activeLoans = 0;\n    mapping(address => uint256) private lendersBalance;\n\n    function name() constant returns (string _name) {\n        _name = \"RCN - Nano loan engine - Basalt 202\";\n    }\n\n    function symbol() constant returns (string _symbol) {\n        _symbol = \"RCN-NLE-202\";\n    }\n\n    function totalSupply() constant returns (uint _totalSupply) {\n        _totalSupply = activeLoans;\n    }\n\n    function balanceOf(address _owner) constant returns (uint _balance) {\n        _balance = lendersBalance[_owner];\n    }\n\n    function tokenOfOwnerByIndex(address _owner, uint256 _index) constant returns (uint tokenId) {\n        uint256 tokenCount = balanceOf(_owner);\n\n        if (tokenCount == 0 || _index >= tokenCount) {\n            // Fail transaction\n            revert();\n        } else {\n            uint256 totalLoans = totalSupply();\n            uint256 resultIndex = 0;\n\n            uint256 loanId;\n            // SWC-128-DoS With Block Gas Limit: L46\n            for (loanId = 0; loanId <= totalLoans; loanId++) {\n                if (loans[loanId].lender == _owner && loans[loanId].status == Status.lent) {\n                    if (resultIndex == _index) {\n                        return loanId;\n                    }\n                    resultIndex++;\n                }\n            }\n\n            revert();\n        }\n    }\n\n    function tokensOfOwner(address _owner) external constant returns(uint256[] ownerTokens) {\n        uint256 tokenCount = balanceOf(_owner);\n\n        if (tokenCount == 0) {\n            // Return an empty array\n            return new uint256[](0);\n        } else {\n            uint256[] memory result = new uint256[](tokenCount);\n            uint256 totalLoans = totalSupply();\n            uint256 resultIndex = 0;\n\n            uint256 loanId;\n\n            for (loanId = 0; loanId <= totalLoans; loanId++) {\n                if (loans[loanId].lender == _owner && loans[loanId].status == Status.lent) {\n                    result[resultIndex] = loanId;\n                    resultIndex++;\n                }\n            }\n\n            return result;\n        }\n    }\n    \n    Token public rcn;\n    bool public deprecated;\n\n    event CreatedLoan(uint _index, address _borrower, address _creator);\n    event ApprovedBy(uint _index, address _address);\n    event Lent(uint _index, address _lender, address _cosigner);\n    event DestroyedBy(uint _index, address _address);\n    event PartialPayment(uint _index, address _sender, address _from, uint256 _amount);\n    event TotalPayment(uint _index);\n\n    function NanoLoanEngine(Token _rcn) public {\n        owner = msg.sender;\n        rcn = _rcn;\n    }\n\n    struct Loan {\n        Status status;\n        Oracle oracle;\n\n        address borrower;\n        address lender;\n        address creator;\n        address cosigner;\n        \n        uint256 amount;\n        uint256 interest;\n        uint256 punitoryInterest;\n        uint256 interestTimestamp;\n        uint256 paid;\n        uint256 interestRate;\n        uint256 interestRatePunitory;\n        uint256 dueTime;\n        uint256 duesIn;\n\n        bytes32 currency;\n        uint256 cancelableAt;\n        uint256 lenderBalance;\n\n        address approvedTransfer;\n        uint256 expirationRequest;\n\n        mapping(address => bool) approbations;\n    }\n\n    Loan[] private loans;\n\n    /**\n        @dev Creates a loan request, the loan can be generated with any borrower, cosigner, and conditions; if the \n        cosigner and borrower agree they must call the \"approve\" function.\n\n        The creator of the loan is the caller of this function; this is useful to track which wallet created the loan.\n\n        @param _oracleContract Address of the Oracle contract, if the loan does not use any oracle, this field should be 0x0.\n        @param _borrower Address of the borrower\n        @param _currency The currency to use with the oracle, the currency code is generated with the following formula,\n            keccak256(ticker,decimals).\n        @param _amount The requested amount; currency and unit are defined by the Oracle, if there is no Oracle present\n            the currency is RCN, and the unit is wei.\n        @param _interestRate The non-punitory interest rate by second, defined as a denominator of 10 000 000.\n        @param _interestRatePunitory The punitory interest rate by second, defined as a denominator of 10 000 000.\n            Ej: interestRate 11108571428571 = 28% Anual interest\n        @param _duesIn The time in seconds that the borrower has in order to pay the debt after the lender lends the money.\n        @param _cancelableAt Delta in seconds specifying how much interest should be added in advance, if the borrower pays \n        entirely or partially the loan before this term, no extra interest will be deducted.\n        @param _expirationRequest Timestamp of when the loan request expires, if the loan is not filled before this date, \n            the request is no longer valid.\n    */\n    function createLoan(Oracle _oracleContract, address _borrower, bytes32 _currency, uint256 _amount, uint256 _interestRate,\n        uint256 _interestRatePunitory, uint256 _duesIn, uint256 _cancelableAt, uint256 _expirationRequest) returns (uint256) {\n\n        require(!deprecated);\n        require(_cancelableAt <= _duesIn);\n        require(_oracleContract != address(0) || _currency == 0x0);\n        require(_borrower != address(0));\n        require(_amount != 0);\n        require(_interestRatePunitory != 0);\n        require(_interestRate != 0);\n        require(_expirationRequest > block.timestamp);\n\n        var loan = Loan(Status.initial, _oracleContract, _borrower, 0x0, msg.sender, 0x0, _amount, 0, 0, 0, 0, _interestRate,\n            _interestRatePunitory, 0, _duesIn, _currency, _cancelableAt, 0, 0x0, _expirationRequest);\n        uint index = loans.push(loan) - 1;\n        CreatedLoan(index, _borrower, msg.sender);\n\n        if (msg.sender == _borrower) {\n            approveLoan(index);\n        }\n\n        return index;\n    }\n    \n    function ownerOf(uint256 index) constant returns (address owner) { owner = loans[index].lender; }\n    function getTotalLoans() constant returns (uint256) { return loans.length; }\n    function getOracle(uint index) constant returns (Oracle) { return loans[index].oracle; }\n    function getBorrower(uint index) constant returns (address) { return loans[index].borrower; }\n    function getCosigner(uint index) constant returns (address) { return loans[index].cosigner; }\n    function getCreator(uint index) constant returns (address) { return loans[index].creator; }\n    function getAmount(uint index) constant returns (uint256) { return loans[index].amount; }\n    function getPunitoryInterest(uint index) constant returns (uint256) { return loans[index].punitoryInterest; }\n    function getInterestTimestamp(uint index) constant returns (uint256) { return loans[index].interestTimestamp; }\n    function getPaid(uint index) constant returns (uint256) { return loans[index].paid; }\n    function getInterestRate(uint index) constant returns (uint256) { return loans[index].interestRate; }\n    function getInterestRatePunitory(uint index) constant returns (uint256) { return loans[index].interestRatePunitory; }\n    function getDueTime(uint index) constant returns (uint256) { return loans[index].dueTime; }\n    function getDuesIn(uint index) constant returns (uint256) { return loans[index].duesIn; }\n    function getCancelableAt(uint index) constant returns (uint256) { return loans[index].cancelableAt; }\n    function getApprobation(uint index, address _address) constant returns (bool) { return loans[index].approbations[_address]; }\n    function getStatus(uint index) constant returns (Status) { return loans[index].status; }\n    function getLenderBalance(uint index) constant returns (uint256) { return loans[index].lenderBalance; }\n    function getApprovedTransfer(uint index) constant returns (address) {return loans[index].approvedTransfer; }\n    function getCurrency(uint index) constant returns (bytes32) { return loans[index].currency; }\n    function getExpirationRequest(uint index) constant returns (uint256) { return loans[index].expirationRequest; }\n    function getInterest(uint index) constant returns (uint256) { return loans[index].interest; }\n\n    /**\n        @param index Index of the loan\n\n        @return true if the loan has been approved by the borrower and cosigner.\n    */\n    function isApproved(uint index) constant returns (bool) {\n        Loan storage loan = loans[index];\n        return loan.approbations[loan.borrower];\n    }\n\n    /**\n        @dev Called by the members of the loan to show that they agree with the terms of the loan; the borrower\n        must call this method before any lender could call the method \"lend\".\n            \n        Any address can call this method to be added to the \"approbations\" mapping.\n\n        @param index Index of the loan\n\n        @return true if the approve was done successfully\n    */\n    function approveLoan(uint index) public returns(bool) {\n        Loan storage loan = loans[index];\n        require(loan.status == Status.initial);\n        loan.approbations[msg.sender] = true;\n        ApprovedBy(index, msg.sender);\n        return true;\n    }\n\n    /**\n        @dev Performs the lend of the RCN equivalent to the requested amount, and transforms the msg.sender in the new lender.\n\n        The loan must be previously approved by the borrower; before calling this function, the lender candidate must \n        call the \"approve\" function on the RCN Token, specifying an amount sufficient enough to pay the equivalent of\n        the requested amount, and the cosigner fee.\n        \n        @param index Index of the loan\n        @param oracleData Data required by the oracle to return the rate, the content of this field must be provided\n            by the url exposed in the url() method of the oracle.\n        @param cosigner Address of the cosigner, 0x0 for lending without cosigner.\n        @param cosignerData Data required by the cosigner to process the request.\n\n        @return true if the lend was done successfully\n    */\n    function lend(uint index, bytes oracleData, Cosigner cosigner, bytes cosignerData) public returns (bool) {\n        Loan storage loan = loans[index];\n\n        require(loan.status == Status.initial);\n        require(isApproved(index));\n        require(block.timestamp <= loan.expirationRequest);\n\n        loan.lender = msg.sender;\n        loan.dueTime = safeAdd(block.timestamp, loan.duesIn);\n        loan.interestTimestamp = block.timestamp;\n        loan.status = Status.lent;\n        \n        if (loan.cancelableAt > 0)\n            internalAddInterest(loan, safeAdd(block.timestamp, loan.cancelableAt));\n\n        uint256 rate = getRate(loan, oracleData);\n\n        if (cosigner != address(0)) {\n            // The cosigner it's temporary set to the next address (cosigner + 2), it's expected that the cosigner will\n            // call the method \"cosign\" to accept the conditions; that method also sets the cosigner to the right\n            // address. If that does not happen, the transaction fails.\n            loan.cosigner = address(uint256(cosigner) + 2);\n            require(cosigner.requestCosign(this, index, cosignerData, oracleData));\n            require(loan.cosigner == address(cosigner));\n        }\n        \n        require(rcn.transferFrom(msg.sender, loan.borrower, safeMult(loan.amount, rate)));\n        \n        // ERC721, create new loan and transfer it to the lender\n        Transfer(0x0, loan.lender, index);\n        activeLoans += 1;\n        lendersBalance[loan.lender] += 1;\n        Lent(index, loan.lender, cosigner);\n\n        return true;\n    }\n\n    /**\n        @dev The cosigner must call this method to accept the conditions of a loan, this method pays the cosigner his fee\n\n        @param index Index of the loan\n        @param cost Fee set by the cosigner\n\n        @return true If the cosign was successfull\n    */\n    function cosign(uint index, uint256 cost) external returns (bool) {\n        Loan storage loan = loans[index];\n        require(loan.status == Status.lent && (loan.dueTime - loan.duesIn) == block.timestamp);\n        require(loan.cosigner != address(0));\n        require(loan.cosigner == address(uint256(msg.sender) + 2));\n        loan.cosigner = msg.sender;\n        require(rcn.transferFrom(loan.lender, msg.sender, cost));\n        return true;\n    }\n\n    /**\n        @dev Destroys a loan, the borrower could call this method if they performed an accidental or regretted \n        \"approve\" of the loan, this method only works for them if the loan is in \"pending\" status.\n\n        The lender can call this method at any moment, in case of a loan with status \"lent\" the lender is pardoning \n        the debt. \n\n        @param index Index of the loan\n\n        @return true if the destroy was done successfully\n    */\n    function destroy(uint index) public returns (bool) {\n        Loan storage loan = loans[index];\n        require(loan.status != Status.destroyed);\n        require(msg.sender == loan.lender || (msg.sender == loan.borrower && loan.status == Status.initial));\n        DestroyedBy(index, msg.sender);\n\n        // ERC721, remove loan from circulation\n        if (loan.status != Status.initial) {\n            lendersBalance[loan.lender] -= 1;\n            activeLoans -= 1;\n            Transfer(loan.lender, 0x0, index);\n        }\n\n        loan.status = Status.destroyed;\n        return true;\n    }\n\n    /**\n        @dev Transfers a loan to a different lender, the caller must be the current lender or previously being\n        approved with the method \"approveTransfer\"; only loans with the Status.lent status can be transfered.\n\n        @param index Index of the loan\n        @param to New lender\n\n        @return true if the transfer was done successfully\n    */\n    function transfer(address to, uint256 index) public returns (bool) {\n        Loan storage loan = loans[index];\n        \n        require(loan.status != Status.destroyed && loan.status != Status.paid);\n        require(msg.sender == loan.lender || msg.sender == loan.approvedTransfer);\n        require(to != address(0));\n        loan.lender = to;\n        loan.approvedTransfer = address(0);\n\n        // ERC721, transfer loan to another address\n        lendersBalance[msg.sender] -= 1;\n        lendersBalance[to] += 1;\n        Transfer(loan.lender, to, index);\n\n        return true;\n    }\n\n    /**\n        @dev ERC721 method, transfers the loan to the msg.sender, the msg.sender must be approved using the \n        \"approve\" method.\n\n        @return true if the transfer was successfull\n    */\n    function takeOwnership(uint256 _index) public returns (bool) {\n        return transfer(msg.sender, _index);\n    }\n\n    /**\n        @dev Approves the transfer of a given loan in the name of the lender, the behavior of this function is similar to\n        \"approve\" in the ERC20 standard, but only one approved address is allowed at a time.\n\n        The same method can be called passing 0x0 as parameter \"to\" to erase a previously approved address.\n\n        @param to Address allowed to transfer the loan or 0x0 to delete\n        @param index Index of the loan\n\n        @return true if the approve was done successfully\n    */\n    function approve(address to, uint256 index) public returns (bool) {\n        Loan storage loan = loans[index];\n        require(msg.sender == loan.lender);\n        loan.approvedTransfer = to;\n        Approval(msg.sender, to, index);\n        return true;\n    }\n\n    /**\n        @dev Returns the pending amount to complete de payment of the loan, keep in mind that this number increases \n        every second.\n\n        @param index Index of the loan\n\n        @return Aprox pending payment amount\n    */\n    function getPendingAmount(uint index) public constant returns (uint256) {\n        Loan storage loan = loans[index];\n        addInterest(index);\n        return getRawPendingAmount(loan);\n    }\n\n    function getRawPendingAmount(Loan loan) internal returns (uint256) {\n        return safeSubtract(safeAdd(safeAdd(loan.amount, loan.interest), loan.punitoryInterest), loan.paid);\n    }\n\n    /**\n        @dev Calculates the interest of a given amount, interest rate and delta time.\n\n        @param timeDelta Elapsed time\n        @param interestRate Interest rate expressed as the denominator of 10 000 000.\n        @param amount Amount to apply interest\n\n        @return realDelta The real timeDelta applied\n        @return interest The interest gained in the realDelta time\n    */\n    function calculateInterest(uint256 timeDelta, uint256 interestRate, uint256 amount) public constant returns (uint256 realDelta, uint256 interest) {\n        if (amount == 0) {\n            interest = 0;\n            realDelta = timeDelta;\n        } else {\n            interest = safeMult(safeMult(100000, amount), timeDelta) / interestRate;\n            realDelta = safeMult(interest, interestRate) / (amount * 100000);\n        }\n    }\n\n    /**\n        @dev Computes loan interest\n\n        Computes the punitory and non-punitory interest of a given loan and only applies the change.\n        \n        @param loan Loan to compute interest\n        @param timestamp Target absolute unix time to calculate interest.\n    */\n    function internalAddInterest(Loan storage loan, uint256 timestamp) internal {\n        if (timestamp > loan.interestTimestamp) {\n            uint256 newInterest = loan.interest;\n            uint256 newPunitoryInterest = loan.punitoryInterest;\n\n            uint256 newTimestamp;\n            uint256 realDelta;\n            uint256 calculatedInterest;\n\n            uint256 deltaTime;\n            uint256 pending;\n\n            uint256 endNonPunitory = min(timestamp, loan.dueTime);\n            if (endNonPunitory > loan.interestTimestamp) {\n                deltaTime = endNonPunitory - loan.interestTimestamp;\n\n                if (loan.paid < loan.amount) {\n                    pending = loan.amount - loan.paid;\n                } else {\n                    pending = 0;\n                }\n\n                (realDelta, calculatedInterest) = calculateInterest(deltaTime, loan.interestRate, pending);\n                newInterest = safeAdd(calculatedInterest, newInterest);\n                newTimestamp = loan.interestTimestamp + realDelta;\n            }\n\n            if (timestamp > loan.dueTime) {\n                uint256 startPunitory = max(loan.dueTime, loan.interestTimestamp);\n                deltaTime = timestamp - startPunitory;\n\n                uint256 debt = safeAdd(loan.amount, newInterest);\n                pending = min(debt, safeSubtract(safeAdd(debt, newPunitoryInterest), loan.paid));\n\n                (realDelta, calculatedInterest) = calculateInterest(deltaTime, loan.interestRatePunitory, pending);\n                newPunitoryInterest = safeAdd(newPunitoryInterest, calculatedInterest);\n                newTimestamp = startPunitory + realDelta;\n            }\n            \n            if (newInterest != loan.interest || newPunitoryInterest != loan.punitoryInterest) {\n                loan.interestTimestamp = newTimestamp;\n                loan.interest = newInterest;\n                loan.punitoryInterest = newPunitoryInterest;\n            }\n        }\n    }\n\n    /**\n        @dev Computes loan interest only up to current unix time\n\n        @param timestamp Target absolute unix time to calculate interest.\n    */\n    function addInterestUpTo(Loan storage loan, uint256 timestamp) internal {\n        require(loan.status == Status.lent);\n        if (timestamp <= block.timestamp) {\n            internalAddInterest(loan, timestamp);\n        }\n    }\n\n    /**\n        @dev Updates the loan accumulated interests up to the current Unix time.\n        \n        @param index Index of the loan\n    */\n    function addInterest(uint index) public {\n        Loan storage loan = loans[index];\n        addInterestUpTo(loan, block.timestamp);\n    }\n    \n    /**\n        @dev Pay loan\n\n        Realizes a payment of a given Loan, before performing the payment the accumulated\n        interest is computed and added to the total pending amount.\n\n        Before calling this function, the msg.sender must call the \"approve\" function on the RCN Token, specifying an amount\n        sufficient enough to pay the equivalent of the desired payment and the oracle fee.\n\n        Because it is difficult or even impossible to know in advance how much RCN are going to be spent on the\n        transaction*, we recommend performing the \"approve\" using an amount 5% superior to the wallet estimated\n        spending. If the RCN spent results to be less, the extra tokens are never debited from the msg.sender.\n\n        * The RCN rate can fluctuate on the same block, and it is impossible to know in advance the exact time of the\n        confirmation of the transaction. \n\n        If the paid pending amount equals zero, the loan changes status to \"paid\" and it is considered closed.\n\n        @param index Index of the loan\n        @param _amount Amount to pay, specified in the loan currency; or in RCN if the loan has no oracle\n        @param _from The identity of the payer\n        @param oracleData Data required by the oracle to return the rate, the content of this field must be provided\n            by the url exposed in the url() method of the oracle.\n            \n        @return true if the payment was executed successfully\n    */\n    function pay(uint index, uint256 _amount, address _from, bytes oracleData) public returns (bool) {\n        Loan storage loan = loans[index];\n\n        require(loan.status == Status.lent);\n        addInterest(index);\n        uint256 toPay = min(getPendingAmount(index), _amount);\n        PartialPayment(index, msg.sender, _from, toPay);\n\n        loan.paid = safeAdd(loan.paid, toPay);\n\n        if (getRawPendingAmount(loan) == 0) {\n            TotalPayment(index);\n            loan.status = Status.paid;\n\n            // ERC721, remove loan from circulation\n            lendersBalance[loan.lender] -= 1;\n            activeLoans -= 1;\n            Transfer(loan.lender, 0x0, index);\n        }\n\n        uint256 rate = getRate(loan, oracleData);\n        uint256 transferValue = safeMult(toPay, rate);\n        lockTokens(rcn, transferValue);\n        require(rcn.transferFrom(msg.sender, this, transferValue));\n        loan.lenderBalance = safeAdd(transferValue, loan.lenderBalance);\n\n        return true;\n    }\n\n    /**\n        @dev Retrieves the rate corresponding of the loan oracle, if the loan has no oracle the rate is 1\n\n        @param loan The loan with the cosigner\n        @param data Data required by the oracle\n\n        @return The rate of the oracle\n    */\n    function getRate(Loan loan, bytes data) internal returns (uint256) {\n        if (loan.oracle == address(0)) {\n            return 1;\n        } else {\n            return loan.oracle.getRate(loan.currency, data);\n        }\n    }\n\n    /**\n        @dev Withdraw lender funds\n\n        When a loan is paid, the funds are not transferred automatically to the lender, the funds are stored on the\n        engine contract, and the lender must call this function specifying the amount desired to transfer and the \n        destination.\n\n        This behavior is defined to allow the temporary transfer of the loan to a smart contract, without worrying that\n        the contract will receive tokens that are not traceable; and it allows the development of decentralized \n        autonomous organizations.\n\n        @param index Index of the loan\n        @param to Destination of the wiwthdraw funds\n        @param amount Amount to withdraw, in RCN\n\n        @return true if the withdraw was executed successfully\n    */\n    function withdrawal(uint index, address to, uint256 amount) public returns (bool) {\n        Loan storage loan = loans[index];\n        require(msg.sender == loan.lender);\n        loan.lenderBalance = safeSubtract(loan.lenderBalance, amount);\n        require(rcn.transfer(to, amount));\n        unlockTokens(rcn, amount);\n        return true;\n    }\n\n    function withdrawalRange(uint256 fromIndex, uint256 toIndex, address to) public returns (uint256) {\n        uint256 loanId;\n        uint256 totalWithdraw = 0;\n\n        for (loanId = fromIndex; loanId <= toIndex; loanId++) {\n            Loan storage loan = loans[loanId];\n            if (loan.lender == msg.sender) {\n                totalWithdraw += loan.lenderBalance;\n                loan.lenderBalance = 0;\n            }\n        }\n\n        require(rcn.transfer(to, totalWithdraw));\n        unlockTokens(rcn, totalWithdraw);\n        \n        return totalWithdraw;\n    }\n\n    function withdrawalList(uint256[] memory loanIds, address to) public returns (uint256) {\n        uint256 inputId;\n        uint256 totalWithdraw = 0;\n\n        for (inputId = 0; inputId < loanIds.length; inputId++) {\n            Loan storage loan = loans[loanIds[inputId]];\n            if (loan.lender == msg.sender) {\n                totalWithdraw += loan.lenderBalance;\n                loan.lenderBalance = 0;\n            }\n        }\n\n        require(rcn.transfer(to, totalWithdraw));\n        unlockTokens(rcn, totalWithdraw);\n\n        return totalWithdraw;\n    }\n\n    /**\n        @dev Deprecates the engine, locks the creation of new loans.\n    */\n    function setDeprecated(bool _deprecated) public onlyOwner {\n        deprecated = _deprecated;\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinfabrik-RCN Network Smart Contract Audit/rcn-network-3ded36151ad55543d16c354e70161852de4061d0/contracts/NanoLoanEngine.sol",
        "vulnerability": "Assertion Failure",
        "check": "FP",
        "response": "Answer: No\nReason: There are no indications of failing internal assertions, and revert statements are used for flow control instead of assert statements."
    },
    {
        "code_segment": "contract NanoLoanEngine is ERC721, Engine, Ownable, TokenLockable {\n    uint256 public constant VERSION = 202;\n    string public constant VERSION_NAME = \"Basalt\";\n\n    uint256 private activeLoans = 0;\n    mapping(address => uint256) private lendersBalance;\n\n    function name() constant returns (string _name) {\n        _name = \"RCN - Nano loan engine - Basalt 202\";\n    }\n\n    function symbol() constant returns (string _symbol) {\n        _symbol = \"RCN-NLE-202\";\n    }\n\n    function totalSupply() constant returns (uint _totalSupply) {\n        _totalSupply = activeLoans;\n    }\n\n    function balanceOf(address _owner) constant returns (uint _balance) {\n        _balance = lendersBalance[_owner];\n    }\n\n    function tokenOfOwnerByIndex(address _owner, uint256 _index) constant returns (uint tokenId) {\n        uint256 tokenCount = balanceOf(_owner);\n\n        if (tokenCount == 0 || _index >= tokenCount) {\n            // Fail transaction\n            revert();\n        } else {\n            uint256 totalLoans = totalSupply();\n            uint256 resultIndex = 0;\n\n            uint256 loanId;\n            // SWC-128-DoS With Block Gas Limit: L46\n            for (loanId = 0; loanId <= totalLoans; loanId++) {\n                if (loans[loanId].lender == _owner && loans[loanId].status == Status.lent) {\n                    if (resultIndex == _index) {\n                        return loanId;\n                    }\n                    resultIndex++;\n                }\n            }\n\n            revert();\n        }\n    }\n\n    function tokensOfOwner(address _owner) external constant returns(uint256[] ownerTokens) {\n        uint256 tokenCount = balanceOf(_owner);\n\n        if (tokenCount == 0) {\n            // Return an empty array\n            return new uint256[](0);\n        } else {\n            uint256[] memory result = new uint256[](tokenCount);\n            uint256 totalLoans = totalSupply();\n            uint256 resultIndex = 0;\n\n            uint256 loanId;\n\n            for (loanId = 0; loanId <= totalLoans; loanId++) {\n                if (loans[loanId].lender == _owner && loans[loanId].status == Status.lent) {\n                    result[resultIndex] = loanId;\n                    resultIndex++;\n                }\n            }\n\n            return result;\n        }\n    }\n    \n    Token public rcn;\n    bool public deprecated;\n\n    event CreatedLoan(uint _index, address _borrower, address _creator);\n    event ApprovedBy(uint _index, address _address);\n    event Lent(uint _index, address _lender, address _cosigner);\n    event DestroyedBy(uint _index, address _address);\n    event PartialPayment(uint _index, address _sender, address _from, uint256 _amount);\n    event TotalPayment(uint _index);\n\n    function NanoLoanEngine(Token _rcn) public {\n        owner = msg.sender;\n        rcn = _rcn;\n    }\n\n    struct Loan {\n        Status status;\n        Oracle oracle;\n\n        address borrower;\n        address lender;\n        address creator;\n        address cosigner;\n        \n        uint256 amount;\n        uint256 interest;\n        uint256 punitoryInterest;\n        uint256 interestTimestamp;\n        uint256 paid;\n        uint256 interestRate;\n        uint256 interestRatePunitory;\n        uint256 dueTime;\n        uint256 duesIn;\n\n        bytes32 currency;\n        uint256 cancelableAt;\n        uint256 lenderBalance;\n\n        address approvedTransfer;\n        uint256 expirationRequest;\n\n        mapping(address => bool) approbations;\n    }\n\n    Loan[] private loans;\n\n    /**\n        @dev Creates a loan request, the loan can be generated with any borrower, cosigner, and conditions; if the \n        cosigner and borrower agree they must call the \"approve\" function.\n\n        The creator of the loan is the caller of this function; this is useful to track which wallet created the loan.\n\n        @param _oracleContract Address of the Oracle contract, if the loan does not use any oracle, this field should be 0x0.\n        @param _borrower Address of the borrower\n        @param _currency The currency to use with the oracle, the currency code is generated with the following formula,\n            keccak256(ticker,decimals).\n        @param _amount The requested amount; currency and unit are defined by the Oracle, if there is no Oracle present\n            the currency is RCN, and the unit is wei.\n        @param _interestRate The non-punitory interest rate by second, defined as a denominator of 10 000 000.\n        @param _interestRatePunitory The punitory interest rate by second, defined as a denominator of 10 000 000.\n            Ej: interestRate 11108571428571 = 28% Anual interest\n        @param _duesIn The time in seconds that the borrower has in order to pay the debt after the lender lends the money.\n        @param _cancelableAt Delta in seconds specifying how much interest should be added in advance, if the borrower pays \n        entirely or partially the loan before this term, no extra interest will be deducted.\n        @param _expirationRequest Timestamp of when the loan request expires, if the loan is not filled before this date, \n            the request is no longer valid.\n    */\n    function createLoan(Oracle _oracleContract, address _borrower, bytes32 _currency, uint256 _amount, uint256 _interestRate,\n        uint256 _interestRatePunitory, uint256 _duesIn, uint256 _cancelableAt, uint256 _expirationRequest) returns (uint256) {\n\n        require(!deprecated);\n        require(_cancelableAt <= _duesIn);\n        require(_oracleContract != address(0) || _currency == 0x0);\n        require(_borrower != address(0));\n        require(_amount != 0);\n        require(_interestRatePunitory != 0);\n        require(_interestRate != 0);\n        require(_expirationRequest > block.timestamp);\n\n        var loan = Loan(Status.initial, _oracleContract, _borrower, 0x0, msg.sender, 0x0, _amount, 0, 0, 0, 0, _interestRate,\n            _interestRatePunitory, 0, _duesIn, _currency, _cancelableAt, 0, 0x0, _expirationRequest);\n        uint index = loans.push(loan) - 1;\n        CreatedLoan(index, _borrower, msg.sender);\n\n        if (msg.sender == _borrower) {\n            approveLoan(index);\n        }\n\n        return index;\n    }\n    \n    function ownerOf(uint256 index) constant returns (address owner) { owner = loans[index].lender; }\n    function getTotalLoans() constant returns (uint256) { return loans.length; }\n    function getOracle(uint index) constant returns (Oracle) { return loans[index].oracle; }\n    function getBorrower(uint index) constant returns (address) { return loans[index].borrower; }\n    function getCosigner(uint index) constant returns (address) { return loans[index].cosigner; }\n    function getCreator(uint index) constant returns (address) { return loans[index].creator; }\n    function getAmount(uint index) constant returns (uint256) { return loans[index].amount; }\n    function getPunitoryInterest(uint index) constant returns (uint256) { return loans[index].punitoryInterest; }\n    function getInterestTimestamp(uint index) constant returns (uint256) { return loans[index].interestTimestamp; }\n    function getPaid(uint index) constant returns (uint256) { return loans[index].paid; }\n    function getInterestRate(uint index) constant returns (uint256) { return loans[index].interestRate; }\n    function getInterestRatePunitory(uint index) constant returns (uint256) { return loans[index].interestRatePunitory; }\n    function getDueTime(uint index) constant returns (uint256) { return loans[index].dueTime; }\n    function getDuesIn(uint index) constant returns (uint256) { return loans[index].duesIn; }\n    function getCancelableAt(uint index) constant returns (uint256) { return loans[index].cancelableAt; }\n    function getApprobation(uint index, address _address) constant returns (bool) { return loans[index].approbations[_address]; }\n    function getStatus(uint index) constant returns (Status) { return loans[index].status; }\n    function getLenderBalance(uint index) constant returns (uint256) { return loans[index].lenderBalance; }\n    function getApprovedTransfer(uint index) constant returns (address) {return loans[index].approvedTransfer; }\n    function getCurrency(uint index) constant returns (bytes32) { return loans[index].currency; }\n    function getExpirationRequest(uint index) constant returns (uint256) { return loans[index].expirationRequest; }\n    function getInterest(uint index) constant returns (uint256) { return loans[index].interest; }\n\n    /**\n        @param index Index of the loan\n\n        @return true if the loan has been approved by the borrower and cosigner.\n    */\n    function isApproved(uint index) constant returns (bool) {\n        Loan storage loan = loans[index];\n        return loan.approbations[loan.borrower];\n    }\n\n    /**\n        @dev Called by the members of the loan to show that they agree with the terms of the loan; the borrower\n        must call this method before any lender could call the method \"lend\".\n            \n        Any address can call this method to be added to the \"approbations\" mapping.\n\n        @param index Index of the loan\n\n        @return true if the approve was done successfully\n    */\n    function approveLoan(uint index) public returns(bool) {\n        Loan storage loan = loans[index];\n        require(loan.status == Status.initial);\n        loan.approbations[msg.sender] = true;\n        ApprovedBy(index, msg.sender);\n        return true;\n    }\n\n    /**\n        @dev Performs the lend of the RCN equivalent to the requested amount, and transforms the msg.sender in the new lender.\n\n        The loan must be previously approved by the borrower; before calling this function, the lender candidate must \n        call the \"approve\" function on the RCN Token, specifying an amount sufficient enough to pay the equivalent of\n        the requested amount, and the cosigner fee.\n        \n        @param index Index of the loan\n        @param oracleData Data required by the oracle to return the rate, the content of this field must be provided\n            by the url exposed in the url() method of the oracle.\n        @param cosigner Address of the cosigner, 0x0 for lending without cosigner.\n        @param cosignerData Data required by the cosigner to process the request.\n\n        @return true if the lend was done successfully\n    */\n    function lend(uint index, bytes oracleData, Cosigner cosigner, bytes cosignerData) public returns (bool) {\n        Loan storage loan = loans[index];\n\n        require(loan.status == Status.initial);\n        require(isApproved(index));\n        require(block.timestamp <= loan.expirationRequest);\n\n        loan.lender = msg.sender;\n        loan.dueTime = safeAdd(block.timestamp, loan.duesIn);\n        loan.interestTimestamp = block.timestamp;\n        loan.status = Status.lent;\n        \n        if (loan.cancelableAt > 0)\n            internalAddInterest(loan, safeAdd(block.timestamp, loan.cancelableAt));\n\n        uint256 rate = getRate(loan, oracleData);\n\n        if (cosigner != address(0)) {\n            // The cosigner it's temporary set to the next address (cosigner + 2), it's expected that the cosigner will\n            // call the method \"cosign\" to accept the conditions; that method also sets the cosigner to the right\n            // address. If that does not happen, the transaction fails.\n            loan.cosigner = address(uint256(cosigner) + 2);\n            require(cosigner.requestCosign(this, index, cosignerData, oracleData));\n            require(loan.cosigner == address(cosigner));\n        }\n        \n        require(rcn.transferFrom(msg.sender, loan.borrower, safeMult(loan.amount, rate)));\n        \n        // ERC721, create new loan and transfer it to the lender\n        Transfer(0x0, loan.lender, index);\n        activeLoans += 1;\n        lendersBalance[loan.lender] += 1;\n        Lent(index, loan.lender, cosigner);\n\n        return true;\n    }\n\n    /**\n        @dev The cosigner must call this method to accept the conditions of a loan, this method pays the cosigner his fee\n\n        @param index Index of the loan\n        @param cost Fee set by the cosigner\n\n        @return true If the cosign was successfull\n    */\n    function cosign(uint index, uint256 cost) external returns (bool) {\n        Loan storage loan = loans[index];\n        require(loan.status == Status.lent && (loan.dueTime - loan.duesIn) == block.timestamp);\n        require(loan.cosigner != address(0));\n        require(loan.cosigner == address(uint256(msg.sender) + 2));\n        loan.cosigner = msg.sender;\n        require(rcn.transferFrom(loan.lender, msg.sender, cost));\n        return true;\n    }\n\n    /**\n        @dev Destroys a loan, the borrower could call this method if they performed an accidental or regretted \n        \"approve\" of the loan, this method only works for them if the loan is in \"pending\" status.\n\n        The lender can call this method at any moment, in case of a loan with status \"lent\" the lender is pardoning \n        the debt. \n\n        @param index Index of the loan\n\n        @return true if the destroy was done successfully\n    */\n    function destroy(uint index) public returns (bool) {\n        Loan storage loan = loans[index];\n        require(loan.status != Status.destroyed);\n        require(msg.sender == loan.lender || (msg.sender == loan.borrower && loan.status == Status.initial));\n        DestroyedBy(index, msg.sender);\n\n        // ERC721, remove loan from circulation\n        if (loan.status != Status.initial) {\n            lendersBalance[loan.lender] -= 1;\n            activeLoans -= 1;\n            Transfer(loan.lender, 0x0, index);\n        }\n\n        loan.status = Status.destroyed;\n        return true;\n    }\n\n    /**\n        @dev Transfers a loan to a different lender, the caller must be the current lender or previously being\n        approved with the method \"approveTransfer\"; only loans with the Status.lent status can be transfered.\n\n        @param index Index of the loan\n        @param to New lender\n\n        @return true if the transfer was done successfully\n    */\n    function transfer(address to, uint256 index) public returns (bool) {\n        Loan storage loan = loans[index];\n        \n        require(loan.status != Status.destroyed && loan.status != Status.paid);\n        require(msg.sender == loan.lender || msg.sender == loan.approvedTransfer);\n        require(to != address(0));\n        loan.lender = to;\n        loan.approvedTransfer = address(0);\n\n        // ERC721, transfer loan to another address\n        lendersBalance[msg.sender] -= 1;\n        lendersBalance[to] += 1;\n        Transfer(loan.lender, to, index);\n\n        return true;\n    }\n\n    /**\n        @dev ERC721 method, transfers the loan to the msg.sender, the msg.sender must be approved using the \n        \"approve\" method.\n\n        @return true if the transfer was successfull\n    */\n    function takeOwnership(uint256 _index) public returns (bool) {\n        return transfer(msg.sender, _index);\n    }\n\n    /**\n        @dev Approves the transfer of a given loan in the name of the lender, the behavior of this function is similar to\n        \"approve\" in the ERC20 standard, but only one approved address is allowed at a time.\n\n        The same method can be called passing 0x0 as parameter \"to\" to erase a previously approved address.\n\n        @param to Address allowed to transfer the loan or 0x0 to delete\n        @param index Index of the loan\n\n        @return true if the approve was done successfully\n    */\n    function approve(address to, uint256 index) public returns (bool) {\n        Loan storage loan = loans[index];\n        require(msg.sender == loan.lender);\n        loan.approvedTransfer = to;\n        Approval(msg.sender, to, index);\n        return true;\n    }\n\n    /**\n        @dev Returns the pending amount to complete de payment of the loan, keep in mind that this number increases \n        every second.\n\n        @param index Index of the loan\n\n        @return Aprox pending payment amount\n    */\n    function getPendingAmount(uint index) public constant returns (uint256) {\n        Loan storage loan = loans[index];\n        addInterest(index);\n        return getRawPendingAmount(loan);\n    }\n\n    function getRawPendingAmount(Loan loan) internal returns (uint256) {\n        return safeSubtract(safeAdd(safeAdd(loan.amount, loan.interest), loan.punitoryInterest), loan.paid);\n    }\n\n    /**\n        @dev Calculates the interest of a given amount, interest rate and delta time.\n\n        @param timeDelta Elapsed time\n        @param interestRate Interest rate expressed as the denominator of 10 000 000.\n        @param amount Amount to apply interest\n\n        @return realDelta The real timeDelta applied\n        @return interest The interest gained in the realDelta time\n    */\n    function calculateInterest(uint256 timeDelta, uint256 interestRate, uint256 amount) public constant returns (uint256 realDelta, uint256 interest) {\n        if (amount == 0) {\n            interest = 0;\n            realDelta = timeDelta;\n        } else {\n            interest = safeMult(safeMult(100000, amount), timeDelta) / interestRate;\n            realDelta = safeMult(interest, interestRate) / (amount * 100000);\n        }\n    }\n\n    /**\n        @dev Computes loan interest\n\n        Computes the punitory and non-punitory interest of a given loan and only applies the change.\n        \n        @param loan Loan to compute interest\n        @param timestamp Target absolute unix time to calculate interest.\n    */\n    function internalAddInterest(Loan storage loan, uint256 timestamp) internal {\n        if (timestamp > loan.interestTimestamp) {\n            uint256 newInterest = loan.interest;\n            uint256 newPunitoryInterest = loan.punitoryInterest;\n\n            uint256 newTimestamp;\n            uint256 realDelta;\n            uint256 calculatedInterest;\n\n            uint256 deltaTime;\n            uint256 pending;\n\n            uint256 endNonPunitory = min(timestamp, loan.dueTime);\n            if (endNonPunitory > loan.interestTimestamp) {\n                deltaTime = endNonPunitory - loan.interestTimestamp;\n\n                if (loan.paid < loan.amount) {\n                    pending = loan.amount - loan.paid;\n                } else {\n                    pending = 0;\n                }\n\n                (realDelta, calculatedInterest) = calculateInterest(deltaTime, loan.interestRate, pending);\n                newInterest = safeAdd(calculatedInterest, newInterest);\n                newTimestamp = loan.interestTimestamp + realDelta;\n            }\n\n            if (timestamp > loan.dueTime) {\n                uint256 startPunitory = max(loan.dueTime, loan.interestTimestamp);\n                deltaTime = timestamp - startPunitory;\n\n                uint256 debt = safeAdd(loan.amount, newInterest);\n                pending = min(debt, safeSubtract(safeAdd(debt, newPunitoryInterest), loan.paid));\n\n                (realDelta, calculatedInterest) = calculateInterest(deltaTime, loan.interestRatePunitory, pending);\n                newPunitoryInterest = safeAdd(newPunitoryInterest, calculatedInterest);\n                newTimestamp = startPunitory + realDelta;\n            }\n            \n            if (newInterest != loan.interest || newPunitoryInterest != loan.punitoryInterest) {\n                loan.interestTimestamp = newTimestamp;\n                loan.interest = newInterest;\n                loan.punitoryInterest = newPunitoryInterest;\n            }\n        }\n    }\n\n    /**\n        @dev Computes loan interest only up to current unix time\n\n        @param timestamp Target absolute unix time to calculate interest.\n    */\n    function addInterestUpTo(Loan storage loan, uint256 timestamp) internal {\n        require(loan.status == Status.lent);\n        if (timestamp <= block.timestamp) {\n            internalAddInterest(loan, timestamp);\n        }\n    }\n\n    /**\n        @dev Updates the loan accumulated interests up to the current Unix time.\n        \n        @param index Index of the loan\n    */\n    function addInterest(uint index) public {\n        Loan storage loan = loans[index];\n        addInterestUpTo(loan, block.timestamp);\n    }\n    \n    /**\n        @dev Pay loan\n\n        Realizes a payment of a given Loan, before performing the payment the accumulated\n        interest is computed and added to the total pending amount.\n\n        Before calling this function, the msg.sender must call the \"approve\" function on the RCN Token, specifying an amount\n        sufficient enough to pay the equivalent of the desired payment and the oracle fee.\n\n        Because it is difficult or even impossible to know in advance how much RCN are going to be spent on the\n        transaction*, we recommend performing the \"approve\" using an amount 5% superior to the wallet estimated\n        spending. If the RCN spent results to be less, the extra tokens are never debited from the msg.sender.\n\n        * The RCN rate can fluctuate on the same block, and it is impossible to know in advance the exact time of the\n        confirmation of the transaction. \n\n        If the paid pending amount equals zero, the loan changes status to \"paid\" and it is considered closed.\n\n        @param index Index of the loan\n        @param _amount Amount to pay, specified in the loan currency; or in RCN if the loan has no oracle\n        @param _from The identity of the payer\n        @param oracleData Data required by the oracle to return the rate, the content of this field must be provided\n            by the url exposed in the url() method of the oracle.\n            \n        @return true if the payment was executed successfully\n    */\n    function pay(uint index, uint256 _amount, address _from, bytes oracleData) public returns (bool) {\n        Loan storage loan = loans[index];\n\n        require(loan.status == Status.lent);\n        addInterest(index);\n        uint256 toPay = min(getPendingAmount(index), _amount);\n        PartialPayment(index, msg.sender, _from, toPay);\n\n        loan.paid = safeAdd(loan.paid, toPay);\n\n        if (getRawPendingAmount(loan) == 0) {\n            TotalPayment(index);\n            loan.status = Status.paid;\n\n            // ERC721, remove loan from circulation\n            lendersBalance[loan.lender] -= 1;\n            activeLoans -= 1;\n            Transfer(loan.lender, 0x0, index);\n        }\n\n        uint256 rate = getRate(loan, oracleData);\n        uint256 transferValue = safeMult(toPay, rate);\n        lockTokens(rcn, transferValue);\n        require(rcn.transferFrom(msg.sender, this, transferValue));\n        loan.lenderBalance = safeAdd(transferValue, loan.lenderBalance);\n\n        return true;\n    }\n\n    /**\n        @dev Retrieves the rate corresponding of the loan oracle, if the loan has no oracle the rate is 1\n\n        @param loan The loan with the cosigner\n        @param data Data required by the oracle\n\n        @return The rate of the oracle\n    */\n    function getRate(Loan loan, bytes data) internal returns (uint256) {\n        if (loan.oracle == address(0)) {\n            return 1;\n        } else {\n            return loan.oracle.getRate(loan.currency, data);\n        }\n    }\n\n    /**\n        @dev Withdraw lender funds\n\n        When a loan is paid, the funds are not transferred automatically to the lender, the funds are stored on the\n        engine contract, and the lender must call this function specifying the amount desired to transfer and the \n        destination.\n\n        This behavior is defined to allow the temporary transfer of the loan to a smart contract, without worrying that\n        the contract will receive tokens that are not traceable; and it allows the development of decentralized \n        autonomous organizations.\n\n        @param index Index of the loan\n        @param to Destination of the wiwthdraw funds\n        @param amount Amount to withdraw, in RCN\n\n        @return true if the withdraw was executed successfully\n    */\n    function withdrawal(uint index, address to, uint256 amount) public returns (bool) {\n        Loan storage loan = loans[index];\n        require(msg.sender == loan.lender);\n        loan.lenderBalance = safeSubtract(loan.lenderBalance, amount);\n        require(rcn.transfer(to, amount));\n        unlockTokens(rcn, amount);\n        return true;\n    }\n\n    function withdrawalRange(uint256 fromIndex, uint256 toIndex, address to) public returns (uint256) {\n        uint256 loanId;\n        uint256 totalWithdraw = 0;\n\n        for (loanId = fromIndex; loanId <= toIndex; loanId++) {\n            Loan storage loan = loans[loanId];\n            if (loan.lender == msg.sender) {\n                totalWithdraw += loan.lenderBalance;\n                loan.lenderBalance = 0;\n            }\n        }\n\n        require(rcn.transfer(to, totalWithdraw));\n        unlockTokens(rcn, totalWithdraw);\n        \n        return totalWithdraw;\n    }\n\n    function withdrawalList(uint256[] memory loanIds, address to) public returns (uint256) {\n        uint256 inputId;\n        uint256 totalWithdraw = 0;\n\n        for (inputId = 0; inputId < loanIds.length; inputId++) {\n            Loan storage loan = loans[loanIds[inputId]];\n            if (loan.lender == msg.sender) {\n                totalWithdraw += loan.lenderBalance;\n                loan.lenderBalance = 0;\n            }\n        }\n\n        require(rcn.transfer(to, totalWithdraw));\n        unlockTokens(rcn, totalWithdraw);\n\n        return totalWithdraw;\n    }\n\n    /**\n        @dev Deprecates the engine, locks the creation of new loans.\n    */\n    function setDeprecated(bool _deprecated) public onlyOwner {\n        deprecated = _deprecated;\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinfabrik-RCN Network Smart Contract Audit/rcn-network-3ded36151ad55543d16c354e70161852de4061d0/contracts/NanoLoanEngine.sol",
        "vulnerability": "Assertion Failure",
        "check": "FP",
        "response": "Answer: No  \nReason: The code does not contain any assert statements which would cause an \"Assertion Failure\"."
    },
    {
        "code_segment": "contract NanoLoanEngine is ERC721, Engine, Ownable, TokenLockable {\n    uint256 public constant VERSION = 202;\n    string public constant VERSION_NAME = \"Basalt\";\n\n    uint256 private activeLoans = 0;\n    mapping(address => uint256) private lendersBalance;\n\n    function name() constant returns (string _name) {\n        _name = \"RCN - Nano loan engine - Basalt 202\";\n    }\n\n    function symbol() constant returns (string _symbol) {\n        _symbol = \"RCN-NLE-202\";\n    }\n\n    function totalSupply() constant returns (uint _totalSupply) {\n        _totalSupply = activeLoans;\n    }\n\n    function balanceOf(address _owner) constant returns (uint _balance) {\n        _balance = lendersBalance[_owner];\n    }\n\n    function tokenOfOwnerByIndex(address _owner, uint256 _index) constant returns (uint tokenId) {\n        uint256 tokenCount = balanceOf(_owner);\n\n        if (tokenCount == 0 || _index >= tokenCount) {\n            // Fail transaction\n            revert();\n        } else {\n            uint256 totalLoans = totalSupply();\n            uint256 resultIndex = 0;\n\n            uint256 loanId;\n            // SWC-128-DoS With Block Gas Limit: L46\n            for (loanId = 0; loanId <= totalLoans; loanId++) {\n                if (loans[loanId].lender == _owner && loans[loanId].status == Status.lent) {\n                    if (resultIndex == _index) {\n                        return loanId;\n                    }\n                    resultIndex++;\n                }\n            }\n\n            revert();\n        }\n    }\n\n    function tokensOfOwner(address _owner) external constant returns(uint256[] ownerTokens) {\n        uint256 tokenCount = balanceOf(_owner);\n\n        if (tokenCount == 0) {\n            // Return an empty array\n            return new uint256[](0);\n        } else {\n            uint256[] memory result = new uint256[](tokenCount);\n            uint256 totalLoans = totalSupply();\n            uint256 resultIndex = 0;\n\n            uint256 loanId;\n\n            for (loanId = 0; loanId <= totalLoans; loanId++) {\n                if (loans[loanId].lender == _owner && loans[loanId].status == Status.lent) {\n                    result[resultIndex] = loanId;\n                    resultIndex++;\n                }\n            }\n\n            return result;\n        }\n    }\n    \n    Token public rcn;\n    bool public deprecated;\n\n    event CreatedLoan(uint _index, address _borrower, address _creator);\n    event ApprovedBy(uint _index, address _address);\n    event Lent(uint _index, address _lender, address _cosigner);\n    event DestroyedBy(uint _index, address _address);\n    event PartialPayment(uint _index, address _sender, address _from, uint256 _amount);\n    event TotalPayment(uint _index);\n\n    function NanoLoanEngine(Token _rcn) public {\n        owner = msg.sender;\n        rcn = _rcn;\n    }\n\n    struct Loan {\n        Status status;\n        Oracle oracle;\n\n        address borrower;\n        address lender;\n        address creator;\n        address cosigner;\n        \n        uint256 amount;\n        uint256 interest;\n        uint256 punitoryInterest;\n        uint256 interestTimestamp;\n        uint256 paid;\n        uint256 interestRate;\n        uint256 interestRatePunitory;\n        uint256 dueTime;\n        uint256 duesIn;\n\n        bytes32 currency;\n        uint256 cancelableAt;\n        uint256 lenderBalance;\n\n        address approvedTransfer;\n        uint256 expirationRequest;\n\n        mapping(address => bool) approbations;\n    }\n\n    Loan[] private loans;\n\n    /**\n        @dev Creates a loan request, the loan can be generated with any borrower, cosigner, and conditions; if the \n        cosigner and borrower agree they must call the \"approve\" function.\n\n        The creator of the loan is the caller of this function; this is useful to track which wallet created the loan.\n\n        @param _oracleContract Address of the Oracle contract, if the loan does not use any oracle, this field should be 0x0.\n        @param _borrower Address of the borrower\n        @param _currency The currency to use with the oracle, the currency code is generated with the following formula,\n            keccak256(ticker,decimals).\n        @param _amount The requested amount; currency and unit are defined by the Oracle, if there is no Oracle present\n            the currency is RCN, and the unit is wei.\n        @param _interestRate The non-punitory interest rate by second, defined as a denominator of 10 000 000.\n        @param _interestRatePunitory The punitory interest rate by second, defined as a denominator of 10 000 000.\n            Ej: interestRate 11108571428571 = 28% Anual interest\n        @param _duesIn The time in seconds that the borrower has in order to pay the debt after the lender lends the money.\n        @param _cancelableAt Delta in seconds specifying how much interest should be added in advance, if the borrower pays \n        entirely or partially the loan before this term, no extra interest will be deducted.\n        @param _expirationRequest Timestamp of when the loan request expires, if the loan is not filled before this date, \n            the request is no longer valid.\n    */\n    function createLoan(Oracle _oracleContract, address _borrower, bytes32 _currency, uint256 _amount, uint256 _interestRate,\n        uint256 _interestRatePunitory, uint256 _duesIn, uint256 _cancelableAt, uint256 _expirationRequest) returns (uint256) {\n\n        require(!deprecated);\n        require(_cancelableAt <= _duesIn);\n        require(_oracleContract != address(0) || _currency == 0x0);\n        require(_borrower != address(0));\n        require(_amount != 0);\n        require(_interestRatePunitory != 0);\n        require(_interestRate != 0);\n        require(_expirationRequest > block.timestamp);\n\n        var loan = Loan(Status.initial, _oracleContract, _borrower, 0x0, msg.sender, 0x0, _amount, 0, 0, 0, 0, _interestRate,\n            _interestRatePunitory, 0, _duesIn, _currency, _cancelableAt, 0, 0x0, _expirationRequest);\n        uint index = loans.push(loan) - 1;\n        CreatedLoan(index, _borrower, msg.sender);\n\n        if (msg.sender == _borrower) {\n            approveLoan(index);\n        }\n\n        return index;\n    }\n    \n    function ownerOf(uint256 index) constant returns (address owner) { owner = loans[index].lender; }\n    function getTotalLoans() constant returns (uint256) { return loans.length; }\n    function getOracle(uint index) constant returns (Oracle) { return loans[index].oracle; }\n    function getBorrower(uint index) constant returns (address) { return loans[index].borrower; }\n    function getCosigner(uint index) constant returns (address) { return loans[index].cosigner; }\n    function getCreator(uint index) constant returns (address) { return loans[index].creator; }\n    function getAmount(uint index) constant returns (uint256) { return loans[index].amount; }\n    function getPunitoryInterest(uint index) constant returns (uint256) { return loans[index].punitoryInterest; }\n    function getInterestTimestamp(uint index) constant returns (uint256) { return loans[index].interestTimestamp; }\n    function getPaid(uint index) constant returns (uint256) { return loans[index].paid; }\n    function getInterestRate(uint index) constant returns (uint256) { return loans[index].interestRate; }\n    function getInterestRatePunitory(uint index) constant returns (uint256) { return loans[index].interestRatePunitory; }\n    function getDueTime(uint index) constant returns (uint256) { return loans[index].dueTime; }\n    function getDuesIn(uint index) constant returns (uint256) { return loans[index].duesIn; }\n    function getCancelableAt(uint index) constant returns (uint256) { return loans[index].cancelableAt; }\n    function getApprobation(uint index, address _address) constant returns (bool) { return loans[index].approbations[_address]; }\n    function getStatus(uint index) constant returns (Status) { return loans[index].status; }\n    function getLenderBalance(uint index) constant returns (uint256) { return loans[index].lenderBalance; }\n    function getApprovedTransfer(uint index) constant returns (address) {return loans[index].approvedTransfer; }\n    function getCurrency(uint index) constant returns (bytes32) { return loans[index].currency; }\n    function getExpirationRequest(uint index) constant returns (uint256) { return loans[index].expirationRequest; }\n    function getInterest(uint index) constant returns (uint256) { return loans[index].interest; }\n\n    /**\n        @param index Index of the loan\n\n        @return true if the loan has been approved by the borrower and cosigner.\n    */\n    function isApproved(uint index) constant returns (bool) {\n        Loan storage loan = loans[index];\n        return loan.approbations[loan.borrower];\n    }\n\n    /**\n        @dev Called by the members of the loan to show that they agree with the terms of the loan; the borrower\n        must call this method before any lender could call the method \"lend\".\n            \n        Any address can call this method to be added to the \"approbations\" mapping.\n\n        @param index Index of the loan\n\n        @return true if the approve was done successfully\n    */\n    function approveLoan(uint index) public returns(bool) {\n        Loan storage loan = loans[index];\n        require(loan.status == Status.initial);\n        loan.approbations[msg.sender] = true;\n        ApprovedBy(index, msg.sender);\n        return true;\n    }\n\n    /**\n        @dev Performs the lend of the RCN equivalent to the requested amount, and transforms the msg.sender in the new lender.\n\n        The loan must be previously approved by the borrower; before calling this function, the lender candidate must \n        call the \"approve\" function on the RCN Token, specifying an amount sufficient enough to pay the equivalent of\n        the requested amount, and the cosigner fee.\n        \n        @param index Index of the loan\n        @param oracleData Data required by the oracle to return the rate, the content of this field must be provided\n            by the url exposed in the url() method of the oracle.\n        @param cosigner Address of the cosigner, 0x0 for lending without cosigner.\n        @param cosignerData Data required by the cosigner to process the request.\n\n        @return true if the lend was done successfully\n    */\n    function lend(uint index, bytes oracleData, Cosigner cosigner, bytes cosignerData) public returns (bool) {\n        Loan storage loan = loans[index];\n\n        require(loan.status == Status.initial);\n        require(isApproved(index));\n        require(block.timestamp <= loan.expirationRequest);\n\n        loan.lender = msg.sender;\n        loan.dueTime = safeAdd(block.timestamp, loan.duesIn);\n        loan.interestTimestamp = block.timestamp;\n        loan.status = Status.lent;\n        \n        if (loan.cancelableAt > 0)\n            internalAddInterest(loan, safeAdd(block.timestamp, loan.cancelableAt));\n\n        uint256 rate = getRate(loan, oracleData);\n\n        if (cosigner != address(0)) {\n            // The cosigner it's temporary set to the next address (cosigner + 2), it's expected that the cosigner will\n            // call the method \"cosign\" to accept the conditions; that method also sets the cosigner to the right\n            // address. If that does not happen, the transaction fails.\n            loan.cosigner = address(uint256(cosigner) + 2);\n            require(cosigner.requestCosign(this, index, cosignerData, oracleData));\n            require(loan.cosigner == address(cosigner));\n        }\n        \n        require(rcn.transferFrom(msg.sender, loan.borrower, safeMult(loan.amount, rate)));\n        \n        // ERC721, create new loan and transfer it to the lender\n        Transfer(0x0, loan.lender, index);\n        activeLoans += 1;\n        lendersBalance[loan.lender] += 1;\n        Lent(index, loan.lender, cosigner);\n\n        return true;\n    }\n\n    /**\n        @dev The cosigner must call this method to accept the conditions of a loan, this method pays the cosigner his fee\n\n        @param index Index of the loan\n        @param cost Fee set by the cosigner\n\n        @return true If the cosign was successfull\n    */\n    function cosign(uint index, uint256 cost) external returns (bool) {\n        Loan storage loan = loans[index];\n        require(loan.status == Status.lent && (loan.dueTime - loan.duesIn) == block.timestamp);\n        require(loan.cosigner != address(0));\n        require(loan.cosigner == address(uint256(msg.sender) + 2));\n        loan.cosigner = msg.sender;\n        require(rcn.transferFrom(loan.lender, msg.sender, cost));\n        return true;\n    }\n\n    /**\n        @dev Destroys a loan, the borrower could call this method if they performed an accidental or regretted \n        \"approve\" of the loan, this method only works for them if the loan is in \"pending\" status.\n\n        The lender can call this method at any moment, in case of a loan with status \"lent\" the lender is pardoning \n        the debt. \n\n        @param index Index of the loan\n\n        @return true if the destroy was done successfully\n    */\n    function destroy(uint index) public returns (bool) {\n        Loan storage loan = loans[index];\n        require(loan.status != Status.destroyed);\n        require(msg.sender == loan.lender || (msg.sender == loan.borrower && loan.status == Status.initial));\n        DestroyedBy(index, msg.sender);\n\n        // ERC721, remove loan from circulation\n        if (loan.status != Status.initial) {\n            lendersBalance[loan.lender] -= 1;\n            activeLoans -= 1;\n            Transfer(loan.lender, 0x0, index);\n        }\n\n        loan.status = Status.destroyed;\n        return true;\n    }\n\n    /**\n        @dev Transfers a loan to a different lender, the caller must be the current lender or previously being\n        approved with the method \"approveTransfer\"; only loans with the Status.lent status can be transfered.\n\n        @param index Index of the loan\n        @param to New lender\n\n        @return true if the transfer was done successfully\n    */\n    function transfer(address to, uint256 index) public returns (bool) {\n        Loan storage loan = loans[index];\n        \n        require(loan.status != Status.destroyed && loan.status != Status.paid);\n        require(msg.sender == loan.lender || msg.sender == loan.approvedTransfer);\n        require(to != address(0));\n        loan.lender = to;\n        loan.approvedTransfer = address(0);\n\n        // ERC721, transfer loan to another address\n        lendersBalance[msg.sender] -= 1;\n        lendersBalance[to] += 1;\n        Transfer(loan.lender, to, index);\n\n        return true;\n    }\n\n    /**\n        @dev ERC721 method, transfers the loan to the msg.sender, the msg.sender must be approved using the \n        \"approve\" method.\n\n        @return true if the transfer was successfull\n    */\n    function takeOwnership(uint256 _index) public returns (bool) {\n        return transfer(msg.sender, _index);\n    }\n\n    /**\n        @dev Approves the transfer of a given loan in the name of the lender, the behavior of this function is similar to\n        \"approve\" in the ERC20 standard, but only one approved address is allowed at a time.\n\n        The same method can be called passing 0x0 as parameter \"to\" to erase a previously approved address.\n\n        @param to Address allowed to transfer the loan or 0x0 to delete\n        @param index Index of the loan\n\n        @return true if the approve was done successfully\n    */\n    function approve(address to, uint256 index) public returns (bool) {\n        Loan storage loan = loans[index];\n        require(msg.sender == loan.lender);\n        loan.approvedTransfer = to;\n        Approval(msg.sender, to, index);\n        return true;\n    }\n\n    /**\n        @dev Returns the pending amount to complete de payment of the loan, keep in mind that this number increases \n        every second.\n\n        @param index Index of the loan\n\n        @return Aprox pending payment amount\n    */\n    function getPendingAmount(uint index) public constant returns (uint256) {\n        Loan storage loan = loans[index];\n        addInterest(index);\n        return getRawPendingAmount(loan);\n    }\n\n    function getRawPendingAmount(Loan loan) internal returns (uint256) {\n        return safeSubtract(safeAdd(safeAdd(loan.amount, loan.interest), loan.punitoryInterest), loan.paid);\n    }\n\n    /**\n        @dev Calculates the interest of a given amount, interest rate and delta time.\n\n        @param timeDelta Elapsed time\n        @param interestRate Interest rate expressed as the denominator of 10 000 000.\n        @param amount Amount to apply interest\n\n        @return realDelta The real timeDelta applied\n        @return interest The interest gained in the realDelta time\n    */\n    function calculateInterest(uint256 timeDelta, uint256 interestRate, uint256 amount) public constant returns (uint256 realDelta, uint256 interest) {\n        if (amount == 0) {\n            interest = 0;\n            realDelta = timeDelta;\n        } else {\n            interest = safeMult(safeMult(100000, amount), timeDelta) / interestRate;\n            realDelta = safeMult(interest, interestRate) / (amount * 100000);\n        }\n    }\n\n    /**\n        @dev Computes loan interest\n\n        Computes the punitory and non-punitory interest of a given loan and only applies the change.\n        \n        @param loan Loan to compute interest\n        @param timestamp Target absolute unix time to calculate interest.\n    */\n    function internalAddInterest(Loan storage loan, uint256 timestamp) internal {\n        if (timestamp > loan.interestTimestamp) {\n            uint256 newInterest = loan.interest;\n            uint256 newPunitoryInterest = loan.punitoryInterest;\n\n            uint256 newTimestamp;\n            uint256 realDelta;\n            uint256 calculatedInterest;\n\n            uint256 deltaTime;\n            uint256 pending;\n\n            uint256 endNonPunitory = min(timestamp, loan.dueTime);\n            if (endNonPunitory > loan.interestTimestamp) {\n                deltaTime = endNonPunitory - loan.interestTimestamp;\n\n                if (loan.paid < loan.amount) {\n                    pending = loan.amount - loan.paid;\n                } else {\n                    pending = 0;\n                }\n\n                (realDelta, calculatedInterest) = calculateInterest(deltaTime, loan.interestRate, pending);\n                newInterest = safeAdd(calculatedInterest, newInterest);\n                newTimestamp = loan.interestTimestamp + realDelta;\n            }\n\n            if (timestamp > loan.dueTime) {\n                uint256 startPunitory = max(loan.dueTime, loan.interestTimestamp);\n                deltaTime = timestamp - startPunitory;\n\n                uint256 debt = safeAdd(loan.amount, newInterest);\n                pending = min(debt, safeSubtract(safeAdd(debt, newPunitoryInterest), loan.paid));\n\n                (realDelta, calculatedInterest) = calculateInterest(deltaTime, loan.interestRatePunitory, pending);\n                newPunitoryInterest = safeAdd(newPunitoryInterest, calculatedInterest);\n                newTimestamp = startPunitory + realDelta;\n            }\n            \n            if (newInterest != loan.interest || newPunitoryInterest != loan.punitoryInterest) {\n                loan.interestTimestamp = newTimestamp;\n                loan.interest = newInterest;\n                loan.punitoryInterest = newPunitoryInterest;\n            }\n        }\n    }\n\n    /**\n        @dev Computes loan interest only up to current unix time\n\n        @param timestamp Target absolute unix time to calculate interest.\n    */\n    function addInterestUpTo(Loan storage loan, uint256 timestamp) internal {\n        require(loan.status == Status.lent);\n        if (timestamp <= block.timestamp) {\n            internalAddInterest(loan, timestamp);\n        }\n    }\n\n    /**\n        @dev Updates the loan accumulated interests up to the current Unix time.\n        \n        @param index Index of the loan\n    */\n    function addInterest(uint index) public {\n        Loan storage loan = loans[index];\n        addInterestUpTo(loan, block.timestamp);\n    }\n    \n    /**\n        @dev Pay loan\n\n        Realizes a payment of a given Loan, before performing the payment the accumulated\n        interest is computed and added to the total pending amount.\n\n        Before calling this function, the msg.sender must call the \"approve\" function on the RCN Token, specifying an amount\n        sufficient enough to pay the equivalent of the desired payment and the oracle fee.\n\n        Because it is difficult or even impossible to know in advance how much RCN are going to be spent on the\n        transaction*, we recommend performing the \"approve\" using an amount 5% superior to the wallet estimated\n        spending. If the RCN spent results to be less, the extra tokens are never debited from the msg.sender.\n\n        * The RCN rate can fluctuate on the same block, and it is impossible to know in advance the exact time of the\n        confirmation of the transaction. \n\n        If the paid pending amount equals zero, the loan changes status to \"paid\" and it is considered closed.\n\n        @param index Index of the loan\n        @param _amount Amount to pay, specified in the loan currency; or in RCN if the loan has no oracle\n        @param _from The identity of the payer\n        @param oracleData Data required by the oracle to return the rate, the content of this field must be provided\n            by the url exposed in the url() method of the oracle.\n            \n        @return true if the payment was executed successfully\n    */\n    function pay(uint index, uint256 _amount, address _from, bytes oracleData) public returns (bool) {\n        Loan storage loan = loans[index];\n\n        require(loan.status == Status.lent);\n        addInterest(index);\n        uint256 toPay = min(getPendingAmount(index), _amount);\n        PartialPayment(index, msg.sender, _from, toPay);\n\n        loan.paid = safeAdd(loan.paid, toPay);\n\n        if (getRawPendingAmount(loan) == 0) {\n            TotalPayment(index);\n            loan.status = Status.paid;\n\n            // ERC721, remove loan from circulation\n            lendersBalance[loan.lender] -= 1;\n            activeLoans -= 1;\n            Transfer(loan.lender, 0x0, index);\n        }\n\n        uint256 rate = getRate(loan, oracleData);\n        uint256 transferValue = safeMult(toPay, rate);\n        lockTokens(rcn, transferValue);\n        require(rcn.transferFrom(msg.sender, this, transferValue));\n        loan.lenderBalance = safeAdd(transferValue, loan.lenderBalance);\n\n        return true;\n    }\n\n    /**\n        @dev Retrieves the rate corresponding of the loan oracle, if the loan has no oracle the rate is 1\n\n        @param loan The loan with the cosigner\n        @param data Data required by the oracle\n\n        @return The rate of the oracle\n    */\n    function getRate(Loan loan, bytes data) internal returns (uint256) {\n        if (loan.oracle == address(0)) {\n            return 1;\n        } else {\n            return loan.oracle.getRate(loan.currency, data);\n        }\n    }\n\n    /**\n        @dev Withdraw lender funds\n\n        When a loan is paid, the funds are not transferred automatically to the lender, the funds are stored on the\n        engine contract, and the lender must call this function specifying the amount desired to transfer and the \n        destination.\n\n        This behavior is defined to allow the temporary transfer of the loan to a smart contract, without worrying that\n        the contract will receive tokens that are not traceable; and it allows the development of decentralized \n        autonomous organizations.\n\n        @param index Index of the loan\n        @param to Destination of the wiwthdraw funds\n        @param amount Amount to withdraw, in RCN\n\n        @return true if the withdraw was executed successfully\n    */\n    function withdrawal(uint index, address to, uint256 amount) public returns (bool) {\n        Loan storage loan = loans[index];\n        require(msg.sender == loan.lender);\n        loan.lenderBalance = safeSubtract(loan.lenderBalance, amount);\n        require(rcn.transfer(to, amount));\n        unlockTokens(rcn, amount);\n        return true;\n    }\n\n    function withdrawalRange(uint256 fromIndex, uint256 toIndex, address to) public returns (uint256) {\n        uint256 loanId;\n        uint256 totalWithdraw = 0;\n\n        for (loanId = fromIndex; loanId <= toIndex; loanId++) {\n            Loan storage loan = loans[loanId];\n            if (loan.lender == msg.sender) {\n                totalWithdraw += loan.lenderBalance;\n                loan.lenderBalance = 0;\n            }\n        }\n\n        require(rcn.transfer(to, totalWithdraw));\n        unlockTokens(rcn, totalWithdraw);\n        \n        return totalWithdraw;\n    }\n\n    function withdrawalList(uint256[] memory loanIds, address to) public returns (uint256) {\n        uint256 inputId;\n        uint256 totalWithdraw = 0;\n\n        for (inputId = 0; inputId < loanIds.length; inputId++) {\n            Loan storage loan = loans[loanIds[inputId]];\n            if (loan.lender == msg.sender) {\n                totalWithdraw += loan.lenderBalance;\n                loan.lenderBalance = 0;\n            }\n        }\n\n        require(rcn.transfer(to, totalWithdraw));\n        unlockTokens(rcn, totalWithdraw);\n\n        return totalWithdraw;\n    }\n\n    /**\n        @dev Deprecates the engine, locks the creation of new loans.\n    */\n    function setDeprecated(bool _deprecated) public onlyOwner {\n        deprecated = _deprecated;\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinfabrik-RCN Network Smart Contract Audit/rcn-network-3ded36151ad55543d16c354e70161852de4061d0/contracts/NanoLoanEngine.sol",
        "vulnerability": "Assertion Failure",
        "check": "FP",
        "response": "**1st Audit:**\n\nAnswer: No  \nReason: The provided code does not contain any `assert` statements, thus no risk of assertion failures.\n\n**2nd Audit:**\n\nAnswer: No  \nReason: The provided code does not contain any `assert` statements, thus no risk of assertion failures.\n\n**3rd Audit:**\n\nAnswer: No  \nReason: The provided code does not contain any `assert` statements, thus no risk of assertion failures.\n\n**4th Audit:**\n\nAnswer: No  \nReason: The provided code does not contain any `assert` statements, thus no risk of assertion failures.\n\n**5th Audit:**\n\nAnswer: No  \nReason: The provided code does not contain any `assert` statements, thus no risk of assertion failures."
    },
    {
        "code_segment": "contract NanoLoanEngine is ERC721, Engine, Ownable, TokenLockable {\n    uint256 public constant VERSION = 202;\n    string public constant VERSION_NAME = \"Basalt\";\n\n    uint256 private activeLoans = 0;\n    mapping(address => uint256) private lendersBalance;\n\n    function name() constant returns (string _name) {\n        _name = \"RCN - Nano loan engine - Basalt 202\";\n    }\n\n    function symbol() constant returns (string _symbol) {\n        _symbol = \"RCN-NLE-202\";\n    }\n\n    function totalSupply() constant returns (uint _totalSupply) {\n        _totalSupply = activeLoans;\n    }\n\n    function balanceOf(address _owner) constant returns (uint _balance) {\n        _balance = lendersBalance[_owner];\n    }\n\n    function tokenOfOwnerByIndex(address _owner, uint256 _index) constant returns (uint tokenId) {\n        uint256 tokenCount = balanceOf(_owner);\n\n        if (tokenCount == 0 || _index >= tokenCount) {\n            // Fail transaction\n            revert();\n        } else {\n            uint256 totalLoans = totalSupply();\n            uint256 resultIndex = 0;\n\n            uint256 loanId;\n            // SWC-128-DoS With Block Gas Limit: L46\n            for (loanId = 0; loanId <= totalLoans; loanId++) {\n                if (loans[loanId].lender == _owner && loans[loanId].status == Status.lent) {\n                    if (resultIndex == _index) {\n                        return loanId;\n                    }\n                    resultIndex++;\n                }\n            }\n\n            revert();\n        }\n    }\n\n    function tokensOfOwner(address _owner) external constant returns(uint256[] ownerTokens) {\n        uint256 tokenCount = balanceOf(_owner);\n\n        if (tokenCount == 0) {\n            // Return an empty array\n            return new uint256[](0);\n        } else {\n            uint256[] memory result = new uint256[](tokenCount);\n            uint256 totalLoans = totalSupply();\n            uint256 resultIndex = 0;\n\n            uint256 loanId;\n\n            for (loanId = 0; loanId <= totalLoans; loanId++) {\n                if (loans[loanId].lender == _owner && loans[loanId].status == Status.lent) {\n                    result[resultIndex] = loanId;\n                    resultIndex++;\n                }\n            }\n\n            return result;\n        }\n    }\n    \n    Token public rcn;\n    bool public deprecated;\n\n    event CreatedLoan(uint _index, address _borrower, address _creator);\n    event ApprovedBy(uint _index, address _address);\n    event Lent(uint _index, address _lender, address _cosigner);\n    event DestroyedBy(uint _index, address _address);\n    event PartialPayment(uint _index, address _sender, address _from, uint256 _amount);\n    event TotalPayment(uint _index);\n\n    function NanoLoanEngine(Token _rcn) public {\n        owner = msg.sender;\n        rcn = _rcn;\n    }\n\n    struct Loan {\n        Status status;\n        Oracle oracle;\n\n        address borrower;\n        address lender;\n        address creator;\n        address cosigner;\n        \n        uint256 amount;\n        uint256 interest;\n        uint256 punitoryInterest;\n        uint256 interestTimestamp;\n        uint256 paid;\n        uint256 interestRate;\n        uint256 interestRatePunitory;\n        uint256 dueTime;\n        uint256 duesIn;\n\n        bytes32 currency;\n        uint256 cancelableAt;\n        uint256 lenderBalance;\n\n        address approvedTransfer;\n        uint256 expirationRequest;\n\n        mapping(address => bool) approbations;\n    }\n\n    Loan[] private loans;\n\n    /**\n        @dev Creates a loan request, the loan can be generated with any borrower, cosigner, and conditions; if the \n        cosigner and borrower agree they must call the \"approve\" function.\n\n        The creator of the loan is the caller of this function; this is useful to track which wallet created the loan.\n\n        @param _oracleContract Address of the Oracle contract, if the loan does not use any oracle, this field should be 0x0.\n        @param _borrower Address of the borrower\n        @param _currency The currency to use with the oracle, the currency code is generated with the following formula,\n            keccak256(ticker,decimals).\n        @param _amount The requested amount; currency and unit are defined by the Oracle, if there is no Oracle present\n            the currency is RCN, and the unit is wei.\n        @param _interestRate The non-punitory interest rate by second, defined as a denominator of 10 000 000.\n        @param _interestRatePunitory The punitory interest rate by second, defined as a denominator of 10 000 000.\n            Ej: interestRate 11108571428571 = 28% Anual interest\n        @param _duesIn The time in seconds that the borrower has in order to pay the debt after the lender lends the money.\n        @param _cancelableAt Delta in seconds specifying how much interest should be added in advance, if the borrower pays \n        entirely or partially the loan before this term, no extra interest will be deducted.\n        @param _expirationRequest Timestamp of when the loan request expires, if the loan is not filled before this date, \n            the request is no longer valid.\n    */\n    function createLoan(Oracle _oracleContract, address _borrower, bytes32 _currency, uint256 _amount, uint256 _interestRate,\n        uint256 _interestRatePunitory, uint256 _duesIn, uint256 _cancelableAt, uint256 _expirationRequest) returns (uint256) {\n\n        require(!deprecated);\n        require(_cancelableAt <= _duesIn);\n        require(_oracleContract != address(0) || _currency == 0x0);\n        require(_borrower != address(0));\n        require(_amount != 0);\n        require(_interestRatePunitory != 0);\n        require(_interestRate != 0);\n        require(_expirationRequest > block.timestamp);\n\n        var loan = Loan(Status.initial, _oracleContract, _borrower, 0x0, msg.sender, 0x0, _amount, 0, 0, 0, 0, _interestRate,\n            _interestRatePunitory, 0, _duesIn, _currency, _cancelableAt, 0, 0x0, _expirationRequest);\n        uint index = loans.push(loan) - 1;\n        CreatedLoan(index, _borrower, msg.sender);\n\n        if (msg.sender == _borrower) {\n            approveLoan(index);\n        }\n\n        return index;\n    }\n    \n    function ownerOf(uint256 index) constant returns (address owner) { owner = loans[index].lender; }\n    function getTotalLoans() constant returns (uint256) { return loans.length; }\n    function getOracle(uint index) constant returns (Oracle) { return loans[index].oracle; }\n    function getBorrower(uint index) constant returns (address) { return loans[index].borrower; }\n    function getCosigner(uint index) constant returns (address) { return loans[index].cosigner; }\n    function getCreator(uint index) constant returns (address) { return loans[index].creator; }\n    function getAmount(uint index) constant returns (uint256) { return loans[index].amount; }\n    function getPunitoryInterest(uint index) constant returns (uint256) { return loans[index].punitoryInterest; }\n    function getInterestTimestamp(uint index) constant returns (uint256) { return loans[index].interestTimestamp; }\n    function getPaid(uint index) constant returns (uint256) { return loans[index].paid; }\n    function getInterestRate(uint index) constant returns (uint256) { return loans[index].interestRate; }\n    function getInterestRatePunitory(uint index) constant returns (uint256) { return loans[index].interestRatePunitory; }\n    function getDueTime(uint index) constant returns (uint256) { return loans[index].dueTime; }\n    function getDuesIn(uint index) constant returns (uint256) { return loans[index].duesIn; }\n    function getCancelableAt(uint index) constant returns (uint256) { return loans[index].cancelableAt; }\n    function getApprobation(uint index, address _address) constant returns (bool) { return loans[index].approbations[_address]; }\n    function getStatus(uint index) constant returns (Status) { return loans[index].status; }\n    function getLenderBalance(uint index) constant returns (uint256) { return loans[index].lenderBalance; }\n    function getApprovedTransfer(uint index) constant returns (address) {return loans[index].approvedTransfer; }\n    function getCurrency(uint index) constant returns (bytes32) { return loans[index].currency; }\n    function getExpirationRequest(uint index) constant returns (uint256) { return loans[index].expirationRequest; }\n    function getInterest(uint index) constant returns (uint256) { return loans[index].interest; }\n\n    /**\n        @param index Index of the loan\n\n        @return true if the loan has been approved by the borrower and cosigner.\n    */\n    function isApproved(uint index) constant returns (bool) {\n        Loan storage loan = loans[index];\n        return loan.approbations[loan.borrower];\n    }\n\n    /**\n        @dev Called by the members of the loan to show that they agree with the terms of the loan; the borrower\n        must call this method before any lender could call the method \"lend\".\n            \n        Any address can call this method to be added to the \"approbations\" mapping.\n\n        @param index Index of the loan\n\n        @return true if the approve was done successfully\n    */\n    function approveLoan(uint index) public returns(bool) {\n        Loan storage loan = loans[index];\n        require(loan.status == Status.initial);\n        loan.approbations[msg.sender] = true;\n        ApprovedBy(index, msg.sender);\n        return true;\n    }\n\n    /**\n        @dev Performs the lend of the RCN equivalent to the requested amount, and transforms the msg.sender in the new lender.\n\n        The loan must be previously approved by the borrower; before calling this function, the lender candidate must \n        call the \"approve\" function on the RCN Token, specifying an amount sufficient enough to pay the equivalent of\n        the requested amount, and the cosigner fee.\n        \n        @param index Index of the loan\n        @param oracleData Data required by the oracle to return the rate, the content of this field must be provided\n            by the url exposed in the url() method of the oracle.\n        @param cosigner Address of the cosigner, 0x0 for lending without cosigner.\n        @param cosignerData Data required by the cosigner to process the request.\n\n        @return true if the lend was done successfully\n    */\n    function lend(uint index, bytes oracleData, Cosigner cosigner, bytes cosignerData) public returns (bool) {\n        Loan storage loan = loans[index];\n\n        require(loan.status == Status.initial);\n        require(isApproved(index));\n        require(block.timestamp <= loan.expirationRequest);\n\n        loan.lender = msg.sender;\n        loan.dueTime = safeAdd(block.timestamp, loan.duesIn);\n        loan.interestTimestamp = block.timestamp;\n        loan.status = Status.lent;\n        \n        if (loan.cancelableAt > 0)\n            internalAddInterest(loan, safeAdd(block.timestamp, loan.cancelableAt));\n\n        uint256 rate = getRate(loan, oracleData);\n\n        if (cosigner != address(0)) {\n            // The cosigner it's temporary set to the next address (cosigner + 2), it's expected that the cosigner will\n            // call the method \"cosign\" to accept the conditions; that method also sets the cosigner to the right\n            // address. If that does not happen, the transaction fails.\n            loan.cosigner = address(uint256(cosigner) + 2);\n            require(cosigner.requestCosign(this, index, cosignerData, oracleData));\n            require(loan.cosigner == address(cosigner));\n        }\n        \n        require(rcn.transferFrom(msg.sender, loan.borrower, safeMult(loan.amount, rate)));\n        \n        // ERC721, create new loan and transfer it to the lender\n        Transfer(0x0, loan.lender, index);\n        activeLoans += 1;\n        lendersBalance[loan.lender] += 1;\n        Lent(index, loan.lender, cosigner);\n\n        return true;\n    }\n\n    /**\n        @dev The cosigner must call this method to accept the conditions of a loan, this method pays the cosigner his fee\n\n        @param index Index of the loan\n        @param cost Fee set by the cosigner\n\n        @return true If the cosign was successfull\n    */\n    function cosign(uint index, uint256 cost) external returns (bool) {\n        Loan storage loan = loans[index];\n        require(loan.status == Status.lent && (loan.dueTime - loan.duesIn) == block.timestamp);\n        require(loan.cosigner != address(0));\n        require(loan.cosigner == address(uint256(msg.sender) + 2));\n        loan.cosigner = msg.sender;\n        require(rcn.transferFrom(loan.lender, msg.sender, cost));\n        return true;\n    }\n\n    /**\n        @dev Destroys a loan, the borrower could call this method if they performed an accidental or regretted \n        \"approve\" of the loan, this method only works for them if the loan is in \"pending\" status.\n\n        The lender can call this method at any moment, in case of a loan with status \"lent\" the lender is pardoning \n        the debt. \n\n        @param index Index of the loan\n\n        @return true if the destroy was done successfully\n    */\n    function destroy(uint index) public returns (bool) {\n        Loan storage loan = loans[index];\n        require(loan.status != Status.destroyed);\n        require(msg.sender == loan.lender || (msg.sender == loan.borrower && loan.status == Status.initial));\n        DestroyedBy(index, msg.sender);\n\n        // ERC721, remove loan from circulation\n        if (loan.status != Status.initial) {\n            lendersBalance[loan.lender] -= 1;\n            activeLoans -= 1;\n            Transfer(loan.lender, 0x0, index);\n        }\n\n        loan.status = Status.destroyed;\n        return true;\n    }\n\n    /**\n        @dev Transfers a loan to a different lender, the caller must be the current lender or previously being\n        approved with the method \"approveTransfer\"; only loans with the Status.lent status can be transfered.\n\n        @param index Index of the loan\n        @param to New lender\n\n        @return true if the transfer was done successfully\n    */\n    function transfer(address to, uint256 index) public returns (bool) {\n        Loan storage loan = loans[index];\n        \n        require(loan.status != Status.destroyed && loan.status != Status.paid);\n        require(msg.sender == loan.lender || msg.sender == loan.approvedTransfer);\n        require(to != address(0));\n        loan.lender = to;\n        loan.approvedTransfer = address(0);\n\n        // ERC721, transfer loan to another address\n        lendersBalance[msg.sender] -= 1;\n        lendersBalance[to] += 1;\n        Transfer(loan.lender, to, index);\n\n        return true;\n    }\n\n    /**\n        @dev ERC721 method, transfers the loan to the msg.sender, the msg.sender must be approved using the \n        \"approve\" method.\n\n        @return true if the transfer was successfull\n    */\n    function takeOwnership(uint256 _index) public returns (bool) {\n        return transfer(msg.sender, _index);\n    }\n\n    /**\n        @dev Approves the transfer of a given loan in the name of the lender, the behavior of this function is similar to\n        \"approve\" in the ERC20 standard, but only one approved address is allowed at a time.\n\n        The same method can be called passing 0x0 as parameter \"to\" to erase a previously approved address.\n\n        @param to Address allowed to transfer the loan or 0x0 to delete\n        @param index Index of the loan\n\n        @return true if the approve was done successfully\n    */\n    function approve(address to, uint256 index) public returns (bool) {\n        Loan storage loan = loans[index];\n        require(msg.sender == loan.lender);\n        loan.approvedTransfer = to;\n        Approval(msg.sender, to, index);\n        return true;\n    }\n\n    /**\n        @dev Returns the pending amount to complete de payment of the loan, keep in mind that this number increases \n        every second.\n\n        @param index Index of the loan\n\n        @return Aprox pending payment amount\n    */\n    function getPendingAmount(uint index) public constant returns (uint256) {\n        Loan storage loan = loans[index];\n        addInterest(index);\n        return getRawPendingAmount(loan);\n    }\n\n    function getRawPendingAmount(Loan loan) internal returns (uint256) {\n        return safeSubtract(safeAdd(safeAdd(loan.amount, loan.interest), loan.punitoryInterest), loan.paid);\n    }\n\n    /**\n        @dev Calculates the interest of a given amount, interest rate and delta time.\n\n        @param timeDelta Elapsed time\n        @param interestRate Interest rate expressed as the denominator of 10 000 000.\n        @param amount Amount to apply interest\n\n        @return realDelta The real timeDelta applied\n        @return interest The interest gained in the realDelta time\n    */\n    function calculateInterest(uint256 timeDelta, uint256 interestRate, uint256 amount) public constant returns (uint256 realDelta, uint256 interest) {\n        if (amount == 0) {\n            interest = 0;\n            realDelta = timeDelta;\n        } else {\n            interest = safeMult(safeMult(100000, amount), timeDelta) / interestRate;\n            realDelta = safeMult(interest, interestRate) / (amount * 100000);\n        }\n    }\n\n    /**\n        @dev Computes loan interest\n\n        Computes the punitory and non-punitory interest of a given loan and only applies the change.\n        \n        @param loan Loan to compute interest\n        @param timestamp Target absolute unix time to calculate interest.\n    */\n    function internalAddInterest(Loan storage loan, uint256 timestamp) internal {\n        if (timestamp > loan.interestTimestamp) {\n            uint256 newInterest = loan.interest;\n            uint256 newPunitoryInterest = loan.punitoryInterest;\n\n            uint256 newTimestamp;\n            uint256 realDelta;\n            uint256 calculatedInterest;\n\n            uint256 deltaTime;\n            uint256 pending;\n\n            uint256 endNonPunitory = min(timestamp, loan.dueTime);\n            if (endNonPunitory > loan.interestTimestamp) {\n                deltaTime = endNonPunitory - loan.interestTimestamp;\n\n                if (loan.paid < loan.amount) {\n                    pending = loan.amount - loan.paid;\n                } else {\n                    pending = 0;\n                }\n\n                (realDelta, calculatedInterest) = calculateInterest(deltaTime, loan.interestRate, pending);\n                newInterest = safeAdd(calculatedInterest, newInterest);\n                newTimestamp = loan.interestTimestamp + realDelta;\n            }\n\n            if (timestamp > loan.dueTime) {\n                uint256 startPunitory = max(loan.dueTime, loan.interestTimestamp);\n                deltaTime = timestamp - startPunitory;\n\n                uint256 debt = safeAdd(loan.amount, newInterest);\n                pending = min(debt, safeSubtract(safeAdd(debt, newPunitoryInterest), loan.paid));\n\n                (realDelta, calculatedInterest) = calculateInterest(deltaTime, loan.interestRatePunitory, pending);\n                newPunitoryInterest = safeAdd(newPunitoryInterest, calculatedInterest);\n                newTimestamp = startPunitory + realDelta;\n            }\n            \n            if (newInterest != loan.interest || newPunitoryInterest != loan.punitoryInterest) {\n                loan.interestTimestamp = newTimestamp;\n                loan.interest = newInterest;\n                loan.punitoryInterest = newPunitoryInterest;\n            }\n        }\n    }\n\n    /**\n        @dev Computes loan interest only up to current unix time\n\n        @param timestamp Target absolute unix time to calculate interest.\n    */\n    function addInterestUpTo(Loan storage loan, uint256 timestamp) internal {\n        require(loan.status == Status.lent);\n        if (timestamp <= block.timestamp) {\n            internalAddInterest(loan, timestamp);\n        }\n    }\n\n    /**\n        @dev Updates the loan accumulated interests up to the current Unix time.\n        \n        @param index Index of the loan\n    */\n    function addInterest(uint index) public {\n        Loan storage loan = loans[index];\n        addInterestUpTo(loan, block.timestamp);\n    }\n    \n    /**\n        @dev Pay loan\n\n        Realizes a payment of a given Loan, before performing the payment the accumulated\n        interest is computed and added to the total pending amount.\n\n        Before calling this function, the msg.sender must call the \"approve\" function on the RCN Token, specifying an amount\n        sufficient enough to pay the equivalent of the desired payment and the oracle fee.\n\n        Because it is difficult or even impossible to know in advance how much RCN are going to be spent on the\n        transaction*, we recommend performing the \"approve\" using an amount 5% superior to the wallet estimated\n        spending. If the RCN spent results to be less, the extra tokens are never debited from the msg.sender.\n\n        * The RCN rate can fluctuate on the same block, and it is impossible to know in advance the exact time of the\n        confirmation of the transaction. \n\n        If the paid pending amount equals zero, the loan changes status to \"paid\" and it is considered closed.\n\n        @param index Index of the loan\n        @param _amount Amount to pay, specified in the loan currency; or in RCN if the loan has no oracle\n        @param _from The identity of the payer\n        @param oracleData Data required by the oracle to return the rate, the content of this field must be provided\n            by the url exposed in the url() method of the oracle.\n            \n        @return true if the payment was executed successfully\n    */\n    function pay(uint index, uint256 _amount, address _from, bytes oracleData) public returns (bool) {\n        Loan storage loan = loans[index];\n\n        require(loan.status == Status.lent);\n        addInterest(index);\n        uint256 toPay = min(getPendingAmount(index), _amount);\n        PartialPayment(index, msg.sender, _from, toPay);\n\n        loan.paid = safeAdd(loan.paid, toPay);\n\n        if (getRawPendingAmount(loan) == 0) {\n            TotalPayment(index);\n            loan.status = Status.paid;\n\n            // ERC721, remove loan from circulation\n            lendersBalance[loan.lender] -= 1;\n            activeLoans -= 1;\n            Transfer(loan.lender, 0x0, index);\n        }\n\n        uint256 rate = getRate(loan, oracleData);\n        uint256 transferValue = safeMult(toPay, rate);\n        lockTokens(rcn, transferValue);\n        require(rcn.transferFrom(msg.sender, this, transferValue));\n        loan.lenderBalance = safeAdd(transferValue, loan.lenderBalance);\n\n        return true;\n    }\n\n    /**\n        @dev Retrieves the rate corresponding of the loan oracle, if the loan has no oracle the rate is 1\n\n        @param loan The loan with the cosigner\n        @param data Data required by the oracle\n\n        @return The rate of the oracle\n    */\n    function getRate(Loan loan, bytes data) internal returns (uint256) {\n        if (loan.oracle == address(0)) {\n            return 1;\n        } else {\n            return loan.oracle.getRate(loan.currency, data);\n        }\n    }\n\n    /**\n        @dev Withdraw lender funds\n\n        When a loan is paid, the funds are not transferred automatically to the lender, the funds are stored on the\n        engine contract, and the lender must call this function specifying the amount desired to transfer and the \n        destination.\n\n        This behavior is defined to allow the temporary transfer of the loan to a smart contract, without worrying that\n        the contract will receive tokens that are not traceable; and it allows the development of decentralized \n        autonomous organizations.\n\n        @param index Index of the loan\n        @param to Destination of the wiwthdraw funds\n        @param amount Amount to withdraw, in RCN\n\n        @return true if the withdraw was executed successfully\n    */\n    function withdrawal(uint index, address to, uint256 amount) public returns (bool) {\n        Loan storage loan = loans[index];\n        require(msg.sender == loan.lender);\n        loan.lenderBalance = safeSubtract(loan.lenderBalance, amount);\n        require(rcn.transfer(to, amount));\n        unlockTokens(rcn, amount);\n        return true;\n    }\n\n    function withdrawalRange(uint256 fromIndex, uint256 toIndex, address to) public returns (uint256) {\n        uint256 loanId;\n        uint256 totalWithdraw = 0;\n\n        for (loanId = fromIndex; loanId <= toIndex; loanId++) {\n            Loan storage loan = loans[loanId];\n            if (loan.lender == msg.sender) {\n                totalWithdraw += loan.lenderBalance;\n                loan.lenderBalance = 0;\n            }\n        }\n\n        require(rcn.transfer(to, totalWithdraw));\n        unlockTokens(rcn, totalWithdraw);\n        \n        return totalWithdraw;\n    }\n\n    function withdrawalList(uint256[] memory loanIds, address to) public returns (uint256) {\n        uint256 inputId;\n        uint256 totalWithdraw = 0;\n\n        for (inputId = 0; inputId < loanIds.length; inputId++) {\n            Loan storage loan = loans[loanIds[inputId]];\n            if (loan.lender == msg.sender) {\n                totalWithdraw += loan.lenderBalance;\n                loan.lenderBalance = 0;\n            }\n        }\n\n        require(rcn.transfer(to, totalWithdraw));\n        unlockTokens(rcn, totalWithdraw);\n\n        return totalWithdraw;\n    }\n\n    /**\n        @dev Deprecates the engine, locks the creation of new loans.\n    */\n    function setDeprecated(bool _deprecated) public onlyOwner {\n        deprecated = _deprecated;\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinfabrik-RCN Network Smart Contract Audit/rcn-network-3ded36151ad55543d16c354e70161852de4061d0/contracts/NanoLoanEngine.sol",
        "vulnerability": "Assertion Failure",
        "check": "FP",
        "response": "Answer: No\nReason: There are no explicit assertions (using `assert`) in the provided code that could lead to an \"Assertion Failure\" vulnerability."
    },
    {
        "code_segment": "contract NanoLoanEngine is ERC721, Engine, Ownable, TokenLockable {\n    uint256 public constant VERSION = 202;\n    string public constant VERSION_NAME = \"Basalt\";\n\n    uint256 private activeLoans = 0;\n    mapping(address => uint256) private lendersBalance;\n\n    function name() constant returns (string _name) {\n        _name = \"RCN - Nano loan engine - Basalt 202\";\n    }\n\n    function symbol() constant returns (string _symbol) {\n        _symbol = \"RCN-NLE-202\";\n    }\n\n    function totalSupply() constant returns (uint _totalSupply) {\n        _totalSupply = activeLoans;\n    }\n\n    function balanceOf(address _owner) constant returns (uint _balance) {\n        _balance = lendersBalance[_owner];\n    }\n\n    function tokenOfOwnerByIndex(address _owner, uint256 _index) constant returns (uint tokenId) {\n        uint256 tokenCount = balanceOf(_owner);\n\n        if (tokenCount == 0 || _index >= tokenCount) {\n            // Fail transaction\n            revert();\n        } else {\n            uint256 totalLoans = totalSupply();\n            uint256 resultIndex = 0;\n\n            uint256 loanId;\n            // SWC-128-DoS With Block Gas Limit: L46\n            for (loanId = 0; loanId <= totalLoans; loanId++) {\n                if (loans[loanId].lender == _owner && loans[loanId].status == Status.lent) {\n                    if (resultIndex == _index) {\n                        return loanId;\n                    }\n                    resultIndex++;\n                }\n            }\n\n            revert();\n        }\n    }\n\n    function tokensOfOwner(address _owner) external constant returns(uint256[] ownerTokens) {\n        uint256 tokenCount = balanceOf(_owner);\n\n        if (tokenCount == 0) {\n            // Return an empty array\n            return new uint256[](0);\n        } else {\n            uint256[] memory result = new uint256[](tokenCount);\n            uint256 totalLoans = totalSupply();\n            uint256 resultIndex = 0;\n\n            uint256 loanId;\n\n            for (loanId = 0; loanId <= totalLoans; loanId++) {\n                if (loans[loanId].lender == _owner && loans[loanId].status == Status.lent) {\n                    result[resultIndex] = loanId;\n                    resultIndex++;\n                }\n            }\n\n            return result;\n        }\n    }\n    \n    Token public rcn;\n    bool public deprecated;\n\n    event CreatedLoan(uint _index, address _borrower, address _creator);\n    event ApprovedBy(uint _index, address _address);\n    event Lent(uint _index, address _lender, address _cosigner);\n    event DestroyedBy(uint _index, address _address);\n    event PartialPayment(uint _index, address _sender, address _from, uint256 _amount);\n    event TotalPayment(uint _index);\n\n    function NanoLoanEngine(Token _rcn) public {\n        owner = msg.sender;\n        rcn = _rcn;\n    }\n\n    struct Loan {\n        Status status;\n        Oracle oracle;\n\n        address borrower;\n        address lender;\n        address creator;\n        address cosigner;\n        \n        uint256 amount;\n        uint256 interest;\n        uint256 punitoryInterest;\n        uint256 interestTimestamp;\n        uint256 paid;\n        uint256 interestRate;\n        uint256 interestRatePunitory;\n        uint256 dueTime;\n        uint256 duesIn;\n\n        bytes32 currency;\n        uint256 cancelableAt;\n        uint256 lenderBalance;\n\n        address approvedTransfer;\n        uint256 expirationRequest;\n\n        mapping(address => bool) approbations;\n    }\n\n    Loan[] private loans;\n\n    /**\n        @dev Creates a loan request, the loan can be generated with any borrower, cosigner, and conditions; if the \n        cosigner and borrower agree they must call the \"approve\" function.\n\n        The creator of the loan is the caller of this function; this is useful to track which wallet created the loan.\n\n        @param _oracleContract Address of the Oracle contract, if the loan does not use any oracle, this field should be 0x0.\n        @param _borrower Address of the borrower\n        @param _currency The currency to use with the oracle, the currency code is generated with the following formula,\n            keccak256(ticker,decimals).\n        @param _amount The requested amount; currency and unit are defined by the Oracle, if there is no Oracle present\n            the currency is RCN, and the unit is wei.\n        @param _interestRate The non-punitory interest rate by second, defined as a denominator of 10 000 000.\n        @param _interestRatePunitory The punitory interest rate by second, defined as a denominator of 10 000 000.\n            Ej: interestRate 11108571428571 = 28% Anual interest\n        @param _duesIn The time in seconds that the borrower has in order to pay the debt after the lender lends the money.\n        @param _cancelableAt Delta in seconds specifying how much interest should be added in advance, if the borrower pays \n        entirely or partially the loan before this term, no extra interest will be deducted.\n        @param _expirationRequest Timestamp of when the loan request expires, if the loan is not filled before this date, \n            the request is no longer valid.\n    */\n    function createLoan(Oracle _oracleContract, address _borrower, bytes32 _currency, uint256 _amount, uint256 _interestRate,\n        uint256 _interestRatePunitory, uint256 _duesIn, uint256 _cancelableAt, uint256 _expirationRequest) returns (uint256) {\n\n        require(!deprecated);\n        require(_cancelableAt <= _duesIn);\n        require(_oracleContract != address(0) || _currency == 0x0);\n        require(_borrower != address(0));\n        require(_amount != 0);\n        require(_interestRatePunitory != 0);\n        require(_interestRate != 0);\n        require(_expirationRequest > block.timestamp);\n\n        var loan = Loan(Status.initial, _oracleContract, _borrower, 0x0, msg.sender, 0x0, _amount, 0, 0, 0, 0, _interestRate,\n            _interestRatePunitory, 0, _duesIn, _currency, _cancelableAt, 0, 0x0, _expirationRequest);\n        uint index = loans.push(loan) - 1;\n        CreatedLoan(index, _borrower, msg.sender);\n\n        if (msg.sender == _borrower) {\n            approveLoan(index);\n        }\n\n        return index;\n    }\n    \n    function ownerOf(uint256 index) constant returns (address owner) { owner = loans[index].lender; }\n    function getTotalLoans() constant returns (uint256) { return loans.length; }\n    function getOracle(uint index) constant returns (Oracle) { return loans[index].oracle; }\n    function getBorrower(uint index) constant returns (address) { return loans[index].borrower; }\n    function getCosigner(uint index) constant returns (address) { return loans[index].cosigner; }\n    function getCreator(uint index) constant returns (address) { return loans[index].creator; }\n    function getAmount(uint index) constant returns (uint256) { return loans[index].amount; }\n    function getPunitoryInterest(uint index) constant returns (uint256) { return loans[index].punitoryInterest; }\n    function getInterestTimestamp(uint index) constant returns (uint256) { return loans[index].interestTimestamp; }\n    function getPaid(uint index) constant returns (uint256) { return loans[index].paid; }\n    function getInterestRate(uint index) constant returns (uint256) { return loans[index].interestRate; }\n    function getInterestRatePunitory(uint index) constant returns (uint256) { return loans[index].interestRatePunitory; }\n    function getDueTime(uint index) constant returns (uint256) { return loans[index].dueTime; }\n    function getDuesIn(uint index) constant returns (uint256) { return loans[index].duesIn; }\n    function getCancelableAt(uint index) constant returns (uint256) { return loans[index].cancelableAt; }\n    function getApprobation(uint index, address _address) constant returns (bool) { return loans[index].approbations[_address]; }\n    function getStatus(uint index) constant returns (Status) { return loans[index].status; }\n    function getLenderBalance(uint index) constant returns (uint256) { return loans[index].lenderBalance; }\n    function getApprovedTransfer(uint index) constant returns (address) {return loans[index].approvedTransfer; }\n    function getCurrency(uint index) constant returns (bytes32) { return loans[index].currency; }\n    function getExpirationRequest(uint index) constant returns (uint256) { return loans[index].expirationRequest; }\n    function getInterest(uint index) constant returns (uint256) { return loans[index].interest; }\n\n    /**\n        @param index Index of the loan\n\n        @return true if the loan has been approved by the borrower and cosigner.\n    */\n    function isApproved(uint index) constant returns (bool) {\n        Loan storage loan = loans[index];\n        return loan.approbations[loan.borrower];\n    }\n\n    /**\n        @dev Called by the members of the loan to show that they agree with the terms of the loan; the borrower\n        must call this method before any lender could call the method \"lend\".\n            \n        Any address can call this method to be added to the \"approbations\" mapping.\n\n        @param index Index of the loan\n\n        @return true if the approve was done successfully\n    */\n    function approveLoan(uint index) public returns(bool) {\n        Loan storage loan = loans[index];\n        require(loan.status == Status.initial);\n        loan.approbations[msg.sender] = true;\n        ApprovedBy(index, msg.sender);\n        return true;\n    }\n\n    /**\n        @dev Performs the lend of the RCN equivalent to the requested amount, and transforms the msg.sender in the new lender.\n\n        The loan must be previously approved by the borrower; before calling this function, the lender candidate must \n        call the \"approve\" function on the RCN Token, specifying an amount sufficient enough to pay the equivalent of\n        the requested amount, and the cosigner fee.\n        \n        @param index Index of the loan\n        @param oracleData Data required by the oracle to return the rate, the content of this field must be provided\n            by the url exposed in the url() method of the oracle.\n        @param cosigner Address of the cosigner, 0x0 for lending without cosigner.\n        @param cosignerData Data required by the cosigner to process the request.\n\n        @return true if the lend was done successfully\n    */\n    function lend(uint index, bytes oracleData, Cosigner cosigner, bytes cosignerData) public returns (bool) {\n        Loan storage loan = loans[index];\n\n        require(loan.status == Status.initial);\n        require(isApproved(index));\n        require(block.timestamp <= loan.expirationRequest);\n\n        loan.lender = msg.sender;\n        loan.dueTime = safeAdd(block.timestamp, loan.duesIn);\n        loan.interestTimestamp = block.timestamp;\n        loan.status = Status.lent;\n        \n        if (loan.cancelableAt > 0)\n            internalAddInterest(loan, safeAdd(block.timestamp, loan.cancelableAt));\n\n        uint256 rate = getRate(loan, oracleData);\n\n        if (cosigner != address(0)) {\n            // The cosigner it's temporary set to the next address (cosigner + 2), it's expected that the cosigner will\n            // call the method \"cosign\" to accept the conditions; that method also sets the cosigner to the right\n            // address. If that does not happen, the transaction fails.\n            loan.cosigner = address(uint256(cosigner) + 2);\n            require(cosigner.requestCosign(this, index, cosignerData, oracleData));\n            require(loan.cosigner == address(cosigner));\n        }\n        \n        require(rcn.transferFrom(msg.sender, loan.borrower, safeMult(loan.amount, rate)));\n        \n        // ERC721, create new loan and transfer it to the lender\n        Transfer(0x0, loan.lender, index);\n        activeLoans += 1;\n        lendersBalance[loan.lender] += 1;\n        Lent(index, loan.lender, cosigner);\n\n        return true;\n    }\n\n    /**\n        @dev The cosigner must call this method to accept the conditions of a loan, this method pays the cosigner his fee\n\n        @param index Index of the loan\n        @param cost Fee set by the cosigner\n\n        @return true If the cosign was successfull\n    */\n    function cosign(uint index, uint256 cost) external returns (bool) {\n        Loan storage loan = loans[index];\n        require(loan.status == Status.lent && (loan.dueTime - loan.duesIn) == block.timestamp);\n        require(loan.cosigner != address(0));\n        require(loan.cosigner == address(uint256(msg.sender) + 2));\n        loan.cosigner = msg.sender;\n        require(rcn.transferFrom(loan.lender, msg.sender, cost));\n        return true;\n    }\n\n    /**\n        @dev Destroys a loan, the borrower could call this method if they performed an accidental or regretted \n        \"approve\" of the loan, this method only works for them if the loan is in \"pending\" status.\n\n        The lender can call this method at any moment, in case of a loan with status \"lent\" the lender is pardoning \n        the debt. \n\n        @param index Index of the loan\n\n        @return true if the destroy was done successfully\n    */\n    function destroy(uint index) public returns (bool) {\n        Loan storage loan = loans[index];\n        require(loan.status != Status.destroyed);\n        require(msg.sender == loan.lender || (msg.sender == loan.borrower && loan.status == Status.initial));\n        DestroyedBy(index, msg.sender);\n\n        // ERC721, remove loan from circulation\n        if (loan.status != Status.initial) {\n            lendersBalance[loan.lender] -= 1;\n            activeLoans -= 1;\n            Transfer(loan.lender, 0x0, index);\n        }\n\n        loan.status = Status.destroyed;\n        return true;\n    }\n\n    /**\n        @dev Transfers a loan to a different lender, the caller must be the current lender or previously being\n        approved with the method \"approveTransfer\"; only loans with the Status.lent status can be transfered.\n\n        @param index Index of the loan\n        @param to New lender\n\n        @return true if the transfer was done successfully\n    */\n    function transfer(address to, uint256 index) public returns (bool) {\n        Loan storage loan = loans[index];\n        \n        require(loan.status != Status.destroyed && loan.status != Status.paid);\n        require(msg.sender == loan.lender || msg.sender == loan.approvedTransfer);\n        require(to != address(0));\n        loan.lender = to;\n        loan.approvedTransfer = address(0);\n\n        // ERC721, transfer loan to another address\n        lendersBalance[msg.sender] -= 1;\n        lendersBalance[to] += 1;\n        Transfer(loan.lender, to, index);\n\n        return true;\n    }\n\n    /**\n        @dev ERC721 method, transfers the loan to the msg.sender, the msg.sender must be approved using the \n        \"approve\" method.\n\n        @return true if the transfer was successfull\n    */\n    function takeOwnership(uint256 _index) public returns (bool) {\n        return transfer(msg.sender, _index);\n    }\n\n    /**\n        @dev Approves the transfer of a given loan in the name of the lender, the behavior of this function is similar to\n        \"approve\" in the ERC20 standard, but only one approved address is allowed at a time.\n\n        The same method can be called passing 0x0 as parameter \"to\" to erase a previously approved address.\n\n        @param to Address allowed to transfer the loan or 0x0 to delete\n        @param index Index of the loan\n\n        @return true if the approve was done successfully\n    */\n    function approve(address to, uint256 index) public returns (bool) {\n        Loan storage loan = loans[index];\n        require(msg.sender == loan.lender);\n        loan.approvedTransfer = to;\n        Approval(msg.sender, to, index);\n        return true;\n    }\n\n    /**\n        @dev Returns the pending amount to complete de payment of the loan, keep in mind that this number increases \n        every second.\n\n        @param index Index of the loan\n\n        @return Aprox pending payment amount\n    */\n    function getPendingAmount(uint index) public constant returns (uint256) {\n        Loan storage loan = loans[index];\n        addInterest(index);\n        return getRawPendingAmount(loan);\n    }\n\n    function getRawPendingAmount(Loan loan) internal returns (uint256) {\n        return safeSubtract(safeAdd(safeAdd(loan.amount, loan.interest), loan.punitoryInterest), loan.paid);\n    }\n\n    /**\n        @dev Calculates the interest of a given amount, interest rate and delta time.\n\n        @param timeDelta Elapsed time\n        @param interestRate Interest rate expressed as the denominator of 10 000 000.\n        @param amount Amount to apply interest\n\n        @return realDelta The real timeDelta applied\n        @return interest The interest gained in the realDelta time\n    */\n    function calculateInterest(uint256 timeDelta, uint256 interestRate, uint256 amount) public constant returns (uint256 realDelta, uint256 interest) {\n        if (amount == 0) {\n            interest = 0;\n            realDelta = timeDelta;\n        } else {\n            interest = safeMult(safeMult(100000, amount), timeDelta) / interestRate;\n            realDelta = safeMult(interest, interestRate) / (amount * 100000);\n        }\n    }\n\n    /**\n        @dev Computes loan interest\n\n        Computes the punitory and non-punitory interest of a given loan and only applies the change.\n        \n        @param loan Loan to compute interest\n        @param timestamp Target absolute unix time to calculate interest.\n    */\n    function internalAddInterest(Loan storage loan, uint256 timestamp) internal {\n        if (timestamp > loan.interestTimestamp) {\n            uint256 newInterest = loan.interest;\n            uint256 newPunitoryInterest = loan.punitoryInterest;\n\n            uint256 newTimestamp;\n            uint256 realDelta;\n            uint256 calculatedInterest;\n\n            uint256 deltaTime;\n            uint256 pending;\n\n            uint256 endNonPunitory = min(timestamp, loan.dueTime);\n            if (endNonPunitory > loan.interestTimestamp) {\n                deltaTime = endNonPunitory - loan.interestTimestamp;\n\n                if (loan.paid < loan.amount) {\n                    pending = loan.amount - loan.paid;\n                } else {\n                    pending = 0;\n                }\n\n                (realDelta, calculatedInterest) = calculateInterest(deltaTime, loan.interestRate, pending);\n                newInterest = safeAdd(calculatedInterest, newInterest);\n                newTimestamp = loan.interestTimestamp + realDelta;\n            }\n\n            if (timestamp > loan.dueTime) {\n                uint256 startPunitory = max(loan.dueTime, loan.interestTimestamp);\n                deltaTime = timestamp - startPunitory;\n\n                uint256 debt = safeAdd(loan.amount, newInterest);\n                pending = min(debt, safeSubtract(safeAdd(debt, newPunitoryInterest), loan.paid));\n\n                (realDelta, calculatedInterest) = calculateInterest(deltaTime, loan.interestRatePunitory, pending);\n                newPunitoryInterest = safeAdd(newPunitoryInterest, calculatedInterest);\n                newTimestamp = startPunitory + realDelta;\n            }\n            \n            if (newInterest != loan.interest || newPunitoryInterest != loan.punitoryInterest) {\n                loan.interestTimestamp = newTimestamp;\n                loan.interest = newInterest;\n                loan.punitoryInterest = newPunitoryInterest;\n            }\n        }\n    }\n\n    /**\n        @dev Computes loan interest only up to current unix time\n\n        @param timestamp Target absolute unix time to calculate interest.\n    */\n    function addInterestUpTo(Loan storage loan, uint256 timestamp) internal {\n        require(loan.status == Status.lent);\n        if (timestamp <= block.timestamp) {\n            internalAddInterest(loan, timestamp);\n        }\n    }\n\n    /**\n        @dev Updates the loan accumulated interests up to the current Unix time.\n        \n        @param index Index of the loan\n    */\n    function addInterest(uint index) public {\n        Loan storage loan = loans[index];\n        addInterestUpTo(loan, block.timestamp);\n    }\n    \n    /**\n        @dev Pay loan\n\n        Realizes a payment of a given Loan, before performing the payment the accumulated\n        interest is computed and added to the total pending amount.\n\n        Before calling this function, the msg.sender must call the \"approve\" function on the RCN Token, specifying an amount\n        sufficient enough to pay the equivalent of the desired payment and the oracle fee.\n\n        Because it is difficult or even impossible to know in advance how much RCN are going to be spent on the\n        transaction*, we recommend performing the \"approve\" using an amount 5% superior to the wallet estimated\n        spending. If the RCN spent results to be less, the extra tokens are never debited from the msg.sender.\n\n        * The RCN rate can fluctuate on the same block, and it is impossible to know in advance the exact time of the\n        confirmation of the transaction. \n\n        If the paid pending amount equals zero, the loan changes status to \"paid\" and it is considered closed.\n\n        @param index Index of the loan\n        @param _amount Amount to pay, specified in the loan currency; or in RCN if the loan has no oracle\n        @param _from The identity of the payer\n        @param oracleData Data required by the oracle to return the rate, the content of this field must be provided\n            by the url exposed in the url() method of the oracle.\n            \n        @return true if the payment was executed successfully\n    */\n    function pay(uint index, uint256 _amount, address _from, bytes oracleData) public returns (bool) {\n        Loan storage loan = loans[index];\n\n        require(loan.status == Status.lent);\n        addInterest(index);\n        uint256 toPay = min(getPendingAmount(index), _amount);\n        PartialPayment(index, msg.sender, _from, toPay);\n\n        loan.paid = safeAdd(loan.paid, toPay);\n\n        if (getRawPendingAmount(loan) == 0) {\n            TotalPayment(index);\n            loan.status = Status.paid;\n\n            // ERC721, remove loan from circulation\n            lendersBalance[loan.lender] -= 1;\n            activeLoans -= 1;\n            Transfer(loan.lender, 0x0, index);\n        }\n\n        uint256 rate = getRate(loan, oracleData);\n        uint256 transferValue = safeMult(toPay, rate);\n        lockTokens(rcn, transferValue);\n        require(rcn.transferFrom(msg.sender, this, transferValue));\n        loan.lenderBalance = safeAdd(transferValue, loan.lenderBalance);\n\n        return true;\n    }\n\n    /**\n        @dev Retrieves the rate corresponding of the loan oracle, if the loan has no oracle the rate is 1\n\n        @param loan The loan with the cosigner\n        @param data Data required by the oracle\n\n        @return The rate of the oracle\n    */\n    function getRate(Loan loan, bytes data) internal returns (uint256) {\n        if (loan.oracle == address(0)) {\n            return 1;\n        } else {\n            return loan.oracle.getRate(loan.currency, data);\n        }\n    }\n\n    /**\n        @dev Withdraw lender funds\n\n        When a loan is paid, the funds are not transferred automatically to the lender, the funds are stored on the\n        engine contract, and the lender must call this function specifying the amount desired to transfer and the \n        destination.\n\n        This behavior is defined to allow the temporary transfer of the loan to a smart contract, without worrying that\n        the contract will receive tokens that are not traceable; and it allows the development of decentralized \n        autonomous organizations.\n\n        @param index Index of the loan\n        @param to Destination of the wiwthdraw funds\n        @param amount Amount to withdraw, in RCN\n\n        @return true if the withdraw was executed successfully\n    */\n    function withdrawal(uint index, address to, uint256 amount) public returns (bool) {\n        Loan storage loan = loans[index];\n        require(msg.sender == loan.lender);\n        loan.lenderBalance = safeSubtract(loan.lenderBalance, amount);\n        require(rcn.transfer(to, amount));\n        unlockTokens(rcn, amount);\n        return true;\n    }\n\n    function withdrawalRange(uint256 fromIndex, uint256 toIndex, address to) public returns (uint256) {\n        uint256 loanId;\n        uint256 totalWithdraw = 0;\n\n        for (loanId = fromIndex; loanId <= toIndex; loanId++) {\n            Loan storage loan = loans[loanId];\n            if (loan.lender == msg.sender) {\n                totalWithdraw += loan.lenderBalance;\n                loan.lenderBalance = 0;\n            }\n        }\n\n        require(rcn.transfer(to, totalWithdraw));\n        unlockTokens(rcn, totalWithdraw);\n        \n        return totalWithdraw;\n    }\n\n    function withdrawalList(uint256[] memory loanIds, address to) public returns (uint256) {\n        uint256 inputId;\n        uint256 totalWithdraw = 0;\n\n        for (inputId = 0; inputId < loanIds.length; inputId++) {\n            Loan storage loan = loans[loanIds[inputId]];\n            if (loan.lender == msg.sender) {\n                totalWithdraw += loan.lenderBalance;\n                loan.lenderBalance = 0;\n            }\n        }\n\n        require(rcn.transfer(to, totalWithdraw));\n        unlockTokens(rcn, totalWithdraw);\n\n        return totalWithdraw;\n    }\n\n    /**\n        @dev Deprecates the engine, locks the creation of new loans.\n    */\n    function setDeprecated(bool _deprecated) public onlyOwner {\n        deprecated = _deprecated;\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinfabrik-RCN Network Smart Contract Audit/rcn-network-3ded36151ad55543d16c354e70161852de4061d0/contracts/NanoLoanEngine.sol",
        "vulnerability": "Assertion Failure",
        "check": "FP",
        "response": "Answer: Yes\nDescription: The use of the assert statement directly or indirectly through functions that use assert can lead to \"Assertion Failure\" vulnerabilities and potential DoS scenarios, especially when assumptions are not adequately validated before assertion points. Additionally, the forward iteration through the `loanId` in the `tokenOfOwnerByIndex` function lacks adequate handling for cases with extensive loan counts, posing further assertion risks."
    },
    {
        "code_segment": "contract NanoLoanEngine is ERC721, Engine, Ownable, TokenLockable {\n    uint256 public constant VERSION = 202;\n    string public constant VERSION_NAME = \"Basalt\";\n\n    uint256 private activeLoans = 0;\n    mapping(address => uint256) private lendersBalance;\n\n    function name() constant returns (string _name) {\n        _name = \"RCN - Nano loan engine - Basalt 202\";\n    }\n\n    function symbol() constant returns (string _symbol) {\n        _symbol = \"RCN-NLE-202\";\n    }\n\n    function totalSupply() constant returns (uint _totalSupply) {\n        _totalSupply = activeLoans;\n    }\n\n    function balanceOf(address _owner) constant returns (uint _balance) {\n        _balance = lendersBalance[_owner];\n    }\n\n    function tokenOfOwnerByIndex(address _owner, uint256 _index) constant returns (uint tokenId) {\n        uint256 tokenCount = balanceOf(_owner);\n\n        if (tokenCount == 0 || _index >= tokenCount) {\n            // Fail transaction\n            revert();\n        } else {\n            uint256 totalLoans = totalSupply();\n            uint256 resultIndex = 0;\n\n            uint256 loanId;\n            // SWC-128-DoS With Block Gas Limit: L46\n            for (loanId = 0; loanId <= totalLoans; loanId++) {\n                if (loans[loanId].lender == _owner && loans[loanId].status == Status.lent) {\n                    if (resultIndex == _index) {\n                        return loanId;\n                    }\n                    resultIndex++;\n                }\n            }\n\n            revert();\n        }\n    }\n\n    function tokensOfOwner(address _owner) external constant returns(uint256[] ownerTokens) {\n        uint256 tokenCount = balanceOf(_owner);\n\n        if (tokenCount == 0) {\n            // Return an empty array\n            return new uint256[](0);\n        } else {\n            uint256[] memory result = new uint256[](tokenCount);\n            uint256 totalLoans = totalSupply();\n            uint256 resultIndex = 0;\n\n            uint256 loanId;\n\n            for (loanId = 0; loanId <= totalLoans; loanId++) {\n                if (loans[loanId].lender == _owner && loans[loanId].status == Status.lent) {\n                    result[resultIndex] = loanId;\n                    resultIndex++;\n                }\n            }\n\n            return result;\n        }\n    }\n    \n    Token public rcn;\n    bool public deprecated;\n\n    event CreatedLoan(uint _index, address _borrower, address _creator);\n    event ApprovedBy(uint _index, address _address);\n    event Lent(uint _index, address _lender, address _cosigner);\n    event DestroyedBy(uint _index, address _address);\n    event PartialPayment(uint _index, address _sender, address _from, uint256 _amount);\n    event TotalPayment(uint _index);\n\n    function NanoLoanEngine(Token _rcn) public {\n        owner = msg.sender;\n        rcn = _rcn;\n    }\n\n    struct Loan {\n        Status status;\n        Oracle oracle;\n\n        address borrower;\n        address lender;\n        address creator;\n        address cosigner;\n        \n        uint256 amount;\n        uint256 interest;\n        uint256 punitoryInterest;\n        uint256 interestTimestamp;\n        uint256 paid;\n        uint256 interestRate;\n        uint256 interestRatePunitory;\n        uint256 dueTime;\n        uint256 duesIn;\n\n        bytes32 currency;\n        uint256 cancelableAt;\n        uint256 lenderBalance;\n\n        address approvedTransfer;\n        uint256 expirationRequest;\n\n        mapping(address => bool) approbations;\n    }\n\n    Loan[] private loans;\n\n    /**\n        @dev Creates a loan request, the loan can be generated with any borrower, cosigner, and conditions; if the \n        cosigner and borrower agree they must call the \"approve\" function.\n\n        The creator of the loan is the caller of this function; this is useful to track which wallet created the loan.\n\n        @param _oracleContract Address of the Oracle contract, if the loan does not use any oracle, this field should be 0x0.\n        @param _borrower Address of the borrower\n        @param _currency The currency to use with the oracle, the currency code is generated with the following formula,\n            keccak256(ticker,decimals).\n        @param _amount The requested amount; currency and unit are defined by the Oracle, if there is no Oracle present\n            the currency is RCN, and the unit is wei.\n        @param _interestRate The non-punitory interest rate by second, defined as a denominator of 10 000 000.\n        @param _interestRatePunitory The punitory interest rate by second, defined as a denominator of 10 000 000.\n            Ej: interestRate 11108571428571 = 28% Anual interest\n        @param _duesIn The time in seconds that the borrower has in order to pay the debt after the lender lends the money.\n        @param _cancelableAt Delta in seconds specifying how much interest should be added in advance, if the borrower pays \n        entirely or partially the loan before this term, no extra interest will be deducted.\n        @param _expirationRequest Timestamp of when the loan request expires, if the loan is not filled before this date, \n            the request is no longer valid.\n    */\n    function createLoan(Oracle _oracleContract, address _borrower, bytes32 _currency, uint256 _amount, uint256 _interestRate,\n        uint256 _interestRatePunitory, uint256 _duesIn, uint256 _cancelableAt, uint256 _expirationRequest) returns (uint256) {\n\n        require(!deprecated);\n        require(_cancelableAt <= _duesIn);\n        require(_oracleContract != address(0) || _currency == 0x0);\n        require(_borrower != address(0));\n        require(_amount != 0);\n        require(_interestRatePunitory != 0);\n        require(_interestRate != 0);\n        require(_expirationRequest > block.timestamp);\n\n        var loan = Loan(Status.initial, _oracleContract, _borrower, 0x0, msg.sender, 0x0, _amount, 0, 0, 0, 0, _interestRate,\n            _interestRatePunitory, 0, _duesIn, _currency, _cancelableAt, 0, 0x0, _expirationRequest);\n        uint index = loans.push(loan) - 1;\n        CreatedLoan(index, _borrower, msg.sender);\n\n        if (msg.sender == _borrower) {\n            approveLoan(index);\n        }\n\n        return index;\n    }\n    \n    function ownerOf(uint256 index) constant returns (address owner) { owner = loans[index].lender; }\n    function getTotalLoans() constant returns (uint256) { return loans.length; }\n    function getOracle(uint index) constant returns (Oracle) { return loans[index].oracle; }\n    function getBorrower(uint index) constant returns (address) { return loans[index].borrower; }\n    function getCosigner(uint index) constant returns (address) { return loans[index].cosigner; }\n    function getCreator(uint index) constant returns (address) { return loans[index].creator; }\n    function getAmount(uint index) constant returns (uint256) { return loans[index].amount; }\n    function getPunitoryInterest(uint index) constant returns (uint256) { return loans[index].punitoryInterest; }\n    function getInterestTimestamp(uint index) constant returns (uint256) { return loans[index].interestTimestamp; }\n    function getPaid(uint index) constant returns (uint256) { return loans[index].paid; }\n    function getInterestRate(uint index) constant returns (uint256) { return loans[index].interestRate; }\n    function getInterestRatePunitory(uint index) constant returns (uint256) { return loans[index].interestRatePunitory; }\n    function getDueTime(uint index) constant returns (uint256) { return loans[index].dueTime; }\n    function getDuesIn(uint index) constant returns (uint256) { return loans[index].duesIn; }\n    function getCancelableAt(uint index) constant returns (uint256) { return loans[index].cancelableAt; }\n    function getApprobation(uint index, address _address) constant returns (bool) { return loans[index].approbations[_address]; }\n    function getStatus(uint index) constant returns (Status) { return loans[index].status; }\n    function getLenderBalance(uint index) constant returns (uint256) { return loans[index].lenderBalance; }\n    function getApprovedTransfer(uint index) constant returns (address) {return loans[index].approvedTransfer; }\n    function getCurrency(uint index) constant returns (bytes32) { return loans[index].currency; }\n    function getExpirationRequest(uint index) constant returns (uint256) { return loans[index].expirationRequest; }\n    function getInterest(uint index) constant returns (uint256) { return loans[index].interest; }\n\n    /**\n        @param index Index of the loan\n\n        @return true if the loan has been approved by the borrower and cosigner.\n    */\n    function isApproved(uint index) constant returns (bool) {\n        Loan storage loan = loans[index];\n        return loan.approbations[loan.borrower];\n    }\n\n    /**\n        @dev Called by the members of the loan to show that they agree with the terms of the loan; the borrower\n        must call this method before any lender could call the method \"lend\".\n            \n        Any address can call this method to be added to the \"approbations\" mapping.\n\n        @param index Index of the loan\n\n        @return true if the approve was done successfully\n    */\n    function approveLoan(uint index) public returns(bool) {\n        Loan storage loan = loans[index];\n        require(loan.status == Status.initial);\n        loan.approbations[msg.sender] = true;\n        ApprovedBy(index, msg.sender);\n        return true;\n    }\n\n    /**\n        @dev Performs the lend of the RCN equivalent to the requested amount, and transforms the msg.sender in the new lender.\n\n        The loan must be previously approved by the borrower; before calling this function, the lender candidate must \n        call the \"approve\" function on the RCN Token, specifying an amount sufficient enough to pay the equivalent of\n        the requested amount, and the cosigner fee.\n        \n        @param index Index of the loan\n        @param oracleData Data required by the oracle to return the rate, the content of this field must be provided\n            by the url exposed in the url() method of the oracle.\n        @param cosigner Address of the cosigner, 0x0 for lending without cosigner.\n        @param cosignerData Data required by the cosigner to process the request.\n\n        @return true if the lend was done successfully\n    */\n    function lend(uint index, bytes oracleData, Cosigner cosigner, bytes cosignerData) public returns (bool) {\n        Loan storage loan = loans[index];\n\n        require(loan.status == Status.initial);\n        require(isApproved(index));\n        require(block.timestamp <= loan.expirationRequest);\n\n        loan.lender = msg.sender;\n        loan.dueTime = safeAdd(block.timestamp, loan.duesIn);\n        loan.interestTimestamp = block.timestamp;\n        loan.status = Status.lent;\n        \n        if (loan.cancelableAt > 0)\n            internalAddInterest(loan, safeAdd(block.timestamp, loan.cancelableAt));\n\n        uint256 rate = getRate(loan, oracleData);\n\n        if (cosigner != address(0)) {\n            // The cosigner it's temporary set to the next address (cosigner + 2), it's expected that the cosigner will\n            // call the method \"cosign\" to accept the conditions; that method also sets the cosigner to the right\n            // address. If that does not happen, the transaction fails.\n            loan.cosigner = address(uint256(cosigner) + 2);\n            require(cosigner.requestCosign(this, index, cosignerData, oracleData));\n            require(loan.cosigner == address(cosigner));\n        }\n        \n        require(rcn.transferFrom(msg.sender, loan.borrower, safeMult(loan.amount, rate)));\n        \n        // ERC721, create new loan and transfer it to the lender\n        Transfer(0x0, loan.lender, index);\n        activeLoans += 1;\n        lendersBalance[loan.lender] += 1;\n        Lent(index, loan.lender, cosigner);\n\n        return true;\n    }\n\n    /**\n        @dev The cosigner must call this method to accept the conditions of a loan, this method pays the cosigner his fee\n\n        @param index Index of the loan\n        @param cost Fee set by the cosigner\n\n        @return true If the cosign was successfull\n    */\n    function cosign(uint index, uint256 cost) external returns (bool) {\n        Loan storage loan = loans[index];\n        require(loan.status == Status.lent && (loan.dueTime - loan.duesIn) == block.timestamp);\n        require(loan.cosigner != address(0));\n        require(loan.cosigner == address(uint256(msg.sender) + 2));\n        loan.cosigner = msg.sender;\n        require(rcn.transferFrom(loan.lender, msg.sender, cost));\n        return true;\n    }\n\n    /**\n        @dev Destroys a loan, the borrower could call this method if they performed an accidental or regretted \n        \"approve\" of the loan, this method only works for them if the loan is in \"pending\" status.\n\n        The lender can call this method at any moment, in case of a loan with status \"lent\" the lender is pardoning \n        the debt. \n\n        @param index Index of the loan\n\n        @return true if the destroy was done successfully\n    */\n    function destroy(uint index) public returns (bool) {\n        Loan storage loan = loans[index];\n        require(loan.status != Status.destroyed);\n        require(msg.sender == loan.lender || (msg.sender == loan.borrower && loan.status == Status.initial));\n        DestroyedBy(index, msg.sender);\n\n        // ERC721, remove loan from circulation\n        if (loan.status != Status.initial) {\n            lendersBalance[loan.lender] -= 1;\n            activeLoans -= 1;\n            Transfer(loan.lender, 0x0, index);\n        }\n\n        loan.status = Status.destroyed;\n        return true;\n    }\n\n    /**\n        @dev Transfers a loan to a different lender, the caller must be the current lender or previously being\n        approved with the method \"approveTransfer\"; only loans with the Status.lent status can be transfered.\n\n        @param index Index of the loan\n        @param to New lender\n\n        @return true if the transfer was done successfully\n    */\n    function transfer(address to, uint256 index) public returns (bool) {\n        Loan storage loan = loans[index];\n        \n        require(loan.status != Status.destroyed && loan.status != Status.paid);\n        require(msg.sender == loan.lender || msg.sender == loan.approvedTransfer);\n        require(to != address(0));\n        loan.lender = to;\n        loan.approvedTransfer = address(0);\n\n        // ERC721, transfer loan to another address\n        lendersBalance[msg.sender] -= 1;\n        lendersBalance[to] += 1;\n        Transfer(loan.lender, to, index);\n\n        return true;\n    }\n\n    /**\n        @dev ERC721 method, transfers the loan to the msg.sender, the msg.sender must be approved using the \n        \"approve\" method.\n\n        @return true if the transfer was successfull\n    */\n    function takeOwnership(uint256 _index) public returns (bool) {\n        return transfer(msg.sender, _index);\n    }\n\n    /**\n        @dev Approves the transfer of a given loan in the name of the lender, the behavior of this function is similar to\n        \"approve\" in the ERC20 standard, but only one approved address is allowed at a time.\n\n        The same method can be called passing 0x0 as parameter \"to\" to erase a previously approved address.\n\n        @param to Address allowed to transfer the loan or 0x0 to delete\n        @param index Index of the loan\n\n        @return true if the approve was done successfully\n    */\n    function approve(address to, uint256 index) public returns (bool) {\n        Loan storage loan = loans[index];\n        require(msg.sender == loan.lender);\n        loan.approvedTransfer = to;\n        Approval(msg.sender, to, index);\n        return true;\n    }\n\n    /**\n        @dev Returns the pending amount to complete de payment of the loan, keep in mind that this number increases \n        every second.\n\n        @param index Index of the loan\n\n        @return Aprox pending payment amount\n    */\n    function getPendingAmount(uint index) public constant returns (uint256) {\n        Loan storage loan = loans[index];\n        addInterest(index);\n        return getRawPendingAmount(loan);\n    }\n\n    function getRawPendingAmount(Loan loan) internal returns (uint256) {\n        return safeSubtract(safeAdd(safeAdd(loan.amount, loan.interest), loan.punitoryInterest), loan.paid);\n    }\n\n    /**\n        @dev Calculates the interest of a given amount, interest rate and delta time.\n\n        @param timeDelta Elapsed time\n        @param interestRate Interest rate expressed as the denominator of 10 000 000.\n        @param amount Amount to apply interest\n\n        @return realDelta The real timeDelta applied\n        @return interest The interest gained in the realDelta time\n    */\n    function calculateInterest(uint256 timeDelta, uint256 interestRate, uint256 amount) public constant returns (uint256 realDelta, uint256 interest) {\n        if (amount == 0) {\n            interest = 0;\n            realDelta = timeDelta;\n        } else {\n            interest = safeMult(safeMult(100000, amount), timeDelta) / interestRate;\n            realDelta = safeMult(interest, interestRate) / (amount * 100000);\n        }\n    }\n\n    /**\n        @dev Computes loan interest\n\n        Computes the punitory and non-punitory interest of a given loan and only applies the change.\n        \n        @param loan Loan to compute interest\n        @param timestamp Target absolute unix time to calculate interest.\n    */\n    function internalAddInterest(Loan storage loan, uint256 timestamp) internal {\n        if (timestamp > loan.interestTimestamp) {\n            uint256 newInterest = loan.interest;\n            uint256 newPunitoryInterest = loan.punitoryInterest;\n\n            uint256 newTimestamp;\n            uint256 realDelta;\n            uint256 calculatedInterest;\n\n            uint256 deltaTime;\n            uint256 pending;\n\n            uint256 endNonPunitory = min(timestamp, loan.dueTime);\n            if (endNonPunitory > loan.interestTimestamp) {\n                deltaTime = endNonPunitory - loan.interestTimestamp;\n\n                if (loan.paid < loan.amount) {\n                    pending = loan.amount - loan.paid;\n                } else {\n                    pending = 0;\n                }\n\n                (realDelta, calculatedInterest) = calculateInterest(deltaTime, loan.interestRate, pending);\n                newInterest = safeAdd(calculatedInterest, newInterest);\n                newTimestamp = loan.interestTimestamp + realDelta;\n            }\n\n            if (timestamp > loan.dueTime) {\n                uint256 startPunitory = max(loan.dueTime, loan.interestTimestamp);\n                deltaTime = timestamp - startPunitory;\n\n                uint256 debt = safeAdd(loan.amount, newInterest);\n                pending = min(debt, safeSubtract(safeAdd(debt, newPunitoryInterest), loan.paid));\n\n                (realDelta, calculatedInterest) = calculateInterest(deltaTime, loan.interestRatePunitory, pending);\n                newPunitoryInterest = safeAdd(newPunitoryInterest, calculatedInterest);\n                newTimestamp = startPunitory + realDelta;\n            }\n            \n            if (newInterest != loan.interest || newPunitoryInterest != loan.punitoryInterest) {\n                loan.interestTimestamp = newTimestamp;\n                loan.interest = newInterest;\n                loan.punitoryInterest = newPunitoryInterest;\n            }\n        }\n    }\n\n    /**\n        @dev Computes loan interest only up to current unix time\n\n        @param timestamp Target absolute unix time to calculate interest.\n    */\n    function addInterestUpTo(Loan storage loan, uint256 timestamp) internal {\n        require(loan.status == Status.lent);\n        if (timestamp <= block.timestamp) {\n            internalAddInterest(loan, timestamp);\n        }\n    }\n\n    /**\n        @dev Updates the loan accumulated interests up to the current Unix time.\n        \n        @param index Index of the loan\n    */\n    function addInterest(uint index) public {\n        Loan storage loan = loans[index];\n        addInterestUpTo(loan, block.timestamp);\n    }\n    \n    /**\n        @dev Pay loan\n\n        Realizes a payment of a given Loan, before performing the payment the accumulated\n        interest is computed and added to the total pending amount.\n\n        Before calling this function, the msg.sender must call the \"approve\" function on the RCN Token, specifying an amount\n        sufficient enough to pay the equivalent of the desired payment and the oracle fee.\n\n        Because it is difficult or even impossible to know in advance how much RCN are going to be spent on the\n        transaction*, we recommend performing the \"approve\" using an amount 5% superior to the wallet estimated\n        spending. If the RCN spent results to be less, the extra tokens are never debited from the msg.sender.\n\n        * The RCN rate can fluctuate on the same block, and it is impossible to know in advance the exact time of the\n        confirmation of the transaction. \n\n        If the paid pending amount equals zero, the loan changes status to \"paid\" and it is considered closed.\n\n        @param index Index of the loan\n        @param _amount Amount to pay, specified in the loan currency; or in RCN if the loan has no oracle\n        @param _from The identity of the payer\n        @param oracleData Data required by the oracle to return the rate, the content of this field must be provided\n            by the url exposed in the url() method of the oracle.\n            \n        @return true if the payment was executed successfully\n    */\n    function pay(uint index, uint256 _amount, address _from, bytes oracleData) public returns (bool) {\n        Loan storage loan = loans[index];\n\n        require(loan.status == Status.lent);\n        addInterest(index);\n        uint256 toPay = min(getPendingAmount(index), _amount);\n        PartialPayment(index, msg.sender, _from, toPay);\n\n        loan.paid = safeAdd(loan.paid, toPay);\n\n        if (getRawPendingAmount(loan) == 0) {\n            TotalPayment(index);\n            loan.status = Status.paid;\n\n            // ERC721, remove loan from circulation\n            lendersBalance[loan.lender] -= 1;\n            activeLoans -= 1;\n            Transfer(loan.lender, 0x0, index);\n        }\n\n        uint256 rate = getRate(loan, oracleData);\n        uint256 transferValue = safeMult(toPay, rate);\n        lockTokens(rcn, transferValue);\n        require(rcn.transferFrom(msg.sender, this, transferValue));\n        loan.lenderBalance = safeAdd(transferValue, loan.lenderBalance);\n\n        return true;\n    }\n\n    /**\n        @dev Retrieves the rate corresponding of the loan oracle, if the loan has no oracle the rate is 1\n\n        @param loan The loan with the cosigner\n        @param data Data required by the oracle\n\n        @return The rate of the oracle\n    */\n    function getRate(Loan loan, bytes data) internal returns (uint256) {\n        if (loan.oracle == address(0)) {\n            return 1;\n        } else {\n            return loan.oracle.getRate(loan.currency, data);\n        }\n    }\n\n    /**\n        @dev Withdraw lender funds\n\n        When a loan is paid, the funds are not transferred automatically to the lender, the funds are stored on the\n        engine contract, and the lender must call this function specifying the amount desired to transfer and the \n        destination.\n\n        This behavior is defined to allow the temporary transfer of the loan to a smart contract, without worrying that\n        the contract will receive tokens that are not traceable; and it allows the development of decentralized \n        autonomous organizations.\n\n        @param index Index of the loan\n        @param to Destination of the wiwthdraw funds\n        @param amount Amount to withdraw, in RCN\n\n        @return true if the withdraw was executed successfully\n    */\n    function withdrawal(uint index, address to, uint256 amount) public returns (bool) {\n        Loan storage loan = loans[index];\n        require(msg.sender == loan.lender);\n        loan.lenderBalance = safeSubtract(loan.lenderBalance, amount);\n        require(rcn.transfer(to, amount));\n        unlockTokens(rcn, amount);\n        return true;\n    }\n\n    function withdrawalRange(uint256 fromIndex, uint256 toIndex, address to) public returns (uint256) {\n        uint256 loanId;\n        uint256 totalWithdraw = 0;\n\n        for (loanId = fromIndex; loanId <= toIndex; loanId++) {\n            Loan storage loan = loans[loanId];\n            if (loan.lender == msg.sender) {\n                totalWithdraw += loan.lenderBalance;\n                loan.lenderBalance = 0;\n            }\n        }\n\n        require(rcn.transfer(to, totalWithdraw));\n        unlockTokens(rcn, totalWithdraw);\n        \n        return totalWithdraw;\n    }\n\n    function withdrawalList(uint256[] memory loanIds, address to) public returns (uint256) {\n        uint256 inputId;\n        uint256 totalWithdraw = 0;\n\n        for (inputId = 0; inputId < loanIds.length; inputId++) {\n            Loan storage loan = loans[loanIds[inputId]];\n            if (loan.lender == msg.sender) {\n                totalWithdraw += loan.lenderBalance;\n                loan.lenderBalance = 0;\n            }\n        }\n\n        require(rcn.transfer(to, totalWithdraw));\n        unlockTokens(rcn, totalWithdraw);\n\n        return totalWithdraw;\n    }\n\n    /**\n        @dev Deprecates the engine, locks the creation of new loans.\n    */\n    function setDeprecated(bool _deprecated) public onlyOwner {\n        deprecated = _deprecated;\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinfabrik-RCN Network Smart Contract Audit/rcn-network-3ded36151ad55543d16c354e70161852de4061d0/contracts/NanoLoanEngine.sol",
        "vulnerability": "Assertion Failure",
        "check": "FP",
        "response": "Answer: No\nReason: There are no assert statements used in the smart contract code, which eliminates the possibility of an assertion failure vulnerability."
    },
    {
        "code_segment": "contract NanoLoanEngine is ERC721, Engine, Ownable, TokenLockable {\n    uint256 public constant VERSION = 202;\n    string public constant VERSION_NAME = \"Basalt\";\n\n    uint256 private activeLoans = 0;\n    mapping(address => uint256) private lendersBalance;\n\n    function name() constant returns (string _name) {\n        _name = \"RCN - Nano loan engine - Basalt 202\";\n    }\n\n    function symbol() constant returns (string _symbol) {\n        _symbol = \"RCN-NLE-202\";\n    }\n\n    function totalSupply() constant returns (uint _totalSupply) {\n        _totalSupply = activeLoans;\n    }\n\n    function balanceOf(address _owner) constant returns (uint _balance) {\n        _balance = lendersBalance[_owner];\n    }\n\n    function tokenOfOwnerByIndex(address _owner, uint256 _index) constant returns (uint tokenId) {\n        uint256 tokenCount = balanceOf(_owner);\n\n        if (tokenCount == 0 || _index >= tokenCount) {\n            // Fail transaction\n            revert();\n        } else {\n            uint256 totalLoans = totalSupply();\n            uint256 resultIndex = 0;\n\n            uint256 loanId;\n            // SWC-128-DoS With Block Gas Limit: L46\n            for (loanId = 0; loanId <= totalLoans; loanId++) {\n                if (loans[loanId].lender == _owner && loans[loanId].status == Status.lent) {\n                    if (resultIndex == _index) {\n                        return loanId;\n                    }\n                    resultIndex++;\n                }\n            }\n\n            revert();\n        }\n    }\n\n    function tokensOfOwner(address _owner) external constant returns(uint256[] ownerTokens) {\n        uint256 tokenCount = balanceOf(_owner);\n\n        if (tokenCount == 0) {\n            // Return an empty array\n            return new uint256[](0);\n        } else {\n            uint256[] memory result = new uint256[](tokenCount);\n            uint256 totalLoans = totalSupply();\n            uint256 resultIndex = 0;\n\n            uint256 loanId;\n\n            for (loanId = 0; loanId <= totalLoans; loanId++) {\n                if (loans[loanId].lender == _owner && loans[loanId].status == Status.lent) {\n                    result[resultIndex] = loanId;\n                    resultIndex++;\n                }\n            }\n\n            return result;\n        }\n    }\n    \n    Token public rcn;\n    bool public deprecated;\n\n    event CreatedLoan(uint _index, address _borrower, address _creator);\n    event ApprovedBy(uint _index, address _address);\n    event Lent(uint _index, address _lender, address _cosigner);\n    event DestroyedBy(uint _index, address _address);\n    event PartialPayment(uint _index, address _sender, address _from, uint256 _amount);\n    event TotalPayment(uint _index);\n\n    function NanoLoanEngine(Token _rcn) public {\n        owner = msg.sender;\n        rcn = _rcn;\n    }\n\n    struct Loan {\n        Status status;\n        Oracle oracle;\n\n        address borrower;\n        address lender;\n        address creator;\n        address cosigner;\n        \n        uint256 amount;\n        uint256 interest;\n        uint256 punitoryInterest;\n        uint256 interestTimestamp;\n        uint256 paid;\n        uint256 interestRate;\n        uint256 interestRatePunitory;\n        uint256 dueTime;\n        uint256 duesIn;\n\n        bytes32 currency;\n        uint256 cancelableAt;\n        uint256 lenderBalance;\n\n        address approvedTransfer;\n        uint256 expirationRequest;\n\n        mapping(address => bool) approbations;\n    }\n\n    Loan[] private loans;\n\n    /**\n        @dev Creates a loan request, the loan can be generated with any borrower, cosigner, and conditions; if the \n        cosigner and borrower agree they must call the \"approve\" function.\n\n        The creator of the loan is the caller of this function; this is useful to track which wallet created the loan.\n\n        @param _oracleContract Address of the Oracle contract, if the loan does not use any oracle, this field should be 0x0.\n        @param _borrower Address of the borrower\n        @param _currency The currency to use with the oracle, the currency code is generated with the following formula,\n            keccak256(ticker,decimals).\n        @param _amount The requested amount; currency and unit are defined by the Oracle, if there is no Oracle present\n            the currency is RCN, and the unit is wei.\n        @param _interestRate The non-punitory interest rate by second, defined as a denominator of 10 000 000.\n        @param _interestRatePunitory The punitory interest rate by second, defined as a denominator of 10 000 000.\n            Ej: interestRate 11108571428571 = 28% Anual interest\n        @param _duesIn The time in seconds that the borrower has in order to pay the debt after the lender lends the money.\n        @param _cancelableAt Delta in seconds specifying how much interest should be added in advance, if the borrower pays \n        entirely or partially the loan before this term, no extra interest will be deducted.\n        @param _expirationRequest Timestamp of when the loan request expires, if the loan is not filled before this date, \n            the request is no longer valid.\n    */\n    function createLoan(Oracle _oracleContract, address _borrower, bytes32 _currency, uint256 _amount, uint256 _interestRate,\n        uint256 _interestRatePunitory, uint256 _duesIn, uint256 _cancelableAt, uint256 _expirationRequest) returns (uint256) {\n\n        require(!deprecated);\n        require(_cancelableAt <= _duesIn);\n        require(_oracleContract != address(0) || _currency == 0x0);\n        require(_borrower != address(0));\n        require(_amount != 0);\n        require(_interestRatePunitory != 0);\n        require(_interestRate != 0);\n        require(_expirationRequest > block.timestamp);\n\n        var loan = Loan(Status.initial, _oracleContract, _borrower, 0x0, msg.sender, 0x0, _amount, 0, 0, 0, 0, _interestRate,\n            _interestRatePunitory, 0, _duesIn, _currency, _cancelableAt, 0, 0x0, _expirationRequest);\n        uint index = loans.push(loan) - 1;\n        CreatedLoan(index, _borrower, msg.sender);\n\n        if (msg.sender == _borrower) {\n            approveLoan(index);\n        }\n\n        return index;\n    }\n    \n    function ownerOf(uint256 index) constant returns (address owner) { owner = loans[index].lender; }\n    function getTotalLoans() constant returns (uint256) { return loans.length; }\n    function getOracle(uint index) constant returns (Oracle) { return loans[index].oracle; }\n    function getBorrower(uint index) constant returns (address) { return loans[index].borrower; }\n    function getCosigner(uint index) constant returns (address) { return loans[index].cosigner; }\n    function getCreator(uint index) constant returns (address) { return loans[index].creator; }\n    function getAmount(uint index) constant returns (uint256) { return loans[index].amount; }\n    function getPunitoryInterest(uint index) constant returns (uint256) { return loans[index].punitoryInterest; }\n    function getInterestTimestamp(uint index) constant returns (uint256) { return loans[index].interestTimestamp; }\n    function getPaid(uint index) constant returns (uint256) { return loans[index].paid; }\n    function getInterestRate(uint index) constant returns (uint256) { return loans[index].interestRate; }\n    function getInterestRatePunitory(uint index) constant returns (uint256) { return loans[index].interestRatePunitory; }\n    function getDueTime(uint index) constant returns (uint256) { return loans[index].dueTime; }\n    function getDuesIn(uint index) constant returns (uint256) { return loans[index].duesIn; }\n    function getCancelableAt(uint index) constant returns (uint256) { return loans[index].cancelableAt; }\n    function getApprobation(uint index, address _address) constant returns (bool) { return loans[index].approbations[_address]; }\n    function getStatus(uint index) constant returns (Status) { return loans[index].status; }\n    function getLenderBalance(uint index) constant returns (uint256) { return loans[index].lenderBalance; }\n    function getApprovedTransfer(uint index) constant returns (address) {return loans[index].approvedTransfer; }\n    function getCurrency(uint index) constant returns (bytes32) { return loans[index].currency; }\n    function getExpirationRequest(uint index) constant returns (uint256) { return loans[index].expirationRequest; }\n    function getInterest(uint index) constant returns (uint256) { return loans[index].interest; }\n\n    /**\n        @param index Index of the loan\n\n        @return true if the loan has been approved by the borrower and cosigner.\n    */\n    function isApproved(uint index) constant returns (bool) {\n        Loan storage loan = loans[index];\n        return loan.approbations[loan.borrower];\n    }\n\n    /**\n        @dev Called by the members of the loan to show that they agree with the terms of the loan; the borrower\n        must call this method before any lender could call the method \"lend\".\n            \n        Any address can call this method to be added to the \"approbations\" mapping.\n\n        @param index Index of the loan\n\n        @return true if the approve was done successfully\n    */\n    function approveLoan(uint index) public returns(bool) {\n        Loan storage loan = loans[index];\n        require(loan.status == Status.initial);\n        loan.approbations[msg.sender] = true;\n        ApprovedBy(index, msg.sender);\n        return true;\n    }\n\n    /**\n        @dev Performs the lend of the RCN equivalent to the requested amount, and transforms the msg.sender in the new lender.\n\n        The loan must be previously approved by the borrower; before calling this function, the lender candidate must \n        call the \"approve\" function on the RCN Token, specifying an amount sufficient enough to pay the equivalent of\n        the requested amount, and the cosigner fee.\n        \n        @param index Index of the loan\n        @param oracleData Data required by the oracle to return the rate, the content of this field must be provided\n            by the url exposed in the url() method of the oracle.\n        @param cosigner Address of the cosigner, 0x0 for lending without cosigner.\n        @param cosignerData Data required by the cosigner to process the request.\n\n        @return true if the lend was done successfully\n    */\n    function lend(uint index, bytes oracleData, Cosigner cosigner, bytes cosignerData) public returns (bool) {\n        Loan storage loan = loans[index];\n\n        require(loan.status == Status.initial);\n        require(isApproved(index));\n        require(block.timestamp <= loan.expirationRequest);\n\n        loan.lender = msg.sender;\n        loan.dueTime = safeAdd(block.timestamp, loan.duesIn);\n        loan.interestTimestamp = block.timestamp;\n        loan.status = Status.lent;\n        \n        if (loan.cancelableAt > 0)\n            internalAddInterest(loan, safeAdd(block.timestamp, loan.cancelableAt));\n\n        uint256 rate = getRate(loan, oracleData);\n\n        if (cosigner != address(0)) {\n            // The cosigner it's temporary set to the next address (cosigner + 2), it's expected that the cosigner will\n            // call the method \"cosign\" to accept the conditions; that method also sets the cosigner to the right\n            // address. If that does not happen, the transaction fails.\n            loan.cosigner = address(uint256(cosigner) + 2);\n            require(cosigner.requestCosign(this, index, cosignerData, oracleData));\n            require(loan.cosigner == address(cosigner));\n        }\n        \n        require(rcn.transferFrom(msg.sender, loan.borrower, safeMult(loan.amount, rate)));\n        \n        // ERC721, create new loan and transfer it to the lender\n        Transfer(0x0, loan.lender, index);\n        activeLoans += 1;\n        lendersBalance[loan.lender] += 1;\n        Lent(index, loan.lender, cosigner);\n\n        return true;\n    }\n\n    /**\n        @dev The cosigner must call this method to accept the conditions of a loan, this method pays the cosigner his fee\n\n        @param index Index of the loan\n        @param cost Fee set by the cosigner\n\n        @return true If the cosign was successfull\n    */\n    function cosign(uint index, uint256 cost) external returns (bool) {\n        Loan storage loan = loans[index];\n        require(loan.status == Status.lent && (loan.dueTime - loan.duesIn) == block.timestamp);\n        require(loan.cosigner != address(0));\n        require(loan.cosigner == address(uint256(msg.sender) + 2));\n        loan.cosigner = msg.sender;\n        require(rcn.transferFrom(loan.lender, msg.sender, cost));\n        return true;\n    }\n\n    /**\n        @dev Destroys a loan, the borrower could call this method if they performed an accidental or regretted \n        \"approve\" of the loan, this method only works for them if the loan is in \"pending\" status.\n\n        The lender can call this method at any moment, in case of a loan with status \"lent\" the lender is pardoning \n        the debt. \n\n        @param index Index of the loan\n\n        @return true if the destroy was done successfully\n    */\n    function destroy(uint index) public returns (bool) {\n        Loan storage loan = loans[index];\n        require(loan.status != Status.destroyed);\n        require(msg.sender == loan.lender || (msg.sender == loan.borrower && loan.status == Status.initial));\n        DestroyedBy(index, msg.sender);\n\n        // ERC721, remove loan from circulation\n        if (loan.status != Status.initial) {\n            lendersBalance[loan.lender] -= 1;\n            activeLoans -= 1;\n            Transfer(loan.lender, 0x0, index);\n        }\n\n        loan.status = Status.destroyed;\n        return true;\n    }\n\n    /**\n        @dev Transfers a loan to a different lender, the caller must be the current lender or previously being\n        approved with the method \"approveTransfer\"; only loans with the Status.lent status can be transfered.\n\n        @param index Index of the loan\n        @param to New lender\n\n        @return true if the transfer was done successfully\n    */\n    function transfer(address to, uint256 index) public returns (bool) {\n        Loan storage loan = loans[index];\n        \n        require(loan.status != Status.destroyed && loan.status != Status.paid);\n        require(msg.sender == loan.lender || msg.sender == loan.approvedTransfer);\n        require(to != address(0));\n        loan.lender = to;\n        loan.approvedTransfer = address(0);\n\n        // ERC721, transfer loan to another address\n        lendersBalance[msg.sender] -= 1;\n        lendersBalance[to] += 1;\n        Transfer(loan.lender, to, index);\n\n        return true;\n    }\n\n    /**\n        @dev ERC721 method, transfers the loan to the msg.sender, the msg.sender must be approved using the \n        \"approve\" method.\n\n        @return true if the transfer was successfull\n    */\n    function takeOwnership(uint256 _index) public returns (bool) {\n        return transfer(msg.sender, _index);\n    }\n\n    /**\n        @dev Approves the transfer of a given loan in the name of the lender, the behavior of this function is similar to\n        \"approve\" in the ERC20 standard, but only one approved address is allowed at a time.\n\n        The same method can be called passing 0x0 as parameter \"to\" to erase a previously approved address.\n\n        @param to Address allowed to transfer the loan or 0x0 to delete\n        @param index Index of the loan\n\n        @return true if the approve was done successfully\n    */\n    function approve(address to, uint256 index) public returns (bool) {\n        Loan storage loan = loans[index];\n        require(msg.sender == loan.lender);\n        loan.approvedTransfer = to;\n        Approval(msg.sender, to, index);\n        return true;\n    }\n\n    /**\n        @dev Returns the pending amount to complete de payment of the loan, keep in mind that this number increases \n        every second.\n\n        @param index Index of the loan\n\n        @return Aprox pending payment amount\n    */\n    function getPendingAmount(uint index) public constant returns (uint256) {\n        Loan storage loan = loans[index];\n        addInterest(index);\n        return getRawPendingAmount(loan);\n    }\n\n    function getRawPendingAmount(Loan loan) internal returns (uint256) {\n        return safeSubtract(safeAdd(safeAdd(loan.amount, loan.interest), loan.punitoryInterest), loan.paid);\n    }\n\n    /**\n        @dev Calculates the interest of a given amount, interest rate and delta time.\n\n        @param timeDelta Elapsed time\n        @param interestRate Interest rate expressed as the denominator of 10 000 000.\n        @param amount Amount to apply interest\n\n        @return realDelta The real timeDelta applied\n        @return interest The interest gained in the realDelta time\n    */\n    function calculateInterest(uint256 timeDelta, uint256 interestRate, uint256 amount) public constant returns (uint256 realDelta, uint256 interest) {\n        if (amount == 0) {\n            interest = 0;\n            realDelta = timeDelta;\n        } else {\n            interest = safeMult(safeMult(100000, amount), timeDelta) / interestRate;\n            realDelta = safeMult(interest, interestRate) / (amount * 100000);\n        }\n    }\n\n    /**\n        @dev Computes loan interest\n\n        Computes the punitory and non-punitory interest of a given loan and only applies the change.\n        \n        @param loan Loan to compute interest\n        @param timestamp Target absolute unix time to calculate interest.\n    */\n    function internalAddInterest(Loan storage loan, uint256 timestamp) internal {\n        if (timestamp > loan.interestTimestamp) {\n            uint256 newInterest = loan.interest;\n            uint256 newPunitoryInterest = loan.punitoryInterest;\n\n            uint256 newTimestamp;\n            uint256 realDelta;\n            uint256 calculatedInterest;\n\n            uint256 deltaTime;\n            uint256 pending;\n\n            uint256 endNonPunitory = min(timestamp, loan.dueTime);\n            if (endNonPunitory > loan.interestTimestamp) {\n                deltaTime = endNonPunitory - loan.interestTimestamp;\n\n                if (loan.paid < loan.amount) {\n                    pending = loan.amount - loan.paid;\n                } else {\n                    pending = 0;\n                }\n\n                (realDelta, calculatedInterest) = calculateInterest(deltaTime, loan.interestRate, pending);\n                newInterest = safeAdd(calculatedInterest, newInterest);\n                newTimestamp = loan.interestTimestamp + realDelta;\n            }\n\n            if (timestamp > loan.dueTime) {\n                uint256 startPunitory = max(loan.dueTime, loan.interestTimestamp);\n                deltaTime = timestamp - startPunitory;\n\n                uint256 debt = safeAdd(loan.amount, newInterest);\n                pending = min(debt, safeSubtract(safeAdd(debt, newPunitoryInterest), loan.paid));\n\n                (realDelta, calculatedInterest) = calculateInterest(deltaTime, loan.interestRatePunitory, pending);\n                newPunitoryInterest = safeAdd(newPunitoryInterest, calculatedInterest);\n                newTimestamp = startPunitory + realDelta;\n            }\n            \n            if (newInterest != loan.interest || newPunitoryInterest != loan.punitoryInterest) {\n                loan.interestTimestamp = newTimestamp;\n                loan.interest = newInterest;\n                loan.punitoryInterest = newPunitoryInterest;\n            }\n        }\n    }\n\n    /**\n        @dev Computes loan interest only up to current unix time\n\n        @param timestamp Target absolute unix time to calculate interest.\n    */\n    function addInterestUpTo(Loan storage loan, uint256 timestamp) internal {\n        require(loan.status == Status.lent);\n        if (timestamp <= block.timestamp) {\n            internalAddInterest(loan, timestamp);\n        }\n    }\n\n    /**\n        @dev Updates the loan accumulated interests up to the current Unix time.\n        \n        @param index Index of the loan\n    */\n    function addInterest(uint index) public {\n        Loan storage loan = loans[index];\n        addInterestUpTo(loan, block.timestamp);\n    }\n    \n    /**\n        @dev Pay loan\n\n        Realizes a payment of a given Loan, before performing the payment the accumulated\n        interest is computed and added to the total pending amount.\n\n        Before calling this function, the msg.sender must call the \"approve\" function on the RCN Token, specifying an amount\n        sufficient enough to pay the equivalent of the desired payment and the oracle fee.\n\n        Because it is difficult or even impossible to know in advance how much RCN are going to be spent on the\n        transaction*, we recommend performing the \"approve\" using an amount 5% superior to the wallet estimated\n        spending. If the RCN spent results to be less, the extra tokens are never debited from the msg.sender.\n\n        * The RCN rate can fluctuate on the same block, and it is impossible to know in advance the exact time of the\n        confirmation of the transaction. \n\n        If the paid pending amount equals zero, the loan changes status to \"paid\" and it is considered closed.\n\n        @param index Index of the loan\n        @param _amount Amount to pay, specified in the loan currency; or in RCN if the loan has no oracle\n        @param _from The identity of the payer\n        @param oracleData Data required by the oracle to return the rate, the content of this field must be provided\n            by the url exposed in the url() method of the oracle.\n            \n        @return true if the payment was executed successfully\n    */\n    function pay(uint index, uint256 _amount, address _from, bytes oracleData) public returns (bool) {\n        Loan storage loan = loans[index];\n\n        require(loan.status == Status.lent);\n        addInterest(index);\n        uint256 toPay = min(getPendingAmount(index), _amount);\n        PartialPayment(index, msg.sender, _from, toPay);\n\n        loan.paid = safeAdd(loan.paid, toPay);\n\n        if (getRawPendingAmount(loan) == 0) {\n            TotalPayment(index);\n            loan.status = Status.paid;\n\n            // ERC721, remove loan from circulation\n            lendersBalance[loan.lender] -= 1;\n            activeLoans -= 1;\n            Transfer(loan.lender, 0x0, index);\n        }\n\n        uint256 rate = getRate(loan, oracleData);\n        uint256 transferValue = safeMult(toPay, rate);\n        lockTokens(rcn, transferValue);\n        require(rcn.transferFrom(msg.sender, this, transferValue));\n        loan.lenderBalance = safeAdd(transferValue, loan.lenderBalance);\n\n        return true;\n    }\n\n    /**\n        @dev Retrieves the rate corresponding of the loan oracle, if the loan has no oracle the rate is 1\n\n        @param loan The loan with the cosigner\n        @param data Data required by the oracle\n\n        @return The rate of the oracle\n    */\n    function getRate(Loan loan, bytes data) internal returns (uint256) {\n        if (loan.oracle == address(0)) {\n            return 1;\n        } else {\n            return loan.oracle.getRate(loan.currency, data);\n        }\n    }\n\n    /**\n        @dev Withdraw lender funds\n\n        When a loan is paid, the funds are not transferred automatically to the lender, the funds are stored on the\n        engine contract, and the lender must call this function specifying the amount desired to transfer and the \n        destination.\n\n        This behavior is defined to allow the temporary transfer of the loan to a smart contract, without worrying that\n        the contract will receive tokens that are not traceable; and it allows the development of decentralized \n        autonomous organizations.\n\n        @param index Index of the loan\n        @param to Destination of the wiwthdraw funds\n        @param amount Amount to withdraw, in RCN\n\n        @return true if the withdraw was executed successfully\n    */\n    function withdrawal(uint index, address to, uint256 amount) public returns (bool) {\n        Loan storage loan = loans[index];\n        require(msg.sender == loan.lender);\n        loan.lenderBalance = safeSubtract(loan.lenderBalance, amount);\n        require(rcn.transfer(to, amount));\n        unlockTokens(rcn, amount);\n        return true;\n    }\n\n    function withdrawalRange(uint256 fromIndex, uint256 toIndex, address to) public returns (uint256) {\n        uint256 loanId;\n        uint256 totalWithdraw = 0;\n\n        for (loanId = fromIndex; loanId <= toIndex; loanId++) {\n            Loan storage loan = loans[loanId];\n            if (loan.lender == msg.sender) {\n                totalWithdraw += loan.lenderBalance;\n                loan.lenderBalance = 0;\n            }\n        }\n\n        require(rcn.transfer(to, totalWithdraw));\n        unlockTokens(rcn, totalWithdraw);\n        \n        return totalWithdraw;\n    }\n\n    function withdrawalList(uint256[] memory loanIds, address to) public returns (uint256) {\n        uint256 inputId;\n        uint256 totalWithdraw = 0;\n\n        for (inputId = 0; inputId < loanIds.length; inputId++) {\n            Loan storage loan = loans[loanIds[inputId]];\n            if (loan.lender == msg.sender) {\n                totalWithdraw += loan.lenderBalance;\n                loan.lenderBalance = 0;\n            }\n        }\n\n        require(rcn.transfer(to, totalWithdraw));\n        unlockTokens(rcn, totalWithdraw);\n\n        return totalWithdraw;\n    }\n\n    /**\n        @dev Deprecates the engine, locks the creation of new loans.\n    */\n    function setDeprecated(bool _deprecated) public onlyOwner {\n        deprecated = _deprecated;\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinfabrik-RCN Network Smart Contract Audit/rcn-network-3ded36151ad55543d16c354e70161852de4061d0/contracts/NanoLoanEngine.sol",
        "vulnerability": "Assertion Failure",
        "check": "FP",
        "response": "Answer: No\nReason: The provided code uses assertions (require statements) to ensure conditions hold true, but does not contain explicit assert statements that can lead to assertion failures."
    },
    {
        "code_segment": "contract NanoLoanEngine is ERC721, Engine, Ownable, TokenLockable {\n    uint256 public constant VERSION = 202;\n    string public constant VERSION_NAME = \"Basalt\";\n\n    uint256 private activeLoans = 0;\n    mapping(address => uint256) private lendersBalance;\n\n    function name() constant returns (string _name) {\n        _name = \"RCN - Nano loan engine - Basalt 202\";\n    }\n\n    function symbol() constant returns (string _symbol) {\n        _symbol = \"RCN-NLE-202\";\n    }\n\n    function totalSupply() constant returns (uint _totalSupply) {\n        _totalSupply = activeLoans;\n    }\n\n    function balanceOf(address _owner) constant returns (uint _balance) {\n        _balance = lendersBalance[_owner];\n    }\n\n    function tokenOfOwnerByIndex(address _owner, uint256 _index) constant returns (uint tokenId) {\n        uint256 tokenCount = balanceOf(_owner);\n\n        if (tokenCount == 0 || _index >= tokenCount) {\n            // Fail transaction\n            revert();\n        } else {\n            uint256 totalLoans = totalSupply();\n            uint256 resultIndex = 0;\n\n            uint256 loanId;\n            // SWC-128-DoS With Block Gas Limit: L46\n            for (loanId = 0; loanId <= totalLoans; loanId++) {\n                if (loans[loanId].lender == _owner && loans[loanId].status == Status.lent) {\n                    if (resultIndex == _index) {\n                        return loanId;\n                    }\n                    resultIndex++;\n                }\n            }\n\n            revert();\n        }\n    }\n\n    function tokensOfOwner(address _owner) external constant returns(uint256[] ownerTokens) {\n        uint256 tokenCount = balanceOf(_owner);\n\n        if (tokenCount == 0) {\n            // Return an empty array\n            return new uint256[](0);\n        } else {\n            uint256[] memory result = new uint256[](tokenCount);\n            uint256 totalLoans = totalSupply();\n            uint256 resultIndex = 0;\n\n            uint256 loanId;\n\n            for (loanId = 0; loanId <= totalLoans; loanId++) {\n                if (loans[loanId].lender == _owner && loans[loanId].status == Status.lent) {\n                    result[resultIndex] = loanId;\n                    resultIndex++;\n                }\n            }\n\n            return result;\n        }\n    }\n    \n    Token public rcn;\n    bool public deprecated;\n\n    event CreatedLoan(uint _index, address _borrower, address _creator);\n    event ApprovedBy(uint _index, address _address);\n    event Lent(uint _index, address _lender, address _cosigner);\n    event DestroyedBy(uint _index, address _address);\n    event PartialPayment(uint _index, address _sender, address _from, uint256 _amount);\n    event TotalPayment(uint _index);\n\n    function NanoLoanEngine(Token _rcn) public {\n        owner = msg.sender;\n        rcn = _rcn;\n    }\n\n    struct Loan {\n        Status status;\n        Oracle oracle;\n\n        address borrower;\n        address lender;\n        address creator;\n        address cosigner;\n        \n        uint256 amount;\n        uint256 interest;\n        uint256 punitoryInterest;\n        uint256 interestTimestamp;\n        uint256 paid;\n        uint256 interestRate;\n        uint256 interestRatePunitory;\n        uint256 dueTime;\n        uint256 duesIn;\n\n        bytes32 currency;\n        uint256 cancelableAt;\n        uint256 lenderBalance;\n\n        address approvedTransfer;\n        uint256 expirationRequest;\n\n        mapping(address => bool) approbations;\n    }\n\n    Loan[] private loans;\n\n    /**\n        @dev Creates a loan request, the loan can be generated with any borrower, cosigner, and conditions; if the \n        cosigner and borrower agree they must call the \"approve\" function.\n\n        The creator of the loan is the caller of this function; this is useful to track which wallet created the loan.\n\n        @param _oracleContract Address of the Oracle contract, if the loan does not use any oracle, this field should be 0x0.\n        @param _borrower Address of the borrower\n        @param _currency The currency to use with the oracle, the currency code is generated with the following formula,\n            keccak256(ticker,decimals).\n        @param _amount The requested amount; currency and unit are defined by the Oracle, if there is no Oracle present\n            the currency is RCN, and the unit is wei.\n        @param _interestRate The non-punitory interest rate by second, defined as a denominator of 10 000 000.\n        @param _interestRatePunitory The punitory interest rate by second, defined as a denominator of 10 000 000.\n            Ej: interestRate 11108571428571 = 28% Anual interest\n        @param _duesIn The time in seconds that the borrower has in order to pay the debt after the lender lends the money.\n        @param _cancelableAt Delta in seconds specifying how much interest should be added in advance, if the borrower pays \n        entirely or partially the loan before this term, no extra interest will be deducted.\n        @param _expirationRequest Timestamp of when the loan request expires, if the loan is not filled before this date, \n            the request is no longer valid.\n    */\n    function createLoan(Oracle _oracleContract, address _borrower, bytes32 _currency, uint256 _amount, uint256 _interestRate,\n        uint256 _interestRatePunitory, uint256 _duesIn, uint256 _cancelableAt, uint256 _expirationRequest) returns (uint256) {\n\n        require(!deprecated);\n        require(_cancelableAt <= _duesIn);\n        require(_oracleContract != address(0) || _currency == 0x0);\n        require(_borrower != address(0));\n        require(_amount != 0);\n        require(_interestRatePunitory != 0);\n        require(_interestRate != 0);\n        require(_expirationRequest > block.timestamp);\n\n        var loan = Loan(Status.initial, _oracleContract, _borrower, 0x0, msg.sender, 0x0, _amount, 0, 0, 0, 0, _interestRate,\n            _interestRatePunitory, 0, _duesIn, _currency, _cancelableAt, 0, 0x0, _expirationRequest);\n        uint index = loans.push(loan) - 1;\n        CreatedLoan(index, _borrower, msg.sender);\n\n        if (msg.sender == _borrower) {\n            approveLoan(index);\n        }\n\n        return index;\n    }\n    \n    function ownerOf(uint256 index) constant returns (address owner) { owner = loans[index].lender; }\n    function getTotalLoans() constant returns (uint256) { return loans.length; }\n    function getOracle(uint index) constant returns (Oracle) { return loans[index].oracle; }\n    function getBorrower(uint index) constant returns (address) { return loans[index].borrower; }\n    function getCosigner(uint index) constant returns (address) { return loans[index].cosigner; }\n    function getCreator(uint index) constant returns (address) { return loans[index].creator; }\n    function getAmount(uint index) constant returns (uint256) { return loans[index].amount; }\n    function getPunitoryInterest(uint index) constant returns (uint256) { return loans[index].punitoryInterest; }\n    function getInterestTimestamp(uint index) constant returns (uint256) { return loans[index].interestTimestamp; }\n    function getPaid(uint index) constant returns (uint256) { return loans[index].paid; }\n    function getInterestRate(uint index) constant returns (uint256) { return loans[index].interestRate; }\n    function getInterestRatePunitory(uint index) constant returns (uint256) { return loans[index].interestRatePunitory; }\n    function getDueTime(uint index) constant returns (uint256) { return loans[index].dueTime; }\n    function getDuesIn(uint index) constant returns (uint256) { return loans[index].duesIn; }\n    function getCancelableAt(uint index) constant returns (uint256) { return loans[index].cancelableAt; }\n    function getApprobation(uint index, address _address) constant returns (bool) { return loans[index].approbations[_address]; }\n    function getStatus(uint index) constant returns (Status) { return loans[index].status; }\n    function getLenderBalance(uint index) constant returns (uint256) { return loans[index].lenderBalance; }\n    function getApprovedTransfer(uint index) constant returns (address) {return loans[index].approvedTransfer; }\n    function getCurrency(uint index) constant returns (bytes32) { return loans[index].currency; }\n    function getExpirationRequest(uint index) constant returns (uint256) { return loans[index].expirationRequest; }\n    function getInterest(uint index) constant returns (uint256) { return loans[index].interest; }\n\n    /**\n        @param index Index of the loan\n\n        @return true if the loan has been approved by the borrower and cosigner.\n    */\n    function isApproved(uint index) constant returns (bool) {\n        Loan storage loan = loans[index];\n        return loan.approbations[loan.borrower];\n    }\n\n    /**\n        @dev Called by the members of the loan to show that they agree with the terms of the loan; the borrower\n        must call this method before any lender could call the method \"lend\".\n            \n        Any address can call this method to be added to the \"approbations\" mapping.\n\n        @param index Index of the loan\n\n        @return true if the approve was done successfully\n    */\n    function approveLoan(uint index) public returns(bool) {\n        Loan storage loan = loans[index];\n        require(loan.status == Status.initial);\n        loan.approbations[msg.sender] = true;\n        ApprovedBy(index, msg.sender);\n        return true;\n    }\n\n    /**\n        @dev Performs the lend of the RCN equivalent to the requested amount, and transforms the msg.sender in the new lender.\n\n        The loan must be previously approved by the borrower; before calling this function, the lender candidate must \n        call the \"approve\" function on the RCN Token, specifying an amount sufficient enough to pay the equivalent of\n        the requested amount, and the cosigner fee.\n        \n        @param index Index of the loan\n        @param oracleData Data required by the oracle to return the rate, the content of this field must be provided\n            by the url exposed in the url() method of the oracle.\n        @param cosigner Address of the cosigner, 0x0 for lending without cosigner.\n        @param cosignerData Data required by the cosigner to process the request.\n\n        @return true if the lend was done successfully\n    */\n    function lend(uint index, bytes oracleData, Cosigner cosigner, bytes cosignerData) public returns (bool) {\n        Loan storage loan = loans[index];\n\n        require(loan.status == Status.initial);\n        require(isApproved(index));\n        require(block.timestamp <= loan.expirationRequest);\n\n        loan.lender = msg.sender;\n        loan.dueTime = safeAdd(block.timestamp, loan.duesIn);\n        loan.interestTimestamp = block.timestamp;\n        loan.status = Status.lent;\n        \n        if (loan.cancelableAt > 0)\n            internalAddInterest(loan, safeAdd(block.timestamp, loan.cancelableAt));\n\n        uint256 rate = getRate(loan, oracleData);\n\n        if (cosigner != address(0)) {\n            // The cosigner it's temporary set to the next address (cosigner + 2), it's expected that the cosigner will\n            // call the method \"cosign\" to accept the conditions; that method also sets the cosigner to the right\n            // address. If that does not happen, the transaction fails.\n            loan.cosigner = address(uint256(cosigner) + 2);\n            require(cosigner.requestCosign(this, index, cosignerData, oracleData));\n            require(loan.cosigner == address(cosigner));\n        }\n        \n        require(rcn.transferFrom(msg.sender, loan.borrower, safeMult(loan.amount, rate)));\n        \n        // ERC721, create new loan and transfer it to the lender\n        Transfer(0x0, loan.lender, index);\n        activeLoans += 1;\n        lendersBalance[loan.lender] += 1;\n        Lent(index, loan.lender, cosigner);\n\n        return true;\n    }\n\n    /**\n        @dev The cosigner must call this method to accept the conditions of a loan, this method pays the cosigner his fee\n\n        @param index Index of the loan\n        @param cost Fee set by the cosigner\n\n        @return true If the cosign was successfull\n    */\n    function cosign(uint index, uint256 cost) external returns (bool) {\n        Loan storage loan = loans[index];\n        require(loan.status == Status.lent && (loan.dueTime - loan.duesIn) == block.timestamp);\n        require(loan.cosigner != address(0));\n        require(loan.cosigner == address(uint256(msg.sender) + 2));\n        loan.cosigner = msg.sender;\n        require(rcn.transferFrom(loan.lender, msg.sender, cost));\n        return true;\n    }\n\n    /**\n        @dev Destroys a loan, the borrower could call this method if they performed an accidental or regretted \n        \"approve\" of the loan, this method only works for them if the loan is in \"pending\" status.\n\n        The lender can call this method at any moment, in case of a loan with status \"lent\" the lender is pardoning \n        the debt. \n\n        @param index Index of the loan\n\n        @return true if the destroy was done successfully\n    */\n    function destroy(uint index) public returns (bool) {\n        Loan storage loan = loans[index];\n        require(loan.status != Status.destroyed);\n        require(msg.sender == loan.lender || (msg.sender == loan.borrower && loan.status == Status.initial));\n        DestroyedBy(index, msg.sender);\n\n        // ERC721, remove loan from circulation\n        if (loan.status != Status.initial) {\n            lendersBalance[loan.lender] -= 1;\n            activeLoans -= 1;\n            Transfer(loan.lender, 0x0, index);\n        }\n\n        loan.status = Status.destroyed;\n        return true;\n    }\n\n    /**\n        @dev Transfers a loan to a different lender, the caller must be the current lender or previously being\n        approved with the method \"approveTransfer\"; only loans with the Status.lent status can be transfered.\n\n        @param index Index of the loan\n        @param to New lender\n\n        @return true if the transfer was done successfully\n    */\n    function transfer(address to, uint256 index) public returns (bool) {\n        Loan storage loan = loans[index];\n        \n        require(loan.status != Status.destroyed && loan.status != Status.paid);\n        require(msg.sender == loan.lender || msg.sender == loan.approvedTransfer);\n        require(to != address(0));\n        loan.lender = to;\n        loan.approvedTransfer = address(0);\n\n        // ERC721, transfer loan to another address\n        lendersBalance[msg.sender] -= 1;\n        lendersBalance[to] += 1;\n        Transfer(loan.lender, to, index);\n\n        return true;\n    }\n\n    /**\n        @dev ERC721 method, transfers the loan to the msg.sender, the msg.sender must be approved using the \n        \"approve\" method.\n\n        @return true if the transfer was successfull\n    */\n    function takeOwnership(uint256 _index) public returns (bool) {\n        return transfer(msg.sender, _index);\n    }\n\n    /**\n        @dev Approves the transfer of a given loan in the name of the lender, the behavior of this function is similar to\n        \"approve\" in the ERC20 standard, but only one approved address is allowed at a time.\n\n        The same method can be called passing 0x0 as parameter \"to\" to erase a previously approved address.\n\n        @param to Address allowed to transfer the loan or 0x0 to delete\n        @param index Index of the loan\n\n        @return true if the approve was done successfully\n    */\n    function approve(address to, uint256 index) public returns (bool) {\n        Loan storage loan = loans[index];\n        require(msg.sender == loan.lender);\n        loan.approvedTransfer = to;\n        Approval(msg.sender, to, index);\n        return true;\n    }\n\n    /**\n        @dev Returns the pending amount to complete de payment of the loan, keep in mind that this number increases \n        every second.\n\n        @param index Index of the loan\n\n        @return Aprox pending payment amount\n    */\n    function getPendingAmount(uint index) public constant returns (uint256) {\n        Loan storage loan = loans[index];\n        addInterest(index);\n        return getRawPendingAmount(loan);\n    }\n\n    function getRawPendingAmount(Loan loan) internal returns (uint256) {\n        return safeSubtract(safeAdd(safeAdd(loan.amount, loan.interest), loan.punitoryInterest), loan.paid);\n    }\n\n    /**\n        @dev Calculates the interest of a given amount, interest rate and delta time.\n\n        @param timeDelta Elapsed time\n        @param interestRate Interest rate expressed as the denominator of 10 000 000.\n        @param amount Amount to apply interest\n\n        @return realDelta The real timeDelta applied\n        @return interest The interest gained in the realDelta time\n    */\n    function calculateInterest(uint256 timeDelta, uint256 interestRate, uint256 amount) public constant returns (uint256 realDelta, uint256 interest) {\n        if (amount == 0) {\n            interest = 0;\n            realDelta = timeDelta;\n        } else {\n            interest = safeMult(safeMult(100000, amount), timeDelta) / interestRate;\n            realDelta = safeMult(interest, interestRate) / (amount * 100000);\n        }\n    }\n\n    /**\n        @dev Computes loan interest\n\n        Computes the punitory and non-punitory interest of a given loan and only applies the change.\n        \n        @param loan Loan to compute interest\n        @param timestamp Target absolute unix time to calculate interest.\n    */\n    function internalAddInterest(Loan storage loan, uint256 timestamp) internal {\n        if (timestamp > loan.interestTimestamp) {\n            uint256 newInterest = loan.interest;\n            uint256 newPunitoryInterest = loan.punitoryInterest;\n\n            uint256 newTimestamp;\n            uint256 realDelta;\n            uint256 calculatedInterest;\n\n            uint256 deltaTime;\n            uint256 pending;\n\n            uint256 endNonPunitory = min(timestamp, loan.dueTime);\n            if (endNonPunitory > loan.interestTimestamp) {\n                deltaTime = endNonPunitory - loan.interestTimestamp;\n\n                if (loan.paid < loan.amount) {\n                    pending = loan.amount - loan.paid;\n                } else {\n                    pending = 0;\n                }\n\n                (realDelta, calculatedInterest) = calculateInterest(deltaTime, loan.interestRate, pending);\n                newInterest = safeAdd(calculatedInterest, newInterest);\n                newTimestamp = loan.interestTimestamp + realDelta;\n            }\n\n            if (timestamp > loan.dueTime) {\n                uint256 startPunitory = max(loan.dueTime, loan.interestTimestamp);\n                deltaTime = timestamp - startPunitory;\n\n                uint256 debt = safeAdd(loan.amount, newInterest);\n                pending = min(debt, safeSubtract(safeAdd(debt, newPunitoryInterest), loan.paid));\n\n                (realDelta, calculatedInterest) = calculateInterest(deltaTime, loan.interestRatePunitory, pending);\n                newPunitoryInterest = safeAdd(newPunitoryInterest, calculatedInterest);\n                newTimestamp = startPunitory + realDelta;\n            }\n            \n            if (newInterest != loan.interest || newPunitoryInterest != loan.punitoryInterest) {\n                loan.interestTimestamp = newTimestamp;\n                loan.interest = newInterest;\n                loan.punitoryInterest = newPunitoryInterest;\n            }\n        }\n    }\n\n    /**\n        @dev Computes loan interest only up to current unix time\n\n        @param timestamp Target absolute unix time to calculate interest.\n    */\n    function addInterestUpTo(Loan storage loan, uint256 timestamp) internal {\n        require(loan.status == Status.lent);\n        if (timestamp <= block.timestamp) {\n            internalAddInterest(loan, timestamp);\n        }\n    }\n\n    /**\n        @dev Updates the loan accumulated interests up to the current Unix time.\n        \n        @param index Index of the loan\n    */\n    function addInterest(uint index) public {\n        Loan storage loan = loans[index];\n        addInterestUpTo(loan, block.timestamp);\n    }\n    \n    /**\n        @dev Pay loan\n\n        Realizes a payment of a given Loan, before performing the payment the accumulated\n        interest is computed and added to the total pending amount.\n\n        Before calling this function, the msg.sender must call the \"approve\" function on the RCN Token, specifying an amount\n        sufficient enough to pay the equivalent of the desired payment and the oracle fee.\n\n        Because it is difficult or even impossible to know in advance how much RCN are going to be spent on the\n        transaction*, we recommend performing the \"approve\" using an amount 5% superior to the wallet estimated\n        spending. If the RCN spent results to be less, the extra tokens are never debited from the msg.sender.\n\n        * The RCN rate can fluctuate on the same block, and it is impossible to know in advance the exact time of the\n        confirmation of the transaction. \n\n        If the paid pending amount equals zero, the loan changes status to \"paid\" and it is considered closed.\n\n        @param index Index of the loan\n        @param _amount Amount to pay, specified in the loan currency; or in RCN if the loan has no oracle\n        @param _from The identity of the payer\n        @param oracleData Data required by the oracle to return the rate, the content of this field must be provided\n            by the url exposed in the url() method of the oracle.\n            \n        @return true if the payment was executed successfully\n    */\n    function pay(uint index, uint256 _amount, address _from, bytes oracleData) public returns (bool) {\n        Loan storage loan = loans[index];\n\n        require(loan.status == Status.lent);\n        addInterest(index);\n        uint256 toPay = min(getPendingAmount(index), _amount);\n        PartialPayment(index, msg.sender, _from, toPay);\n\n        loan.paid = safeAdd(loan.paid, toPay);\n\n        if (getRawPendingAmount(loan) == 0) {\n            TotalPayment(index);\n            loan.status = Status.paid;\n\n            // ERC721, remove loan from circulation\n            lendersBalance[loan.lender] -= 1;\n            activeLoans -= 1;\n            Transfer(loan.lender, 0x0, index);\n        }\n\n        uint256 rate = getRate(loan, oracleData);\n        uint256 transferValue = safeMult(toPay, rate);\n        lockTokens(rcn, transferValue);\n        require(rcn.transferFrom(msg.sender, this, transferValue));\n        loan.lenderBalance = safeAdd(transferValue, loan.lenderBalance);\n\n        return true;\n    }\n\n    /**\n        @dev Retrieves the rate corresponding of the loan oracle, if the loan has no oracle the rate is 1\n\n        @param loan The loan with the cosigner\n        @param data Data required by the oracle\n\n        @return The rate of the oracle\n    */\n    function getRate(Loan loan, bytes data) internal returns (uint256) {\n        if (loan.oracle == address(0)) {\n            return 1;\n        } else {\n            return loan.oracle.getRate(loan.currency, data);\n        }\n    }\n\n    /**\n        @dev Withdraw lender funds\n\n        When a loan is paid, the funds are not transferred automatically to the lender, the funds are stored on the\n        engine contract, and the lender must call this function specifying the amount desired to transfer and the \n        destination.\n\n        This behavior is defined to allow the temporary transfer of the loan to a smart contract, without worrying that\n        the contract will receive tokens that are not traceable; and it allows the development of decentralized \n        autonomous organizations.\n\n        @param index Index of the loan\n        @param to Destination of the wiwthdraw funds\n        @param amount Amount to withdraw, in RCN\n\n        @return true if the withdraw was executed successfully\n    */\n    function withdrawal(uint index, address to, uint256 amount) public returns (bool) {\n        Loan storage loan = loans[index];\n        require(msg.sender == loan.lender);\n        loan.lenderBalance = safeSubtract(loan.lenderBalance, amount);\n        require(rcn.transfer(to, amount));\n        unlockTokens(rcn, amount);\n        return true;\n    }\n\n    function withdrawalRange(uint256 fromIndex, uint256 toIndex, address to) public returns (uint256) {\n        uint256 loanId;\n        uint256 totalWithdraw = 0;\n\n        for (loanId = fromIndex; loanId <= toIndex; loanId++) {\n            Loan storage loan = loans[loanId];\n            if (loan.lender == msg.sender) {\n                totalWithdraw += loan.lenderBalance;\n                loan.lenderBalance = 0;\n            }\n        }\n\n        require(rcn.transfer(to, totalWithdraw));\n        unlockTokens(rcn, totalWithdraw);\n        \n        return totalWithdraw;\n    }\n\n    function withdrawalList(uint256[] memory loanIds, address to) public returns (uint256) {\n        uint256 inputId;\n        uint256 totalWithdraw = 0;\n\n        for (inputId = 0; inputId < loanIds.length; inputId++) {\n            Loan storage loan = loans[loanIds[inputId]];\n            if (loan.lender == msg.sender) {\n                totalWithdraw += loan.lenderBalance;\n                loan.lenderBalance = 0;\n            }\n        }\n\n        require(rcn.transfer(to, totalWithdraw));\n        unlockTokens(rcn, totalWithdraw);\n\n        return totalWithdraw;\n    }\n\n    /**\n        @dev Deprecates the engine, locks the creation of new loans.\n    */\n    function setDeprecated(bool _deprecated) public onlyOwner {\n        deprecated = _deprecated;\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinfabrik-RCN Network Smart Contract Audit/rcn-network-3ded36151ad55543d16c354e70161852de4061d0/contracts/NanoLoanEngine.sol",
        "vulnerability": "Assertion Failure",
        "check": "FP",
        "response": "Answer: No\nReason: The code does not contain explicit Solidity `assert` statements or conditions that can result in assertion failures."
    },
    {
        "code_segment": "contract NanoLoanEngine is ERC721, Engine, Ownable, TokenLockable {\n    uint256 public constant VERSION = 202;\n    string public constant VERSION_NAME = \"Basalt\";\n\n    uint256 private activeLoans = 0;\n    mapping(address => uint256) private lendersBalance;\n\n    function name() constant returns (string _name) {\n        _name = \"RCN - Nano loan engine - Basalt 202\";\n    }\n\n    function symbol() constant returns (string _symbol) {\n        _symbol = \"RCN-NLE-202\";\n    }\n\n    function totalSupply() constant returns (uint _totalSupply) {\n        _totalSupply = activeLoans;\n    }\n\n    function balanceOf(address _owner) constant returns (uint _balance) {\n        _balance = lendersBalance[_owner];\n    }\n\n    function tokenOfOwnerByIndex(address _owner, uint256 _index) constant returns (uint tokenId) {\n        uint256 tokenCount = balanceOf(_owner);\n\n        if (tokenCount == 0 || _index >= tokenCount) {\n            // Fail transaction\n            revert();\n        } else {\n            uint256 totalLoans = totalSupply();\n            uint256 resultIndex = 0;\n\n            uint256 loanId;\n            // SWC-128-DoS With Block Gas Limit: L46\n            for (loanId = 0; loanId <= totalLoans; loanId++) {\n                if (loans[loanId].lender == _owner && loans[loanId].status == Status.lent) {\n                    if (resultIndex == _index) {\n                        return loanId;\n                    }\n                    resultIndex++;\n                }\n            }\n\n            revert();\n        }\n    }\n\n    function tokensOfOwner(address _owner) external constant returns(uint256[] ownerTokens) {\n        uint256 tokenCount = balanceOf(_owner);\n\n        if (tokenCount == 0) {\n            // Return an empty array\n            return new uint256[](0);\n        } else {\n            uint256[] memory result = new uint256[](tokenCount);\n            uint256 totalLoans = totalSupply();\n            uint256 resultIndex = 0;\n\n            uint256 loanId;\n\n            for (loanId = 0; loanId <= totalLoans; loanId++) {\n                if (loans[loanId].lender == _owner && loans[loanId].status == Status.lent) {\n                    result[resultIndex] = loanId;\n                    resultIndex++;\n                }\n            }\n\n            return result;\n        }\n    }\n    \n    Token public rcn;\n    bool public deprecated;\n\n    event CreatedLoan(uint _index, address _borrower, address _creator);\n    event ApprovedBy(uint _index, address _address);\n    event Lent(uint _index, address _lender, address _cosigner);\n    event DestroyedBy(uint _index, address _address);\n    event PartialPayment(uint _index, address _sender, address _from, uint256 _amount);\n    event TotalPayment(uint _index);\n\n    function NanoLoanEngine(Token _rcn) public {\n        owner = msg.sender;\n        rcn = _rcn;\n    }\n\n    struct Loan {\n        Status status;\n        Oracle oracle;\n\n        address borrower;\n        address lender;\n        address creator;\n        address cosigner;\n        \n        uint256 amount;\n        uint256 interest;\n        uint256 punitoryInterest;\n        uint256 interestTimestamp;\n        uint256 paid;\n        uint256 interestRate;\n        uint256 interestRatePunitory;\n        uint256 dueTime;\n        uint256 duesIn;\n\n        bytes32 currency;\n        uint256 cancelableAt;\n        uint256 lenderBalance;\n\n        address approvedTransfer;\n        uint256 expirationRequest;\n\n        mapping(address => bool) approbations;\n    }\n\n    Loan[] private loans;\n\n    /**\n        @dev Creates a loan request, the loan can be generated with any borrower, cosigner, and conditions; if the \n        cosigner and borrower agree they must call the \"approve\" function.\n\n        The creator of the loan is the caller of this function; this is useful to track which wallet created the loan.\n\n        @param _oracleContract Address of the Oracle contract, if the loan does not use any oracle, this field should be 0x0.\n        @param _borrower Address of the borrower\n        @param _currency The currency to use with the oracle, the currency code is generated with the following formula,\n            keccak256(ticker,decimals).\n        @param _amount The requested amount; currency and unit are defined by the Oracle, if there is no Oracle present\n            the currency is RCN, and the unit is wei.\n        @param _interestRate The non-punitory interest rate by second, defined as a denominator of 10 000 000.\n        @param _interestRatePunitory The punitory interest rate by second, defined as a denominator of 10 000 000.\n            Ej: interestRate 11108571428571 = 28% Anual interest\n        @param _duesIn The time in seconds that the borrower has in order to pay the debt after the lender lends the money.\n        @param _cancelableAt Delta in seconds specifying how much interest should be added in advance, if the borrower pays \n        entirely or partially the loan before this term, no extra interest will be deducted.\n        @param _expirationRequest Timestamp of when the loan request expires, if the loan is not filled before this date, \n            the request is no longer valid.\n    */\n    function createLoan(Oracle _oracleContract, address _borrower, bytes32 _currency, uint256 _amount, uint256 _interestRate,\n        uint256 _interestRatePunitory, uint256 _duesIn, uint256 _cancelableAt, uint256 _expirationRequest) returns (uint256) {\n\n        require(!deprecated);\n        require(_cancelableAt <= _duesIn);\n        require(_oracleContract != address(0) || _currency == 0x0);\n        require(_borrower != address(0));\n        require(_amount != 0);\n        require(_interestRatePunitory != 0);\n        require(_interestRate != 0);\n        require(_expirationRequest > block.timestamp);\n\n        var loan = Loan(Status.initial, _oracleContract, _borrower, 0x0, msg.sender, 0x0, _amount, 0, 0, 0, 0, _interestRate,\n            _interestRatePunitory, 0, _duesIn, _currency, _cancelableAt, 0, 0x0, _expirationRequest);\n        uint index = loans.push(loan) - 1;\n        CreatedLoan(index, _borrower, msg.sender);\n\n        if (msg.sender == _borrower) {\n            approveLoan(index);\n        }\n\n        return index;\n    }\n    \n    function ownerOf(uint256 index) constant returns (address owner) { owner = loans[index].lender; }\n    function getTotalLoans() constant returns (uint256) { return loans.length; }\n    function getOracle(uint index) constant returns (Oracle) { return loans[index].oracle; }\n    function getBorrower(uint index) constant returns (address) { return loans[index].borrower; }\n    function getCosigner(uint index) constant returns (address) { return loans[index].cosigner; }\n    function getCreator(uint index) constant returns (address) { return loans[index].creator; }\n    function getAmount(uint index) constant returns (uint256) { return loans[index].amount; }\n    function getPunitoryInterest(uint index) constant returns (uint256) { return loans[index].punitoryInterest; }\n    function getInterestTimestamp(uint index) constant returns (uint256) { return loans[index].interestTimestamp; }\n    function getPaid(uint index) constant returns (uint256) { return loans[index].paid; }\n    function getInterestRate(uint index) constant returns (uint256) { return loans[index].interestRate; }\n    function getInterestRatePunitory(uint index) constant returns (uint256) { return loans[index].interestRatePunitory; }\n    function getDueTime(uint index) constant returns (uint256) { return loans[index].dueTime; }\n    function getDuesIn(uint index) constant returns (uint256) { return loans[index].duesIn; }\n    function getCancelableAt(uint index) constant returns (uint256) { return loans[index].cancelableAt; }\n    function getApprobation(uint index, address _address) constant returns (bool) { return loans[index].approbations[_address]; }\n    function getStatus(uint index) constant returns (Status) { return loans[index].status; }\n    function getLenderBalance(uint index) constant returns (uint256) { return loans[index].lenderBalance; }\n    function getApprovedTransfer(uint index) constant returns (address) {return loans[index].approvedTransfer; }\n    function getCurrency(uint index) constant returns (bytes32) { return loans[index].currency; }\n    function getExpirationRequest(uint index) constant returns (uint256) { return loans[index].expirationRequest; }\n    function getInterest(uint index) constant returns (uint256) { return loans[index].interest; }\n\n    /**\n        @param index Index of the loan\n\n        @return true if the loan has been approved by the borrower and cosigner.\n    */\n    function isApproved(uint index) constant returns (bool) {\n        Loan storage loan = loans[index];\n        return loan.approbations[loan.borrower];\n    }\n\n    /**\n        @dev Called by the members of the loan to show that they agree with the terms of the loan; the borrower\n        must call this method before any lender could call the method \"lend\".\n            \n        Any address can call this method to be added to the \"approbations\" mapping.\n\n        @param index Index of the loan\n\n        @return true if the approve was done successfully\n    */\n    function approveLoan(uint index) public returns(bool) {\n        Loan storage loan = loans[index];\n        require(loan.status == Status.initial);\n        loan.approbations[msg.sender] = true;\n        ApprovedBy(index, msg.sender);\n        return true;\n    }\n\n    /**\n        @dev Performs the lend of the RCN equivalent to the requested amount, and transforms the msg.sender in the new lender.\n\n        The loan must be previously approved by the borrower; before calling this function, the lender candidate must \n        call the \"approve\" function on the RCN Token, specifying an amount sufficient enough to pay the equivalent of\n        the requested amount, and the cosigner fee.\n        \n        @param index Index of the loan\n        @param oracleData Data required by the oracle to return the rate, the content of this field must be provided\n            by the url exposed in the url() method of the oracle.\n        @param cosigner Address of the cosigner, 0x0 for lending without cosigner.\n        @param cosignerData Data required by the cosigner to process the request.\n\n        @return true if the lend was done successfully\n    */\n    function lend(uint index, bytes oracleData, Cosigner cosigner, bytes cosignerData) public returns (bool) {\n        Loan storage loan = loans[index];\n\n        require(loan.status == Status.initial);\n        require(isApproved(index));\n        require(block.timestamp <= loan.expirationRequest);\n\n        loan.lender = msg.sender;\n        loan.dueTime = safeAdd(block.timestamp, loan.duesIn);\n        loan.interestTimestamp = block.timestamp;\n        loan.status = Status.lent;\n        \n        if (loan.cancelableAt > 0)\n            internalAddInterest(loan, safeAdd(block.timestamp, loan.cancelableAt));\n\n        uint256 rate = getRate(loan, oracleData);\n\n        if (cosigner != address(0)) {\n            // The cosigner it's temporary set to the next address (cosigner + 2), it's expected that the cosigner will\n            // call the method \"cosign\" to accept the conditions; that method also sets the cosigner to the right\n            // address. If that does not happen, the transaction fails.\n            loan.cosigner = address(uint256(cosigner) + 2);\n            require(cosigner.requestCosign(this, index, cosignerData, oracleData));\n            require(loan.cosigner == address(cosigner));\n        }\n        \n        require(rcn.transferFrom(msg.sender, loan.borrower, safeMult(loan.amount, rate)));\n        \n        // ERC721, create new loan and transfer it to the lender\n        Transfer(0x0, loan.lender, index);\n        activeLoans += 1;\n        lendersBalance[loan.lender] += 1;\n        Lent(index, loan.lender, cosigner);\n\n        return true;\n    }\n\n    /**\n        @dev The cosigner must call this method to accept the conditions of a loan, this method pays the cosigner his fee\n\n        @param index Index of the loan\n        @param cost Fee set by the cosigner\n\n        @return true If the cosign was successfull\n    */\n    function cosign(uint index, uint256 cost) external returns (bool) {\n        Loan storage loan = loans[index];\n        require(loan.status == Status.lent && (loan.dueTime - loan.duesIn) == block.timestamp);\n        require(loan.cosigner != address(0));\n        require(loan.cosigner == address(uint256(msg.sender) + 2));\n        loan.cosigner = msg.sender;\n        require(rcn.transferFrom(loan.lender, msg.sender, cost));\n        return true;\n    }\n\n    /**\n        @dev Destroys a loan, the borrower could call this method if they performed an accidental or regretted \n        \"approve\" of the loan, this method only works for them if the loan is in \"pending\" status.\n\n        The lender can call this method at any moment, in case of a loan with status \"lent\" the lender is pardoning \n        the debt. \n\n        @param index Index of the loan\n\n        @return true if the destroy was done successfully\n    */\n    function destroy(uint index) public returns (bool) {\n        Loan storage loan = loans[index];\n        require(loan.status != Status.destroyed);\n        require(msg.sender == loan.lender || (msg.sender == loan.borrower && loan.status == Status.initial));\n        DestroyedBy(index, msg.sender);\n\n        // ERC721, remove loan from circulation\n        if (loan.status != Status.initial) {\n            lendersBalance[loan.lender] -= 1;\n            activeLoans -= 1;\n            Transfer(loan.lender, 0x0, index);\n        }\n\n        loan.status = Status.destroyed;\n        return true;\n    }\n\n    /**\n        @dev Transfers a loan to a different lender, the caller must be the current lender or previously being\n        approved with the method \"approveTransfer\"; only loans with the Status.lent status can be transfered.\n\n        @param index Index of the loan\n        @param to New lender\n\n        @return true if the transfer was done successfully\n    */\n    function transfer(address to, uint256 index) public returns (bool) {\n        Loan storage loan = loans[index];\n        \n        require(loan.status != Status.destroyed && loan.status != Status.paid);\n        require(msg.sender == loan.lender || msg.sender == loan.approvedTransfer);\n        require(to != address(0));\n        loan.lender = to;\n        loan.approvedTransfer = address(0);\n\n        // ERC721, transfer loan to another address\n        lendersBalance[msg.sender] -= 1;\n        lendersBalance[to] += 1;\n        Transfer(loan.lender, to, index);\n\n        return true;\n    }\n\n    /**\n        @dev ERC721 method, transfers the loan to the msg.sender, the msg.sender must be approved using the \n        \"approve\" method.\n\n        @return true if the transfer was successfull\n    */\n    function takeOwnership(uint256 _index) public returns (bool) {\n        return transfer(msg.sender, _index);\n    }\n\n    /**\n        @dev Approves the transfer of a given loan in the name of the lender, the behavior of this function is similar to\n        \"approve\" in the ERC20 standard, but only one approved address is allowed at a time.\n\n        The same method can be called passing 0x0 as parameter \"to\" to erase a previously approved address.\n\n        @param to Address allowed to transfer the loan or 0x0 to delete\n        @param index Index of the loan\n\n        @return true if the approve was done successfully\n    */\n    function approve(address to, uint256 index) public returns (bool) {\n        Loan storage loan = loans[index];\n        require(msg.sender == loan.lender);\n        loan.approvedTransfer = to;\n        Approval(msg.sender, to, index);\n        return true;\n    }\n\n    /**\n        @dev Returns the pending amount to complete de payment of the loan, keep in mind that this number increases \n        every second.\n\n        @param index Index of the loan\n\n        @return Aprox pending payment amount\n    */\n    function getPendingAmount(uint index) public constant returns (uint256) {\n        Loan storage loan = loans[index];\n        addInterest(index);\n        return getRawPendingAmount(loan);\n    }\n\n    function getRawPendingAmount(Loan loan) internal returns (uint256) {\n        return safeSubtract(safeAdd(safeAdd(loan.amount, loan.interest), loan.punitoryInterest), loan.paid);\n    }\n\n    /**\n        @dev Calculates the interest of a given amount, interest rate and delta time.\n\n        @param timeDelta Elapsed time\n        @param interestRate Interest rate expressed as the denominator of 10 000 000.\n        @param amount Amount to apply interest\n\n        @return realDelta The real timeDelta applied\n        @return interest The interest gained in the realDelta time\n    */\n    function calculateInterest(uint256 timeDelta, uint256 interestRate, uint256 amount) public constant returns (uint256 realDelta, uint256 interest) {\n        if (amount == 0) {\n            interest = 0;\n            realDelta = timeDelta;\n        } else {\n            interest = safeMult(safeMult(100000, amount), timeDelta) / interestRate;\n            realDelta = safeMult(interest, interestRate) / (amount * 100000);\n        }\n    }\n\n    /**\n        @dev Computes loan interest\n\n        Computes the punitory and non-punitory interest of a given loan and only applies the change.\n        \n        @param loan Loan to compute interest\n        @param timestamp Target absolute unix time to calculate interest.\n    */\n    function internalAddInterest(Loan storage loan, uint256 timestamp) internal {\n        if (timestamp > loan.interestTimestamp) {\n            uint256 newInterest = loan.interest;\n            uint256 newPunitoryInterest = loan.punitoryInterest;\n\n            uint256 newTimestamp;\n            uint256 realDelta;\n            uint256 calculatedInterest;\n\n            uint256 deltaTime;\n            uint256 pending;\n\n            uint256 endNonPunitory = min(timestamp, loan.dueTime);\n            if (endNonPunitory > loan.interestTimestamp) {\n                deltaTime = endNonPunitory - loan.interestTimestamp;\n\n                if (loan.paid < loan.amount) {\n                    pending = loan.amount - loan.paid;\n                } else {\n                    pending = 0;\n                }\n\n                (realDelta, calculatedInterest) = calculateInterest(deltaTime, loan.interestRate, pending);\n                newInterest = safeAdd(calculatedInterest, newInterest);\n                newTimestamp = loan.interestTimestamp + realDelta;\n            }\n\n            if (timestamp > loan.dueTime) {\n                uint256 startPunitory = max(loan.dueTime, loan.interestTimestamp);\n                deltaTime = timestamp - startPunitory;\n\n                uint256 debt = safeAdd(loan.amount, newInterest);\n                pending = min(debt, safeSubtract(safeAdd(debt, newPunitoryInterest), loan.paid));\n\n                (realDelta, calculatedInterest) = calculateInterest(deltaTime, loan.interestRatePunitory, pending);\n                newPunitoryInterest = safeAdd(newPunitoryInterest, calculatedInterest);\n                newTimestamp = startPunitory + realDelta;\n            }\n            \n            if (newInterest != loan.interest || newPunitoryInterest != loan.punitoryInterest) {\n                loan.interestTimestamp = newTimestamp;\n                loan.interest = newInterest;\n                loan.punitoryInterest = newPunitoryInterest;\n            }\n        }\n    }\n\n    /**\n        @dev Computes loan interest only up to current unix time\n\n        @param timestamp Target absolute unix time to calculate interest.\n    */\n    function addInterestUpTo(Loan storage loan, uint256 timestamp) internal {\n        require(loan.status == Status.lent);\n        if (timestamp <= block.timestamp) {\n            internalAddInterest(loan, timestamp);\n        }\n    }\n\n    /**\n        @dev Updates the loan accumulated interests up to the current Unix time.\n        \n        @param index Index of the loan\n    */\n    function addInterest(uint index) public {\n        Loan storage loan = loans[index];\n        addInterestUpTo(loan, block.timestamp);\n    }\n    \n    /**\n        @dev Pay loan\n\n        Realizes a payment of a given Loan, before performing the payment the accumulated\n        interest is computed and added to the total pending amount.\n\n        Before calling this function, the msg.sender must call the \"approve\" function on the RCN Token, specifying an amount\n        sufficient enough to pay the equivalent of the desired payment and the oracle fee.\n\n        Because it is difficult or even impossible to know in advance how much RCN are going to be spent on the\n        transaction*, we recommend performing the \"approve\" using an amount 5% superior to the wallet estimated\n        spending. If the RCN spent results to be less, the extra tokens are never debited from the msg.sender.\n\n        * The RCN rate can fluctuate on the same block, and it is impossible to know in advance the exact time of the\n        confirmation of the transaction. \n\n        If the paid pending amount equals zero, the loan changes status to \"paid\" and it is considered closed.\n\n        @param index Index of the loan\n        @param _amount Amount to pay, specified in the loan currency; or in RCN if the loan has no oracle\n        @param _from The identity of the payer\n        @param oracleData Data required by the oracle to return the rate, the content of this field must be provided\n            by the url exposed in the url() method of the oracle.\n            \n        @return true if the payment was executed successfully\n    */\n    function pay(uint index, uint256 _amount, address _from, bytes oracleData) public returns (bool) {\n        Loan storage loan = loans[index];\n\n        require(loan.status == Status.lent);\n        addInterest(index);\n        uint256 toPay = min(getPendingAmount(index), _amount);\n        PartialPayment(index, msg.sender, _from, toPay);\n\n        loan.paid = safeAdd(loan.paid, toPay);\n\n        if (getRawPendingAmount(loan) == 0) {\n            TotalPayment(index);\n            loan.status = Status.paid;\n\n            // ERC721, remove loan from circulation\n            lendersBalance[loan.lender] -= 1;\n            activeLoans -= 1;\n            Transfer(loan.lender, 0x0, index);\n        }\n\n        uint256 rate = getRate(loan, oracleData);\n        uint256 transferValue = safeMult(toPay, rate);\n        lockTokens(rcn, transferValue);\n        require(rcn.transferFrom(msg.sender, this, transferValue));\n        loan.lenderBalance = safeAdd(transferValue, loan.lenderBalance);\n\n        return true;\n    }\n\n    /**\n        @dev Retrieves the rate corresponding of the loan oracle, if the loan has no oracle the rate is 1\n\n        @param loan The loan with the cosigner\n        @param data Data required by the oracle\n\n        @return The rate of the oracle\n    */\n    function getRate(Loan loan, bytes data) internal returns (uint256) {\n        if (loan.oracle == address(0)) {\n            return 1;\n        } else {\n            return loan.oracle.getRate(loan.currency, data);\n        }\n    }\n\n    /**\n        @dev Withdraw lender funds\n\n        When a loan is paid, the funds are not transferred automatically to the lender, the funds are stored on the\n        engine contract, and the lender must call this function specifying the amount desired to transfer and the \n        destination.\n\n        This behavior is defined to allow the temporary transfer of the loan to a smart contract, without worrying that\n        the contract will receive tokens that are not traceable; and it allows the development of decentralized \n        autonomous organizations.\n\n        @param index Index of the loan\n        @param to Destination of the wiwthdraw funds\n        @param amount Amount to withdraw, in RCN\n\n        @return true if the withdraw was executed successfully\n    */\n    function withdrawal(uint index, address to, uint256 amount) public returns (bool) {\n        Loan storage loan = loans[index];\n        require(msg.sender == loan.lender);\n        loan.lenderBalance = safeSubtract(loan.lenderBalance, amount);\n        require(rcn.transfer(to, amount));\n        unlockTokens(rcn, amount);\n        return true;\n    }\n\n    function withdrawalRange(uint256 fromIndex, uint256 toIndex, address to) public returns (uint256) {\n        uint256 loanId;\n        uint256 totalWithdraw = 0;\n\n        for (loanId = fromIndex; loanId <= toIndex; loanId++) {\n            Loan storage loan = loans[loanId];\n            if (loan.lender == msg.sender) {\n                totalWithdraw += loan.lenderBalance;\n                loan.lenderBalance = 0;\n            }\n        }\n\n        require(rcn.transfer(to, totalWithdraw));\n        unlockTokens(rcn, totalWithdraw);\n        \n        return totalWithdraw;\n    }\n\n    function withdrawalList(uint256[] memory loanIds, address to) public returns (uint256) {\n        uint256 inputId;\n        uint256 totalWithdraw = 0;\n\n        for (inputId = 0; inputId < loanIds.length; inputId++) {\n            Loan storage loan = loans[loanIds[inputId]];\n            if (loan.lender == msg.sender) {\n                totalWithdraw += loan.lenderBalance;\n                loan.lenderBalance = 0;\n            }\n        }\n\n        require(rcn.transfer(to, totalWithdraw));\n        unlockTokens(rcn, totalWithdraw);\n\n        return totalWithdraw;\n    }\n\n    /**\n        @dev Deprecates the engine, locks the creation of new loans.\n    */\n    function setDeprecated(bool _deprecated) public onlyOwner {\n        deprecated = _deprecated;\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinfabrik-RCN Network Smart Contract Audit/rcn-network-3ded36151ad55543d16c354e70161852de4061d0/contracts/NanoLoanEngine.sol",
        "vulnerability": "Assertion Failure",
        "check": "FP",
        "response": "Answer: Yes\nDescription: Possible usage of assert or require statements without appropriate error handling in several functions, such as `tokenOfOwnerByIndex`, which may cause the transaction to be reverted unexpectedly."
    },
    {
        "code_segment": "contract NanoLoanEngine is ERC721, Engine, Ownable, TokenLockable {\n    uint256 public constant VERSION = 202;\n    string public constant VERSION_NAME = \"Basalt\";\n\n    uint256 private activeLoans = 0;\n    mapping(address => uint256) private lendersBalance;\n\n    function name() constant returns (string _name) {\n        _name = \"RCN - Nano loan engine - Basalt 202\";\n    }\n\n    function symbol() constant returns (string _symbol) {\n        _symbol = \"RCN-NLE-202\";\n    }\n\n    function totalSupply() constant returns (uint _totalSupply) {\n        _totalSupply = activeLoans;\n    }\n\n    function balanceOf(address _owner) constant returns (uint _balance) {\n        _balance = lendersBalance[_owner];\n    }\n\n    function tokenOfOwnerByIndex(address _owner, uint256 _index) constant returns (uint tokenId) {\n        uint256 tokenCount = balanceOf(_owner);\n\n        if (tokenCount == 0 || _index >= tokenCount) {\n            // Fail transaction\n            revert();\n        } else {\n            uint256 totalLoans = totalSupply();\n            uint256 resultIndex = 0;\n\n            uint256 loanId;\n            // SWC-128-DoS With Block Gas Limit: L46\n            for (loanId = 0; loanId <= totalLoans; loanId++) {\n                if (loans[loanId].lender == _owner && loans[loanId].status == Status.lent) {\n                    if (resultIndex == _index) {\n                        return loanId;\n                    }\n                    resultIndex++;\n                }\n            }\n\n            revert();\n        }\n    }\n\n    function tokensOfOwner(address _owner) external constant returns(uint256[] ownerTokens) {\n        uint256 tokenCount = balanceOf(_owner);\n\n        if (tokenCount == 0) {\n            // Return an empty array\n            return new uint256[](0);\n        } else {\n            uint256[] memory result = new uint256[](tokenCount);\n            uint256 totalLoans = totalSupply();\n            uint256 resultIndex = 0;\n\n            uint256 loanId;\n\n            for (loanId = 0; loanId <= totalLoans; loanId++) {\n                if (loans[loanId].lender == _owner && loans[loanId].status == Status.lent) {\n                    result[resultIndex] = loanId;\n                    resultIndex++;\n                }\n            }\n\n            return result;\n        }\n    }\n    \n    Token public rcn;\n    bool public deprecated;\n\n    event CreatedLoan(uint _index, address _borrower, address _creator);\n    event ApprovedBy(uint _index, address _address);\n    event Lent(uint _index, address _lender, address _cosigner);\n    event DestroyedBy(uint _index, address _address);\n    event PartialPayment(uint _index, address _sender, address _from, uint256 _amount);\n    event TotalPayment(uint _index);\n\n    function NanoLoanEngine(Token _rcn) public {\n        owner = msg.sender;\n        rcn = _rcn;\n    }\n\n    struct Loan {\n        Status status;\n        Oracle oracle;\n\n        address borrower;\n        address lender;\n        address creator;\n        address cosigner;\n        \n        uint256 amount;\n        uint256 interest;\n        uint256 punitoryInterest;\n        uint256 interestTimestamp;\n        uint256 paid;\n        uint256 interestRate;\n        uint256 interestRatePunitory;\n        uint256 dueTime;\n        uint256 duesIn;\n\n        bytes32 currency;\n        uint256 cancelableAt;\n        uint256 lenderBalance;\n\n        address approvedTransfer;\n        uint256 expirationRequest;\n\n        mapping(address => bool) approbations;\n    }\n\n    Loan[] private loans;\n\n    /**\n        @dev Creates a loan request, the loan can be generated with any borrower, cosigner, and conditions; if the \n        cosigner and borrower agree they must call the \"approve\" function.\n\n        The creator of the loan is the caller of this function; this is useful to track which wallet created the loan.\n\n        @param _oracleContract Address of the Oracle contract, if the loan does not use any oracle, this field should be 0x0.\n        @param _borrower Address of the borrower\n        @param _currency The currency to use with the oracle, the currency code is generated with the following formula,\n            keccak256(ticker,decimals).\n        @param _amount The requested amount; currency and unit are defined by the Oracle, if there is no Oracle present\n            the currency is RCN, and the unit is wei.\n        @param _interestRate The non-punitory interest rate by second, defined as a denominator of 10 000 000.\n        @param _interestRatePunitory The punitory interest rate by second, defined as a denominator of 10 000 000.\n            Ej: interestRate 11108571428571 = 28% Anual interest\n        @param _duesIn The time in seconds that the borrower has in order to pay the debt after the lender lends the money.\n        @param _cancelableAt Delta in seconds specifying how much interest should be added in advance, if the borrower pays \n        entirely or partially the loan before this term, no extra interest will be deducted.\n        @param _expirationRequest Timestamp of when the loan request expires, if the loan is not filled before this date, \n            the request is no longer valid.\n    */\n    function createLoan(Oracle _oracleContract, address _borrower, bytes32 _currency, uint256 _amount, uint256 _interestRate,\n        uint256 _interestRatePunitory, uint256 _duesIn, uint256 _cancelableAt, uint256 _expirationRequest) returns (uint256) {\n\n        require(!deprecated);\n        require(_cancelableAt <= _duesIn);\n        require(_oracleContract != address(0) || _currency == 0x0);\n        require(_borrower != address(0));\n        require(_amount != 0);\n        require(_interestRatePunitory != 0);\n        require(_interestRate != 0);\n        require(_expirationRequest > block.timestamp);\n\n        var loan = Loan(Status.initial, _oracleContract, _borrower, 0x0, msg.sender, 0x0, _amount, 0, 0, 0, 0, _interestRate,\n            _interestRatePunitory, 0, _duesIn, _currency, _cancelableAt, 0, 0x0, _expirationRequest);\n        uint index = loans.push(loan) - 1;\n        CreatedLoan(index, _borrower, msg.sender);\n\n        if (msg.sender == _borrower) {\n            approveLoan(index);\n        }\n\n        return index;\n    }\n    \n    function ownerOf(uint256 index) constant returns (address owner) { owner = loans[index].lender; }\n    function getTotalLoans() constant returns (uint256) { return loans.length; }\n    function getOracle(uint index) constant returns (Oracle) { return loans[index].oracle; }\n    function getBorrower(uint index) constant returns (address) { return loans[index].borrower; }\n    function getCosigner(uint index) constant returns (address) { return loans[index].cosigner; }\n    function getCreator(uint index) constant returns (address) { return loans[index].creator; }\n    function getAmount(uint index) constant returns (uint256) { return loans[index].amount; }\n    function getPunitoryInterest(uint index) constant returns (uint256) { return loans[index].punitoryInterest; }\n    function getInterestTimestamp(uint index) constant returns (uint256) { return loans[index].interestTimestamp; }\n    function getPaid(uint index) constant returns (uint256) { return loans[index].paid; }\n    function getInterestRate(uint index) constant returns (uint256) { return loans[index].interestRate; }\n    function getInterestRatePunitory(uint index) constant returns (uint256) { return loans[index].interestRatePunitory; }\n    function getDueTime(uint index) constant returns (uint256) { return loans[index].dueTime; }\n    function getDuesIn(uint index) constant returns (uint256) { return loans[index].duesIn; }\n    function getCancelableAt(uint index) constant returns (uint256) { return loans[index].cancelableAt; }\n    function getApprobation(uint index, address _address) constant returns (bool) { return loans[index].approbations[_address]; }\n    function getStatus(uint index) constant returns (Status) { return loans[index].status; }\n    function getLenderBalance(uint index) constant returns (uint256) { return loans[index].lenderBalance; }\n    function getApprovedTransfer(uint index) constant returns (address) {return loans[index].approvedTransfer; }\n    function getCurrency(uint index) constant returns (bytes32) { return loans[index].currency; }\n    function getExpirationRequest(uint index) constant returns (uint256) { return loans[index].expirationRequest; }\n    function getInterest(uint index) constant returns (uint256) { return loans[index].interest; }\n\n    /**\n        @param index Index of the loan\n\n        @return true if the loan has been approved by the borrower and cosigner.\n    */\n    function isApproved(uint index) constant returns (bool) {\n        Loan storage loan = loans[index];\n        return loan.approbations[loan.borrower];\n    }\n\n    /**\n        @dev Called by the members of the loan to show that they agree with the terms of the loan; the borrower\n        must call this method before any lender could call the method \"lend\".\n            \n        Any address can call this method to be added to the \"approbations\" mapping.\n\n        @param index Index of the loan\n\n        @return true if the approve was done successfully\n    */\n    function approveLoan(uint index) public returns(bool) {\n        Loan storage loan = loans[index];\n        require(loan.status == Status.initial);\n        loan.approbations[msg.sender] = true;\n        ApprovedBy(index, msg.sender);\n        return true;\n    }\n\n    /**\n        @dev Performs the lend of the RCN equivalent to the requested amount, and transforms the msg.sender in the new lender.\n\n        The loan must be previously approved by the borrower; before calling this function, the lender candidate must \n        call the \"approve\" function on the RCN Token, specifying an amount sufficient enough to pay the equivalent of\n        the requested amount, and the cosigner fee.\n        \n        @param index Index of the loan\n        @param oracleData Data required by the oracle to return the rate, the content of this field must be provided\n            by the url exposed in the url() method of the oracle.\n        @param cosigner Address of the cosigner, 0x0 for lending without cosigner.\n        @param cosignerData Data required by the cosigner to process the request.\n\n        @return true if the lend was done successfully\n    */\n    function lend(uint index, bytes oracleData, Cosigner cosigner, bytes cosignerData) public returns (bool) {\n        Loan storage loan = loans[index];\n\n        require(loan.status == Status.initial);\n        require(isApproved(index));\n        require(block.timestamp <= loan.expirationRequest);\n\n        loan.lender = msg.sender;\n        loan.dueTime = safeAdd(block.timestamp, loan.duesIn);\n        loan.interestTimestamp = block.timestamp;\n        loan.status = Status.lent;\n        \n        if (loan.cancelableAt > 0)\n            internalAddInterest(loan, safeAdd(block.timestamp, loan.cancelableAt));\n\n        uint256 rate = getRate(loan, oracleData);\n\n        if (cosigner != address(0)) {\n            // The cosigner it's temporary set to the next address (cosigner + 2), it's expected that the cosigner will\n            // call the method \"cosign\" to accept the conditions; that method also sets the cosigner to the right\n            // address. If that does not happen, the transaction fails.\n            loan.cosigner = address(uint256(cosigner) + 2);\n            require(cosigner.requestCosign(this, index, cosignerData, oracleData));\n            require(loan.cosigner == address(cosigner));\n        }\n        \n        require(rcn.transferFrom(msg.sender, loan.borrower, safeMult(loan.amount, rate)));\n        \n        // ERC721, create new loan and transfer it to the lender\n        Transfer(0x0, loan.lender, index);\n        activeLoans += 1;\n        lendersBalance[loan.lender] += 1;\n        Lent(index, loan.lender, cosigner);\n\n        return true;\n    }\n\n    /**\n        @dev The cosigner must call this method to accept the conditions of a loan, this method pays the cosigner his fee\n\n        @param index Index of the loan\n        @param cost Fee set by the cosigner\n\n        @return true If the cosign was successfull\n    */\n    function cosign(uint index, uint256 cost) external returns (bool) {\n        Loan storage loan = loans[index];\n        require(loan.status == Status.lent && (loan.dueTime - loan.duesIn) == block.timestamp);\n        require(loan.cosigner != address(0));\n        require(loan.cosigner == address(uint256(msg.sender) + 2));\n        loan.cosigner = msg.sender;\n        require(rcn.transferFrom(loan.lender, msg.sender, cost));\n        return true;\n    }\n\n    /**\n        @dev Destroys a loan, the borrower could call this method if they performed an accidental or regretted \n        \"approve\" of the loan, this method only works for them if the loan is in \"pending\" status.\n\n        The lender can call this method at any moment, in case of a loan with status \"lent\" the lender is pardoning \n        the debt. \n\n        @param index Index of the loan\n\n        @return true if the destroy was done successfully\n    */\n    function destroy(uint index) public returns (bool) {\n        Loan storage loan = loans[index];\n        require(loan.status != Status.destroyed);\n        require(msg.sender == loan.lender || (msg.sender == loan.borrower && loan.status == Status.initial));\n        DestroyedBy(index, msg.sender);\n\n        // ERC721, remove loan from circulation\n        if (loan.status != Status.initial) {\n            lendersBalance[loan.lender] -= 1;\n            activeLoans -= 1;\n            Transfer(loan.lender, 0x0, index);\n        }\n\n        loan.status = Status.destroyed;\n        return true;\n    }\n\n    /**\n        @dev Transfers a loan to a different lender, the caller must be the current lender or previously being\n        approved with the method \"approveTransfer\"; only loans with the Status.lent status can be transfered.\n\n        @param index Index of the loan\n        @param to New lender\n\n        @return true if the transfer was done successfully\n    */\n    function transfer(address to, uint256 index) public returns (bool) {\n        Loan storage loan = loans[index];\n        \n        require(loan.status != Status.destroyed && loan.status != Status.paid);\n        require(msg.sender == loan.lender || msg.sender == loan.approvedTransfer);\n        require(to != address(0));\n        loan.lender = to;\n        loan.approvedTransfer = address(0);\n\n        // ERC721, transfer loan to another address\n        lendersBalance[msg.sender] -= 1;\n        lendersBalance[to] += 1;\n        Transfer(loan.lender, to, index);\n\n        return true;\n    }\n\n    /**\n        @dev ERC721 method, transfers the loan to the msg.sender, the msg.sender must be approved using the \n        \"approve\" method.\n\n        @return true if the transfer was successfull\n    */\n    function takeOwnership(uint256 _index) public returns (bool) {\n        return transfer(msg.sender, _index);\n    }\n\n    /**\n        @dev Approves the transfer of a given loan in the name of the lender, the behavior of this function is similar to\n        \"approve\" in the ERC20 standard, but only one approved address is allowed at a time.\n\n        The same method can be called passing 0x0 as parameter \"to\" to erase a previously approved address.\n\n        @param to Address allowed to transfer the loan or 0x0 to delete\n        @param index Index of the loan\n\n        @return true if the approve was done successfully\n    */\n    function approve(address to, uint256 index) public returns (bool) {\n        Loan storage loan = loans[index];\n        require(msg.sender == loan.lender);\n        loan.approvedTransfer = to;\n        Approval(msg.sender, to, index);\n        return true;\n    }\n\n    /**\n        @dev Returns the pending amount to complete de payment of the loan, keep in mind that this number increases \n        every second.\n\n        @param index Index of the loan\n\n        @return Aprox pending payment amount\n    */\n    function getPendingAmount(uint index) public constant returns (uint256) {\n        Loan storage loan = loans[index];\n        addInterest(index);\n        return getRawPendingAmount(loan);\n    }\n\n    function getRawPendingAmount(Loan loan) internal returns (uint256) {\n        return safeSubtract(safeAdd(safeAdd(loan.amount, loan.interest), loan.punitoryInterest), loan.paid);\n    }\n\n    /**\n        @dev Calculates the interest of a given amount, interest rate and delta time.\n\n        @param timeDelta Elapsed time\n        @param interestRate Interest rate expressed as the denominator of 10 000 000.\n        @param amount Amount to apply interest\n\n        @return realDelta The real timeDelta applied\n        @return interest The interest gained in the realDelta time\n    */\n    function calculateInterest(uint256 timeDelta, uint256 interestRate, uint256 amount) public constant returns (uint256 realDelta, uint256 interest) {\n        if (amount == 0) {\n            interest = 0;\n            realDelta = timeDelta;\n        } else {\n            interest = safeMult(safeMult(100000, amount), timeDelta) / interestRate;\n            realDelta = safeMult(interest, interestRate) / (amount * 100000);\n        }\n    }\n\n    /**\n        @dev Computes loan interest\n\n        Computes the punitory and non-punitory interest of a given loan and only applies the change.\n        \n        @param loan Loan to compute interest\n        @param timestamp Target absolute unix time to calculate interest.\n    */\n    function internalAddInterest(Loan storage loan, uint256 timestamp) internal {\n        if (timestamp > loan.interestTimestamp) {\n            uint256 newInterest = loan.interest;\n            uint256 newPunitoryInterest = loan.punitoryInterest;\n\n            uint256 newTimestamp;\n            uint256 realDelta;\n            uint256 calculatedInterest;\n\n            uint256 deltaTime;\n            uint256 pending;\n\n            uint256 endNonPunitory = min(timestamp, loan.dueTime);\n            if (endNonPunitory > loan.interestTimestamp) {\n                deltaTime = endNonPunitory - loan.interestTimestamp;\n\n                if (loan.paid < loan.amount) {\n                    pending = loan.amount - loan.paid;\n                } else {\n                    pending = 0;\n                }\n\n                (realDelta, calculatedInterest) = calculateInterest(deltaTime, loan.interestRate, pending);\n                newInterest = safeAdd(calculatedInterest, newInterest);\n                newTimestamp = loan.interestTimestamp + realDelta;\n            }\n\n            if (timestamp > loan.dueTime) {\n                uint256 startPunitory = max(loan.dueTime, loan.interestTimestamp);\n                deltaTime = timestamp - startPunitory;\n\n                uint256 debt = safeAdd(loan.amount, newInterest);\n                pending = min(debt, safeSubtract(safeAdd(debt, newPunitoryInterest), loan.paid));\n\n                (realDelta, calculatedInterest) = calculateInterest(deltaTime, loan.interestRatePunitory, pending);\n                newPunitoryInterest = safeAdd(newPunitoryInterest, calculatedInterest);\n                newTimestamp = startPunitory + realDelta;\n            }\n            \n            if (newInterest != loan.interest || newPunitoryInterest != loan.punitoryInterest) {\n                loan.interestTimestamp = newTimestamp;\n                loan.interest = newInterest;\n                loan.punitoryInterest = newPunitoryInterest;\n            }\n        }\n    }\n\n    /**\n        @dev Computes loan interest only up to current unix time\n\n        @param timestamp Target absolute unix time to calculate interest.\n    */\n    function addInterestUpTo(Loan storage loan, uint256 timestamp) internal {\n        require(loan.status == Status.lent);\n        if (timestamp <= block.timestamp) {\n            internalAddInterest(loan, timestamp);\n        }\n    }\n\n    /**\n        @dev Updates the loan accumulated interests up to the current Unix time.\n        \n        @param index Index of the loan\n    */\n    function addInterest(uint index) public {\n        Loan storage loan = loans[index];\n        addInterestUpTo(loan, block.timestamp);\n    }\n    \n    /**\n        @dev Pay loan\n\n        Realizes a payment of a given Loan, before performing the payment the accumulated\n        interest is computed and added to the total pending amount.\n\n        Before calling this function, the msg.sender must call the \"approve\" function on the RCN Token, specifying an amount\n        sufficient enough to pay the equivalent of the desired payment and the oracle fee.\n\n        Because it is difficult or even impossible to know in advance how much RCN are going to be spent on the\n        transaction*, we recommend performing the \"approve\" using an amount 5% superior to the wallet estimated\n        spending. If the RCN spent results to be less, the extra tokens are never debited from the msg.sender.\n\n        * The RCN rate can fluctuate on the same block, and it is impossible to know in advance the exact time of the\n        confirmation of the transaction. \n\n        If the paid pending amount equals zero, the loan changes status to \"paid\" and it is considered closed.\n\n        @param index Index of the loan\n        @param _amount Amount to pay, specified in the loan currency; or in RCN if the loan has no oracle\n        @param _from The identity of the payer\n        @param oracleData Data required by the oracle to return the rate, the content of this field must be provided\n            by the url exposed in the url() method of the oracle.\n            \n        @return true if the payment was executed successfully\n    */\n    function pay(uint index, uint256 _amount, address _from, bytes oracleData) public returns (bool) {\n        Loan storage loan = loans[index];\n\n        require(loan.status == Status.lent);\n        addInterest(index);\n        uint256 toPay = min(getPendingAmount(index), _amount);\n        PartialPayment(index, msg.sender, _from, toPay);\n\n        loan.paid = safeAdd(loan.paid, toPay);\n\n        if (getRawPendingAmount(loan) == 0) {\n            TotalPayment(index);\n            loan.status = Status.paid;\n\n            // ERC721, remove loan from circulation\n            lendersBalance[loan.lender] -= 1;\n            activeLoans -= 1;\n            Transfer(loan.lender, 0x0, index);\n        }\n\n        uint256 rate = getRate(loan, oracleData);\n        uint256 transferValue = safeMult(toPay, rate);\n        lockTokens(rcn, transferValue);\n        require(rcn.transferFrom(msg.sender, this, transferValue));\n        loan.lenderBalance = safeAdd(transferValue, loan.lenderBalance);\n\n        return true;\n    }\n\n    /**\n        @dev Retrieves the rate corresponding of the loan oracle, if the loan has no oracle the rate is 1\n\n        @param loan The loan with the cosigner\n        @param data Data required by the oracle\n\n        @return The rate of the oracle\n    */\n    function getRate(Loan loan, bytes data) internal returns (uint256) {\n        if (loan.oracle == address(0)) {\n            return 1;\n        } else {\n            return loan.oracle.getRate(loan.currency, data);\n        }\n    }\n\n    /**\n        @dev Withdraw lender funds\n\n        When a loan is paid, the funds are not transferred automatically to the lender, the funds are stored on the\n        engine contract, and the lender must call this function specifying the amount desired to transfer and the \n        destination.\n\n        This behavior is defined to allow the temporary transfer of the loan to a smart contract, without worrying that\n        the contract will receive tokens that are not traceable; and it allows the development of decentralized \n        autonomous organizations.\n\n        @param index Index of the loan\n        @param to Destination of the wiwthdraw funds\n        @param amount Amount to withdraw, in RCN\n\n        @return true if the withdraw was executed successfully\n    */\n    function withdrawal(uint index, address to, uint256 amount) public returns (bool) {\n        Loan storage loan = loans[index];\n        require(msg.sender == loan.lender);\n        loan.lenderBalance = safeSubtract(loan.lenderBalance, amount);\n        require(rcn.transfer(to, amount));\n        unlockTokens(rcn, amount);\n        return true;\n    }\n\n    function withdrawalRange(uint256 fromIndex, uint256 toIndex, address to) public returns (uint256) {\n        uint256 loanId;\n        uint256 totalWithdraw = 0;\n\n        for (loanId = fromIndex; loanId <= toIndex; loanId++) {\n            Loan storage loan = loans[loanId];\n            if (loan.lender == msg.sender) {\n                totalWithdraw += loan.lenderBalance;\n                loan.lenderBalance = 0;\n            }\n        }\n\n        require(rcn.transfer(to, totalWithdraw));\n        unlockTokens(rcn, totalWithdraw);\n        \n        return totalWithdraw;\n    }\n\n    function withdrawalList(uint256[] memory loanIds, address to) public returns (uint256) {\n        uint256 inputId;\n        uint256 totalWithdraw = 0;\n\n        for (inputId = 0; inputId < loanIds.length; inputId++) {\n            Loan storage loan = loans[loanIds[inputId]];\n            if (loan.lender == msg.sender) {\n                totalWithdraw += loan.lenderBalance;\n                loan.lenderBalance = 0;\n            }\n        }\n\n        require(rcn.transfer(to, totalWithdraw));\n        unlockTokens(rcn, totalWithdraw);\n\n        return totalWithdraw;\n    }\n\n    /**\n        @dev Deprecates the engine, locks the creation of new loans.\n    */\n    function setDeprecated(bool _deprecated) public onlyOwner {\n        deprecated = _deprecated;\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinfabrik-RCN Network Smart Contract Audit/rcn-network-3ded36151ad55543d16c354e70161852de4061d0/contracts/NanoLoanEngine.sol",
        "vulnerability": "Assertion Failure",
        "check": "FP",
        "response": "Answer: No\nReason: The code does not perform any explicit assertions; it relies on conditional checks and reverts to handle errors."
    },
    {
        "code_segment": "contract NanoLoanEngine is ERC721, Engine, Ownable, TokenLockable {\n    uint256 public constant VERSION = 202;\n    string public constant VERSION_NAME = \"Basalt\";\n\n    uint256 private activeLoans = 0;\n    mapping(address => uint256) private lendersBalance;\n\n    function name() constant returns (string _name) {\n        _name = \"RCN - Nano loan engine - Basalt 202\";\n    }\n\n    function symbol() constant returns (string _symbol) {\n        _symbol = \"RCN-NLE-202\";\n    }\n\n    function totalSupply() constant returns (uint _totalSupply) {\n        _totalSupply = activeLoans;\n    }\n\n    function balanceOf(address _owner) constant returns (uint _balance) {\n        _balance = lendersBalance[_owner];\n    }\n\n    function tokenOfOwnerByIndex(address _owner, uint256 _index) constant returns (uint tokenId) {\n        uint256 tokenCount = balanceOf(_owner);\n\n        if (tokenCount == 0 || _index >= tokenCount) {\n            // Fail transaction\n            revert();\n        } else {\n            uint256 totalLoans = totalSupply();\n            uint256 resultIndex = 0;\n\n            uint256 loanId;\n            // SWC-128-DoS With Block Gas Limit: L46\n            for (loanId = 0; loanId <= totalLoans; loanId++) {\n                if (loans[loanId].lender == _owner && loans[loanId].status == Status.lent) {\n                    if (resultIndex == _index) {\n                        return loanId;\n                    }\n                    resultIndex++;\n                }\n            }\n\n            revert();\n        }\n    }\n\n    function tokensOfOwner(address _owner) external constant returns(uint256[] ownerTokens) {\n        uint256 tokenCount = balanceOf(_owner);\n\n        if (tokenCount == 0) {\n            // Return an empty array\n            return new uint256[](0);\n        } else {\n            uint256[] memory result = new uint256[](tokenCount);\n            uint256 totalLoans = totalSupply();\n            uint256 resultIndex = 0;\n\n            uint256 loanId;\n\n            for (loanId = 0; loanId <= totalLoans; loanId++) {\n                if (loans[loanId].lender == _owner && loans[loanId].status == Status.lent) {\n                    result[resultIndex] = loanId;\n                    resultIndex++;\n                }\n            }\n\n            return result;\n        }\n    }\n    \n    Token public rcn;\n    bool public deprecated;\n\n    event CreatedLoan(uint _index, address _borrower, address _creator);\n    event ApprovedBy(uint _index, address _address);\n    event Lent(uint _index, address _lender, address _cosigner);\n    event DestroyedBy(uint _index, address _address);\n    event PartialPayment(uint _index, address _sender, address _from, uint256 _amount);\n    event TotalPayment(uint _index);\n\n    function NanoLoanEngine(Token _rcn) public {\n        owner = msg.sender;\n        rcn = _rcn;\n    }\n\n    struct Loan {\n        Status status;\n        Oracle oracle;\n\n        address borrower;\n        address lender;\n        address creator;\n        address cosigner;\n        \n        uint256 amount;\n        uint256 interest;\n        uint256 punitoryInterest;\n        uint256 interestTimestamp;\n        uint256 paid;\n        uint256 interestRate;\n        uint256 interestRatePunitory;\n        uint256 dueTime;\n        uint256 duesIn;\n\n        bytes32 currency;\n        uint256 cancelableAt;\n        uint256 lenderBalance;\n\n        address approvedTransfer;\n        uint256 expirationRequest;\n\n        mapping(address => bool) approbations;\n    }\n\n    Loan[] private loans;\n\n    /**\n        @dev Creates a loan request, the loan can be generated with any borrower, cosigner, and conditions; if the \n        cosigner and borrower agree they must call the \"approve\" function.\n\n        The creator of the loan is the caller of this function; this is useful to track which wallet created the loan.\n\n        @param _oracleContract Address of the Oracle contract, if the loan does not use any oracle, this field should be 0x0.\n        @param _borrower Address of the borrower\n        @param _currency The currency to use with the oracle, the currency code is generated with the following formula,\n            keccak256(ticker,decimals).\n        @param _amount The requested amount; currency and unit are defined by the Oracle, if there is no Oracle present\n            the currency is RCN, and the unit is wei.\n        @param _interestRate The non-punitory interest rate by second, defined as a denominator of 10 000 000.\n        @param _interestRatePunitory The punitory interest rate by second, defined as a denominator of 10 000 000.\n            Ej: interestRate 11108571428571 = 28% Anual interest\n        @param _duesIn The time in seconds that the borrower has in order to pay the debt after the lender lends the money.\n        @param _cancelableAt Delta in seconds specifying how much interest should be added in advance, if the borrower pays \n        entirely or partially the loan before this term, no extra interest will be deducted.\n        @param _expirationRequest Timestamp of when the loan request expires, if the loan is not filled before this date, \n            the request is no longer valid.\n    */\n    function createLoan(Oracle _oracleContract, address _borrower, bytes32 _currency, uint256 _amount, uint256 _interestRate,\n        uint256 _interestRatePunitory, uint256 _duesIn, uint256 _cancelableAt, uint256 _expirationRequest) returns (uint256) {\n\n        require(!deprecated);\n        require(_cancelableAt <= _duesIn);\n        require(_oracleContract != address(0) || _currency == 0x0);\n        require(_borrower != address(0));\n        require(_amount != 0);\n        require(_interestRatePunitory != 0);\n        require(_interestRate != 0);\n        require(_expirationRequest > block.timestamp);\n\n        var loan = Loan(Status.initial, _oracleContract, _borrower, 0x0, msg.sender, 0x0, _amount, 0, 0, 0, 0, _interestRate,\n            _interestRatePunitory, 0, _duesIn, _currency, _cancelableAt, 0, 0x0, _expirationRequest);\n        uint index = loans.push(loan) - 1;\n        CreatedLoan(index, _borrower, msg.sender);\n\n        if (msg.sender == _borrower) {\n            approveLoan(index);\n        }\n\n        return index;\n    }\n    \n    function ownerOf(uint256 index) constant returns (address owner) { owner = loans[index].lender; }\n    function getTotalLoans() constant returns (uint256) { return loans.length; }\n    function getOracle(uint index) constant returns (Oracle) { return loans[index].oracle; }\n    function getBorrower(uint index) constant returns (address) { return loans[index].borrower; }\n    function getCosigner(uint index) constant returns (address) { return loans[index].cosigner; }\n    function getCreator(uint index) constant returns (address) { return loans[index].creator; }\n    function getAmount(uint index) constant returns (uint256) { return loans[index].amount; }\n    function getPunitoryInterest(uint index) constant returns (uint256) { return loans[index].punitoryInterest; }\n    function getInterestTimestamp(uint index) constant returns (uint256) { return loans[index].interestTimestamp; }\n    function getPaid(uint index) constant returns (uint256) { return loans[index].paid; }\n    function getInterestRate(uint index) constant returns (uint256) { return loans[index].interestRate; }\n    function getInterestRatePunitory(uint index) constant returns (uint256) { return loans[index].interestRatePunitory; }\n    function getDueTime(uint index) constant returns (uint256) { return loans[index].dueTime; }\n    function getDuesIn(uint index) constant returns (uint256) { return loans[index].duesIn; }\n    function getCancelableAt(uint index) constant returns (uint256) { return loans[index].cancelableAt; }\n    function getApprobation(uint index, address _address) constant returns (bool) { return loans[index].approbations[_address]; }\n    function getStatus(uint index) constant returns (Status) { return loans[index].status; }\n    function getLenderBalance(uint index) constant returns (uint256) { return loans[index].lenderBalance; }\n    function getApprovedTransfer(uint index) constant returns (address) {return loans[index].approvedTransfer; }\n    function getCurrency(uint index) constant returns (bytes32) { return loans[index].currency; }\n    function getExpirationRequest(uint index) constant returns (uint256) { return loans[index].expirationRequest; }\n    function getInterest(uint index) constant returns (uint256) { return loans[index].interest; }\n\n    /**\n        @param index Index of the loan\n\n        @return true if the loan has been approved by the borrower and cosigner.\n    */\n    function isApproved(uint index) constant returns (bool) {\n        Loan storage loan = loans[index];\n        return loan.approbations[loan.borrower];\n    }\n\n    /**\n        @dev Called by the members of the loan to show that they agree with the terms of the loan; the borrower\n        must call this method before any lender could call the method \"lend\".\n            \n        Any address can call this method to be added to the \"approbations\" mapping.\n\n        @param index Index of the loan\n\n        @return true if the approve was done successfully\n    */\n    function approveLoan(uint index) public returns(bool) {\n        Loan storage loan = loans[index];\n        require(loan.status == Status.initial);\n        loan.approbations[msg.sender] = true;\n        ApprovedBy(index, msg.sender);\n        return true;\n    }\n\n    /**\n        @dev Performs the lend of the RCN equivalent to the requested amount, and transforms the msg.sender in the new lender.\n\n        The loan must be previously approved by the borrower; before calling this function, the lender candidate must \n        call the \"approve\" function on the RCN Token, specifying an amount sufficient enough to pay the equivalent of\n        the requested amount, and the cosigner fee.\n        \n        @param index Index of the loan\n        @param oracleData Data required by the oracle to return the rate, the content of this field must be provided\n            by the url exposed in the url() method of the oracle.\n        @param cosigner Address of the cosigner, 0x0 for lending without cosigner.\n        @param cosignerData Data required by the cosigner to process the request.\n\n        @return true if the lend was done successfully\n    */\n    function lend(uint index, bytes oracleData, Cosigner cosigner, bytes cosignerData) public returns (bool) {\n        Loan storage loan = loans[index];\n\n        require(loan.status == Status.initial);\n        require(isApproved(index));\n        require(block.timestamp <= loan.expirationRequest);\n\n        loan.lender = msg.sender;\n        loan.dueTime = safeAdd(block.timestamp, loan.duesIn);\n        loan.interestTimestamp = block.timestamp;\n        loan.status = Status.lent;\n        \n        if (loan.cancelableAt > 0)\n            internalAddInterest(loan, safeAdd(block.timestamp, loan.cancelableAt));\n\n        uint256 rate = getRate(loan, oracleData);\n\n        if (cosigner != address(0)) {\n            // The cosigner it's temporary set to the next address (cosigner + 2), it's expected that the cosigner will\n            // call the method \"cosign\" to accept the conditions; that method also sets the cosigner to the right\n            // address. If that does not happen, the transaction fails.\n            loan.cosigner = address(uint256(cosigner) + 2);\n            require(cosigner.requestCosign(this, index, cosignerData, oracleData));\n            require(loan.cosigner == address(cosigner));\n        }\n        \n        require(rcn.transferFrom(msg.sender, loan.borrower, safeMult(loan.amount, rate)));\n        \n        // ERC721, create new loan and transfer it to the lender\n        Transfer(0x0, loan.lender, index);\n        activeLoans += 1;\n        lendersBalance[loan.lender] += 1;\n        Lent(index, loan.lender, cosigner);\n\n        return true;\n    }\n\n    /**\n        @dev The cosigner must call this method to accept the conditions of a loan, this method pays the cosigner his fee\n\n        @param index Index of the loan\n        @param cost Fee set by the cosigner\n\n        @return true If the cosign was successfull\n    */\n    function cosign(uint index, uint256 cost) external returns (bool) {\n        Loan storage loan = loans[index];\n        require(loan.status == Status.lent && (loan.dueTime - loan.duesIn) == block.timestamp);\n        require(loan.cosigner != address(0));\n        require(loan.cosigner == address(uint256(msg.sender) + 2));\n        loan.cosigner = msg.sender;\n        require(rcn.transferFrom(loan.lender, msg.sender, cost));\n        return true;\n    }\n\n    /**\n        @dev Destroys a loan, the borrower could call this method if they performed an accidental or regretted \n        \"approve\" of the loan, this method only works for them if the loan is in \"pending\" status.\n\n        The lender can call this method at any moment, in case of a loan with status \"lent\" the lender is pardoning \n        the debt. \n\n        @param index Index of the loan\n\n        @return true if the destroy was done successfully\n    */\n    function destroy(uint index) public returns (bool) {\n        Loan storage loan = loans[index];\n        require(loan.status != Status.destroyed);\n        require(msg.sender == loan.lender || (msg.sender == loan.borrower && loan.status == Status.initial));\n        DestroyedBy(index, msg.sender);\n\n        // ERC721, remove loan from circulation\n        if (loan.status != Status.initial) {\n            lendersBalance[loan.lender] -= 1;\n            activeLoans -= 1;\n            Transfer(loan.lender, 0x0, index);\n        }\n\n        loan.status = Status.destroyed;\n        return true;\n    }\n\n    /**\n        @dev Transfers a loan to a different lender, the caller must be the current lender or previously being\n        approved with the method \"approveTransfer\"; only loans with the Status.lent status can be transfered.\n\n        @param index Index of the loan\n        @param to New lender\n\n        @return true if the transfer was done successfully\n    */\n    function transfer(address to, uint256 index) public returns (bool) {\n        Loan storage loan = loans[index];\n        \n        require(loan.status != Status.destroyed && loan.status != Status.paid);\n        require(msg.sender == loan.lender || msg.sender == loan.approvedTransfer);\n        require(to != address(0));\n        loan.lender = to;\n        loan.approvedTransfer = address(0);\n\n        // ERC721, transfer loan to another address\n        lendersBalance[msg.sender] -= 1;\n        lendersBalance[to] += 1;\n        Transfer(loan.lender, to, index);\n\n        return true;\n    }\n\n    /**\n        @dev ERC721 method, transfers the loan to the msg.sender, the msg.sender must be approved using the \n        \"approve\" method.\n\n        @return true if the transfer was successfull\n    */\n    function takeOwnership(uint256 _index) public returns (bool) {\n        return transfer(msg.sender, _index);\n    }\n\n    /**\n        @dev Approves the transfer of a given loan in the name of the lender, the behavior of this function is similar to\n        \"approve\" in the ERC20 standard, but only one approved address is allowed at a time.\n\n        The same method can be called passing 0x0 as parameter \"to\" to erase a previously approved address.\n\n        @param to Address allowed to transfer the loan or 0x0 to delete\n        @param index Index of the loan\n\n        @return true if the approve was done successfully\n    */\n    function approve(address to, uint256 index) public returns (bool) {\n        Loan storage loan = loans[index];\n        require(msg.sender == loan.lender);\n        loan.approvedTransfer = to;\n        Approval(msg.sender, to, index);\n        return true;\n    }\n\n    /**\n        @dev Returns the pending amount to complete de payment of the loan, keep in mind that this number increases \n        every second.\n\n        @param index Index of the loan\n\n        @return Aprox pending payment amount\n    */\n    function getPendingAmount(uint index) public constant returns (uint256) {\n        Loan storage loan = loans[index];\n        addInterest(index);\n        return getRawPendingAmount(loan);\n    }\n\n    function getRawPendingAmount(Loan loan) internal returns (uint256) {\n        return safeSubtract(safeAdd(safeAdd(loan.amount, loan.interest), loan.punitoryInterest), loan.paid);\n    }\n\n    /**\n        @dev Calculates the interest of a given amount, interest rate and delta time.\n\n        @param timeDelta Elapsed time\n        @param interestRate Interest rate expressed as the denominator of 10 000 000.\n        @param amount Amount to apply interest\n\n        @return realDelta The real timeDelta applied\n        @return interest The interest gained in the realDelta time\n    */\n    function calculateInterest(uint256 timeDelta, uint256 interestRate, uint256 amount) public constant returns (uint256 realDelta, uint256 interest) {\n        if (amount == 0) {\n            interest = 0;\n            realDelta = timeDelta;\n        } else {\n            interest = safeMult(safeMult(100000, amount), timeDelta) / interestRate;\n            realDelta = safeMult(interest, interestRate) / (amount * 100000);\n        }\n    }\n\n    /**\n        @dev Computes loan interest\n\n        Computes the punitory and non-punitory interest of a given loan and only applies the change.\n        \n        @param loan Loan to compute interest\n        @param timestamp Target absolute unix time to calculate interest.\n    */\n    function internalAddInterest(Loan storage loan, uint256 timestamp) internal {\n        if (timestamp > loan.interestTimestamp) {\n            uint256 newInterest = loan.interest;\n            uint256 newPunitoryInterest = loan.punitoryInterest;\n\n            uint256 newTimestamp;\n            uint256 realDelta;\n            uint256 calculatedInterest;\n\n            uint256 deltaTime;\n            uint256 pending;\n\n            uint256 endNonPunitory = min(timestamp, loan.dueTime);\n            if (endNonPunitory > loan.interestTimestamp) {\n                deltaTime = endNonPunitory - loan.interestTimestamp;\n\n                if (loan.paid < loan.amount) {\n                    pending = loan.amount - loan.paid;\n                } else {\n                    pending = 0;\n                }\n\n                (realDelta, calculatedInterest) = calculateInterest(deltaTime, loan.interestRate, pending);\n                newInterest = safeAdd(calculatedInterest, newInterest);\n                newTimestamp = loan.interestTimestamp + realDelta;\n            }\n\n            if (timestamp > loan.dueTime) {\n                uint256 startPunitory = max(loan.dueTime, loan.interestTimestamp);\n                deltaTime = timestamp - startPunitory;\n\n                uint256 debt = safeAdd(loan.amount, newInterest);\n                pending = min(debt, safeSubtract(safeAdd(debt, newPunitoryInterest), loan.paid));\n\n                (realDelta, calculatedInterest) = calculateInterest(deltaTime, loan.interestRatePunitory, pending);\n                newPunitoryInterest = safeAdd(newPunitoryInterest, calculatedInterest);\n                newTimestamp = startPunitory + realDelta;\n            }\n            \n            if (newInterest != loan.interest || newPunitoryInterest != loan.punitoryInterest) {\n                loan.interestTimestamp = newTimestamp;\n                loan.interest = newInterest;\n                loan.punitoryInterest = newPunitoryInterest;\n            }\n        }\n    }\n\n    /**\n        @dev Computes loan interest only up to current unix time\n\n        @param timestamp Target absolute unix time to calculate interest.\n    */\n    function addInterestUpTo(Loan storage loan, uint256 timestamp) internal {\n        require(loan.status == Status.lent);\n        if (timestamp <= block.timestamp) {\n            internalAddInterest(loan, timestamp);\n        }\n    }\n\n    /**\n        @dev Updates the loan accumulated interests up to the current Unix time.\n        \n        @param index Index of the loan\n    */\n    function addInterest(uint index) public {\n        Loan storage loan = loans[index];\n        addInterestUpTo(loan, block.timestamp);\n    }\n    \n    /**\n        @dev Pay loan\n\n        Realizes a payment of a given Loan, before performing the payment the accumulated\n        interest is computed and added to the total pending amount.\n\n        Before calling this function, the msg.sender must call the \"approve\" function on the RCN Token, specifying an amount\n        sufficient enough to pay the equivalent of the desired payment and the oracle fee.\n\n        Because it is difficult or even impossible to know in advance how much RCN are going to be spent on the\n        transaction*, we recommend performing the \"approve\" using an amount 5% superior to the wallet estimated\n        spending. If the RCN spent results to be less, the extra tokens are never debited from the msg.sender.\n\n        * The RCN rate can fluctuate on the same block, and it is impossible to know in advance the exact time of the\n        confirmation of the transaction. \n\n        If the paid pending amount equals zero, the loan changes status to \"paid\" and it is considered closed.\n\n        @param index Index of the loan\n        @param _amount Amount to pay, specified in the loan currency; or in RCN if the loan has no oracle\n        @param _from The identity of the payer\n        @param oracleData Data required by the oracle to return the rate, the content of this field must be provided\n            by the url exposed in the url() method of the oracle.\n            \n        @return true if the payment was executed successfully\n    */\n    function pay(uint index, uint256 _amount, address _from, bytes oracleData) public returns (bool) {\n        Loan storage loan = loans[index];\n\n        require(loan.status == Status.lent);\n        addInterest(index);\n        uint256 toPay = min(getPendingAmount(index), _amount);\n        PartialPayment(index, msg.sender, _from, toPay);\n\n        loan.paid = safeAdd(loan.paid, toPay);\n\n        if (getRawPendingAmount(loan) == 0) {\n            TotalPayment(index);\n            loan.status = Status.paid;\n\n            // ERC721, remove loan from circulation\n            lendersBalance[loan.lender] -= 1;\n            activeLoans -= 1;\n            Transfer(loan.lender, 0x0, index);\n        }\n\n        uint256 rate = getRate(loan, oracleData);\n        uint256 transferValue = safeMult(toPay, rate);\n        lockTokens(rcn, transferValue);\n        require(rcn.transferFrom(msg.sender, this, transferValue));\n        loan.lenderBalance = safeAdd(transferValue, loan.lenderBalance);\n\n        return true;\n    }\n\n    /**\n        @dev Retrieves the rate corresponding of the loan oracle, if the loan has no oracle the rate is 1\n\n        @param loan The loan with the cosigner\n        @param data Data required by the oracle\n\n        @return The rate of the oracle\n    */\n    function getRate(Loan loan, bytes data) internal returns (uint256) {\n        if (loan.oracle == address(0)) {\n            return 1;\n        } else {\n            return loan.oracle.getRate(loan.currency, data);\n        }\n    }\n\n    /**\n        @dev Withdraw lender funds\n\n        When a loan is paid, the funds are not transferred automatically to the lender, the funds are stored on the\n        engine contract, and the lender must call this function specifying the amount desired to transfer and the \n        destination.\n\n        This behavior is defined to allow the temporary transfer of the loan to a smart contract, without worrying that\n        the contract will receive tokens that are not traceable; and it allows the development of decentralized \n        autonomous organizations.\n\n        @param index Index of the loan\n        @param to Destination of the wiwthdraw funds\n        @param amount Amount to withdraw, in RCN\n\n        @return true if the withdraw was executed successfully\n    */\n    function withdrawal(uint index, address to, uint256 amount) public returns (bool) {\n        Loan storage loan = loans[index];\n        require(msg.sender == loan.lender);\n        loan.lenderBalance = safeSubtract(loan.lenderBalance, amount);\n        require(rcn.transfer(to, amount));\n        unlockTokens(rcn, amount);\n        return true;\n    }\n\n    function withdrawalRange(uint256 fromIndex, uint256 toIndex, address to) public returns (uint256) {\n        uint256 loanId;\n        uint256 totalWithdraw = 0;\n\n        for (loanId = fromIndex; loanId <= toIndex; loanId++) {\n            Loan storage loan = loans[loanId];\n            if (loan.lender == msg.sender) {\n                totalWithdraw += loan.lenderBalance;\n                loan.lenderBalance = 0;\n            }\n        }\n\n        require(rcn.transfer(to, totalWithdraw));\n        unlockTokens(rcn, totalWithdraw);\n        \n        return totalWithdraw;\n    }\n\n    function withdrawalList(uint256[] memory loanIds, address to) public returns (uint256) {\n        uint256 inputId;\n        uint256 totalWithdraw = 0;\n\n        for (inputId = 0; inputId < loanIds.length; inputId++) {\n            Loan storage loan = loans[loanIds[inputId]];\n            if (loan.lender == msg.sender) {\n                totalWithdraw += loan.lenderBalance;\n                loan.lenderBalance = 0;\n            }\n        }\n\n        require(rcn.transfer(to, totalWithdraw));\n        unlockTokens(rcn, totalWithdraw);\n\n        return totalWithdraw;\n    }\n\n    /**\n        @dev Deprecates the engine, locks the creation of new loans.\n    */\n    function setDeprecated(bool _deprecated) public onlyOwner {\n        deprecated = _deprecated;\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinfabrik-RCN Network Smart Contract Audit/rcn-network-3ded36151ad55543d16c354e70161852de4061d0/contracts/NanoLoanEngine.sol",
        "vulnerability": "Assertion Failure",
        "check": "FP",
        "response": "Answer: No\nReason: The contract does not contain any assertions (require/other statements) that are guaranteed to fail under normal conditions."
    },
    {
        "code_segment": "contract NanoLoanEngine is ERC721, Engine, Ownable, TokenLockable {\n    uint256 public constant VERSION = 202;\n    string public constant VERSION_NAME = \"Basalt\";\n\n    uint256 private activeLoans = 0;\n    mapping(address => uint256) private lendersBalance;\n\n    function name() constant returns (string _name) {\n        _name = \"RCN - Nano loan engine - Basalt 202\";\n    }\n\n    function symbol() constant returns (string _symbol) {\n        _symbol = \"RCN-NLE-202\";\n    }\n\n    function totalSupply() constant returns (uint _totalSupply) {\n        _totalSupply = activeLoans;\n    }\n\n    function balanceOf(address _owner) constant returns (uint _balance) {\n        _balance = lendersBalance[_owner];\n    }\n\n    function tokenOfOwnerByIndex(address _owner, uint256 _index) constant returns (uint tokenId) {\n        uint256 tokenCount = balanceOf(_owner);\n\n        if (tokenCount == 0 || _index >= tokenCount) {\n            // Fail transaction\n            revert();\n        } else {\n            uint256 totalLoans = totalSupply();\n            uint256 resultIndex = 0;\n\n            uint256 loanId;\n            // SWC-128-DoS With Block Gas Limit: L46\n            for (loanId = 0; loanId <= totalLoans; loanId++) {\n                if (loans[loanId].lender == _owner && loans[loanId].status == Status.lent) {\n                    if (resultIndex == _index) {\n                        return loanId;\n                    }\n                    resultIndex++;\n                }\n            }\n\n            revert();\n        }\n    }\n\n    function tokensOfOwner(address _owner) external constant returns(uint256[] ownerTokens) {\n        uint256 tokenCount = balanceOf(_owner);\n\n        if (tokenCount == 0) {\n            // Return an empty array\n            return new uint256[](0);\n        } else {\n            uint256[] memory result = new uint256[](tokenCount);\n            uint256 totalLoans = totalSupply();\n            uint256 resultIndex = 0;\n\n            uint256 loanId;\n\n            for (loanId = 0; loanId <= totalLoans; loanId++) {\n                if (loans[loanId].lender == _owner && loans[loanId].status == Status.lent) {\n                    result[resultIndex] = loanId;\n                    resultIndex++;\n                }\n            }\n\n            return result;\n        }\n    }\n    \n    Token public rcn;\n    bool public deprecated;\n\n    event CreatedLoan(uint _index, address _borrower, address _creator);\n    event ApprovedBy(uint _index, address _address);\n    event Lent(uint _index, address _lender, address _cosigner);\n    event DestroyedBy(uint _index, address _address);\n    event PartialPayment(uint _index, address _sender, address _from, uint256 _amount);\n    event TotalPayment(uint _index);\n\n    function NanoLoanEngine(Token _rcn) public {\n        owner = msg.sender;\n        rcn = _rcn;\n    }\n\n    struct Loan {\n        Status status;\n        Oracle oracle;\n\n        address borrower;\n        address lender;\n        address creator;\n        address cosigner;\n        \n        uint256 amount;\n        uint256 interest;\n        uint256 punitoryInterest;\n        uint256 interestTimestamp;\n        uint256 paid;\n        uint256 interestRate;\n        uint256 interestRatePunitory;\n        uint256 dueTime;\n        uint256 duesIn;\n\n        bytes32 currency;\n        uint256 cancelableAt;\n        uint256 lenderBalance;\n\n        address approvedTransfer;\n        uint256 expirationRequest;\n\n        mapping(address => bool) approbations;\n    }\n\n    Loan[] private loans;\n\n    /**\n        @dev Creates a loan request, the loan can be generated with any borrower, cosigner, and conditions; if the \n        cosigner and borrower agree they must call the \"approve\" function.\n\n        The creator of the loan is the caller of this function; this is useful to track which wallet created the loan.\n\n        @param _oracleContract Address of the Oracle contract, if the loan does not use any oracle, this field should be 0x0.\n        @param _borrower Address of the borrower\n        @param _currency The currency to use with the oracle, the currency code is generated with the following formula,\n            keccak256(ticker,decimals).\n        @param _amount The requested amount; currency and unit are defined by the Oracle, if there is no Oracle present\n            the currency is RCN, and the unit is wei.\n        @param _interestRate The non-punitory interest rate by second, defined as a denominator of 10 000 000.\n        @param _interestRatePunitory The punitory interest rate by second, defined as a denominator of 10 000 000.\n            Ej: interestRate 11108571428571 = 28% Anual interest\n        @param _duesIn The time in seconds that the borrower has in order to pay the debt after the lender lends the money.\n        @param _cancelableAt Delta in seconds specifying how much interest should be added in advance, if the borrower pays \n        entirely or partially the loan before this term, no extra interest will be deducted.\n        @param _expirationRequest Timestamp of when the loan request expires, if the loan is not filled before this date, \n            the request is no longer valid.\n    */\n    function createLoan(Oracle _oracleContract, address _borrower, bytes32 _currency, uint256 _amount, uint256 _interestRate,\n        uint256 _interestRatePunitory, uint256 _duesIn, uint256 _cancelableAt, uint256 _expirationRequest) returns (uint256) {\n\n        require(!deprecated);\n        require(_cancelableAt <= _duesIn);\n        require(_oracleContract != address(0) || _currency == 0x0);\n        require(_borrower != address(0));\n        require(_amount != 0);\n        require(_interestRatePunitory != 0);\n        require(_interestRate != 0);\n        require(_expirationRequest > block.timestamp);\n\n        var loan = Loan(Status.initial, _oracleContract, _borrower, 0x0, msg.sender, 0x0, _amount, 0, 0, 0, 0, _interestRate,\n            _interestRatePunitory, 0, _duesIn, _currency, _cancelableAt, 0, 0x0, _expirationRequest);\n        uint index = loans.push(loan) - 1;\n        CreatedLoan(index, _borrower, msg.sender);\n\n        if (msg.sender == _borrower) {\n            approveLoan(index);\n        }\n\n        return index;\n    }\n    \n    function ownerOf(uint256 index) constant returns (address owner) { owner = loans[index].lender; }\n    function getTotalLoans() constant returns (uint256) { return loans.length; }\n    function getOracle(uint index) constant returns (Oracle) { return loans[index].oracle; }\n    function getBorrower(uint index) constant returns (address) { return loans[index].borrower; }\n    function getCosigner(uint index) constant returns (address) { return loans[index].cosigner; }\n    function getCreator(uint index) constant returns (address) { return loans[index].creator; }\n    function getAmount(uint index) constant returns (uint256) { return loans[index].amount; }\n    function getPunitoryInterest(uint index) constant returns (uint256) { return loans[index].punitoryInterest; }\n    function getInterestTimestamp(uint index) constant returns (uint256) { return loans[index].interestTimestamp; }\n    function getPaid(uint index) constant returns (uint256) { return loans[index].paid; }\n    function getInterestRate(uint index) constant returns (uint256) { return loans[index].interestRate; }\n    function getInterestRatePunitory(uint index) constant returns (uint256) { return loans[index].interestRatePunitory; }\n    function getDueTime(uint index) constant returns (uint256) { return loans[index].dueTime; }\n    function getDuesIn(uint index) constant returns (uint256) { return loans[index].duesIn; }\n    function getCancelableAt(uint index) constant returns (uint256) { return loans[index].cancelableAt; }\n    function getApprobation(uint index, address _address) constant returns (bool) { return loans[index].approbations[_address]; }\n    function getStatus(uint index) constant returns (Status) { return loans[index].status; }\n    function getLenderBalance(uint index) constant returns (uint256) { return loans[index].lenderBalance; }\n    function getApprovedTransfer(uint index) constant returns (address) {return loans[index].approvedTransfer; }\n    function getCurrency(uint index) constant returns (bytes32) { return loans[index].currency; }\n    function getExpirationRequest(uint index) constant returns (uint256) { return loans[index].expirationRequest; }\n    function getInterest(uint index) constant returns (uint256) { return loans[index].interest; }\n\n    /**\n        @param index Index of the loan\n\n        @return true if the loan has been approved by the borrower and cosigner.\n    */\n    function isApproved(uint index) constant returns (bool) {\n        Loan storage loan = loans[index];\n        return loan.approbations[loan.borrower];\n    }\n\n    /**\n        @dev Called by the members of the loan to show that they agree with the terms of the loan; the borrower\n        must call this method before any lender could call the method \"lend\".\n            \n        Any address can call this method to be added to the \"approbations\" mapping.\n\n        @param index Index of the loan\n\n        @return true if the approve was done successfully\n    */\n    function approveLoan(uint index) public returns(bool) {\n        Loan storage loan = loans[index];\n        require(loan.status == Status.initial);\n        loan.approbations[msg.sender] = true;\n        ApprovedBy(index, msg.sender);\n        return true;\n    }\n\n    /**\n        @dev Performs the lend of the RCN equivalent to the requested amount, and transforms the msg.sender in the new lender.\n\n        The loan must be previously approved by the borrower; before calling this function, the lender candidate must \n        call the \"approve\" function on the RCN Token, specifying an amount sufficient enough to pay the equivalent of\n        the requested amount, and the cosigner fee.\n        \n        @param index Index of the loan\n        @param oracleData Data required by the oracle to return the rate, the content of this field must be provided\n            by the url exposed in the url() method of the oracle.\n        @param cosigner Address of the cosigner, 0x0 for lending without cosigner.\n        @param cosignerData Data required by the cosigner to process the request.\n\n        @return true if the lend was done successfully\n    */\n    function lend(uint index, bytes oracleData, Cosigner cosigner, bytes cosignerData) public returns (bool) {\n        Loan storage loan = loans[index];\n\n        require(loan.status == Status.initial);\n        require(isApproved(index));\n        require(block.timestamp <= loan.expirationRequest);\n\n        loan.lender = msg.sender;\n        loan.dueTime = safeAdd(block.timestamp, loan.duesIn);\n        loan.interestTimestamp = block.timestamp;\n        loan.status = Status.lent;\n        \n        if (loan.cancelableAt > 0)\n            internalAddInterest(loan, safeAdd(block.timestamp, loan.cancelableAt));\n\n        uint256 rate = getRate(loan, oracleData);\n\n        if (cosigner != address(0)) {\n            // The cosigner it's temporary set to the next address (cosigner + 2), it's expected that the cosigner will\n            // call the method \"cosign\" to accept the conditions; that method also sets the cosigner to the right\n            // address. If that does not happen, the transaction fails.\n            loan.cosigner = address(uint256(cosigner) + 2);\n            require(cosigner.requestCosign(this, index, cosignerData, oracleData));\n            require(loan.cosigner == address(cosigner));\n        }\n        \n        require(rcn.transferFrom(msg.sender, loan.borrower, safeMult(loan.amount, rate)));\n        \n        // ERC721, create new loan and transfer it to the lender\n        Transfer(0x0, loan.lender, index);\n        activeLoans += 1;\n        lendersBalance[loan.lender] += 1;\n        Lent(index, loan.lender, cosigner);\n\n        return true;\n    }\n\n    /**\n        @dev The cosigner must call this method to accept the conditions of a loan, this method pays the cosigner his fee\n\n        @param index Index of the loan\n        @param cost Fee set by the cosigner\n\n        @return true If the cosign was successfull\n    */\n    function cosign(uint index, uint256 cost) external returns (bool) {\n        Loan storage loan = loans[index];\n        require(loan.status == Status.lent && (loan.dueTime - loan.duesIn) == block.timestamp);\n        require(loan.cosigner != address(0));\n        require(loan.cosigner == address(uint256(msg.sender) + 2));\n        loan.cosigner = msg.sender;\n        require(rcn.transferFrom(loan.lender, msg.sender, cost));\n        return true;\n    }\n\n    /**\n        @dev Destroys a loan, the borrower could call this method if they performed an accidental or regretted \n        \"approve\" of the loan, this method only works for them if the loan is in \"pending\" status.\n\n        The lender can call this method at any moment, in case of a loan with status \"lent\" the lender is pardoning \n        the debt. \n\n        @param index Index of the loan\n\n        @return true if the destroy was done successfully\n    */\n    function destroy(uint index) public returns (bool) {\n        Loan storage loan = loans[index];\n        require(loan.status != Status.destroyed);\n        require(msg.sender == loan.lender || (msg.sender == loan.borrower && loan.status == Status.initial));\n        DestroyedBy(index, msg.sender);\n\n        // ERC721, remove loan from circulation\n        if (loan.status != Status.initial) {\n            lendersBalance[loan.lender] -= 1;\n            activeLoans -= 1;\n            Transfer(loan.lender, 0x0, index);\n        }\n\n        loan.status = Status.destroyed;\n        return true;\n    }\n\n    /**\n        @dev Transfers a loan to a different lender, the caller must be the current lender or previously being\n        approved with the method \"approveTransfer\"; only loans with the Status.lent status can be transfered.\n\n        @param index Index of the loan\n        @param to New lender\n\n        @return true if the transfer was done successfully\n    */\n    function transfer(address to, uint256 index) public returns (bool) {\n        Loan storage loan = loans[index];\n        \n        require(loan.status != Status.destroyed && loan.status != Status.paid);\n        require(msg.sender == loan.lender || msg.sender == loan.approvedTransfer);\n        require(to != address(0));\n        loan.lender = to;\n        loan.approvedTransfer = address(0);\n\n        // ERC721, transfer loan to another address\n        lendersBalance[msg.sender] -= 1;\n        lendersBalance[to] += 1;\n        Transfer(loan.lender, to, index);\n\n        return true;\n    }\n\n    /**\n        @dev ERC721 method, transfers the loan to the msg.sender, the msg.sender must be approved using the \n        \"approve\" method.\n\n        @return true if the transfer was successfull\n    */\n    function takeOwnership(uint256 _index) public returns (bool) {\n        return transfer(msg.sender, _index);\n    }\n\n    /**\n        @dev Approves the transfer of a given loan in the name of the lender, the behavior of this function is similar to\n        \"approve\" in the ERC20 standard, but only one approved address is allowed at a time.\n\n        The same method can be called passing 0x0 as parameter \"to\" to erase a previously approved address.\n\n        @param to Address allowed to transfer the loan or 0x0 to delete\n        @param index Index of the loan\n\n        @return true if the approve was done successfully\n    */\n    function approve(address to, uint256 index) public returns (bool) {\n        Loan storage loan = loans[index];\n        require(msg.sender == loan.lender);\n        loan.approvedTransfer = to;\n        Approval(msg.sender, to, index);\n        return true;\n    }\n\n    /**\n        @dev Returns the pending amount to complete de payment of the loan, keep in mind that this number increases \n        every second.\n\n        @param index Index of the loan\n\n        @return Aprox pending payment amount\n    */\n    function getPendingAmount(uint index) public constant returns (uint256) {\n        Loan storage loan = loans[index];\n        addInterest(index);\n        return getRawPendingAmount(loan);\n    }\n\n    function getRawPendingAmount(Loan loan) internal returns (uint256) {\n        return safeSubtract(safeAdd(safeAdd(loan.amount, loan.interest), loan.punitoryInterest), loan.paid);\n    }\n\n    /**\n        @dev Calculates the interest of a given amount, interest rate and delta time.\n\n        @param timeDelta Elapsed time\n        @param interestRate Interest rate expressed as the denominator of 10 000 000.\n        @param amount Amount to apply interest\n\n        @return realDelta The real timeDelta applied\n        @return interest The interest gained in the realDelta time\n    */\n    function calculateInterest(uint256 timeDelta, uint256 interestRate, uint256 amount) public constant returns (uint256 realDelta, uint256 interest) {\n        if (amount == 0) {\n            interest = 0;\n            realDelta = timeDelta;\n        } else {\n            interest = safeMult(safeMult(100000, amount), timeDelta) / interestRate;\n            realDelta = safeMult(interest, interestRate) / (amount * 100000);\n        }\n    }\n\n    /**\n        @dev Computes loan interest\n\n        Computes the punitory and non-punitory interest of a given loan and only applies the change.\n        \n        @param loan Loan to compute interest\n        @param timestamp Target absolute unix time to calculate interest.\n    */\n    function internalAddInterest(Loan storage loan, uint256 timestamp) internal {\n        if (timestamp > loan.interestTimestamp) {\n            uint256 newInterest = loan.interest;\n            uint256 newPunitoryInterest = loan.punitoryInterest;\n\n            uint256 newTimestamp;\n            uint256 realDelta;\n            uint256 calculatedInterest;\n\n            uint256 deltaTime;\n            uint256 pending;\n\n            uint256 endNonPunitory = min(timestamp, loan.dueTime);\n            if (endNonPunitory > loan.interestTimestamp) {\n                deltaTime = endNonPunitory - loan.interestTimestamp;\n\n                if (loan.paid < loan.amount) {\n                    pending = loan.amount - loan.paid;\n                } else {\n                    pending = 0;\n                }\n\n                (realDelta, calculatedInterest) = calculateInterest(deltaTime, loan.interestRate, pending);\n                newInterest = safeAdd(calculatedInterest, newInterest);\n                newTimestamp = loan.interestTimestamp + realDelta;\n            }\n\n            if (timestamp > loan.dueTime) {\n                uint256 startPunitory = max(loan.dueTime, loan.interestTimestamp);\n                deltaTime = timestamp - startPunitory;\n\n                uint256 debt = safeAdd(loan.amount, newInterest);\n                pending = min(debt, safeSubtract(safeAdd(debt, newPunitoryInterest), loan.paid));\n\n                (realDelta, calculatedInterest) = calculateInterest(deltaTime, loan.interestRatePunitory, pending);\n                newPunitoryInterest = safeAdd(newPunitoryInterest, calculatedInterest);\n                newTimestamp = startPunitory + realDelta;\n            }\n            \n            if (newInterest != loan.interest || newPunitoryInterest != loan.punitoryInterest) {\n                loan.interestTimestamp = newTimestamp;\n                loan.interest = newInterest;\n                loan.punitoryInterest = newPunitoryInterest;\n            }\n        }\n    }\n\n    /**\n        @dev Computes loan interest only up to current unix time\n\n        @param timestamp Target absolute unix time to calculate interest.\n    */\n    function addInterestUpTo(Loan storage loan, uint256 timestamp) internal {\n        require(loan.status == Status.lent);\n        if (timestamp <= block.timestamp) {\n            internalAddInterest(loan, timestamp);\n        }\n    }\n\n    /**\n        @dev Updates the loan accumulated interests up to the current Unix time.\n        \n        @param index Index of the loan\n    */\n    function addInterest(uint index) public {\n        Loan storage loan = loans[index];\n        addInterestUpTo(loan, block.timestamp);\n    }\n    \n    /**\n        @dev Pay loan\n\n        Realizes a payment of a given Loan, before performing the payment the accumulated\n        interest is computed and added to the total pending amount.\n\n        Before calling this function, the msg.sender must call the \"approve\" function on the RCN Token, specifying an amount\n        sufficient enough to pay the equivalent of the desired payment and the oracle fee.\n\n        Because it is difficult or even impossible to know in advance how much RCN are going to be spent on the\n        transaction*, we recommend performing the \"approve\" using an amount 5% superior to the wallet estimated\n        spending. If the RCN spent results to be less, the extra tokens are never debited from the msg.sender.\n\n        * The RCN rate can fluctuate on the same block, and it is impossible to know in advance the exact time of the\n        confirmation of the transaction. \n\n        If the paid pending amount equals zero, the loan changes status to \"paid\" and it is considered closed.\n\n        @param index Index of the loan\n        @param _amount Amount to pay, specified in the loan currency; or in RCN if the loan has no oracle\n        @param _from The identity of the payer\n        @param oracleData Data required by the oracle to return the rate, the content of this field must be provided\n            by the url exposed in the url() method of the oracle.\n            \n        @return true if the payment was executed successfully\n    */\n    function pay(uint index, uint256 _amount, address _from, bytes oracleData) public returns (bool) {\n        Loan storage loan = loans[index];\n\n        require(loan.status == Status.lent);\n        addInterest(index);\n        uint256 toPay = min(getPendingAmount(index), _amount);\n        PartialPayment(index, msg.sender, _from, toPay);\n\n        loan.paid = safeAdd(loan.paid, toPay);\n\n        if (getRawPendingAmount(loan) == 0) {\n            TotalPayment(index);\n            loan.status = Status.paid;\n\n            // ERC721, remove loan from circulation\n            lendersBalance[loan.lender] -= 1;\n            activeLoans -= 1;\n            Transfer(loan.lender, 0x0, index);\n        }\n\n        uint256 rate = getRate(loan, oracleData);\n        uint256 transferValue = safeMult(toPay, rate);\n        lockTokens(rcn, transferValue);\n        require(rcn.transferFrom(msg.sender, this, transferValue));\n        loan.lenderBalance = safeAdd(transferValue, loan.lenderBalance);\n\n        return true;\n    }\n\n    /**\n        @dev Retrieves the rate corresponding of the loan oracle, if the loan has no oracle the rate is 1\n\n        @param loan The loan with the cosigner\n        @param data Data required by the oracle\n\n        @return The rate of the oracle\n    */\n    function getRate(Loan loan, bytes data) internal returns (uint256) {\n        if (loan.oracle == address(0)) {\n            return 1;\n        } else {\n            return loan.oracle.getRate(loan.currency, data);\n        }\n    }\n\n    /**\n        @dev Withdraw lender funds\n\n        When a loan is paid, the funds are not transferred automatically to the lender, the funds are stored on the\n        engine contract, and the lender must call this function specifying the amount desired to transfer and the \n        destination.\n\n        This behavior is defined to allow the temporary transfer of the loan to a smart contract, without worrying that\n        the contract will receive tokens that are not traceable; and it allows the development of decentralized \n        autonomous organizations.\n\n        @param index Index of the loan\n        @param to Destination of the wiwthdraw funds\n        @param amount Amount to withdraw, in RCN\n\n        @return true if the withdraw was executed successfully\n    */\n    function withdrawal(uint index, address to, uint256 amount) public returns (bool) {\n        Loan storage loan = loans[index];\n        require(msg.sender == loan.lender);\n        loan.lenderBalance = safeSubtract(loan.lenderBalance, amount);\n        require(rcn.transfer(to, amount));\n        unlockTokens(rcn, amount);\n        return true;\n    }\n\n    function withdrawalRange(uint256 fromIndex, uint256 toIndex, address to) public returns (uint256) {\n        uint256 loanId;\n        uint256 totalWithdraw = 0;\n\n        for (loanId = fromIndex; loanId <= toIndex; loanId++) {\n            Loan storage loan = loans[loanId];\n            if (loan.lender == msg.sender) {\n                totalWithdraw += loan.lenderBalance;\n                loan.lenderBalance = 0;\n            }\n        }\n\n        require(rcn.transfer(to, totalWithdraw));\n        unlockTokens(rcn, totalWithdraw);\n        \n        return totalWithdraw;\n    }\n\n    function withdrawalList(uint256[] memory loanIds, address to) public returns (uint256) {\n        uint256 inputId;\n        uint256 totalWithdraw = 0;\n\n        for (inputId = 0; inputId < loanIds.length; inputId++) {\n            Loan storage loan = loans[loanIds[inputId]];\n            if (loan.lender == msg.sender) {\n                totalWithdraw += loan.lenderBalance;\n                loan.lenderBalance = 0;\n            }\n        }\n\n        require(rcn.transfer(to, totalWithdraw));\n        unlockTokens(rcn, totalWithdraw);\n\n        return totalWithdraw;\n    }\n\n    /**\n        @dev Deprecates the engine, locks the creation of new loans.\n    */\n    function setDeprecated(bool _deprecated) public onlyOwner {\n        deprecated = _deprecated;\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinfabrik-RCN Network Smart Contract Audit/rcn-network-3ded36151ad55543d16c354e70161852de4061d0/contracts/NanoLoanEngine.sol",
        "vulnerability": "Assertion Failure",
        "check": "FP",
        "response": "Answer: No  \nReason: The code does not contain any assert statements that could lead to assertion failures."
    },
    {
        "code_segment": "contract NanoLoanEngine is ERC721, Engine, Ownable, TokenLockable {\n    uint256 public constant VERSION = 202;\n    string public constant VERSION_NAME = \"Basalt\";\n\n    uint256 private activeLoans = 0;\n    mapping(address => uint256) private lendersBalance;\n\n    function name() constant returns (string _name) {\n        _name = \"RCN - Nano loan engine - Basalt 202\";\n    }\n\n    function symbol() constant returns (string _symbol) {\n        _symbol = \"RCN-NLE-202\";\n    }\n\n    function totalSupply() constant returns (uint _totalSupply) {\n        _totalSupply = activeLoans;\n    }\n\n    function balanceOf(address _owner) constant returns (uint _balance) {\n        _balance = lendersBalance[_owner];\n    }\n\n    function tokenOfOwnerByIndex(address _owner, uint256 _index) constant returns (uint tokenId) {\n        uint256 tokenCount = balanceOf(_owner);\n\n        if (tokenCount == 0 || _index >= tokenCount) {\n            // Fail transaction\n            revert();\n        } else {\n            uint256 totalLoans = totalSupply();\n            uint256 resultIndex = 0;\n\n            uint256 loanId;\n            // SWC-128-DoS With Block Gas Limit: L46\n            for (loanId = 0; loanId <= totalLoans; loanId++) {\n                if (loans[loanId].lender == _owner && loans[loanId].status == Status.lent) {\n                    if (resultIndex == _index) {\n                        return loanId;\n                    }\n                    resultIndex++;\n                }\n            }\n\n            revert();\n        }\n    }\n\n    function tokensOfOwner(address _owner) external constant returns(uint256[] ownerTokens) {\n        uint256 tokenCount = balanceOf(_owner);\n\n        if (tokenCount == 0) {\n            // Return an empty array\n            return new uint256[](0);\n        } else {\n            uint256[] memory result = new uint256[](tokenCount);\n            uint256 totalLoans = totalSupply();\n            uint256 resultIndex = 0;\n\n            uint256 loanId;\n\n            for (loanId = 0; loanId <= totalLoans; loanId++) {\n                if (loans[loanId].lender == _owner && loans[loanId].status == Status.lent) {\n                    result[resultIndex] = loanId;\n                    resultIndex++;\n                }\n            }\n\n            return result;\n        }\n    }\n    \n    Token public rcn;\n    bool public deprecated;\n\n    event CreatedLoan(uint _index, address _borrower, address _creator);\n    event ApprovedBy(uint _index, address _address);\n    event Lent(uint _index, address _lender, address _cosigner);\n    event DestroyedBy(uint _index, address _address);\n    event PartialPayment(uint _index, address _sender, address _from, uint256 _amount);\n    event TotalPayment(uint _index);\n\n    function NanoLoanEngine(Token _rcn) public {\n        owner = msg.sender;\n        rcn = _rcn;\n    }\n\n    struct Loan {\n        Status status;\n        Oracle oracle;\n\n        address borrower;\n        address lender;\n        address creator;\n        address cosigner;\n        \n        uint256 amount;\n        uint256 interest;\n        uint256 punitoryInterest;\n        uint256 interestTimestamp;\n        uint256 paid;\n        uint256 interestRate;\n        uint256 interestRatePunitory;\n        uint256 dueTime;\n        uint256 duesIn;\n\n        bytes32 currency;\n        uint256 cancelableAt;\n        uint256 lenderBalance;\n\n        address approvedTransfer;\n        uint256 expirationRequest;\n\n        mapping(address => bool) approbations;\n    }\n\n    Loan[] private loans;\n\n    /**\n        @dev Creates a loan request, the loan can be generated with any borrower, cosigner, and conditions; if the \n        cosigner and borrower agree they must call the \"approve\" function.\n\n        The creator of the loan is the caller of this function; this is useful to track which wallet created the loan.\n\n        @param _oracleContract Address of the Oracle contract, if the loan does not use any oracle, this field should be 0x0.\n        @param _borrower Address of the borrower\n        @param _currency The currency to use with the oracle, the currency code is generated with the following formula,\n            keccak256(ticker,decimals).\n        @param _amount The requested amount; currency and unit are defined by the Oracle, if there is no Oracle present\n            the currency is RCN, and the unit is wei.\n        @param _interestRate The non-punitory interest rate by second, defined as a denominator of 10 000 000.\n        @param _interestRatePunitory The punitory interest rate by second, defined as a denominator of 10 000 000.\n            Ej: interestRate 11108571428571 = 28% Anual interest\n        @param _duesIn The time in seconds that the borrower has in order to pay the debt after the lender lends the money.\n        @param _cancelableAt Delta in seconds specifying how much interest should be added in advance, if the borrower pays \n        entirely or partially the loan before this term, no extra interest will be deducted.\n        @param _expirationRequest Timestamp of when the loan request expires, if the loan is not filled before this date, \n            the request is no longer valid.\n    */\n    function createLoan(Oracle _oracleContract, address _borrower, bytes32 _currency, uint256 _amount, uint256 _interestRate,\n        uint256 _interestRatePunitory, uint256 _duesIn, uint256 _cancelableAt, uint256 _expirationRequest) returns (uint256) {\n\n        require(!deprecated);\n        require(_cancelableAt <= _duesIn);\n        require(_oracleContract != address(0) || _currency == 0x0);\n        require(_borrower != address(0));\n        require(_amount != 0);\n        require(_interestRatePunitory != 0);\n        require(_interestRate != 0);\n        require(_expirationRequest > block.timestamp);\n\n        var loan = Loan(Status.initial, _oracleContract, _borrower, 0x0, msg.sender, 0x0, _amount, 0, 0, 0, 0, _interestRate,\n            _interestRatePunitory, 0, _duesIn, _currency, _cancelableAt, 0, 0x0, _expirationRequest);\n        uint index = loans.push(loan) - 1;\n        CreatedLoan(index, _borrower, msg.sender);\n\n        if (msg.sender == _borrower) {\n            approveLoan(index);\n        }\n\n        return index;\n    }\n    \n    function ownerOf(uint256 index) constant returns (address owner) { owner = loans[index].lender; }\n    function getTotalLoans() constant returns (uint256) { return loans.length; }\n    function getOracle(uint index) constant returns (Oracle) { return loans[index].oracle; }\n    function getBorrower(uint index) constant returns (address) { return loans[index].borrower; }\n    function getCosigner(uint index) constant returns (address) { return loans[index].cosigner; }\n    function getCreator(uint index) constant returns (address) { return loans[index].creator; }\n    function getAmount(uint index) constant returns (uint256) { return loans[index].amount; }\n    function getPunitoryInterest(uint index) constant returns (uint256) { return loans[index].punitoryInterest; }\n    function getInterestTimestamp(uint index) constant returns (uint256) { return loans[index].interestTimestamp; }\n    function getPaid(uint index) constant returns (uint256) { return loans[index].paid; }\n    function getInterestRate(uint index) constant returns (uint256) { return loans[index].interestRate; }\n    function getInterestRatePunitory(uint index) constant returns (uint256) { return loans[index].interestRatePunitory; }\n    function getDueTime(uint index) constant returns (uint256) { return loans[index].dueTime; }\n    function getDuesIn(uint index) constant returns (uint256) { return loans[index].duesIn; }\n    function getCancelableAt(uint index) constant returns (uint256) { return loans[index].cancelableAt; }\n    function getApprobation(uint index, address _address) constant returns (bool) { return loans[index].approbations[_address]; }\n    function getStatus(uint index) constant returns (Status) { return loans[index].status; }\n    function getLenderBalance(uint index) constant returns (uint256) { return loans[index].lenderBalance; }\n    function getApprovedTransfer(uint index) constant returns (address) {return loans[index].approvedTransfer; }\n    function getCurrency(uint index) constant returns (bytes32) { return loans[index].currency; }\n    function getExpirationRequest(uint index) constant returns (uint256) { return loans[index].expirationRequest; }\n    function getInterest(uint index) constant returns (uint256) { return loans[index].interest; }\n\n    /**\n        @param index Index of the loan\n\n        @return true if the loan has been approved by the borrower and cosigner.\n    */\n    function isApproved(uint index) constant returns (bool) {\n        Loan storage loan = loans[index];\n        return loan.approbations[loan.borrower];\n    }\n\n    /**\n        @dev Called by the members of the loan to show that they agree with the terms of the loan; the borrower\n        must call this method before any lender could call the method \"lend\".\n            \n        Any address can call this method to be added to the \"approbations\" mapping.\n\n        @param index Index of the loan\n\n        @return true if the approve was done successfully\n    */\n    function approveLoan(uint index) public returns(bool) {\n        Loan storage loan = loans[index];\n        require(loan.status == Status.initial);\n        loan.approbations[msg.sender] = true;\n        ApprovedBy(index, msg.sender);\n        return true;\n    }\n\n    /**\n        @dev Performs the lend of the RCN equivalent to the requested amount, and transforms the msg.sender in the new lender.\n\n        The loan must be previously approved by the borrower; before calling this function, the lender candidate must \n        call the \"approve\" function on the RCN Token, specifying an amount sufficient enough to pay the equivalent of\n        the requested amount, and the cosigner fee.\n        \n        @param index Index of the loan\n        @param oracleData Data required by the oracle to return the rate, the content of this field must be provided\n            by the url exposed in the url() method of the oracle.\n        @param cosigner Address of the cosigner, 0x0 for lending without cosigner.\n        @param cosignerData Data required by the cosigner to process the request.\n\n        @return true if the lend was done successfully\n    */\n    function lend(uint index, bytes oracleData, Cosigner cosigner, bytes cosignerData) public returns (bool) {\n        Loan storage loan = loans[index];\n\n        require(loan.status == Status.initial);\n        require(isApproved(index));\n        require(block.timestamp <= loan.expirationRequest);\n\n        loan.lender = msg.sender;\n        loan.dueTime = safeAdd(block.timestamp, loan.duesIn);\n        loan.interestTimestamp = block.timestamp;\n        loan.status = Status.lent;\n        \n        if (loan.cancelableAt > 0)\n            internalAddInterest(loan, safeAdd(block.timestamp, loan.cancelableAt));\n\n        uint256 rate = getRate(loan, oracleData);\n\n        if (cosigner != address(0)) {\n            // The cosigner it's temporary set to the next address (cosigner + 2), it's expected that the cosigner will\n            // call the method \"cosign\" to accept the conditions; that method also sets the cosigner to the right\n            // address. If that does not happen, the transaction fails.\n            loan.cosigner = address(uint256(cosigner) + 2);\n            require(cosigner.requestCosign(this, index, cosignerData, oracleData));\n            require(loan.cosigner == address(cosigner));\n        }\n        \n        require(rcn.transferFrom(msg.sender, loan.borrower, safeMult(loan.amount, rate)));\n        \n        // ERC721, create new loan and transfer it to the lender\n        Transfer(0x0, loan.lender, index);\n        activeLoans += 1;\n        lendersBalance[loan.lender] += 1;\n        Lent(index, loan.lender, cosigner);\n\n        return true;\n    }\n\n    /**\n        @dev The cosigner must call this method to accept the conditions of a loan, this method pays the cosigner his fee\n\n        @param index Index of the loan\n        @param cost Fee set by the cosigner\n\n        @return true If the cosign was successfull\n    */\n    function cosign(uint index, uint256 cost) external returns (bool) {\n        Loan storage loan = loans[index];\n        require(loan.status == Status.lent && (loan.dueTime - loan.duesIn) == block.timestamp);\n        require(loan.cosigner != address(0));\n        require(loan.cosigner == address(uint256(msg.sender) + 2));\n        loan.cosigner = msg.sender;\n        require(rcn.transferFrom(loan.lender, msg.sender, cost));\n        return true;\n    }\n\n    /**\n        @dev Destroys a loan, the borrower could call this method if they performed an accidental or regretted \n        \"approve\" of the loan, this method only works for them if the loan is in \"pending\" status.\n\n        The lender can call this method at any moment, in case of a loan with status \"lent\" the lender is pardoning \n        the debt. \n\n        @param index Index of the loan\n\n        @return true if the destroy was done successfully\n    */\n    function destroy(uint index) public returns (bool) {\n        Loan storage loan = loans[index];\n        require(loan.status != Status.destroyed);\n        require(msg.sender == loan.lender || (msg.sender == loan.borrower && loan.status == Status.initial));\n        DestroyedBy(index, msg.sender);\n\n        // ERC721, remove loan from circulation\n        if (loan.status != Status.initial) {\n            lendersBalance[loan.lender] -= 1;\n            activeLoans -= 1;\n            Transfer(loan.lender, 0x0, index);\n        }\n\n        loan.status = Status.destroyed;\n        return true;\n    }\n\n    /**\n        @dev Transfers a loan to a different lender, the caller must be the current lender or previously being\n        approved with the method \"approveTransfer\"; only loans with the Status.lent status can be transfered.\n\n        @param index Index of the loan\n        @param to New lender\n\n        @return true if the transfer was done successfully\n    */\n    function transfer(address to, uint256 index) public returns (bool) {\n        Loan storage loan = loans[index];\n        \n        require(loan.status != Status.destroyed && loan.status != Status.paid);\n        require(msg.sender == loan.lender || msg.sender == loan.approvedTransfer);\n        require(to != address(0));\n        loan.lender = to;\n        loan.approvedTransfer = address(0);\n\n        // ERC721, transfer loan to another address\n        lendersBalance[msg.sender] -= 1;\n        lendersBalance[to] += 1;\n        Transfer(loan.lender, to, index);\n\n        return true;\n    }\n\n    /**\n        @dev ERC721 method, transfers the loan to the msg.sender, the msg.sender must be approved using the \n        \"approve\" method.\n\n        @return true if the transfer was successfull\n    */\n    function takeOwnership(uint256 _index) public returns (bool) {\n        return transfer(msg.sender, _index);\n    }\n\n    /**\n        @dev Approves the transfer of a given loan in the name of the lender, the behavior of this function is similar to\n        \"approve\" in the ERC20 standard, but only one approved address is allowed at a time.\n\n        The same method can be called passing 0x0 as parameter \"to\" to erase a previously approved address.\n\n        @param to Address allowed to transfer the loan or 0x0 to delete\n        @param index Index of the loan\n\n        @return true if the approve was done successfully\n    */\n    function approve(address to, uint256 index) public returns (bool) {\n        Loan storage loan = loans[index];\n        require(msg.sender == loan.lender);\n        loan.approvedTransfer = to;\n        Approval(msg.sender, to, index);\n        return true;\n    }\n\n    /**\n        @dev Returns the pending amount to complete de payment of the loan, keep in mind that this number increases \n        every second.\n\n        @param index Index of the loan\n\n        @return Aprox pending payment amount\n    */\n    function getPendingAmount(uint index) public constant returns (uint256) {\n        Loan storage loan = loans[index];\n        addInterest(index);\n        return getRawPendingAmount(loan);\n    }\n\n    function getRawPendingAmount(Loan loan) internal returns (uint256) {\n        return safeSubtract(safeAdd(safeAdd(loan.amount, loan.interest), loan.punitoryInterest), loan.paid);\n    }\n\n    /**\n        @dev Calculates the interest of a given amount, interest rate and delta time.\n\n        @param timeDelta Elapsed time\n        @param interestRate Interest rate expressed as the denominator of 10 000 000.\n        @param amount Amount to apply interest\n\n        @return realDelta The real timeDelta applied\n        @return interest The interest gained in the realDelta time\n    */\n    function calculateInterest(uint256 timeDelta, uint256 interestRate, uint256 amount) public constant returns (uint256 realDelta, uint256 interest) {\n        if (amount == 0) {\n            interest = 0;\n            realDelta = timeDelta;\n        } else {\n            interest = safeMult(safeMult(100000, amount), timeDelta) / interestRate;\n            realDelta = safeMult(interest, interestRate) / (amount * 100000);\n        }\n    }\n\n    /**\n        @dev Computes loan interest\n\n        Computes the punitory and non-punitory interest of a given loan and only applies the change.\n        \n        @param loan Loan to compute interest\n        @param timestamp Target absolute unix time to calculate interest.\n    */\n    function internalAddInterest(Loan storage loan, uint256 timestamp) internal {\n        if (timestamp > loan.interestTimestamp) {\n            uint256 newInterest = loan.interest;\n            uint256 newPunitoryInterest = loan.punitoryInterest;\n\n            uint256 newTimestamp;\n            uint256 realDelta;\n            uint256 calculatedInterest;\n\n            uint256 deltaTime;\n            uint256 pending;\n\n            uint256 endNonPunitory = min(timestamp, loan.dueTime);\n            if (endNonPunitory > loan.interestTimestamp) {\n                deltaTime = endNonPunitory - loan.interestTimestamp;\n\n                if (loan.paid < loan.amount) {\n                    pending = loan.amount - loan.paid;\n                } else {\n                    pending = 0;\n                }\n\n                (realDelta, calculatedInterest) = calculateInterest(deltaTime, loan.interestRate, pending);\n                newInterest = safeAdd(calculatedInterest, newInterest);\n                newTimestamp = loan.interestTimestamp + realDelta;\n            }\n\n            if (timestamp > loan.dueTime) {\n                uint256 startPunitory = max(loan.dueTime, loan.interestTimestamp);\n                deltaTime = timestamp - startPunitory;\n\n                uint256 debt = safeAdd(loan.amount, newInterest);\n                pending = min(debt, safeSubtract(safeAdd(debt, newPunitoryInterest), loan.paid));\n\n                (realDelta, calculatedInterest) = calculateInterest(deltaTime, loan.interestRatePunitory, pending);\n                newPunitoryInterest = safeAdd(newPunitoryInterest, calculatedInterest);\n                newTimestamp = startPunitory + realDelta;\n            }\n            \n            if (newInterest != loan.interest || newPunitoryInterest != loan.punitoryInterest) {\n                loan.interestTimestamp = newTimestamp;\n                loan.interest = newInterest;\n                loan.punitoryInterest = newPunitoryInterest;\n            }\n        }\n    }\n\n    /**\n        @dev Computes loan interest only up to current unix time\n\n        @param timestamp Target absolute unix time to calculate interest.\n    */\n    function addInterestUpTo(Loan storage loan, uint256 timestamp) internal {\n        require(loan.status == Status.lent);\n        if (timestamp <= block.timestamp) {\n            internalAddInterest(loan, timestamp);\n        }\n    }\n\n    /**\n        @dev Updates the loan accumulated interests up to the current Unix time.\n        \n        @param index Index of the loan\n    */\n    function addInterest(uint index) public {\n        Loan storage loan = loans[index];\n        addInterestUpTo(loan, block.timestamp);\n    }\n    \n    /**\n        @dev Pay loan\n\n        Realizes a payment of a given Loan, before performing the payment the accumulated\n        interest is computed and added to the total pending amount.\n\n        Before calling this function, the msg.sender must call the \"approve\" function on the RCN Token, specifying an amount\n        sufficient enough to pay the equivalent of the desired payment and the oracle fee.\n\n        Because it is difficult or even impossible to know in advance how much RCN are going to be spent on the\n        transaction*, we recommend performing the \"approve\" using an amount 5% superior to the wallet estimated\n        spending. If the RCN spent results to be less, the extra tokens are never debited from the msg.sender.\n\n        * The RCN rate can fluctuate on the same block, and it is impossible to know in advance the exact time of the\n        confirmation of the transaction. \n\n        If the paid pending amount equals zero, the loan changes status to \"paid\" and it is considered closed.\n\n        @param index Index of the loan\n        @param _amount Amount to pay, specified in the loan currency; or in RCN if the loan has no oracle\n        @param _from The identity of the payer\n        @param oracleData Data required by the oracle to return the rate, the content of this field must be provided\n            by the url exposed in the url() method of the oracle.\n            \n        @return true if the payment was executed successfully\n    */\n    function pay(uint index, uint256 _amount, address _from, bytes oracleData) public returns (bool) {\n        Loan storage loan = loans[index];\n\n        require(loan.status == Status.lent);\n        addInterest(index);\n        uint256 toPay = min(getPendingAmount(index), _amount);\n        PartialPayment(index, msg.sender, _from, toPay);\n\n        loan.paid = safeAdd(loan.paid, toPay);\n\n        if (getRawPendingAmount(loan) == 0) {\n            TotalPayment(index);\n            loan.status = Status.paid;\n\n            // ERC721, remove loan from circulation\n            lendersBalance[loan.lender] -= 1;\n            activeLoans -= 1;\n            Transfer(loan.lender, 0x0, index);\n        }\n\n        uint256 rate = getRate(loan, oracleData);\n        uint256 transferValue = safeMult(toPay, rate);\n        lockTokens(rcn, transferValue);\n        require(rcn.transferFrom(msg.sender, this, transferValue));\n        loan.lenderBalance = safeAdd(transferValue, loan.lenderBalance);\n\n        return true;\n    }\n\n    /**\n        @dev Retrieves the rate corresponding of the loan oracle, if the loan has no oracle the rate is 1\n\n        @param loan The loan with the cosigner\n        @param data Data required by the oracle\n\n        @return The rate of the oracle\n    */\n    function getRate(Loan loan, bytes data) internal returns (uint256) {\n        if (loan.oracle == address(0)) {\n            return 1;\n        } else {\n            return loan.oracle.getRate(loan.currency, data);\n        }\n    }\n\n    /**\n        @dev Withdraw lender funds\n\n        When a loan is paid, the funds are not transferred automatically to the lender, the funds are stored on the\n        engine contract, and the lender must call this function specifying the amount desired to transfer and the \n        destination.\n\n        This behavior is defined to allow the temporary transfer of the loan to a smart contract, without worrying that\n        the contract will receive tokens that are not traceable; and it allows the development of decentralized \n        autonomous organizations.\n\n        @param index Index of the loan\n        @param to Destination of the wiwthdraw funds\n        @param amount Amount to withdraw, in RCN\n\n        @return true if the withdraw was executed successfully\n    */\n    function withdrawal(uint index, address to, uint256 amount) public returns (bool) {\n        Loan storage loan = loans[index];\n        require(msg.sender == loan.lender);\n        loan.lenderBalance = safeSubtract(loan.lenderBalance, amount);\n        require(rcn.transfer(to, amount));\n        unlockTokens(rcn, amount);\n        return true;\n    }\n\n    function withdrawalRange(uint256 fromIndex, uint256 toIndex, address to) public returns (uint256) {\n        uint256 loanId;\n        uint256 totalWithdraw = 0;\n\n        for (loanId = fromIndex; loanId <= toIndex; loanId++) {\n            Loan storage loan = loans[loanId];\n            if (loan.lender == msg.sender) {\n                totalWithdraw += loan.lenderBalance;\n                loan.lenderBalance = 0;\n            }\n        }\n\n        require(rcn.transfer(to, totalWithdraw));\n        unlockTokens(rcn, totalWithdraw);\n        \n        return totalWithdraw;\n    }\n\n    function withdrawalList(uint256[] memory loanIds, address to) public returns (uint256) {\n        uint256 inputId;\n        uint256 totalWithdraw = 0;\n\n        for (inputId = 0; inputId < loanIds.length; inputId++) {\n            Loan storage loan = loans[loanIds[inputId]];\n            if (loan.lender == msg.sender) {\n                totalWithdraw += loan.lenderBalance;\n                loan.lenderBalance = 0;\n            }\n        }\n\n        require(rcn.transfer(to, totalWithdraw));\n        unlockTokens(rcn, totalWithdraw);\n\n        return totalWithdraw;\n    }\n\n    /**\n        @dev Deprecates the engine, locks the creation of new loans.\n    */\n    function setDeprecated(bool _deprecated) public onlyOwner {\n        deprecated = _deprecated;\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinfabrik-RCN Network Smart Contract Audit/rcn-network-3ded36151ad55543d16c354e70161852de4061d0/contracts/NanoLoanEngine.sol",
        "vulnerability": "Assertion Failure",
        "check": "FP",
        "response": "Answer: Yes\nDescription: The variable `totalLoans` is obtained from `totalSupply()`, which is equivalent to `activeLoans`. Therefore, the loop condition `loanId <= totalLoans` exceeds valid loan indices, as `loanId` should be less than `totalLoans`. This leads to an out-of-bounds array access, which may cause an assertion failure."
    },
    {
        "code_segment": "contract NanoLoanEngine is ERC721, Engine, Ownable, TokenLockable {\n    uint256 public constant VERSION = 202;\n    string public constant VERSION_NAME = \"Basalt\";\n\n    uint256 private activeLoans = 0;\n    mapping(address => uint256) private lendersBalance;\n\n    function name() constant returns (string _name) {\n        _name = \"RCN - Nano loan engine - Basalt 202\";\n    }\n\n    function symbol() constant returns (string _symbol) {\n        _symbol = \"RCN-NLE-202\";\n    }\n\n    function totalSupply() constant returns (uint _totalSupply) {\n        _totalSupply = activeLoans;\n    }\n\n    function balanceOf(address _owner) constant returns (uint _balance) {\n        _balance = lendersBalance[_owner];\n    }\n\n    function tokenOfOwnerByIndex(address _owner, uint256 _index) constant returns (uint tokenId) {\n        uint256 tokenCount = balanceOf(_owner);\n\n        if (tokenCount == 0 || _index >= tokenCount) {\n            // Fail transaction\n            revert();\n        } else {\n            uint256 totalLoans = totalSupply();\n            uint256 resultIndex = 0;\n\n            uint256 loanId;\n            // SWC-128-DoS With Block Gas Limit: L46\n            for (loanId = 0; loanId <= totalLoans; loanId++) {\n                if (loans[loanId].lender == _owner && loans[loanId].status == Status.lent) {\n                    if (resultIndex == _index) {\n                        return loanId;\n                    }\n                    resultIndex++;\n                }\n            }\n\n            revert();\n        }\n    }\n\n    function tokensOfOwner(address _owner) external constant returns(uint256[] ownerTokens) {\n        uint256 tokenCount = balanceOf(_owner);\n\n        if (tokenCount == 0) {\n            // Return an empty array\n            return new uint256[](0);\n        } else {\n            uint256[] memory result = new uint256[](tokenCount);\n            uint256 totalLoans = totalSupply();\n            uint256 resultIndex = 0;\n\n            uint256 loanId;\n\n            for (loanId = 0; loanId <= totalLoans; loanId++) {\n                if (loans[loanId].lender == _owner && loans[loanId].status == Status.lent) {\n                    result[resultIndex] = loanId;\n                    resultIndex++;\n                }\n            }\n\n            return result;\n        }\n    }\n    \n    Token public rcn;\n    bool public deprecated;\n\n    event CreatedLoan(uint _index, address _borrower, address _creator);\n    event ApprovedBy(uint _index, address _address);\n    event Lent(uint _index, address _lender, address _cosigner);\n    event DestroyedBy(uint _index, address _address);\n    event PartialPayment(uint _index, address _sender, address _from, uint256 _amount);\n    event TotalPayment(uint _index);\n\n    function NanoLoanEngine(Token _rcn) public {\n        owner = msg.sender;\n        rcn = _rcn;\n    }\n\n    struct Loan {\n        Status status;\n        Oracle oracle;\n\n        address borrower;\n        address lender;\n        address creator;\n        address cosigner;\n        \n        uint256 amount;\n        uint256 interest;\n        uint256 punitoryInterest;\n        uint256 interestTimestamp;\n        uint256 paid;\n        uint256 interestRate;\n        uint256 interestRatePunitory;\n        uint256 dueTime;\n        uint256 duesIn;\n\n        bytes32 currency;\n        uint256 cancelableAt;\n        uint256 lenderBalance;\n\n        address approvedTransfer;\n        uint256 expirationRequest;\n\n        mapping(address => bool) approbations;\n    }\n\n    Loan[] private loans;\n\n    /**\n        @dev Creates a loan request, the loan can be generated with any borrower, cosigner, and conditions; if the \n        cosigner and borrower agree they must call the \"approve\" function.\n\n        The creator of the loan is the caller of this function; this is useful to track which wallet created the loan.\n\n        @param _oracleContract Address of the Oracle contract, if the loan does not use any oracle, this field should be 0x0.\n        @param _borrower Address of the borrower\n        @param _currency The currency to use with the oracle, the currency code is generated with the following formula,\n            keccak256(ticker,decimals).\n        @param _amount The requested amount; currency and unit are defined by the Oracle, if there is no Oracle present\n            the currency is RCN, and the unit is wei.\n        @param _interestRate The non-punitory interest rate by second, defined as a denominator of 10 000 000.\n        @param _interestRatePunitory The punitory interest rate by second, defined as a denominator of 10 000 000.\n            Ej: interestRate 11108571428571 = 28% Anual interest\n        @param _duesIn The time in seconds that the borrower has in order to pay the debt after the lender lends the money.\n        @param _cancelableAt Delta in seconds specifying how much interest should be added in advance, if the borrower pays \n        entirely or partially the loan before this term, no extra interest will be deducted.\n        @param _expirationRequest Timestamp of when the loan request expires, if the loan is not filled before this date, \n            the request is no longer valid.\n    */\n    function createLoan(Oracle _oracleContract, address _borrower, bytes32 _currency, uint256 _amount, uint256 _interestRate,\n        uint256 _interestRatePunitory, uint256 _duesIn, uint256 _cancelableAt, uint256 _expirationRequest) returns (uint256) {\n\n        require(!deprecated);\n        require(_cancelableAt <= _duesIn);\n        require(_oracleContract != address(0) || _currency == 0x0);\n        require(_borrower != address(0));\n        require(_amount != 0);\n        require(_interestRatePunitory != 0);\n        require(_interestRate != 0);\n        require(_expirationRequest > block.timestamp);\n\n        var loan = Loan(Status.initial, _oracleContract, _borrower, 0x0, msg.sender, 0x0, _amount, 0, 0, 0, 0, _interestRate,\n            _interestRatePunitory, 0, _duesIn, _currency, _cancelableAt, 0, 0x0, _expirationRequest);\n        uint index = loans.push(loan) - 1;\n        CreatedLoan(index, _borrower, msg.sender);\n\n        if (msg.sender == _borrower) {\n            approveLoan(index);\n        }\n\n        return index;\n    }\n    \n    function ownerOf(uint256 index) constant returns (address owner) { owner = loans[index].lender; }\n    function getTotalLoans() constant returns (uint256) { return loans.length; }\n    function getOracle(uint index) constant returns (Oracle) { return loans[index].oracle; }\n    function getBorrower(uint index) constant returns (address) { return loans[index].borrower; }\n    function getCosigner(uint index) constant returns (address) { return loans[index].cosigner; }\n    function getCreator(uint index) constant returns (address) { return loans[index].creator; }\n    function getAmount(uint index) constant returns (uint256) { return loans[index].amount; }\n    function getPunitoryInterest(uint index) constant returns (uint256) { return loans[index].punitoryInterest; }\n    function getInterestTimestamp(uint index) constant returns (uint256) { return loans[index].interestTimestamp; }\n    function getPaid(uint index) constant returns (uint256) { return loans[index].paid; }\n    function getInterestRate(uint index) constant returns (uint256) { return loans[index].interestRate; }\n    function getInterestRatePunitory(uint index) constant returns (uint256) { return loans[index].interestRatePunitory; }\n    function getDueTime(uint index) constant returns (uint256) { return loans[index].dueTime; }\n    function getDuesIn(uint index) constant returns (uint256) { return loans[index].duesIn; }\n    function getCancelableAt(uint index) constant returns (uint256) { return loans[index].cancelableAt; }\n    function getApprobation(uint index, address _address) constant returns (bool) { return loans[index].approbations[_address]; }\n    function getStatus(uint index) constant returns (Status) { return loans[index].status; }\n    function getLenderBalance(uint index) constant returns (uint256) { return loans[index].lenderBalance; }\n    function getApprovedTransfer(uint index) constant returns (address) {return loans[index].approvedTransfer; }\n    function getCurrency(uint index) constant returns (bytes32) { return loans[index].currency; }\n    function getExpirationRequest(uint index) constant returns (uint256) { return loans[index].expirationRequest; }\n    function getInterest(uint index) constant returns (uint256) { return loans[index].interest; }\n\n    /**\n        @param index Index of the loan\n\n        @return true if the loan has been approved by the borrower and cosigner.\n    */\n    function isApproved(uint index) constant returns (bool) {\n        Loan storage loan = loans[index];\n        return loan.approbations[loan.borrower];\n    }\n\n    /**\n        @dev Called by the members of the loan to show that they agree with the terms of the loan; the borrower\n        must call this method before any lender could call the method \"lend\".\n            \n        Any address can call this method to be added to the \"approbations\" mapping.\n\n        @param index Index of the loan\n\n        @return true if the approve was done successfully\n    */\n    function approveLoan(uint index) public returns(bool) {\n        Loan storage loan = loans[index];\n        require(loan.status == Status.initial);\n        loan.approbations[msg.sender] = true;\n        ApprovedBy(index, msg.sender);\n        return true;\n    }\n\n    /**\n        @dev Performs the lend of the RCN equivalent to the requested amount, and transforms the msg.sender in the new lender.\n\n        The loan must be previously approved by the borrower; before calling this function, the lender candidate must \n        call the \"approve\" function on the RCN Token, specifying an amount sufficient enough to pay the equivalent of\n        the requested amount, and the cosigner fee.\n        \n        @param index Index of the loan\n        @param oracleData Data required by the oracle to return the rate, the content of this field must be provided\n            by the url exposed in the url() method of the oracle.\n        @param cosigner Address of the cosigner, 0x0 for lending without cosigner.\n        @param cosignerData Data required by the cosigner to process the request.\n\n        @return true if the lend was done successfully\n    */\n    function lend(uint index, bytes oracleData, Cosigner cosigner, bytes cosignerData) public returns (bool) {\n        Loan storage loan = loans[index];\n\n        require(loan.status == Status.initial);\n        require(isApproved(index));\n        require(block.timestamp <= loan.expirationRequest);\n\n        loan.lender = msg.sender;\n        loan.dueTime = safeAdd(block.timestamp, loan.duesIn);\n        loan.interestTimestamp = block.timestamp;\n        loan.status = Status.lent;\n        \n        if (loan.cancelableAt > 0)\n            internalAddInterest(loan, safeAdd(block.timestamp, loan.cancelableAt));\n\n        uint256 rate = getRate(loan, oracleData);\n\n        if (cosigner != address(0)) {\n            // The cosigner it's temporary set to the next address (cosigner + 2), it's expected that the cosigner will\n            // call the method \"cosign\" to accept the conditions; that method also sets the cosigner to the right\n            // address. If that does not happen, the transaction fails.\n            loan.cosigner = address(uint256(cosigner) + 2);\n            require(cosigner.requestCosign(this, index, cosignerData, oracleData));\n            require(loan.cosigner == address(cosigner));\n        }\n        \n        require(rcn.transferFrom(msg.sender, loan.borrower, safeMult(loan.amount, rate)));\n        \n        // ERC721, create new loan and transfer it to the lender\n        Transfer(0x0, loan.lender, index);\n        activeLoans += 1;\n        lendersBalance[loan.lender] += 1;\n        Lent(index, loan.lender, cosigner);\n\n        return true;\n    }\n\n    /**\n        @dev The cosigner must call this method to accept the conditions of a loan, this method pays the cosigner his fee\n\n        @param index Index of the loan\n        @param cost Fee set by the cosigner\n\n        @return true If the cosign was successfull\n    */\n    function cosign(uint index, uint256 cost) external returns (bool) {\n        Loan storage loan = loans[index];\n        require(loan.status == Status.lent && (loan.dueTime - loan.duesIn) == block.timestamp);\n        require(loan.cosigner != address(0));\n        require(loan.cosigner == address(uint256(msg.sender) + 2));\n        loan.cosigner = msg.sender;\n        require(rcn.transferFrom(loan.lender, msg.sender, cost));\n        return true;\n    }\n\n    /**\n        @dev Destroys a loan, the borrower could call this method if they performed an accidental or regretted \n        \"approve\" of the loan, this method only works for them if the loan is in \"pending\" status.\n\n        The lender can call this method at any moment, in case of a loan with status \"lent\" the lender is pardoning \n        the debt. \n\n        @param index Index of the loan\n\n        @return true if the destroy was done successfully\n    */\n    function destroy(uint index) public returns (bool) {\n        Loan storage loan = loans[index];\n        require(loan.status != Status.destroyed);\n        require(msg.sender == loan.lender || (msg.sender == loan.borrower && loan.status == Status.initial));\n        DestroyedBy(index, msg.sender);\n\n        // ERC721, remove loan from circulation\n        if (loan.status != Status.initial) {\n            lendersBalance[loan.lender] -= 1;\n            activeLoans -= 1;\n            Transfer(loan.lender, 0x0, index);\n        }\n\n        loan.status = Status.destroyed;\n        return true;\n    }\n\n    /**\n        @dev Transfers a loan to a different lender, the caller must be the current lender or previously being\n        approved with the method \"approveTransfer\"; only loans with the Status.lent status can be transfered.\n\n        @param index Index of the loan\n        @param to New lender\n\n        @return true if the transfer was done successfully\n    */\n    function transfer(address to, uint256 index) public returns (bool) {\n        Loan storage loan = loans[index];\n        \n        require(loan.status != Status.destroyed && loan.status != Status.paid);\n        require(msg.sender == loan.lender || msg.sender == loan.approvedTransfer);\n        require(to != address(0));\n        loan.lender = to;\n        loan.approvedTransfer = address(0);\n\n        // ERC721, transfer loan to another address\n        lendersBalance[msg.sender] -= 1;\n        lendersBalance[to] += 1;\n        Transfer(loan.lender, to, index);\n\n        return true;\n    }\n\n    /**\n        @dev ERC721 method, transfers the loan to the msg.sender, the msg.sender must be approved using the \n        \"approve\" method.\n\n        @return true if the transfer was successfull\n    */\n    function takeOwnership(uint256 _index) public returns (bool) {\n        return transfer(msg.sender, _index);\n    }\n\n    /**\n        @dev Approves the transfer of a given loan in the name of the lender, the behavior of this function is similar to\n        \"approve\" in the ERC20 standard, but only one approved address is allowed at a time.\n\n        The same method can be called passing 0x0 as parameter \"to\" to erase a previously approved address.\n\n        @param to Address allowed to transfer the loan or 0x0 to delete\n        @param index Index of the loan\n\n        @return true if the approve was done successfully\n    */\n    function approve(address to, uint256 index) public returns (bool) {\n        Loan storage loan = loans[index];\n        require(msg.sender == loan.lender);\n        loan.approvedTransfer = to;\n        Approval(msg.sender, to, index);\n        return true;\n    }\n\n    /**\n        @dev Returns the pending amount to complete de payment of the loan, keep in mind that this number increases \n        every second.\n\n        @param index Index of the loan\n\n        @return Aprox pending payment amount\n    */\n    function getPendingAmount(uint index) public constant returns (uint256) {\n        Loan storage loan = loans[index];\n        addInterest(index);\n        return getRawPendingAmount(loan);\n    }\n\n    function getRawPendingAmount(Loan loan) internal returns (uint256) {\n        return safeSubtract(safeAdd(safeAdd(loan.amount, loan.interest), loan.punitoryInterest), loan.paid);\n    }\n\n    /**\n        @dev Calculates the interest of a given amount, interest rate and delta time.\n\n        @param timeDelta Elapsed time\n        @param interestRate Interest rate expressed as the denominator of 10 000 000.\n        @param amount Amount to apply interest\n\n        @return realDelta The real timeDelta applied\n        @return interest The interest gained in the realDelta time\n    */\n    function calculateInterest(uint256 timeDelta, uint256 interestRate, uint256 amount) public constant returns (uint256 realDelta, uint256 interest) {\n        if (amount == 0) {\n            interest = 0;\n            realDelta = timeDelta;\n        } else {\n            interest = safeMult(safeMult(100000, amount), timeDelta) / interestRate;\n            realDelta = safeMult(interest, interestRate) / (amount * 100000);\n        }\n    }\n\n    /**\n        @dev Computes loan interest\n\n        Computes the punitory and non-punitory interest of a given loan and only applies the change.\n        \n        @param loan Loan to compute interest\n        @param timestamp Target absolute unix time to calculate interest.\n    */\n    function internalAddInterest(Loan storage loan, uint256 timestamp) internal {\n        if (timestamp > loan.interestTimestamp) {\n            uint256 newInterest = loan.interest;\n            uint256 newPunitoryInterest = loan.punitoryInterest;\n\n            uint256 newTimestamp;\n            uint256 realDelta;\n            uint256 calculatedInterest;\n\n            uint256 deltaTime;\n            uint256 pending;\n\n            uint256 endNonPunitory = min(timestamp, loan.dueTime);\n            if (endNonPunitory > loan.interestTimestamp) {\n                deltaTime = endNonPunitory - loan.interestTimestamp;\n\n                if (loan.paid < loan.amount) {\n                    pending = loan.amount - loan.paid;\n                } else {\n                    pending = 0;\n                }\n\n                (realDelta, calculatedInterest) = calculateInterest(deltaTime, loan.interestRate, pending);\n                newInterest = safeAdd(calculatedInterest, newInterest);\n                newTimestamp = loan.interestTimestamp + realDelta;\n            }\n\n            if (timestamp > loan.dueTime) {\n                uint256 startPunitory = max(loan.dueTime, loan.interestTimestamp);\n                deltaTime = timestamp - startPunitory;\n\n                uint256 debt = safeAdd(loan.amount, newInterest);\n                pending = min(debt, safeSubtract(safeAdd(debt, newPunitoryInterest), loan.paid));\n\n                (realDelta, calculatedInterest) = calculateInterest(deltaTime, loan.interestRatePunitory, pending);\n                newPunitoryInterest = safeAdd(newPunitoryInterest, calculatedInterest);\n                newTimestamp = startPunitory + realDelta;\n            }\n            \n            if (newInterest != loan.interest || newPunitoryInterest != loan.punitoryInterest) {\n                loan.interestTimestamp = newTimestamp;\n                loan.interest = newInterest;\n                loan.punitoryInterest = newPunitoryInterest;\n            }\n        }\n    }\n\n    /**\n        @dev Computes loan interest only up to current unix time\n\n        @param timestamp Target absolute unix time to calculate interest.\n    */\n    function addInterestUpTo(Loan storage loan, uint256 timestamp) internal {\n        require(loan.status == Status.lent);\n        if (timestamp <= block.timestamp) {\n            internalAddInterest(loan, timestamp);\n        }\n    }\n\n    /**\n        @dev Updates the loan accumulated interests up to the current Unix time.\n        \n        @param index Index of the loan\n    */\n    function addInterest(uint index) public {\n        Loan storage loan = loans[index];\n        addInterestUpTo(loan, block.timestamp);\n    }\n    \n    /**\n        @dev Pay loan\n\n        Realizes a payment of a given Loan, before performing the payment the accumulated\n        interest is computed and added to the total pending amount.\n\n        Before calling this function, the msg.sender must call the \"approve\" function on the RCN Token, specifying an amount\n        sufficient enough to pay the equivalent of the desired payment and the oracle fee.\n\n        Because it is difficult or even impossible to know in advance how much RCN are going to be spent on the\n        transaction*, we recommend performing the \"approve\" using an amount 5% superior to the wallet estimated\n        spending. If the RCN spent results to be less, the extra tokens are never debited from the msg.sender.\n\n        * The RCN rate can fluctuate on the same block, and it is impossible to know in advance the exact time of the\n        confirmation of the transaction. \n\n        If the paid pending amount equals zero, the loan changes status to \"paid\" and it is considered closed.\n\n        @param index Index of the loan\n        @param _amount Amount to pay, specified in the loan currency; or in RCN if the loan has no oracle\n        @param _from The identity of the payer\n        @param oracleData Data required by the oracle to return the rate, the content of this field must be provided\n            by the url exposed in the url() method of the oracle.\n            \n        @return true if the payment was executed successfully\n    */\n    function pay(uint index, uint256 _amount, address _from, bytes oracleData) public returns (bool) {\n        Loan storage loan = loans[index];\n\n        require(loan.status == Status.lent);\n        addInterest(index);\n        uint256 toPay = min(getPendingAmount(index), _amount);\n        PartialPayment(index, msg.sender, _from, toPay);\n\n        loan.paid = safeAdd(loan.paid, toPay);\n\n        if (getRawPendingAmount(loan) == 0) {\n            TotalPayment(index);\n            loan.status = Status.paid;\n\n            // ERC721, remove loan from circulation\n            lendersBalance[loan.lender] -= 1;\n            activeLoans -= 1;\n            Transfer(loan.lender, 0x0, index);\n        }\n\n        uint256 rate = getRate(loan, oracleData);\n        uint256 transferValue = safeMult(toPay, rate);\n        lockTokens(rcn, transferValue);\n        require(rcn.transferFrom(msg.sender, this, transferValue));\n        loan.lenderBalance = safeAdd(transferValue, loan.lenderBalance);\n\n        return true;\n    }\n\n    /**\n        @dev Retrieves the rate corresponding of the loan oracle, if the loan has no oracle the rate is 1\n\n        @param loan The loan with the cosigner\n        @param data Data required by the oracle\n\n        @return The rate of the oracle\n    */\n    function getRate(Loan loan, bytes data) internal returns (uint256) {\n        if (loan.oracle == address(0)) {\n            return 1;\n        } else {\n            return loan.oracle.getRate(loan.currency, data);\n        }\n    }\n\n    /**\n        @dev Withdraw lender funds\n\n        When a loan is paid, the funds are not transferred automatically to the lender, the funds are stored on the\n        engine contract, and the lender must call this function specifying the amount desired to transfer and the \n        destination.\n\n        This behavior is defined to allow the temporary transfer of the loan to a smart contract, without worrying that\n        the contract will receive tokens that are not traceable; and it allows the development of decentralized \n        autonomous organizations.\n\n        @param index Index of the loan\n        @param to Destination of the wiwthdraw funds\n        @param amount Amount to withdraw, in RCN\n\n        @return true if the withdraw was executed successfully\n    */\n    function withdrawal(uint index, address to, uint256 amount) public returns (bool) {\n        Loan storage loan = loans[index];\n        require(msg.sender == loan.lender);\n        loan.lenderBalance = safeSubtract(loan.lenderBalance, amount);\n        require(rcn.transfer(to, amount));\n        unlockTokens(rcn, amount);\n        return true;\n    }\n\n    function withdrawalRange(uint256 fromIndex, uint256 toIndex, address to) public returns (uint256) {\n        uint256 loanId;\n        uint256 totalWithdraw = 0;\n\n        for (loanId = fromIndex; loanId <= toIndex; loanId++) {\n            Loan storage loan = loans[loanId];\n            if (loan.lender == msg.sender) {\n                totalWithdraw += loan.lenderBalance;\n                loan.lenderBalance = 0;\n            }\n        }\n\n        require(rcn.transfer(to, totalWithdraw));\n        unlockTokens(rcn, totalWithdraw);\n        \n        return totalWithdraw;\n    }\n\n    function withdrawalList(uint256[] memory loanIds, address to) public returns (uint256) {\n        uint256 inputId;\n        uint256 totalWithdraw = 0;\n\n        for (inputId = 0; inputId < loanIds.length; inputId++) {\n            Loan storage loan = loans[loanIds[inputId]];\n            if (loan.lender == msg.sender) {\n                totalWithdraw += loan.lenderBalance;\n                loan.lenderBalance = 0;\n            }\n        }\n\n        require(rcn.transfer(to, totalWithdraw));\n        unlockTokens(rcn, totalWithdraw);\n\n        return totalWithdraw;\n    }\n\n    /**\n        @dev Deprecates the engine, locks the creation of new loans.\n    */\n    function setDeprecated(bool _deprecated) public onlyOwner {\n        deprecated = _deprecated;\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinfabrik-RCN Network Smart Contract Audit/rcn-network-3ded36151ad55543d16c354e70161852de4061d0/contracts/NanoLoanEngine.sol",
        "vulnerability": "Assertion Failure",
        "check": "FP",
        "response": "Answer: No\nReason: There are no assertions in the code that could fail and cause an \"Assertion Failure\"."
    },
    {
        "code_segment": "contract NanoLoanEngine is ERC721, Engine, Ownable, TokenLockable {\n    uint256 public constant VERSION = 202;\n    string public constant VERSION_NAME = \"Basalt\";\n\n    uint256 private activeLoans = 0;\n    mapping(address => uint256) private lendersBalance;\n\n    function name() constant returns (string _name) {\n        _name = \"RCN - Nano loan engine - Basalt 202\";\n    }\n\n    function symbol() constant returns (string _symbol) {\n        _symbol = \"RCN-NLE-202\";\n    }\n\n    function totalSupply() constant returns (uint _totalSupply) {\n        _totalSupply = activeLoans;\n    }\n\n    function balanceOf(address _owner) constant returns (uint _balance) {\n        _balance = lendersBalance[_owner];\n    }\n\n    function tokenOfOwnerByIndex(address _owner, uint256 _index) constant returns (uint tokenId) {\n        uint256 tokenCount = balanceOf(_owner);\n\n        if (tokenCount == 0 || _index >= tokenCount) {\n            // Fail transaction\n            revert();\n        } else {\n            uint256 totalLoans = totalSupply();\n            uint256 resultIndex = 0;\n\n            uint256 loanId;\n            // SWC-128-DoS With Block Gas Limit: L46\n            for (loanId = 0; loanId <= totalLoans; loanId++) {\n                if (loans[loanId].lender == _owner && loans[loanId].status == Status.lent) {\n                    if (resultIndex == _index) {\n                        return loanId;\n                    }\n                    resultIndex++;\n                }\n            }\n\n            revert();\n        }\n    }\n\n    function tokensOfOwner(address _owner) external constant returns(uint256[] ownerTokens) {\n        uint256 tokenCount = balanceOf(_owner);\n\n        if (tokenCount == 0) {\n            // Return an empty array\n            return new uint256[](0);\n        } else {\n            uint256[] memory result = new uint256[](tokenCount);\n            uint256 totalLoans = totalSupply();\n            uint256 resultIndex = 0;\n\n            uint256 loanId;\n\n            for (loanId = 0; loanId <= totalLoans; loanId++) {\n                if (loans[loanId].lender == _owner && loans[loanId].status == Status.lent) {\n                    result[resultIndex] = loanId;\n                    resultIndex++;\n                }\n            }\n\n            return result;\n        }\n    }\n    \n    Token public rcn;\n    bool public deprecated;\n\n    event CreatedLoan(uint _index, address _borrower, address _creator);\n    event ApprovedBy(uint _index, address _address);\n    event Lent(uint _index, address _lender, address _cosigner);\n    event DestroyedBy(uint _index, address _address);\n    event PartialPayment(uint _index, address _sender, address _from, uint256 _amount);\n    event TotalPayment(uint _index);\n\n    function NanoLoanEngine(Token _rcn) public {\n        owner = msg.sender;\n        rcn = _rcn;\n    }\n\n    struct Loan {\n        Status status;\n        Oracle oracle;\n\n        address borrower;\n        address lender;\n        address creator;\n        address cosigner;\n        \n        uint256 amount;\n        uint256 interest;\n        uint256 punitoryInterest;\n        uint256 interestTimestamp;\n        uint256 paid;\n        uint256 interestRate;\n        uint256 interestRatePunitory;\n        uint256 dueTime;\n        uint256 duesIn;\n\n        bytes32 currency;\n        uint256 cancelableAt;\n        uint256 lenderBalance;\n\n        address approvedTransfer;\n        uint256 expirationRequest;\n\n        mapping(address => bool) approbations;\n    }\n\n    Loan[] private loans;\n\n    /**\n        @dev Creates a loan request, the loan can be generated with any borrower, cosigner, and conditions; if the \n        cosigner and borrower agree they must call the \"approve\" function.\n\n        The creator of the loan is the caller of this function; this is useful to track which wallet created the loan.\n\n        @param _oracleContract Address of the Oracle contract, if the loan does not use any oracle, this field should be 0x0.\n        @param _borrower Address of the borrower\n        @param _currency The currency to use with the oracle, the currency code is generated with the following formula,\n            keccak256(ticker,decimals).\n        @param _amount The requested amount; currency and unit are defined by the Oracle, if there is no Oracle present\n            the currency is RCN, and the unit is wei.\n        @param _interestRate The non-punitory interest rate by second, defined as a denominator of 10 000 000.\n        @param _interestRatePunitory The punitory interest rate by second, defined as a denominator of 10 000 000.\n            Ej: interestRate 11108571428571 = 28% Anual interest\n        @param _duesIn The time in seconds that the borrower has in order to pay the debt after the lender lends the money.\n        @param _cancelableAt Delta in seconds specifying how much interest should be added in advance, if the borrower pays \n        entirely or partially the loan before this term, no extra interest will be deducted.\n        @param _expirationRequest Timestamp of when the loan request expires, if the loan is not filled before this date, \n            the request is no longer valid.\n    */\n    function createLoan(Oracle _oracleContract, address _borrower, bytes32 _currency, uint256 _amount, uint256 _interestRate,\n        uint256 _interestRatePunitory, uint256 _duesIn, uint256 _cancelableAt, uint256 _expirationRequest) returns (uint256) {\n\n        require(!deprecated);\n        require(_cancelableAt <= _duesIn);\n        require(_oracleContract != address(0) || _currency == 0x0);\n        require(_borrower != address(0));\n        require(_amount != 0);\n        require(_interestRatePunitory != 0);\n        require(_interestRate != 0);\n        require(_expirationRequest > block.timestamp);\n\n        var loan = Loan(Status.initial, _oracleContract, _borrower, 0x0, msg.sender, 0x0, _amount, 0, 0, 0, 0, _interestRate,\n            _interestRatePunitory, 0, _duesIn, _currency, _cancelableAt, 0, 0x0, _expirationRequest);\n        uint index = loans.push(loan) - 1;\n        CreatedLoan(index, _borrower, msg.sender);\n\n        if (msg.sender == _borrower) {\n            approveLoan(index);\n        }\n\n        return index;\n    }\n    \n    function ownerOf(uint256 index) constant returns (address owner) { owner = loans[index].lender; }\n    function getTotalLoans() constant returns (uint256) { return loans.length; }\n    function getOracle(uint index) constant returns (Oracle) { return loans[index].oracle; }\n    function getBorrower(uint index) constant returns (address) { return loans[index].borrower; }\n    function getCosigner(uint index) constant returns (address) { return loans[index].cosigner; }\n    function getCreator(uint index) constant returns (address) { return loans[index].creator; }\n    function getAmount(uint index) constant returns (uint256) { return loans[index].amount; }\n    function getPunitoryInterest(uint index) constant returns (uint256) { return loans[index].punitoryInterest; }\n    function getInterestTimestamp(uint index) constant returns (uint256) { return loans[index].interestTimestamp; }\n    function getPaid(uint index) constant returns (uint256) { return loans[index].paid; }\n    function getInterestRate(uint index) constant returns (uint256) { return loans[index].interestRate; }\n    function getInterestRatePunitory(uint index) constant returns (uint256) { return loans[index].interestRatePunitory; }\n    function getDueTime(uint index) constant returns (uint256) { return loans[index].dueTime; }\n    function getDuesIn(uint index) constant returns (uint256) { return loans[index].duesIn; }\n    function getCancelableAt(uint index) constant returns (uint256) { return loans[index].cancelableAt; }\n    function getApprobation(uint index, address _address) constant returns (bool) { return loans[index].approbations[_address]; }\n    function getStatus(uint index) constant returns (Status) { return loans[index].status; }\n    function getLenderBalance(uint index) constant returns (uint256) { return loans[index].lenderBalance; }\n    function getApprovedTransfer(uint index) constant returns (address) {return loans[index].approvedTransfer; }\n    function getCurrency(uint index) constant returns (bytes32) { return loans[index].currency; }\n    function getExpirationRequest(uint index) constant returns (uint256) { return loans[index].expirationRequest; }\n    function getInterest(uint index) constant returns (uint256) { return loans[index].interest; }\n\n    /**\n        @param index Index of the loan\n\n        @return true if the loan has been approved by the borrower and cosigner.\n    */\n    function isApproved(uint index) constant returns (bool) {\n        Loan storage loan = loans[index];\n        return loan.approbations[loan.borrower];\n    }\n\n    /**\n        @dev Called by the members of the loan to show that they agree with the terms of the loan; the borrower\n        must call this method before any lender could call the method \"lend\".\n            \n        Any address can call this method to be added to the \"approbations\" mapping.\n\n        @param index Index of the loan\n\n        @return true if the approve was done successfully\n    */\n    function approveLoan(uint index) public returns(bool) {\n        Loan storage loan = loans[index];\n        require(loan.status == Status.initial);\n        loan.approbations[msg.sender] = true;\n        ApprovedBy(index, msg.sender);\n        return true;\n    }\n\n    /**\n        @dev Performs the lend of the RCN equivalent to the requested amount, and transforms the msg.sender in the new lender.\n\n        The loan must be previously approved by the borrower; before calling this function, the lender candidate must \n        call the \"approve\" function on the RCN Token, specifying an amount sufficient enough to pay the equivalent of\n        the requested amount, and the cosigner fee.\n        \n        @param index Index of the loan\n        @param oracleData Data required by the oracle to return the rate, the content of this field must be provided\n            by the url exposed in the url() method of the oracle.\n        @param cosigner Address of the cosigner, 0x0 for lending without cosigner.\n        @param cosignerData Data required by the cosigner to process the request.\n\n        @return true if the lend was done successfully\n    */\n    function lend(uint index, bytes oracleData, Cosigner cosigner, bytes cosignerData) public returns (bool) {\n        Loan storage loan = loans[index];\n\n        require(loan.status == Status.initial);\n        require(isApproved(index));\n        require(block.timestamp <= loan.expirationRequest);\n\n        loan.lender = msg.sender;\n        loan.dueTime = safeAdd(block.timestamp, loan.duesIn);\n        loan.interestTimestamp = block.timestamp;\n        loan.status = Status.lent;\n        \n        if (loan.cancelableAt > 0)\n            internalAddInterest(loan, safeAdd(block.timestamp, loan.cancelableAt));\n\n        uint256 rate = getRate(loan, oracleData);\n\n        if (cosigner != address(0)) {\n            // The cosigner it's temporary set to the next address (cosigner + 2), it's expected that the cosigner will\n            // call the method \"cosign\" to accept the conditions; that method also sets the cosigner to the right\n            // address. If that does not happen, the transaction fails.\n            loan.cosigner = address(uint256(cosigner) + 2);\n            require(cosigner.requestCosign(this, index, cosignerData, oracleData));\n            require(loan.cosigner == address(cosigner));\n        }\n        \n        require(rcn.transferFrom(msg.sender, loan.borrower, safeMult(loan.amount, rate)));\n        \n        // ERC721, create new loan and transfer it to the lender\n        Transfer(0x0, loan.lender, index);\n        activeLoans += 1;\n        lendersBalance[loan.lender] += 1;\n        Lent(index, loan.lender, cosigner);\n\n        return true;\n    }\n\n    /**\n        @dev The cosigner must call this method to accept the conditions of a loan, this method pays the cosigner his fee\n\n        @param index Index of the loan\n        @param cost Fee set by the cosigner\n\n        @return true If the cosign was successfull\n    */\n    function cosign(uint index, uint256 cost) external returns (bool) {\n        Loan storage loan = loans[index];\n        require(loan.status == Status.lent && (loan.dueTime - loan.duesIn) == block.timestamp);\n        require(loan.cosigner != address(0));\n        require(loan.cosigner == address(uint256(msg.sender) + 2));\n        loan.cosigner = msg.sender;\n        require(rcn.transferFrom(loan.lender, msg.sender, cost));\n        return true;\n    }\n\n    /**\n        @dev Destroys a loan, the borrower could call this method if they performed an accidental or regretted \n        \"approve\" of the loan, this method only works for them if the loan is in \"pending\" status.\n\n        The lender can call this method at any moment, in case of a loan with status \"lent\" the lender is pardoning \n        the debt. \n\n        @param index Index of the loan\n\n        @return true if the destroy was done successfully\n    */\n    function destroy(uint index) public returns (bool) {\n        Loan storage loan = loans[index];\n        require(loan.status != Status.destroyed);\n        require(msg.sender == loan.lender || (msg.sender == loan.borrower && loan.status == Status.initial));\n        DestroyedBy(index, msg.sender);\n\n        // ERC721, remove loan from circulation\n        if (loan.status != Status.initial) {\n            lendersBalance[loan.lender] -= 1;\n            activeLoans -= 1;\n            Transfer(loan.lender, 0x0, index);\n        }\n\n        loan.status = Status.destroyed;\n        return true;\n    }\n\n    /**\n        @dev Transfers a loan to a different lender, the caller must be the current lender or previously being\n        approved with the method \"approveTransfer\"; only loans with the Status.lent status can be transfered.\n\n        @param index Index of the loan\n        @param to New lender\n\n        @return true if the transfer was done successfully\n    */\n    function transfer(address to, uint256 index) public returns (bool) {\n        Loan storage loan = loans[index];\n        \n        require(loan.status != Status.destroyed && loan.status != Status.paid);\n        require(msg.sender == loan.lender || msg.sender == loan.approvedTransfer);\n        require(to != address(0));\n        loan.lender = to;\n        loan.approvedTransfer = address(0);\n\n        // ERC721, transfer loan to another address\n        lendersBalance[msg.sender] -= 1;\n        lendersBalance[to] += 1;\n        Transfer(loan.lender, to, index);\n\n        return true;\n    }\n\n    /**\n        @dev ERC721 method, transfers the loan to the msg.sender, the msg.sender must be approved using the \n        \"approve\" method.\n\n        @return true if the transfer was successfull\n    */\n    function takeOwnership(uint256 _index) public returns (bool) {\n        return transfer(msg.sender, _index);\n    }\n\n    /**\n        @dev Approves the transfer of a given loan in the name of the lender, the behavior of this function is similar to\n        \"approve\" in the ERC20 standard, but only one approved address is allowed at a time.\n\n        The same method can be called passing 0x0 as parameter \"to\" to erase a previously approved address.\n\n        @param to Address allowed to transfer the loan or 0x0 to delete\n        @param index Index of the loan\n\n        @return true if the approve was done successfully\n    */\n    function approve(address to, uint256 index) public returns (bool) {\n        Loan storage loan = loans[index];\n        require(msg.sender == loan.lender);\n        loan.approvedTransfer = to;\n        Approval(msg.sender, to, index);\n        return true;\n    }\n\n    /**\n        @dev Returns the pending amount to complete de payment of the loan, keep in mind that this number increases \n        every second.\n\n        @param index Index of the loan\n\n        @return Aprox pending payment amount\n    */\n    function getPendingAmount(uint index) public constant returns (uint256) {\n        Loan storage loan = loans[index];\n        addInterest(index);\n        return getRawPendingAmount(loan);\n    }\n\n    function getRawPendingAmount(Loan loan) internal returns (uint256) {\n        return safeSubtract(safeAdd(safeAdd(loan.amount, loan.interest), loan.punitoryInterest), loan.paid);\n    }\n\n    /**\n        @dev Calculates the interest of a given amount, interest rate and delta time.\n\n        @param timeDelta Elapsed time\n        @param interestRate Interest rate expressed as the denominator of 10 000 000.\n        @param amount Amount to apply interest\n\n        @return realDelta The real timeDelta applied\n        @return interest The interest gained in the realDelta time\n    */\n    function calculateInterest(uint256 timeDelta, uint256 interestRate, uint256 amount) public constant returns (uint256 realDelta, uint256 interest) {\n        if (amount == 0) {\n            interest = 0;\n            realDelta = timeDelta;\n        } else {\n            interest = safeMult(safeMult(100000, amount), timeDelta) / interestRate;\n            realDelta = safeMult(interest, interestRate) / (amount * 100000);\n        }\n    }\n\n    /**\n        @dev Computes loan interest\n\n        Computes the punitory and non-punitory interest of a given loan and only applies the change.\n        \n        @param loan Loan to compute interest\n        @param timestamp Target absolute unix time to calculate interest.\n    */\n    function internalAddInterest(Loan storage loan, uint256 timestamp) internal {\n        if (timestamp > loan.interestTimestamp) {\n            uint256 newInterest = loan.interest;\n            uint256 newPunitoryInterest = loan.punitoryInterest;\n\n            uint256 newTimestamp;\n            uint256 realDelta;\n            uint256 calculatedInterest;\n\n            uint256 deltaTime;\n            uint256 pending;\n\n            uint256 endNonPunitory = min(timestamp, loan.dueTime);\n            if (endNonPunitory > loan.interestTimestamp) {\n                deltaTime = endNonPunitory - loan.interestTimestamp;\n\n                if (loan.paid < loan.amount) {\n                    pending = loan.amount - loan.paid;\n                } else {\n                    pending = 0;\n                }\n\n                (realDelta, calculatedInterest) = calculateInterest(deltaTime, loan.interestRate, pending);\n                newInterest = safeAdd(calculatedInterest, newInterest);\n                newTimestamp = loan.interestTimestamp + realDelta;\n            }\n\n            if (timestamp > loan.dueTime) {\n                uint256 startPunitory = max(loan.dueTime, loan.interestTimestamp);\n                deltaTime = timestamp - startPunitory;\n\n                uint256 debt = safeAdd(loan.amount, newInterest);\n                pending = min(debt, safeSubtract(safeAdd(debt, newPunitoryInterest), loan.paid));\n\n                (realDelta, calculatedInterest) = calculateInterest(deltaTime, loan.interestRatePunitory, pending);\n                newPunitoryInterest = safeAdd(newPunitoryInterest, calculatedInterest);\n                newTimestamp = startPunitory + realDelta;\n            }\n            \n            if (newInterest != loan.interest || newPunitoryInterest != loan.punitoryInterest) {\n                loan.interestTimestamp = newTimestamp;\n                loan.interest = newInterest;\n                loan.punitoryInterest = newPunitoryInterest;\n            }\n        }\n    }\n\n    /**\n        @dev Computes loan interest only up to current unix time\n\n        @param timestamp Target absolute unix time to calculate interest.\n    */\n    function addInterestUpTo(Loan storage loan, uint256 timestamp) internal {\n        require(loan.status == Status.lent);\n        if (timestamp <= block.timestamp) {\n            internalAddInterest(loan, timestamp);\n        }\n    }\n\n    /**\n        @dev Updates the loan accumulated interests up to the current Unix time.\n        \n        @param index Index of the loan\n    */\n    function addInterest(uint index) public {\n        Loan storage loan = loans[index];\n        addInterestUpTo(loan, block.timestamp);\n    }\n    \n    /**\n        @dev Pay loan\n\n        Realizes a payment of a given Loan, before performing the payment the accumulated\n        interest is computed and added to the total pending amount.\n\n        Before calling this function, the msg.sender must call the \"approve\" function on the RCN Token, specifying an amount\n        sufficient enough to pay the equivalent of the desired payment and the oracle fee.\n\n        Because it is difficult or even impossible to know in advance how much RCN are going to be spent on the\n        transaction*, we recommend performing the \"approve\" using an amount 5% superior to the wallet estimated\n        spending. If the RCN spent results to be less, the extra tokens are never debited from the msg.sender.\n\n        * The RCN rate can fluctuate on the same block, and it is impossible to know in advance the exact time of the\n        confirmation of the transaction. \n\n        If the paid pending amount equals zero, the loan changes status to \"paid\" and it is considered closed.\n\n        @param index Index of the loan\n        @param _amount Amount to pay, specified in the loan currency; or in RCN if the loan has no oracle\n        @param _from The identity of the payer\n        @param oracleData Data required by the oracle to return the rate, the content of this field must be provided\n            by the url exposed in the url() method of the oracle.\n            \n        @return true if the payment was executed successfully\n    */\n    function pay(uint index, uint256 _amount, address _from, bytes oracleData) public returns (bool) {\n        Loan storage loan = loans[index];\n\n        require(loan.status == Status.lent);\n        addInterest(index);\n        uint256 toPay = min(getPendingAmount(index), _amount);\n        PartialPayment(index, msg.sender, _from, toPay);\n\n        loan.paid = safeAdd(loan.paid, toPay);\n\n        if (getRawPendingAmount(loan) == 0) {\n            TotalPayment(index);\n            loan.status = Status.paid;\n\n            // ERC721, remove loan from circulation\n            lendersBalance[loan.lender] -= 1;\n            activeLoans -= 1;\n            Transfer(loan.lender, 0x0, index);\n        }\n\n        uint256 rate = getRate(loan, oracleData);\n        uint256 transferValue = safeMult(toPay, rate);\n        lockTokens(rcn, transferValue);\n        require(rcn.transferFrom(msg.sender, this, transferValue));\n        loan.lenderBalance = safeAdd(transferValue, loan.lenderBalance);\n\n        return true;\n    }\n\n    /**\n        @dev Retrieves the rate corresponding of the loan oracle, if the loan has no oracle the rate is 1\n\n        @param loan The loan with the cosigner\n        @param data Data required by the oracle\n\n        @return The rate of the oracle\n    */\n    function getRate(Loan loan, bytes data) internal returns (uint256) {\n        if (loan.oracle == address(0)) {\n            return 1;\n        } else {\n            return loan.oracle.getRate(loan.currency, data);\n        }\n    }\n\n    /**\n        @dev Withdraw lender funds\n\n        When a loan is paid, the funds are not transferred automatically to the lender, the funds are stored on the\n        engine contract, and the lender must call this function specifying the amount desired to transfer and the \n        destination.\n\n        This behavior is defined to allow the temporary transfer of the loan to a smart contract, without worrying that\n        the contract will receive tokens that are not traceable; and it allows the development of decentralized \n        autonomous organizations.\n\n        @param index Index of the loan\n        @param to Destination of the wiwthdraw funds\n        @param amount Amount to withdraw, in RCN\n\n        @return true if the withdraw was executed successfully\n    */\n    function withdrawal(uint index, address to, uint256 amount) public returns (bool) {\n        Loan storage loan = loans[index];\n        require(msg.sender == loan.lender);\n        loan.lenderBalance = safeSubtract(loan.lenderBalance, amount);\n        require(rcn.transfer(to, amount));\n        unlockTokens(rcn, amount);\n        return true;\n    }\n\n    function withdrawalRange(uint256 fromIndex, uint256 toIndex, address to) public returns (uint256) {\n        uint256 loanId;\n        uint256 totalWithdraw = 0;\n\n        for (loanId = fromIndex; loanId <= toIndex; loanId++) {\n            Loan storage loan = loans[loanId];\n            if (loan.lender == msg.sender) {\n                totalWithdraw += loan.lenderBalance;\n                loan.lenderBalance = 0;\n            }\n        }\n\n        require(rcn.transfer(to, totalWithdraw));\n        unlockTokens(rcn, totalWithdraw);\n        \n        return totalWithdraw;\n    }\n\n    function withdrawalList(uint256[] memory loanIds, address to) public returns (uint256) {\n        uint256 inputId;\n        uint256 totalWithdraw = 0;\n\n        for (inputId = 0; inputId < loanIds.length; inputId++) {\n            Loan storage loan = loans[loanIds[inputId]];\n            if (loan.lender == msg.sender) {\n                totalWithdraw += loan.lenderBalance;\n                loan.lenderBalance = 0;\n            }\n        }\n\n        require(rcn.transfer(to, totalWithdraw));\n        unlockTokens(rcn, totalWithdraw);\n\n        return totalWithdraw;\n    }\n\n    /**\n        @dev Deprecates the engine, locks the creation of new loans.\n    */\n    function setDeprecated(bool _deprecated) public onlyOwner {\n        deprecated = _deprecated;\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinfabrik-RCN Network Smart Contract Audit/rcn-network-3ded36151ad55543d16c354e70161852de4061d0/contracts/NanoLoanEngine.sol",
        "vulnerability": "Assertion Failure",
        "check": "FP",
        "response": "Answer: No\nReason: The provided code does not contain any assert() statements that could cause an assertion failure vulnerability. However, it uses require() and revert() for error handling, which do not fall under assertion failures."
    },
    {
        "code_segment": "contract NanoLoanEngine is ERC721, Engine, Ownable, TokenLockable {\n    uint256 public constant VERSION = 202;\n    string public constant VERSION_NAME = \"Basalt\";\n\n    uint256 private activeLoans = 0;\n    mapping(address => uint256) private lendersBalance;\n\n    function name() constant returns (string _name) {\n        _name = \"RCN - Nano loan engine - Basalt 202\";\n    }\n\n    function symbol() constant returns (string _symbol) {\n        _symbol = \"RCN-NLE-202\";\n    }\n\n    function totalSupply() constant returns (uint _totalSupply) {\n        _totalSupply = activeLoans;\n    }\n\n    function balanceOf(address _owner) constant returns (uint _balance) {\n        _balance = lendersBalance[_owner];\n    }\n\n    function tokenOfOwnerByIndex(address _owner, uint256 _index) constant returns (uint tokenId) {\n        uint256 tokenCount = balanceOf(_owner);\n\n        if (tokenCount == 0 || _index >= tokenCount) {\n            // Fail transaction\n            revert();\n        } else {\n            uint256 totalLoans = totalSupply();\n            uint256 resultIndex = 0;\n\n            uint256 loanId;\n            // SWC-128-DoS With Block Gas Limit: L46\n            for (loanId = 0; loanId <= totalLoans; loanId++) {\n                if (loans[loanId].lender == _owner && loans[loanId].status == Status.lent) {\n                    if (resultIndex == _index) {\n                        return loanId;\n                    }\n                    resultIndex++;\n                }\n            }\n\n            revert();\n        }\n    }\n\n    function tokensOfOwner(address _owner) external constant returns(uint256[] ownerTokens) {\n        uint256 tokenCount = balanceOf(_owner);\n\n        if (tokenCount == 0) {\n            // Return an empty array\n            return new uint256[](0);\n        } else {\n            uint256[] memory result = new uint256[](tokenCount);\n            uint256 totalLoans = totalSupply();\n            uint256 resultIndex = 0;\n\n            uint256 loanId;\n\n            for (loanId = 0; loanId <= totalLoans; loanId++) {\n                if (loans[loanId].lender == _owner && loans[loanId].status == Status.lent) {\n                    result[resultIndex] = loanId;\n                    resultIndex++;\n                }\n            }\n\n            return result;\n        }\n    }\n    \n    Token public rcn;\n    bool public deprecated;\n\n    event CreatedLoan(uint _index, address _borrower, address _creator);\n    event ApprovedBy(uint _index, address _address);\n    event Lent(uint _index, address _lender, address _cosigner);\n    event DestroyedBy(uint _index, address _address);\n    event PartialPayment(uint _index, address _sender, address _from, uint256 _amount);\n    event TotalPayment(uint _index);\n\n    function NanoLoanEngine(Token _rcn) public {\n        owner = msg.sender;\n        rcn = _rcn;\n    }\n\n    struct Loan {\n        Status status;\n        Oracle oracle;\n\n        address borrower;\n        address lender;\n        address creator;\n        address cosigner;\n        \n        uint256 amount;\n        uint256 interest;\n        uint256 punitoryInterest;\n        uint256 interestTimestamp;\n        uint256 paid;\n        uint256 interestRate;\n        uint256 interestRatePunitory;\n        uint256 dueTime;\n        uint256 duesIn;\n\n        bytes32 currency;\n        uint256 cancelableAt;\n        uint256 lenderBalance;\n\n        address approvedTransfer;\n        uint256 expirationRequest;\n\n        mapping(address => bool) approbations;\n    }\n\n    Loan[] private loans;\n\n    /**\n        @dev Creates a loan request, the loan can be generated with any borrower, cosigner, and conditions; if the \n        cosigner and borrower agree they must call the \"approve\" function.\n\n        The creator of the loan is the caller of this function; this is useful to track which wallet created the loan.\n\n        @param _oracleContract Address of the Oracle contract, if the loan does not use any oracle, this field should be 0x0.\n        @param _borrower Address of the borrower\n        @param _currency The currency to use with the oracle, the currency code is generated with the following formula,\n            keccak256(ticker,decimals).\n        @param _amount The requested amount; currency and unit are defined by the Oracle, if there is no Oracle present\n            the currency is RCN, and the unit is wei.\n        @param _interestRate The non-punitory interest rate by second, defined as a denominator of 10 000 000.\n        @param _interestRatePunitory The punitory interest rate by second, defined as a denominator of 10 000 000.\n            Ej: interestRate 11108571428571 = 28% Anual interest\n        @param _duesIn The time in seconds that the borrower has in order to pay the debt after the lender lends the money.\n        @param _cancelableAt Delta in seconds specifying how much interest should be added in advance, if the borrower pays \n        entirely or partially the loan before this term, no extra interest will be deducted.\n        @param _expirationRequest Timestamp of when the loan request expires, if the loan is not filled before this date, \n            the request is no longer valid.\n    */\n    function createLoan(Oracle _oracleContract, address _borrower, bytes32 _currency, uint256 _amount, uint256 _interestRate,\n        uint256 _interestRatePunitory, uint256 _duesIn, uint256 _cancelableAt, uint256 _expirationRequest) returns (uint256) {\n\n        require(!deprecated);\n        require(_cancelableAt <= _duesIn);\n        require(_oracleContract != address(0) || _currency == 0x0);\n        require(_borrower != address(0));\n        require(_amount != 0);\n        require(_interestRatePunitory != 0);\n        require(_interestRate != 0);\n        require(_expirationRequest > block.timestamp);\n\n        var loan = Loan(Status.initial, _oracleContract, _borrower, 0x0, msg.sender, 0x0, _amount, 0, 0, 0, 0, _interestRate,\n            _interestRatePunitory, 0, _duesIn, _currency, _cancelableAt, 0, 0x0, _expirationRequest);\n        uint index = loans.push(loan) - 1;\n        CreatedLoan(index, _borrower, msg.sender);\n\n        if (msg.sender == _borrower) {\n            approveLoan(index);\n        }\n\n        return index;\n    }\n    \n    function ownerOf(uint256 index) constant returns (address owner) { owner = loans[index].lender; }\n    function getTotalLoans() constant returns (uint256) { return loans.length; }\n    function getOracle(uint index) constant returns (Oracle) { return loans[index].oracle; }\n    function getBorrower(uint index) constant returns (address) { return loans[index].borrower; }\n    function getCosigner(uint index) constant returns (address) { return loans[index].cosigner; }\n    function getCreator(uint index) constant returns (address) { return loans[index].creator; }\n    function getAmount(uint index) constant returns (uint256) { return loans[index].amount; }\n    function getPunitoryInterest(uint index) constant returns (uint256) { return loans[index].punitoryInterest; }\n    function getInterestTimestamp(uint index) constant returns (uint256) { return loans[index].interestTimestamp; }\n    function getPaid(uint index) constant returns (uint256) { return loans[index].paid; }\n    function getInterestRate(uint index) constant returns (uint256) { return loans[index].interestRate; }\n    function getInterestRatePunitory(uint index) constant returns (uint256) { return loans[index].interestRatePunitory; }\n    function getDueTime(uint index) constant returns (uint256) { return loans[index].dueTime; }\n    function getDuesIn(uint index) constant returns (uint256) { return loans[index].duesIn; }\n    function getCancelableAt(uint index) constant returns (uint256) { return loans[index].cancelableAt; }\n    function getApprobation(uint index, address _address) constant returns (bool) { return loans[index].approbations[_address]; }\n    function getStatus(uint index) constant returns (Status) { return loans[index].status; }\n    function getLenderBalance(uint index) constant returns (uint256) { return loans[index].lenderBalance; }\n    function getApprovedTransfer(uint index) constant returns (address) {return loans[index].approvedTransfer; }\n    function getCurrency(uint index) constant returns (bytes32) { return loans[index].currency; }\n    function getExpirationRequest(uint index) constant returns (uint256) { return loans[index].expirationRequest; }\n    function getInterest(uint index) constant returns (uint256) { return loans[index].interest; }\n\n    /**\n        @param index Index of the loan\n\n        @return true if the loan has been approved by the borrower and cosigner.\n    */\n    function isApproved(uint index) constant returns (bool) {\n        Loan storage loan = loans[index];\n        return loan.approbations[loan.borrower];\n    }\n\n    /**\n        @dev Called by the members of the loan to show that they agree with the terms of the loan; the borrower\n        must call this method before any lender could call the method \"lend\".\n            \n        Any address can call this method to be added to the \"approbations\" mapping.\n\n        @param index Index of the loan\n\n        @return true if the approve was done successfully\n    */\n    function approveLoan(uint index) public returns(bool) {\n        Loan storage loan = loans[index];\n        require(loan.status == Status.initial);\n        loan.approbations[msg.sender] = true;\n        ApprovedBy(index, msg.sender);\n        return true;\n    }\n\n    /**\n        @dev Performs the lend of the RCN equivalent to the requested amount, and transforms the msg.sender in the new lender.\n\n        The loan must be previously approved by the borrower; before calling this function, the lender candidate must \n        call the \"approve\" function on the RCN Token, specifying an amount sufficient enough to pay the equivalent of\n        the requested amount, and the cosigner fee.\n        \n        @param index Index of the loan\n        @param oracleData Data required by the oracle to return the rate, the content of this field must be provided\n            by the url exposed in the url() method of the oracle.\n        @param cosigner Address of the cosigner, 0x0 for lending without cosigner.\n        @param cosignerData Data required by the cosigner to process the request.\n\n        @return true if the lend was done successfully\n    */\n    function lend(uint index, bytes oracleData, Cosigner cosigner, bytes cosignerData) public returns (bool) {\n        Loan storage loan = loans[index];\n\n        require(loan.status == Status.initial);\n        require(isApproved(index));\n        require(block.timestamp <= loan.expirationRequest);\n\n        loan.lender = msg.sender;\n        loan.dueTime = safeAdd(block.timestamp, loan.duesIn);\n        loan.interestTimestamp = block.timestamp;\n        loan.status = Status.lent;\n        \n        if (loan.cancelableAt > 0)\n            internalAddInterest(loan, safeAdd(block.timestamp, loan.cancelableAt));\n\n        uint256 rate = getRate(loan, oracleData);\n\n        if (cosigner != address(0)) {\n            // The cosigner it's temporary set to the next address (cosigner + 2), it's expected that the cosigner will\n            // call the method \"cosign\" to accept the conditions; that method also sets the cosigner to the right\n            // address. If that does not happen, the transaction fails.\n            loan.cosigner = address(uint256(cosigner) + 2);\n            require(cosigner.requestCosign(this, index, cosignerData, oracleData));\n            require(loan.cosigner == address(cosigner));\n        }\n        \n        require(rcn.transferFrom(msg.sender, loan.borrower, safeMult(loan.amount, rate)));\n        \n        // ERC721, create new loan and transfer it to the lender\n        Transfer(0x0, loan.lender, index);\n        activeLoans += 1;\n        lendersBalance[loan.lender] += 1;\n        Lent(index, loan.lender, cosigner);\n\n        return true;\n    }\n\n    /**\n        @dev The cosigner must call this method to accept the conditions of a loan, this method pays the cosigner his fee\n\n        @param index Index of the loan\n        @param cost Fee set by the cosigner\n\n        @return true If the cosign was successfull\n    */\n    function cosign(uint index, uint256 cost) external returns (bool) {\n        Loan storage loan = loans[index];\n        require(loan.status == Status.lent && (loan.dueTime - loan.duesIn) == block.timestamp);\n        require(loan.cosigner != address(0));\n        require(loan.cosigner == address(uint256(msg.sender) + 2));\n        loan.cosigner = msg.sender;\n        require(rcn.transferFrom(loan.lender, msg.sender, cost));\n        return true;\n    }\n\n    /**\n        @dev Destroys a loan, the borrower could call this method if they performed an accidental or regretted \n        \"approve\" of the loan, this method only works for them if the loan is in \"pending\" status.\n\n        The lender can call this method at any moment, in case of a loan with status \"lent\" the lender is pardoning \n        the debt. \n\n        @param index Index of the loan\n\n        @return true if the destroy was done successfully\n    */\n    function destroy(uint index) public returns (bool) {\n        Loan storage loan = loans[index];\n        require(loan.status != Status.destroyed);\n        require(msg.sender == loan.lender || (msg.sender == loan.borrower && loan.status == Status.initial));\n        DestroyedBy(index, msg.sender);\n\n        // ERC721, remove loan from circulation\n        if (loan.status != Status.initial) {\n            lendersBalance[loan.lender] -= 1;\n            activeLoans -= 1;\n            Transfer(loan.lender, 0x0, index);\n        }\n\n        loan.status = Status.destroyed;\n        return true;\n    }\n\n    /**\n        @dev Transfers a loan to a different lender, the caller must be the current lender or previously being\n        approved with the method \"approveTransfer\"; only loans with the Status.lent status can be transfered.\n\n        @param index Index of the loan\n        @param to New lender\n\n        @return true if the transfer was done successfully\n    */\n    function transfer(address to, uint256 index) public returns (bool) {\n        Loan storage loan = loans[index];\n        \n        require(loan.status != Status.destroyed && loan.status != Status.paid);\n        require(msg.sender == loan.lender || msg.sender == loan.approvedTransfer);\n        require(to != address(0));\n        loan.lender = to;\n        loan.approvedTransfer = address(0);\n\n        // ERC721, transfer loan to another address\n        lendersBalance[msg.sender] -= 1;\n        lendersBalance[to] += 1;\n        Transfer(loan.lender, to, index);\n\n        return true;\n    }\n\n    /**\n        @dev ERC721 method, transfers the loan to the msg.sender, the msg.sender must be approved using the \n        \"approve\" method.\n\n        @return true if the transfer was successfull\n    */\n    function takeOwnership(uint256 _index) public returns (bool) {\n        return transfer(msg.sender, _index);\n    }\n\n    /**\n        @dev Approves the transfer of a given loan in the name of the lender, the behavior of this function is similar to\n        \"approve\" in the ERC20 standard, but only one approved address is allowed at a time.\n\n        The same method can be called passing 0x0 as parameter \"to\" to erase a previously approved address.\n\n        @param to Address allowed to transfer the loan or 0x0 to delete\n        @param index Index of the loan\n\n        @return true if the approve was done successfully\n    */\n    function approve(address to, uint256 index) public returns (bool) {\n        Loan storage loan = loans[index];\n        require(msg.sender == loan.lender);\n        loan.approvedTransfer = to;\n        Approval(msg.sender, to, index);\n        return true;\n    }\n\n    /**\n        @dev Returns the pending amount to complete de payment of the loan, keep in mind that this number increases \n        every second.\n\n        @param index Index of the loan\n\n        @return Aprox pending payment amount\n    */\n    function getPendingAmount(uint index) public constant returns (uint256) {\n        Loan storage loan = loans[index];\n        addInterest(index);\n        return getRawPendingAmount(loan);\n    }\n\n    function getRawPendingAmount(Loan loan) internal returns (uint256) {\n        return safeSubtract(safeAdd(safeAdd(loan.amount, loan.interest), loan.punitoryInterest), loan.paid);\n    }\n\n    /**\n        @dev Calculates the interest of a given amount, interest rate and delta time.\n\n        @param timeDelta Elapsed time\n        @param interestRate Interest rate expressed as the denominator of 10 000 000.\n        @param amount Amount to apply interest\n\n        @return realDelta The real timeDelta applied\n        @return interest The interest gained in the realDelta time\n    */\n    function calculateInterest(uint256 timeDelta, uint256 interestRate, uint256 amount) public constant returns (uint256 realDelta, uint256 interest) {\n        if (amount == 0) {\n            interest = 0;\n            realDelta = timeDelta;\n        } else {\n            interest = safeMult(safeMult(100000, amount), timeDelta) / interestRate;\n            realDelta = safeMult(interest, interestRate) / (amount * 100000);\n        }\n    }\n\n    /**\n        @dev Computes loan interest\n\n        Computes the punitory and non-punitory interest of a given loan and only applies the change.\n        \n        @param loan Loan to compute interest\n        @param timestamp Target absolute unix time to calculate interest.\n    */\n    function internalAddInterest(Loan storage loan, uint256 timestamp) internal {\n        if (timestamp > loan.interestTimestamp) {\n            uint256 newInterest = loan.interest;\n            uint256 newPunitoryInterest = loan.punitoryInterest;\n\n            uint256 newTimestamp;\n            uint256 realDelta;\n            uint256 calculatedInterest;\n\n            uint256 deltaTime;\n            uint256 pending;\n\n            uint256 endNonPunitory = min(timestamp, loan.dueTime);\n            if (endNonPunitory > loan.interestTimestamp) {\n                deltaTime = endNonPunitory - loan.interestTimestamp;\n\n                if (loan.paid < loan.amount) {\n                    pending = loan.amount - loan.paid;\n                } else {\n                    pending = 0;\n                }\n\n                (realDelta, calculatedInterest) = calculateInterest(deltaTime, loan.interestRate, pending);\n                newInterest = safeAdd(calculatedInterest, newInterest);\n                newTimestamp = loan.interestTimestamp + realDelta;\n            }\n\n            if (timestamp > loan.dueTime) {\n                uint256 startPunitory = max(loan.dueTime, loan.interestTimestamp);\n                deltaTime = timestamp - startPunitory;\n\n                uint256 debt = safeAdd(loan.amount, newInterest);\n                pending = min(debt, safeSubtract(safeAdd(debt, newPunitoryInterest), loan.paid));\n\n                (realDelta, calculatedInterest) = calculateInterest(deltaTime, loan.interestRatePunitory, pending);\n                newPunitoryInterest = safeAdd(newPunitoryInterest, calculatedInterest);\n                newTimestamp = startPunitory + realDelta;\n            }\n            \n            if (newInterest != loan.interest || newPunitoryInterest != loan.punitoryInterest) {\n                loan.interestTimestamp = newTimestamp;\n                loan.interest = newInterest;\n                loan.punitoryInterest = newPunitoryInterest;\n            }\n        }\n    }\n\n    /**\n        @dev Computes loan interest only up to current unix time\n\n        @param timestamp Target absolute unix time to calculate interest.\n    */\n    function addInterestUpTo(Loan storage loan, uint256 timestamp) internal {\n        require(loan.status == Status.lent);\n        if (timestamp <= block.timestamp) {\n            internalAddInterest(loan, timestamp);\n        }\n    }\n\n    /**\n        @dev Updates the loan accumulated interests up to the current Unix time.\n        \n        @param index Index of the loan\n    */\n    function addInterest(uint index) public {\n        Loan storage loan = loans[index];\n        addInterestUpTo(loan, block.timestamp);\n    }\n    \n    /**\n        @dev Pay loan\n\n        Realizes a payment of a given Loan, before performing the payment the accumulated\n        interest is computed and added to the total pending amount.\n\n        Before calling this function, the msg.sender must call the \"approve\" function on the RCN Token, specifying an amount\n        sufficient enough to pay the equivalent of the desired payment and the oracle fee.\n\n        Because it is difficult or even impossible to know in advance how much RCN are going to be spent on the\n        transaction*, we recommend performing the \"approve\" using an amount 5% superior to the wallet estimated\n        spending. If the RCN spent results to be less, the extra tokens are never debited from the msg.sender.\n\n        * The RCN rate can fluctuate on the same block, and it is impossible to know in advance the exact time of the\n        confirmation of the transaction. \n\n        If the paid pending amount equals zero, the loan changes status to \"paid\" and it is considered closed.\n\n        @param index Index of the loan\n        @param _amount Amount to pay, specified in the loan currency; or in RCN if the loan has no oracle\n        @param _from The identity of the payer\n        @param oracleData Data required by the oracle to return the rate, the content of this field must be provided\n            by the url exposed in the url() method of the oracle.\n            \n        @return true if the payment was executed successfully\n    */\n    function pay(uint index, uint256 _amount, address _from, bytes oracleData) public returns (bool) {\n        Loan storage loan = loans[index];\n\n        require(loan.status == Status.lent);\n        addInterest(index);\n        uint256 toPay = min(getPendingAmount(index), _amount);\n        PartialPayment(index, msg.sender, _from, toPay);\n\n        loan.paid = safeAdd(loan.paid, toPay);\n\n        if (getRawPendingAmount(loan) == 0) {\n            TotalPayment(index);\n            loan.status = Status.paid;\n\n            // ERC721, remove loan from circulation\n            lendersBalance[loan.lender] -= 1;\n            activeLoans -= 1;\n            Transfer(loan.lender, 0x0, index);\n        }\n\n        uint256 rate = getRate(loan, oracleData);\n        uint256 transferValue = safeMult(toPay, rate);\n        lockTokens(rcn, transferValue);\n        require(rcn.transferFrom(msg.sender, this, transferValue));\n        loan.lenderBalance = safeAdd(transferValue, loan.lenderBalance);\n\n        return true;\n    }\n\n    /**\n        @dev Retrieves the rate corresponding of the loan oracle, if the loan has no oracle the rate is 1\n\n        @param loan The loan with the cosigner\n        @param data Data required by the oracle\n\n        @return The rate of the oracle\n    */\n    function getRate(Loan loan, bytes data) internal returns (uint256) {\n        if (loan.oracle == address(0)) {\n            return 1;\n        } else {\n            return loan.oracle.getRate(loan.currency, data);\n        }\n    }\n\n    /**\n        @dev Withdraw lender funds\n\n        When a loan is paid, the funds are not transferred automatically to the lender, the funds are stored on the\n        engine contract, and the lender must call this function specifying the amount desired to transfer and the \n        destination.\n\n        This behavior is defined to allow the temporary transfer of the loan to a smart contract, without worrying that\n        the contract will receive tokens that are not traceable; and it allows the development of decentralized \n        autonomous organizations.\n\n        @param index Index of the loan\n        @param to Destination of the wiwthdraw funds\n        @param amount Amount to withdraw, in RCN\n\n        @return true if the withdraw was executed successfully\n    */\n    function withdrawal(uint index, address to, uint256 amount) public returns (bool) {\n        Loan storage loan = loans[index];\n        require(msg.sender == loan.lender);\n        loan.lenderBalance = safeSubtract(loan.lenderBalance, amount);\n        require(rcn.transfer(to, amount));\n        unlockTokens(rcn, amount);\n        return true;\n    }\n\n    function withdrawalRange(uint256 fromIndex, uint256 toIndex, address to) public returns (uint256) {\n        uint256 loanId;\n        uint256 totalWithdraw = 0;\n\n        for (loanId = fromIndex; loanId <= toIndex; loanId++) {\n            Loan storage loan = loans[loanId];\n            if (loan.lender == msg.sender) {\n                totalWithdraw += loan.lenderBalance;\n                loan.lenderBalance = 0;\n            }\n        }\n\n        require(rcn.transfer(to, totalWithdraw));\n        unlockTokens(rcn, totalWithdraw);\n        \n        return totalWithdraw;\n    }\n\n    function withdrawalList(uint256[] memory loanIds, address to) public returns (uint256) {\n        uint256 inputId;\n        uint256 totalWithdraw = 0;\n\n        for (inputId = 0; inputId < loanIds.length; inputId++) {\n            Loan storage loan = loans[loanIds[inputId]];\n            if (loan.lender == msg.sender) {\n                totalWithdraw += loan.lenderBalance;\n                loan.lenderBalance = 0;\n            }\n        }\n\n        require(rcn.transfer(to, totalWithdraw));\n        unlockTokens(rcn, totalWithdraw);\n\n        return totalWithdraw;\n    }\n\n    /**\n        @dev Deprecates the engine, locks the creation of new loans.\n    */\n    function setDeprecated(bool _deprecated) public onlyOwner {\n        deprecated = _deprecated;\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinfabrik-RCN Network Smart Contract Audit/rcn-network-3ded36151ad55543d16c354e70161852de4061d0/contracts/NanoLoanEngine.sol",
        "vulnerability": "Assertion Failure",
        "check": "FP",
        "response": "Answer: Yes\nDescription: There are multiple calls to `revert()` in the function `tokenOfOwnerByIndex` that could trigger in the case of an invalid state or input, leading to potential assertion failure scenarios. More specifically, if any `loanId` in the range 0 to `totalLoans` does not meet the conditions (`loan.lender == _owner` and `loan.status == Status.lent`), the `revert()` call will be executed."
    },
    {
        "code_segment": "contract NanoLoanEngine is ERC721, Engine, Ownable, TokenLockable {\n    uint256 public constant VERSION = 202;\n    string public constant VERSION_NAME = \"Basalt\";\n\n    uint256 private activeLoans = 0;\n    mapping(address => uint256) private lendersBalance;\n\n    function name() constant returns (string _name) {\n        _name = \"RCN - Nano loan engine - Basalt 202\";\n    }\n\n    function symbol() constant returns (string _symbol) {\n        _symbol = \"RCN-NLE-202\";\n    }\n\n    function totalSupply() constant returns (uint _totalSupply) {\n        _totalSupply = activeLoans;\n    }\n\n    function balanceOf(address _owner) constant returns (uint _balance) {\n        _balance = lendersBalance[_owner];\n    }\n\n    function tokenOfOwnerByIndex(address _owner, uint256 _index) constant returns (uint tokenId) {\n        uint256 tokenCount = balanceOf(_owner);\n\n        if (tokenCount == 0 || _index >= tokenCount) {\n            // Fail transaction\n            revert();\n        } else {\n            uint256 totalLoans = totalSupply();\n            uint256 resultIndex = 0;\n\n            uint256 loanId;\n            // SWC-128-DoS With Block Gas Limit: L46\n            for (loanId = 0; loanId <= totalLoans; loanId++) {\n                if (loans[loanId].lender == _owner && loans[loanId].status == Status.lent) {\n                    if (resultIndex == _index) {\n                        return loanId;\n                    }\n                    resultIndex++;\n                }\n            }\n\n            revert();\n        }\n    }\n\n    function tokensOfOwner(address _owner) external constant returns(uint256[] ownerTokens) {\n        uint256 tokenCount = balanceOf(_owner);\n\n        if (tokenCount == 0) {\n            // Return an empty array\n            return new uint256[](0);\n        } else {\n            uint256[] memory result = new uint256[](tokenCount);\n            uint256 totalLoans = totalSupply();\n            uint256 resultIndex = 0;\n\n            uint256 loanId;\n\n            for (loanId = 0; loanId <= totalLoans; loanId++) {\n                if (loans[loanId].lender == _owner && loans[loanId].status == Status.lent) {\n                    result[resultIndex] = loanId;\n                    resultIndex++;\n                }\n            }\n\n            return result;\n        }\n    }\n    \n    Token public rcn;\n    bool public deprecated;\n\n    event CreatedLoan(uint _index, address _borrower, address _creator);\n    event ApprovedBy(uint _index, address _address);\n    event Lent(uint _index, address _lender, address _cosigner);\n    event DestroyedBy(uint _index, address _address);\n    event PartialPayment(uint _index, address _sender, address _from, uint256 _amount);\n    event TotalPayment(uint _index);\n\n    function NanoLoanEngine(Token _rcn) public {\n        owner = msg.sender;\n        rcn = _rcn;\n    }\n\n    struct Loan {\n        Status status;\n        Oracle oracle;\n\n        address borrower;\n        address lender;\n        address creator;\n        address cosigner;\n        \n        uint256 amount;\n        uint256 interest;\n        uint256 punitoryInterest;\n        uint256 interestTimestamp;\n        uint256 paid;\n        uint256 interestRate;\n        uint256 interestRatePunitory;\n        uint256 dueTime;\n        uint256 duesIn;\n\n        bytes32 currency;\n        uint256 cancelableAt;\n        uint256 lenderBalance;\n\n        address approvedTransfer;\n        uint256 expirationRequest;\n\n        mapping(address => bool) approbations;\n    }\n\n    Loan[] private loans;\n\n    /**\n        @dev Creates a loan request, the loan can be generated with any borrower, cosigner, and conditions; if the \n        cosigner and borrower agree they must call the \"approve\" function.\n\n        The creator of the loan is the caller of this function; this is useful to track which wallet created the loan.\n\n        @param _oracleContract Address of the Oracle contract, if the loan does not use any oracle, this field should be 0x0.\n        @param _borrower Address of the borrower\n        @param _currency The currency to use with the oracle, the currency code is generated with the following formula,\n            keccak256(ticker,decimals).\n        @param _amount The requested amount; currency and unit are defined by the Oracle, if there is no Oracle present\n            the currency is RCN, and the unit is wei.\n        @param _interestRate The non-punitory interest rate by second, defined as a denominator of 10 000 000.\n        @param _interestRatePunitory The punitory interest rate by second, defined as a denominator of 10 000 000.\n            Ej: interestRate 11108571428571 = 28% Anual interest\n        @param _duesIn The time in seconds that the borrower has in order to pay the debt after the lender lends the money.\n        @param _cancelableAt Delta in seconds specifying how much interest should be added in advance, if the borrower pays \n        entirely or partially the loan before this term, no extra interest will be deducted.\n        @param _expirationRequest Timestamp of when the loan request expires, if the loan is not filled before this date, \n            the request is no longer valid.\n    */\n    function createLoan(Oracle _oracleContract, address _borrower, bytes32 _currency, uint256 _amount, uint256 _interestRate,\n        uint256 _interestRatePunitory, uint256 _duesIn, uint256 _cancelableAt, uint256 _expirationRequest) returns (uint256) {\n\n        require(!deprecated);\n        require(_cancelableAt <= _duesIn);\n        require(_oracleContract != address(0) || _currency == 0x0);\n        require(_borrower != address(0));\n        require(_amount != 0);\n        require(_interestRatePunitory != 0);\n        require(_interestRate != 0);\n        require(_expirationRequest > block.timestamp);\n\n        var loan = Loan(Status.initial, _oracleContract, _borrower, 0x0, msg.sender, 0x0, _amount, 0, 0, 0, 0, _interestRate,\n            _interestRatePunitory, 0, _duesIn, _currency, _cancelableAt, 0, 0x0, _expirationRequest);\n        uint index = loans.push(loan) - 1;\n        CreatedLoan(index, _borrower, msg.sender);\n\n        if (msg.sender == _borrower) {\n            approveLoan(index);\n        }\n\n        return index;\n    }\n    \n    function ownerOf(uint256 index) constant returns (address owner) { owner = loans[index].lender; }\n    function getTotalLoans() constant returns (uint256) { return loans.length; }\n    function getOracle(uint index) constant returns (Oracle) { return loans[index].oracle; }\n    function getBorrower(uint index) constant returns (address) { return loans[index].borrower; }\n    function getCosigner(uint index) constant returns (address) { return loans[index].cosigner; }\n    function getCreator(uint index) constant returns (address) { return loans[index].creator; }\n    function getAmount(uint index) constant returns (uint256) { return loans[index].amount; }\n    function getPunitoryInterest(uint index) constant returns (uint256) { return loans[index].punitoryInterest; }\n    function getInterestTimestamp(uint index) constant returns (uint256) { return loans[index].interestTimestamp; }\n    function getPaid(uint index) constant returns (uint256) { return loans[index].paid; }\n    function getInterestRate(uint index) constant returns (uint256) { return loans[index].interestRate; }\n    function getInterestRatePunitory(uint index) constant returns (uint256) { return loans[index].interestRatePunitory; }\n    function getDueTime(uint index) constant returns (uint256) { return loans[index].dueTime; }\n    function getDuesIn(uint index) constant returns (uint256) { return loans[index].duesIn; }\n    function getCancelableAt(uint index) constant returns (uint256) { return loans[index].cancelableAt; }\n    function getApprobation(uint index, address _address) constant returns (bool) { return loans[index].approbations[_address]; }\n    function getStatus(uint index) constant returns (Status) { return loans[index].status; }\n    function getLenderBalance(uint index) constant returns (uint256) { return loans[index].lenderBalance; }\n    function getApprovedTransfer(uint index) constant returns (address) {return loans[index].approvedTransfer; }\n    function getCurrency(uint index) constant returns (bytes32) { return loans[index].currency; }\n    function getExpirationRequest(uint index) constant returns (uint256) { return loans[index].expirationRequest; }\n    function getInterest(uint index) constant returns (uint256) { return loans[index].interest; }\n\n    /**\n        @param index Index of the loan\n\n        @return true if the loan has been approved by the borrower and cosigner.\n    */\n    function isApproved(uint index) constant returns (bool) {\n        Loan storage loan = loans[index];\n        return loan.approbations[loan.borrower];\n    }\n\n    /**\n        @dev Called by the members of the loan to show that they agree with the terms of the loan; the borrower\n        must call this method before any lender could call the method \"lend\".\n            \n        Any address can call this method to be added to the \"approbations\" mapping.\n\n        @param index Index of the loan\n\n        @return true if the approve was done successfully\n    */\n    function approveLoan(uint index) public returns(bool) {\n        Loan storage loan = loans[index];\n        require(loan.status == Status.initial);\n        loan.approbations[msg.sender] = true;\n        ApprovedBy(index, msg.sender);\n        return true;\n    }\n\n    /**\n        @dev Performs the lend of the RCN equivalent to the requested amount, and transforms the msg.sender in the new lender.\n\n        The loan must be previously approved by the borrower; before calling this function, the lender candidate must \n        call the \"approve\" function on the RCN Token, specifying an amount sufficient enough to pay the equivalent of\n        the requested amount, and the cosigner fee.\n        \n        @param index Index of the loan\n        @param oracleData Data required by the oracle to return the rate, the content of this field must be provided\n            by the url exposed in the url() method of the oracle.\n        @param cosigner Address of the cosigner, 0x0 for lending without cosigner.\n        @param cosignerData Data required by the cosigner to process the request.\n\n        @return true if the lend was done successfully\n    */\n    function lend(uint index, bytes oracleData, Cosigner cosigner, bytes cosignerData) public returns (bool) {\n        Loan storage loan = loans[index];\n\n        require(loan.status == Status.initial);\n        require(isApproved(index));\n        require(block.timestamp <= loan.expirationRequest);\n\n        loan.lender = msg.sender;\n        loan.dueTime = safeAdd(block.timestamp, loan.duesIn);\n        loan.interestTimestamp = block.timestamp;\n        loan.status = Status.lent;\n        \n        if (loan.cancelableAt > 0)\n            internalAddInterest(loan, safeAdd(block.timestamp, loan.cancelableAt));\n\n        uint256 rate = getRate(loan, oracleData);\n\n        if (cosigner != address(0)) {\n            // The cosigner it's temporary set to the next address (cosigner + 2), it's expected that the cosigner will\n            // call the method \"cosign\" to accept the conditions; that method also sets the cosigner to the right\n            // address. If that does not happen, the transaction fails.\n            loan.cosigner = address(uint256(cosigner) + 2);\n            require(cosigner.requestCosign(this, index, cosignerData, oracleData));\n            require(loan.cosigner == address(cosigner));\n        }\n        \n        require(rcn.transferFrom(msg.sender, loan.borrower, safeMult(loan.amount, rate)));\n        \n        // ERC721, create new loan and transfer it to the lender\n        Transfer(0x0, loan.lender, index);\n        activeLoans += 1;\n        lendersBalance[loan.lender] += 1;\n        Lent(index, loan.lender, cosigner);\n\n        return true;\n    }\n\n    /**\n        @dev The cosigner must call this method to accept the conditions of a loan, this method pays the cosigner his fee\n\n        @param index Index of the loan\n        @param cost Fee set by the cosigner\n\n        @return true If the cosign was successfull\n    */\n    function cosign(uint index, uint256 cost) external returns (bool) {\n        Loan storage loan = loans[index];\n        require(loan.status == Status.lent && (loan.dueTime - loan.duesIn) == block.timestamp);\n        require(loan.cosigner != address(0));\n        require(loan.cosigner == address(uint256(msg.sender) + 2));\n        loan.cosigner = msg.sender;\n        require(rcn.transferFrom(loan.lender, msg.sender, cost));\n        return true;\n    }\n\n    /**\n        @dev Destroys a loan, the borrower could call this method if they performed an accidental or regretted \n        \"approve\" of the loan, this method only works for them if the loan is in \"pending\" status.\n\n        The lender can call this method at any moment, in case of a loan with status \"lent\" the lender is pardoning \n        the debt. \n\n        @param index Index of the loan\n\n        @return true if the destroy was done successfully\n    */\n    function destroy(uint index) public returns (bool) {\n        Loan storage loan = loans[index];\n        require(loan.status != Status.destroyed);\n        require(msg.sender == loan.lender || (msg.sender == loan.borrower && loan.status == Status.initial));\n        DestroyedBy(index, msg.sender);\n\n        // ERC721, remove loan from circulation\n        if (loan.status != Status.initial) {\n            lendersBalance[loan.lender] -= 1;\n            activeLoans -= 1;\n            Transfer(loan.lender, 0x0, index);\n        }\n\n        loan.status = Status.destroyed;\n        return true;\n    }\n\n    /**\n        @dev Transfers a loan to a different lender, the caller must be the current lender or previously being\n        approved with the method \"approveTransfer\"; only loans with the Status.lent status can be transfered.\n\n        @param index Index of the loan\n        @param to New lender\n\n        @return true if the transfer was done successfully\n    */\n    function transfer(address to, uint256 index) public returns (bool) {\n        Loan storage loan = loans[index];\n        \n        require(loan.status != Status.destroyed && loan.status != Status.paid);\n        require(msg.sender == loan.lender || msg.sender == loan.approvedTransfer);\n        require(to != address(0));\n        loan.lender = to;\n        loan.approvedTransfer = address(0);\n\n        // ERC721, transfer loan to another address\n        lendersBalance[msg.sender] -= 1;\n        lendersBalance[to] += 1;\n        Transfer(loan.lender, to, index);\n\n        return true;\n    }\n\n    /**\n        @dev ERC721 method, transfers the loan to the msg.sender, the msg.sender must be approved using the \n        \"approve\" method.\n\n        @return true if the transfer was successfull\n    */\n    function takeOwnership(uint256 _index) public returns (bool) {\n        return transfer(msg.sender, _index);\n    }\n\n    /**\n        @dev Approves the transfer of a given loan in the name of the lender, the behavior of this function is similar to\n        \"approve\" in the ERC20 standard, but only one approved address is allowed at a time.\n\n        The same method can be called passing 0x0 as parameter \"to\" to erase a previously approved address.\n\n        @param to Address allowed to transfer the loan or 0x0 to delete\n        @param index Index of the loan\n\n        @return true if the approve was done successfully\n    */\n    function approve(address to, uint256 index) public returns (bool) {\n        Loan storage loan = loans[index];\n        require(msg.sender == loan.lender);\n        loan.approvedTransfer = to;\n        Approval(msg.sender, to, index);\n        return true;\n    }\n\n    /**\n        @dev Returns the pending amount to complete de payment of the loan, keep in mind that this number increases \n        every second.\n\n        @param index Index of the loan\n\n        @return Aprox pending payment amount\n    */\n    function getPendingAmount(uint index) public constant returns (uint256) {\n        Loan storage loan = loans[index];\n        addInterest(index);\n        return getRawPendingAmount(loan);\n    }\n\n    function getRawPendingAmount(Loan loan) internal returns (uint256) {\n        return safeSubtract(safeAdd(safeAdd(loan.amount, loan.interest), loan.punitoryInterest), loan.paid);\n    }\n\n    /**\n        @dev Calculates the interest of a given amount, interest rate and delta time.\n\n        @param timeDelta Elapsed time\n        @param interestRate Interest rate expressed as the denominator of 10 000 000.\n        @param amount Amount to apply interest\n\n        @return realDelta The real timeDelta applied\n        @return interest The interest gained in the realDelta time\n    */\n    function calculateInterest(uint256 timeDelta, uint256 interestRate, uint256 amount) public constant returns (uint256 realDelta, uint256 interest) {\n        if (amount == 0) {\n            interest = 0;\n            realDelta = timeDelta;\n        } else {\n            interest = safeMult(safeMult(100000, amount), timeDelta) / interestRate;\n            realDelta = safeMult(interest, interestRate) / (amount * 100000);\n        }\n    }\n\n    /**\n        @dev Computes loan interest\n\n        Computes the punitory and non-punitory interest of a given loan and only applies the change.\n        \n        @param loan Loan to compute interest\n        @param timestamp Target absolute unix time to calculate interest.\n    */\n    function internalAddInterest(Loan storage loan, uint256 timestamp) internal {\n        if (timestamp > loan.interestTimestamp) {\n            uint256 newInterest = loan.interest;\n            uint256 newPunitoryInterest = loan.punitoryInterest;\n\n            uint256 newTimestamp;\n            uint256 realDelta;\n            uint256 calculatedInterest;\n\n            uint256 deltaTime;\n            uint256 pending;\n\n            uint256 endNonPunitory = min(timestamp, loan.dueTime);\n            if (endNonPunitory > loan.interestTimestamp) {\n                deltaTime = endNonPunitory - loan.interestTimestamp;\n\n                if (loan.paid < loan.amount) {\n                    pending = loan.amount - loan.paid;\n                } else {\n                    pending = 0;\n                }\n\n                (realDelta, calculatedInterest) = calculateInterest(deltaTime, loan.interestRate, pending);\n                newInterest = safeAdd(calculatedInterest, newInterest);\n                newTimestamp = loan.interestTimestamp + realDelta;\n            }\n\n            if (timestamp > loan.dueTime) {\n                uint256 startPunitory = max(loan.dueTime, loan.interestTimestamp);\n                deltaTime = timestamp - startPunitory;\n\n                uint256 debt = safeAdd(loan.amount, newInterest);\n                pending = min(debt, safeSubtract(safeAdd(debt, newPunitoryInterest), loan.paid));\n\n                (realDelta, calculatedInterest) = calculateInterest(deltaTime, loan.interestRatePunitory, pending);\n                newPunitoryInterest = safeAdd(newPunitoryInterest, calculatedInterest);\n                newTimestamp = startPunitory + realDelta;\n            }\n            \n            if (newInterest != loan.interest || newPunitoryInterest != loan.punitoryInterest) {\n                loan.interestTimestamp = newTimestamp;\n                loan.interest = newInterest;\n                loan.punitoryInterest = newPunitoryInterest;\n            }\n        }\n    }\n\n    /**\n        @dev Computes loan interest only up to current unix time\n\n        @param timestamp Target absolute unix time to calculate interest.\n    */\n    function addInterestUpTo(Loan storage loan, uint256 timestamp) internal {\n        require(loan.status == Status.lent);\n        if (timestamp <= block.timestamp) {\n            internalAddInterest(loan, timestamp);\n        }\n    }\n\n    /**\n        @dev Updates the loan accumulated interests up to the current Unix time.\n        \n        @param index Index of the loan\n    */\n    function addInterest(uint index) public {\n        Loan storage loan = loans[index];\n        addInterestUpTo(loan, block.timestamp);\n    }\n    \n    /**\n        @dev Pay loan\n\n        Realizes a payment of a given Loan, before performing the payment the accumulated\n        interest is computed and added to the total pending amount.\n\n        Before calling this function, the msg.sender must call the \"approve\" function on the RCN Token, specifying an amount\n        sufficient enough to pay the equivalent of the desired payment and the oracle fee.\n\n        Because it is difficult or even impossible to know in advance how much RCN are going to be spent on the\n        transaction*, we recommend performing the \"approve\" using an amount 5% superior to the wallet estimated\n        spending. If the RCN spent results to be less, the extra tokens are never debited from the msg.sender.\n\n        * The RCN rate can fluctuate on the same block, and it is impossible to know in advance the exact time of the\n        confirmation of the transaction. \n\n        If the paid pending amount equals zero, the loan changes status to \"paid\" and it is considered closed.\n\n        @param index Index of the loan\n        @param _amount Amount to pay, specified in the loan currency; or in RCN if the loan has no oracle\n        @param _from The identity of the payer\n        @param oracleData Data required by the oracle to return the rate, the content of this field must be provided\n            by the url exposed in the url() method of the oracle.\n            \n        @return true if the payment was executed successfully\n    */\n    function pay(uint index, uint256 _amount, address _from, bytes oracleData) public returns (bool) {\n        Loan storage loan = loans[index];\n\n        require(loan.status == Status.lent);\n        addInterest(index);\n        uint256 toPay = min(getPendingAmount(index), _amount);\n        PartialPayment(index, msg.sender, _from, toPay);\n\n        loan.paid = safeAdd(loan.paid, toPay);\n\n        if (getRawPendingAmount(loan) == 0) {\n            TotalPayment(index);\n            loan.status = Status.paid;\n\n            // ERC721, remove loan from circulation\n            lendersBalance[loan.lender] -= 1;\n            activeLoans -= 1;\n            Transfer(loan.lender, 0x0, index);\n        }\n\n        uint256 rate = getRate(loan, oracleData);\n        uint256 transferValue = safeMult(toPay, rate);\n        lockTokens(rcn, transferValue);\n        require(rcn.transferFrom(msg.sender, this, transferValue));\n        loan.lenderBalance = safeAdd(transferValue, loan.lenderBalance);\n\n        return true;\n    }\n\n    /**\n        @dev Retrieves the rate corresponding of the loan oracle, if the loan has no oracle the rate is 1\n\n        @param loan The loan with the cosigner\n        @param data Data required by the oracle\n\n        @return The rate of the oracle\n    */\n    function getRate(Loan loan, bytes data) internal returns (uint256) {\n        if (loan.oracle == address(0)) {\n            return 1;\n        } else {\n            return loan.oracle.getRate(loan.currency, data);\n        }\n    }\n\n    /**\n        @dev Withdraw lender funds\n\n        When a loan is paid, the funds are not transferred automatically to the lender, the funds are stored on the\n        engine contract, and the lender must call this function specifying the amount desired to transfer and the \n        destination.\n\n        This behavior is defined to allow the temporary transfer of the loan to a smart contract, without worrying that\n        the contract will receive tokens that are not traceable; and it allows the development of decentralized \n        autonomous organizations.\n\n        @param index Index of the loan\n        @param to Destination of the wiwthdraw funds\n        @param amount Amount to withdraw, in RCN\n\n        @return true if the withdraw was executed successfully\n    */\n    function withdrawal(uint index, address to, uint256 amount) public returns (bool) {\n        Loan storage loan = loans[index];\n        require(msg.sender == loan.lender);\n        loan.lenderBalance = safeSubtract(loan.lenderBalance, amount);\n        require(rcn.transfer(to, amount));\n        unlockTokens(rcn, amount);\n        return true;\n    }\n\n    function withdrawalRange(uint256 fromIndex, uint256 toIndex, address to) public returns (uint256) {\n        uint256 loanId;\n        uint256 totalWithdraw = 0;\n\n        for (loanId = fromIndex; loanId <= toIndex; loanId++) {\n            Loan storage loan = loans[loanId];\n            if (loan.lender == msg.sender) {\n                totalWithdraw += loan.lenderBalance;\n                loan.lenderBalance = 0;\n            }\n        }\n\n        require(rcn.transfer(to, totalWithdraw));\n        unlockTokens(rcn, totalWithdraw);\n        \n        return totalWithdraw;\n    }\n\n    function withdrawalList(uint256[] memory loanIds, address to) public returns (uint256) {\n        uint256 inputId;\n        uint256 totalWithdraw = 0;\n\n        for (inputId = 0; inputId < loanIds.length; inputId++) {\n            Loan storage loan = loans[loanIds[inputId]];\n            if (loan.lender == msg.sender) {\n                totalWithdraw += loan.lenderBalance;\n                loan.lenderBalance = 0;\n            }\n        }\n\n        require(rcn.transfer(to, totalWithdraw));\n        unlockTokens(rcn, totalWithdraw);\n\n        return totalWithdraw;\n    }\n\n    /**\n        @dev Deprecates the engine, locks the creation of new loans.\n    */\n    function setDeprecated(bool _deprecated) public onlyOwner {\n        deprecated = _deprecated;\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinfabrik-RCN Network Smart Contract Audit/rcn-network-3ded36151ad55543d16c354e70161852de4061d0/contracts/NanoLoanEngine.sol",
        "vulnerability": "Assertion Failure",
        "check": "FP",
        "response": "Answer: No\nReason: There are no assertions in the code which can lead to an assertion failure vulnerability."
    },
    {
        "code_segment": "contract NanoLoanEngine is ERC721, Engine, Ownable, TokenLockable {\n    uint256 public constant VERSION = 202;\n    string public constant VERSION_NAME = \"Basalt\";\n\n    uint256 private activeLoans = 0;\n    mapping(address => uint256) private lendersBalance;\n\n    function name() constant returns (string _name) {\n        _name = \"RCN - Nano loan engine - Basalt 202\";\n    }\n\n    function symbol() constant returns (string _symbol) {\n        _symbol = \"RCN-NLE-202\";\n    }\n\n    function totalSupply() constant returns (uint _totalSupply) {\n        _totalSupply = activeLoans;\n    }\n\n    function balanceOf(address _owner) constant returns (uint _balance) {\n        _balance = lendersBalance[_owner];\n    }\n\n    function tokenOfOwnerByIndex(address _owner, uint256 _index) constant returns (uint tokenId) {\n        uint256 tokenCount = balanceOf(_owner);\n\n        if (tokenCount == 0 || _index >= tokenCount) {\n            // Fail transaction\n            revert();\n        } else {\n            uint256 totalLoans = totalSupply();\n            uint256 resultIndex = 0;\n\n            uint256 loanId;\n            // SWC-128-DoS With Block Gas Limit: L46\n            for (loanId = 0; loanId <= totalLoans; loanId++) {\n                if (loans[loanId].lender == _owner && loans[loanId].status == Status.lent) {\n                    if (resultIndex == _index) {\n                        return loanId;\n                    }\n                    resultIndex++;\n                }\n            }\n\n            revert();\n        }\n    }\n\n    function tokensOfOwner(address _owner) external constant returns(uint256[] ownerTokens) {\n        uint256 tokenCount = balanceOf(_owner);\n\n        if (tokenCount == 0) {\n            // Return an empty array\n            return new uint256[](0);\n        } else {\n            uint256[] memory result = new uint256[](tokenCount);\n            uint256 totalLoans = totalSupply();\n            uint256 resultIndex = 0;\n\n            uint256 loanId;\n\n            for (loanId = 0; loanId <= totalLoans; loanId++) {\n                if (loans[loanId].lender == _owner && loans[loanId].status == Status.lent) {\n                    result[resultIndex] = loanId;\n                    resultIndex++;\n                }\n            }\n\n            return result;\n        }\n    }\n    \n    Token public rcn;\n    bool public deprecated;\n\n    event CreatedLoan(uint _index, address _borrower, address _creator);\n    event ApprovedBy(uint _index, address _address);\n    event Lent(uint _index, address _lender, address _cosigner);\n    event DestroyedBy(uint _index, address _address);\n    event PartialPayment(uint _index, address _sender, address _from, uint256 _amount);\n    event TotalPayment(uint _index);\n\n    function NanoLoanEngine(Token _rcn) public {\n        owner = msg.sender;\n        rcn = _rcn;\n    }\n\n    struct Loan {\n        Status status;\n        Oracle oracle;\n\n        address borrower;\n        address lender;\n        address creator;\n        address cosigner;\n        \n        uint256 amount;\n        uint256 interest;\n        uint256 punitoryInterest;\n        uint256 interestTimestamp;\n        uint256 paid;\n        uint256 interestRate;\n        uint256 interestRatePunitory;\n        uint256 dueTime;\n        uint256 duesIn;\n\n        bytes32 currency;\n        uint256 cancelableAt;\n        uint256 lenderBalance;\n\n        address approvedTransfer;\n        uint256 expirationRequest;\n\n        mapping(address => bool) approbations;\n    }\n\n    Loan[] private loans;\n\n    /**\n        @dev Creates a loan request, the loan can be generated with any borrower, cosigner, and conditions; if the \n        cosigner and borrower agree they must call the \"approve\" function.\n\n        The creator of the loan is the caller of this function; this is useful to track which wallet created the loan.\n\n        @param _oracleContract Address of the Oracle contract, if the loan does not use any oracle, this field should be 0x0.\n        @param _borrower Address of the borrower\n        @param _currency The currency to use with the oracle, the currency code is generated with the following formula,\n            keccak256(ticker,decimals).\n        @param _amount The requested amount; currency and unit are defined by the Oracle, if there is no Oracle present\n            the currency is RCN, and the unit is wei.\n        @param _interestRate The non-punitory interest rate by second, defined as a denominator of 10 000 000.\n        @param _interestRatePunitory The punitory interest rate by second, defined as a denominator of 10 000 000.\n            Ej: interestRate 11108571428571 = 28% Anual interest\n        @param _duesIn The time in seconds that the borrower has in order to pay the debt after the lender lends the money.\n        @param _cancelableAt Delta in seconds specifying how much interest should be added in advance, if the borrower pays \n        entirely or partially the loan before this term, no extra interest will be deducted.\n        @param _expirationRequest Timestamp of when the loan request expires, if the loan is not filled before this date, \n            the request is no longer valid.\n    */\n    function createLoan(Oracle _oracleContract, address _borrower, bytes32 _currency, uint256 _amount, uint256 _interestRate,\n        uint256 _interestRatePunitory, uint256 _duesIn, uint256 _cancelableAt, uint256 _expirationRequest) returns (uint256) {\n\n        require(!deprecated);\n        require(_cancelableAt <= _duesIn);\n        require(_oracleContract != address(0) || _currency == 0x0);\n        require(_borrower != address(0));\n        require(_amount != 0);\n        require(_interestRatePunitory != 0);\n        require(_interestRate != 0);\n        require(_expirationRequest > block.timestamp);\n\n        var loan = Loan(Status.initial, _oracleContract, _borrower, 0x0, msg.sender, 0x0, _amount, 0, 0, 0, 0, _interestRate,\n            _interestRatePunitory, 0, _duesIn, _currency, _cancelableAt, 0, 0x0, _expirationRequest);\n        uint index = loans.push(loan) - 1;\n        CreatedLoan(index, _borrower, msg.sender);\n\n        if (msg.sender == _borrower) {\n            approveLoan(index);\n        }\n\n        return index;\n    }\n    \n    function ownerOf(uint256 index) constant returns (address owner) { owner = loans[index].lender; }\n    function getTotalLoans() constant returns (uint256) { return loans.length; }\n    function getOracle(uint index) constant returns (Oracle) { return loans[index].oracle; }\n    function getBorrower(uint index) constant returns (address) { return loans[index].borrower; }\n    function getCosigner(uint index) constant returns (address) { return loans[index].cosigner; }\n    function getCreator(uint index) constant returns (address) { return loans[index].creator; }\n    function getAmount(uint index) constant returns (uint256) { return loans[index].amount; }\n    function getPunitoryInterest(uint index) constant returns (uint256) { return loans[index].punitoryInterest; }\n    function getInterestTimestamp(uint index) constant returns (uint256) { return loans[index].interestTimestamp; }\n    function getPaid(uint index) constant returns (uint256) { return loans[index].paid; }\n    function getInterestRate(uint index) constant returns (uint256) { return loans[index].interestRate; }\n    function getInterestRatePunitory(uint index) constant returns (uint256) { return loans[index].interestRatePunitory; }\n    function getDueTime(uint index) constant returns (uint256) { return loans[index].dueTime; }\n    function getDuesIn(uint index) constant returns (uint256) { return loans[index].duesIn; }\n    function getCancelableAt(uint index) constant returns (uint256) { return loans[index].cancelableAt; }\n    function getApprobation(uint index, address _address) constant returns (bool) { return loans[index].approbations[_address]; }\n    function getStatus(uint index) constant returns (Status) { return loans[index].status; }\n    function getLenderBalance(uint index) constant returns (uint256) { return loans[index].lenderBalance; }\n    function getApprovedTransfer(uint index) constant returns (address) {return loans[index].approvedTransfer; }\n    function getCurrency(uint index) constant returns (bytes32) { return loans[index].currency; }\n    function getExpirationRequest(uint index) constant returns (uint256) { return loans[index].expirationRequest; }\n    function getInterest(uint index) constant returns (uint256) { return loans[index].interest; }\n\n    /**\n        @param index Index of the loan\n\n        @return true if the loan has been approved by the borrower and cosigner.\n    */\n    function isApproved(uint index) constant returns (bool) {\n        Loan storage loan = loans[index];\n        return loan.approbations[loan.borrower];\n    }\n\n    /**\n        @dev Called by the members of the loan to show that they agree with the terms of the loan; the borrower\n        must call this method before any lender could call the method \"lend\".\n            \n        Any address can call this method to be added to the \"approbations\" mapping.\n\n        @param index Index of the loan\n\n        @return true if the approve was done successfully\n    */\n    function approveLoan(uint index) public returns(bool) {\n        Loan storage loan = loans[index];\n        require(loan.status == Status.initial);\n        loan.approbations[msg.sender] = true;\n        ApprovedBy(index, msg.sender);\n        return true;\n    }\n\n    /**\n        @dev Performs the lend of the RCN equivalent to the requested amount, and transforms the msg.sender in the new lender.\n\n        The loan must be previously approved by the borrower; before calling this function, the lender candidate must \n        call the \"approve\" function on the RCN Token, specifying an amount sufficient enough to pay the equivalent of\n        the requested amount, and the cosigner fee.\n        \n        @param index Index of the loan\n        @param oracleData Data required by the oracle to return the rate, the content of this field must be provided\n            by the url exposed in the url() method of the oracle.\n        @param cosigner Address of the cosigner, 0x0 for lending without cosigner.\n        @param cosignerData Data required by the cosigner to process the request.\n\n        @return true if the lend was done successfully\n    */\n    function lend(uint index, bytes oracleData, Cosigner cosigner, bytes cosignerData) public returns (bool) {\n        Loan storage loan = loans[index];\n\n        require(loan.status == Status.initial);\n        require(isApproved(index));\n        require(block.timestamp <= loan.expirationRequest);\n\n        loan.lender = msg.sender;\n        loan.dueTime = safeAdd(block.timestamp, loan.duesIn);\n        loan.interestTimestamp = block.timestamp;\n        loan.status = Status.lent;\n        \n        if (loan.cancelableAt > 0)\n            internalAddInterest(loan, safeAdd(block.timestamp, loan.cancelableAt));\n\n        uint256 rate = getRate(loan, oracleData);\n\n        if (cosigner != address(0)) {\n            // The cosigner it's temporary set to the next address (cosigner + 2), it's expected that the cosigner will\n            // call the method \"cosign\" to accept the conditions; that method also sets the cosigner to the right\n            // address. If that does not happen, the transaction fails.\n            loan.cosigner = address(uint256(cosigner) + 2);\n            require(cosigner.requestCosign(this, index, cosignerData, oracleData));\n            require(loan.cosigner == address(cosigner));\n        }\n        \n        require(rcn.transferFrom(msg.sender, loan.borrower, safeMult(loan.amount, rate)));\n        \n        // ERC721, create new loan and transfer it to the lender\n        Transfer(0x0, loan.lender, index);\n        activeLoans += 1;\n        lendersBalance[loan.lender] += 1;\n        Lent(index, loan.lender, cosigner);\n\n        return true;\n    }\n\n    /**\n        @dev The cosigner must call this method to accept the conditions of a loan, this method pays the cosigner his fee\n\n        @param index Index of the loan\n        @param cost Fee set by the cosigner\n\n        @return true If the cosign was successfull\n    */\n    function cosign(uint index, uint256 cost) external returns (bool) {\n        Loan storage loan = loans[index];\n        require(loan.status == Status.lent && (loan.dueTime - loan.duesIn) == block.timestamp);\n        require(loan.cosigner != address(0));\n        require(loan.cosigner == address(uint256(msg.sender) + 2));\n        loan.cosigner = msg.sender;\n        require(rcn.transferFrom(loan.lender, msg.sender, cost));\n        return true;\n    }\n\n    /**\n        @dev Destroys a loan, the borrower could call this method if they performed an accidental or regretted \n        \"approve\" of the loan, this method only works for them if the loan is in \"pending\" status.\n\n        The lender can call this method at any moment, in case of a loan with status \"lent\" the lender is pardoning \n        the debt. \n\n        @param index Index of the loan\n\n        @return true if the destroy was done successfully\n    */\n    function destroy(uint index) public returns (bool) {\n        Loan storage loan = loans[index];\n        require(loan.status != Status.destroyed);\n        require(msg.sender == loan.lender || (msg.sender == loan.borrower && loan.status == Status.initial));\n        DestroyedBy(index, msg.sender);\n\n        // ERC721, remove loan from circulation\n        if (loan.status != Status.initial) {\n            lendersBalance[loan.lender] -= 1;\n            activeLoans -= 1;\n            Transfer(loan.lender, 0x0, index);\n        }\n\n        loan.status = Status.destroyed;\n        return true;\n    }\n\n    /**\n        @dev Transfers a loan to a different lender, the caller must be the current lender or previously being\n        approved with the method \"approveTransfer\"; only loans with the Status.lent status can be transfered.\n\n        @param index Index of the loan\n        @param to New lender\n\n        @return true if the transfer was done successfully\n    */\n    function transfer(address to, uint256 index) public returns (bool) {\n        Loan storage loan = loans[index];\n        \n        require(loan.status != Status.destroyed && loan.status != Status.paid);\n        require(msg.sender == loan.lender || msg.sender == loan.approvedTransfer);\n        require(to != address(0));\n        loan.lender = to;\n        loan.approvedTransfer = address(0);\n\n        // ERC721, transfer loan to another address\n        lendersBalance[msg.sender] -= 1;\n        lendersBalance[to] += 1;\n        Transfer(loan.lender, to, index);\n\n        return true;\n    }\n\n    /**\n        @dev ERC721 method, transfers the loan to the msg.sender, the msg.sender must be approved using the \n        \"approve\" method.\n\n        @return true if the transfer was successfull\n    */\n    function takeOwnership(uint256 _index) public returns (bool) {\n        return transfer(msg.sender, _index);\n    }\n\n    /**\n        @dev Approves the transfer of a given loan in the name of the lender, the behavior of this function is similar to\n        \"approve\" in the ERC20 standard, but only one approved address is allowed at a time.\n\n        The same method can be called passing 0x0 as parameter \"to\" to erase a previously approved address.\n\n        @param to Address allowed to transfer the loan or 0x0 to delete\n        @param index Index of the loan\n\n        @return true if the approve was done successfully\n    */\n    function approve(address to, uint256 index) public returns (bool) {\n        Loan storage loan = loans[index];\n        require(msg.sender == loan.lender);\n        loan.approvedTransfer = to;\n        Approval(msg.sender, to, index);\n        return true;\n    }\n\n    /**\n        @dev Returns the pending amount to complete de payment of the loan, keep in mind that this number increases \n        every second.\n\n        @param index Index of the loan\n\n        @return Aprox pending payment amount\n    */\n    function getPendingAmount(uint index) public constant returns (uint256) {\n        Loan storage loan = loans[index];\n        addInterest(index);\n        return getRawPendingAmount(loan);\n    }\n\n    function getRawPendingAmount(Loan loan) internal returns (uint256) {\n        return safeSubtract(safeAdd(safeAdd(loan.amount, loan.interest), loan.punitoryInterest), loan.paid);\n    }\n\n    /**\n        @dev Calculates the interest of a given amount, interest rate and delta time.\n\n        @param timeDelta Elapsed time\n        @param interestRate Interest rate expressed as the denominator of 10 000 000.\n        @param amount Amount to apply interest\n\n        @return realDelta The real timeDelta applied\n        @return interest The interest gained in the realDelta time\n    */\n    function calculateInterest(uint256 timeDelta, uint256 interestRate, uint256 amount) public constant returns (uint256 realDelta, uint256 interest) {\n        if (amount == 0) {\n            interest = 0;\n            realDelta = timeDelta;\n        } else {\n            interest = safeMult(safeMult(100000, amount), timeDelta) / interestRate;\n            realDelta = safeMult(interest, interestRate) / (amount * 100000);\n        }\n    }\n\n    /**\n        @dev Computes loan interest\n\n        Computes the punitory and non-punitory interest of a given loan and only applies the change.\n        \n        @param loan Loan to compute interest\n        @param timestamp Target absolute unix time to calculate interest.\n    */\n    function internalAddInterest(Loan storage loan, uint256 timestamp) internal {\n        if (timestamp > loan.interestTimestamp) {\n            uint256 newInterest = loan.interest;\n            uint256 newPunitoryInterest = loan.punitoryInterest;\n\n            uint256 newTimestamp;\n            uint256 realDelta;\n            uint256 calculatedInterest;\n\n            uint256 deltaTime;\n            uint256 pending;\n\n            uint256 endNonPunitory = min(timestamp, loan.dueTime);\n            if (endNonPunitory > loan.interestTimestamp) {\n                deltaTime = endNonPunitory - loan.interestTimestamp;\n\n                if (loan.paid < loan.amount) {\n                    pending = loan.amount - loan.paid;\n                } else {\n                    pending = 0;\n                }\n\n                (realDelta, calculatedInterest) = calculateInterest(deltaTime, loan.interestRate, pending);\n                newInterest = safeAdd(calculatedInterest, newInterest);\n                newTimestamp = loan.interestTimestamp + realDelta;\n            }\n\n            if (timestamp > loan.dueTime) {\n                uint256 startPunitory = max(loan.dueTime, loan.interestTimestamp);\n                deltaTime = timestamp - startPunitory;\n\n                uint256 debt = safeAdd(loan.amount, newInterest);\n                pending = min(debt, safeSubtract(safeAdd(debt, newPunitoryInterest), loan.paid));\n\n                (realDelta, calculatedInterest) = calculateInterest(deltaTime, loan.interestRatePunitory, pending);\n                newPunitoryInterest = safeAdd(newPunitoryInterest, calculatedInterest);\n                newTimestamp = startPunitory + realDelta;\n            }\n            \n            if (newInterest != loan.interest || newPunitoryInterest != loan.punitoryInterest) {\n                loan.interestTimestamp = newTimestamp;\n                loan.interest = newInterest;\n                loan.punitoryInterest = newPunitoryInterest;\n            }\n        }\n    }\n\n    /**\n        @dev Computes loan interest only up to current unix time\n\n        @param timestamp Target absolute unix time to calculate interest.\n    */\n    function addInterestUpTo(Loan storage loan, uint256 timestamp) internal {\n        require(loan.status == Status.lent);\n        if (timestamp <= block.timestamp) {\n            internalAddInterest(loan, timestamp);\n        }\n    }\n\n    /**\n        @dev Updates the loan accumulated interests up to the current Unix time.\n        \n        @param index Index of the loan\n    */\n    function addInterest(uint index) public {\n        Loan storage loan = loans[index];\n        addInterestUpTo(loan, block.timestamp);\n    }\n    \n    /**\n        @dev Pay loan\n\n        Realizes a payment of a given Loan, before performing the payment the accumulated\n        interest is computed and added to the total pending amount.\n\n        Before calling this function, the msg.sender must call the \"approve\" function on the RCN Token, specifying an amount\n        sufficient enough to pay the equivalent of the desired payment and the oracle fee.\n\n        Because it is difficult or even impossible to know in advance how much RCN are going to be spent on the\n        transaction*, we recommend performing the \"approve\" using an amount 5% superior to the wallet estimated\n        spending. If the RCN spent results to be less, the extra tokens are never debited from the msg.sender.\n\n        * The RCN rate can fluctuate on the same block, and it is impossible to know in advance the exact time of the\n        confirmation of the transaction. \n\n        If the paid pending amount equals zero, the loan changes status to \"paid\" and it is considered closed.\n\n        @param index Index of the loan\n        @param _amount Amount to pay, specified in the loan currency; or in RCN if the loan has no oracle\n        @param _from The identity of the payer\n        @param oracleData Data required by the oracle to return the rate, the content of this field must be provided\n            by the url exposed in the url() method of the oracle.\n            \n        @return true if the payment was executed successfully\n    */\n    function pay(uint index, uint256 _amount, address _from, bytes oracleData) public returns (bool) {\n        Loan storage loan = loans[index];\n\n        require(loan.status == Status.lent);\n        addInterest(index);\n        uint256 toPay = min(getPendingAmount(index), _amount);\n        PartialPayment(index, msg.sender, _from, toPay);\n\n        loan.paid = safeAdd(loan.paid, toPay);\n\n        if (getRawPendingAmount(loan) == 0) {\n            TotalPayment(index);\n            loan.status = Status.paid;\n\n            // ERC721, remove loan from circulation\n            lendersBalance[loan.lender] -= 1;\n            activeLoans -= 1;\n            Transfer(loan.lender, 0x0, index);\n        }\n\n        uint256 rate = getRate(loan, oracleData);\n        uint256 transferValue = safeMult(toPay, rate);\n        lockTokens(rcn, transferValue);\n        require(rcn.transferFrom(msg.sender, this, transferValue));\n        loan.lenderBalance = safeAdd(transferValue, loan.lenderBalance);\n\n        return true;\n    }\n\n    /**\n        @dev Retrieves the rate corresponding of the loan oracle, if the loan has no oracle the rate is 1\n\n        @param loan The loan with the cosigner\n        @param data Data required by the oracle\n\n        @return The rate of the oracle\n    */\n    function getRate(Loan loan, bytes data) internal returns (uint256) {\n        if (loan.oracle == address(0)) {\n            return 1;\n        } else {\n            return loan.oracle.getRate(loan.currency, data);\n        }\n    }\n\n    /**\n        @dev Withdraw lender funds\n\n        When a loan is paid, the funds are not transferred automatically to the lender, the funds are stored on the\n        engine contract, and the lender must call this function specifying the amount desired to transfer and the \n        destination.\n\n        This behavior is defined to allow the temporary transfer of the loan to a smart contract, without worrying that\n        the contract will receive tokens that are not traceable; and it allows the development of decentralized \n        autonomous organizations.\n\n        @param index Index of the loan\n        @param to Destination of the wiwthdraw funds\n        @param amount Amount to withdraw, in RCN\n\n        @return true if the withdraw was executed successfully\n    */\n    function withdrawal(uint index, address to, uint256 amount) public returns (bool) {\n        Loan storage loan = loans[index];\n        require(msg.sender == loan.lender);\n        loan.lenderBalance = safeSubtract(loan.lenderBalance, amount);\n        require(rcn.transfer(to, amount));\n        unlockTokens(rcn, amount);\n        return true;\n    }\n\n    function withdrawalRange(uint256 fromIndex, uint256 toIndex, address to) public returns (uint256) {\n        uint256 loanId;\n        uint256 totalWithdraw = 0;\n\n        for (loanId = fromIndex; loanId <= toIndex; loanId++) {\n            Loan storage loan = loans[loanId];\n            if (loan.lender == msg.sender) {\n                totalWithdraw += loan.lenderBalance;\n                loan.lenderBalance = 0;\n            }\n        }\n\n        require(rcn.transfer(to, totalWithdraw));\n        unlockTokens(rcn, totalWithdraw);\n        \n        return totalWithdraw;\n    }\n\n    function withdrawalList(uint256[] memory loanIds, address to) public returns (uint256) {\n        uint256 inputId;\n        uint256 totalWithdraw = 0;\n\n        for (inputId = 0; inputId < loanIds.length; inputId++) {\n            Loan storage loan = loans[loanIds[inputId]];\n            if (loan.lender == msg.sender) {\n                totalWithdraw += loan.lenderBalance;\n                loan.lenderBalance = 0;\n            }\n        }\n\n        require(rcn.transfer(to, totalWithdraw));\n        unlockTokens(rcn, totalWithdraw);\n\n        return totalWithdraw;\n    }\n\n    /**\n        @dev Deprecates the engine, locks the creation of new loans.\n    */\n    function setDeprecated(bool _deprecated) public onlyOwner {\n        deprecated = _deprecated;\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinfabrik-RCN Network Smart Contract Audit/rcn-network-3ded36151ad55543d16c354e70161852de4061d0/contracts/NanoLoanEngine.sol",
        "vulnerability": "Assertion Failure",
        "check": "FP",
        "response": "Answer: No\nReason: The contract does not contain any assertions using the `assert` statement, which could result in an assertion failure. The `require` and `revert` statements used ensure error handling and revert the state properly."
    },
    {
        "code_segment": "contract NanoLoanEngine is ERC721, Engine, Ownable, TokenLockable {\n    uint256 public constant VERSION = 202;\n    string public constant VERSION_NAME = \"Basalt\";\n\n    uint256 private activeLoans = 0;\n    mapping(address => uint256) private lendersBalance;\n\n    function name() constant returns (string _name) {\n        _name = \"RCN - Nano loan engine - Basalt 202\";\n    }\n\n    function symbol() constant returns (string _symbol) {\n        _symbol = \"RCN-NLE-202\";\n    }\n\n    function totalSupply() constant returns (uint _totalSupply) {\n        _totalSupply = activeLoans;\n    }\n\n    function balanceOf(address _owner) constant returns (uint _balance) {\n        _balance = lendersBalance[_owner];\n    }\n\n    function tokenOfOwnerByIndex(address _owner, uint256 _index) constant returns (uint tokenId) {\n        uint256 tokenCount = balanceOf(_owner);\n\n        if (tokenCount == 0 || _index >= tokenCount) {\n            // Fail transaction\n            revert();\n        } else {\n            uint256 totalLoans = totalSupply();\n            uint256 resultIndex = 0;\n\n            uint256 loanId;\n            // SWC-128-DoS With Block Gas Limit: L46\n            for (loanId = 0; loanId <= totalLoans; loanId++) {\n                if (loans[loanId].lender == _owner && loans[loanId].status == Status.lent) {\n                    if (resultIndex == _index) {\n                        return loanId;\n                    }\n                    resultIndex++;\n                }\n            }\n\n            revert();\n        }\n    }\n\n    function tokensOfOwner(address _owner) external constant returns(uint256[] ownerTokens) {\n        uint256 tokenCount = balanceOf(_owner);\n\n        if (tokenCount == 0) {\n            // Return an empty array\n            return new uint256[](0);\n        } else {\n            uint256[] memory result = new uint256[](tokenCount);\n            uint256 totalLoans = totalSupply();\n            uint256 resultIndex = 0;\n\n            uint256 loanId;\n\n            for (loanId = 0; loanId <= totalLoans; loanId++) {\n                if (loans[loanId].lender == _owner && loans[loanId].status == Status.lent) {\n                    result[resultIndex] = loanId;\n                    resultIndex++;\n                }\n            }\n\n            return result;\n        }\n    }\n    \n    Token public rcn;\n    bool public deprecated;\n\n    event CreatedLoan(uint _index, address _borrower, address _creator);\n    event ApprovedBy(uint _index, address _address);\n    event Lent(uint _index, address _lender, address _cosigner);\n    event DestroyedBy(uint _index, address _address);\n    event PartialPayment(uint _index, address _sender, address _from, uint256 _amount);\n    event TotalPayment(uint _index);\n\n    function NanoLoanEngine(Token _rcn) public {\n        owner = msg.sender;\n        rcn = _rcn;\n    }\n\n    struct Loan {\n        Status status;\n        Oracle oracle;\n\n        address borrower;\n        address lender;\n        address creator;\n        address cosigner;\n        \n        uint256 amount;\n        uint256 interest;\n        uint256 punitoryInterest;\n        uint256 interestTimestamp;\n        uint256 paid;\n        uint256 interestRate;\n        uint256 interestRatePunitory;\n        uint256 dueTime;\n        uint256 duesIn;\n\n        bytes32 currency;\n        uint256 cancelableAt;\n        uint256 lenderBalance;\n\n        address approvedTransfer;\n        uint256 expirationRequest;\n\n        mapping(address => bool) approbations;\n    }\n\n    Loan[] private loans;\n\n    /**\n        @dev Creates a loan request, the loan can be generated with any borrower, cosigner, and conditions; if the \n        cosigner and borrower agree they must call the \"approve\" function.\n\n        The creator of the loan is the caller of this function; this is useful to track which wallet created the loan.\n\n        @param _oracleContract Address of the Oracle contract, if the loan does not use any oracle, this field should be 0x0.\n        @param _borrower Address of the borrower\n        @param _currency The currency to use with the oracle, the currency code is generated with the following formula,\n            keccak256(ticker,decimals).\n        @param _amount The requested amount; currency and unit are defined by the Oracle, if there is no Oracle present\n            the currency is RCN, and the unit is wei.\n        @param _interestRate The non-punitory interest rate by second, defined as a denominator of 10 000 000.\n        @param _interestRatePunitory The punitory interest rate by second, defined as a denominator of 10 000 000.\n            Ej: interestRate 11108571428571 = 28% Anual interest\n        @param _duesIn The time in seconds that the borrower has in order to pay the debt after the lender lends the money.\n        @param _cancelableAt Delta in seconds specifying how much interest should be added in advance, if the borrower pays \n        entirely or partially the loan before this term, no extra interest will be deducted.\n        @param _expirationRequest Timestamp of when the loan request expires, if the loan is not filled before this date, \n            the request is no longer valid.\n    */\n    function createLoan(Oracle _oracleContract, address _borrower, bytes32 _currency, uint256 _amount, uint256 _interestRate,\n        uint256 _interestRatePunitory, uint256 _duesIn, uint256 _cancelableAt, uint256 _expirationRequest) returns (uint256) {\n\n        require(!deprecated);\n        require(_cancelableAt <= _duesIn);\n        require(_oracleContract != address(0) || _currency == 0x0);\n        require(_borrower != address(0));\n        require(_amount != 0);\n        require(_interestRatePunitory != 0);\n        require(_interestRate != 0);\n        require(_expirationRequest > block.timestamp);\n\n        var loan = Loan(Status.initial, _oracleContract, _borrower, 0x0, msg.sender, 0x0, _amount, 0, 0, 0, 0, _interestRate,\n            _interestRatePunitory, 0, _duesIn, _currency, _cancelableAt, 0, 0x0, _expirationRequest);\n        uint index = loans.push(loan) - 1;\n        CreatedLoan(index, _borrower, msg.sender);\n\n        if (msg.sender == _borrower) {\n            approveLoan(index);\n        }\n\n        return index;\n    }\n    \n    function ownerOf(uint256 index) constant returns (address owner) { owner = loans[index].lender; }\n    function getTotalLoans() constant returns (uint256) { return loans.length; }\n    function getOracle(uint index) constant returns (Oracle) { return loans[index].oracle; }\n    function getBorrower(uint index) constant returns (address) { return loans[index].borrower; }\n    function getCosigner(uint index) constant returns (address) { return loans[index].cosigner; }\n    function getCreator(uint index) constant returns (address) { return loans[index].creator; }\n    function getAmount(uint index) constant returns (uint256) { return loans[index].amount; }\n    function getPunitoryInterest(uint index) constant returns (uint256) { return loans[index].punitoryInterest; }\n    function getInterestTimestamp(uint index) constant returns (uint256) { return loans[index].interestTimestamp; }\n    function getPaid(uint index) constant returns (uint256) { return loans[index].paid; }\n    function getInterestRate(uint index) constant returns (uint256) { return loans[index].interestRate; }\n    function getInterestRatePunitory(uint index) constant returns (uint256) { return loans[index].interestRatePunitory; }\n    function getDueTime(uint index) constant returns (uint256) { return loans[index].dueTime; }\n    function getDuesIn(uint index) constant returns (uint256) { return loans[index].duesIn; }\n    function getCancelableAt(uint index) constant returns (uint256) { return loans[index].cancelableAt; }\n    function getApprobation(uint index, address _address) constant returns (bool) { return loans[index].approbations[_address]; }\n    function getStatus(uint index) constant returns (Status) { return loans[index].status; }\n    function getLenderBalance(uint index) constant returns (uint256) { return loans[index].lenderBalance; }\n    function getApprovedTransfer(uint index) constant returns (address) {return loans[index].approvedTransfer; }\n    function getCurrency(uint index) constant returns (bytes32) { return loans[index].currency; }\n    function getExpirationRequest(uint index) constant returns (uint256) { return loans[index].expirationRequest; }\n    function getInterest(uint index) constant returns (uint256) { return loans[index].interest; }\n\n    /**\n        @param index Index of the loan\n\n        @return true if the loan has been approved by the borrower and cosigner.\n    */\n    function isApproved(uint index) constant returns (bool) {\n        Loan storage loan = loans[index];\n        return loan.approbations[loan.borrower];\n    }\n\n    /**\n        @dev Called by the members of the loan to show that they agree with the terms of the loan; the borrower\n        must call this method before any lender could call the method \"lend\".\n            \n        Any address can call this method to be added to the \"approbations\" mapping.\n\n        @param index Index of the loan\n\n        @return true if the approve was done successfully\n    */\n    function approveLoan(uint index) public returns(bool) {\n        Loan storage loan = loans[index];\n        require(loan.status == Status.initial);\n        loan.approbations[msg.sender] = true;\n        ApprovedBy(index, msg.sender);\n        return true;\n    }\n\n    /**\n        @dev Performs the lend of the RCN equivalent to the requested amount, and transforms the msg.sender in the new lender.\n\n        The loan must be previously approved by the borrower; before calling this function, the lender candidate must \n        call the \"approve\" function on the RCN Token, specifying an amount sufficient enough to pay the equivalent of\n        the requested amount, and the cosigner fee.\n        \n        @param index Index of the loan\n        @param oracleData Data required by the oracle to return the rate, the content of this field must be provided\n            by the url exposed in the url() method of the oracle.\n        @param cosigner Address of the cosigner, 0x0 for lending without cosigner.\n        @param cosignerData Data required by the cosigner to process the request.\n\n        @return true if the lend was done successfully\n    */\n    function lend(uint index, bytes oracleData, Cosigner cosigner, bytes cosignerData) public returns (bool) {\n        Loan storage loan = loans[index];\n\n        require(loan.status == Status.initial);\n        require(isApproved(index));\n        require(block.timestamp <= loan.expirationRequest);\n\n        loan.lender = msg.sender;\n        loan.dueTime = safeAdd(block.timestamp, loan.duesIn);\n        loan.interestTimestamp = block.timestamp;\n        loan.status = Status.lent;\n        \n        if (loan.cancelableAt > 0)\n            internalAddInterest(loan, safeAdd(block.timestamp, loan.cancelableAt));\n\n        uint256 rate = getRate(loan, oracleData);\n\n        if (cosigner != address(0)) {\n            // The cosigner it's temporary set to the next address (cosigner + 2), it's expected that the cosigner will\n            // call the method \"cosign\" to accept the conditions; that method also sets the cosigner to the right\n            // address. If that does not happen, the transaction fails.\n            loan.cosigner = address(uint256(cosigner) + 2);\n            require(cosigner.requestCosign(this, index, cosignerData, oracleData));\n            require(loan.cosigner == address(cosigner));\n        }\n        \n        require(rcn.transferFrom(msg.sender, loan.borrower, safeMult(loan.amount, rate)));\n        \n        // ERC721, create new loan and transfer it to the lender\n        Transfer(0x0, loan.lender, index);\n        activeLoans += 1;\n        lendersBalance[loan.lender] += 1;\n        Lent(index, loan.lender, cosigner);\n\n        return true;\n    }\n\n    /**\n        @dev The cosigner must call this method to accept the conditions of a loan, this method pays the cosigner his fee\n\n        @param index Index of the loan\n        @param cost Fee set by the cosigner\n\n        @return true If the cosign was successfull\n    */\n    function cosign(uint index, uint256 cost) external returns (bool) {\n        Loan storage loan = loans[index];\n        require(loan.status == Status.lent && (loan.dueTime - loan.duesIn) == block.timestamp);\n        require(loan.cosigner != address(0));\n        require(loan.cosigner == address(uint256(msg.sender) + 2));\n        loan.cosigner = msg.sender;\n        require(rcn.transferFrom(loan.lender, msg.sender, cost));\n        return true;\n    }\n\n    /**\n        @dev Destroys a loan, the borrower could call this method if they performed an accidental or regretted \n        \"approve\" of the loan, this method only works for them if the loan is in \"pending\" status.\n\n        The lender can call this method at any moment, in case of a loan with status \"lent\" the lender is pardoning \n        the debt. \n\n        @param index Index of the loan\n\n        @return true if the destroy was done successfully\n    */\n    function destroy(uint index) public returns (bool) {\n        Loan storage loan = loans[index];\n        require(loan.status != Status.destroyed);\n        require(msg.sender == loan.lender || (msg.sender == loan.borrower && loan.status == Status.initial));\n        DestroyedBy(index, msg.sender);\n\n        // ERC721, remove loan from circulation\n        if (loan.status != Status.initial) {\n            lendersBalance[loan.lender] -= 1;\n            activeLoans -= 1;\n            Transfer(loan.lender, 0x0, index);\n        }\n\n        loan.status = Status.destroyed;\n        return true;\n    }\n\n    /**\n        @dev Transfers a loan to a different lender, the caller must be the current lender or previously being\n        approved with the method \"approveTransfer\"; only loans with the Status.lent status can be transfered.\n\n        @param index Index of the loan\n        @param to New lender\n\n        @return true if the transfer was done successfully\n    */\n    function transfer(address to, uint256 index) public returns (bool) {\n        Loan storage loan = loans[index];\n        \n        require(loan.status != Status.destroyed && loan.status != Status.paid);\n        require(msg.sender == loan.lender || msg.sender == loan.approvedTransfer);\n        require(to != address(0));\n        loan.lender = to;\n        loan.approvedTransfer = address(0);\n\n        // ERC721, transfer loan to another address\n        lendersBalance[msg.sender] -= 1;\n        lendersBalance[to] += 1;\n        Transfer(loan.lender, to, index);\n\n        return true;\n    }\n\n    /**\n        @dev ERC721 method, transfers the loan to the msg.sender, the msg.sender must be approved using the \n        \"approve\" method.\n\n        @return true if the transfer was successfull\n    */\n    function takeOwnership(uint256 _index) public returns (bool) {\n        return transfer(msg.sender, _index);\n    }\n\n    /**\n        @dev Approves the transfer of a given loan in the name of the lender, the behavior of this function is similar to\n        \"approve\" in the ERC20 standard, but only one approved address is allowed at a time.\n\n        The same method can be called passing 0x0 as parameter \"to\" to erase a previously approved address.\n\n        @param to Address allowed to transfer the loan or 0x0 to delete\n        @param index Index of the loan\n\n        @return true if the approve was done successfully\n    */\n    function approve(address to, uint256 index) public returns (bool) {\n        Loan storage loan = loans[index];\n        require(msg.sender == loan.lender);\n        loan.approvedTransfer = to;\n        Approval(msg.sender, to, index);\n        return true;\n    }\n\n    /**\n        @dev Returns the pending amount to complete de payment of the loan, keep in mind that this number increases \n        every second.\n\n        @param index Index of the loan\n\n        @return Aprox pending payment amount\n    */\n    function getPendingAmount(uint index) public constant returns (uint256) {\n        Loan storage loan = loans[index];\n        addInterest(index);\n        return getRawPendingAmount(loan);\n    }\n\n    function getRawPendingAmount(Loan loan) internal returns (uint256) {\n        return safeSubtract(safeAdd(safeAdd(loan.amount, loan.interest), loan.punitoryInterest), loan.paid);\n    }\n\n    /**\n        @dev Calculates the interest of a given amount, interest rate and delta time.\n\n        @param timeDelta Elapsed time\n        @param interestRate Interest rate expressed as the denominator of 10 000 000.\n        @param amount Amount to apply interest\n\n        @return realDelta The real timeDelta applied\n        @return interest The interest gained in the realDelta time\n    */\n    function calculateInterest(uint256 timeDelta, uint256 interestRate, uint256 amount) public constant returns (uint256 realDelta, uint256 interest) {\n        if (amount == 0) {\n            interest = 0;\n            realDelta = timeDelta;\n        } else {\n            interest = safeMult(safeMult(100000, amount), timeDelta) / interestRate;\n            realDelta = safeMult(interest, interestRate) / (amount * 100000);\n        }\n    }\n\n    /**\n        @dev Computes loan interest\n\n        Computes the punitory and non-punitory interest of a given loan and only applies the change.\n        \n        @param loan Loan to compute interest\n        @param timestamp Target absolute unix time to calculate interest.\n    */\n    function internalAddInterest(Loan storage loan, uint256 timestamp) internal {\n        if (timestamp > loan.interestTimestamp) {\n            uint256 newInterest = loan.interest;\n            uint256 newPunitoryInterest = loan.punitoryInterest;\n\n            uint256 newTimestamp;\n            uint256 realDelta;\n            uint256 calculatedInterest;\n\n            uint256 deltaTime;\n            uint256 pending;\n\n            uint256 endNonPunitory = min(timestamp, loan.dueTime);\n            if (endNonPunitory > loan.interestTimestamp) {\n                deltaTime = endNonPunitory - loan.interestTimestamp;\n\n                if (loan.paid < loan.amount) {\n                    pending = loan.amount - loan.paid;\n                } else {\n                    pending = 0;\n                }\n\n                (realDelta, calculatedInterest) = calculateInterest(deltaTime, loan.interestRate, pending);\n                newInterest = safeAdd(calculatedInterest, newInterest);\n                newTimestamp = loan.interestTimestamp + realDelta;\n            }\n\n            if (timestamp > loan.dueTime) {\n                uint256 startPunitory = max(loan.dueTime, loan.interestTimestamp);\n                deltaTime = timestamp - startPunitory;\n\n                uint256 debt = safeAdd(loan.amount, newInterest);\n                pending = min(debt, safeSubtract(safeAdd(debt, newPunitoryInterest), loan.paid));\n\n                (realDelta, calculatedInterest) = calculateInterest(deltaTime, loan.interestRatePunitory, pending);\n                newPunitoryInterest = safeAdd(newPunitoryInterest, calculatedInterest);\n                newTimestamp = startPunitory + realDelta;\n            }\n            \n            if (newInterest != loan.interest || newPunitoryInterest != loan.punitoryInterest) {\n                loan.interestTimestamp = newTimestamp;\n                loan.interest = newInterest;\n                loan.punitoryInterest = newPunitoryInterest;\n            }\n        }\n    }\n\n    /**\n        @dev Computes loan interest only up to current unix time\n\n        @param timestamp Target absolute unix time to calculate interest.\n    */\n    function addInterestUpTo(Loan storage loan, uint256 timestamp) internal {\n        require(loan.status == Status.lent);\n        if (timestamp <= block.timestamp) {\n            internalAddInterest(loan, timestamp);\n        }\n    }\n\n    /**\n        @dev Updates the loan accumulated interests up to the current Unix time.\n        \n        @param index Index of the loan\n    */\n    function addInterest(uint index) public {\n        Loan storage loan = loans[index];\n        addInterestUpTo(loan, block.timestamp);\n    }\n    \n    /**\n        @dev Pay loan\n\n        Realizes a payment of a given Loan, before performing the payment the accumulated\n        interest is computed and added to the total pending amount.\n\n        Before calling this function, the msg.sender must call the \"approve\" function on the RCN Token, specifying an amount\n        sufficient enough to pay the equivalent of the desired payment and the oracle fee.\n\n        Because it is difficult or even impossible to know in advance how much RCN are going to be spent on the\n        transaction*, we recommend performing the \"approve\" using an amount 5% superior to the wallet estimated\n        spending. If the RCN spent results to be less, the extra tokens are never debited from the msg.sender.\n\n        * The RCN rate can fluctuate on the same block, and it is impossible to know in advance the exact time of the\n        confirmation of the transaction. \n\n        If the paid pending amount equals zero, the loan changes status to \"paid\" and it is considered closed.\n\n        @param index Index of the loan\n        @param _amount Amount to pay, specified in the loan currency; or in RCN if the loan has no oracle\n        @param _from The identity of the payer\n        @param oracleData Data required by the oracle to return the rate, the content of this field must be provided\n            by the url exposed in the url() method of the oracle.\n            \n        @return true if the payment was executed successfully\n    */\n    function pay(uint index, uint256 _amount, address _from, bytes oracleData) public returns (bool) {\n        Loan storage loan = loans[index];\n\n        require(loan.status == Status.lent);\n        addInterest(index);\n        uint256 toPay = min(getPendingAmount(index), _amount);\n        PartialPayment(index, msg.sender, _from, toPay);\n\n        loan.paid = safeAdd(loan.paid, toPay);\n\n        if (getRawPendingAmount(loan) == 0) {\n            TotalPayment(index);\n            loan.status = Status.paid;\n\n            // ERC721, remove loan from circulation\n            lendersBalance[loan.lender] -= 1;\n            activeLoans -= 1;\n            Transfer(loan.lender, 0x0, index);\n        }\n\n        uint256 rate = getRate(loan, oracleData);\n        uint256 transferValue = safeMult(toPay, rate);\n        lockTokens(rcn, transferValue);\n        require(rcn.transferFrom(msg.sender, this, transferValue));\n        loan.lenderBalance = safeAdd(transferValue, loan.lenderBalance);\n\n        return true;\n    }\n\n    /**\n        @dev Retrieves the rate corresponding of the loan oracle, if the loan has no oracle the rate is 1\n\n        @param loan The loan with the cosigner\n        @param data Data required by the oracle\n\n        @return The rate of the oracle\n    */\n    function getRate(Loan loan, bytes data) internal returns (uint256) {\n        if (loan.oracle == address(0)) {\n            return 1;\n        } else {\n            return loan.oracle.getRate(loan.currency, data);\n        }\n    }\n\n    /**\n        @dev Withdraw lender funds\n\n        When a loan is paid, the funds are not transferred automatically to the lender, the funds are stored on the\n        engine contract, and the lender must call this function specifying the amount desired to transfer and the \n        destination.\n\n        This behavior is defined to allow the temporary transfer of the loan to a smart contract, without worrying that\n        the contract will receive tokens that are not traceable; and it allows the development of decentralized \n        autonomous organizations.\n\n        @param index Index of the loan\n        @param to Destination of the wiwthdraw funds\n        @param amount Amount to withdraw, in RCN\n\n        @return true if the withdraw was executed successfully\n    */\n    function withdrawal(uint index, address to, uint256 amount) public returns (bool) {\n        Loan storage loan = loans[index];\n        require(msg.sender == loan.lender);\n        loan.lenderBalance = safeSubtract(loan.lenderBalance, amount);\n        require(rcn.transfer(to, amount));\n        unlockTokens(rcn, amount);\n        return true;\n    }\n\n    function withdrawalRange(uint256 fromIndex, uint256 toIndex, address to) public returns (uint256) {\n        uint256 loanId;\n        uint256 totalWithdraw = 0;\n\n        for (loanId = fromIndex; loanId <= toIndex; loanId++) {\n            Loan storage loan = loans[loanId];\n            if (loan.lender == msg.sender) {\n                totalWithdraw += loan.lenderBalance;\n                loan.lenderBalance = 0;\n            }\n        }\n\n        require(rcn.transfer(to, totalWithdraw));\n        unlockTokens(rcn, totalWithdraw);\n        \n        return totalWithdraw;\n    }\n\n    function withdrawalList(uint256[] memory loanIds, address to) public returns (uint256) {\n        uint256 inputId;\n        uint256 totalWithdraw = 0;\n\n        for (inputId = 0; inputId < loanIds.length; inputId++) {\n            Loan storage loan = loans[loanIds[inputId]];\n            if (loan.lender == msg.sender) {\n                totalWithdraw += loan.lenderBalance;\n                loan.lenderBalance = 0;\n            }\n        }\n\n        require(rcn.transfer(to, totalWithdraw));\n        unlockTokens(rcn, totalWithdraw);\n\n        return totalWithdraw;\n    }\n\n    /**\n        @dev Deprecates the engine, locks the creation of new loans.\n    */\n    function setDeprecated(bool _deprecated) public onlyOwner {\n        deprecated = _deprecated;\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinfabrik-RCN Network Smart Contract Audit/rcn-network-3ded36151ad55543d16c354e70161852de4061d0/contracts/NanoLoanEngine.sol",
        "vulnerability": "Assertion Failure",
        "check": "FP",
        "response": "Answer: No\nReason: The code does not contain any assert statements or conditions that would trigger an assertion failure."
    },
    {
        "code_segment": "contract NanoLoanEngine is ERC721, Engine, Ownable, TokenLockable {\n    uint256 public constant VERSION = 202;\n    string public constant VERSION_NAME = \"Basalt\";\n\n    uint256 private activeLoans = 0;\n    mapping(address => uint256) private lendersBalance;\n\n    function name() constant returns (string _name) {\n        _name = \"RCN - Nano loan engine - Basalt 202\";\n    }\n\n    function symbol() constant returns (string _symbol) {\n        _symbol = \"RCN-NLE-202\";\n    }\n\n    function totalSupply() constant returns (uint _totalSupply) {\n        _totalSupply = activeLoans;\n    }\n\n    function balanceOf(address _owner) constant returns (uint _balance) {\n        _balance = lendersBalance[_owner];\n    }\n\n    function tokenOfOwnerByIndex(address _owner, uint256 _index) constant returns (uint tokenId) {\n        uint256 tokenCount = balanceOf(_owner);\n\n        if (tokenCount == 0 || _index >= tokenCount) {\n            // Fail transaction\n            revert();\n        } else {\n            uint256 totalLoans = totalSupply();\n            uint256 resultIndex = 0;\n\n            uint256 loanId;\n            // SWC-128-DoS With Block Gas Limit: L46\n            for (loanId = 0; loanId <= totalLoans; loanId++) {\n                if (loans[loanId].lender == _owner && loans[loanId].status == Status.lent) {\n                    if (resultIndex == _index) {\n                        return loanId;\n                    }\n                    resultIndex++;\n                }\n            }\n\n            revert();\n        }\n    }\n\n    function tokensOfOwner(address _owner) external constant returns(uint256[] ownerTokens) {\n        uint256 tokenCount = balanceOf(_owner);\n\n        if (tokenCount == 0) {\n            // Return an empty array\n            return new uint256[](0);\n        } else {\n            uint256[] memory result = new uint256[](tokenCount);\n            uint256 totalLoans = totalSupply();\n            uint256 resultIndex = 0;\n\n            uint256 loanId;\n\n            for (loanId = 0; loanId <= totalLoans; loanId++) {\n                if (loans[loanId].lender == _owner && loans[loanId].status == Status.lent) {\n                    result[resultIndex] = loanId;\n                    resultIndex++;\n                }\n            }\n\n            return result;\n        }\n    }\n    \n    Token public rcn;\n    bool public deprecated;\n\n    event CreatedLoan(uint _index, address _borrower, address _creator);\n    event ApprovedBy(uint _index, address _address);\n    event Lent(uint _index, address _lender, address _cosigner);\n    event DestroyedBy(uint _index, address _address);\n    event PartialPayment(uint _index, address _sender, address _from, uint256 _amount);\n    event TotalPayment(uint _index);\n\n    function NanoLoanEngine(Token _rcn) public {\n        owner = msg.sender;\n        rcn = _rcn;\n    }\n\n    struct Loan {\n        Status status;\n        Oracle oracle;\n\n        address borrower;\n        address lender;\n        address creator;\n        address cosigner;\n        \n        uint256 amount;\n        uint256 interest;\n        uint256 punitoryInterest;\n        uint256 interestTimestamp;\n        uint256 paid;\n        uint256 interestRate;\n        uint256 interestRatePunitory;\n        uint256 dueTime;\n        uint256 duesIn;\n\n        bytes32 currency;\n        uint256 cancelableAt;\n        uint256 lenderBalance;\n\n        address approvedTransfer;\n        uint256 expirationRequest;\n\n        mapping(address => bool) approbations;\n    }\n\n    Loan[] private loans;\n\n    /**\n        @dev Creates a loan request, the loan can be generated with any borrower, cosigner, and conditions; if the \n        cosigner and borrower agree they must call the \"approve\" function.\n\n        The creator of the loan is the caller of this function; this is useful to track which wallet created the loan.\n\n        @param _oracleContract Address of the Oracle contract, if the loan does not use any oracle, this field should be 0x0.\n        @param _borrower Address of the borrower\n        @param _currency The currency to use with the oracle, the currency code is generated with the following formula,\n            keccak256(ticker,decimals).\n        @param _amount The requested amount; currency and unit are defined by the Oracle, if there is no Oracle present\n            the currency is RCN, and the unit is wei.\n        @param _interestRate The non-punitory interest rate by second, defined as a denominator of 10 000 000.\n        @param _interestRatePunitory The punitory interest rate by second, defined as a denominator of 10 000 000.\n            Ej: interestRate 11108571428571 = 28% Anual interest\n        @param _duesIn The time in seconds that the borrower has in order to pay the debt after the lender lends the money.\n        @param _cancelableAt Delta in seconds specifying how much interest should be added in advance, if the borrower pays \n        entirely or partially the loan before this term, no extra interest will be deducted.\n        @param _expirationRequest Timestamp of when the loan request expires, if the loan is not filled before this date, \n            the request is no longer valid.\n    */\n    function createLoan(Oracle _oracleContract, address _borrower, bytes32 _currency, uint256 _amount, uint256 _interestRate,\n        uint256 _interestRatePunitory, uint256 _duesIn, uint256 _cancelableAt, uint256 _expirationRequest) returns (uint256) {\n\n        require(!deprecated);\n        require(_cancelableAt <= _duesIn);\n        require(_oracleContract != address(0) || _currency == 0x0);\n        require(_borrower != address(0));\n        require(_amount != 0);\n        require(_interestRatePunitory != 0);\n        require(_interestRate != 0);\n        require(_expirationRequest > block.timestamp);\n\n        var loan = Loan(Status.initial, _oracleContract, _borrower, 0x0, msg.sender, 0x0, _amount, 0, 0, 0, 0, _interestRate,\n            _interestRatePunitory, 0, _duesIn, _currency, _cancelableAt, 0, 0x0, _expirationRequest);\n        uint index = loans.push(loan) - 1;\n        CreatedLoan(index, _borrower, msg.sender);\n\n        if (msg.sender == _borrower) {\n            approveLoan(index);\n        }\n\n        return index;\n    }\n    \n    function ownerOf(uint256 index) constant returns (address owner) { owner = loans[index].lender; }\n    function getTotalLoans() constant returns (uint256) { return loans.length; }\n    function getOracle(uint index) constant returns (Oracle) { return loans[index].oracle; }\n    function getBorrower(uint index) constant returns (address) { return loans[index].borrower; }\n    function getCosigner(uint index) constant returns (address) { return loans[index].cosigner; }\n    function getCreator(uint index) constant returns (address) { return loans[index].creator; }\n    function getAmount(uint index) constant returns (uint256) { return loans[index].amount; }\n    function getPunitoryInterest(uint index) constant returns (uint256) { return loans[index].punitoryInterest; }\n    function getInterestTimestamp(uint index) constant returns (uint256) { return loans[index].interestTimestamp; }\n    function getPaid(uint index) constant returns (uint256) { return loans[index].paid; }\n    function getInterestRate(uint index) constant returns (uint256) { return loans[index].interestRate; }\n    function getInterestRatePunitory(uint index) constant returns (uint256) { return loans[index].interestRatePunitory; }\n    function getDueTime(uint index) constant returns (uint256) { return loans[index].dueTime; }\n    function getDuesIn(uint index) constant returns (uint256) { return loans[index].duesIn; }\n    function getCancelableAt(uint index) constant returns (uint256) { return loans[index].cancelableAt; }\n    function getApprobation(uint index, address _address) constant returns (bool) { return loans[index].approbations[_address]; }\n    function getStatus(uint index) constant returns (Status) { return loans[index].status; }\n    function getLenderBalance(uint index) constant returns (uint256) { return loans[index].lenderBalance; }\n    function getApprovedTransfer(uint index) constant returns (address) {return loans[index].approvedTransfer; }\n    function getCurrency(uint index) constant returns (bytes32) { return loans[index].currency; }\n    function getExpirationRequest(uint index) constant returns (uint256) { return loans[index].expirationRequest; }\n    function getInterest(uint index) constant returns (uint256) { return loans[index].interest; }\n\n    /**\n        @param index Index of the loan\n\n        @return true if the loan has been approved by the borrower and cosigner.\n    */\n    function isApproved(uint index) constant returns (bool) {\n        Loan storage loan = loans[index];\n        return loan.approbations[loan.borrower];\n    }\n\n    /**\n        @dev Called by the members of the loan to show that they agree with the terms of the loan; the borrower\n        must call this method before any lender could call the method \"lend\".\n            \n        Any address can call this method to be added to the \"approbations\" mapping.\n\n        @param index Index of the loan\n\n        @return true if the approve was done successfully\n    */\n    function approveLoan(uint index) public returns(bool) {\n        Loan storage loan = loans[index];\n        require(loan.status == Status.initial);\n        loan.approbations[msg.sender] = true;\n        ApprovedBy(index, msg.sender);\n        return true;\n    }\n\n    /**\n        @dev Performs the lend of the RCN equivalent to the requested amount, and transforms the msg.sender in the new lender.\n\n        The loan must be previously approved by the borrower; before calling this function, the lender candidate must \n        call the \"approve\" function on the RCN Token, specifying an amount sufficient enough to pay the equivalent of\n        the requested amount, and the cosigner fee.\n        \n        @param index Index of the loan\n        @param oracleData Data required by the oracle to return the rate, the content of this field must be provided\n            by the url exposed in the url() method of the oracle.\n        @param cosigner Address of the cosigner, 0x0 for lending without cosigner.\n        @param cosignerData Data required by the cosigner to process the request.\n\n        @return true if the lend was done successfully\n    */\n    function lend(uint index, bytes oracleData, Cosigner cosigner, bytes cosignerData) public returns (bool) {\n        Loan storage loan = loans[index];\n\n        require(loan.status == Status.initial);\n        require(isApproved(index));\n        require(block.timestamp <= loan.expirationRequest);\n\n        loan.lender = msg.sender;\n        loan.dueTime = safeAdd(block.timestamp, loan.duesIn);\n        loan.interestTimestamp = block.timestamp;\n        loan.status = Status.lent;\n        \n        if (loan.cancelableAt > 0)\n            internalAddInterest(loan, safeAdd(block.timestamp, loan.cancelableAt));\n\n        uint256 rate = getRate(loan, oracleData);\n\n        if (cosigner != address(0)) {\n            // The cosigner it's temporary set to the next address (cosigner + 2), it's expected that the cosigner will\n            // call the method \"cosign\" to accept the conditions; that method also sets the cosigner to the right\n            // address. If that does not happen, the transaction fails.\n            loan.cosigner = address(uint256(cosigner) + 2);\n            require(cosigner.requestCosign(this, index, cosignerData, oracleData));\n            require(loan.cosigner == address(cosigner));\n        }\n        \n        require(rcn.transferFrom(msg.sender, loan.borrower, safeMult(loan.amount, rate)));\n        \n        // ERC721, create new loan and transfer it to the lender\n        Transfer(0x0, loan.lender, index);\n        activeLoans += 1;\n        lendersBalance[loan.lender] += 1;\n        Lent(index, loan.lender, cosigner);\n\n        return true;\n    }\n\n    /**\n        @dev The cosigner must call this method to accept the conditions of a loan, this method pays the cosigner his fee\n\n        @param index Index of the loan\n        @param cost Fee set by the cosigner\n\n        @return true If the cosign was successfull\n    */\n    function cosign(uint index, uint256 cost) external returns (bool) {\n        Loan storage loan = loans[index];\n        require(loan.status == Status.lent && (loan.dueTime - loan.duesIn) == block.timestamp);\n        require(loan.cosigner != address(0));\n        require(loan.cosigner == address(uint256(msg.sender) + 2));\n        loan.cosigner = msg.sender;\n        require(rcn.transferFrom(loan.lender, msg.sender, cost));\n        return true;\n    }\n\n    /**\n        @dev Destroys a loan, the borrower could call this method if they performed an accidental or regretted \n        \"approve\" of the loan, this method only works for them if the loan is in \"pending\" status.\n\n        The lender can call this method at any moment, in case of a loan with status \"lent\" the lender is pardoning \n        the debt. \n\n        @param index Index of the loan\n\n        @return true if the destroy was done successfully\n    */\n    function destroy(uint index) public returns (bool) {\n        Loan storage loan = loans[index];\n        require(loan.status != Status.destroyed);\n        require(msg.sender == loan.lender || (msg.sender == loan.borrower && loan.status == Status.initial));\n        DestroyedBy(index, msg.sender);\n\n        // ERC721, remove loan from circulation\n        if (loan.status != Status.initial) {\n            lendersBalance[loan.lender] -= 1;\n            activeLoans -= 1;\n            Transfer(loan.lender, 0x0, index);\n        }\n\n        loan.status = Status.destroyed;\n        return true;\n    }\n\n    /**\n        @dev Transfers a loan to a different lender, the caller must be the current lender or previously being\n        approved with the method \"approveTransfer\"; only loans with the Status.lent status can be transfered.\n\n        @param index Index of the loan\n        @param to New lender\n\n        @return true if the transfer was done successfully\n    */\n    function transfer(address to, uint256 index) public returns (bool) {\n        Loan storage loan = loans[index];\n        \n        require(loan.status != Status.destroyed && loan.status != Status.paid);\n        require(msg.sender == loan.lender || msg.sender == loan.approvedTransfer);\n        require(to != address(0));\n        loan.lender = to;\n        loan.approvedTransfer = address(0);\n\n        // ERC721, transfer loan to another address\n        lendersBalance[msg.sender] -= 1;\n        lendersBalance[to] += 1;\n        Transfer(loan.lender, to, index);\n\n        return true;\n    }\n\n    /**\n        @dev ERC721 method, transfers the loan to the msg.sender, the msg.sender must be approved using the \n        \"approve\" method.\n\n        @return true if the transfer was successfull\n    */\n    function takeOwnership(uint256 _index) public returns (bool) {\n        return transfer(msg.sender, _index);\n    }\n\n    /**\n        @dev Approves the transfer of a given loan in the name of the lender, the behavior of this function is similar to\n        \"approve\" in the ERC20 standard, but only one approved address is allowed at a time.\n\n        The same method can be called passing 0x0 as parameter \"to\" to erase a previously approved address.\n\n        @param to Address allowed to transfer the loan or 0x0 to delete\n        @param index Index of the loan\n\n        @return true if the approve was done successfully\n    */\n    function approve(address to, uint256 index) public returns (bool) {\n        Loan storage loan = loans[index];\n        require(msg.sender == loan.lender);\n        loan.approvedTransfer = to;\n        Approval(msg.sender, to, index);\n        return true;\n    }\n\n    /**\n        @dev Returns the pending amount to complete de payment of the loan, keep in mind that this number increases \n        every second.\n\n        @param index Index of the loan\n\n        @return Aprox pending payment amount\n    */\n    function getPendingAmount(uint index) public constant returns (uint256) {\n        Loan storage loan = loans[index];\n        addInterest(index);\n        return getRawPendingAmount(loan);\n    }\n\n    function getRawPendingAmount(Loan loan) internal returns (uint256) {\n        return safeSubtract(safeAdd(safeAdd(loan.amount, loan.interest), loan.punitoryInterest), loan.paid);\n    }\n\n    /**\n        @dev Calculates the interest of a given amount, interest rate and delta time.\n\n        @param timeDelta Elapsed time\n        @param interestRate Interest rate expressed as the denominator of 10 000 000.\n        @param amount Amount to apply interest\n\n        @return realDelta The real timeDelta applied\n        @return interest The interest gained in the realDelta time\n    */\n    function calculateInterest(uint256 timeDelta, uint256 interestRate, uint256 amount) public constant returns (uint256 realDelta, uint256 interest) {\n        if (amount == 0) {\n            interest = 0;\n            realDelta = timeDelta;\n        } else {\n            interest = safeMult(safeMult(100000, amount), timeDelta) / interestRate;\n            realDelta = safeMult(interest, interestRate) / (amount * 100000);\n        }\n    }\n\n    /**\n        @dev Computes loan interest\n\n        Computes the punitory and non-punitory interest of a given loan and only applies the change.\n        \n        @param loan Loan to compute interest\n        @param timestamp Target absolute unix time to calculate interest.\n    */\n    function internalAddInterest(Loan storage loan, uint256 timestamp) internal {\n        if (timestamp > loan.interestTimestamp) {\n            uint256 newInterest = loan.interest;\n            uint256 newPunitoryInterest = loan.punitoryInterest;\n\n            uint256 newTimestamp;\n            uint256 realDelta;\n            uint256 calculatedInterest;\n\n            uint256 deltaTime;\n            uint256 pending;\n\n            uint256 endNonPunitory = min(timestamp, loan.dueTime);\n            if (endNonPunitory > loan.interestTimestamp) {\n                deltaTime = endNonPunitory - loan.interestTimestamp;\n\n                if (loan.paid < loan.amount) {\n                    pending = loan.amount - loan.paid;\n                } else {\n                    pending = 0;\n                }\n\n                (realDelta, calculatedInterest) = calculateInterest(deltaTime, loan.interestRate, pending);\n                newInterest = safeAdd(calculatedInterest, newInterest);\n                newTimestamp = loan.interestTimestamp + realDelta;\n            }\n\n            if (timestamp > loan.dueTime) {\n                uint256 startPunitory = max(loan.dueTime, loan.interestTimestamp);\n                deltaTime = timestamp - startPunitory;\n\n                uint256 debt = safeAdd(loan.amount, newInterest);\n                pending = min(debt, safeSubtract(safeAdd(debt, newPunitoryInterest), loan.paid));\n\n                (realDelta, calculatedInterest) = calculateInterest(deltaTime, loan.interestRatePunitory, pending);\n                newPunitoryInterest = safeAdd(newPunitoryInterest, calculatedInterest);\n                newTimestamp = startPunitory + realDelta;\n            }\n            \n            if (newInterest != loan.interest || newPunitoryInterest != loan.punitoryInterest) {\n                loan.interestTimestamp = newTimestamp;\n                loan.interest = newInterest;\n                loan.punitoryInterest = newPunitoryInterest;\n            }\n        }\n    }\n\n    /**\n        @dev Computes loan interest only up to current unix time\n\n        @param timestamp Target absolute unix time to calculate interest.\n    */\n    function addInterestUpTo(Loan storage loan, uint256 timestamp) internal {\n        require(loan.status == Status.lent);\n        if (timestamp <= block.timestamp) {\n            internalAddInterest(loan, timestamp);\n        }\n    }\n\n    /**\n        @dev Updates the loan accumulated interests up to the current Unix time.\n        \n        @param index Index of the loan\n    */\n    function addInterest(uint index) public {\n        Loan storage loan = loans[index];\n        addInterestUpTo(loan, block.timestamp);\n    }\n    \n    /**\n        @dev Pay loan\n\n        Realizes a payment of a given Loan, before performing the payment the accumulated\n        interest is computed and added to the total pending amount.\n\n        Before calling this function, the msg.sender must call the \"approve\" function on the RCN Token, specifying an amount\n        sufficient enough to pay the equivalent of the desired payment and the oracle fee.\n\n        Because it is difficult or even impossible to know in advance how much RCN are going to be spent on the\n        transaction*, we recommend performing the \"approve\" using an amount 5% superior to the wallet estimated\n        spending. If the RCN spent results to be less, the extra tokens are never debited from the msg.sender.\n\n        * The RCN rate can fluctuate on the same block, and it is impossible to know in advance the exact time of the\n        confirmation of the transaction. \n\n        If the paid pending amount equals zero, the loan changes status to \"paid\" and it is considered closed.\n\n        @param index Index of the loan\n        @param _amount Amount to pay, specified in the loan currency; or in RCN if the loan has no oracle\n        @param _from The identity of the payer\n        @param oracleData Data required by the oracle to return the rate, the content of this field must be provided\n            by the url exposed in the url() method of the oracle.\n            \n        @return true if the payment was executed successfully\n    */\n    function pay(uint index, uint256 _amount, address _from, bytes oracleData) public returns (bool) {\n        Loan storage loan = loans[index];\n\n        require(loan.status == Status.lent);\n        addInterest(index);\n        uint256 toPay = min(getPendingAmount(index), _amount);\n        PartialPayment(index, msg.sender, _from, toPay);\n\n        loan.paid = safeAdd(loan.paid, toPay);\n\n        if (getRawPendingAmount(loan) == 0) {\n            TotalPayment(index);\n            loan.status = Status.paid;\n\n            // ERC721, remove loan from circulation\n            lendersBalance[loan.lender] -= 1;\n            activeLoans -= 1;\n            Transfer(loan.lender, 0x0, index);\n        }\n\n        uint256 rate = getRate(loan, oracleData);\n        uint256 transferValue = safeMult(toPay, rate);\n        lockTokens(rcn, transferValue);\n        require(rcn.transferFrom(msg.sender, this, transferValue));\n        loan.lenderBalance = safeAdd(transferValue, loan.lenderBalance);\n\n        return true;\n    }\n\n    /**\n        @dev Retrieves the rate corresponding of the loan oracle, if the loan has no oracle the rate is 1\n\n        @param loan The loan with the cosigner\n        @param data Data required by the oracle\n\n        @return The rate of the oracle\n    */\n    function getRate(Loan loan, bytes data) internal returns (uint256) {\n        if (loan.oracle == address(0)) {\n            return 1;\n        } else {\n            return loan.oracle.getRate(loan.currency, data);\n        }\n    }\n\n    /**\n        @dev Withdraw lender funds\n\n        When a loan is paid, the funds are not transferred automatically to the lender, the funds are stored on the\n        engine contract, and the lender must call this function specifying the amount desired to transfer and the \n        destination.\n\n        This behavior is defined to allow the temporary transfer of the loan to a smart contract, without worrying that\n        the contract will receive tokens that are not traceable; and it allows the development of decentralized \n        autonomous organizations.\n\n        @param index Index of the loan\n        @param to Destination of the wiwthdraw funds\n        @param amount Amount to withdraw, in RCN\n\n        @return true if the withdraw was executed successfully\n    */\n    function withdrawal(uint index, address to, uint256 amount) public returns (bool) {\n        Loan storage loan = loans[index];\n        require(msg.sender == loan.lender);\n        loan.lenderBalance = safeSubtract(loan.lenderBalance, amount);\n        require(rcn.transfer(to, amount));\n        unlockTokens(rcn, amount);\n        return true;\n    }\n\n    function withdrawalRange(uint256 fromIndex, uint256 toIndex, address to) public returns (uint256) {\n        uint256 loanId;\n        uint256 totalWithdraw = 0;\n\n        for (loanId = fromIndex; loanId <= toIndex; loanId++) {\n            Loan storage loan = loans[loanId];\n            if (loan.lender == msg.sender) {\n                totalWithdraw += loan.lenderBalance;\n                loan.lenderBalance = 0;\n            }\n        }\n\n        require(rcn.transfer(to, totalWithdraw));\n        unlockTokens(rcn, totalWithdraw);\n        \n        return totalWithdraw;\n    }\n\n    function withdrawalList(uint256[] memory loanIds, address to) public returns (uint256) {\n        uint256 inputId;\n        uint256 totalWithdraw = 0;\n\n        for (inputId = 0; inputId < loanIds.length; inputId++) {\n            Loan storage loan = loans[loanIds[inputId]];\n            if (loan.lender == msg.sender) {\n                totalWithdraw += loan.lenderBalance;\n                loan.lenderBalance = 0;\n            }\n        }\n\n        require(rcn.transfer(to, totalWithdraw));\n        unlockTokens(rcn, totalWithdraw);\n\n        return totalWithdraw;\n    }\n\n    /**\n        @dev Deprecates the engine, locks the creation of new loans.\n    */\n    function setDeprecated(bool _deprecated) public onlyOwner {\n        deprecated = _deprecated;\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinfabrik-RCN Network Smart Contract Audit/rcn-network-3ded36151ad55543d16c354e70161852de4061d0/contracts/NanoLoanEngine.sol",
        "vulnerability": "Assertion Failure",
        "check": "FP",
        "response": "Answer: No  \nReason: The contract does not contain any assert statements that could cause an \"Assertion Failure\"."
    },
    {
        "code_segment": "contract NanoLoanEngine is ERC721, Engine, Ownable, TokenLockable {\n    uint256 public constant VERSION = 202;\n    string public constant VERSION_NAME = \"Basalt\";\n\n    uint256 private activeLoans = 0;\n    mapping(address => uint256) private lendersBalance;\n\n    function name() constant returns (string _name) {\n        _name = \"RCN - Nano loan engine - Basalt 202\";\n    }\n\n    function symbol() constant returns (string _symbol) {\n        _symbol = \"RCN-NLE-202\";\n    }\n\n    function totalSupply() constant returns (uint _totalSupply) {\n        _totalSupply = activeLoans;\n    }\n\n    function balanceOf(address _owner) constant returns (uint _balance) {\n        _balance = lendersBalance[_owner];\n    }\n\n    function tokenOfOwnerByIndex(address _owner, uint256 _index) constant returns (uint tokenId) {\n        uint256 tokenCount = balanceOf(_owner);\n\n        if (tokenCount == 0 || _index >= tokenCount) {\n            // Fail transaction\n            revert();\n        } else {\n            uint256 totalLoans = totalSupply();\n            uint256 resultIndex = 0;\n\n            uint256 loanId;\n            // SWC-128-DoS With Block Gas Limit: L46\n            for (loanId = 0; loanId <= totalLoans; loanId++) {\n                if (loans[loanId].lender == _owner && loans[loanId].status == Status.lent) {\n                    if (resultIndex == _index) {\n                        return loanId;\n                    }\n                    resultIndex++;\n                }\n            }\n\n            revert();\n        }\n    }\n\n    function tokensOfOwner(address _owner) external constant returns(uint256[] ownerTokens) {\n        uint256 tokenCount = balanceOf(_owner);\n\n        if (tokenCount == 0) {\n            // Return an empty array\n            return new uint256[](0);\n        } else {\n            uint256[] memory result = new uint256[](tokenCount);\n            uint256 totalLoans = totalSupply();\n            uint256 resultIndex = 0;\n\n            uint256 loanId;\n\n            for (loanId = 0; loanId <= totalLoans; loanId++) {\n                if (loans[loanId].lender == _owner && loans[loanId].status == Status.lent) {\n                    result[resultIndex] = loanId;\n                    resultIndex++;\n                }\n            }\n\n            return result;\n        }\n    }\n    \n    Token public rcn;\n    bool public deprecated;\n\n    event CreatedLoan(uint _index, address _borrower, address _creator);\n    event ApprovedBy(uint _index, address _address);\n    event Lent(uint _index, address _lender, address _cosigner);\n    event DestroyedBy(uint _index, address _address);\n    event PartialPayment(uint _index, address _sender, address _from, uint256 _amount);\n    event TotalPayment(uint _index);\n\n    function NanoLoanEngine(Token _rcn) public {\n        owner = msg.sender;\n        rcn = _rcn;\n    }\n\n    struct Loan {\n        Status status;\n        Oracle oracle;\n\n        address borrower;\n        address lender;\n        address creator;\n        address cosigner;\n        \n        uint256 amount;\n        uint256 interest;\n        uint256 punitoryInterest;\n        uint256 interestTimestamp;\n        uint256 paid;\n        uint256 interestRate;\n        uint256 interestRatePunitory;\n        uint256 dueTime;\n        uint256 duesIn;\n\n        bytes32 currency;\n        uint256 cancelableAt;\n        uint256 lenderBalance;\n\n        address approvedTransfer;\n        uint256 expirationRequest;\n\n        mapping(address => bool) approbations;\n    }\n\n    Loan[] private loans;\n\n    /**\n        @dev Creates a loan request, the loan can be generated with any borrower, cosigner, and conditions; if the \n        cosigner and borrower agree they must call the \"approve\" function.\n\n        The creator of the loan is the caller of this function; this is useful to track which wallet created the loan.\n\n        @param _oracleContract Address of the Oracle contract, if the loan does not use any oracle, this field should be 0x0.\n        @param _borrower Address of the borrower\n        @param _currency The currency to use with the oracle, the currency code is generated with the following formula,\n            keccak256(ticker,decimals).\n        @param _amount The requested amount; currency and unit are defined by the Oracle, if there is no Oracle present\n            the currency is RCN, and the unit is wei.\n        @param _interestRate The non-punitory interest rate by second, defined as a denominator of 10 000 000.\n        @param _interestRatePunitory The punitory interest rate by second, defined as a denominator of 10 000 000.\n            Ej: interestRate 11108571428571 = 28% Anual interest\n        @param _duesIn The time in seconds that the borrower has in order to pay the debt after the lender lends the money.\n        @param _cancelableAt Delta in seconds specifying how much interest should be added in advance, if the borrower pays \n        entirely or partially the loan before this term, no extra interest will be deducted.\n        @param _expirationRequest Timestamp of when the loan request expires, if the loan is not filled before this date, \n            the request is no longer valid.\n    */\n    function createLoan(Oracle _oracleContract, address _borrower, bytes32 _currency, uint256 _amount, uint256 _interestRate,\n        uint256 _interestRatePunitory, uint256 _duesIn, uint256 _cancelableAt, uint256 _expirationRequest) returns (uint256) {\n\n        require(!deprecated);\n        require(_cancelableAt <= _duesIn);\n        require(_oracleContract != address(0) || _currency == 0x0);\n        require(_borrower != address(0));\n        require(_amount != 0);\n        require(_interestRatePunitory != 0);\n        require(_interestRate != 0);\n        require(_expirationRequest > block.timestamp);\n\n        var loan = Loan(Status.initial, _oracleContract, _borrower, 0x0, msg.sender, 0x0, _amount, 0, 0, 0, 0, _interestRate,\n            _interestRatePunitory, 0, _duesIn, _currency, _cancelableAt, 0, 0x0, _expirationRequest);\n        uint index = loans.push(loan) - 1;\n        CreatedLoan(index, _borrower, msg.sender);\n\n        if (msg.sender == _borrower) {\n            approveLoan(index);\n        }\n\n        return index;\n    }\n    \n    function ownerOf(uint256 index) constant returns (address owner) { owner = loans[index].lender; }\n    function getTotalLoans() constant returns (uint256) { return loans.length; }\n    function getOracle(uint index) constant returns (Oracle) { return loans[index].oracle; }\n    function getBorrower(uint index) constant returns (address) { return loans[index].borrower; }\n    function getCosigner(uint index) constant returns (address) { return loans[index].cosigner; }\n    function getCreator(uint index) constant returns (address) { return loans[index].creator; }\n    function getAmount(uint index) constant returns (uint256) { return loans[index].amount; }\n    function getPunitoryInterest(uint index) constant returns (uint256) { return loans[index].punitoryInterest; }\n    function getInterestTimestamp(uint index) constant returns (uint256) { return loans[index].interestTimestamp; }\n    function getPaid(uint index) constant returns (uint256) { return loans[index].paid; }\n    function getInterestRate(uint index) constant returns (uint256) { return loans[index].interestRate; }\n    function getInterestRatePunitory(uint index) constant returns (uint256) { return loans[index].interestRatePunitory; }\n    function getDueTime(uint index) constant returns (uint256) { return loans[index].dueTime; }\n    function getDuesIn(uint index) constant returns (uint256) { return loans[index].duesIn; }\n    function getCancelableAt(uint index) constant returns (uint256) { return loans[index].cancelableAt; }\n    function getApprobation(uint index, address _address) constant returns (bool) { return loans[index].approbations[_address]; }\n    function getStatus(uint index) constant returns (Status) { return loans[index].status; }\n    function getLenderBalance(uint index) constant returns (uint256) { return loans[index].lenderBalance; }\n    function getApprovedTransfer(uint index) constant returns (address) {return loans[index].approvedTransfer; }\n    function getCurrency(uint index) constant returns (bytes32) { return loans[index].currency; }\n    function getExpirationRequest(uint index) constant returns (uint256) { return loans[index].expirationRequest; }\n    function getInterest(uint index) constant returns (uint256) { return loans[index].interest; }\n\n    /**\n        @param index Index of the loan\n\n        @return true if the loan has been approved by the borrower and cosigner.\n    */\n    function isApproved(uint index) constant returns (bool) {\n        Loan storage loan = loans[index];\n        return loan.approbations[loan.borrower];\n    }\n\n    /**\n        @dev Called by the members of the loan to show that they agree with the terms of the loan; the borrower\n        must call this method before any lender could call the method \"lend\".\n            \n        Any address can call this method to be added to the \"approbations\" mapping.\n\n        @param index Index of the loan\n\n        @return true if the approve was done successfully\n    */\n    function approveLoan(uint index) public returns(bool) {\n        Loan storage loan = loans[index];\n        require(loan.status == Status.initial);\n        loan.approbations[msg.sender] = true;\n        ApprovedBy(index, msg.sender);\n        return true;\n    }\n\n    /**\n        @dev Performs the lend of the RCN equivalent to the requested amount, and transforms the msg.sender in the new lender.\n\n        The loan must be previously approved by the borrower; before calling this function, the lender candidate must \n        call the \"approve\" function on the RCN Token, specifying an amount sufficient enough to pay the equivalent of\n        the requested amount, and the cosigner fee.\n        \n        @param index Index of the loan\n        @param oracleData Data required by the oracle to return the rate, the content of this field must be provided\n            by the url exposed in the url() method of the oracle.\n        @param cosigner Address of the cosigner, 0x0 for lending without cosigner.\n        @param cosignerData Data required by the cosigner to process the request.\n\n        @return true if the lend was done successfully\n    */\n    function lend(uint index, bytes oracleData, Cosigner cosigner, bytes cosignerData) public returns (bool) {\n        Loan storage loan = loans[index];\n\n        require(loan.status == Status.initial);\n        require(isApproved(index));\n        require(block.timestamp <= loan.expirationRequest);\n\n        loan.lender = msg.sender;\n        loan.dueTime = safeAdd(block.timestamp, loan.duesIn);\n        loan.interestTimestamp = block.timestamp;\n        loan.status = Status.lent;\n        \n        if (loan.cancelableAt > 0)\n            internalAddInterest(loan, safeAdd(block.timestamp, loan.cancelableAt));\n\n        uint256 rate = getRate(loan, oracleData);\n\n        if (cosigner != address(0)) {\n            // The cosigner it's temporary set to the next address (cosigner + 2), it's expected that the cosigner will\n            // call the method \"cosign\" to accept the conditions; that method also sets the cosigner to the right\n            // address. If that does not happen, the transaction fails.\n            loan.cosigner = address(uint256(cosigner) + 2);\n            require(cosigner.requestCosign(this, index, cosignerData, oracleData));\n            require(loan.cosigner == address(cosigner));\n        }\n        \n        require(rcn.transferFrom(msg.sender, loan.borrower, safeMult(loan.amount, rate)));\n        \n        // ERC721, create new loan and transfer it to the lender\n        Transfer(0x0, loan.lender, index);\n        activeLoans += 1;\n        lendersBalance[loan.lender] += 1;\n        Lent(index, loan.lender, cosigner);\n\n        return true;\n    }\n\n    /**\n        @dev The cosigner must call this method to accept the conditions of a loan, this method pays the cosigner his fee\n\n        @param index Index of the loan\n        @param cost Fee set by the cosigner\n\n        @return true If the cosign was successfull\n    */\n    function cosign(uint index, uint256 cost) external returns (bool) {\n        Loan storage loan = loans[index];\n        require(loan.status == Status.lent && (loan.dueTime - loan.duesIn) == block.timestamp);\n        require(loan.cosigner != address(0));\n        require(loan.cosigner == address(uint256(msg.sender) + 2));\n        loan.cosigner = msg.sender;\n        require(rcn.transferFrom(loan.lender, msg.sender, cost));\n        return true;\n    }\n\n    /**\n        @dev Destroys a loan, the borrower could call this method if they performed an accidental or regretted \n        \"approve\" of the loan, this method only works for them if the loan is in \"pending\" status.\n\n        The lender can call this method at any moment, in case of a loan with status \"lent\" the lender is pardoning \n        the debt. \n\n        @param index Index of the loan\n\n        @return true if the destroy was done successfully\n    */\n    function destroy(uint index) public returns (bool) {\n        Loan storage loan = loans[index];\n        require(loan.status != Status.destroyed);\n        require(msg.sender == loan.lender || (msg.sender == loan.borrower && loan.status == Status.initial));\n        DestroyedBy(index, msg.sender);\n\n        // ERC721, remove loan from circulation\n        if (loan.status != Status.initial) {\n            lendersBalance[loan.lender] -= 1;\n            activeLoans -= 1;\n            Transfer(loan.lender, 0x0, index);\n        }\n\n        loan.status = Status.destroyed;\n        return true;\n    }\n\n    /**\n        @dev Transfers a loan to a different lender, the caller must be the current lender or previously being\n        approved with the method \"approveTransfer\"; only loans with the Status.lent status can be transfered.\n\n        @param index Index of the loan\n        @param to New lender\n\n        @return true if the transfer was done successfully\n    */\n    function transfer(address to, uint256 index) public returns (bool) {\n        Loan storage loan = loans[index];\n        \n        require(loan.status != Status.destroyed && loan.status != Status.paid);\n        require(msg.sender == loan.lender || msg.sender == loan.approvedTransfer);\n        require(to != address(0));\n        loan.lender = to;\n        loan.approvedTransfer = address(0);\n\n        // ERC721, transfer loan to another address\n        lendersBalance[msg.sender] -= 1;\n        lendersBalance[to] += 1;\n        Transfer(loan.lender, to, index);\n\n        return true;\n    }\n\n    /**\n        @dev ERC721 method, transfers the loan to the msg.sender, the msg.sender must be approved using the \n        \"approve\" method.\n\n        @return true if the transfer was successfull\n    */\n    function takeOwnership(uint256 _index) public returns (bool) {\n        return transfer(msg.sender, _index);\n    }\n\n    /**\n        @dev Approves the transfer of a given loan in the name of the lender, the behavior of this function is similar to\n        \"approve\" in the ERC20 standard, but only one approved address is allowed at a time.\n\n        The same method can be called passing 0x0 as parameter \"to\" to erase a previously approved address.\n\n        @param to Address allowed to transfer the loan or 0x0 to delete\n        @param index Index of the loan\n\n        @return true if the approve was done successfully\n    */\n    function approve(address to, uint256 index) public returns (bool) {\n        Loan storage loan = loans[index];\n        require(msg.sender == loan.lender);\n        loan.approvedTransfer = to;\n        Approval(msg.sender, to, index);\n        return true;\n    }\n\n    /**\n        @dev Returns the pending amount to complete de payment of the loan, keep in mind that this number increases \n        every second.\n\n        @param index Index of the loan\n\n        @return Aprox pending payment amount\n    */\n    function getPendingAmount(uint index) public constant returns (uint256) {\n        Loan storage loan = loans[index];\n        addInterest(index);\n        return getRawPendingAmount(loan);\n    }\n\n    function getRawPendingAmount(Loan loan) internal returns (uint256) {\n        return safeSubtract(safeAdd(safeAdd(loan.amount, loan.interest), loan.punitoryInterest), loan.paid);\n    }\n\n    /**\n        @dev Calculates the interest of a given amount, interest rate and delta time.\n\n        @param timeDelta Elapsed time\n        @param interestRate Interest rate expressed as the denominator of 10 000 000.\n        @param amount Amount to apply interest\n\n        @return realDelta The real timeDelta applied\n        @return interest The interest gained in the realDelta time\n    */\n    function calculateInterest(uint256 timeDelta, uint256 interestRate, uint256 amount) public constant returns (uint256 realDelta, uint256 interest) {\n        if (amount == 0) {\n            interest = 0;\n            realDelta = timeDelta;\n        } else {\n            interest = safeMult(safeMult(100000, amount), timeDelta) / interestRate;\n            realDelta = safeMult(interest, interestRate) / (amount * 100000);\n        }\n    }\n\n    /**\n        @dev Computes loan interest\n\n        Computes the punitory and non-punitory interest of a given loan and only applies the change.\n        \n        @param loan Loan to compute interest\n        @param timestamp Target absolute unix time to calculate interest.\n    */\n    function internalAddInterest(Loan storage loan, uint256 timestamp) internal {\n        if (timestamp > loan.interestTimestamp) {\n            uint256 newInterest = loan.interest;\n            uint256 newPunitoryInterest = loan.punitoryInterest;\n\n            uint256 newTimestamp;\n            uint256 realDelta;\n            uint256 calculatedInterest;\n\n            uint256 deltaTime;\n            uint256 pending;\n\n            uint256 endNonPunitory = min(timestamp, loan.dueTime);\n            if (endNonPunitory > loan.interestTimestamp) {\n                deltaTime = endNonPunitory - loan.interestTimestamp;\n\n                if (loan.paid < loan.amount) {\n                    pending = loan.amount - loan.paid;\n                } else {\n                    pending = 0;\n                }\n\n                (realDelta, calculatedInterest) = calculateInterest(deltaTime, loan.interestRate, pending);\n                newInterest = safeAdd(calculatedInterest, newInterest);\n                newTimestamp = loan.interestTimestamp + realDelta;\n            }\n\n            if (timestamp > loan.dueTime) {\n                uint256 startPunitory = max(loan.dueTime, loan.interestTimestamp);\n                deltaTime = timestamp - startPunitory;\n\n                uint256 debt = safeAdd(loan.amount, newInterest);\n                pending = min(debt, safeSubtract(safeAdd(debt, newPunitoryInterest), loan.paid));\n\n                (realDelta, calculatedInterest) = calculateInterest(deltaTime, loan.interestRatePunitory, pending);\n                newPunitoryInterest = safeAdd(newPunitoryInterest, calculatedInterest);\n                newTimestamp = startPunitory + realDelta;\n            }\n            \n            if (newInterest != loan.interest || newPunitoryInterest != loan.punitoryInterest) {\n                loan.interestTimestamp = newTimestamp;\n                loan.interest = newInterest;\n                loan.punitoryInterest = newPunitoryInterest;\n            }\n        }\n    }\n\n    /**\n        @dev Computes loan interest only up to current unix time\n\n        @param timestamp Target absolute unix time to calculate interest.\n    */\n    function addInterestUpTo(Loan storage loan, uint256 timestamp) internal {\n        require(loan.status == Status.lent);\n        if (timestamp <= block.timestamp) {\n            internalAddInterest(loan, timestamp);\n        }\n    }\n\n    /**\n        @dev Updates the loan accumulated interests up to the current Unix time.\n        \n        @param index Index of the loan\n    */\n    function addInterest(uint index) public {\n        Loan storage loan = loans[index];\n        addInterestUpTo(loan, block.timestamp);\n    }\n    \n    /**\n        @dev Pay loan\n\n        Realizes a payment of a given Loan, before performing the payment the accumulated\n        interest is computed and added to the total pending amount.\n\n        Before calling this function, the msg.sender must call the \"approve\" function on the RCN Token, specifying an amount\n        sufficient enough to pay the equivalent of the desired payment and the oracle fee.\n\n        Because it is difficult or even impossible to know in advance how much RCN are going to be spent on the\n        transaction*, we recommend performing the \"approve\" using an amount 5% superior to the wallet estimated\n        spending. If the RCN spent results to be less, the extra tokens are never debited from the msg.sender.\n\n        * The RCN rate can fluctuate on the same block, and it is impossible to know in advance the exact time of the\n        confirmation of the transaction. \n\n        If the paid pending amount equals zero, the loan changes status to \"paid\" and it is considered closed.\n\n        @param index Index of the loan\n        @param _amount Amount to pay, specified in the loan currency; or in RCN if the loan has no oracle\n        @param _from The identity of the payer\n        @param oracleData Data required by the oracle to return the rate, the content of this field must be provided\n            by the url exposed in the url() method of the oracle.\n            \n        @return true if the payment was executed successfully\n    */\n    function pay(uint index, uint256 _amount, address _from, bytes oracleData) public returns (bool) {\n        Loan storage loan = loans[index];\n\n        require(loan.status == Status.lent);\n        addInterest(index);\n        uint256 toPay = min(getPendingAmount(index), _amount);\n        PartialPayment(index, msg.sender, _from, toPay);\n\n        loan.paid = safeAdd(loan.paid, toPay);\n\n        if (getRawPendingAmount(loan) == 0) {\n            TotalPayment(index);\n            loan.status = Status.paid;\n\n            // ERC721, remove loan from circulation\n            lendersBalance[loan.lender] -= 1;\n            activeLoans -= 1;\n            Transfer(loan.lender, 0x0, index);\n        }\n\n        uint256 rate = getRate(loan, oracleData);\n        uint256 transferValue = safeMult(toPay, rate);\n        lockTokens(rcn, transferValue);\n        require(rcn.transferFrom(msg.sender, this, transferValue));\n        loan.lenderBalance = safeAdd(transferValue, loan.lenderBalance);\n\n        return true;\n    }\n\n    /**\n        @dev Retrieves the rate corresponding of the loan oracle, if the loan has no oracle the rate is 1\n\n        @param loan The loan with the cosigner\n        @param data Data required by the oracle\n\n        @return The rate of the oracle\n    */\n    function getRate(Loan loan, bytes data) internal returns (uint256) {\n        if (loan.oracle == address(0)) {\n            return 1;\n        } else {\n            return loan.oracle.getRate(loan.currency, data);\n        }\n    }\n\n    /**\n        @dev Withdraw lender funds\n\n        When a loan is paid, the funds are not transferred automatically to the lender, the funds are stored on the\n        engine contract, and the lender must call this function specifying the amount desired to transfer and the \n        destination.\n\n        This behavior is defined to allow the temporary transfer of the loan to a smart contract, without worrying that\n        the contract will receive tokens that are not traceable; and it allows the development of decentralized \n        autonomous organizations.\n\n        @param index Index of the loan\n        @param to Destination of the wiwthdraw funds\n        @param amount Amount to withdraw, in RCN\n\n        @return true if the withdraw was executed successfully\n    */\n    function withdrawal(uint index, address to, uint256 amount) public returns (bool) {\n        Loan storage loan = loans[index];\n        require(msg.sender == loan.lender);\n        loan.lenderBalance = safeSubtract(loan.lenderBalance, amount);\n        require(rcn.transfer(to, amount));\n        unlockTokens(rcn, amount);\n        return true;\n    }\n\n    function withdrawalRange(uint256 fromIndex, uint256 toIndex, address to) public returns (uint256) {\n        uint256 loanId;\n        uint256 totalWithdraw = 0;\n\n        for (loanId = fromIndex; loanId <= toIndex; loanId++) {\n            Loan storage loan = loans[loanId];\n            if (loan.lender == msg.sender) {\n                totalWithdraw += loan.lenderBalance;\n                loan.lenderBalance = 0;\n            }\n        }\n\n        require(rcn.transfer(to, totalWithdraw));\n        unlockTokens(rcn, totalWithdraw);\n        \n        return totalWithdraw;\n    }\n\n    function withdrawalList(uint256[] memory loanIds, address to) public returns (uint256) {\n        uint256 inputId;\n        uint256 totalWithdraw = 0;\n\n        for (inputId = 0; inputId < loanIds.length; inputId++) {\n            Loan storage loan = loans[loanIds[inputId]];\n            if (loan.lender == msg.sender) {\n                totalWithdraw += loan.lenderBalance;\n                loan.lenderBalance = 0;\n            }\n        }\n\n        require(rcn.transfer(to, totalWithdraw));\n        unlockTokens(rcn, totalWithdraw);\n\n        return totalWithdraw;\n    }\n\n    /**\n        @dev Deprecates the engine, locks the creation of new loans.\n    */\n    function setDeprecated(bool _deprecated) public onlyOwner {\n        deprecated = _deprecated;\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinfabrik-RCN Network Smart Contract Audit/rcn-network-3ded36151ad55543d16c354e70161852de4061d0/contracts/NanoLoanEngine.sol",
        "vulnerability": "Block Dependency",
        "check": "FP",
        "response": "Answer: Yes\nDescription: The contract uses \"block.timestamp\" in the \"createLoan\" and \"lend\" functions for loan expiry and validity checks. This can be manipulated by miners, leading to potential unexpected behavior."
    },
    {
        "code_segment": "contract TokenLockable is RpSafeMath, Ownable {\n    mapping(address => uint256) public lockedTokens;\n\n    /**\n        @dev Locked tokens cannot be withdrawn using the withdrawTokens function.\n    */\n    function lockTokens(address token, uint256 amount) internal {\n        lockedTokens[token] = safeAdd(lockedTokens[token], amount);\n    }\n\n    /**\n        @dev Unlocks previusly locked tokens.\n    */\n    function unlockTokens(address token, uint256 amount) internal {\n        lockedTokens[token] = safeSubtract(lockedTokens[token], amount);\n    }\n\n    /**\n        @dev Withdraws tokens from the contract.\n\n        @param token Token to withdraw\n        @param to Destination of the tokens\n        @param amount Amount to withdraw \n    */\n    function withdrawTokens(Token token, address to, uint256 amount) public onlyOwner returns (bool) {\n        require(safeSubtract(token.balanceOf(this), lockedTokens[token]) >= amount);\n        require(to != address(0));\n        return token.transfer(to, amount);\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinfabrik-RCN Network Smart Contract Audit/rcn-network-3ded36151ad55543d16c354e70161852de4061d0/contracts/NanoLoanEngine.sol",
        "vulnerability": "Reentrancy",
        "check": "FP",
        "response": "Answer: Yes\nDescription: The withdrawal function does not update the balance state before calling the external transfer function, allowing the possibility of a reentrancy attack."
    },
    {
        "code_segment": "contract AVX is ERC20 {\n    \n    /**\n     * @dev Sets symbol, name, decimals and totalSupply of the token\n     * \n     * - Sets msg.sender as the owner of the contract\n     * - Transfers totalSupply to owner\n     */ \n    constructor()   {\n        symbol = \"AVX\";\n        name = \"AVX Launchpad\";\n        decimals = 18;                                    \n        totalSupply = 21000000 * 10**18;\n        change = false;\n        percent = 15;\n       \n        owner = msg.sender;\n        balances[owner] = totalSupply;\n    }\n    \n    \n    /**\n     * @dev Calls mint function from ERC20 contract\n     * \n     * Requirements:\n     * \n     * - only owner can call this function\n     * - 'to' address cannot be zero address\n     */\n    function mint(address to, uint amount) external onlyOwner {\n        require(to != address(0), \"No mint to zero address\");\n        _mint(to, amount);\n    }\n    \n    /**\n     * @dev Calls burn function from ERC20 contract\n     * \n     */\n    function burn(uint amount) external {\n        _burn(msg.sender, amount);\n    }\n    \n    \n   \n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/QuillAudits-AVX Smart Contract/code/code.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No\nReason: The provided code does not contain arithmetic operations that would be susceptible to integer overflow. The constructor, mint, and burn functions use safe abstractions of the ERC20 standard, which typically employ built-in checks or SafeMath for handling such vulnerabilities."
    },
    {
        "code_segment": "contract BSB_StakingSmartStakers is Ownable {\n    using SafeMath for uint;\n    using EnumerableSet for EnumerableSet.AddressSet;\n    \n    event RewardsTransferred(address holder, uint amount);\n    event RewardsRestaked(address holder, uint amount);\n    \n    /*\n    * @dev Token contract address\n    */\n    address public constant tokenDepositAddress = 0xA478A13242b64629bff309125770B69f75Bd77cb;\n    \n    /*\n    * @dev Reward rate 520.00% per year\n    */\n    uint public rewardRate = 52000;\n    uint public constant rewardInterval = 365 days;\n    \n    /*\n    * @dev Staking fee 1 percent\n    */\n    uint public constant stakingFeeRate = 100;\n    \n    /*\n    * @dev Unstaking fee 0.50 percent\n    */\n    uint public constant unstakingFeeRate = 50;\n    \n    /*\n    * @dev Unstaking possible after 90 days\n    */\n    uint public constant unstakeTime = 90 days;\n    \n    /*\n    * @dev Claiming possible every 10 days\n    */\n    uint public constant claimTime = 10 days;\n    \n    /*\n    * @dev Pool size \n    */\n    uint public constant maxPoolSize = 50000000000000000000000;\n    uint public availablePoolSize = 50000000000000000000000;\n    \n    /*\n    * @dev Total rewards\n    */\n    uint public constant totalRewards = 200000000000000000000000; \n    \n    uint public totalClaimedRewards = 0;\n    uint public totalDeposited = 0; // usar esta variable que no se usa!\n    bool public ended ;\n    \n    EnumerableSet.AddressSet private holders;\n    \n    mapping (address => uint) public depositedTokens;\n    mapping (address => uint) public maxDepositedTokens;\n    mapping (address => uint) public stakingTime; //used for the unstaking locktime\n    mapping (address => uint) public firstTime; //used for the APY boost\n    mapping (address => uint) public lastClaimedTime; //used for the claiming locktime\n    mapping (address => uint) public progressiveTime; //used for the claiming locktime\n    mapping (address => uint) public totalEarnedTokens;\n    \n    mapping (address => uint) public rewardEnded;\n    \n    /*\n    * @dev Progressive Unstaking\n    */\n    mapping (address => uint) public alreadyProgUnstaked; \n    mapping (address => uint) public amountPerInterval;\n    uint public number_intervals = 4;\n    uint public duration_interval = 30 days;\n    \n    /*\n    * @dev Incentive For Not Unstaking\n    */\n    uint extraAPY = 10400; // 2% extra weekly\n    \n    /*\n    * @dev Smart Capped Claiming\n    */\n    uint percent_claim = 2; // 20% of weekly rewards earned\n    mapping (address => uint) public unclaimed;\n    \n    uint public endTime;\n    \n    /* FUNCTIONS */\n    \n    /*\n    * @dev End the staking pool\n    */\n    function end() public onlyOwner returns (bool){\n        require(!ended, \"Staking already ended\");\n        address _aux;\n        // SWC-128-DoS With Block Gas Limit: L393 - L401\n        for(uint i = 0; i < holders.length(); i = i.add(1)){\n            _aux = holders.at(i);\n            rewardEnded[_aux] = getPendingRewards(_aux);\n            unclaimed[_aux] = 0;\n            stakingTime[_aux] = block.timestamp;\n            progressiveTime[_aux] = block.timestamp;\n            alreadyProgUnstaked[_aux] = 0;\n            amountPerInterval[_aux] = depositedTokens[_aux].div(number_intervals);\n        }\n        \n        ended = true;\n        endTime = block.timestamp;\n        return true;\n    }\n    \n    function getRewardsLeft() public view returns (uint){\n       \n        uint _res;\n        if(ended){\n            _res = 0;\n        }else{\n            uint totalPending;\n        // SWC-128-DoS With Block Gas Limit: L416 - L418\n            for(uint i = 0; i < holders.length(); i = i.add(1)){\n                totalPending = totalPending.add(getPendingRewards(holders.at(i)));\n            }\n            if(totalRewards > totalClaimedRewards.add(totalPending)){\n                _res = totalRewards.sub(totalClaimedRewards).sub(totalPending);\n            }else{\n                _res = 0;\n            }\n            \n        }\n        \n        return _res;\n    }\n    \n    function updateAccount(address account, bool _restake, bool _withdraw) private returns (bool){\n        uint pendingDivs = getPendingRewards(account);\n        uint toSend = pendingDivs;\n        \n        if(depositedTokens[account].mul(percent_claim).div(100) < pendingDivs){\n            toSend = depositedTokens[account].mul(percent_claim).div(100);\n        }\n        \n        if (pendingDivs > 0) {\n            if(ended){ // claim o withdraw cuando ha terminado\n                if(!_withdraw){\n                     \n                    if(depositedTokens[account] == 0){\n                        \n                        if( maxDepositedTokens[account].mul(percent_claim).div(100) > pendingDivs ){\n                            toSend = pendingDivs;\n                        }else{\n                            toSend = maxDepositedTokens[account].mul(percent_claim).div(100);\n                        }\n                    }\n                     rewardEnded[account] = rewardEnded[account].sub(toSend);\n                     require(Token(tokenDepositAddress).transfer(account, toSend), \"Could not transfer tokens.\");\n                     totalEarnedTokens[account] = totalEarnedTokens[account].add(toSend);\n                     totalClaimedRewards = totalClaimedRewards.add(toSend);\n                }\n               \n            }else{\n                \n                if(_restake){ // deposit\n                    require(pendingDivs <= availablePoolSize, \"No spot available\");\n                    depositedTokens[account] = depositedTokens[account].add(pendingDivs);\n                    \n                    unclaimed[account] = 0;\n                    \n                    if(depositedTokens[account] > maxDepositedTokens[account]){\n                        maxDepositedTokens[account] = depositedTokens[account];\n                    } \n                    availablePoolSize = availablePoolSize.sub(pendingDivs);\n                    totalDeposited = totalDeposited.add(pendingDivs);\n                    totalEarnedTokens[account] = totalEarnedTokens[account].add(pendingDivs);\n                    totalClaimedRewards = totalClaimedRewards.add(pendingDivs);\n                }else if(_withdraw){ // withdraw\n                    unclaimed[account] = pendingDivs;\n                // claim\n                }else{ // does not have deposited tokens\n                    if(depositedTokens[account] == 0){\n                        \n                        if( maxDepositedTokens[account].mul(percent_claim).div(100) > pendingDivs ){\n                            toSend = pendingDivs;\n                        }else{\n                            toSend = maxDepositedTokens[account].mul(percent_claim).div(100);\n                        }\n                    }\n                    uint toUnclaimed = 0;\n                    uint subUnclaimed = 0;\n                    uint pendingWithoutUnclaimed = getOnlyPendingRewards(account);\n                    if(toSend > pendingWithoutUnclaimed){\n                        subUnclaimed = toSend.sub(pendingWithoutUnclaimed);\n                        toUnclaimed = 0;\n                    }else{\n                        toUnclaimed = pendingWithoutUnclaimed.sub(toSend);\n                        subUnclaimed = 0;\n                    }\n                \n                    unclaimed[account] = unclaimed[account].add(toUnclaimed).sub(subUnclaimed);\n                    require(Token(tokenDepositAddress).transfer(account, toSend), \"Could not transfer tokens.\");\n                    totalEarnedTokens[account] = totalEarnedTokens[account].add(toSend);\n                    totalClaimedRewards = totalClaimedRewards.add(toSend);\n                }\n            }    \n        }\n        lastClaimedTime[account] = block.timestamp;\n        return true;\n    }\n    \n    function getAPY(address _staker) public view returns(uint){\n        uint apy = rewardRate;\n        if(block.timestamp.sub(firstTime[_staker]) > unstakeTime && alreadyProgUnstaked[_staker] == 0 && !ended){\n            apy = apy.add(extraAPY);\n        }\n        return apy;\n    }\n    \n    function getPendingRewards(address _holder) public view returns (uint) { //getPendingRewards\n        if (!holders.contains(_holder)) return 0;\n        if (depositedTokens[_holder] == 0 && unclaimed[_holder] == 0 && !ended) return 0;\n        uint pendingDivs;\n        if(!ended){\n             uint timeDiff = block.timestamp.sub(lastClaimedTime[_holder]);\n             uint stakedAmount = depositedTokens[_holder];\n             \n             // Incentive For Not Unstaking\n             uint apy = getAPY(_holder);\n        \n             pendingDivs = stakedAmount\n                                .mul(apy) \n                                .mul(timeDiff)\n                                .div(rewardInterval)\n                                .div(1e4);\n                                \n             pendingDivs = pendingDivs.add(unclaimed[_holder]);\n            \n        }else{\n            pendingDivs = rewardEnded[_holder];\n        }\n       \n        return pendingDivs;\n    }\n    \n    function getOnlyPendingRewards(address _holder) internal view returns (uint) { // getPendingRewards without \"Unclaimed\"\n        if (!holders.contains(_holder)) return 0;\n        if (depositedTokens[_holder] == 0 || ended) return 0;\n        uint pendingDivs;\n        if(!ended){\n             uint timeDiff = block.timestamp.sub(lastClaimedTime[_holder]);\n             uint stakedAmount = depositedTokens[_holder];\n             \n             // Incentive For Not Unstaking\n             uint apy = getAPY(_holder);\n        \n             pendingDivs = stakedAmount\n                                .mul(apy) \n                                .mul(timeDiff)\n                                .div(rewardInterval)\n                                .div(1e4);\n            \n        }else{\n            pendingDivs = 0;\n        }\n       \n        return pendingDivs;\n    }\n    \n    function getNumberOfHolders() public view returns (uint) {\n        return holders.length();\n    }\n    \n    function deposit(uint amountToStake) public returns (bool){\n        require(!ended, \"Staking has ended\");\n        require(getRewardsLeft() > 0, \"No rewards left\");\n        require(amountToStake > 0, \"Cannot deposit 0 Tokens\");\n       \n        require(Token(tokenDepositAddress).transferFrom(msg.sender, address(this), amountToStake), \"Insufficient Token Allowance\");\n        \n        \n        require(updateAccount(msg.sender, true, false), \"Error updating account\");\n        \n        uint fee = amountToStake.mul(stakingFeeRate).div(1e4);\n        uint amountAfterFee = amountToStake.sub(fee);\n        require(amountAfterFee <= availablePoolSize, \"No space available\");\n        require(Token(tokenDepositAddress).transfer(owner, fee), \"Could not transfer deposit fee.\");\n        \n        depositedTokens[msg.sender] = depositedTokens[msg.sender].add(amountAfterFee);\n        if(depositedTokens[msg.sender] > maxDepositedTokens[msg.sender]){\n            maxDepositedTokens[msg.sender] = depositedTokens[msg.sender];\n        } \n        availablePoolSize = availablePoolSize.sub(amountAfterFee);\n        totalDeposited = totalDeposited.add(amountAfterFee);\n        \n        if (!holders.contains(msg.sender)) {\n            holders.add(msg.sender);\n            firstTime[msg.sender] = block.timestamp;\n            \n        }\n        \n        // Reset the Progressive Unstaking\n        amountPerInterval[msg.sender] = 0;\n        if(alreadyProgUnstaked[msg.sender] > 0){\n            firstTime[msg.sender] = block.timestamp;\n        } \n        \n        alreadyProgUnstaked[msg.sender] = 0;\n        \n        stakingTime[msg.sender] = block.timestamp;\n        return true;\n    }\n    \n    /*\n    * @dev Max amount withdrawable on basis on time\n    */\n    function getMaxAmountWithdrawable(address _staker) public view returns(uint){\n        uint _res = 0;\n        if(block.timestamp.sub(stakingTime[msg.sender]) < unstakeTime && !ended && alreadyProgUnstaked[_staker] == 0){\n            _res = 0;\n        }else if(alreadyProgUnstaked[_staker] == 0 && !ended){\n            \n            if(block.timestamp.sub(stakingTime[msg.sender]) > unstakeTime){\n                _res = depositedTokens[_staker].div(number_intervals);\n            }\n          \n        }else{\n            uint _time = progressiveTime[_staker];\n            \n            if(block.timestamp < _time.add(duration_interval)){\n                _res = 0;\n            }else{\n               \n                \n                uint _numIntervals = (block.timestamp.sub(_time)).div(duration_interval);\n                \n                if(_numIntervals == 0){\n                    return 0;\n                }\n                if(!ended){\n                    _numIntervals = _numIntervals.add(1);\n                }\n                \n                \n                if(_numIntervals > number_intervals){\n                    _numIntervals = number_intervals;\n                }\n                \n                if(_numIntervals.mul(amountPerInterval[_staker]) > alreadyProgUnstaked[_staker]){\n                    _res = _numIntervals.mul(amountPerInterval[_staker]).sub(alreadyProgUnstaked[_staker]);\n                }else{\n                    _res = 0;\n                }\n            }\n            \n            \n        }\n\n        return _res;\n    }\n    \n    /*\n    * @dev Progressive Unstaking (Second, third, fourth... Progressive withdraws)\n    */\n    function withdraw2(uint amountToWithdraw) public returns (bool){\n        require(holders.contains(msg.sender), \"Not a staker\");\n        require(amountToWithdraw <= getMaxAmountWithdrawable(msg.sender), \"Maximum reached\");\n        require(alreadyProgUnstaked[msg.sender] > 0 || ended, \"Use withdraw first\");\n        \n        alreadyProgUnstaked[msg.sender] = alreadyProgUnstaked[msg.sender].add(amountToWithdraw);\n        \n        uint fee = amountToWithdraw.mul(unstakingFeeRate).div(1e4);\n        uint amountAfterFee = amountToWithdraw.sub(fee);\n        \n        updateAccount(msg.sender, false, true);\n        \n        require(Token(tokenDepositAddress).transfer(owner, fee), \"Could not transfer withdraw fee.\");\n        require(Token(tokenDepositAddress).transfer(msg.sender, amountAfterFee), \"Could not transfer tokens.\");\n        \n        depositedTokens[msg.sender] = depositedTokens[msg.sender].sub(amountToWithdraw);\n        availablePoolSize = availablePoolSize.add(amountToWithdraw);\n        totalDeposited = totalDeposited.sub(amountToWithdraw);\n        \n        if (holders.contains(msg.sender) && depositedTokens[msg.sender] == 0 && getPendingRewards(msg.sender) == 0) {\n            holders.remove(msg.sender);\n            firstTime[msg.sender] = 0;\n        }\n        return true;\n    }\n    \n    /*\n    * @dev Progressive Unstaking (First  withdraw)\n    */\n    function withdraw(uint amountToWithdraw) public returns (bool){\n        require(holders.contains(msg.sender), \"Not a staker\");\n        require(alreadyProgUnstaked[msg.sender] == 0 && !ended , \"Use withdraw2 function\");\n        amountPerInterval[msg.sender] = depositedTokens[msg.sender].div(number_intervals);\n        require(depositedTokens[msg.sender].div(number_intervals) >= amountToWithdraw, \"Invalid amount to withdraw\");\n        alreadyProgUnstaked[msg.sender] = amountToWithdraw;\n        require(block.timestamp.sub(stakingTime[msg.sender]) > unstakeTime || ended, \"You recently staked, please wait before withdrawing.\");\n        \n        \n        \n        updateAccount(msg.sender, false, true);\n        \n        uint fee = amountToWithdraw.mul(unstakingFeeRate).div(1e4);\n        uint amountAfterFee = amountToWithdraw.sub(fee);\n        \n        require(Token(tokenDepositAddress).transfer(owner, fee), \"Could not transfer withdraw fee.\");\n        require(Token(tokenDepositAddress).transfer(msg.sender, amountAfterFee), \"Could not transfer tokens.\");\n        \n        depositedTokens[msg.sender] = depositedTokens[msg.sender].sub(amountToWithdraw);\n        availablePoolSize = availablePoolSize.add(amountToWithdraw);\n        totalDeposited = totalDeposited.sub(amountToWithdraw);\n        \n        progressiveTime[msg.sender] = block.timestamp;\n    \n        return true;\n    }\n    \n    function getTimeToWithdraw(address _staker) public view returns (uint){\n        if(getMaxAmountWithdrawable(_staker) != 0) return 0;\n        \n        uint _res = 0;\n        uint _time = stakingTime[_staker];\n        if(alreadyProgUnstaked[_staker] == 0 && !ended ){\n            \n            if(block.timestamp <= _time.add(unstakeTime)){\n                _res = _time.add(unstakeTime).sub(block.timestamp);\n            }\n            \n        }else{\n            _time = progressiveTime[_staker];\n            \n            for(uint i = 1; i <= number_intervals; i = i.add(1)){\n                if(block.timestamp < _time.add(duration_interval.mul(i))){\n                    _res = _time.add(duration_interval.mul(i)).sub(block.timestamp);\n                    break;\n                }\n            }\n            \n        }\n        return _res;\n    }\n    \n    function getTimeToClaim(address _staker) public view returns (uint){\n        uint _res = 0;\n        \n        if(lastClaimedTime[_staker].add(claimTime) > block.timestamp){\n            _res = lastClaimedTime[_staker].add(claimTime).sub(block.timestamp);\n        }\n        \n        return _res;\n    }\n    \n    function claimDivs() public  returns (bool){\n        require(holders.contains(msg.sender), \"Not a staker\");\n        require(block.timestamp.sub(lastClaimedTime[msg.sender]) > claimTime, \"Not yet\");\n        updateAccount(msg.sender, false, false);\n        return true;\n    }\n    \n    function getStakersList(uint startIndex, uint endIndex) public view returns (address[] memory stakers, uint[] memory stakingTimestamps,  uint[] memory lastClaimedTimeStamps, uint[] memory stakedTokens) {\n        require (startIndex < endIndex);\n        \n        uint length = endIndex.sub(startIndex);\n        address[] memory _stakers = new address[](length);\n        uint[] memory _stakingTimestamps = new uint[](length);\n        uint[] memory _lastClaimedTimeStamps = new uint[](length);\n        uint[] memory _stakedTokens = new uint[](length);\n        \n        for (uint i = startIndex; i < endIndex; i = i.add(1)) {\n            address staker = holders.at(i);\n            uint listIndex = i.sub(startIndex);\n            _stakers[listIndex] = staker;\n            _stakingTimestamps[listIndex] = stakingTime[staker];\n            _lastClaimedTimeStamps[listIndex] = lastClaimedTime[staker];\n            _stakedTokens[listIndex] = depositedTokens[staker];\n        }\n        \n        return (_stakers, _stakingTimestamps, _lastClaimedTimeStamps, _stakedTokens);\n    }\n    \n    /*\n    * @dev function to allow admin to claim *other* ERC20 tokens sent to this contract (by mistake)\n    */\n    function transferAnyERC20Tokens(address _tokenAddr, address _to, uint _amount) public onlyOwner  returns (bool){\n        require (_tokenAddr != tokenDepositAddress, \"Cannot Transfer Out this token\");\n        Token(_tokenAddr).transfer(_to, _amount);\n        return true;\n    }\n    \n    function getClaimableAmount(address account) public view returns (uint){\n        uint pendingDivs = getPendingRewards(account);\n        uint toSend = pendingDivs;\n        \n        if(depositedTokens[account].mul(percent_claim).div(100) < pendingDivs){\n            toSend = depositedTokens[account].mul(percent_claim).div(100);\n        }\n        \n        if (pendingDivs > 0) {\n            if(ended){ // claim o withdraw cuando ha terminado\n                    if(depositedTokens[account] == 0){\n                        \n                        if( maxDepositedTokens[account].mul(percent_claim).div(100) > pendingDivs ){\n                            toSend = pendingDivs;\n                        }else{\n                            toSend = maxDepositedTokens[account].mul(percent_claim).div(100);\n                        }\n                    }\n                \n            }else{\n                if(depositedTokens[account] == 0){\n                        \n                    if( maxDepositedTokens[account].mul(percent_claim).div(100) > pendingDivs ){\n                        toSend = pendingDivs;\n                    }else{\n                        toSend = maxDepositedTokens[account].mul(percent_claim).div(100);\n                    }\n                }\n            }    \n        }\n        return toSend;\n    }\n    \n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Hacken-Bitcoin SB-V2/code/BSB_StakingSmartStakers.sol",
        "vulnerability": "Block Dependency",
        "check": "FP",
        "response": "Answer: No\nReason: There are no instances of using block properties such as `block.number` or `blockhash` for critical control flow or calculations, which are characteristics of block dependency vulnerabilities.\n"
    },
    {
        "code_segment": "contract BSB_StakingSmartStakers is Ownable {\n    using SafeMath for uint;\n    using EnumerableSet for EnumerableSet.AddressSet;\n    \n    event RewardsTransferred(address holder, uint amount);\n    event RewardsRestaked(address holder, uint amount);\n    \n    /*\n    * @dev Token contract address\n    */\n    address public constant tokenDepositAddress = 0xA478A13242b64629bff309125770B69f75Bd77cb;\n    \n    /*\n    * @dev Reward rate 520.00% per year\n    */\n    uint public rewardRate = 52000;\n    uint public constant rewardInterval = 365 days;\n    \n    /*\n    * @dev Staking fee 1 percent\n    */\n    uint public constant stakingFeeRate = 100;\n    \n    /*\n    * @dev Unstaking fee 0.50 percent\n    */\n    uint public constant unstakingFeeRate = 50;\n    \n    /*\n    * @dev Unstaking possible after 90 days\n    */\n    uint public constant unstakeTime = 90 days;\n    \n    /*\n    * @dev Claiming possible every 10 days\n    */\n    uint public constant claimTime = 10 days;\n    \n    /*\n    * @dev Pool size \n    */\n    uint public constant maxPoolSize = 50000000000000000000000;\n    uint public availablePoolSize = 50000000000000000000000;\n    \n    /*\n    * @dev Total rewards\n    */\n    uint public constant totalRewards = 200000000000000000000000; \n    \n    uint public totalClaimedRewards = 0;\n    uint public totalDeposited = 0; // usar esta variable que no se usa!\n    bool public ended ;\n    \n    EnumerableSet.AddressSet private holders;\n    \n    mapping (address => uint) public depositedTokens;\n    mapping (address => uint) public maxDepositedTokens;\n    mapping (address => uint) public stakingTime; //used for the unstaking locktime\n    mapping (address => uint) public firstTime; //used for the APY boost\n    mapping (address => uint) public lastClaimedTime; //used for the claiming locktime\n    mapping (address => uint) public progressiveTime; //used for the claiming locktime\n    mapping (address => uint) public totalEarnedTokens;\n    \n    mapping (address => uint) public rewardEnded;\n    \n    /*\n    * @dev Progressive Unstaking\n    */\n    mapping (address => uint) public alreadyProgUnstaked; \n    mapping (address => uint) public amountPerInterval;\n    uint public number_intervals = 4;\n    uint public duration_interval = 30 days;\n    \n    /*\n    * @dev Incentive For Not Unstaking\n    */\n    uint extraAPY = 10400; // 2% extra weekly\n    \n    /*\n    * @dev Smart Capped Claiming\n    */\n    uint percent_claim = 2; // 20% of weekly rewards earned\n    mapping (address => uint) public unclaimed;\n    \n    uint public endTime;\n    \n    /* FUNCTIONS */\n    \n    /*\n    * @dev End the staking pool\n    */\n    function end() public onlyOwner returns (bool){\n        require(!ended, \"Staking already ended\");\n        address _aux;\n        // SWC-128-DoS With Block Gas Limit: L393 - L401\n        for(uint i = 0; i < holders.length(); i = i.add(1)){\n            _aux = holders.at(i);\n            rewardEnded[_aux] = getPendingRewards(_aux);\n            unclaimed[_aux] = 0;\n            stakingTime[_aux] = block.timestamp;\n            progressiveTime[_aux] = block.timestamp;\n            alreadyProgUnstaked[_aux] = 0;\n            amountPerInterval[_aux] = depositedTokens[_aux].div(number_intervals);\n        }\n        \n        ended = true;\n        endTime = block.timestamp;\n        return true;\n    }\n    \n    function getRewardsLeft() public view returns (uint){\n       \n        uint _res;\n        if(ended){\n            _res = 0;\n        }else{\n            uint totalPending;\n        // SWC-128-DoS With Block Gas Limit: L416 - L418\n            for(uint i = 0; i < holders.length(); i = i.add(1)){\n                totalPending = totalPending.add(getPendingRewards(holders.at(i)));\n            }\n            if(totalRewards > totalClaimedRewards.add(totalPending)){\n                _res = totalRewards.sub(totalClaimedRewards).sub(totalPending);\n            }else{\n                _res = 0;\n            }\n            \n        }\n        \n        return _res;\n    }\n    \n    function updateAccount(address account, bool _restake, bool _withdraw) private returns (bool){\n        uint pendingDivs = getPendingRewards(account);\n        uint toSend = pendingDivs;\n        \n        if(depositedTokens[account].mul(percent_claim).div(100) < pendingDivs){\n            toSend = depositedTokens[account].mul(percent_claim).div(100);\n        }\n        \n        if (pendingDivs > 0) {\n            if(ended){ // claim o withdraw cuando ha terminado\n                if(!_withdraw){\n                     \n                    if(depositedTokens[account] == 0){\n                        \n                        if( maxDepositedTokens[account].mul(percent_claim).div(100) > pendingDivs ){\n                            toSend = pendingDivs;\n                        }else{\n                            toSend = maxDepositedTokens[account].mul(percent_claim).div(100);\n                        }\n                    }\n                     rewardEnded[account] = rewardEnded[account].sub(toSend);\n                     require(Token(tokenDepositAddress).transfer(account, toSend), \"Could not transfer tokens.\");\n                     totalEarnedTokens[account] = totalEarnedTokens[account].add(toSend);\n                     totalClaimedRewards = totalClaimedRewards.add(toSend);\n                }\n               \n            }else{\n                \n                if(_restake){ // deposit\n                    require(pendingDivs <= availablePoolSize, \"No spot available\");\n                    depositedTokens[account] = depositedTokens[account].add(pendingDivs);\n                    \n                    unclaimed[account] = 0;\n                    \n                    if(depositedTokens[account] > maxDepositedTokens[account]){\n                        maxDepositedTokens[account] = depositedTokens[account];\n                    } \n                    availablePoolSize = availablePoolSize.sub(pendingDivs);\n                    totalDeposited = totalDeposited.add(pendingDivs);\n                    totalEarnedTokens[account] = totalEarnedTokens[account].add(pendingDivs);\n                    totalClaimedRewards = totalClaimedRewards.add(pendingDivs);\n                }else if(_withdraw){ // withdraw\n                    unclaimed[account] = pendingDivs;\n                // claim\n                }else{ // does not have deposited tokens\n                    if(depositedTokens[account] == 0){\n                        \n                        if( maxDepositedTokens[account].mul(percent_claim).div(100) > pendingDivs ){\n                            toSend = pendingDivs;\n                        }else{\n                            toSend = maxDepositedTokens[account].mul(percent_claim).div(100);\n                        }\n                    }\n                    uint toUnclaimed = 0;\n                    uint subUnclaimed = 0;\n                    uint pendingWithoutUnclaimed = getOnlyPendingRewards(account);\n                    if(toSend > pendingWithoutUnclaimed){\n                        subUnclaimed = toSend.sub(pendingWithoutUnclaimed);\n                        toUnclaimed = 0;\n                    }else{\n                        toUnclaimed = pendingWithoutUnclaimed.sub(toSend);\n                        subUnclaimed = 0;\n                    }\n                \n                    unclaimed[account] = unclaimed[account].add(toUnclaimed).sub(subUnclaimed);\n                    require(Token(tokenDepositAddress).transfer(account, toSend), \"Could not transfer tokens.\");\n                    totalEarnedTokens[account] = totalEarnedTokens[account].add(toSend);\n                    totalClaimedRewards = totalClaimedRewards.add(toSend);\n                }\n            }    \n        }\n        lastClaimedTime[account] = block.timestamp;\n        return true;\n    }\n    \n    function getAPY(address _staker) public view returns(uint){\n        uint apy = rewardRate;\n        if(block.timestamp.sub(firstTime[_staker]) > unstakeTime && alreadyProgUnstaked[_staker] == 0 && !ended){\n            apy = apy.add(extraAPY);\n        }\n        return apy;\n    }\n    \n    function getPendingRewards(address _holder) public view returns (uint) { //getPendingRewards\n        if (!holders.contains(_holder)) return 0;\n        if (depositedTokens[_holder] == 0 && unclaimed[_holder] == 0 && !ended) return 0;\n        uint pendingDivs;\n        if(!ended){\n             uint timeDiff = block.timestamp.sub(lastClaimedTime[_holder]);\n             uint stakedAmount = depositedTokens[_holder];\n             \n             // Incentive For Not Unstaking\n             uint apy = getAPY(_holder);\n        \n             pendingDivs = stakedAmount\n                                .mul(apy) \n                                .mul(timeDiff)\n                                .div(rewardInterval)\n                                .div(1e4);\n                                \n             pendingDivs = pendingDivs.add(unclaimed[_holder]);\n            \n        }else{\n            pendingDivs = rewardEnded[_holder];\n        }\n       \n        return pendingDivs;\n    }\n    \n    function getOnlyPendingRewards(address _holder) internal view returns (uint) { // getPendingRewards without \"Unclaimed\"\n        if (!holders.contains(_holder)) return 0;\n        if (depositedTokens[_holder] == 0 || ended) return 0;\n        uint pendingDivs;\n        if(!ended){\n             uint timeDiff = block.timestamp.sub(lastClaimedTime[_holder]);\n             uint stakedAmount = depositedTokens[_holder];\n             \n             // Incentive For Not Unstaking\n             uint apy = getAPY(_holder);\n        \n             pendingDivs = stakedAmount\n                                .mul(apy) \n                                .mul(timeDiff)\n                                .div(rewardInterval)\n                                .div(1e4);\n            \n        }else{\n            pendingDivs = 0;\n        }\n       \n        return pendingDivs;\n    }\n    \n    function getNumberOfHolders() public view returns (uint) {\n        return holders.length();\n    }\n    \n    function deposit(uint amountToStake) public returns (bool){\n        require(!ended, \"Staking has ended\");\n        require(getRewardsLeft() > 0, \"No rewards left\");\n        require(amountToStake > 0, \"Cannot deposit 0 Tokens\");\n       \n        require(Token(tokenDepositAddress).transferFrom(msg.sender, address(this), amountToStake), \"Insufficient Token Allowance\");\n        \n        \n        require(updateAccount(msg.sender, true, false), \"Error updating account\");\n        \n        uint fee = amountToStake.mul(stakingFeeRate).div(1e4);\n        uint amountAfterFee = amountToStake.sub(fee);\n        require(amountAfterFee <= availablePoolSize, \"No space available\");\n        require(Token(tokenDepositAddress).transfer(owner, fee), \"Could not transfer deposit fee.\");\n        \n        depositedTokens[msg.sender] = depositedTokens[msg.sender].add(amountAfterFee);\n        if(depositedTokens[msg.sender] > maxDepositedTokens[msg.sender]){\n            maxDepositedTokens[msg.sender] = depositedTokens[msg.sender];\n        } \n        availablePoolSize = availablePoolSize.sub(amountAfterFee);\n        totalDeposited = totalDeposited.add(amountAfterFee);\n        \n        if (!holders.contains(msg.sender)) {\n            holders.add(msg.sender);\n            firstTime[msg.sender] = block.timestamp;\n            \n        }\n        \n        // Reset the Progressive Unstaking\n        amountPerInterval[msg.sender] = 0;\n        if(alreadyProgUnstaked[msg.sender] > 0){\n            firstTime[msg.sender] = block.timestamp;\n        } \n        \n        alreadyProgUnstaked[msg.sender] = 0;\n        \n        stakingTime[msg.sender] = block.timestamp;\n        return true;\n    }\n    \n    /*\n    * @dev Max amount withdrawable on basis on time\n    */\n    function getMaxAmountWithdrawable(address _staker) public view returns(uint){\n        uint _res = 0;\n        if(block.timestamp.sub(stakingTime[msg.sender]) < unstakeTime && !ended && alreadyProgUnstaked[_staker] == 0){\n            _res = 0;\n        }else if(alreadyProgUnstaked[_staker] == 0 && !ended){\n            \n            if(block.timestamp.sub(stakingTime[msg.sender]) > unstakeTime){\n                _res = depositedTokens[_staker].div(number_intervals);\n            }\n          \n        }else{\n            uint _time = progressiveTime[_staker];\n            \n            if(block.timestamp < _time.add(duration_interval)){\n                _res = 0;\n            }else{\n               \n                \n                uint _numIntervals = (block.timestamp.sub(_time)).div(duration_interval);\n                \n                if(_numIntervals == 0){\n                    return 0;\n                }\n                if(!ended){\n                    _numIntervals = _numIntervals.add(1);\n                }\n                \n                \n                if(_numIntervals > number_intervals){\n                    _numIntervals = number_intervals;\n                }\n                \n                if(_numIntervals.mul(amountPerInterval[_staker]) > alreadyProgUnstaked[_staker]){\n                    _res = _numIntervals.mul(amountPerInterval[_staker]).sub(alreadyProgUnstaked[_staker]);\n                }else{\n                    _res = 0;\n                }\n            }\n            \n            \n        }\n\n        return _res;\n    }\n    \n    /*\n    * @dev Progressive Unstaking (Second, third, fourth... Progressive withdraws)\n    */\n    function withdraw2(uint amountToWithdraw) public returns (bool){\n        require(holders.contains(msg.sender), \"Not a staker\");\n        require(amountToWithdraw <= getMaxAmountWithdrawable(msg.sender), \"Maximum reached\");\n        require(alreadyProgUnstaked[msg.sender] > 0 || ended, \"Use withdraw first\");\n        \n        alreadyProgUnstaked[msg.sender] = alreadyProgUnstaked[msg.sender].add(amountToWithdraw);\n        \n        uint fee = amountToWithdraw.mul(unstakingFeeRate).div(1e4);\n        uint amountAfterFee = amountToWithdraw.sub(fee);\n        \n        updateAccount(msg.sender, false, true);\n        \n        require(Token(tokenDepositAddress).transfer(owner, fee), \"Could not transfer withdraw fee.\");\n        require(Token(tokenDepositAddress).transfer(msg.sender, amountAfterFee), \"Could not transfer tokens.\");\n        \n        depositedTokens[msg.sender] = depositedTokens[msg.sender].sub(amountToWithdraw);\n        availablePoolSize = availablePoolSize.add(amountToWithdraw);\n        totalDeposited = totalDeposited.sub(amountToWithdraw);\n        \n        if (holders.contains(msg.sender) && depositedTokens[msg.sender] == 0 && getPendingRewards(msg.sender) == 0) {\n            holders.remove(msg.sender);\n            firstTime[msg.sender] = 0;\n        }\n        return true;\n    }\n    \n    /*\n    * @dev Progressive Unstaking (First  withdraw)\n    */\n    function withdraw(uint amountToWithdraw) public returns (bool){\n        require(holders.contains(msg.sender), \"Not a staker\");\n        require(alreadyProgUnstaked[msg.sender] == 0 && !ended , \"Use withdraw2 function\");\n        amountPerInterval[msg.sender] = depositedTokens[msg.sender].div(number_intervals);\n        require(depositedTokens[msg.sender].div(number_intervals) >= amountToWithdraw, \"Invalid amount to withdraw\");\n        alreadyProgUnstaked[msg.sender] = amountToWithdraw;\n        require(block.timestamp.sub(stakingTime[msg.sender]) > unstakeTime || ended, \"You recently staked, please wait before withdrawing.\");\n        \n        \n        \n        updateAccount(msg.sender, false, true);\n        \n        uint fee = amountToWithdraw.mul(unstakingFeeRate).div(1e4);\n        uint amountAfterFee = amountToWithdraw.sub(fee);\n        \n        require(Token(tokenDepositAddress).transfer(owner, fee), \"Could not transfer withdraw fee.\");\n        require(Token(tokenDepositAddress).transfer(msg.sender, amountAfterFee), \"Could not transfer tokens.\");\n        \n        depositedTokens[msg.sender] = depositedTokens[msg.sender].sub(amountToWithdraw);\n        availablePoolSize = availablePoolSize.add(amountToWithdraw);\n        totalDeposited = totalDeposited.sub(amountToWithdraw);\n        \n        progressiveTime[msg.sender] = block.timestamp;\n    \n        return true;\n    }\n    \n    function getTimeToWithdraw(address _staker) public view returns (uint){\n        if(getMaxAmountWithdrawable(_staker) != 0) return 0;\n        \n        uint _res = 0;\n        uint _time = stakingTime[_staker];\n        if(alreadyProgUnstaked[_staker] == 0 && !ended ){\n            \n            if(block.timestamp <= _time.add(unstakeTime)){\n                _res = _time.add(unstakeTime).sub(block.timestamp);\n            }\n            \n        }else{\n            _time = progressiveTime[_staker];\n            \n            for(uint i = 1; i <= number_intervals; i = i.add(1)){\n                if(block.timestamp < _time.add(duration_interval.mul(i))){\n                    _res = _time.add(duration_interval.mul(i)).sub(block.timestamp);\n                    break;\n                }\n            }\n            \n        }\n        return _res;\n    }\n    \n    function getTimeToClaim(address _staker) public view returns (uint){\n        uint _res = 0;\n        \n        if(lastClaimedTime[_staker].add(claimTime) > block.timestamp){\n            _res = lastClaimedTime[_staker].add(claimTime).sub(block.timestamp);\n        }\n        \n        return _res;\n    }\n    \n    function claimDivs() public  returns (bool){\n        require(holders.contains(msg.sender), \"Not a staker\");\n        require(block.timestamp.sub(lastClaimedTime[msg.sender]) > claimTime, \"Not yet\");\n        updateAccount(msg.sender, false, false);\n        return true;\n    }\n    \n    function getStakersList(uint startIndex, uint endIndex) public view returns (address[] memory stakers, uint[] memory stakingTimestamps,  uint[] memory lastClaimedTimeStamps, uint[] memory stakedTokens) {\n        require (startIndex < endIndex);\n        \n        uint length = endIndex.sub(startIndex);\n        address[] memory _stakers = new address[](length);\n        uint[] memory _stakingTimestamps = new uint[](length);\n        uint[] memory _lastClaimedTimeStamps = new uint[](length);\n        uint[] memory _stakedTokens = new uint[](length);\n        \n        for (uint i = startIndex; i < endIndex; i = i.add(1)) {\n            address staker = holders.at(i);\n            uint listIndex = i.sub(startIndex);\n            _stakers[listIndex] = staker;\n            _stakingTimestamps[listIndex] = stakingTime[staker];\n            _lastClaimedTimeStamps[listIndex] = lastClaimedTime[staker];\n            _stakedTokens[listIndex] = depositedTokens[staker];\n        }\n        \n        return (_stakers, _stakingTimestamps, _lastClaimedTimeStamps, _stakedTokens);\n    }\n    \n    /*\n    * @dev function to allow admin to claim *other* ERC20 tokens sent to this contract (by mistake)\n    */\n    function transferAnyERC20Tokens(address _tokenAddr, address _to, uint _amount) public onlyOwner  returns (bool){\n        require (_tokenAddr != tokenDepositAddress, \"Cannot Transfer Out this token\");\n        Token(_tokenAddr).transfer(_to, _amount);\n        return true;\n    }\n    \n    function getClaimableAmount(address account) public view returns (uint){\n        uint pendingDivs = getPendingRewards(account);\n        uint toSend = pendingDivs;\n        \n        if(depositedTokens[account].mul(percent_claim).div(100) < pendingDivs){\n            toSend = depositedTokens[account].mul(percent_claim).div(100);\n        }\n        \n        if (pendingDivs > 0) {\n            if(ended){ // claim o withdraw cuando ha terminado\n                    if(depositedTokens[account] == 0){\n                        \n                        if( maxDepositedTokens[account].mul(percent_claim).div(100) > pendingDivs ){\n                            toSend = pendingDivs;\n                        }else{\n                            toSend = maxDepositedTokens[account].mul(percent_claim).div(100);\n                        }\n                    }\n                \n            }else{\n                if(depositedTokens[account] == 0){\n                        \n                    if( maxDepositedTokens[account].mul(percent_claim).div(100) > pendingDivs ){\n                        toSend = pendingDivs;\n                    }else{\n                        toSend = maxDepositedTokens[account].mul(percent_claim).div(100);\n                    }\n                }\n            }    \n        }\n        return toSend;\n    }\n    \n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Hacken-Bitcoin SB-V2/code/BSB_StakingSmartStakers.sol",
        "vulnerability": "Block Dependency",
        "check": "FP",
        "response": "Answer: Yes\nDescription: The contract uses the block timestamp (block.timestamp) in calculations for determining the staking time, last claimed time, progressive time, and end time, which can be manipulated by miners to influence the outcome of transactions, specifically in time-dependent logic processes."
    },
    {
        "code_segment": "contract BSB_StakingSmartStakers is Ownable {\n    using SafeMath for uint;\n    using EnumerableSet for EnumerableSet.AddressSet;\n    \n    event RewardsTransferred(address holder, uint amount);\n    event RewardsRestaked(address holder, uint amount);\n    \n    /*\n    * @dev Token contract address\n    */\n    address public constant tokenDepositAddress = 0xA478A13242b64629bff309125770B69f75Bd77cb;\n    \n    /*\n    * @dev Reward rate 520.00% per year\n    */\n    uint public rewardRate = 52000;\n    uint public constant rewardInterval = 365 days;\n    \n    /*\n    * @dev Staking fee 1 percent\n    */\n    uint public constant stakingFeeRate = 100;\n    \n    /*\n    * @dev Unstaking fee 0.50 percent\n    */\n    uint public constant unstakingFeeRate = 50;\n    \n    /*\n    * @dev Unstaking possible after 90 days\n    */\n    uint public constant unstakeTime = 90 days;\n    \n    /*\n    * @dev Claiming possible every 10 days\n    */\n    uint public constant claimTime = 10 days;\n    \n    /*\n    * @dev Pool size \n    */\n    uint public constant maxPoolSize = 50000000000000000000000;\n    uint public availablePoolSize = 50000000000000000000000;\n    \n    /*\n    * @dev Total rewards\n    */\n    uint public constant totalRewards = 200000000000000000000000; \n    \n    uint public totalClaimedRewards = 0;\n    uint public totalDeposited = 0; // usar esta variable que no se usa!\n    bool public ended ;\n    \n    EnumerableSet.AddressSet private holders;\n    \n    mapping (address => uint) public depositedTokens;\n    mapping (address => uint) public maxDepositedTokens;\n    mapping (address => uint) public stakingTime; //used for the unstaking locktime\n    mapping (address => uint) public firstTime; //used for the APY boost\n    mapping (address => uint) public lastClaimedTime; //used for the claiming locktime\n    mapping (address => uint) public progressiveTime; //used for the claiming locktime\n    mapping (address => uint) public totalEarnedTokens;\n    \n    mapping (address => uint) public rewardEnded;\n    \n    /*\n    * @dev Progressive Unstaking\n    */\n    mapping (address => uint) public alreadyProgUnstaked; \n    mapping (address => uint) public amountPerInterval;\n    uint public number_intervals = 4;\n    uint public duration_interval = 30 days;\n    \n    /*\n    * @dev Incentive For Not Unstaking\n    */\n    uint extraAPY = 10400; // 2% extra weekly\n    \n    /*\n    * @dev Smart Capped Claiming\n    */\n    uint percent_claim = 2; // 20% of weekly rewards earned\n    mapping (address => uint) public unclaimed;\n    \n    uint public endTime;\n    \n    /* FUNCTIONS */\n    \n    /*\n    * @dev End the staking pool\n    */\n    function end() public onlyOwner returns (bool){\n        require(!ended, \"Staking already ended\");\n        address _aux;\n        // SWC-128-DoS With Block Gas Limit: L393 - L401\n        for(uint i = 0; i < holders.length(); i = i.add(1)){\n            _aux = holders.at(i);\n            rewardEnded[_aux] = getPendingRewards(_aux);\n            unclaimed[_aux] = 0;\n            stakingTime[_aux] = block.timestamp;\n            progressiveTime[_aux] = block.timestamp;\n            alreadyProgUnstaked[_aux] = 0;\n            amountPerInterval[_aux] = depositedTokens[_aux].div(number_intervals);\n        }\n        \n        ended = true;\n        endTime = block.timestamp;\n        return true;\n    }\n    \n    function getRewardsLeft() public view returns (uint){\n       \n        uint _res;\n        if(ended){\n            _res = 0;\n        }else{\n            uint totalPending;\n        // SWC-128-DoS With Block Gas Limit: L416 - L418\n            for(uint i = 0; i < holders.length(); i = i.add(1)){\n                totalPending = totalPending.add(getPendingRewards(holders.at(i)));\n            }\n            if(totalRewards > totalClaimedRewards.add(totalPending)){\n                _res = totalRewards.sub(totalClaimedRewards).sub(totalPending);\n            }else{\n                _res = 0;\n            }\n            \n        }\n        \n        return _res;\n    }\n    \n    function updateAccount(address account, bool _restake, bool _withdraw) private returns (bool){\n        uint pendingDivs = getPendingRewards(account);\n        uint toSend = pendingDivs;\n        \n        if(depositedTokens[account].mul(percent_claim).div(100) < pendingDivs){\n            toSend = depositedTokens[account].mul(percent_claim).div(100);\n        }\n        \n        if (pendingDivs > 0) {\n            if(ended){ // claim o withdraw cuando ha terminado\n                if(!_withdraw){\n                     \n                    if(depositedTokens[account] == 0){\n                        \n                        if( maxDepositedTokens[account].mul(percent_claim).div(100) > pendingDivs ){\n                            toSend = pendingDivs;\n                        }else{\n                            toSend = maxDepositedTokens[account].mul(percent_claim).div(100);\n                        }\n                    }\n                     rewardEnded[account] = rewardEnded[account].sub(toSend);\n                     require(Token(tokenDepositAddress).transfer(account, toSend), \"Could not transfer tokens.\");\n                     totalEarnedTokens[account] = totalEarnedTokens[account].add(toSend);\n                     totalClaimedRewards = totalClaimedRewards.add(toSend);\n                }\n               \n            }else{\n                \n                if(_restake){ // deposit\n                    require(pendingDivs <= availablePoolSize, \"No spot available\");\n                    depositedTokens[account] = depositedTokens[account].add(pendingDivs);\n                    \n                    unclaimed[account] = 0;\n                    \n                    if(depositedTokens[account] > maxDepositedTokens[account]){\n                        maxDepositedTokens[account] = depositedTokens[account];\n                    } \n                    availablePoolSize = availablePoolSize.sub(pendingDivs);\n                    totalDeposited = totalDeposited.add(pendingDivs);\n                    totalEarnedTokens[account] = totalEarnedTokens[account].add(pendingDivs);\n                    totalClaimedRewards = totalClaimedRewards.add(pendingDivs);\n                }else if(_withdraw){ // withdraw\n                    unclaimed[account] = pendingDivs;\n                // claim\n                }else{ // does not have deposited tokens\n                    if(depositedTokens[account] == 0){\n                        \n                        if( maxDepositedTokens[account].mul(percent_claim).div(100) > pendingDivs ){\n                            toSend = pendingDivs;\n                        }else{\n                            toSend = maxDepositedTokens[account].mul(percent_claim).div(100);\n                        }\n                    }\n                    uint toUnclaimed = 0;\n                    uint subUnclaimed = 0;\n                    uint pendingWithoutUnclaimed = getOnlyPendingRewards(account);\n                    if(toSend > pendingWithoutUnclaimed){\n                        subUnclaimed = toSend.sub(pendingWithoutUnclaimed);\n                        toUnclaimed = 0;\n                    }else{\n                        toUnclaimed = pendingWithoutUnclaimed.sub(toSend);\n                        subUnclaimed = 0;\n                    }\n                \n                    unclaimed[account] = unclaimed[account].add(toUnclaimed).sub(subUnclaimed);\n                    require(Token(tokenDepositAddress).transfer(account, toSend), \"Could not transfer tokens.\");\n                    totalEarnedTokens[account] = totalEarnedTokens[account].add(toSend);\n                    totalClaimedRewards = totalClaimedRewards.add(toSend);\n                }\n            }    \n        }\n        lastClaimedTime[account] = block.timestamp;\n        return true;\n    }\n    \n    function getAPY(address _staker) public view returns(uint){\n        uint apy = rewardRate;\n        if(block.timestamp.sub(firstTime[_staker]) > unstakeTime && alreadyProgUnstaked[_staker] == 0 && !ended){\n            apy = apy.add(extraAPY);\n        }\n        return apy;\n    }\n    \n    function getPendingRewards(address _holder) public view returns (uint) { //getPendingRewards\n        if (!holders.contains(_holder)) return 0;\n        if (depositedTokens[_holder] == 0 && unclaimed[_holder] == 0 && !ended) return 0;\n        uint pendingDivs;\n        if(!ended){\n             uint timeDiff = block.timestamp.sub(lastClaimedTime[_holder]);\n             uint stakedAmount = depositedTokens[_holder];\n             \n             // Incentive For Not Unstaking\n             uint apy = getAPY(_holder);\n        \n             pendingDivs = stakedAmount\n                                .mul(apy) \n                                .mul(timeDiff)\n                                .div(rewardInterval)\n                                .div(1e4);\n                                \n             pendingDivs = pendingDivs.add(unclaimed[_holder]);\n            \n        }else{\n            pendingDivs = rewardEnded[_holder];\n        }\n       \n        return pendingDivs;\n    }\n    \n    function getOnlyPendingRewards(address _holder) internal view returns (uint) { // getPendingRewards without \"Unclaimed\"\n        if (!holders.contains(_holder)) return 0;\n        if (depositedTokens[_holder] == 0 || ended) return 0;\n        uint pendingDivs;\n        if(!ended){\n             uint timeDiff = block.timestamp.sub(lastClaimedTime[_holder]);\n             uint stakedAmount = depositedTokens[_holder];\n             \n             // Incentive For Not Unstaking\n             uint apy = getAPY(_holder);\n        \n             pendingDivs = stakedAmount\n                                .mul(apy) \n                                .mul(timeDiff)\n                                .div(rewardInterval)\n                                .div(1e4);\n            \n        }else{\n            pendingDivs = 0;\n        }\n       \n        return pendingDivs;\n    }\n    \n    function getNumberOfHolders() public view returns (uint) {\n        return holders.length();\n    }\n    \n    function deposit(uint amountToStake) public returns (bool){\n        require(!ended, \"Staking has ended\");\n        require(getRewardsLeft() > 0, \"No rewards left\");\n        require(amountToStake > 0, \"Cannot deposit 0 Tokens\");\n       \n        require(Token(tokenDepositAddress).transferFrom(msg.sender, address(this), amountToStake), \"Insufficient Token Allowance\");\n        \n        \n        require(updateAccount(msg.sender, true, false), \"Error updating account\");\n        \n        uint fee = amountToStake.mul(stakingFeeRate).div(1e4);\n        uint amountAfterFee = amountToStake.sub(fee);\n        require(amountAfterFee <= availablePoolSize, \"No space available\");\n        require(Token(tokenDepositAddress).transfer(owner, fee), \"Could not transfer deposit fee.\");\n        \n        depositedTokens[msg.sender] = depositedTokens[msg.sender].add(amountAfterFee);\n        if(depositedTokens[msg.sender] > maxDepositedTokens[msg.sender]){\n            maxDepositedTokens[msg.sender] = depositedTokens[msg.sender];\n        } \n        availablePoolSize = availablePoolSize.sub(amountAfterFee);\n        totalDeposited = totalDeposited.add(amountAfterFee);\n        \n        if (!holders.contains(msg.sender)) {\n            holders.add(msg.sender);\n            firstTime[msg.sender] = block.timestamp;\n            \n        }\n        \n        // Reset the Progressive Unstaking\n        amountPerInterval[msg.sender] = 0;\n        if(alreadyProgUnstaked[msg.sender] > 0){\n            firstTime[msg.sender] = block.timestamp;\n        } \n        \n        alreadyProgUnstaked[msg.sender] = 0;\n        \n        stakingTime[msg.sender] = block.timestamp;\n        return true;\n    }\n    \n    /*\n    * @dev Max amount withdrawable on basis on time\n    */\n    function getMaxAmountWithdrawable(address _staker) public view returns(uint){\n        uint _res = 0;\n        if(block.timestamp.sub(stakingTime[msg.sender]) < unstakeTime && !ended && alreadyProgUnstaked[_staker] == 0){\n            _res = 0;\n        }else if(alreadyProgUnstaked[_staker] == 0 && !ended){\n            \n            if(block.timestamp.sub(stakingTime[msg.sender]) > unstakeTime){\n                _res = depositedTokens[_staker].div(number_intervals);\n            }\n          \n        }else{\n            uint _time = progressiveTime[_staker];\n            \n            if(block.timestamp < _time.add(duration_interval)){\n                _res = 0;\n            }else{\n               \n                \n                uint _numIntervals = (block.timestamp.sub(_time)).div(duration_interval);\n                \n                if(_numIntervals == 0){\n                    return 0;\n                }\n                if(!ended){\n                    _numIntervals = _numIntervals.add(1);\n                }\n                \n                \n                if(_numIntervals > number_intervals){\n                    _numIntervals = number_intervals;\n                }\n                \n                if(_numIntervals.mul(amountPerInterval[_staker]) > alreadyProgUnstaked[_staker]){\n                    _res = _numIntervals.mul(amountPerInterval[_staker]).sub(alreadyProgUnstaked[_staker]);\n                }else{\n                    _res = 0;\n                }\n            }\n            \n            \n        }\n\n        return _res;\n    }\n    \n    /*\n    * @dev Progressive Unstaking (Second, third, fourth... Progressive withdraws)\n    */\n    function withdraw2(uint amountToWithdraw) public returns (bool){\n        require(holders.contains(msg.sender), \"Not a staker\");\n        require(amountToWithdraw <= getMaxAmountWithdrawable(msg.sender), \"Maximum reached\");\n        require(alreadyProgUnstaked[msg.sender] > 0 || ended, \"Use withdraw first\");\n        \n        alreadyProgUnstaked[msg.sender] = alreadyProgUnstaked[msg.sender].add(amountToWithdraw);\n        \n        uint fee = amountToWithdraw.mul(unstakingFeeRate).div(1e4);\n        uint amountAfterFee = amountToWithdraw.sub(fee);\n        \n        updateAccount(msg.sender, false, true);\n        \n        require(Token(tokenDepositAddress).transfer(owner, fee), \"Could not transfer withdraw fee.\");\n        require(Token(tokenDepositAddress).transfer(msg.sender, amountAfterFee), \"Could not transfer tokens.\");\n        \n        depositedTokens[msg.sender] = depositedTokens[msg.sender].sub(amountToWithdraw);\n        availablePoolSize = availablePoolSize.add(amountToWithdraw);\n        totalDeposited = totalDeposited.sub(amountToWithdraw);\n        \n        if (holders.contains(msg.sender) && depositedTokens[msg.sender] == 0 && getPendingRewards(msg.sender) == 0) {\n            holders.remove(msg.sender);\n            firstTime[msg.sender] = 0;\n        }\n        return true;\n    }\n    \n    /*\n    * @dev Progressive Unstaking (First  withdraw)\n    */\n    function withdraw(uint amountToWithdraw) public returns (bool){\n        require(holders.contains(msg.sender), \"Not a staker\");\n        require(alreadyProgUnstaked[msg.sender] == 0 && !ended , \"Use withdraw2 function\");\n        amountPerInterval[msg.sender] = depositedTokens[msg.sender].div(number_intervals);\n        require(depositedTokens[msg.sender].div(number_intervals) >= amountToWithdraw, \"Invalid amount to withdraw\");\n        alreadyProgUnstaked[msg.sender] = amountToWithdraw;\n        require(block.timestamp.sub(stakingTime[msg.sender]) > unstakeTime || ended, \"You recently staked, please wait before withdrawing.\");\n        \n        \n        \n        updateAccount(msg.sender, false, true);\n        \n        uint fee = amountToWithdraw.mul(unstakingFeeRate).div(1e4);\n        uint amountAfterFee = amountToWithdraw.sub(fee);\n        \n        require(Token(tokenDepositAddress).transfer(owner, fee), \"Could not transfer withdraw fee.\");\n        require(Token(tokenDepositAddress).transfer(msg.sender, amountAfterFee), \"Could not transfer tokens.\");\n        \n        depositedTokens[msg.sender] = depositedTokens[msg.sender].sub(amountToWithdraw);\n        availablePoolSize = availablePoolSize.add(amountToWithdraw);\n        totalDeposited = totalDeposited.sub(amountToWithdraw);\n        \n        progressiveTime[msg.sender] = block.timestamp;\n    \n        return true;\n    }\n    \n    function getTimeToWithdraw(address _staker) public view returns (uint){\n        if(getMaxAmountWithdrawable(_staker) != 0) return 0;\n        \n        uint _res = 0;\n        uint _time = stakingTime[_staker];\n        if(alreadyProgUnstaked[_staker] == 0 && !ended ){\n            \n            if(block.timestamp <= _time.add(unstakeTime)){\n                _res = _time.add(unstakeTime).sub(block.timestamp);\n            }\n            \n        }else{\n            _time = progressiveTime[_staker];\n            \n            for(uint i = 1; i <= number_intervals; i = i.add(1)){\n                if(block.timestamp < _time.add(duration_interval.mul(i))){\n                    _res = _time.add(duration_interval.mul(i)).sub(block.timestamp);\n                    break;\n                }\n            }\n            \n        }\n        return _res;\n    }\n    \n    function getTimeToClaim(address _staker) public view returns (uint){\n        uint _res = 0;\n        \n        if(lastClaimedTime[_staker].add(claimTime) > block.timestamp){\n            _res = lastClaimedTime[_staker].add(claimTime).sub(block.timestamp);\n        }\n        \n        return _res;\n    }\n    \n    function claimDivs() public  returns (bool){\n        require(holders.contains(msg.sender), \"Not a staker\");\n        require(block.timestamp.sub(lastClaimedTime[msg.sender]) > claimTime, \"Not yet\");\n        updateAccount(msg.sender, false, false);\n        return true;\n    }\n    \n    function getStakersList(uint startIndex, uint endIndex) public view returns (address[] memory stakers, uint[] memory stakingTimestamps,  uint[] memory lastClaimedTimeStamps, uint[] memory stakedTokens) {\n        require (startIndex < endIndex);\n        \n        uint length = endIndex.sub(startIndex);\n        address[] memory _stakers = new address[](length);\n        uint[] memory _stakingTimestamps = new uint[](length);\n        uint[] memory _lastClaimedTimeStamps = new uint[](length);\n        uint[] memory _stakedTokens = new uint[](length);\n        \n        for (uint i = startIndex; i < endIndex; i = i.add(1)) {\n            address staker = holders.at(i);\n            uint listIndex = i.sub(startIndex);\n            _stakers[listIndex] = staker;\n            _stakingTimestamps[listIndex] = stakingTime[staker];\n            _lastClaimedTimeStamps[listIndex] = lastClaimedTime[staker];\n            _stakedTokens[listIndex] = depositedTokens[staker];\n        }\n        \n        return (_stakers, _stakingTimestamps, _lastClaimedTimeStamps, _stakedTokens);\n    }\n    \n    /*\n    * @dev function to allow admin to claim *other* ERC20 tokens sent to this contract (by mistake)\n    */\n    function transferAnyERC20Tokens(address _tokenAddr, address _to, uint _amount) public onlyOwner  returns (bool){\n        require (_tokenAddr != tokenDepositAddress, \"Cannot Transfer Out this token\");\n        Token(_tokenAddr).transfer(_to, _amount);\n        return true;\n    }\n    \n    function getClaimableAmount(address account) public view returns (uint){\n        uint pendingDivs = getPendingRewards(account);\n        uint toSend = pendingDivs;\n        \n        if(depositedTokens[account].mul(percent_claim).div(100) < pendingDivs){\n            toSend = depositedTokens[account].mul(percent_claim).div(100);\n        }\n        \n        if (pendingDivs > 0) {\n            if(ended){ // claim o withdraw cuando ha terminado\n                    if(depositedTokens[account] == 0){\n                        \n                        if( maxDepositedTokens[account].mul(percent_claim).div(100) > pendingDivs ){\n                            toSend = pendingDivs;\n                        }else{\n                            toSend = maxDepositedTokens[account].mul(percent_claim).div(100);\n                        }\n                    }\n                \n            }else{\n                if(depositedTokens[account] == 0){\n                        \n                    if( maxDepositedTokens[account].mul(percent_claim).div(100) > pendingDivs ){\n                        toSend = pendingDivs;\n                    }else{\n                        toSend = maxDepositedTokens[account].mul(percent_claim).div(100);\n                    }\n                }\n            }    \n        }\n        return toSend;\n    }\n    \n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Hacken-Bitcoin SB-V2/code/BSB_StakingSmartStakers.sol",
        "vulnerability": "Block Dependency",
        "check": "FP",
        "response": "Answer: No\nReason: The contract does not use the block number for important operations and relies on timestamps which are less predictable."
    },
    {
        "code_segment": "contract BSB_StakingSmartStakers is Ownable {\n    using SafeMath for uint;\n    using EnumerableSet for EnumerableSet.AddressSet;\n    \n    event RewardsTransferred(address holder, uint amount);\n    event RewardsRestaked(address holder, uint amount);\n    \n    /*\n    * @dev Token contract address\n    */\n    address public constant tokenDepositAddress = 0xA478A13242b64629bff309125770B69f75Bd77cb;\n    \n    /*\n    * @dev Reward rate 520.00% per year\n    */\n    uint public rewardRate = 52000;\n    uint public constant rewardInterval = 365 days;\n    \n    /*\n    * @dev Staking fee 1 percent\n    */\n    uint public constant stakingFeeRate = 100;\n    \n    /*\n    * @dev Unstaking fee 0.50 percent\n    */\n    uint public constant unstakingFeeRate = 50;\n    \n    /*\n    * @dev Unstaking possible after 90 days\n    */\n    uint public constant unstakeTime = 90 days;\n    \n    /*\n    * @dev Claiming possible every 10 days\n    */\n    uint public constant claimTime = 10 days;\n    \n    /*\n    * @dev Pool size \n    */\n    uint public constant maxPoolSize = 50000000000000000000000;\n    uint public availablePoolSize = 50000000000000000000000;\n    \n    /*\n    * @dev Total rewards\n    */\n    uint public constant totalRewards = 200000000000000000000000; \n    \n    uint public totalClaimedRewards = 0;\n    uint public totalDeposited = 0; // usar esta variable que no se usa!\n    bool public ended ;\n    \n    EnumerableSet.AddressSet private holders;\n    \n    mapping (address => uint) public depositedTokens;\n    mapping (address => uint) public maxDepositedTokens;\n    mapping (address => uint) public stakingTime; //used for the unstaking locktime\n    mapping (address => uint) public firstTime; //used for the APY boost\n    mapping (address => uint) public lastClaimedTime; //used for the claiming locktime\n    mapping (address => uint) public progressiveTime; //used for the claiming locktime\n    mapping (address => uint) public totalEarnedTokens;\n    \n    mapping (address => uint) public rewardEnded;\n    \n    /*\n    * @dev Progressive Unstaking\n    */\n    mapping (address => uint) public alreadyProgUnstaked; \n    mapping (address => uint) public amountPerInterval;\n    uint public number_intervals = 4;\n    uint public duration_interval = 30 days;\n    \n    /*\n    * @dev Incentive For Not Unstaking\n    */\n    uint extraAPY = 10400; // 2% extra weekly\n    \n    /*\n    * @dev Smart Capped Claiming\n    */\n    uint percent_claim = 2; // 20% of weekly rewards earned\n    mapping (address => uint) public unclaimed;\n    \n    uint public endTime;\n    \n    /* FUNCTIONS */\n    \n    /*\n    * @dev End the staking pool\n    */\n    function end() public onlyOwner returns (bool){\n        require(!ended, \"Staking already ended\");\n        address _aux;\n        // SWC-128-DoS With Block Gas Limit: L393 - L401\n        for(uint i = 0; i < holders.length(); i = i.add(1)){\n            _aux = holders.at(i);\n            rewardEnded[_aux] = getPendingRewards(_aux);\n            unclaimed[_aux] = 0;\n            stakingTime[_aux] = block.timestamp;\n            progressiveTime[_aux] = block.timestamp;\n            alreadyProgUnstaked[_aux] = 0;\n            amountPerInterval[_aux] = depositedTokens[_aux].div(number_intervals);\n        }\n        \n        ended = true;\n        endTime = block.timestamp;\n        return true;\n    }\n    \n    function getRewardsLeft() public view returns (uint){\n       \n        uint _res;\n        if(ended){\n            _res = 0;\n        }else{\n            uint totalPending;\n        // SWC-128-DoS With Block Gas Limit: L416 - L418\n            for(uint i = 0; i < holders.length(); i = i.add(1)){\n                totalPending = totalPending.add(getPendingRewards(holders.at(i)));\n            }\n            if(totalRewards > totalClaimedRewards.add(totalPending)){\n                _res = totalRewards.sub(totalClaimedRewards).sub(totalPending);\n            }else{\n                _res = 0;\n            }\n            \n        }\n        \n        return _res;\n    }\n    \n    function updateAccount(address account, bool _restake, bool _withdraw) private returns (bool){\n        uint pendingDivs = getPendingRewards(account);\n        uint toSend = pendingDivs;\n        \n        if(depositedTokens[account].mul(percent_claim).div(100) < pendingDivs){\n            toSend = depositedTokens[account].mul(percent_claim).div(100);\n        }\n        \n        if (pendingDivs > 0) {\n            if(ended){ // claim o withdraw cuando ha terminado\n                if(!_withdraw){\n                     \n                    if(depositedTokens[account] == 0){\n                        \n                        if( maxDepositedTokens[account].mul(percent_claim).div(100) > pendingDivs ){\n                            toSend = pendingDivs;\n                        }else{\n                            toSend = maxDepositedTokens[account].mul(percent_claim).div(100);\n                        }\n                    }\n                     rewardEnded[account] = rewardEnded[account].sub(toSend);\n                     require(Token(tokenDepositAddress).transfer(account, toSend), \"Could not transfer tokens.\");\n                     totalEarnedTokens[account] = totalEarnedTokens[account].add(toSend);\n                     totalClaimedRewards = totalClaimedRewards.add(toSend);\n                }\n               \n            }else{\n                \n                if(_restake){ // deposit\n                    require(pendingDivs <= availablePoolSize, \"No spot available\");\n                    depositedTokens[account] = depositedTokens[account].add(pendingDivs);\n                    \n                    unclaimed[account] = 0;\n                    \n                    if(depositedTokens[account] > maxDepositedTokens[account]){\n                        maxDepositedTokens[account] = depositedTokens[account];\n                    } \n                    availablePoolSize = availablePoolSize.sub(pendingDivs);\n                    totalDeposited = totalDeposited.add(pendingDivs);\n                    totalEarnedTokens[account] = totalEarnedTokens[account].add(pendingDivs);\n                    totalClaimedRewards = totalClaimedRewards.add(pendingDivs);\n                }else if(_withdraw){ // withdraw\n                    unclaimed[account] = pendingDivs;\n                // claim\n                }else{ // does not have deposited tokens\n                    if(depositedTokens[account] == 0){\n                        \n                        if( maxDepositedTokens[account].mul(percent_claim).div(100) > pendingDivs ){\n                            toSend = pendingDivs;\n                        }else{\n                            toSend = maxDepositedTokens[account].mul(percent_claim).div(100);\n                        }\n                    }\n                    uint toUnclaimed = 0;\n                    uint subUnclaimed = 0;\n                    uint pendingWithoutUnclaimed = getOnlyPendingRewards(account);\n                    if(toSend > pendingWithoutUnclaimed){\n                        subUnclaimed = toSend.sub(pendingWithoutUnclaimed);\n                        toUnclaimed = 0;\n                    }else{\n                        toUnclaimed = pendingWithoutUnclaimed.sub(toSend);\n                        subUnclaimed = 0;\n                    }\n                \n                    unclaimed[account] = unclaimed[account].add(toUnclaimed).sub(subUnclaimed);\n                    require(Token(tokenDepositAddress).transfer(account, toSend), \"Could not transfer tokens.\");\n                    totalEarnedTokens[account] = totalEarnedTokens[account].add(toSend);\n                    totalClaimedRewards = totalClaimedRewards.add(toSend);\n                }\n            }    \n        }\n        lastClaimedTime[account] = block.timestamp;\n        return true;\n    }\n    \n    function getAPY(address _staker) public view returns(uint){\n        uint apy = rewardRate;\n        if(block.timestamp.sub(firstTime[_staker]) > unstakeTime && alreadyProgUnstaked[_staker] == 0 && !ended){\n            apy = apy.add(extraAPY);\n        }\n        return apy;\n    }\n    \n    function getPendingRewards(address _holder) public view returns (uint) { //getPendingRewards\n        if (!holders.contains(_holder)) return 0;\n        if (depositedTokens[_holder] == 0 && unclaimed[_holder] == 0 && !ended) return 0;\n        uint pendingDivs;\n        if(!ended){\n             uint timeDiff = block.timestamp.sub(lastClaimedTime[_holder]);\n             uint stakedAmount = depositedTokens[_holder];\n             \n             // Incentive For Not Unstaking\n             uint apy = getAPY(_holder);\n        \n             pendingDivs = stakedAmount\n                                .mul(apy) \n                                .mul(timeDiff)\n                                .div(rewardInterval)\n                                .div(1e4);\n                                \n             pendingDivs = pendingDivs.add(unclaimed[_holder]);\n            \n        }else{\n            pendingDivs = rewardEnded[_holder];\n        }\n       \n        return pendingDivs;\n    }\n    \n    function getOnlyPendingRewards(address _holder) internal view returns (uint) { // getPendingRewards without \"Unclaimed\"\n        if (!holders.contains(_holder)) return 0;\n        if (depositedTokens[_holder] == 0 || ended) return 0;\n        uint pendingDivs;\n        if(!ended){\n             uint timeDiff = block.timestamp.sub(lastClaimedTime[_holder]);\n             uint stakedAmount = depositedTokens[_holder];\n             \n             // Incentive For Not Unstaking\n             uint apy = getAPY(_holder);\n        \n             pendingDivs = stakedAmount\n                                .mul(apy) \n                                .mul(timeDiff)\n                                .div(rewardInterval)\n                                .div(1e4);\n            \n        }else{\n            pendingDivs = 0;\n        }\n       \n        return pendingDivs;\n    }\n    \n    function getNumberOfHolders() public view returns (uint) {\n        return holders.length();\n    }\n    \n    function deposit(uint amountToStake) public returns (bool){\n        require(!ended, \"Staking has ended\");\n        require(getRewardsLeft() > 0, \"No rewards left\");\n        require(amountToStake > 0, \"Cannot deposit 0 Tokens\");\n       \n        require(Token(tokenDepositAddress).transferFrom(msg.sender, address(this), amountToStake), \"Insufficient Token Allowance\");\n        \n        \n        require(updateAccount(msg.sender, true, false), \"Error updating account\");\n        \n        uint fee = amountToStake.mul(stakingFeeRate).div(1e4);\n        uint amountAfterFee = amountToStake.sub(fee);\n        require(amountAfterFee <= availablePoolSize, \"No space available\");\n        require(Token(tokenDepositAddress).transfer(owner, fee), \"Could not transfer deposit fee.\");\n        \n        depositedTokens[msg.sender] = depositedTokens[msg.sender].add(amountAfterFee);\n        if(depositedTokens[msg.sender] > maxDepositedTokens[msg.sender]){\n            maxDepositedTokens[msg.sender] = depositedTokens[msg.sender];\n        } \n        availablePoolSize = availablePoolSize.sub(amountAfterFee);\n        totalDeposited = totalDeposited.add(amountAfterFee);\n        \n        if (!holders.contains(msg.sender)) {\n            holders.add(msg.sender);\n            firstTime[msg.sender] = block.timestamp;\n            \n        }\n        \n        // Reset the Progressive Unstaking\n        amountPerInterval[msg.sender] = 0;\n        if(alreadyProgUnstaked[msg.sender] > 0){\n            firstTime[msg.sender] = block.timestamp;\n        } \n        \n        alreadyProgUnstaked[msg.sender] = 0;\n        \n        stakingTime[msg.sender] = block.timestamp;\n        return true;\n    }\n    \n    /*\n    * @dev Max amount withdrawable on basis on time\n    */\n    function getMaxAmountWithdrawable(address _staker) public view returns(uint){\n        uint _res = 0;\n        if(block.timestamp.sub(stakingTime[msg.sender]) < unstakeTime && !ended && alreadyProgUnstaked[_staker] == 0){\n            _res = 0;\n        }else if(alreadyProgUnstaked[_staker] == 0 && !ended){\n            \n            if(block.timestamp.sub(stakingTime[msg.sender]) > unstakeTime){\n                _res = depositedTokens[_staker].div(number_intervals);\n            }\n          \n        }else{\n            uint _time = progressiveTime[_staker];\n            \n            if(block.timestamp < _time.add(duration_interval)){\n                _res = 0;\n            }else{\n               \n                \n                uint _numIntervals = (block.timestamp.sub(_time)).div(duration_interval);\n                \n                if(_numIntervals == 0){\n                    return 0;\n                }\n                if(!ended){\n                    _numIntervals = _numIntervals.add(1);\n                }\n                \n                \n                if(_numIntervals > number_intervals){\n                    _numIntervals = number_intervals;\n                }\n                \n                if(_numIntervals.mul(amountPerInterval[_staker]) > alreadyProgUnstaked[_staker]){\n                    _res = _numIntervals.mul(amountPerInterval[_staker]).sub(alreadyProgUnstaked[_staker]);\n                }else{\n                    _res = 0;\n                }\n            }\n            \n            \n        }\n\n        return _res;\n    }\n    \n    /*\n    * @dev Progressive Unstaking (Second, third, fourth... Progressive withdraws)\n    */\n    function withdraw2(uint amountToWithdraw) public returns (bool){\n        require(holders.contains(msg.sender), \"Not a staker\");\n        require(amountToWithdraw <= getMaxAmountWithdrawable(msg.sender), \"Maximum reached\");\n        require(alreadyProgUnstaked[msg.sender] > 0 || ended, \"Use withdraw first\");\n        \n        alreadyProgUnstaked[msg.sender] = alreadyProgUnstaked[msg.sender].add(amountToWithdraw);\n        \n        uint fee = amountToWithdraw.mul(unstakingFeeRate).div(1e4);\n        uint amountAfterFee = amountToWithdraw.sub(fee);\n        \n        updateAccount(msg.sender, false, true);\n        \n        require(Token(tokenDepositAddress).transfer(owner, fee), \"Could not transfer withdraw fee.\");\n        require(Token(tokenDepositAddress).transfer(msg.sender, amountAfterFee), \"Could not transfer tokens.\");\n        \n        depositedTokens[msg.sender] = depositedTokens[msg.sender].sub(amountToWithdraw);\n        availablePoolSize = availablePoolSize.add(amountToWithdraw);\n        totalDeposited = totalDeposited.sub(amountToWithdraw);\n        \n        if (holders.contains(msg.sender) && depositedTokens[msg.sender] == 0 && getPendingRewards(msg.sender) == 0) {\n            holders.remove(msg.sender);\n            firstTime[msg.sender] = 0;\n        }\n        return true;\n    }\n    \n    /*\n    * @dev Progressive Unstaking (First  withdraw)\n    */\n    function withdraw(uint amountToWithdraw) public returns (bool){\n        require(holders.contains(msg.sender), \"Not a staker\");\n        require(alreadyProgUnstaked[msg.sender] == 0 && !ended , \"Use withdraw2 function\");\n        amountPerInterval[msg.sender] = depositedTokens[msg.sender].div(number_intervals);\n        require(depositedTokens[msg.sender].div(number_intervals) >= amountToWithdraw, \"Invalid amount to withdraw\");\n        alreadyProgUnstaked[msg.sender] = amountToWithdraw;\n        require(block.timestamp.sub(stakingTime[msg.sender]) > unstakeTime || ended, \"You recently staked, please wait before withdrawing.\");\n        \n        \n        \n        updateAccount(msg.sender, false, true);\n        \n        uint fee = amountToWithdraw.mul(unstakingFeeRate).div(1e4);\n        uint amountAfterFee = amountToWithdraw.sub(fee);\n        \n        require(Token(tokenDepositAddress).transfer(owner, fee), \"Could not transfer withdraw fee.\");\n        require(Token(tokenDepositAddress).transfer(msg.sender, amountAfterFee), \"Could not transfer tokens.\");\n        \n        depositedTokens[msg.sender] = depositedTokens[msg.sender].sub(amountToWithdraw);\n        availablePoolSize = availablePoolSize.add(amountToWithdraw);\n        totalDeposited = totalDeposited.sub(amountToWithdraw);\n        \n        progressiveTime[msg.sender] = block.timestamp;\n    \n        return true;\n    }\n    \n    function getTimeToWithdraw(address _staker) public view returns (uint){\n        if(getMaxAmountWithdrawable(_staker) != 0) return 0;\n        \n        uint _res = 0;\n        uint _time = stakingTime[_staker];\n        if(alreadyProgUnstaked[_staker] == 0 && !ended ){\n            \n            if(block.timestamp <= _time.add(unstakeTime)){\n                _res = _time.add(unstakeTime).sub(block.timestamp);\n            }\n            \n        }else{\n            _time = progressiveTime[_staker];\n            \n            for(uint i = 1; i <= number_intervals; i = i.add(1)){\n                if(block.timestamp < _time.add(duration_interval.mul(i))){\n                    _res = _time.add(duration_interval.mul(i)).sub(block.timestamp);\n                    break;\n                }\n            }\n            \n        }\n        return _res;\n    }\n    \n    function getTimeToClaim(address _staker) public view returns (uint){\n        uint _res = 0;\n        \n        if(lastClaimedTime[_staker].add(claimTime) > block.timestamp){\n            _res = lastClaimedTime[_staker].add(claimTime).sub(block.timestamp);\n        }\n        \n        return _res;\n    }\n    \n    function claimDivs() public  returns (bool){\n        require(holders.contains(msg.sender), \"Not a staker\");\n        require(block.timestamp.sub(lastClaimedTime[msg.sender]) > claimTime, \"Not yet\");\n        updateAccount(msg.sender, false, false);\n        return true;\n    }\n    \n    function getStakersList(uint startIndex, uint endIndex) public view returns (address[] memory stakers, uint[] memory stakingTimestamps,  uint[] memory lastClaimedTimeStamps, uint[] memory stakedTokens) {\n        require (startIndex < endIndex);\n        \n        uint length = endIndex.sub(startIndex);\n        address[] memory _stakers = new address[](length);\n        uint[] memory _stakingTimestamps = new uint[](length);\n        uint[] memory _lastClaimedTimeStamps = new uint[](length);\n        uint[] memory _stakedTokens = new uint[](length);\n        \n        for (uint i = startIndex; i < endIndex; i = i.add(1)) {\n            address staker = holders.at(i);\n            uint listIndex = i.sub(startIndex);\n            _stakers[listIndex] = staker;\n            _stakingTimestamps[listIndex] = stakingTime[staker];\n            _lastClaimedTimeStamps[listIndex] = lastClaimedTime[staker];\n            _stakedTokens[listIndex] = depositedTokens[staker];\n        }\n        \n        return (_stakers, _stakingTimestamps, _lastClaimedTimeStamps, _stakedTokens);\n    }\n    \n    /*\n    * @dev function to allow admin to claim *other* ERC20 tokens sent to this contract (by mistake)\n    */\n    function transferAnyERC20Tokens(address _tokenAddr, address _to, uint _amount) public onlyOwner  returns (bool){\n        require (_tokenAddr != tokenDepositAddress, \"Cannot Transfer Out this token\");\n        Token(_tokenAddr).transfer(_to, _amount);\n        return true;\n    }\n    \n    function getClaimableAmount(address account) public view returns (uint){\n        uint pendingDivs = getPendingRewards(account);\n        uint toSend = pendingDivs;\n        \n        if(depositedTokens[account].mul(percent_claim).div(100) < pendingDivs){\n            toSend = depositedTokens[account].mul(percent_claim).div(100);\n        }\n        \n        if (pendingDivs > 0) {\n            if(ended){ // claim o withdraw cuando ha terminado\n                    if(depositedTokens[account] == 0){\n                        \n                        if( maxDepositedTokens[account].mul(percent_claim).div(100) > pendingDivs ){\n                            toSend = pendingDivs;\n                        }else{\n                            toSend = maxDepositedTokens[account].mul(percent_claim).div(100);\n                        }\n                    }\n                \n            }else{\n                if(depositedTokens[account] == 0){\n                        \n                    if( maxDepositedTokens[account].mul(percent_claim).div(100) > pendingDivs ){\n                        toSend = pendingDivs;\n                    }else{\n                        toSend = maxDepositedTokens[account].mul(percent_claim).div(100);\n                    }\n                }\n            }    \n        }\n        return toSend;\n    }\n    \n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Hacken-Bitcoin SB-V2/code/BSB_StakingSmartStakers.sol",
        "vulnerability": "Block Dependency",
        "check": "FP",
        "response": "Answer: No\nReason: The contract does not exhibit block dependency issues such as predicting outcomes or rewards based on block data like blockhash or block.timestamp in a way that would compromise fairness or security. The use of block.timestamp is appropriate for time-based logic in this context."
    },
    {
        "code_segment": "contract HoldefiSettings is HoldefiOwnable {\n\n\tusing SafeMath for uint256;\n\n\t\n\tstruct MarketSettings {\n\t\tbool isExist;\t\t// Market is exist or not\n\t\tbool isActive;\t\t// Market is open for deposit or not\n\n\t\tuint256 borrowRate;\n\t\tuint256 borrowRateUpdateTime;\n\n\t\tuint256 suppliersShareRate;\n\t\tuint256 suppliersShareRateUpdateTime;\n\n\t\tuint256 promotionRate;\n\t}\n\n\t\n\tstruct CollateralSettings {\n\t\tbool isExist;\t\t// Collateral is exist or not\n\t\tbool isActive;\t\t// Collateral is open for deposit or not\n\n\t\tuint256 valueToLoanRate;\n\t\tuint256 VTLUpdateTime;\n\n\t\tuint256 penaltyRate;\n\t\tuint256 penaltyUpdateTime;\n\n\t\tuint256 bonusRate;\n\t}\n\n\tuint256 constant public rateDecimals = 10 ** 4;\n\n\taddress constant public ethAddress = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n\tuint256 constant public periodBetweenUpdates = 864000;      \t// seconds per ten days\n\n\tuint256 constant public maxBorrowRate = 4000;      \t\t\t\t// 40%\n\n\tuint256 constant public borrowRateMaxIncrease = 500;      \t\t// 5%\n\n\tuint256 constant public minSuppliersShareRate = 5000;      \t\t// 50%\n\n\tuint256 constant public suppliersShareRateMaxDecrease = 500;\t// 5%\n\n\tuint256 constant public maxValueToLoanRate = 20000;      \t\t// 200%\n\n\tuint256 constant public valueToLoanRateMaxIncrease = 500;      \t// 5%\n\n\tuint256 constant public maxPenaltyRate = 13000;      \t\t\t// 130%\n\n\tuint256 constant public penaltyRateMaxIncrease = 500;      \t\t// 5%\n\n\tuint256 constant public maxPromotionRate = 3000;\t\t\t\t// 30%\n\n\tuint256 constant public maxListsLength = 25;\n\n\t\n\t\n\tuint256 constant private fivePercentLiquidationGap = 500;\n\n\tmapping (address => MarketSettings) public marketAssets;\n\taddress[] public marketsList;\n\n\tmapping (address => CollateralSettings) public collateralAssets;\n\n\tHoldefiInterface public holdefiContract;\n\n\t\n\tevent MarketActivationChanged(address indexed market, bool status);\n\n\t\n\tevent CollateralActivationChanged(address indexed collateral, bool status);\n\n\t\n\tevent MarketExistenceChanged(address indexed market, bool status);\n\n\t\n\tevent CollateralExistenceChanged(address indexed collateral, bool status);\n\n\t\n\tevent BorrowRateChanged(address indexed market, uint256 newRate, uint256 oldRate);\n\n\t\n\tevent SuppliersShareRateChanged(address indexed market, uint256 newRate, uint256 oldRate);\n\n\t\n\tevent PromotionRateChanged(address indexed market, uint256 newRate, uint256 oldRate);\n\n\t\n\tevent ValueToLoanRateChanged(address indexed collateral, uint256 newRate, uint256 oldRate);\n\n\t\n\tevent PenaltyRateChanged(address indexed collateral, uint256 newRate, uint256 oldRate);\n\n\t\n\tevent BonusRateChanged(address indexed collateral, uint256 newRate, uint256 oldRate);\n\n\n\n\t\n\t\n    modifier marketIsExist(address market) {\n        require (marketAssets[market].isExist, \"The market is not exist\");\n        _;\n    }\n\n\t\n\t\n    modifier collateralIsExist(address collateral) {\n        require (collateralAssets[collateral].isExist, \"The collateral is not exist\");\n        _;\n    }\n\n\n\t\n    receive() external payable {\n        revert();\n    }\n\n \t\n\t\n\t\n\tfunction activateMarket (address market) public onlyOwner marketIsExist(market) {\n\t\tactivateMarketInternal(market);\n\t}\n\n\t\n\t\n\t\n\tfunction deactivateMarket (address market) public onlyOwner marketIsExist(market) {\n\t\tmarketAssets[market].isActive = false;\n\t\temit MarketActivationChanged(market, false);\n\t}\n\n\t\n\t\n\t\n\tfunction activateCollateral (address collateral) public onlyOwner collateralIsExist(collateral) {\n\t\tactivateCollateralInternal(collateral);\n\t}\n\n\t\n\t\n\t\n\tfunction deactivateCollateral (address collateral) public onlyOwner collateralIsExist(collateral) {\n\t\tcollateralAssets[collateral].isActive = false;\n\t\temit CollateralActivationChanged(collateral, false);\n\t}\n\n\t\n\t\n\tfunction getMarketsList() external view returns (address[] memory res){\n\t\tres = marketsList;\n\t}\n\n\t\n\t\n\t\n\tfunction setHoldefiContract(HoldefiInterface holdefiContractAddress) external onlyOwner {\n\t\trequire (holdefiContractAddress.holdefiSettings() == address(this),\n\t\t\t\"Conflict with Holdefi contract address\"\n\t\t);\n\t\trequire (address(holdefiContract) == address(0), \"Should be set once\");\n\t\tholdefiContract = holdefiContractAddress;\n\t}\n\n\t\n\t\n\t\n\t\n\t\n\t\n\tfunction getInterests (address market)\n\t\texternal\n\t\tview\n\t\treturns (uint256 borrowRate, uint256 supplyRateBase, uint256 promotionRate)\n\t{\n\t\tuint256 totalBorrow = holdefiContract.marketAssets(market).totalBorrow;\n\t\tuint256 totalSupply = holdefiContract.marketAssets(market).totalSupply;\n\t\tborrowRate = marketAssets[market].borrowRate;\n\n\t\tif (totalSupply == 0) {\n\t\t\tsupplyRateBase = 0;\n\t\t}\n\t\telse {\n\t\t\tuint256 totalInterestFromBorrow = totalBorrow.mul(borrowRate);\n\t\t\tuint256 suppliersShare = totalInterestFromBorrow.mul(marketAssets[market].suppliersShareRate);\n\t\t\tsuppliersShare = suppliersShare.div(rateDecimals);\n\t\t\tsupplyRateBase = suppliersShare.div(totalSupply);\n\t\t}\n\t\tpromotionRate = marketAssets[market].promotionRate;\n\t}\n\n\n\t\n\t\n\t\n\t\n\tfunction setPromotionRate (address market, uint256 newPromotionRate) external onlyOwner {\n\t\trequire (newPromotionRate <= maxPromotionRate, \"Rate should be in allowed range\");\n\n\t\tholdefiContract.beforeChangeSupplyRate(market);\n\t\tholdefiContract.reserveSettlement(market);\n\n\t\temit PromotionRateChanged(market, newPromotionRate, marketAssets[market].promotionRate);\n\t\tmarketAssets[market].promotionRate = newPromotionRate;\n\t}\n\n\t\n\t\n\t\n\tfunction resetPromotionRate (address market) external {\n\t\trequire (msg.sender == address(holdefiContract), \"Sender is not Holdefi contract\");\n\n\t\temit PromotionRateChanged(market, 0, marketAssets[market].promotionRate);\n\t\tmarketAssets[market].promotionRate = 0;\n\t}\n\n\t\n\t\n\t\n\t\n\tfunction setBorrowRate (address market, uint256 newBorrowRate)\n\t\texternal \n\t\tonlyOwner\n\t\tmarketIsExist(market)\n\t{\n\t\tsetBorrowRateInternal(market, newBorrowRate);\n\t}\n\n\t\n\t\n\t\n\t\n\tfunction setSuppliersShareRate (address market, uint256 newSuppliersShareRate)\n\t\texternal\n\t\tonlyOwner\n\t\tmarketIsExist(market)\n\t{\n\t\tsetSuppliersShareRateInternal(market, newSuppliersShareRate);\n\t}\n\n\t\n\t\n\t\n\t\n\tfunction setValueToLoanRate (address collateral, uint256 newValueToLoanRate)\n\t\texternal\n\t\tonlyOwner\n\t\tcollateralIsExist(collateral)\n\t{\n\t\tsetValueToLoanRateInternal(collateral, newValueToLoanRate);\n\t}\n\n\t\n\t\n\t\n\t\n\tfunction setPenaltyRate (address collateral, uint256 newPenaltyRate)\n\t\texternal\n\t\tonlyOwner\n\t\tcollateralIsExist(collateral)\n\t{\n\t\tsetPenaltyRateInternal(collateral, newPenaltyRate);\n\t}\n\n\t\n\t\n\t\n\t\n\tfunction setBonusRate (address collateral, uint256 newBonusRate)\n\t\texternal\n\t\tonlyOwner\n\t\tcollateralIsExist(collateral)\n\t{\n\t\tsetBonusRateInternal(collateral, newBonusRate); \n\t}\n\n\t\n\t\n\t\n\t\n\t\n\t//SWC-135-Code With No Effects: L322-L341\n\tfunction addMarket (address market, uint256 borrowRate, uint256 suppliersShareRate)\n\t\texternal\n\t\tonlyOwner\n\t{\n\t\trequire (!marketAssets[market].isExist, \"The market is exist\");\n\t\trequire (marketsList.length < maxListsLength, \"Market list is full\");\n\n\t\tif (market != ethAddress) {\n\t\t\tIERC20(market);\n\t\t}\n\n\t\tmarketsList.push(market);\n\t\tmarketAssets[market].isExist = true;\n\t\temit MarketExistenceChanged(market, true);\n\n\t\tsetBorrowRateInternal(market, borrowRate);\n\t\tsetSuppliersShareRateInternal(market, suppliersShareRate);\n\t\t\n\t\tactivateMarketInternal(market);\t\t\n\t}\n\n\t\n\t\n\t\n\tfunction removeMarket (address market) external onlyOwner marketIsExist(market) {\n\t\tuint256 totalBorrow = holdefiContract.marketAssets(market).totalBorrow;\n\t\trequire (totalBorrow == 0, \"Total borrow is not zero\");\n\t\t\n\t\tholdefiContract.beforeChangeBorrowRate(market);\n\n\t\tuint256 i;\n\t\tuint256 index;\n\t\tuint256 marketListLength = marketsList.length;\n\t\tfor (i = 0 ; i < marketListLength ; i++) {\n\t\t\tif (marketsList[i] == market) {\n\t\t\t\tindex = i;\n\t\t\t}\n\t\t}\n\n\t\tif (index != marketListLength-1) {\n\t\t\tfor (i = index ; i < marketListLength-1 ; i++) {\n\t\t\t\tmarketsList[i] = marketsList[i+1];\n\t\t\t}\n\t\t}\n\n\t\tmarketsList.pop();\n\t\tdelete marketAssets[market];\n\t\temit MarketExistenceChanged(market, false);\n\t}\n\n\t\n\t\n\t\n\t\n\t\n\t\n\tfunction addCollateral (\n\t\taddress collateral,\n\t\tuint256 valueToLoanRate,\n\t\tuint256 penaltyRate,\n\t\tuint256 bonusRate\n\t)\n\t\texternal\n\t\tonlyOwner\n\t{\n\t\trequire (!collateralAssets[collateral].isExist, \"The collateral is exist\");\n\n\t\tif (collateral != ethAddress) {\n\t\t\tIERC20(collateral);\n\t\t}\n\n\t\tcollateralAssets[collateral].isExist = true;\n\t\temit CollateralExistenceChanged(collateral, true);\n\n\t\tsetValueToLoanRateInternal(collateral, valueToLoanRate);\n\t\tsetPenaltyRateInternal(collateral, penaltyRate);\n\t\tsetBonusRateInternal(collateral, bonusRate);\n\n\t\tactivateCollateralInternal(collateral);\n\t}\n\n\t\n\tfunction activateMarketInternal (address market) internal {\n\t\tmarketAssets[market].isActive = true;\n\t\temit MarketActivationChanged(market, true);\n\t}\n\n\t\n\tfunction activateCollateralInternal (address collateral) internal {\n\t\tcollateralAssets[collateral].isActive = true;\n\t\temit CollateralActivationChanged(collateral, true);\n\t}\n\n\t\n\tfunction setBorrowRateInternal (address market, uint256 newBorrowRate) internal {\n\t\trequire (newBorrowRate <= maxBorrowRate, \"Rate should be less than max\");\n\t\tuint256 currentTime = block.timestamp;\n\n\t\tif (marketAssets[market].borrowRateUpdateTime != 0) {\n\t\t\tif (newBorrowRate > marketAssets[market].borrowRate) {\n\t\t\t\tuint256 deltaTime = currentTime.sub(marketAssets[market].borrowRateUpdateTime);\n\t\t\t\trequire (deltaTime >= periodBetweenUpdates, \"Increasing rate is not allowed at this time\");\n\n\t\t\t\tuint256 maxIncrease = marketAssets[market].borrowRate.add(borrowRateMaxIncrease);\n\t\t\t\trequire (newBorrowRate <= maxIncrease, \"Rate should be increased less than max allowed\");\n\t\t\t}\n\n\t\t\tholdefiContract.beforeChangeBorrowRate(market);\n\t\t}\n\n\t\temit BorrowRateChanged(market, newBorrowRate, marketAssets[market].borrowRate);\n\n\t\tmarketAssets[market].borrowRate = newBorrowRate;\n\t\tmarketAssets[market].borrowRateUpdateTime = currentTime;\n\t}\n\n\t\n\tfunction setSuppliersShareRateInternal (address market, uint256 newSuppliersShareRate) internal {\n\t\trequire (\n\t\t\tnewSuppliersShareRate >= minSuppliersShareRate && newSuppliersShareRate <= rateDecimals,\n\t\t\t\"Rate should be in allowed range\"\n\t\t);\n\t\tuint256 currentTime = block.timestamp;\n\n\t\tif (marketAssets[market].suppliersShareRateUpdateTime != 0) {\n\t\t\tif (newSuppliersShareRate < marketAssets[market].suppliersShareRate) {\n\t\t\t\tuint256 deltaTime = currentTime.sub(marketAssets[market].suppliersShareRateUpdateTime);\n\t\t\t\trequire (deltaTime >= periodBetweenUpdates, \"Decreasing rate is not allowed at this time\");\n\n\t\t\t\tuint256 decreasedAllowed = newSuppliersShareRate.add(suppliersShareRateMaxDecrease);\n\t\t\t\trequire (\n\t\t\t\t\tmarketAssets[market].suppliersShareRate <= decreasedAllowed,\n\t\t\t\t\t\"Rate should be decreased less than max allowed\"\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tholdefiContract.beforeChangeSupplyRate(market);\n\t\t}\n\n\t\temit SuppliersShareRateChanged(\n\t\t\tmarket,\n\t\t\tnewSuppliersShareRate,\n\t\t\tmarketAssets[market].suppliersShareRate\n\t\t);\n\n\t\tmarketAssets[market].suppliersShareRate = newSuppliersShareRate;\n\t\tmarketAssets[market].suppliersShareRateUpdateTime = currentTime;\n\t}\n\n\t\n\tfunction setValueToLoanRateInternal (address collateral, uint256 newValueToLoanRate) internal {\n\t\trequire (\n\t\t\tnewValueToLoanRate <= maxValueToLoanRate &&\n\t\t\tcollateralAssets[collateral].penaltyRate.add(fivePercentLiquidationGap) <= newValueToLoanRate,\n\t\t\t\"Rate should be in allowed range\"\n\t\t);\n\t\t\n\t\tuint256 currentTime = block.timestamp;\n\t\tif (\n\t\t\tcollateralAssets[collateral].VTLUpdateTime != 0 &&\n\t\t\tnewValueToLoanRate > collateralAssets[collateral].valueToLoanRate\n\t\t) {\n\t\t\tuint256 deltaTime = currentTime.sub(collateralAssets[collateral].VTLUpdateTime);\n\t\t\trequire (deltaTime >= periodBetweenUpdates,\"Increasing rate is not allowed at this time\");\n\t\t\tuint256 maxIncrease = collateralAssets[collateral].valueToLoanRate.add(\n\t\t\t\tvalueToLoanRateMaxIncrease\n\t\t\t);\n\t\t\trequire (newValueToLoanRate <= maxIncrease,\"Rate should be increased less than max allowed\");\n\t\t}\n\t\temit ValueToLoanRateChanged(\n\t\t\tcollateral,\n\t\t\tnewValueToLoanRate,\n\t\t\tcollateralAssets[collateral].valueToLoanRate\n\t\t);\n\n\t    collateralAssets[collateral].valueToLoanRate = newValueToLoanRate;\n\t    collateralAssets[collateral].VTLUpdateTime = currentTime;\n\t}\n\n\t\n\tfunction setPenaltyRateInternal (address collateral, uint256 newPenaltyRate) internal {\n\t\trequire (\n\t\t\tnewPenaltyRate <= maxPenaltyRate &&\n\t\t\tnewPenaltyRate <= collateralAssets[collateral].valueToLoanRate.sub(fivePercentLiquidationGap) &&\n\t\t\tcollateralAssets[collateral].bonusRate <= newPenaltyRate,\n\t\t\t\"Rate should be in allowed range\"\n\t\t);\n\n\t\tuint256 currentTime = block.timestamp;\n\t\tif (\n\t\t\tcollateralAssets[collateral].penaltyUpdateTime != 0 &&\n\t\t\tnewPenaltyRate > collateralAssets[collateral].penaltyRate\n\t\t) {\n\t\t\tuint256 deltaTime = currentTime.sub(collateralAssets[collateral].penaltyUpdateTime);\n\t\t\trequire (deltaTime >= periodBetweenUpdates, \"Increasing rate is not allowed at this time\");\n\t\t\tuint256 maxIncrease = collateralAssets[collateral].penaltyRate.add(penaltyRateMaxIncrease);\n\t\t\trequire (newPenaltyRate <= maxIncrease, \"Rate should be increased less than max allowed\");\n\t\t}\n\n\t\temit PenaltyRateChanged(collateral, newPenaltyRate, collateralAssets[collateral].penaltyRate);\n\n\t    collateralAssets[collateral].penaltyRate  = newPenaltyRate;\n\t    collateralAssets[collateral].penaltyUpdateTime = currentTime;\n\t}\n\n\t\n\tfunction setBonusRateInternal (address collateral, uint256 newBonusRate) internal {\n\t\trequire (\n\t\t\tnewBonusRate <= collateralAssets[collateral].penaltyRate && newBonusRate >= rateDecimals,\n\t\t\t\"Rate should be in allowed range\"\n\t\t);\n\t\t\n\t\temit BonusRateChanged(collateral, newBonusRate, collateralAssets[collateral].bonusRate);\n\t    collateralAssets[collateral].bonusRate = newBonusRate;    \n\t}\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/PeckShield-Holdefi/Holdefi-5a1e6e0d582120142e8a531f6806eba6665ef2f4/contracts/HoldefiSettings.sol",
        "vulnerability": "Assertion Failure",
        "check": "FP",
        "response": "Answer: No  \nReason: There are no `assert` statements present in the code, and all conditions using `require` are well-defined with clear error messages."
    },
    {
        "code_segment": "contract StakingPool is Owned {\n    using SafeMath for uint256;\n    \n    Ierc20 public tswap;\n    Ierc20 public rewardToken;\n    uint256 poolDuration;\n    uint256 totalRewards;\n    uint256 rewardsWithdrawn;\n    uint256 poolStartTime;\n    uint256 poolEndTime;\n    uint256 totalStaked;\n    // Represents a single stake for a user. A user may have multiple.\n    struct Stake {\n        uint256 amount;\n        uint256 stakingTime;\n        uint256 lastWithdrawTime;\n    }\n    mapping (address => Stake[]) public userStaking;\n    \n    // Represents total staking of an user\n    struct UserTotals {\n        uint256 totalStaking;\n        uint256 totalStakingTIme;\n    }\n    mapping (address => UserTotals) public userTotalStaking;\n    \n    struct Ris3Rewards {\n        uint256 totalWithdrawn;\n        uint256 lastWithdrawTime;\n    }\n    mapping(address => Ris3Rewards) public userRewardInfo;\n    \n    event OwnerSetReward(uint256 amount);\n    event Staked(address userAddress, uint256 amount);\n    event StakingWithdrawal(address userAddress, uint256 amount);\n    event RewardWithdrawal(address userAddress, uint256 amount);\n    event PoolDurationChange(uint256 poolDuration);\n    \n    /**\n     * Constrctor function\n    */\n    constructor() public {\n        tswap = Ierc20(0xf823eA01D48F7Fb36b4b319f21dae404Ac86Bb8d);\n        rewardToken = Ierc20(0xdE55ea8232e0B1615d762eFCB17Cb2D7df164727);\n        poolDuration = 1 hours;\n    }\n    \n    //Set pool rewards\n    function ownerSetPoolRewards(uint256 _rewardAmount) external onlyOwner {\n        require(poolStartTime == 0, \"Pool rewards already set\");\n        require(_rewardAmount > 0, \"Cannot create pool with zero amount\");\n        \n        //set total rewards value\n        totalRewards = _rewardAmount;\n        \n        poolStartTime = now;\n        poolEndTime = now + poolDuration;\n        \n        //transfer tokens to contract\n        // SWC-104-Unchecked Call Return Value: L132\n        rewardToken.transferFrom(msg.sender, this, _rewardAmount);\n        emit OwnerSetReward(_rewardAmount);\n    }\n    \n    //Stake function for users to stake SWAP token\n    function stake(uint256 amount) external {\n        require(amount > 0, \"Cannot stake 0\");\n        require(now < poolEndTime, \"Staking pool is closed\"); //staking pool is closed for staking\n        \n        //add value in staking\n        userTotalStaking[msg.sender].totalStaking = userTotalStaking[msg.sender].totalStaking.add(amount);\n        \n        //add new stake\n        Stake memory newStake = Stake(amount, now, 0);\n        userStaking[msg.sender].push(newStake);\n        \n        //add to total staked\n        totalStaked = totalStaked.add(amount);\n        \n        tswap.transferFrom(msg.sender, this, amount);\n        emit Staked(msg.sender, amount);\n    }\n    \n    //compute rewards\n    function computeNewReward(uint256 _rewardAmount, uint256 _stakedAmount, uint256 _stakeTimeSec) private view returns (uint256 _reward) {\n        uint256 rewardPerSecond = totalRewards.mul(1 ether);\n        if (rewardPerSecond != 0 ) {\n            rewardPerSecond = rewardPerSecond.div(poolDuration);\n        }\n        \n        if (rewardPerSecond > 0) {\n            uint256 rewardPerSecForEachTokenStaked = rewardPerSecond.div(totalStaked);\n            uint256 userRewards = rewardPerSecForEachTokenStaked.mul(_stakedAmount).mul(_stakeTimeSec);\n                    userRewards = userRewards.div(1 ether);\n            \n            return _rewardAmount.add(userRewards);\n        } else {\n            return 0;\n        }\n    }\n    \n    //calculate your rewards\n    function calculateReward(address _userAddress) public view returns (uint256 _reward) {\n        // all user stakes\n        Stake[] storage accountStakes = userStaking[_userAddress];\n        \n        // Redeem from most recent stake and go backwards in time.\n        uint256 rewardAmount = 0;\n        uint256 i = accountStakes.length;\n        while (i > 0) {\n            Stake storage userStake = accountStakes[i - 1];\n            uint256 stakeTimeSec;\n            \n            //check if current time is more than pool ending time\n            if (now > poolEndTime) {\n                stakeTimeSec = poolEndTime.sub(userStake.stakingTime);\n                if(userStake.lastWithdrawTime != 0){\n                    stakeTimeSec = poolEndTime.sub(userStake.lastWithdrawTime);\n                }\n            } else {\n                stakeTimeSec = now.sub(userStake.stakingTime);\n                if(userStake.lastWithdrawTime != 0){\n                    stakeTimeSec = now.sub(userStake.lastWithdrawTime);\n                }\n            }\n            \n            // fully redeem a past stake\n            rewardAmount = computeNewReward(rewardAmount, userStake.amount, stakeTimeSec);\n            i--;\n        }\n        \n        return rewardAmount;\n    }\n    \n    //Withdraw staking and rewards\n    function withdrawStaking(uint256 amount) external {\n        require(amount > 0, \"Amount can not be zero\");\n        require(userTotalStaking[msg.sender].totalStaking >= amount, \"You are trying to withdaw more than your stake\");\n        \n        // 1. User Accounting\n        Stake[] storage accountStakes = userStaking[msg.sender];\n        \n        // Redeem from most recent stake and go backwards in time.\n        uint256 sharesLeftToBurn = amount;\n        uint256 rewardAmount = 0;\n        while (sharesLeftToBurn > 0) {\n            Stake storage lastStake = accountStakes[accountStakes.length - 1];\n            uint256 stakeTimeSec;\n            //check if current time is more than pool ending time\n            if (now > poolEndTime) {\n                stakeTimeSec = poolEndTime.sub(lastStake.stakingTime);\n                if(lastStake.lastWithdrawTime != 0){\n                    stakeTimeSec = poolEndTime.sub(lastStake.lastWithdrawTime);\n                }\n            } else {\n                stakeTimeSec = now.sub(lastStake.stakingTime);\n                if(lastStake.lastWithdrawTime != 0){\n                    stakeTimeSec = now.sub(lastStake.lastWithdrawTime);\n                }\n            }\n            \n            if (lastStake.amount <= sharesLeftToBurn) {\n                // fully redeem a past stake\n                rewardAmount = computeNewReward(rewardAmount, lastStake.amount, stakeTimeSec);\n                sharesLeftToBurn = sharesLeftToBurn.sub(lastStake.amount);\n                accountStakes.length--;\n            } else {\n                // partially redeem a past stake\n                rewardAmount = computeNewReward(rewardAmount, sharesLeftToBurn, stakeTimeSec);\n                lastStake.amount = lastStake.amount.sub(sharesLeftToBurn);\n                lastStake.lastWithdrawTime = now;\n                sharesLeftToBurn = 0;\n            }\n        }\n        \n        //substract value in staking\n        userTotalStaking[msg.sender].totalStaking = userTotalStaking[msg.sender].totalStaking.sub(amount);\n        \n        //substract from total staked\n        totalStaked = totalStaked.sub(amount);\n        \n        //update user rewards info\n        userRewardInfo[msg.sender].totalWithdrawn = userRewardInfo[msg.sender].totalWithdrawn.add(rewardAmount);\n        userRewardInfo[msg.sender].lastWithdrawTime = now;\n        \n        //update total rewards withdrawn\n        rewardsWithdrawn = rewardsWithdrawn.add(rewardAmount);\n        \n        //transfer rewards and tokens\n        // SWC-104-Unchecked Call Return Value: L262\n        rewardToken.transfer(msg.sender, rewardAmount);\n        tswap.transfer(msg.sender, amount);\n        \n        emit RewardWithdrawal(msg.sender, rewardAmount);\n        emit StakingWithdrawal(msg.sender, amount);\n    }\n    \n    //Withdraw rewards\n    function withdrawRewardsOnly() external {\n        uint256 _rwdAmount = calculateReward(msg.sender);\n        require(_rwdAmount > 0, \"You do not have enough rewards\");\n        \n        // 1. User Accounting\n        Stake[] storage accountStakes = userStaking[msg.sender];\n        \n        // Redeem from most recent stake and go backwards in time.\n        uint256 rewardAmount = 0;\n        uint256 i = accountStakes.length;\n        while (i > 0) {\n            Stake storage userStake = accountStakes[i - 1];\n            uint256 stakeTimeSec;\n            \n            //check if current time is more than pool ending time\n            if (now > poolEndTime) {\n                stakeTimeSec = poolEndTime.sub(userStake.stakingTime);\n                if(userStake.lastWithdrawTime != 0){\n                    stakeTimeSec = poolEndTime.sub(userStake.lastWithdrawTime);\n                }\n            } else {\n                stakeTimeSec = now.sub(userStake.stakingTime);\n                if(userStake.lastWithdrawTime != 0){\n                    stakeTimeSec = now.sub(userStake.lastWithdrawTime);\n                }\n            }\n            \n            // fully redeem a past stake\n            rewardAmount = computeNewReward(rewardAmount, userStake.amount, stakeTimeSec);\n            userStake.lastWithdrawTime = now;\n            i--;\n        }\n        \n        //update user rewards info\n        userRewardInfo[msg.sender].totalWithdrawn = userRewardInfo[msg.sender].totalWithdrawn.add(rewardAmount);\n        userRewardInfo[msg.sender].lastWithdrawTime = now;\n        \n        //update total rewards withdrawn\n        rewardsWithdrawn = rewardsWithdrawn.add(rewardAmount);\n        \n        //transfer rewards\n        rewardToken.transfer(msg.sender, rewardAmount);\n        emit RewardWithdrawal(msg.sender, rewardAmount);\n    }\n    \n    //get staking details by user address\n    function getStakingAmount(address _userAddress) external constant returns (uint256 _stakedAmount) {\n        return userTotalStaking[_userAddress].totalStaking;\n    }\n    \n    //get total rewards collected by user\n    function getTotalRewardCollectedByUser(address userAddress) view external returns (uint256 _totalRewardCollected) \n    {\n        return userRewardInfo[userAddress].totalWithdrawn;\n    }\n    \n    //get total SWAP token staked in the contract\n    function getTotalStaked() external constant returns ( uint256 _totalStaked) {\n        return totalStaked;\n    }\n    \n    //get total rewards in the contract\n    function getTotalRewards() external constant returns ( uint256 _totalRewards) {\n        return totalRewards;\n    }\n    \n    //get pool details\n    function getPoolDetails() external view returns (address _baseToken, address _pairedToken, uint256 _totalRewards, uint256 _rewardsWithdrawn, uint256 _poolStartTime, uint256 _poolEndTime) {\n        return (address(tswap),address(rewardToken),totalRewards,rewardsWithdrawn,poolStartTime,poolEndTime);\n    }\n    \n    //get duration of pools\n    function getPoolDuration() external constant returns (uint256 _poolDuration) {\n        return poolDuration;\n    }\n\n    //set duration of pools by owner in seconds\n    function setPoolDuration(uint256 _poolDuration) external onlyOwner {\n        poolDuration = _poolDuration;\n        poolEndTime = poolStartTime + _poolDuration;\n        emit PoolDurationChange(_poolDuration);\n    }\n    \n    //get SWAP token address\n    function getSwapAddress() external constant returns (address _swapAddress) {\n        return address(tswap);\n    }\n    \n    //set tswap address\n    function setTswapAddress(address _address) external onlyOwner {\n        tswap = Ierc20(_address);\n    }\n    \n    //set reward token address\n    function setRewardTokenAddress(address _address) external onlyOwner {\n        rewardToken = Ierc20(_address);\n    }\n    \n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Hacken-TrustSwap-V1/code/StakingPool.sol",
        "vulnerability": "Assertion Failure",
        "check": "FP",
        "response": "Answer: Yes\nDescription: The `computeNewReward` function can potentially cause an assertion failure if `totalStaked` is zero, as it would lead to a division by zero error."
    },
    {
        "code_segment": "contract StakingPool is Owned {\n    using SafeMath for uint256;\n    \n    Ierc20 public tswap;\n    Ierc20 public rewardToken;\n    uint256 poolDuration;\n    uint256 totalRewards;\n    uint256 rewardsWithdrawn;\n    uint256 poolStartTime;\n    uint256 poolEndTime;\n    uint256 totalStaked;\n    // Represents a single stake for a user. A user may have multiple.\n    struct Stake {\n        uint256 amount;\n        uint256 stakingTime;\n        uint256 lastWithdrawTime;\n    }\n    mapping (address => Stake[]) public userStaking;\n    \n    // Represents total staking of an user\n    struct UserTotals {\n        uint256 totalStaking;\n        uint256 totalStakingTIme;\n    }\n    mapping (address => UserTotals) public userTotalStaking;\n    \n    struct Ris3Rewards {\n        uint256 totalWithdrawn;\n        uint256 lastWithdrawTime;\n    }\n    mapping(address => Ris3Rewards) public userRewardInfo;\n    \n    event OwnerSetReward(uint256 amount);\n    event Staked(address userAddress, uint256 amount);\n    event StakingWithdrawal(address userAddress, uint256 amount);\n    event RewardWithdrawal(address userAddress, uint256 amount);\n    event PoolDurationChange(uint256 poolDuration);\n    \n    /**\n     * Constrctor function\n    */\n    constructor() public {\n        tswap = Ierc20(0xf823eA01D48F7Fb36b4b319f21dae404Ac86Bb8d);\n        rewardToken = Ierc20(0xdE55ea8232e0B1615d762eFCB17Cb2D7df164727);\n        poolDuration = 1 hours;\n    }\n    \n    //Set pool rewards\n    function ownerSetPoolRewards(uint256 _rewardAmount) external onlyOwner {\n        require(poolStartTime == 0, \"Pool rewards already set\");\n        require(_rewardAmount > 0, \"Cannot create pool with zero amount\");\n        \n        //set total rewards value\n        totalRewards = _rewardAmount;\n        \n        poolStartTime = now;\n        poolEndTime = now + poolDuration;\n        \n        //transfer tokens to contract\n        // SWC-104-Unchecked Call Return Value: L132\n        rewardToken.transferFrom(msg.sender, this, _rewardAmount);\n        emit OwnerSetReward(_rewardAmount);\n    }\n    \n    //Stake function for users to stake SWAP token\n    function stake(uint256 amount) external {\n        require(amount > 0, \"Cannot stake 0\");\n        require(now < poolEndTime, \"Staking pool is closed\"); //staking pool is closed for staking\n        \n        //add value in staking\n        userTotalStaking[msg.sender].totalStaking = userTotalStaking[msg.sender].totalStaking.add(amount);\n        \n        //add new stake\n        Stake memory newStake = Stake(amount, now, 0);\n        userStaking[msg.sender].push(newStake);\n        \n        //add to total staked\n        totalStaked = totalStaked.add(amount);\n        \n        tswap.transferFrom(msg.sender, this, amount);\n        emit Staked(msg.sender, amount);\n    }\n    \n    //compute rewards\n    function computeNewReward(uint256 _rewardAmount, uint256 _stakedAmount, uint256 _stakeTimeSec) private view returns (uint256 _reward) {\n        uint256 rewardPerSecond = totalRewards.mul(1 ether);\n        if (rewardPerSecond != 0 ) {\n            rewardPerSecond = rewardPerSecond.div(poolDuration);\n        }\n        \n        if (rewardPerSecond > 0) {\n            uint256 rewardPerSecForEachTokenStaked = rewardPerSecond.div(totalStaked);\n            uint256 userRewards = rewardPerSecForEachTokenStaked.mul(_stakedAmount).mul(_stakeTimeSec);\n                    userRewards = userRewards.div(1 ether);\n            \n            return _rewardAmount.add(userRewards);\n        } else {\n            return 0;\n        }\n    }\n    \n    //calculate your rewards\n    function calculateReward(address _userAddress) public view returns (uint256 _reward) {\n        // all user stakes\n        Stake[] storage accountStakes = userStaking[_userAddress];\n        \n        // Redeem from most recent stake and go backwards in time.\n        uint256 rewardAmount = 0;\n        uint256 i = accountStakes.length;\n        while (i > 0) {\n            Stake storage userStake = accountStakes[i - 1];\n            uint256 stakeTimeSec;\n            \n            //check if current time is more than pool ending time\n            if (now > poolEndTime) {\n                stakeTimeSec = poolEndTime.sub(userStake.stakingTime);\n                if(userStake.lastWithdrawTime != 0){\n                    stakeTimeSec = poolEndTime.sub(userStake.lastWithdrawTime);\n                }\n            } else {\n                stakeTimeSec = now.sub(userStake.stakingTime);\n                if(userStake.lastWithdrawTime != 0){\n                    stakeTimeSec = now.sub(userStake.lastWithdrawTime);\n                }\n            }\n            \n            // fully redeem a past stake\n            rewardAmount = computeNewReward(rewardAmount, userStake.amount, stakeTimeSec);\n            i--;\n        }\n        \n        return rewardAmount;\n    }\n    \n    //Withdraw staking and rewards\n    function withdrawStaking(uint256 amount) external {\n        require(amount > 0, \"Amount can not be zero\");\n        require(userTotalStaking[msg.sender].totalStaking >= amount, \"You are trying to withdaw more than your stake\");\n        \n        // 1. User Accounting\n        Stake[] storage accountStakes = userStaking[msg.sender];\n        \n        // Redeem from most recent stake and go backwards in time.\n        uint256 sharesLeftToBurn = amount;\n        uint256 rewardAmount = 0;\n        while (sharesLeftToBurn > 0) {\n            Stake storage lastStake = accountStakes[accountStakes.length - 1];\n            uint256 stakeTimeSec;\n            //check if current time is more than pool ending time\n            if (now > poolEndTime) {\n                stakeTimeSec = poolEndTime.sub(lastStake.stakingTime);\n                if(lastStake.lastWithdrawTime != 0){\n                    stakeTimeSec = poolEndTime.sub(lastStake.lastWithdrawTime);\n                }\n            } else {\n                stakeTimeSec = now.sub(lastStake.stakingTime);\n                if(lastStake.lastWithdrawTime != 0){\n                    stakeTimeSec = now.sub(lastStake.lastWithdrawTime);\n                }\n            }\n            \n            if (lastStake.amount <= sharesLeftToBurn) {\n                // fully redeem a past stake\n                rewardAmount = computeNewReward(rewardAmount, lastStake.amount, stakeTimeSec);\n                sharesLeftToBurn = sharesLeftToBurn.sub(lastStake.amount);\n                accountStakes.length--;\n            } else {\n                // partially redeem a past stake\n                rewardAmount = computeNewReward(rewardAmount, sharesLeftToBurn, stakeTimeSec);\n                lastStake.amount = lastStake.amount.sub(sharesLeftToBurn);\n                lastStake.lastWithdrawTime = now;\n                sharesLeftToBurn = 0;\n            }\n        }\n        \n        //substract value in staking\n        userTotalStaking[msg.sender].totalStaking = userTotalStaking[msg.sender].totalStaking.sub(amount);\n        \n        //substract from total staked\n        totalStaked = totalStaked.sub(amount);\n        \n        //update user rewards info\n        userRewardInfo[msg.sender].totalWithdrawn = userRewardInfo[msg.sender].totalWithdrawn.add(rewardAmount);\n        userRewardInfo[msg.sender].lastWithdrawTime = now;\n        \n        //update total rewards withdrawn\n        rewardsWithdrawn = rewardsWithdrawn.add(rewardAmount);\n        \n        //transfer rewards and tokens\n        // SWC-104-Unchecked Call Return Value: L262\n        rewardToken.transfer(msg.sender, rewardAmount);\n        tswap.transfer(msg.sender, amount);\n        \n        emit RewardWithdrawal(msg.sender, rewardAmount);\n        emit StakingWithdrawal(msg.sender, amount);\n    }\n    \n    //Withdraw rewards\n    function withdrawRewardsOnly() external {\n        uint256 _rwdAmount = calculateReward(msg.sender);\n        require(_rwdAmount > 0, \"You do not have enough rewards\");\n        \n        // 1. User Accounting\n        Stake[] storage accountStakes = userStaking[msg.sender];\n        \n        // Redeem from most recent stake and go backwards in time.\n        uint256 rewardAmount = 0;\n        uint256 i = accountStakes.length;\n        while (i > 0) {\n            Stake storage userStake = accountStakes[i - 1];\n            uint256 stakeTimeSec;\n            \n            //check if current time is more than pool ending time\n            if (now > poolEndTime) {\n                stakeTimeSec = poolEndTime.sub(userStake.stakingTime);\n                if(userStake.lastWithdrawTime != 0){\n                    stakeTimeSec = poolEndTime.sub(userStake.lastWithdrawTime);\n                }\n            } else {\n                stakeTimeSec = now.sub(userStake.stakingTime);\n                if(userStake.lastWithdrawTime != 0){\n                    stakeTimeSec = now.sub(userStake.lastWithdrawTime);\n                }\n            }\n            \n            // fully redeem a past stake\n            rewardAmount = computeNewReward(rewardAmount, userStake.amount, stakeTimeSec);\n            userStake.lastWithdrawTime = now;\n            i--;\n        }\n        \n        //update user rewards info\n        userRewardInfo[msg.sender].totalWithdrawn = userRewardInfo[msg.sender].totalWithdrawn.add(rewardAmount);\n        userRewardInfo[msg.sender].lastWithdrawTime = now;\n        \n        //update total rewards withdrawn\n        rewardsWithdrawn = rewardsWithdrawn.add(rewardAmount);\n        \n        //transfer rewards\n        rewardToken.transfer(msg.sender, rewardAmount);\n        emit RewardWithdrawal(msg.sender, rewardAmount);\n    }\n    \n    //get staking details by user address\n    function getStakingAmount(address _userAddress) external constant returns (uint256 _stakedAmount) {\n        return userTotalStaking[_userAddress].totalStaking;\n    }\n    \n    //get total rewards collected by user\n    function getTotalRewardCollectedByUser(address userAddress) view external returns (uint256 _totalRewardCollected) \n    {\n        return userRewardInfo[userAddress].totalWithdrawn;\n    }\n    \n    //get total SWAP token staked in the contract\n    function getTotalStaked() external constant returns ( uint256 _totalStaked) {\n        return totalStaked;\n    }\n    \n    //get total rewards in the contract\n    function getTotalRewards() external constant returns ( uint256 _totalRewards) {\n        return totalRewards;\n    }\n    \n    //get pool details\n    function getPoolDetails() external view returns (address _baseToken, address _pairedToken, uint256 _totalRewards, uint256 _rewardsWithdrawn, uint256 _poolStartTime, uint256 _poolEndTime) {\n        return (address(tswap),address(rewardToken),totalRewards,rewardsWithdrawn,poolStartTime,poolEndTime);\n    }\n    \n    //get duration of pools\n    function getPoolDuration() external constant returns (uint256 _poolDuration) {\n        return poolDuration;\n    }\n\n    //set duration of pools by owner in seconds\n    function setPoolDuration(uint256 _poolDuration) external onlyOwner {\n        poolDuration = _poolDuration;\n        poolEndTime = poolStartTime + _poolDuration;\n        emit PoolDurationChange(_poolDuration);\n    }\n    \n    //get SWAP token address\n    function getSwapAddress() external constant returns (address _swapAddress) {\n        return address(tswap);\n    }\n    \n    //set tswap address\n    function setTswapAddress(address _address) external onlyOwner {\n        tswap = Ierc20(_address);\n    }\n    \n    //set reward token address\n    function setRewardTokenAddress(address _address) external onlyOwner {\n        rewardToken = Ierc20(_address);\n    }\n    \n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Hacken-TrustSwap-V1/code/StakingPool.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No\nReason: The code uses the SafeMath library for all arithmetic operations involving uint256, which prevents integer overflow vulnerabilities."
    },
    {
        "code_segment": "contract StakingPool is Owned {\n    using SafeMath for uint256;\n    \n    Ierc20 public tswap;\n    Ierc20 public rewardToken;\n    uint256 poolDuration;\n    uint256 totalRewards;\n    uint256 rewardsWithdrawn;\n    uint256 poolStartTime;\n    uint256 poolEndTime;\n    uint256 totalStaked;\n    // Represents a single stake for a user. A user may have multiple.\n    struct Stake {\n        uint256 amount;\n        uint256 stakingTime;\n        uint256 lastWithdrawTime;\n    }\n    mapping (address => Stake[]) public userStaking;\n    \n    // Represents total staking of an user\n    struct UserTotals {\n        uint256 totalStaking;\n        uint256 totalStakingTIme;\n    }\n    mapping (address => UserTotals) public userTotalStaking;\n    \n    struct Ris3Rewards {\n        uint256 totalWithdrawn;\n        uint256 lastWithdrawTime;\n    }\n    mapping(address => Ris3Rewards) public userRewardInfo;\n    \n    event OwnerSetReward(uint256 amount);\n    event Staked(address userAddress, uint256 amount);\n    event StakingWithdrawal(address userAddress, uint256 amount);\n    event RewardWithdrawal(address userAddress, uint256 amount);\n    event PoolDurationChange(uint256 poolDuration);\n    \n    /**\n     * Constrctor function\n    */\n    constructor() public {\n        tswap = Ierc20(0xf823eA01D48F7Fb36b4b319f21dae404Ac86Bb8d);\n        rewardToken = Ierc20(0xdE55ea8232e0B1615d762eFCB17Cb2D7df164727);\n        poolDuration = 1 hours;\n    }\n    \n    //Set pool rewards\n    function ownerSetPoolRewards(uint256 _rewardAmount) external onlyOwner {\n        require(poolStartTime == 0, \"Pool rewards already set\");\n        require(_rewardAmount > 0, \"Cannot create pool with zero amount\");\n        \n        //set total rewards value\n        totalRewards = _rewardAmount;\n        \n        poolStartTime = now;\n        poolEndTime = now + poolDuration;\n        \n        //transfer tokens to contract\n        // SWC-104-Unchecked Call Return Value: L132\n        rewardToken.transferFrom(msg.sender, this, _rewardAmount);\n        emit OwnerSetReward(_rewardAmount);\n    }\n    \n    //Stake function for users to stake SWAP token\n    function stake(uint256 amount) external {\n        require(amount > 0, \"Cannot stake 0\");\n        require(now < poolEndTime, \"Staking pool is closed\"); //staking pool is closed for staking\n        \n        //add value in staking\n        userTotalStaking[msg.sender].totalStaking = userTotalStaking[msg.sender].totalStaking.add(amount);\n        \n        //add new stake\n        Stake memory newStake = Stake(amount, now, 0);\n        userStaking[msg.sender].push(newStake);\n        \n        //add to total staked\n        totalStaked = totalStaked.add(amount);\n        \n        tswap.transferFrom(msg.sender, this, amount);\n        emit Staked(msg.sender, amount);\n    }\n    \n    //compute rewards\n    function computeNewReward(uint256 _rewardAmount, uint256 _stakedAmount, uint256 _stakeTimeSec) private view returns (uint256 _reward) {\n        uint256 rewardPerSecond = totalRewards.mul(1 ether);\n        if (rewardPerSecond != 0 ) {\n            rewardPerSecond = rewardPerSecond.div(poolDuration);\n        }\n        \n        if (rewardPerSecond > 0) {\n            uint256 rewardPerSecForEachTokenStaked = rewardPerSecond.div(totalStaked);\n            uint256 userRewards = rewardPerSecForEachTokenStaked.mul(_stakedAmount).mul(_stakeTimeSec);\n                    userRewards = userRewards.div(1 ether);\n            \n            return _rewardAmount.add(userRewards);\n        } else {\n            return 0;\n        }\n    }\n    \n    //calculate your rewards\n    function calculateReward(address _userAddress) public view returns (uint256 _reward) {\n        // all user stakes\n        Stake[] storage accountStakes = userStaking[_userAddress];\n        \n        // Redeem from most recent stake and go backwards in time.\n        uint256 rewardAmount = 0;\n        uint256 i = accountStakes.length;\n        while (i > 0) {\n            Stake storage userStake = accountStakes[i - 1];\n            uint256 stakeTimeSec;\n            \n            //check if current time is more than pool ending time\n            if (now > poolEndTime) {\n                stakeTimeSec = poolEndTime.sub(userStake.stakingTime);\n                if(userStake.lastWithdrawTime != 0){\n                    stakeTimeSec = poolEndTime.sub(userStake.lastWithdrawTime);\n                }\n            } else {\n                stakeTimeSec = now.sub(userStake.stakingTime);\n                if(userStake.lastWithdrawTime != 0){\n                    stakeTimeSec = now.sub(userStake.lastWithdrawTime);\n                }\n            }\n            \n            // fully redeem a past stake\n            rewardAmount = computeNewReward(rewardAmount, userStake.amount, stakeTimeSec);\n            i--;\n        }\n        \n        return rewardAmount;\n    }\n    \n    //Withdraw staking and rewards\n    function withdrawStaking(uint256 amount) external {\n        require(amount > 0, \"Amount can not be zero\");\n        require(userTotalStaking[msg.sender].totalStaking >= amount, \"You are trying to withdaw more than your stake\");\n        \n        // 1. User Accounting\n        Stake[] storage accountStakes = userStaking[msg.sender];\n        \n        // Redeem from most recent stake and go backwards in time.\n        uint256 sharesLeftToBurn = amount;\n        uint256 rewardAmount = 0;\n        while (sharesLeftToBurn > 0) {\n            Stake storage lastStake = accountStakes[accountStakes.length - 1];\n            uint256 stakeTimeSec;\n            //check if current time is more than pool ending time\n            if (now > poolEndTime) {\n                stakeTimeSec = poolEndTime.sub(lastStake.stakingTime);\n                if(lastStake.lastWithdrawTime != 0){\n                    stakeTimeSec = poolEndTime.sub(lastStake.lastWithdrawTime);\n                }\n            } else {\n                stakeTimeSec = now.sub(lastStake.stakingTime);\n                if(lastStake.lastWithdrawTime != 0){\n                    stakeTimeSec = now.sub(lastStake.lastWithdrawTime);\n                }\n            }\n            \n            if (lastStake.amount <= sharesLeftToBurn) {\n                // fully redeem a past stake\n                rewardAmount = computeNewReward(rewardAmount, lastStake.amount, stakeTimeSec);\n                sharesLeftToBurn = sharesLeftToBurn.sub(lastStake.amount);\n                accountStakes.length--;\n            } else {\n                // partially redeem a past stake\n                rewardAmount = computeNewReward(rewardAmount, sharesLeftToBurn, stakeTimeSec);\n                lastStake.amount = lastStake.amount.sub(sharesLeftToBurn);\n                lastStake.lastWithdrawTime = now;\n                sharesLeftToBurn = 0;\n            }\n        }\n        \n        //substract value in staking\n        userTotalStaking[msg.sender].totalStaking = userTotalStaking[msg.sender].totalStaking.sub(amount);\n        \n        //substract from total staked\n        totalStaked = totalStaked.sub(amount);\n        \n        //update user rewards info\n        userRewardInfo[msg.sender].totalWithdrawn = userRewardInfo[msg.sender].totalWithdrawn.add(rewardAmount);\n        userRewardInfo[msg.sender].lastWithdrawTime = now;\n        \n        //update total rewards withdrawn\n        rewardsWithdrawn = rewardsWithdrawn.add(rewardAmount);\n        \n        //transfer rewards and tokens\n        // SWC-104-Unchecked Call Return Value: L262\n        rewardToken.transfer(msg.sender, rewardAmount);\n        tswap.transfer(msg.sender, amount);\n        \n        emit RewardWithdrawal(msg.sender, rewardAmount);\n        emit StakingWithdrawal(msg.sender, amount);\n    }\n    \n    //Withdraw rewards\n    function withdrawRewardsOnly() external {\n        uint256 _rwdAmount = calculateReward(msg.sender);\n        require(_rwdAmount > 0, \"You do not have enough rewards\");\n        \n        // 1. User Accounting\n        Stake[] storage accountStakes = userStaking[msg.sender];\n        \n        // Redeem from most recent stake and go backwards in time.\n        uint256 rewardAmount = 0;\n        uint256 i = accountStakes.length;\n        while (i > 0) {\n            Stake storage userStake = accountStakes[i - 1];\n            uint256 stakeTimeSec;\n            \n            //check if current time is more than pool ending time\n            if (now > poolEndTime) {\n                stakeTimeSec = poolEndTime.sub(userStake.stakingTime);\n                if(userStake.lastWithdrawTime != 0){\n                    stakeTimeSec = poolEndTime.sub(userStake.lastWithdrawTime);\n                }\n            } else {\n                stakeTimeSec = now.sub(userStake.stakingTime);\n                if(userStake.lastWithdrawTime != 0){\n                    stakeTimeSec = now.sub(userStake.lastWithdrawTime);\n                }\n            }\n            \n            // fully redeem a past stake\n            rewardAmount = computeNewReward(rewardAmount, userStake.amount, stakeTimeSec);\n            userStake.lastWithdrawTime = now;\n            i--;\n        }\n        \n        //update user rewards info\n        userRewardInfo[msg.sender].totalWithdrawn = userRewardInfo[msg.sender].totalWithdrawn.add(rewardAmount);\n        userRewardInfo[msg.sender].lastWithdrawTime = now;\n        \n        //update total rewards withdrawn\n        rewardsWithdrawn = rewardsWithdrawn.add(rewardAmount);\n        \n        //transfer rewards\n        rewardToken.transfer(msg.sender, rewardAmount);\n        emit RewardWithdrawal(msg.sender, rewardAmount);\n    }\n    \n    //get staking details by user address\n    function getStakingAmount(address _userAddress) external constant returns (uint256 _stakedAmount) {\n        return userTotalStaking[_userAddress].totalStaking;\n    }\n    \n    //get total rewards collected by user\n    function getTotalRewardCollectedByUser(address userAddress) view external returns (uint256 _totalRewardCollected) \n    {\n        return userRewardInfo[userAddress].totalWithdrawn;\n    }\n    \n    //get total SWAP token staked in the contract\n    function getTotalStaked() external constant returns ( uint256 _totalStaked) {\n        return totalStaked;\n    }\n    \n    //get total rewards in the contract\n    function getTotalRewards() external constant returns ( uint256 _totalRewards) {\n        return totalRewards;\n    }\n    \n    //get pool details\n    function getPoolDetails() external view returns (address _baseToken, address _pairedToken, uint256 _totalRewards, uint256 _rewardsWithdrawn, uint256 _poolStartTime, uint256 _poolEndTime) {\n        return (address(tswap),address(rewardToken),totalRewards,rewardsWithdrawn,poolStartTime,poolEndTime);\n    }\n    \n    //get duration of pools\n    function getPoolDuration() external constant returns (uint256 _poolDuration) {\n        return poolDuration;\n    }\n\n    //set duration of pools by owner in seconds\n    function setPoolDuration(uint256 _poolDuration) external onlyOwner {\n        poolDuration = _poolDuration;\n        poolEndTime = poolStartTime + _poolDuration;\n        emit PoolDurationChange(_poolDuration);\n    }\n    \n    //get SWAP token address\n    function getSwapAddress() external constant returns (address _swapAddress) {\n        return address(tswap);\n    }\n    \n    //set tswap address\n    function setTswapAddress(address _address) external onlyOwner {\n        tswap = Ierc20(_address);\n    }\n    \n    //set reward token address\n    function setRewardTokenAddress(address _address) external onlyOwner {\n        rewardToken = Ierc20(_address);\n    }\n    \n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Hacken-TrustSwap-V1/code/StakingPool.sol",
        "vulnerability": "Block Dependency",
        "check": "FP",
        "response": "Answer: Yes\nDescription: The contract uses the current block timestamp (via `now`) for critical calculations in several places (e.g., `stake`, `calculateReward`, `withdrawStaking`, `withdrawRewardsOnly`). This can make the contract vulnerable to \"Block Dependency,\" as miners can manipulate block timestamps slightly to their advantage."
    },
    {
        "code_segment": "contract StakingPool is Owned {\n    using SafeMath for uint256;\n    \n    Ierc20 public tswap;\n    Ierc20 public rewardToken;\n    uint256 poolDuration;\n    uint256 totalRewards;\n    uint256 rewardsWithdrawn;\n    uint256 poolStartTime;\n    uint256 poolEndTime;\n    uint256 totalStaked;\n    // Represents a single stake for a user. A user may have multiple.\n    struct Stake {\n        uint256 amount;\n        uint256 stakingTime;\n        uint256 lastWithdrawTime;\n    }\n    mapping (address => Stake[]) public userStaking;\n    \n    // Represents total staking of an user\n    struct UserTotals {\n        uint256 totalStaking;\n        uint256 totalStakingTIme;\n    }\n    mapping (address => UserTotals) public userTotalStaking;\n    \n    struct Ris3Rewards {\n        uint256 totalWithdrawn;\n        uint256 lastWithdrawTime;\n    }\n    mapping(address => Ris3Rewards) public userRewardInfo;\n    \n    event OwnerSetReward(uint256 amount);\n    event Staked(address userAddress, uint256 amount);\n    event StakingWithdrawal(address userAddress, uint256 amount);\n    event RewardWithdrawal(address userAddress, uint256 amount);\n    event PoolDurationChange(uint256 poolDuration);\n    \n    /**\n     * Constrctor function\n    */\n    constructor() public {\n        tswap = Ierc20(0xf823eA01D48F7Fb36b4b319f21dae404Ac86Bb8d);\n        rewardToken = Ierc20(0xdE55ea8232e0B1615d762eFCB17Cb2D7df164727);\n        poolDuration = 1 hours;\n    }\n    \n    //Set pool rewards\n    function ownerSetPoolRewards(uint256 _rewardAmount) external onlyOwner {\n        require(poolStartTime == 0, \"Pool rewards already set\");\n        require(_rewardAmount > 0, \"Cannot create pool with zero amount\");\n        \n        //set total rewards value\n        totalRewards = _rewardAmount;\n        \n        poolStartTime = now;\n        poolEndTime = now + poolDuration;\n        \n        //transfer tokens to contract\n        // SWC-104-Unchecked Call Return Value: L132\n        rewardToken.transferFrom(msg.sender, this, _rewardAmount);\n        emit OwnerSetReward(_rewardAmount);\n    }\n    \n    //Stake function for users to stake SWAP token\n    function stake(uint256 amount) external {\n        require(amount > 0, \"Cannot stake 0\");\n        require(now < poolEndTime, \"Staking pool is closed\"); //staking pool is closed for staking\n        \n        //add value in staking\n        userTotalStaking[msg.sender].totalStaking = userTotalStaking[msg.sender].totalStaking.add(amount);\n        \n        //add new stake\n        Stake memory newStake = Stake(amount, now, 0);\n        userStaking[msg.sender].push(newStake);\n        \n        //add to total staked\n        totalStaked = totalStaked.add(amount);\n        \n        tswap.transferFrom(msg.sender, this, amount);\n        emit Staked(msg.sender, amount);\n    }\n    \n    //compute rewards\n    function computeNewReward(uint256 _rewardAmount, uint256 _stakedAmount, uint256 _stakeTimeSec) private view returns (uint256 _reward) {\n        uint256 rewardPerSecond = totalRewards.mul(1 ether);\n        if (rewardPerSecond != 0 ) {\n            rewardPerSecond = rewardPerSecond.div(poolDuration);\n        }\n        \n        if (rewardPerSecond > 0) {\n            uint256 rewardPerSecForEachTokenStaked = rewardPerSecond.div(totalStaked);\n            uint256 userRewards = rewardPerSecForEachTokenStaked.mul(_stakedAmount).mul(_stakeTimeSec);\n                    userRewards = userRewards.div(1 ether);\n            \n            return _rewardAmount.add(userRewards);\n        } else {\n            return 0;\n        }\n    }\n    \n    //calculate your rewards\n    function calculateReward(address _userAddress) public view returns (uint256 _reward) {\n        // all user stakes\n        Stake[] storage accountStakes = userStaking[_userAddress];\n        \n        // Redeem from most recent stake and go backwards in time.\n        uint256 rewardAmount = 0;\n        uint256 i = accountStakes.length;\n        while (i > 0) {\n            Stake storage userStake = accountStakes[i - 1];\n            uint256 stakeTimeSec;\n            \n            //check if current time is more than pool ending time\n            if (now > poolEndTime) {\n                stakeTimeSec = poolEndTime.sub(userStake.stakingTime);\n                if(userStake.lastWithdrawTime != 0){\n                    stakeTimeSec = poolEndTime.sub(userStake.lastWithdrawTime);\n                }\n            } else {\n                stakeTimeSec = now.sub(userStake.stakingTime);\n                if(userStake.lastWithdrawTime != 0){\n                    stakeTimeSec = now.sub(userStake.lastWithdrawTime);\n                }\n            }\n            \n            // fully redeem a past stake\n            rewardAmount = computeNewReward(rewardAmount, userStake.amount, stakeTimeSec);\n            i--;\n        }\n        \n        return rewardAmount;\n    }\n    \n    //Withdraw staking and rewards\n    function withdrawStaking(uint256 amount) external {\n        require(amount > 0, \"Amount can not be zero\");\n        require(userTotalStaking[msg.sender].totalStaking >= amount, \"You are trying to withdaw more than your stake\");\n        \n        // 1. User Accounting\n        Stake[] storage accountStakes = userStaking[msg.sender];\n        \n        // Redeem from most recent stake and go backwards in time.\n        uint256 sharesLeftToBurn = amount;\n        uint256 rewardAmount = 0;\n        while (sharesLeftToBurn > 0) {\n            Stake storage lastStake = accountStakes[accountStakes.length - 1];\n            uint256 stakeTimeSec;\n            //check if current time is more than pool ending time\n            if (now > poolEndTime) {\n                stakeTimeSec = poolEndTime.sub(lastStake.stakingTime);\n                if(lastStake.lastWithdrawTime != 0){\n                    stakeTimeSec = poolEndTime.sub(lastStake.lastWithdrawTime);\n                }\n            } else {\n                stakeTimeSec = now.sub(lastStake.stakingTime);\n                if(lastStake.lastWithdrawTime != 0){\n                    stakeTimeSec = now.sub(lastStake.lastWithdrawTime);\n                }\n            }\n            \n            if (lastStake.amount <= sharesLeftToBurn) {\n                // fully redeem a past stake\n                rewardAmount = computeNewReward(rewardAmount, lastStake.amount, stakeTimeSec);\n                sharesLeftToBurn = sharesLeftToBurn.sub(lastStake.amount);\n                accountStakes.length--;\n            } else {\n                // partially redeem a past stake\n                rewardAmount = computeNewReward(rewardAmount, sharesLeftToBurn, stakeTimeSec);\n                lastStake.amount = lastStake.amount.sub(sharesLeftToBurn);\n                lastStake.lastWithdrawTime = now;\n                sharesLeftToBurn = 0;\n            }\n        }\n        \n        //substract value in staking\n        userTotalStaking[msg.sender].totalStaking = userTotalStaking[msg.sender].totalStaking.sub(amount);\n        \n        //substract from total staked\n        totalStaked = totalStaked.sub(amount);\n        \n        //update user rewards info\n        userRewardInfo[msg.sender].totalWithdrawn = userRewardInfo[msg.sender].totalWithdrawn.add(rewardAmount);\n        userRewardInfo[msg.sender].lastWithdrawTime = now;\n        \n        //update total rewards withdrawn\n        rewardsWithdrawn = rewardsWithdrawn.add(rewardAmount);\n        \n        //transfer rewards and tokens\n        // SWC-104-Unchecked Call Return Value: L262\n        rewardToken.transfer(msg.sender, rewardAmount);\n        tswap.transfer(msg.sender, amount);\n        \n        emit RewardWithdrawal(msg.sender, rewardAmount);\n        emit StakingWithdrawal(msg.sender, amount);\n    }\n    \n    //Withdraw rewards\n    function withdrawRewardsOnly() external {\n        uint256 _rwdAmount = calculateReward(msg.sender);\n        require(_rwdAmount > 0, \"You do not have enough rewards\");\n        \n        // 1. User Accounting\n        Stake[] storage accountStakes = userStaking[msg.sender];\n        \n        // Redeem from most recent stake and go backwards in time.\n        uint256 rewardAmount = 0;\n        uint256 i = accountStakes.length;\n        while (i > 0) {\n            Stake storage userStake = accountStakes[i - 1];\n            uint256 stakeTimeSec;\n            \n            //check if current time is more than pool ending time\n            if (now > poolEndTime) {\n                stakeTimeSec = poolEndTime.sub(userStake.stakingTime);\n                if(userStake.lastWithdrawTime != 0){\n                    stakeTimeSec = poolEndTime.sub(userStake.lastWithdrawTime);\n                }\n            } else {\n                stakeTimeSec = now.sub(userStake.stakingTime);\n                if(userStake.lastWithdrawTime != 0){\n                    stakeTimeSec = now.sub(userStake.lastWithdrawTime);\n                }\n            }\n            \n            // fully redeem a past stake\n            rewardAmount = computeNewReward(rewardAmount, userStake.amount, stakeTimeSec);\n            userStake.lastWithdrawTime = now;\n            i--;\n        }\n        \n        //update user rewards info\n        userRewardInfo[msg.sender].totalWithdrawn = userRewardInfo[msg.sender].totalWithdrawn.add(rewardAmount);\n        userRewardInfo[msg.sender].lastWithdrawTime = now;\n        \n        //update total rewards withdrawn\n        rewardsWithdrawn = rewardsWithdrawn.add(rewardAmount);\n        \n        //transfer rewards\n        rewardToken.transfer(msg.sender, rewardAmount);\n        emit RewardWithdrawal(msg.sender, rewardAmount);\n    }\n    \n    //get staking details by user address\n    function getStakingAmount(address _userAddress) external constant returns (uint256 _stakedAmount) {\n        return userTotalStaking[_userAddress].totalStaking;\n    }\n    \n    //get total rewards collected by user\n    function getTotalRewardCollectedByUser(address userAddress) view external returns (uint256 _totalRewardCollected) \n    {\n        return userRewardInfo[userAddress].totalWithdrawn;\n    }\n    \n    //get total SWAP token staked in the contract\n    function getTotalStaked() external constant returns ( uint256 _totalStaked) {\n        return totalStaked;\n    }\n    \n    //get total rewards in the contract\n    function getTotalRewards() external constant returns ( uint256 _totalRewards) {\n        return totalRewards;\n    }\n    \n    //get pool details\n    function getPoolDetails() external view returns (address _baseToken, address _pairedToken, uint256 _totalRewards, uint256 _rewardsWithdrawn, uint256 _poolStartTime, uint256 _poolEndTime) {\n        return (address(tswap),address(rewardToken),totalRewards,rewardsWithdrawn,poolStartTime,poolEndTime);\n    }\n    \n    //get duration of pools\n    function getPoolDuration() external constant returns (uint256 _poolDuration) {\n        return poolDuration;\n    }\n\n    //set duration of pools by owner in seconds\n    function setPoolDuration(uint256 _poolDuration) external onlyOwner {\n        poolDuration = _poolDuration;\n        poolEndTime = poolStartTime + _poolDuration;\n        emit PoolDurationChange(_poolDuration);\n    }\n    \n    //get SWAP token address\n    function getSwapAddress() external constant returns (address _swapAddress) {\n        return address(tswap);\n    }\n    \n    //set tswap address\n    function setTswapAddress(address _address) external onlyOwner {\n        tswap = Ierc20(_address);\n    }\n    \n    //set reward token address\n    function setRewardTokenAddress(address _address) external onlyOwner {\n        rewardToken = Ierc20(_address);\n    }\n    \n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Hacken-TrustSwap-V1/code/StakingPool.sol",
        "vulnerability": "Block Dependency",
        "check": "FP",
        "response": "Answer: Yes\nDescription: The contract uses `now` (current block timestamp) in several function calls including calculations in `stake`, `calculateReward`, `withdrawStaking`, and `withdrawRewardsOnly` functions. This introduces dependency on the block timestamp and can be manipulated by miners to affect the contract logic."
    },
    {
        "code_segment": "contract StakingPool is Owned {\n    using SafeMath for uint256;\n    \n    Ierc20 public tswap;\n    Ierc20 public rewardToken;\n    uint256 poolDuration;\n    uint256 totalRewards;\n    uint256 rewardsWithdrawn;\n    uint256 poolStartTime;\n    uint256 poolEndTime;\n    uint256 totalStaked;\n    // Represents a single stake for a user. A user may have multiple.\n    struct Stake {\n        uint256 amount;\n        uint256 stakingTime;\n        uint256 lastWithdrawTime;\n    }\n    mapping (address => Stake[]) public userStaking;\n    \n    // Represents total staking of an user\n    struct UserTotals {\n        uint256 totalStaking;\n        uint256 totalStakingTIme;\n    }\n    mapping (address => UserTotals) public userTotalStaking;\n    \n    struct Ris3Rewards {\n        uint256 totalWithdrawn;\n        uint256 lastWithdrawTime;\n    }\n    mapping(address => Ris3Rewards) public userRewardInfo;\n    \n    event OwnerSetReward(uint256 amount);\n    event Staked(address userAddress, uint256 amount);\n    event StakingWithdrawal(address userAddress, uint256 amount);\n    event RewardWithdrawal(address userAddress, uint256 amount);\n    event PoolDurationChange(uint256 poolDuration);\n    \n    /**\n     * Constrctor function\n    */\n    constructor() public {\n        tswap = Ierc20(0xf823eA01D48F7Fb36b4b319f21dae404Ac86Bb8d);\n        rewardToken = Ierc20(0xdE55ea8232e0B1615d762eFCB17Cb2D7df164727);\n        poolDuration = 1 hours;\n    }\n    \n    //Set pool rewards\n    function ownerSetPoolRewards(uint256 _rewardAmount) external onlyOwner {\n        require(poolStartTime == 0, \"Pool rewards already set\");\n        require(_rewardAmount > 0, \"Cannot create pool with zero amount\");\n        \n        //set total rewards value\n        totalRewards = _rewardAmount;\n        \n        poolStartTime = now;\n        poolEndTime = now + poolDuration;\n        \n        //transfer tokens to contract\n        // SWC-104-Unchecked Call Return Value: L132\n        rewardToken.transferFrom(msg.sender, this, _rewardAmount);\n        emit OwnerSetReward(_rewardAmount);\n    }\n    \n    //Stake function for users to stake SWAP token\n    function stake(uint256 amount) external {\n        require(amount > 0, \"Cannot stake 0\");\n        require(now < poolEndTime, \"Staking pool is closed\"); //staking pool is closed for staking\n        \n        //add value in staking\n        userTotalStaking[msg.sender].totalStaking = userTotalStaking[msg.sender].totalStaking.add(amount);\n        \n        //add new stake\n        Stake memory newStake = Stake(amount, now, 0);\n        userStaking[msg.sender].push(newStake);\n        \n        //add to total staked\n        totalStaked = totalStaked.add(amount);\n        \n        tswap.transferFrom(msg.sender, this, amount);\n        emit Staked(msg.sender, amount);\n    }\n    \n    //compute rewards\n    function computeNewReward(uint256 _rewardAmount, uint256 _stakedAmount, uint256 _stakeTimeSec) private view returns (uint256 _reward) {\n        uint256 rewardPerSecond = totalRewards.mul(1 ether);\n        if (rewardPerSecond != 0 ) {\n            rewardPerSecond = rewardPerSecond.div(poolDuration);\n        }\n        \n        if (rewardPerSecond > 0) {\n            uint256 rewardPerSecForEachTokenStaked = rewardPerSecond.div(totalStaked);\n            uint256 userRewards = rewardPerSecForEachTokenStaked.mul(_stakedAmount).mul(_stakeTimeSec);\n                    userRewards = userRewards.div(1 ether);\n            \n            return _rewardAmount.add(userRewards);\n        } else {\n            return 0;\n        }\n    }\n    \n    //calculate your rewards\n    function calculateReward(address _userAddress) public view returns (uint256 _reward) {\n        // all user stakes\n        Stake[] storage accountStakes = userStaking[_userAddress];\n        \n        // Redeem from most recent stake and go backwards in time.\n        uint256 rewardAmount = 0;\n        uint256 i = accountStakes.length;\n        while (i > 0) {\n            Stake storage userStake = accountStakes[i - 1];\n            uint256 stakeTimeSec;\n            \n            //check if current time is more than pool ending time\n            if (now > poolEndTime) {\n                stakeTimeSec = poolEndTime.sub(userStake.stakingTime);\n                if(userStake.lastWithdrawTime != 0){\n                    stakeTimeSec = poolEndTime.sub(userStake.lastWithdrawTime);\n                }\n            } else {\n                stakeTimeSec = now.sub(userStake.stakingTime);\n                if(userStake.lastWithdrawTime != 0){\n                    stakeTimeSec = now.sub(userStake.lastWithdrawTime);\n                }\n            }\n            \n            // fully redeem a past stake\n            rewardAmount = computeNewReward(rewardAmount, userStake.amount, stakeTimeSec);\n            i--;\n        }\n        \n        return rewardAmount;\n    }\n    \n    //Withdraw staking and rewards\n    function withdrawStaking(uint256 amount) external {\n        require(amount > 0, \"Amount can not be zero\");\n        require(userTotalStaking[msg.sender].totalStaking >= amount, \"You are trying to withdaw more than your stake\");\n        \n        // 1. User Accounting\n        Stake[] storage accountStakes = userStaking[msg.sender];\n        \n        // Redeem from most recent stake and go backwards in time.\n        uint256 sharesLeftToBurn = amount;\n        uint256 rewardAmount = 0;\n        while (sharesLeftToBurn > 0) {\n            Stake storage lastStake = accountStakes[accountStakes.length - 1];\n            uint256 stakeTimeSec;\n            //check if current time is more than pool ending time\n            if (now > poolEndTime) {\n                stakeTimeSec = poolEndTime.sub(lastStake.stakingTime);\n                if(lastStake.lastWithdrawTime != 0){\n                    stakeTimeSec = poolEndTime.sub(lastStake.lastWithdrawTime);\n                }\n            } else {\n                stakeTimeSec = now.sub(lastStake.stakingTime);\n                if(lastStake.lastWithdrawTime != 0){\n                    stakeTimeSec = now.sub(lastStake.lastWithdrawTime);\n                }\n            }\n            \n            if (lastStake.amount <= sharesLeftToBurn) {\n                // fully redeem a past stake\n                rewardAmount = computeNewReward(rewardAmount, lastStake.amount, stakeTimeSec);\n                sharesLeftToBurn = sharesLeftToBurn.sub(lastStake.amount);\n                accountStakes.length--;\n            } else {\n                // partially redeem a past stake\n                rewardAmount = computeNewReward(rewardAmount, sharesLeftToBurn, stakeTimeSec);\n                lastStake.amount = lastStake.amount.sub(sharesLeftToBurn);\n                lastStake.lastWithdrawTime = now;\n                sharesLeftToBurn = 0;\n            }\n        }\n        \n        //substract value in staking\n        userTotalStaking[msg.sender].totalStaking = userTotalStaking[msg.sender].totalStaking.sub(amount);\n        \n        //substract from total staked\n        totalStaked = totalStaked.sub(amount);\n        \n        //update user rewards info\n        userRewardInfo[msg.sender].totalWithdrawn = userRewardInfo[msg.sender].totalWithdrawn.add(rewardAmount);\n        userRewardInfo[msg.sender].lastWithdrawTime = now;\n        \n        //update total rewards withdrawn\n        rewardsWithdrawn = rewardsWithdrawn.add(rewardAmount);\n        \n        //transfer rewards and tokens\n        // SWC-104-Unchecked Call Return Value: L262\n        rewardToken.transfer(msg.sender, rewardAmount);\n        tswap.transfer(msg.sender, amount);\n        \n        emit RewardWithdrawal(msg.sender, rewardAmount);\n        emit StakingWithdrawal(msg.sender, amount);\n    }\n    \n    //Withdraw rewards\n    function withdrawRewardsOnly() external {\n        uint256 _rwdAmount = calculateReward(msg.sender);\n        require(_rwdAmount > 0, \"You do not have enough rewards\");\n        \n        // 1. User Accounting\n        Stake[] storage accountStakes = userStaking[msg.sender];\n        \n        // Redeem from most recent stake and go backwards in time.\n        uint256 rewardAmount = 0;\n        uint256 i = accountStakes.length;\n        while (i > 0) {\n            Stake storage userStake = accountStakes[i - 1];\n            uint256 stakeTimeSec;\n            \n            //check if current time is more than pool ending time\n            if (now > poolEndTime) {\n                stakeTimeSec = poolEndTime.sub(userStake.stakingTime);\n                if(userStake.lastWithdrawTime != 0){\n                    stakeTimeSec = poolEndTime.sub(userStake.lastWithdrawTime);\n                }\n            } else {\n                stakeTimeSec = now.sub(userStake.stakingTime);\n                if(userStake.lastWithdrawTime != 0){\n                    stakeTimeSec = now.sub(userStake.lastWithdrawTime);\n                }\n            }\n            \n            // fully redeem a past stake\n            rewardAmount = computeNewReward(rewardAmount, userStake.amount, stakeTimeSec);\n            userStake.lastWithdrawTime = now;\n            i--;\n        }\n        \n        //update user rewards info\n        userRewardInfo[msg.sender].totalWithdrawn = userRewardInfo[msg.sender].totalWithdrawn.add(rewardAmount);\n        userRewardInfo[msg.sender].lastWithdrawTime = now;\n        \n        //update total rewards withdrawn\n        rewardsWithdrawn = rewardsWithdrawn.add(rewardAmount);\n        \n        //transfer rewards\n        rewardToken.transfer(msg.sender, rewardAmount);\n        emit RewardWithdrawal(msg.sender, rewardAmount);\n    }\n    \n    //get staking details by user address\n    function getStakingAmount(address _userAddress) external constant returns (uint256 _stakedAmount) {\n        return userTotalStaking[_userAddress].totalStaking;\n    }\n    \n    //get total rewards collected by user\n    function getTotalRewardCollectedByUser(address userAddress) view external returns (uint256 _totalRewardCollected) \n    {\n        return userRewardInfo[userAddress].totalWithdrawn;\n    }\n    \n    //get total SWAP token staked in the contract\n    function getTotalStaked() external constant returns ( uint256 _totalStaked) {\n        return totalStaked;\n    }\n    \n    //get total rewards in the contract\n    function getTotalRewards() external constant returns ( uint256 _totalRewards) {\n        return totalRewards;\n    }\n    \n    //get pool details\n    function getPoolDetails() external view returns (address _baseToken, address _pairedToken, uint256 _totalRewards, uint256 _rewardsWithdrawn, uint256 _poolStartTime, uint256 _poolEndTime) {\n        return (address(tswap),address(rewardToken),totalRewards,rewardsWithdrawn,poolStartTime,poolEndTime);\n    }\n    \n    //get duration of pools\n    function getPoolDuration() external constant returns (uint256 _poolDuration) {\n        return poolDuration;\n    }\n\n    //set duration of pools by owner in seconds\n    function setPoolDuration(uint256 _poolDuration) external onlyOwner {\n        poolDuration = _poolDuration;\n        poolEndTime = poolStartTime + _poolDuration;\n        emit PoolDurationChange(_poolDuration);\n    }\n    \n    //get SWAP token address\n    function getSwapAddress() external constant returns (address _swapAddress) {\n        return address(tswap);\n    }\n    \n    //set tswap address\n    function setTswapAddress(address _address) external onlyOwner {\n        tswap = Ierc20(_address);\n    }\n    \n    //set reward token address\n    function setRewardTokenAddress(address _address) external onlyOwner {\n        rewardToken = Ierc20(_address);\n    }\n    \n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Hacken-TrustSwap-V1/code/StakingPool.sol",
        "vulnerability": "Block Dependency",
        "check": "FP",
        "response": "Answer: Yes\nDescription: The contract uses `now` (an alias for `block.timestamp`) in multiple places to determine staking times and durations, which makes the contract susceptible to block timestamp manipulation by miners."
    },
    {
        "code_segment": "contract StratAlpaca is UpgradeableOwnable, ReentrancyGuardPausable, ISimpleStrategy, Initializable {\n\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n    using SafeERC20 for IAlpacaVault;\n\n    bool public wantIsWBNB = false;\n    IERC20 public wantToken = IERC20(0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56);\n    address public uniRouterAddress = 0x05fF2B0DB69458A0750badebc4f9e13aDd608C7F;\n\n    address public wbnbAddress =\n        0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;\n\n    IFairLaunch public fairLaunch = IFairLaunch(0xA625AB01B08ce023B2a342Dbb12a16f2C8489A8F);\n    IERC20 public alpacaToken = IERC20(0x8F0528cE5eF7B51152A59745bEfDD91D97091d2F);\n    IAlpacaVault public alpacaVault = IAlpacaVault(0x7C9e73d4C71dae564d41F78d56439bB4ba87592f);\n\n    uint256 public lastHarvestBlock = 0;\n\n    address[] public alpacaToWantPath;\n\n    uint256 public poolId = 3;\n\n    address public vault;\n\n    mapping (address => bool) public keepers;\n\n    event KeepersSet(address[] keepers, bool[] states);\n\n    constructor() public {}\n\n    /*\n     * Parameters on BSC:\n     * poolId: 3\n     * fairLaunchAddress: 0xA625AB01B08ce023B2a342Dbb12a16f2C8489A8F\n     * alpacaToken: 0x8F0528cE5eF7B51152A59745bEfDD91D97091d2F\n     * alpacaVault: 0x7C9e73d4C71dae564d41F78d56439bB4ba87592f\n     * wantAddress: 0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56\n     * bnbAddress: 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c\n     * uniRouterAddress: 0x05fF2B0DB69458A0750badebc4f9e13aDd608C7F\n     */\n    function initialize(\n        uint256 _poolId,\n        address _fairLaunchAddress,\n        address _alpacaToken,\n        address _alpacaVault,\n        address _wantAddress,\n        address _wbnbAddress,\n        address _uniRouterAddress,\n        address _vault\n    )\n        external\n        initializer\n        onlyOwner\n    {\n        poolId = _poolId;\n        fairLaunch = IFairLaunch(_fairLaunchAddress);\n        alpacaToken = IERC20(_alpacaToken);\n        alpacaVault = IAlpacaVault(_alpacaVault);\n\n        wantToken = IERC20(_wantAddress);\n        wbnbAddress = _wbnbAddress;\n\n        if (_wantAddress == wbnbAddress) {\n            wantIsWBNB = true;\n            alpacaToWantPath = [_alpacaToken, wbnbAddress];\n        } else {\n            alpacaToWantPath = [_alpacaToken, wbnbAddress, _wantAddress];\n        }\n\n        uniRouterAddress = _uniRouterAddress;\n\n        wantToken.safeApprove(_alpacaVault, uint256(-1));\n        alpacaVault.safeApprove(_fairLaunchAddress, uint256(-1));\n        alpacaToken.safeApprove(uniRouterAddress, uint256(-1));\n        vault = _vault;\n    }\n\n    modifier onlyVault() {\n        require (msg.sender == vault, \"Must from vault\");\n        _;\n    }\n\n    modifier onlyVaultOrKeeper() {\n        require (msg.sender == vault || keepers[msg.sender], \"Must from vault/keeper\");\n        _;\n    }\n\n    function alpacaVaultTotalToken() public view returns (uint256) {\n        uint256 reservePool = alpacaVault.reservePool();\n        uint256 vaultDebtVal = alpacaVault.vaultDebtVal();\n        if (now > alpacaVault.lastAccrueTime()) {\n            uint256 interest = alpacaVault.pendingInterest(0);\n            uint256 toReserve = interest.mul(IVaultConfig(alpacaVault.config()).getReservePoolBps()).div(10000);\n            reservePool = reservePool.add(toReserve);\n            vaultDebtVal = vaultDebtVal.add(interest);\n        }\n        return wantToken.balanceOf(address(alpacaVault)).add(vaultDebtVal).sub(reservePool);\n    }\n    \n    function _ibDeposited() internal view returns (uint256) {\n        (uint256 ibBal,,,) = fairLaunch.userInfo(poolId, address(this));\n        return ibBal;\n    }\n\n    function totalBalance() external override view returns (uint256) {\n        uint256 ibBal = _ibDeposited();\n        return alpacaVaultTotalToken().mul(ibBal).div(alpacaVault.totalSupply());\n    }\n\n    function wantAmtToIbAmount(uint256 _wantAmt) public view returns (uint256) {\n        return _wantAmt.mul(alpacaVault.totalSupply()).div(alpacaVaultTotalToken());\n    }\n\n// SWC-114-Transaction Order Dependence: L191\n    function deposit(uint256 _wantAmt)\n        external\n        override\n        onlyVault\n        nonReentrantAndUnpaused\n    {\n        IERC20(wantToken).safeTransferFrom(\n            address(msg.sender),\n            address(this),\n            _wantAmt\n        );\n\n        alpacaVault.deposit(_wantAmt);\n        fairLaunch.deposit(address(this), poolId, alpacaVault.balanceOf(address(this)));\n    }\n\n    function withdraw(uint256 _wantAmt)\n        external\n        override\n        onlyVault\n        nonReentrantAndUnpaused\n    {\n        uint256 ibAmt = wantAmtToIbAmount(_wantAmt);\n        fairLaunch.withdraw(address(this), poolId, ibAmt);\n        alpacaVault.withdraw(alpacaVault.balanceOf(address(this)));\n\n        uint256 actualWantAmount = wantToken.balanceOf(address(this));\n        wantToken.safeTransfer(\n            address(msg.sender),\n            actualWantAmount\n        );\n    }\n\n    function _harvest(uint256 priceMin) internal {\n        if (lastHarvestBlock == block.number) {\n            return;\n        }\n\n        // Do not harvest if no token is deposited (otherwise, fairLaunch will fail)\n        if (_ibDeposited() == 0) {\n            return;\n        }\n\n        // Collect alpacaToken\n        fairLaunch.harvest(poolId);\n\n        uint256 earnedAlpacaBalance = alpacaToken.balanceOf(address(this));\n        if (earnedAlpacaBalance == 0) {\n            return;\n        }\n\n        if (alpacaToken != wantToken) {\n            IPancakeRouter02(uniRouterAddress).swapExactTokensForTokens(\n                earnedAlpacaBalance,\n                earnedAlpacaBalance.mul(priceMin).div(1e18),\n                alpacaToWantPath,\n                address(this),\n                now.add(600)\n            );\n        }\n\n        alpacaVault.deposit(IERC20(wantToken).balanceOf(address(this)));\n        fairLaunch.deposit(address(this), poolId, alpacaVault.balanceOf(address(this)));\n\n        lastHarvestBlock = block.number;\n    }\n\n    function harvest(uint256 minPrice) external override onlyVaultOrKeeper nonReentrantAndUnpaused {\n        _harvest(minPrice);\n    }\n\n    /**\n     * @dev Pauses the strat.\n     */\n    function pause(uint256 _flags) external onlyOwner {\n        _pause();\n\n        alpacaToken.safeApprove(uniRouterAddress, 0);\n        wantToken.safeApprove(uniRouterAddress, 0);\n    }\n\n    /**\n     * @dev Unpauses the strat.\n     */\n    function unpause(uint256 _flags) external onlyOwner {\n        _unpause();\n\n        alpacaToken.safeApprove(uniRouterAddress, uint256(-1));\n        wantToken.safeApprove(uniRouterAddress, uint256(-1));\n    }\n\n    function setVault(address _vault) external onlyOwner {\n        vault = _vault;\n    }\n\n    function setKeepers(address[] calldata _keepers, bool[] calldata _states) external onlyOwner {\n        uint256 n = _keepers.length;\n        for(uint256 i = 0; i < n; i++) {\n            keepers[_keepers[i]] = _states[i];\n        }\n        emit KeepersSet(_keepers, _states);\n    }\n\n    receive() external payable {}\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Inspex-StakingPool, Vault, Strategy & VotingEscrow/scientix-contract-main/contracts/vaults/StratAlpaca.sol",
        "vulnerability": "Assertion Failure",
        "check": "FP",
        "response": "Answer: No\nReason: The code does not contain any assert statements that could cause an assertion failure."
    },
    {
        "code_segment": "contract StratAlpaca is UpgradeableOwnable, ReentrancyGuardPausable, ISimpleStrategy, Initializable {\n\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n    using SafeERC20 for IAlpacaVault;\n\n    bool public wantIsWBNB = false;\n    IERC20 public wantToken = IERC20(0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56);\n    address public uniRouterAddress = 0x05fF2B0DB69458A0750badebc4f9e13aDd608C7F;\n\n    address public wbnbAddress =\n        0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;\n\n    IFairLaunch public fairLaunch = IFairLaunch(0xA625AB01B08ce023B2a342Dbb12a16f2C8489A8F);\n    IERC20 public alpacaToken = IERC20(0x8F0528cE5eF7B51152A59745bEfDD91D97091d2F);\n    IAlpacaVault public alpacaVault = IAlpacaVault(0x7C9e73d4C71dae564d41F78d56439bB4ba87592f);\n\n    uint256 public lastHarvestBlock = 0;\n\n    address[] public alpacaToWantPath;\n\n    uint256 public poolId = 3;\n\n    address public vault;\n\n    mapping (address => bool) public keepers;\n\n    event KeepersSet(address[] keepers, bool[] states);\n\n    constructor() public {}\n\n    /*\n     * Parameters on BSC:\n     * poolId: 3\n     * fairLaunchAddress: 0xA625AB01B08ce023B2a342Dbb12a16f2C8489A8F\n     * alpacaToken: 0x8F0528cE5eF7B51152A59745bEfDD91D97091d2F\n     * alpacaVault: 0x7C9e73d4C71dae564d41F78d56439bB4ba87592f\n     * wantAddress: 0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56\n     * bnbAddress: 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c\n     * uniRouterAddress: 0x05fF2B0DB69458A0750badebc4f9e13aDd608C7F\n     */\n    function initialize(\n        uint256 _poolId,\n        address _fairLaunchAddress,\n        address _alpacaToken,\n        address _alpacaVault,\n        address _wantAddress,\n        address _wbnbAddress,\n        address _uniRouterAddress,\n        address _vault\n    )\n        external\n        initializer\n        onlyOwner\n    {\n        poolId = _poolId;\n        fairLaunch = IFairLaunch(_fairLaunchAddress);\n        alpacaToken = IERC20(_alpacaToken);\n        alpacaVault = IAlpacaVault(_alpacaVault);\n\n        wantToken = IERC20(_wantAddress);\n        wbnbAddress = _wbnbAddress;\n\n        if (_wantAddress == wbnbAddress) {\n            wantIsWBNB = true;\n            alpacaToWantPath = [_alpacaToken, wbnbAddress];\n        } else {\n            alpacaToWantPath = [_alpacaToken, wbnbAddress, _wantAddress];\n        }\n\n        uniRouterAddress = _uniRouterAddress;\n\n        wantToken.safeApprove(_alpacaVault, uint256(-1));\n        alpacaVault.safeApprove(_fairLaunchAddress, uint256(-1));\n        alpacaToken.safeApprove(uniRouterAddress, uint256(-1));\n        vault = _vault;\n    }\n\n    modifier onlyVault() {\n        require (msg.sender == vault, \"Must from vault\");\n        _;\n    }\n\n    modifier onlyVaultOrKeeper() {\n        require (msg.sender == vault || keepers[msg.sender], \"Must from vault/keeper\");\n        _;\n    }\n\n    function alpacaVaultTotalToken() public view returns (uint256) {\n        uint256 reservePool = alpacaVault.reservePool();\n        uint256 vaultDebtVal = alpacaVault.vaultDebtVal();\n        if (now > alpacaVault.lastAccrueTime()) {\n            uint256 interest = alpacaVault.pendingInterest(0);\n            uint256 toReserve = interest.mul(IVaultConfig(alpacaVault.config()).getReservePoolBps()).div(10000);\n            reservePool = reservePool.add(toReserve);\n            vaultDebtVal = vaultDebtVal.add(interest);\n        }\n        return wantToken.balanceOf(address(alpacaVault)).add(vaultDebtVal).sub(reservePool);\n    }\n    \n    function _ibDeposited() internal view returns (uint256) {\n        (uint256 ibBal,,,) = fairLaunch.userInfo(poolId, address(this));\n        return ibBal;\n    }\n\n    function totalBalance() external override view returns (uint256) {\n        uint256 ibBal = _ibDeposited();\n        return alpacaVaultTotalToken().mul(ibBal).div(alpacaVault.totalSupply());\n    }\n\n    function wantAmtToIbAmount(uint256 _wantAmt) public view returns (uint256) {\n        return _wantAmt.mul(alpacaVault.totalSupply()).div(alpacaVaultTotalToken());\n    }\n\n// SWC-114-Transaction Order Dependence: L191\n    function deposit(uint256 _wantAmt)\n        external\n        override\n        onlyVault\n        nonReentrantAndUnpaused\n    {\n        IERC20(wantToken).safeTransferFrom(\n            address(msg.sender),\n            address(this),\n            _wantAmt\n        );\n\n        alpacaVault.deposit(_wantAmt);\n        fairLaunch.deposit(address(this), poolId, alpacaVault.balanceOf(address(this)));\n    }\n\n    function withdraw(uint256 _wantAmt)\n        external\n        override\n        onlyVault\n        nonReentrantAndUnpaused\n    {\n        uint256 ibAmt = wantAmtToIbAmount(_wantAmt);\n        fairLaunch.withdraw(address(this), poolId, ibAmt);\n        alpacaVault.withdraw(alpacaVault.balanceOf(address(this)));\n\n        uint256 actualWantAmount = wantToken.balanceOf(address(this));\n        wantToken.safeTransfer(\n            address(msg.sender),\n            actualWantAmount\n        );\n    }\n\n    function _harvest(uint256 priceMin) internal {\n        if (lastHarvestBlock == block.number) {\n            return;\n        }\n\n        // Do not harvest if no token is deposited (otherwise, fairLaunch will fail)\n        if (_ibDeposited() == 0) {\n            return;\n        }\n\n        // Collect alpacaToken\n        fairLaunch.harvest(poolId);\n\n        uint256 earnedAlpacaBalance = alpacaToken.balanceOf(address(this));\n        if (earnedAlpacaBalance == 0) {\n            return;\n        }\n\n        if (alpacaToken != wantToken) {\n            IPancakeRouter02(uniRouterAddress).swapExactTokensForTokens(\n                earnedAlpacaBalance,\n                earnedAlpacaBalance.mul(priceMin).div(1e18),\n                alpacaToWantPath,\n                address(this),\n                now.add(600)\n            );\n        }\n\n        alpacaVault.deposit(IERC20(wantToken).balanceOf(address(this)));\n        fairLaunch.deposit(address(this), poolId, alpacaVault.balanceOf(address(this)));\n\n        lastHarvestBlock = block.number;\n    }\n\n    function harvest(uint256 minPrice) external override onlyVaultOrKeeper nonReentrantAndUnpaused {\n        _harvest(minPrice);\n    }\n\n    /**\n     * @dev Pauses the strat.\n     */\n    function pause(uint256 _flags) external onlyOwner {\n        _pause();\n\n        alpacaToken.safeApprove(uniRouterAddress, 0);\n        wantToken.safeApprove(uniRouterAddress, 0);\n    }\n\n    /**\n     * @dev Unpauses the strat.\n     */\n    function unpause(uint256 _flags) external onlyOwner {\n        _unpause();\n\n        alpacaToken.safeApprove(uniRouterAddress, uint256(-1));\n        wantToken.safeApprove(uniRouterAddress, uint256(-1));\n    }\n\n    function setVault(address _vault) external onlyOwner {\n        vault = _vault;\n    }\n\n    function setKeepers(address[] calldata _keepers, bool[] calldata _states) external onlyOwner {\n        uint256 n = _keepers.length;\n        for(uint256 i = 0; i < n; i++) {\n            keepers[_keepers[i]] = _states[i];\n        }\n        emit KeepersSet(_keepers, _states);\n    }\n\n    receive() external payable {}\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Inspex-StakingPool, Vault, Strategy & VotingEscrow/scientix-contract-main/contracts/vaults/StratAlpaca.sol",
        "vulnerability": "Block Dependency",
        "check": "FP",
        "response": "Answer: No\nReason: The contract does not use block numbers or block timestamps in a way that can be exploited."
    },
    {
        "code_segment": "contract StratAlpaca is UpgradeableOwnable, ReentrancyGuardPausable, ISimpleStrategy, Initializable {\n\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n    using SafeERC20 for IAlpacaVault;\n\n    bool public wantIsWBNB = false;\n    IERC20 public wantToken = IERC20(0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56);\n    address public uniRouterAddress = 0x05fF2B0DB69458A0750badebc4f9e13aDd608C7F;\n\n    address public wbnbAddress =\n        0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;\n\n    IFairLaunch public fairLaunch = IFairLaunch(0xA625AB01B08ce023B2a342Dbb12a16f2C8489A8F);\n    IERC20 public alpacaToken = IERC20(0x8F0528cE5eF7B51152A59745bEfDD91D97091d2F);\n    IAlpacaVault public alpacaVault = IAlpacaVault(0x7C9e73d4C71dae564d41F78d56439bB4ba87592f);\n\n    uint256 public lastHarvestBlock = 0;\n\n    address[] public alpacaToWantPath;\n\n    uint256 public poolId = 3;\n\n    address public vault;\n\n    mapping (address => bool) public keepers;\n\n    event KeepersSet(address[] keepers, bool[] states);\n\n    constructor() public {}\n\n    /*\n     * Parameters on BSC:\n     * poolId: 3\n     * fairLaunchAddress: 0xA625AB01B08ce023B2a342Dbb12a16f2C8489A8F\n     * alpacaToken: 0x8F0528cE5eF7B51152A59745bEfDD91D97091d2F\n     * alpacaVault: 0x7C9e73d4C71dae564d41F78d56439bB4ba87592f\n     * wantAddress: 0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56\n     * bnbAddress: 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c\n     * uniRouterAddress: 0x05fF2B0DB69458A0750badebc4f9e13aDd608C7F\n     */\n    function initialize(\n        uint256 _poolId,\n        address _fairLaunchAddress,\n        address _alpacaToken,\n        address _alpacaVault,\n        address _wantAddress,\n        address _wbnbAddress,\n        address _uniRouterAddress,\n        address _vault\n    )\n        external\n        initializer\n        onlyOwner\n    {\n        poolId = _poolId;\n        fairLaunch = IFairLaunch(_fairLaunchAddress);\n        alpacaToken = IERC20(_alpacaToken);\n        alpacaVault = IAlpacaVault(_alpacaVault);\n\n        wantToken = IERC20(_wantAddress);\n        wbnbAddress = _wbnbAddress;\n\n        if (_wantAddress == wbnbAddress) {\n            wantIsWBNB = true;\n            alpacaToWantPath = [_alpacaToken, wbnbAddress];\n        } else {\n            alpacaToWantPath = [_alpacaToken, wbnbAddress, _wantAddress];\n        }\n\n        uniRouterAddress = _uniRouterAddress;\n\n        wantToken.safeApprove(_alpacaVault, uint256(-1));\n        alpacaVault.safeApprove(_fairLaunchAddress, uint256(-1));\n        alpacaToken.safeApprove(uniRouterAddress, uint256(-1));\n        vault = _vault;\n    }\n\n    modifier onlyVault() {\n        require (msg.sender == vault, \"Must from vault\");\n        _;\n    }\n\n    modifier onlyVaultOrKeeper() {\n        require (msg.sender == vault || keepers[msg.sender], \"Must from vault/keeper\");\n        _;\n    }\n\n    function alpacaVaultTotalToken() public view returns (uint256) {\n        uint256 reservePool = alpacaVault.reservePool();\n        uint256 vaultDebtVal = alpacaVault.vaultDebtVal();\n        if (now > alpacaVault.lastAccrueTime()) {\n            uint256 interest = alpacaVault.pendingInterest(0);\n            uint256 toReserve = interest.mul(IVaultConfig(alpacaVault.config()).getReservePoolBps()).div(10000);\n            reservePool = reservePool.add(toReserve);\n            vaultDebtVal = vaultDebtVal.add(interest);\n        }\n        return wantToken.balanceOf(address(alpacaVault)).add(vaultDebtVal).sub(reservePool);\n    }\n    \n    function _ibDeposited() internal view returns (uint256) {\n        (uint256 ibBal,,,) = fairLaunch.userInfo(poolId, address(this));\n        return ibBal;\n    }\n\n    function totalBalance() external override view returns (uint256) {\n        uint256 ibBal = _ibDeposited();\n        return alpacaVaultTotalToken().mul(ibBal).div(alpacaVault.totalSupply());\n    }\n\n    function wantAmtToIbAmount(uint256 _wantAmt) public view returns (uint256) {\n        return _wantAmt.mul(alpacaVault.totalSupply()).div(alpacaVaultTotalToken());\n    }\n\n// SWC-114-Transaction Order Dependence: L191\n    function deposit(uint256 _wantAmt)\n        external\n        override\n        onlyVault\n        nonReentrantAndUnpaused\n    {\n        IERC20(wantToken).safeTransferFrom(\n            address(msg.sender),\n            address(this),\n            _wantAmt\n        );\n\n        alpacaVault.deposit(_wantAmt);\n        fairLaunch.deposit(address(this), poolId, alpacaVault.balanceOf(address(this)));\n    }\n\n    function withdraw(uint256 _wantAmt)\n        external\n        override\n        onlyVault\n        nonReentrantAndUnpaused\n    {\n        uint256 ibAmt = wantAmtToIbAmount(_wantAmt);\n        fairLaunch.withdraw(address(this), poolId, ibAmt);\n        alpacaVault.withdraw(alpacaVault.balanceOf(address(this)));\n\n        uint256 actualWantAmount = wantToken.balanceOf(address(this));\n        wantToken.safeTransfer(\n            address(msg.sender),\n            actualWantAmount\n        );\n    }\n\n    function _harvest(uint256 priceMin) internal {\n        if (lastHarvestBlock == block.number) {\n            return;\n        }\n\n        // Do not harvest if no token is deposited (otherwise, fairLaunch will fail)\n        if (_ibDeposited() == 0) {\n            return;\n        }\n\n        // Collect alpacaToken\n        fairLaunch.harvest(poolId);\n\n        uint256 earnedAlpacaBalance = alpacaToken.balanceOf(address(this));\n        if (earnedAlpacaBalance == 0) {\n            return;\n        }\n\n        if (alpacaToken != wantToken) {\n            IPancakeRouter02(uniRouterAddress).swapExactTokensForTokens(\n                earnedAlpacaBalance,\n                earnedAlpacaBalance.mul(priceMin).div(1e18),\n                alpacaToWantPath,\n                address(this),\n                now.add(600)\n            );\n        }\n\n        alpacaVault.deposit(IERC20(wantToken).balanceOf(address(this)));\n        fairLaunch.deposit(address(this), poolId, alpacaVault.balanceOf(address(this)));\n\n        lastHarvestBlock = block.number;\n    }\n\n    function harvest(uint256 minPrice) external override onlyVaultOrKeeper nonReentrantAndUnpaused {\n        _harvest(minPrice);\n    }\n\n    /**\n     * @dev Pauses the strat.\n     */\n    function pause(uint256 _flags) external onlyOwner {\n        _pause();\n\n        alpacaToken.safeApprove(uniRouterAddress, 0);\n        wantToken.safeApprove(uniRouterAddress, 0);\n    }\n\n    /**\n     * @dev Unpauses the strat.\n     */\n    function unpause(uint256 _flags) external onlyOwner {\n        _unpause();\n\n        alpacaToken.safeApprove(uniRouterAddress, uint256(-1));\n        wantToken.safeApprove(uniRouterAddress, uint256(-1));\n    }\n\n    function setVault(address _vault) external onlyOwner {\n        vault = _vault;\n    }\n\n    function setKeepers(address[] calldata _keepers, bool[] calldata _states) external onlyOwner {\n        uint256 n = _keepers.length;\n        for(uint256 i = 0; i < n; i++) {\n            keepers[_keepers[i]] = _states[i];\n        }\n        emit KeepersSet(_keepers, _states);\n    }\n\n    receive() external payable {}\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Inspex-StakingPool, Vault, Strategy & VotingEscrow/scientix-contract-main/contracts/vaults/StratAlpaca.sol",
        "vulnerability": "Assertion Failure",
        "check": "FP",
        "response": "Answer: No\nReason: The provided code does not contain assertion statements that could lead to an assertion failure vulnerability."
    },
    {
        "code_segment": "contract SHIELDToken is Context, IBEP20, Ownable {\n  using SafeMath for uint256;\n  mapping (address => uint256) private _balances;\n  mapping (address => mapping (address => uint256)) private _allowances;\n  uint256 private _totalSupply;\n  uint8 public _decimals;\n  string public _symbol;\n  string public _name;\n  constructor() {\n    _name = \"Shield Protocol\";\n    _symbol = \"SHIELD\";\n    _decimals = 18;\n    _totalSupply = 1000000  * (10 ** uint256(_decimals));\n    _balances[msg.sender] = _totalSupply;\n    emit Transfer(address(0), msg.sender, _totalSupply);\n  }\n  /**\n   * @dev Returns the bep token owner.\n   */\n  function getOwner() external view override returns (address) {\n    return owner();\n  }\n  /**\n   * @dev Returns the token decimals.\n   */\n  //  SWC-135-Code With No Effects: L332 - L346\n  function decimals() external view override returns (uint256) {\n    return _decimals;\n  }\n  /**\n   * @dev Returns the token symbol.\n   */\n  function symbol() external view override returns (string memory) {\n    return _symbol;\n  }\n  /**\n  * @dev Returns the token name.\n  */\n  function name() external view override returns (string memory) {\n    return _name;\n  }\n  /**\n   * @dev See {BEP20-totalSupply}.\n   */\n  function totalSupply() external view override returns (uint256) {\n    return _totalSupply;\n  }\n  /**\n   * @dev See {BEP20-balanceOf}.\n   */\n  function balanceOf(address account) external view override returns (uint256) {\n    return _balances[account];\n  }\n  /**\n   * @dev See {BEP20-transfer}.\n   *\n   * Requirements:\n   *\n   * - `recipient` cannot be the zero address.\n   * - the caller must have a balance of at least `amount`.\n   */\n  function transfer(address recipient, uint256 amount) external override returns (bool) {\n    _transfer(_msgSender(), recipient, amount);\n    return true;\n  }\n  /**\n   * @dev See {BEP20-allowance}.\n   */\n  function allowance(address owner, address spender) external view override returns (uint256) {\n    return _allowances[owner][spender];\n  }\n  /**\n   * @dev See {BEP20-approve}.\n   *\n   * Requirements:\n   *\n   * - `spender` cannot be the zero address.\n   */\n  function approve(address spender, uint256 amount) external override returns (bool) {\n    _approve(_msgSender(), spender, amount);\n    return true;\n  }\n  /**\n   * @dev See {BEP20-transferFrom}.\n   *\n   * Emits an {Approval} event indicating the updated allowance. This is not\n   * required by the EIP. See the note at the beginning of {BEP20};\n   *\n   * Requirements:\n   * - `sender` and `recipient` cannot be the zero address.\n   * - `sender` must have a balance of at least `amount`.\n   * - the caller must have allowance for `sender`'s tokens of at least\n   * `amount`.\n   */\n  function transferFrom(address sender, address recipient, uint256 amount) external override returns (bool) {\n    _transfer(sender, recipient, amount);\n    _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"BEP20: transfer amount exceeds allowance\"));\n    return true;\n  }\n  /**\n   * @dev Atomically increases the allowance granted to `spender` by the caller.\n   *\n   * This is an alternative to {approve} that can be used as a mitigation for\n   * problems described in {BEP20-approve}.\n   *\n   * Emits an {Approval} event indicating the updated allowance.\n   *\n   * Requirements:\n   *\n   * - `spender` cannot be the zero address.\n   */\n  function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n    _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n    return true;\n  }\n  /**\n   * @dev Atomically decreases the allowance granted to `spender` by the caller.\n   *\n   * This is an alternative to {approve} that can be used as a mitigation for\n   * problems described in {BEP20-approve}.\n   *\n   * Emits an {Approval} event indicating the updated allowance.\n   *\n   * Requirements:\n   *\n   * - `spender` cannot be the zero address.\n   * - `spender` must have allowance for the caller of at least\n   * `subtractedValue`.\n   */\n  function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n    _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"BEP20: decreased allowance below zero\"));\n    return true;\n  }\n  /**\n   * @dev Moves tokens `amount` from `sender` to `recipient`.\n   *\n   * This is internal function is equivalent to {transfer}, and can be used to\n   * e.g. implement automatic token fees, slashing mechanisms, etc.\n   *\n   * Emits a {Transfer} event.\n   *\n   * Requirements:\n   *\n   * - `sender` cannot be the zero address.\n   * - `recipient` cannot be the zero address.\n   * - `sender` must have a balance of at least `amount`.\n   */\n  function _transfer(address sender, address recipient, uint256 amount) internal {\n    require(sender != address(0), \"BEP20: transfer from the zero address\");\n    require(recipient != address(0), \"BEP20: transfer to the zero address\");\n    _balances[sender] = _balances[sender].sub(amount, \"BEP20: transfer amount exceeds balance\");\n    _balances[recipient] = _balances[recipient].add(amount);\n    emit Transfer(sender, recipient, amount);\n  }\n  /**\n   * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\n   *\n   * This is internal function is equivalent to `approve`, and can be used to\n   * e.g. set automatic allowances for certain subsystems, etc.\n   *\n   * Emits an {Approval} event.\n   *\n   * Requirements:\n   *\n   * - `owner` cannot be the zero address.\n   * - `spender` cannot be the zero address.\n   */\n  function _approve(address owner, address spender, uint256 amount) internal {\n    require(owner != address(0), \"BEP20: approve from the zero address\");\n    require(spender != address(0), \"BEP20: approve to the zero address\");\n    _allowances[owner][spender] = amount;\n    emit Approval(owner, spender, amount);\n  }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Callisto_Network-Shield Protocol Token (SHIELD) Security Audit/smart-contract-f5c1a5d77c158f84889b65a4070f7b80c3cf6898/BinanceSmartChain_SHIELD.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No\nReason: The contract uses the SafeMath library which prevents integer overflow."
    },
    {
        "code_segment": "contract zAuctionAccountant {\n    address public zauction;\n    address public admin;\n    mapping(address => uint256) public ethbalance;\n\n    event Deposited(address indexed depositer, uint256 amount);\n    event Withdrew(address indexed withrawer, uint256 amount);\n    event zDeposited(address indexed depositer, uint256 amount);\n    event zWithdrew(address indexed withrawer, uint256 amount);\n    event zExchanged(address indexed from, address indexed to, uint256 amount);\n    event ZauctionSet(address);\n    event AdminSet(address, address);\n    \n    constructor(){\n        admin = msg.sender;\n    }\n\n    modifier onlyZauction(){\n        require(msg.sender == zauction, 'zAuctionAccountant: sender is not zauction contract');\n        _;\n    }\n    modifier onlyAdmin(){\n        require(msg.sender == admin, 'zAuctionAccountant: sender is not admin');\n        _;\n    }\n    \n    function Deposit() external payable {\n        ethbalance[msg.sender] = SafeMath.add(ethbalance[msg.sender], msg.value);\n        emit Deposited(msg.sender, msg.value);\n    }\n\n    function Withdraw(uint256 amount) external {\n        ethbalance[msg.sender] = SafeMath.sub(ethbalance[msg.sender], amount);\n        payable(msg.sender).transfer(amount);\n        emit Withdrew(msg.sender, amount);\n    }\n    // SWC-135-Code With No Effects: L44-52\n    function zDeposit(address to) external payable onlyZauction {\n        ethbalance[to] = SafeMath.add(ethbalance[to], msg.value);\n        emit zDeposited(to, msg.value);\n    }\n\n    function zWithdraw(address from, uint256 amount) external onlyZauction {\n        ethbalance[from] = SafeMath.sub(ethbalance[from], amount);\n        emit zWithdrew(from, amount);\n    }\n\n    function Exchange(address from, address to, uint256 amount) external onlyZauction {\n        ethbalance[from] = SafeMath.sub(ethbalance[from], amount);\n        ethbalance[to] = SafeMath.add(ethbalance[to], amount);\n        emit zExchanged(from, to, amount);\n    } \n    // SWC-114-Transaction Order Dependence: L60-68\n    function SetZauction(address zauctionaddress) external onlyAdmin{\n        zauction = zauctionaddress;\n        emit ZauctionSet(zauctionaddress);\n    }\n\n    function SetAdmin(address newadmin) external onlyAdmin{\n        admin = newadmin;\n        emit AdminSet(msg.sender, newadmin);\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/consensys-Zer0_zAuction/zAuction-50d3b6ce6d7ee00e7181d5b2a9a2eedcdd3fdb72/contracts/zAuctionAccountant.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No\nReason: The contract uses SafeMath library functions which prevent integer overflow and underflow.\n\nAnswer: No\nReason: The contract uses SafeMath library functions which prevent integer overflow and underflow.\n\nAnswer: No\nReason: The contract uses SafeMath library functions which prevent integer overflow and underflow.\n\nAnswer: No\nReason: The contract uses SafeMath library functions which prevent integer overflow and underflow.\n\nAnswer: No\nReason: The contract uses SafeMath library functions which prevent integer overflow and underflow."
    },
    {
        "code_segment": "contract zAuctionAccountant {\n    address public zauction;\n    address public admin;\n    mapping(address => uint256) public ethbalance;\n\n    event Deposited(address indexed depositer, uint256 amount);\n    event Withdrew(address indexed withrawer, uint256 amount);\n    event zDeposited(address indexed depositer, uint256 amount);\n    event zWithdrew(address indexed withrawer, uint256 amount);\n    event zExchanged(address indexed from, address indexed to, uint256 amount);\n    event ZauctionSet(address);\n    event AdminSet(address, address);\n    \n    constructor(){\n        admin = msg.sender;\n    }\n\n    modifier onlyZauction(){\n        require(msg.sender == zauction, 'zAuctionAccountant: sender is not zauction contract');\n        _;\n    }\n    modifier onlyAdmin(){\n        require(msg.sender == admin, 'zAuctionAccountant: sender is not admin');\n        _;\n    }\n    \n    function Deposit() external payable {\n        ethbalance[msg.sender] = SafeMath.add(ethbalance[msg.sender], msg.value);\n        emit Deposited(msg.sender, msg.value);\n    }\n\n    function Withdraw(uint256 amount) external {\n        ethbalance[msg.sender] = SafeMath.sub(ethbalance[msg.sender], amount);\n        payable(msg.sender).transfer(amount);\n        emit Withdrew(msg.sender, amount);\n    }\n    // SWC-135-Code With No Effects: L44-52\n    function zDeposit(address to) external payable onlyZauction {\n        ethbalance[to] = SafeMath.add(ethbalance[to], msg.value);\n        emit zDeposited(to, msg.value);\n    }\n\n    function zWithdraw(address from, uint256 amount) external onlyZauction {\n        ethbalance[from] = SafeMath.sub(ethbalance[from], amount);\n        emit zWithdrew(from, amount);\n    }\n\n    function Exchange(address from, address to, uint256 amount) external onlyZauction {\n        ethbalance[from] = SafeMath.sub(ethbalance[from], amount);\n        ethbalance[to] = SafeMath.add(ethbalance[to], amount);\n        emit zExchanged(from, to, amount);\n    } \n    // SWC-114-Transaction Order Dependence: L60-68\n    function SetZauction(address zauctionaddress) external onlyAdmin{\n        zauction = zauctionaddress;\n        emit ZauctionSet(zauctionaddress);\n    }\n\n    function SetAdmin(address newadmin) external onlyAdmin{\n        admin = newadmin;\n        emit AdminSet(msg.sender, newadmin);\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/consensys-Zer0_zAuction/zAuction-50d3b6ce6d7ee00e7181d5b2a9a2eedcdd3fdb72/contracts/zAuctionAccountant.sol",
        "vulnerability": "Transaction Order Dependency",
        "check": "FP",
        "response": "Answer: Yes\nDescription: The SetZauction function allows the admin to set the zauction address, which can impact the order of execution and be exploited to gain an unfair advantage."
    },
    {
        "code_segment": "contract zAuctionAccountant {\n    address public zauction;\n    address public admin;\n    mapping(address => uint256) public ethbalance;\n\n    event Deposited(address indexed depositer, uint256 amount);\n    event Withdrew(address indexed withrawer, uint256 amount);\n    event zDeposited(address indexed depositer, uint256 amount);\n    event zWithdrew(address indexed withrawer, uint256 amount);\n    event zExchanged(address indexed from, address indexed to, uint256 amount);\n    event ZauctionSet(address);\n    event AdminSet(address, address);\n    \n    constructor(){\n        admin = msg.sender;\n    }\n\n    modifier onlyZauction(){\n        require(msg.sender == zauction, 'zAuctionAccountant: sender is not zauction contract');\n        _;\n    }\n    modifier onlyAdmin(){\n        require(msg.sender == admin, 'zAuctionAccountant: sender is not admin');\n        _;\n    }\n    \n    function Deposit() external payable {\n        ethbalance[msg.sender] = SafeMath.add(ethbalance[msg.sender], msg.value);\n        emit Deposited(msg.sender, msg.value);\n    }\n\n    function Withdraw(uint256 amount) external {\n        ethbalance[msg.sender] = SafeMath.sub(ethbalance[msg.sender], amount);\n        payable(msg.sender).transfer(amount);\n        emit Withdrew(msg.sender, amount);\n    }\n    // SWC-135-Code With No Effects: L44-52\n    function zDeposit(address to) external payable onlyZauction {\n        ethbalance[to] = SafeMath.add(ethbalance[to], msg.value);\n        emit zDeposited(to, msg.value);\n    }\n\n    function zWithdraw(address from, uint256 amount) external onlyZauction {\n        ethbalance[from] = SafeMath.sub(ethbalance[from], amount);\n        emit zWithdrew(from, amount);\n    }\n\n    function Exchange(address from, address to, uint256 amount) external onlyZauction {\n        ethbalance[from] = SafeMath.sub(ethbalance[from], amount);\n        ethbalance[to] = SafeMath.add(ethbalance[to], amount);\n        emit zExchanged(from, to, amount);\n    } \n    // SWC-114-Transaction Order Dependence: L60-68\n    function SetZauction(address zauctionaddress) external onlyAdmin{\n        zauction = zauctionaddress;\n        emit ZauctionSet(zauctionaddress);\n    }\n\n    function SetAdmin(address newadmin) external onlyAdmin{\n        admin = newadmin;\n        emit AdminSet(msg.sender, newadmin);\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/consensys-Zer0_zAuction/zAuction-50d3b6ce6d7ee00e7181d5b2a9a2eedcdd3fdb72/contracts/zAuctionAccountant.sol",
        "vulnerability": "Transaction Order Dependency",
        "check": "FP",
        "response": "Answer: Yes\nDescription: The SetZauction function allows the admin to change the address of the zauction contract, which could result in race conditions if multiple transactions attempt to set or interact with this contract in quick succession."
    },
    {
        "code_segment": "contract zAuctionAccountant {\n    address public zauction;\n    address public admin;\n    mapping(address => uint256) public ethbalance;\n\n    event Deposited(address indexed depositer, uint256 amount);\n    event Withdrew(address indexed withrawer, uint256 amount);\n    event zDeposited(address indexed depositer, uint256 amount);\n    event zWithdrew(address indexed withrawer, uint256 amount);\n    event zExchanged(address indexed from, address indexed to, uint256 amount);\n    event ZauctionSet(address);\n    event AdminSet(address, address);\n    \n    constructor(){\n        admin = msg.sender;\n    }\n\n    modifier onlyZauction(){\n        require(msg.sender == zauction, 'zAuctionAccountant: sender is not zauction contract');\n        _;\n    }\n    modifier onlyAdmin(){\n        require(msg.sender == admin, 'zAuctionAccountant: sender is not admin');\n        _;\n    }\n    \n    function Deposit() external payable {\n        ethbalance[msg.sender] = SafeMath.add(ethbalance[msg.sender], msg.value);\n        emit Deposited(msg.sender, msg.value);\n    }\n\n    function Withdraw(uint256 amount) external {\n        ethbalance[msg.sender] = SafeMath.sub(ethbalance[msg.sender], amount);\n        payable(msg.sender).transfer(amount);\n        emit Withdrew(msg.sender, amount);\n    }\n    // SWC-135-Code With No Effects: L44-52\n    function zDeposit(address to) external payable onlyZauction {\n        ethbalance[to] = SafeMath.add(ethbalance[to], msg.value);\n        emit zDeposited(to, msg.value);\n    }\n\n    function zWithdraw(address from, uint256 amount) external onlyZauction {\n        ethbalance[from] = SafeMath.sub(ethbalance[from], amount);\n        emit zWithdrew(from, amount);\n    }\n\n    function Exchange(address from, address to, uint256 amount) external onlyZauction {\n        ethbalance[from] = SafeMath.sub(ethbalance[from], amount);\n        ethbalance[to] = SafeMath.add(ethbalance[to], amount);\n        emit zExchanged(from, to, amount);\n    } \n    // SWC-114-Transaction Order Dependence: L60-68\n    function SetZauction(address zauctionaddress) external onlyAdmin{\n        zauction = zauctionaddress;\n        emit ZauctionSet(zauctionaddress);\n    }\n\n    function SetAdmin(address newadmin) external onlyAdmin{\n        admin = newadmin;\n        emit AdminSet(msg.sender, newadmin);\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/consensys-Zer0_zAuction/zAuction-50d3b6ce6d7ee00e7181d5b2a9a2eedcdd3fdb72/contracts/zAuctionAccountant.sol",
        "vulnerability": "Transaction Order Dependency",
        "check": "FP",
        "response": "Answer: Yes\nDescription: The function `SetZauction` enables the admin to change the `zauction` address, which may allow manipulation of the sequence of transactions depending on when the address is changed."
    },
    {
        "code_segment": "contract BaseFilterV1 is InitializableOwnable, ReentrancyGuard {\n    using SafeMath for uint256;\n\n    //=================== Storage ===================\n    address public _NFT_COLLECTION_;\n    uint256 public _NFT_ID_START_;\n    uint256 public _NFT_ID_END_ = uint256(-1);\n\n    //tokenId => isRegistered\n    mapping(uint256 => bool) public _SPREAD_IDS_REGISTRY_;\n\n    //tokenId => amount\n    mapping(uint256 => uint256) public _NFT_RESERVE_;\n\n    uint256[] public _NFT_IDS_;\n    uint256 public _TOTAL_NFT_AMOUNT_;\n    uint256 public _MAX_NFT_AMOUNT_;\n    uint256 public _MIN_NFT_AMOUNT_;\n\n    // GS -> Geometric sequence\n    // CR -> Common Ratio\n\n    //For Deposit NFT INto Pool\n    uint256 public _GS_START_IN_;\n    uint256 public _CR_IN_;\n    bool public _NFT_IN_TOGGLE_ = false;\n\n    //For NFT Random OUT from Pool\n    uint256 public _GS_START_RANDOM_OUT_;\n    uint256 public _CR_RANDOM_OUT_;\n    bool public _NFT_RANDOM_OUT_TOGGLE_ = false;\n\n    //For NFT Target OUT from Pool\n    uint256 public _GS_START_TARGET_OUT_;\n    uint256 public _CR_TARGET_OUT_;\n    bool public _NFT_TARGET_OUT_TOGGLE_ = false;\n\n    modifier onlySuperOwner() {\n        require(msg.sender == IFilterAdmin(_OWNER_)._OWNER_(), \"ONLY_SUPER_OWNER\");\n        _;\n    }\n\n    //==================== Query Prop ==================\n\n    function isNFTValid(address nftCollectionAddress, uint256 nftId) external view returns (bool) {\n        if (nftCollectionAddress == _NFT_COLLECTION_) {\n            return isNFTIDValid(nftId);\n        } else {\n            return false;\n        }\n    }\n\n    function isNFTIDValid(uint256 nftId) public view returns (bool) {\n        return (nftId >= _NFT_ID_START_ && nftId <= _NFT_ID_END_) || _SPREAD_IDS_REGISTRY_[nftId];\n    }\n\n    function getAvaliableNFTInAmount() public view returns (uint256) {\n        if (_MAX_NFT_AMOUNT_ <= _TOTAL_NFT_AMOUNT_) {\n            return 0;\n        } else {\n            return _MAX_NFT_AMOUNT_ - _TOTAL_NFT_AMOUNT_;\n        }\n    }\n\n    function getAvaliableNFTOutAmount() public view returns (uint256) {\n        if (_TOTAL_NFT_AMOUNT_ <= _MIN_NFT_AMOUNT_) {\n            return 0;\n        } else {\n            return _TOTAL_NFT_AMOUNT_ - _MIN_NFT_AMOUNT_;\n        }\n    }\n\n    function getNFTIndexById(uint256 tokenId) public view returns (uint256) {\n        uint256 i = 0;\n        for (; i < _NFT_IDS_.length; i++) {\n            if (_NFT_IDS_[i] == tokenId) break;\n        }\n        require(i < _NFT_IDS_.length, \"TOKEN_ID_NOT_EXSIT\");\n        return i;\n    }\n\n    //==================== Query Price ==================\n\n    function queryNFTIn(uint256 NFTInAmount)\n        public\n        view\n        returns (\n            uint256 rawReceive, \n            uint256 received\n        )\n    {\n        require(NFTInAmount <= getAvaliableNFTInAmount(), \"EXCEDD_IN_AMOUNT\");\n        rawReceive = _geometricCalc(\n            _GS_START_IN_,\n            _CR_IN_,\n            _TOTAL_NFT_AMOUNT_,\n            _TOTAL_NFT_AMOUNT_ + NFTInAmount\n        );\n        (,, received) = IFilterAdmin(_OWNER_).queryMintFee(rawReceive);\n    }\n\n    function queryNFTTargetOut(uint256 NFTOutAmount)\n        public\n        view\n        returns (\n            uint256 rawPay, \n            uint256 pay\n        )\n    {\n        require(NFTOutAmount <= getAvaliableNFTOutAmount(), \"EXCEED_OUT_AMOUNT\");\n        rawPay = _geometricCalc(\n            _GS_START_TARGET_OUT_,\n            _CR_TARGET_OUT_,\n            _TOTAL_NFT_AMOUNT_ - NFTOutAmount,\n            _TOTAL_NFT_AMOUNT_\n        );\n        (,, pay) = IFilterAdmin(_OWNER_).queryBurnFee(rawPay);\n    }\n\n    function queryNFTRandomOut(uint256 NFTOutAmount)\n        public\n        view\n        returns (\n            uint256 rawPay, \n            uint256 pay\n        )\n    {\n        require(NFTOutAmount <= getAvaliableNFTOutAmount(), \"EXCEED_OUT_AMOUNT\");\n        rawPay = _geometricCalc(\n            _GS_START_RANDOM_OUT_,\n            _CR_RANDOM_OUT_,\n            _TOTAL_NFT_AMOUNT_ - NFTOutAmount,\n            _TOTAL_NFT_AMOUNT_\n        );\n        (,, pay) = IFilterAdmin(_OWNER_).queryBurnFee(rawPay);\n    }\n\n    // ============ Math =============\n\n    function _geometricCalc(\n        uint256 a1,\n        uint256 q,\n        uint256 start,\n        uint256 end\n    ) internal view returns (uint256) {\n        if (q == DecimalMath.ONE) {\n            return end.sub(start).mul(a1);\n        }\n        //Sn=a1*(q^n-1)/(q-1)\n        //Sn-Sm = a1*(q^n-q^m)/(q-1)\n\n        //q^n\n        uint256 qn = DecimalMath.powFloor(q, end);\n        //q^m\n        uint256 qm = DecimalMath.powFloor(q, start);\n        return a1.mul(qn.sub(qm)).div(q.sub(DecimalMath.ONE));\n    }\n    // SWC-120-Weak Sources of Randomness from Chain Attributes: L175\n    function _getRandomNum() public view returns (uint256 randomNum) {\n        randomNum = uint256(\n            keccak256(abi.encodePacked(tx.origin, blockhash(block.number - 1), gasleft()))\n        );\n    }\n\n    // ================= Ownable ================\n\n    function changeNFTInPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) external onlySuperOwner {\n        _changeNFTInPrice(newGsStart, newCr, toggleFlag);\n    }\n\n    function _changeNFTInPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) internal {\n        require(newCr > DecimalMath.ONE, \"CR_INVALID\");\n        _GS_START_IN_ = newGsStart;\n        _CR_IN_ = newCr;\n        _NFT_IN_TOGGLE_ = true;\n    }\n\n    function changeNFTRandomInPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) external onlySuperOwner {\n        _changeNFTRandomInPrice(newGsStart, newCr, toggleFlag);\n    }\n\n    function _changeNFTRandomInPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) internal {\n        require(newCr > DecimalMath.ONE, \"CR_INVALID\");\n        _GS_START_RANDOM_OUT_ = newGsStart;\n        _CR_RANDOM_OUT_ = newCr;\n        _NFT_RANDOM_OUT_TOGGLE_ = true;\n    }\n\n    function changeNFTTargetOutPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) external onlySuperOwner {\n        _changeNFTTargetOutPrice(newGsStart, newCr, toggleFlag);\n    }\n\n    function _changeNFTTargetOutPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) internal {\n        require(newCr > DecimalMath.ONE, \"CR_INVALID\");\n        _GS_START_TARGET_OUT_ = newGsStart;\n        _CR_TARGET_OUT_ = newCr;\n        _NFT_TARGET_OUT_TOGGLE_ = true;\n    }\n\n    function changeNFTAmountRange(uint256 maxNFTAmount, uint256 minNFTAmount)\n        external\n        onlySuperOwner\n    {\n        _changeNFTAmountRange(maxNFTAmount, minNFTAmount);\n    }\n\n    function _changeNFTAmountRange(uint256 maxNFTAmount, uint256 minNFTAmount) internal {\n        require(maxNFTAmount >= minNFTAmount, \"AMOUNT_INVALID\");\n        _MAX_NFT_AMOUNT_ = maxNFTAmount;\n        _MIN_NFT_AMOUNT_ = minNFTAmount;\n    }\n\n    function changeTokenIdRange(uint256 nftIdStart, uint256 nftIdEnd) external onlySuperOwner {\n        _changeTokenIdRange(nftIdStart, nftIdEnd);\n    }\n\n    function _changeTokenIdRange(uint256 nftIdStart, uint256 nftIdEnd) internal {\n        require(nftIdStart <= nftIdEnd, \"TOKEN_RANGE_INVALID\");\n\n        _NFT_ID_START_ = nftIdStart;\n        _NFT_ID_END_ = nftIdEnd;\n    }\n\n    function changeTokenIdMap(uint256[] memory tokenIds, bool[] memory isRegistered)\n        external\n        onlySuperOwner\n    {\n        _changeTokenIdMap(tokenIds, isRegistered);\n    }\n\n    function _changeTokenIdMap(uint256[] memory tokenIds, bool[] memory isRegistered) internal {\n        require(tokenIds.length == isRegistered.length, \"PARAM_NOT_MATCH\");\n\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            _SPREAD_IDS_REGISTRY_[tokenIds[i]] = isRegistered[i];\n        }\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/SlowMist-DODO-NFTPool Smart Contract Security Audit Report/contractV2-e16ceb038ed6bf070ea75d9359c7ad54e6f3e226/contracts/NFTPool/impl/BaseFilterV1.sol",
        "vulnerability": "Assertion Failure",
        "check": "FP",
        "response": "Answer: No\nReason: After reviewing the code, there are no explicit calls to the 'assert' function which could directly cause assertion failures."
    },
    {
        "code_segment": "contract BURST is ERC20Interface, SafeMath {\n    string public name;\n    string public symbol;\n    uint8 public decimals; // 18 decimals is the strongly suggested default, avoid changing it\n\n    uint256 public _totalSupply;\n\n    mapping(address => uint) balances;\n    mapping(address => mapping(address => uint)) allowed;\n\n    /**\n     * Constrctor function\n     *\n     * Initializes contract with initial supply tokens to the creator of the contract\n     */\n    constructor() public {\n        name = \"BURST\";\n        symbol = \"BURST\";\n        decimals = 18;\n        _totalSupply = 31000000000000000000000000;\n\n        balances[msg.sender] = _totalSupply;\n        emit Transfer(address(0), msg.sender, _totalSupply);\n    }\n//SWC-101-Integer Overflow and Underflow: L60\n    function totalSupply() public view returns (uint) {\n        return _totalSupply  - balances[address(0)];\n    }\n\n    function balanceOf(address tokenOwner) public view returns (uint balance) {\n        return balances[tokenOwner];\n    }\n\n    function allowance(address tokenOwner, address spender) public view returns (uint remaining) {\n        return allowed[tokenOwner][spender];\n    }\n//SWC-114-Transaction Order Dependence: L71-75\n    function approve(address spender, uint tokens) public returns (bool success) {\n        allowed[msg.sender][spender] = tokens;\n        emit Approval(msg.sender, spender, tokens);\n        return true;\n    }\n\n    function transfer(address to, uint tokens) public returns (bool success) {\n        balances[msg.sender] = safeSub(balances[msg.sender], tokens);\n        balances[to] = safeAdd(balances[to], tokens);\n        emit Transfer(msg.sender, to, tokens);\n        return true;\n    }\n\n    function transferFrom(address from, address to, uint tokens) public returns (bool success) {\n        balances[from] = safeSub(balances[from], tokens);\n        allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);\n        balances[to] = safeAdd(balances[to], tokens);\n        emit Transfer(from, to, tokens);\n        return true;\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/QuillAudits-Burst Token Smart Contract/BURST-Token-33b0e2e7ec14828e000ae95e7d4cef77e0796acd/burst.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No\nReason: The contract uses SafeMath functions for arithmetic operations, which prevent integer overflow."
    },
    {
        "code_segment": "contract SafeMath {\n    function safeAdd(uint a, uint b) public pure returns (uint c) {\n        c = a + b;\n        require(c >= a);\n    }\n    function safeSub(uint a, uint b) public pure returns (uint c) {\n        require(b <= a); c = a - b; } function safeMul(uint a, uint b) public pure returns (uint c) { c = a * b; require(a == 0 || c / a == b); } function safeDiv(uint a, uint b) public pure returns (uint c) { require(b > 0);\n        c = a / b;\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/QuillAudits-Burst Token Smart Contract/BURST-Token-33b0e2e7ec14828e000ae95e7d4cef77e0796acd/burst.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No\nReason: The contract includes checks (require statements) that prevent integer overflow and underflow."
    },
    {
        "code_segment": "contract BridgeValidators is IBridgeValidators, EternalStorage, Ownable {\n    using SafeMath for uint256;\n    event ValidatorAdded (address validator);\n    event ValidatorRemoved (address validator);\n    event RequiredSignaturesChanged (uint256 requiredSignatures);\n\n    function initialize(uint256 _requiredSignatures, address[] _initialValidators, address _owner)\n      public returns(bool)\n    {\n        require(!isInitialized());\n        require(_owner != address(0));\n        setOwner(_owner);\n        require(_requiredSignatures != 0);\n        require(_initialValidators.length >= _requiredSignatures);\n        for (uint256 i = 0; i < _initialValidators.length; i++) {\n            require(_initialValidators[i] != address(0));\n            assert(validators(_initialValidators[i]) != true);\n            setValidatorCount(validatorCount().add(1));\n            setValidator(_initialValidators[i], true);\n            emit ValidatorAdded(_initialValidators[i]);\n        }\n        //SWC-135-Code With No Effects: L31\n        require(validatorCount() >= _requiredSignatures);\n        uintStorage[keccak256(abi.encodePacked(\"requiredSignatures\"))] = _requiredSignatures;\n        setInitialize(true);\n        return isInitialized();\n    }\n\n    function addValidator(address _validator) external onlyOwner {\n        require(_validator != address(0));\n        require(!isValidator(_validator));\n        setValidatorCount(validatorCount().add(1));\n        setValidator(_validator, true);\n        emit ValidatorAdded(_validator);\n    }\n\n    function removeValidator(address _validator) external onlyOwner {\n        require(validatorCount() > requiredSignatures());\n        require(isValidator(_validator));\n        setValidator(_validator, false);\n        setValidatorCount(validatorCount().sub(1));\n        emit ValidatorRemoved(_validator);\n    }\n\n    function setRequiredSignatures(uint256 _requiredSignatures) external onlyOwner {\n        require(validatorCount() >= _requiredSignatures);\n        require(_requiredSignatures != 0);\n        uintStorage[keccak256(abi.encodePacked(\"requiredSignatures\"))] = _requiredSignatures;\n        emit RequiredSignaturesChanged(_requiredSignatures);\n    }\n\n    function requiredSignatures() public view returns(uint256) {\n        return uintStorage[keccak256(abi.encodePacked(\"requiredSignatures\"))];\n    }\n\n    function validatorCount() public view returns(uint256) {\n        return uintStorage[keccak256(abi.encodePacked(\"validatorCount\"))];\n    }\n\n    function validators(address _validator) public view returns(bool) {\n        return boolStorage[keccak256(abi.encodePacked(\"validators\", _validator))];\n    }\n\n    function isValidator(address _validator) public view returns(bool) {\n        return validators(_validator) == true;\n    }\n\n    function isInitialized() public view returns(bool) {\n        return boolStorage[keccak256(abi.encodePacked(\"isInitialized\"))];\n    }\n\n    function setValidatorCount(uint256 _validatorCount) private {\n        uintStorage[keccak256(abi.encodePacked(\"validatorCount\"))] = _validatorCount;\n    }\n\n    function setValidator(address _validator, bool _status) private {\n        boolStorage[keccak256(abi.encodePacked(\"validators\", _validator))] = _status;\n    }\n\n    function setInitialize(bool _status) private {\n        boolStorage[keccak256(abi.encodePacked(\"isInitialized\"))] = _status;\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/PepperSec-POA-Network-Bridge/tokenbridge-contracts-2bf70c7e9fd42968aec2dc352017618907834401/contracts/upgradeable_contracts/BridgeValidators.sol",
        "vulnerability": "Assertion Failure",
        "check": "FP",
        "response": "Answer: No\nReason: The assertions and require statements in the code ensure that all conditions must be met before any further execution, preventing any assertion failures."
    },
    {
        "code_segment": "contract CryptoGamez is BEP20 {\n    \n    /**\n     * @dev Sets symbol, name, decimals and totalSupply of the token\n     * \n     * - Sets msg.sender as the owner of the contract\n     * - Transfers totalSupply to owner\n     */ \n    constructor()   {\n        symbol = \"CGAZ\";\n        name = \"CryptoGamez\";\n        decimals = 18;                                    \n        totalSupply = 11500000 * 10**18;\n        change = false;\n        percent = 10;\n       \n        owner = msg.sender;\n        balances[owner] = totalSupply;\n    }\n    \n    \n    /**\n     * @dev Calls mint function from BEP20 contract\n     * \n     * Requirements:\n     * \n     * - only owner can call this function\n     * - 'to' address cannot be zero address\n     */\n    function mint(address to, uint amount) external onlyOwner {\n        require(to != address(0), \"No mint to zero address\");\n        _mint(to, amount);\n    }\n    \n    /**\n     * @dev Calls burn function from BEP20 contract\n     * \n     */\n    function burn(uint amount) external {\n        _burn(msg.sender, amount);\n    }\n    \n    \n   \n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/QuillAudits-CryptoGamez Smart Contract/CryptoGamez/CryptoGamez.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No\nReason: The code does not perform any arithmetic operations that could cause an integer overflow, leveraging safe methods from the BEP20 contract for minting and burning."
    },
    {
        "code_segment": "contract Vault {\n    using SafeMath for uint;\n    /**\n     * @dev Storage slot with the incognito proxy.\n     * This is the keccak-256 hash of \"eip1967.proxy.incognito.\" subtracted by 1\n     */\n    bytes32 private constant _INCOGNITO_SLOT = 0x62135fc083646fdb4e1a9d700e351b886a4a5a39da980650269edd1ade91ffd2;\n    address constant public ETH_TOKEN = 0x0000000000000000000000000000000000000000;\n    mapping(bytes32 => bool) public withdrawed;\n    mapping(bytes32 => bool) public sigDataUsed;\n    // address => token => amount\n    mapping(address => mapping(address => uint)) public withdrawRequests;\n    mapping(address => mapping(address => bool)) public migration;\n    mapping(address => uint) public totalDepositedToSCAmount;\n    Withdrawable public prevVault;\n    bool public notEntered = true;\n    bool public isInitialized = false;\n\n    struct BurnInstData {\n        uint8 meta; // type of the instruction\n        uint8 shard; // ID of the Incognito shard containing the instruction, must be 1\n        address token; // ETH address of the token contract (0x0 for ETH)\n        address payable to; // ETH address of the receiver of the token\n        uint amount; // burned amount (on Incognito)\n        bytes32 itx; // Incognito's burning tx\n    }\n\n    // error code\n    enum Errors {\n        EMPTY,\n        NO_REENTRANCE,\n        MAX_UINT_REACHED,\n        VALUE_OVER_FLOW,\n        INTERNAL_TX_ERROR,\n        ALREADY_USED,\n        INVALID_DATA,\n        TOKEN_NOT_ENOUGH,\n        WITHDRAW_REQUEST_TOKEN_NOT_ENOUGH,\n        INVALID_RETURN_DATA,\n        NOT_EQUAL,\n        NULL_VALUE,\n        ONLY_PREVAULT,\n        PREVAULT_NOT_PAUSED\n    }\n\n    event Deposit(address token, string incognitoAddress, uint amount);\n    event Withdraw(address token, address to, uint amount);\n    event UpdateTokenTotal(address[] assets, uint[] amounts);\n    event UpdateIncognitoProxy(address newIncognitoProxy);\n\n    /**\n     * modifier for contract version\n     */\n     modifier onlyPreVault(){\n        require(address(prevVault) != address(0x0) && msg.sender == address(prevVault), errorToString(Errors.ONLY_PREVAULT));\n        _;\n     }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, notEntered will be true\n        require(notEntered, errorToString(Errors.NO_REENTRANCE));\n\n        // Any calls to nonReentrant after this point will fail\n        notEntered = false;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        notEntered = true;\n    }\n\n    /**\n     * @dev Creates new Vault to hold assets for Incognito Chain\n     * @param _prevVault: previous version of the Vault to refer back if necessary\n     * After migrating all assets to a new Vault, we still need to refer\n     * back to previous Vault to make sure old withdrawals aren't being reused\n     */\n    function initialize(address _prevVault) external {\n        require(!isInitialized);\n        prevVault = Withdrawable(_prevVault);\n        isInitialized = true;\n        notEntered = true;\n    }\n\n    /**\n     * @dev Returns the current incognito proxy.\n     */\n    function _incognito() internal view returns (address icg) {\n        bytes32 slot = _INCOGNITO_SLOT;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            icg := sload(slot)\n        }\n    }\n\n    /**\n     * @dev Makes a ETH deposit to the vault to mint pETH over at Incognito Chain\n     * @notice This only works when the contract is not Paused\n     * @notice The maximum amount to deposit is capped since Incognito balance is stored as uint64\n     * @param incognitoAddress: Incognito Address to receive pETH\n     */\n    function deposit(string calldata incognitoAddress) external payable nonReentrant {\n        require(address(this).balance <= 10 ** 27, errorToString(Errors.MAX_UINT_REACHED));\n        emit Deposit(ETH_TOKEN, incognitoAddress, msg.value);\n    }\n\n    /**\n     * @dev Makes a ERC20 deposit to the vault to mint pERC20 over at Incognito Chain\n     * @notice This only works when the contract is not Paused\n     * @notice The maximum amount to deposit is capped since Incognito balance is stored as uint64\n     * @notice Before calling this function, enough ERC20 must be allowed to\n     * tranfer from msg.sender to this contract\n     * @param token: address of the ERC20 token\n     * @param amount: to deposit to the vault and mint on Incognito Chain\n     * @param incognitoAddress: Incognito Address to receive pERC20\n     */\n    function depositERC20(address token, uint amount, string calldata incognitoAddress) external payable nonReentrant {\n        IERC20 erc20Interface = IERC20(token);\n        uint8 decimals = getDecimals(address(token));\n        uint tokenBalance = erc20Interface.balanceOf(address(this));\n        uint beforeTransfer = tokenBalance;\n        uint emitAmount = amount;\n        if (decimals > 9) {\n            emitAmount = emitAmount / (10 ** (uint(decimals) - 9));\n            tokenBalance = tokenBalance / (10 ** (uint(decimals) - 9));\n        }\n        require(emitAmount <= 10 ** 18 && tokenBalance <= 10 ** 18 && emitAmount.safeAdd(tokenBalance) <= 10 ** 18, errorToString(Errors.VALUE_OVER_FLOW));\n        erc20Interface.transferFrom(msg.sender, address(this), amount);\n        require(checkSuccess(), errorToString(Errors.INTERNAL_TX_ERROR));\n        require(balanceOf(token).safeSub(beforeTransfer) == amount, errorToString(Errors.NOT_EQUAL));\n\n        emit Deposit(token, incognitoAddress, emitAmount);\n    }\n\n    /**\n     * @dev Checks if a burn proof has been used before\n     * @notice First, we check inside the storage of this contract itself. If the\n     * hash has been used before, we return the result. Otherwise, we query\n     * previous vault recursively until the first Vault (prevVault address is 0x0)\n     * @param hash: of the burn proof\n     * @return bool: whether the proof has been used or not\n     */\n    function isWithdrawed(bytes32 hash) public view returns(bool) {\n        if (withdrawed[hash]) {\n            return true;\n        } else if (address(prevVault) == address(0)) {\n            return false;\n        }\n        return prevVault.isWithdrawed(hash);\n    }\n\n    /**\n     * @dev Parses a burn instruction and returns the components\n     * @param inst: the full instruction, containing both metadata and body\n     */\n    function parseBurnInst(bytes memory inst) public pure returns (BurnInstData memory) {\n        BurnInstData memory data;\n        data.meta = uint8(inst[0]);\n        data.shard = uint8(inst[1]);\n        address token;\n        address payable to;\n        uint amount;\n        bytes32 itx;\n        assembly {\n            // skip first 0x20 bytes (stored length of inst)\n            token := mload(add(inst, 0x22)) // [3:34]\n            to := mload(add(inst, 0x42)) // [34:66]\n            amount := mload(add(inst, 0x62)) // [66:98]\n            itx := mload(add(inst, 0x82)) // [98:130]\n        }\n        data.token = token;\n        data.to = to;\n        data.amount = amount;\n        data.itx = itx;\n        return data;\n    }\n\n    /**\n     * @dev Verifies that a burn instruction is valid\n     * @notice All params except inst are the list of 2 elements corresponding to\n     * the proof on beacon and bridge\n     * @notice All params are the same as in `withdraw`\n     */\n    function verifyInst(\n        bytes memory inst,\n        uint heights,\n        bytes32[] memory instPaths,\n        bool[] memory instPathIsLefts,\n        bytes32 instRoots,\n        bytes32 blkData,\n        uint[] memory sigIdxs,\n        uint8[] memory sigVs,\n        bytes32[] memory sigRs,\n        bytes32[] memory sigSs\n    ) view internal {\n        // Each instruction can only by redeemed once\n        bytes32 beaconInstHash = keccak256(abi.encodePacked(inst, heights));\n\n        // Verify instruction on beacon\n        require(Incognito(_incognito()).instructionApproved(\n            true, // Only check instruction on beacon\n            beaconInstHash,\n            heights,\n            instPaths,\n            instPathIsLefts,\n            instRoots,\n            blkData,\n            sigIdxs,\n            sigVs,\n            sigRs,\n            sigSs\n        ), errorToString(Errors.INVALID_DATA));\n    }\n\n    /**\n     * @dev Withdraws pETH/pIERC20 by providing a burn proof over at Incognito Chain\n     * @notice This function takes a burn instruction on Incognito Chain, checks\n     * for its validity and returns the token back to ETH chain\n     * @notice This only works when the contract is not Paused\n     * @param inst: the decoded instruction as a list of bytes\n     * @param heights: the blocks containing the instruction\n     * @param instPaths: merkle path of the instruction\n     * @param instPathIsLefts: whether each node on the path is the left or right child\n     * @param instRoots: root of the merkle tree contains all instructions\n     * @param blkData: merkle has of the block body\n     * @param sigIdxs: indices of the validators who signed this block\n     * @param sigVs: part of the signatures of the validators\n     * @param sigRs: part of the signatures of the validators\n     * @param sigSs: part of the signatures of the validators\n     */\n    function withdraw(\n        bytes memory inst,\n        uint heights,\n        bytes32[] memory instPaths,\n        bool[] memory instPathIsLefts,\n        bytes32 instRoots,\n        bytes32 blkData,\n        uint[] memory sigIdxs,\n        uint8[] memory sigVs,\n        bytes32[] memory sigRs,\n        bytes32[] memory sigSs\n    ) public nonReentrant {\n        require(inst.length >= 130);\n        BurnInstData memory data = parseBurnInst(inst);\n        require(data.meta == 241 && data.shard == 1); // Check instruction type\n\n        // Not withdrawed\n        require(!isWithdrawed(data.itx), errorToString(Errors.ALREADY_USED));\n        withdrawed[data.itx] = true;\n\n        // Check if balance is enough\n        if (data.token == ETH_TOKEN) {\n            require(address(this).balance >= data.amount.safeAdd(totalDepositedToSCAmount[data.token]), errorToString(Errors.TOKEN_NOT_ENOUGH));\n        } else {\n            uint8 decimals = getDecimals(data.token);\n            if (decimals > 9) {\n                data.amount = data.amount * (10 ** (uint(decimals) - 9));\n            }\n            require(IERC20(data.token).balanceOf(address(this)) >= data.amount.safeAdd(totalDepositedToSCAmount[data.token]), errorToString(Errors.TOKEN_NOT_ENOUGH));\n        }\n\n        verifyInst(\n            inst,\n            heights,\n            instPaths,\n            instPathIsLefts,\n            instRoots,\n            blkData,\n            sigIdxs,\n            sigVs,\n            sigRs,\n            sigSs\n        );\n\n        // Send and notify\n        if (data.token == ETH_TOKEN) {\n          (bool success, ) =  data.to.call{value: data.amount}(\"\");\n          require(success, errorToString(Errors.INTERNAL_TX_ERROR));\n        } else {\n            IERC20(data.token).transfer(data.to, data.amount);\n            require(checkSuccess(), errorToString(Errors.INTERNAL_TX_ERROR));\n        }\n        emit Withdraw(data.token, data.to, data.amount);\n    }\n\n    /**\n     * @dev Burnt Proof is submited to store burnt amount of p-token/p-ETH and receiver's address\n     * Receiver then can call withdrawRequest to withdraw these token to he/she incognito address.\n     * @notice This function takes a burn instruction on Incognito Chain, checks\n     * for its validity and returns the token back to ETH chain\n     * @notice This only works when the contract is not Paused\n     * @param inst: the decoded instruction as a list of bytes\n     * @param heights: the blocks containing the instruction\n     * @param instPaths: merkle path of the instruction\n     * @param instPathIsLefts: whether each node on the path is the left or right child\n     * @param instRoots: root of the merkle tree contains all instructions\n     * @param blkData: merkle has of the block body\n     * @param sigIdxs: indices of the validators who signed this block\n     * @param sigVs: part of the signatures of the validators\n     * @param sigRs: part of the signatures of the validators\n     * @param sigSs: part of the signatures of the validators\n     */\n    function submitBurnProof(\n        bytes memory inst,\n        uint heights,\n        bytes32[] memory instPaths,\n        bool[] memory instPathIsLefts,\n        bytes32 instRoots,\n        bytes32 blkData,\n        uint[] memory sigIdxs,\n        uint8[] memory sigVs,\n        bytes32[] memory sigRs,\n        bytes32[] memory sigSs\n    ) public nonReentrant {\n        require(inst.length >= 130);\n        BurnInstData memory data = parseBurnInst(inst);\n        require(data.meta == 243 && data.shard == 1); // Check instruction type\n\n        // Not withdrawed\n        require(!isWithdrawed(data.itx), errorToString(Errors.ALREADY_USED));\n        withdrawed[data.itx] = true;\n\n        // Check if balance is enough\n        if (data.token == ETH_TOKEN) {\n            require(address(this).balance >= data.amount.safeAdd(totalDepositedToSCAmount[data.token]), errorToString(Errors.TOKEN_NOT_ENOUGH));\n        } else {\n            uint8 decimals = getDecimals(data.token);\n            if (decimals > 9) {\n                // SWC-101-Integer Overflow and Underflow: L409\n                data.amount = data.amount * (10 ** (uint(decimals) - 9));\n            }\n            require(IERC20(data.token).balanceOf(address(this)) >= data.amount.safeAdd(totalDepositedToSCAmount[data.token]), errorToString(Errors.TOKEN_NOT_ENOUGH));\n        }\n\n        verifyInst(\n            inst,\n            heights,\n            instPaths,\n            instPathIsLefts,\n            instRoots,\n            blkData,\n            sigIdxs,\n            sigVs,\n            sigRs,\n            sigSs\n        );\n\n        withdrawRequests[data.to][data.token] = withdrawRequests[data.to][data.token].safeAdd(data.amount);\n        totalDepositedToSCAmount[data.token] = totalDepositedToSCAmount[data.token].safeAdd(data.amount);\n    }\n\n    /**\n     * @dev generate address from signature data and hash.\n     */\n    function sigToAddress(bytes memory signData, bytes32 hash) public pure returns (address) {\n        bytes32 s;\n        bytes32 r;\n        uint8 v;\n        assembly {\n            r := mload(add(signData, 0x20))\n            s := mload(add(signData, 0x40))\n        }\n        v = uint8(signData[64]) + 27;\n        return ecrecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Checks if a sig data has been used before\n     * @notice First, we check inside the storage of this contract itself. If the\n     * hash has been used before, we return the result. Otherwise, we query\n     * previous vault recursively until the first Vault (prevVault address is 0x0)\n     * @param hash: of the sig data\n     * @return bool: whether the sig data has been used or not\n     */\n    function isSigDataUsed(bytes32 hash) public view returns(bool) {\n        if (sigDataUsed[hash]) {\n            return true;\n        } else if (address(prevVault) == address(0)) {\n            return false;\n        }\n        return prevVault.isSigDataUsed(hash);\n    }\n\n    /**\n     * @dev User requests withdraw token contains in withdrawRequests.\n     * Deposit event will be emitted to let incognito recognize and mint new p-tokens for the user.\n     * @param incognitoAddress: incognito's address that will receive minted p-tokens.\n     * @param token: ethereum's token address (eg., ETH, DAI, ...)\n     * @param amount: amount of the token in ethereum's denomination\n     * @param signData: signature of an unique data that is signed by an account which is generated from user's incognito privkey\n     * @param timestamp: unique data generated from client (timestamp for example)\n     */\n    function requestWithdraw(\n        string calldata incognitoAddress,\n        address token,\n        uint amount,\n        bytes calldata signData,\n        bytes calldata timestamp\n    ) external nonReentrant {\n        // verify owner signs data\n        address verifier = verifySignData(abi.encode(incognitoAddress, token, timestamp, amount), signData);\n\n        // migrate from preVault\n        migrateBalance(verifier, token);\n\n        require(withdrawRequests[verifier][token] >= amount, errorToString(Errors.WITHDRAW_REQUEST_TOKEN_NOT_ENOUGH));\n        withdrawRequests[verifier][token] = withdrawRequests[verifier][token].safeSub(amount);\n        totalDepositedToSCAmount[token] = totalDepositedToSCAmount[token].safeSub(amount);\n\n        // convert denomination from ethereum's to incognito's (pcoin)\n        uint emitAmount = amount;\n        if (token != ETH_TOKEN) {\n            uint8 decimals = getDecimals(token);\n            if (decimals > 9) {\n                emitAmount = amount / (10 ** (uint(decimals) - 9));\n            }\n        }\n\n        emit Deposit(token, incognitoAddress, emitAmount);\n    }\n\n    /**\n     * @dev execute is a general function that plays a role as proxy to interact to other smart contracts.\n     * @param token: ethereum's token address (eg., ETH, DAI, ...)\n     * @param amount: amount of the token in ethereum's denomination\n     * @param recipientToken: received token address.\n     * @param exchangeAddress: address of targeting smart contract that actually executes the desired logics like trade, invest, borrow and so on.\n     * @param callData: encoded with signature and params of function from targeting smart contract.\n     * @param timestamp: unique data generated from client (timestamp for example)\n     * @param signData: signature of an unique data that is signed by an account which is generated from user's incognito privkey\n     */\n    //  SWC-114-Transaction Order Dependence: L512 - L547\n    // SWC-105-Unprotected Ether Withdrawal: L513 - 548\n    function execute(\n        address token,\n        uint amount,\n        address recipientToken,\n        address exchangeAddress,\n        bytes calldata callData,\n        bytes calldata timestamp,\n        bytes calldata signData\n    ) external payable nonReentrant {\n        //verify ower signs data from input\n        address verifier = verifySignData(abi.encode(exchangeAddress, callData, timestamp, amount), signData);\n\n        // migrate from preVault\n        migrateBalance(verifier, token);\n        require(withdrawRequests[verifier][token] >= amount, errorToString(Errors.WITHDRAW_REQUEST_TOKEN_NOT_ENOUGH));\n\n        // update balance of verifier\n        totalDepositedToSCAmount[token] = totalDepositedToSCAmount[token].safeSub(amount);\n        withdrawRequests[verifier][token] = withdrawRequests[verifier][token].safeSub(amount);\n\n        // define number of eth spent for forwarder.\n        uint ethAmount = msg.value;\n        if (token == ETH_TOKEN) {\n            ethAmount = ethAmount.safeAdd(amount);\n        } else {\n            // transfer token to exchangeAddress.\n            require(IERC20(token).balanceOf(address(this)) >= amount, errorToString(Errors.TOKEN_NOT_ENOUGH));\n            IERC20(token).transfer(exchangeAddress, amount);\n            require(checkSuccess(), errorToString(Errors.INTERNAL_TX_ERROR));\n        }\n        uint returnedAmount = callExtFunc(recipientToken, ethAmount, callData, exchangeAddress);\n\n        // update withdrawRequests\n        withdrawRequests[verifier][recipientToken] = withdrawRequests[verifier][recipientToken].safeAdd(returnedAmount);\n        totalDepositedToSCAmount[recipientToken] = totalDepositedToSCAmount[recipientToken].safeAdd(returnedAmount);\n    }\n\n    /**\n     * @dev single trade\n     */\n    function callExtFunc(address recipientToken, uint ethAmount, bytes memory callData, address exchangeAddress) internal returns (uint) {\n         // get balance of recipient token before trade to compare after trade.\n        uint balanceBeforeTrade = balanceOf(recipientToken);\n        if (recipientToken == ETH_TOKEN) {\n            balanceBeforeTrade = balanceBeforeTrade.safeSub(msg.value);\n        }\n        require(address(this).balance >= ethAmount, errorToString(Errors.TOKEN_NOT_ENOUGH));\n        (bool success, bytes memory result) = exchangeAddress.call{value: ethAmount}(callData);\n        require(success);\n\n        (address returnedTokenAddress, uint returnedAmount) = abi.decode(result, (address, uint));\n        require(returnedTokenAddress == recipientToken && balanceOf(recipientToken).safeSub(balanceBeforeTrade) == returnedAmount, errorToString(Errors.INVALID_RETURN_DATA));\n\n        return returnedAmount;\n    }\n\n    /**\n     * @dev verify sign data\n     */\n     function verifySignData(bytes memory data, bytes memory signData) internal returns(address){\n        bytes32 hash = keccak256(data);\n        require(!isSigDataUsed(hash), errorToString(Errors.ALREADY_USED));\n        address verifier = sigToAddress(signData, hash);\n       // mark data hash of sig as used\n        sigDataUsed[hash] = true;\n\n        return verifier;\n     }\n\n    /**\n      * @dev migrate balance from previous vault\n      * Note: uncomment for next version\n      */\n    function migrateBalance(address owner, address token) internal {\n        if (address(prevVault) != address(0x0) && !migration[owner][token]) {\n            withdrawRequests[owner][token] = withdrawRequests[owner][token].safeAdd(prevVault.getDepositedBalance(token, owner));\n  \t        migration[owner][token] = true;\n  \t   }\n    }\n\n    /**\n     * @dev Get the amount of specific coin for specific wallet\n     */\n    function getDepositedBalance(\n        address token,\n        address owner\n    ) public view returns (uint) {\n        if (address(prevVault) != address(0x0) && !migration[owner][token]) {\n \t        return withdrawRequests[owner][token].safeAdd(prevVault.getDepositedBalance(token, owner));\n \t    }\n        return withdrawRequests[owner][token];\n    }\n\n    /**\n     * @dev Move total number of assets to newVault\n     * @notice This only works when the preVault is Paused\n     * @notice This can only be called by preVault\n     * @param assets: address of the ERC20 tokens to move, 0x0 for ETH\n     * @param amounts: total number of the ERC20 tokens to move, 0x0 for ETH\n     */\n    function updateAssets(address[] calldata assets, uint[] calldata amounts) external onlyPreVault returns(bool) {\n        require(assets.length == amounts.length,  errorToString(Errors.NOT_EQUAL));\n        require(Withdrawable(prevVault).paused(), errorToString(Errors.PREVAULT_NOT_PAUSED));\n        for (uint i = 0; i < assets.length; i++) {\n            totalDepositedToSCAmount[assets[i]] = totalDepositedToSCAmount[assets[i]].safeAdd(amounts[i]);\n        }\n        emit UpdateTokenTotal(assets, amounts);\n\n        return true;\n    }\n\n    /**\n     * @dev Payable receive function to receive Ether from oldVault when migrating\n     */\n    receive() external payable {}\n\n    /**\n     * @dev Check if transfer() and transferFrom() of ERC20 succeeded or not\n     * This check is needed to fix https://github.com/ethereum/solidity/issues/4116\n     * This function is copied from https://github.com/AdExNetwork/adex-protocol-eth/blob/master/contracts/libs/SafeERC20.sol\n     */\n    function checkSuccess() private pure returns (bool) {\n\t\tuint256 returnValue = 0;\n\t\tassembly {\n\t\t\t// check number of bytes returned from last function call\n\t\t\tswitch returndatasize()\n\n\t\t\t// no bytes returned: assume success\n\t\t\tcase 0x0 {\n\t\t\t\treturnValue := 1\n\t\t\t}\n\n\t\t\t// 32 bytes returned: check if non-zero\n\t\t\tcase 0x20 {\n\t\t\t\t// copy 32 bytes into scratch space\n\t\t\t\treturndatacopy(0x0, 0x0, 0x20)\n\n\t\t\t\t// load those bytes into returnValue\n\t\t\t\treturnValue := mload(0x0)\n\t\t\t}\n\n\t\t\t// not sure what was returned: don't mark as success\n\t\t\tdefault { }\n\t\t}\n\t\treturn returnValue != 0;\n\t}\n\n    /**\n     * @dev convert enum to string value\n     */\n     function errorToString(Errors error) internal pure returns(string memory) {\n        uint8 erroNum = uint8(error);\n        uint maxlength = 10;\n        bytes memory reversed = new bytes(maxlength);\n        uint i = 0;\n        while (erroNum != 0) {\n            uint8 remainder = erroNum % 10;\n            erroNum = erroNum / 10;\n            reversed[i++] = byte(48 + remainder);\n        }\n        bytes memory s = new bytes(i + 1);\n        for (uint j = 0; j <= i; j++) {\n            s[j] = reversed[i - j];\n        }\n        return string(s);\n    }\n\n    /**\n     * @dev Get the decimals of an ERC20 token, return 0 if it isn't defined\n     * We check the returndatasize to covert both cases that the token has\n     * and doesn't have the function decimals()\n     */\n    function getDecimals(address token) public view returns (uint8) {\n        IERC20 erc20 = IERC20(token);\n        return uint8(erc20.decimals());\n    }\n\n    /**\n     * @dev Get the amount of coin deposited to this smartcontract\n     */\n    function balanceOf(address token) public view returns (uint) {\n        if (token == ETH_TOKEN) {\n            return address(this).balance;\n        }\n        return IERC20(token).balanceOf(address(this));\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinspect-Incognito Audit/bridge-eth-4879219669a38d601265582f815596b6775855b6/bridge/contracts/vault.sol",
        "vulnerability": "Assertion Failure",
        "check": "FP",
        "response": "Answer: No  \nReason: There are no `assert` statements in the provided contract code, hence no risk of assertion failure."
    },
    {
        "code_segment": "contract Vault {\n    using SafeMath for uint;\n    /**\n     * @dev Storage slot with the incognito proxy.\n     * This is the keccak-256 hash of \"eip1967.proxy.incognito.\" subtracted by 1\n     */\n    bytes32 private constant _INCOGNITO_SLOT = 0x62135fc083646fdb4e1a9d700e351b886a4a5a39da980650269edd1ade91ffd2;\n    address constant public ETH_TOKEN = 0x0000000000000000000000000000000000000000;\n    mapping(bytes32 => bool) public withdrawed;\n    mapping(bytes32 => bool) public sigDataUsed;\n    // address => token => amount\n    mapping(address => mapping(address => uint)) public withdrawRequests;\n    mapping(address => mapping(address => bool)) public migration;\n    mapping(address => uint) public totalDepositedToSCAmount;\n    Withdrawable public prevVault;\n    bool public notEntered = true;\n    bool public isInitialized = false;\n\n    struct BurnInstData {\n        uint8 meta; // type of the instruction\n        uint8 shard; // ID of the Incognito shard containing the instruction, must be 1\n        address token; // ETH address of the token contract (0x0 for ETH)\n        address payable to; // ETH address of the receiver of the token\n        uint amount; // burned amount (on Incognito)\n        bytes32 itx; // Incognito's burning tx\n    }\n\n    // error code\n    enum Errors {\n        EMPTY,\n        NO_REENTRANCE,\n        MAX_UINT_REACHED,\n        VALUE_OVER_FLOW,\n        INTERNAL_TX_ERROR,\n        ALREADY_USED,\n        INVALID_DATA,\n        TOKEN_NOT_ENOUGH,\n        WITHDRAW_REQUEST_TOKEN_NOT_ENOUGH,\n        INVALID_RETURN_DATA,\n        NOT_EQUAL,\n        NULL_VALUE,\n        ONLY_PREVAULT,\n        PREVAULT_NOT_PAUSED\n    }\n\n    event Deposit(address token, string incognitoAddress, uint amount);\n    event Withdraw(address token, address to, uint amount);\n    event UpdateTokenTotal(address[] assets, uint[] amounts);\n    event UpdateIncognitoProxy(address newIncognitoProxy);\n\n    /**\n     * modifier for contract version\n     */\n     modifier onlyPreVault(){\n        require(address(prevVault) != address(0x0) && msg.sender == address(prevVault), errorToString(Errors.ONLY_PREVAULT));\n        _;\n     }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, notEntered will be true\n        require(notEntered, errorToString(Errors.NO_REENTRANCE));\n\n        // Any calls to nonReentrant after this point will fail\n        notEntered = false;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        notEntered = true;\n    }\n\n    /**\n     * @dev Creates new Vault to hold assets for Incognito Chain\n     * @param _prevVault: previous version of the Vault to refer back if necessary\n     * After migrating all assets to a new Vault, we still need to refer\n     * back to previous Vault to make sure old withdrawals aren't being reused\n     */\n    function initialize(address _prevVault) external {\n        require(!isInitialized);\n        prevVault = Withdrawable(_prevVault);\n        isInitialized = true;\n        notEntered = true;\n    }\n\n    /**\n     * @dev Returns the current incognito proxy.\n     */\n    function _incognito() internal view returns (address icg) {\n        bytes32 slot = _INCOGNITO_SLOT;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            icg := sload(slot)\n        }\n    }\n\n    /**\n     * @dev Makes a ETH deposit to the vault to mint pETH over at Incognito Chain\n     * @notice This only works when the contract is not Paused\n     * @notice The maximum amount to deposit is capped since Incognito balance is stored as uint64\n     * @param incognitoAddress: Incognito Address to receive pETH\n     */\n    function deposit(string calldata incognitoAddress) external payable nonReentrant {\n        require(address(this).balance <= 10 ** 27, errorToString(Errors.MAX_UINT_REACHED));\n        emit Deposit(ETH_TOKEN, incognitoAddress, msg.value);\n    }\n\n    /**\n     * @dev Makes a ERC20 deposit to the vault to mint pERC20 over at Incognito Chain\n     * @notice This only works when the contract is not Paused\n     * @notice The maximum amount to deposit is capped since Incognito balance is stored as uint64\n     * @notice Before calling this function, enough ERC20 must be allowed to\n     * tranfer from msg.sender to this contract\n     * @param token: address of the ERC20 token\n     * @param amount: to deposit to the vault and mint on Incognito Chain\n     * @param incognitoAddress: Incognito Address to receive pERC20\n     */\n    function depositERC20(address token, uint amount, string calldata incognitoAddress) external payable nonReentrant {\n        IERC20 erc20Interface = IERC20(token);\n        uint8 decimals = getDecimals(address(token));\n        uint tokenBalance = erc20Interface.balanceOf(address(this));\n        uint beforeTransfer = tokenBalance;\n        uint emitAmount = amount;\n        if (decimals > 9) {\n            emitAmount = emitAmount / (10 ** (uint(decimals) - 9));\n            tokenBalance = tokenBalance / (10 ** (uint(decimals) - 9));\n        }\n        require(emitAmount <= 10 ** 18 && tokenBalance <= 10 ** 18 && emitAmount.safeAdd(tokenBalance) <= 10 ** 18, errorToString(Errors.VALUE_OVER_FLOW));\n        erc20Interface.transferFrom(msg.sender, address(this), amount);\n        require(checkSuccess(), errorToString(Errors.INTERNAL_TX_ERROR));\n        require(balanceOf(token).safeSub(beforeTransfer) == amount, errorToString(Errors.NOT_EQUAL));\n\n        emit Deposit(token, incognitoAddress, emitAmount);\n    }\n\n    /**\n     * @dev Checks if a burn proof has been used before\n     * @notice First, we check inside the storage of this contract itself. If the\n     * hash has been used before, we return the result. Otherwise, we query\n     * previous vault recursively until the first Vault (prevVault address is 0x0)\n     * @param hash: of the burn proof\n     * @return bool: whether the proof has been used or not\n     */\n    function isWithdrawed(bytes32 hash) public view returns(bool) {\n        if (withdrawed[hash]) {\n            return true;\n        } else if (address(prevVault) == address(0)) {\n            return false;\n        }\n        return prevVault.isWithdrawed(hash);\n    }\n\n    /**\n     * @dev Parses a burn instruction and returns the components\n     * @param inst: the full instruction, containing both metadata and body\n     */\n    function parseBurnInst(bytes memory inst) public pure returns (BurnInstData memory) {\n        BurnInstData memory data;\n        data.meta = uint8(inst[0]);\n        data.shard = uint8(inst[1]);\n        address token;\n        address payable to;\n        uint amount;\n        bytes32 itx;\n        assembly {\n            // skip first 0x20 bytes (stored length of inst)\n            token := mload(add(inst, 0x22)) // [3:34]\n            to := mload(add(inst, 0x42)) // [34:66]\n            amount := mload(add(inst, 0x62)) // [66:98]\n            itx := mload(add(inst, 0x82)) // [98:130]\n        }\n        data.token = token;\n        data.to = to;\n        data.amount = amount;\n        data.itx = itx;\n        return data;\n    }\n\n    /**\n     * @dev Verifies that a burn instruction is valid\n     * @notice All params except inst are the list of 2 elements corresponding to\n     * the proof on beacon and bridge\n     * @notice All params are the same as in `withdraw`\n     */\n    function verifyInst(\n        bytes memory inst,\n        uint heights,\n        bytes32[] memory instPaths,\n        bool[] memory instPathIsLefts,\n        bytes32 instRoots,\n        bytes32 blkData,\n        uint[] memory sigIdxs,\n        uint8[] memory sigVs,\n        bytes32[] memory sigRs,\n        bytes32[] memory sigSs\n    ) view internal {\n        // Each instruction can only by redeemed once\n        bytes32 beaconInstHash = keccak256(abi.encodePacked(inst, heights));\n\n        // Verify instruction on beacon\n        require(Incognito(_incognito()).instructionApproved(\n            true, // Only check instruction on beacon\n            beaconInstHash,\n            heights,\n            instPaths,\n            instPathIsLefts,\n            instRoots,\n            blkData,\n            sigIdxs,\n            sigVs,\n            sigRs,\n            sigSs\n        ), errorToString(Errors.INVALID_DATA));\n    }\n\n    /**\n     * @dev Withdraws pETH/pIERC20 by providing a burn proof over at Incognito Chain\n     * @notice This function takes a burn instruction on Incognito Chain, checks\n     * for its validity and returns the token back to ETH chain\n     * @notice This only works when the contract is not Paused\n     * @param inst: the decoded instruction as a list of bytes\n     * @param heights: the blocks containing the instruction\n     * @param instPaths: merkle path of the instruction\n     * @param instPathIsLefts: whether each node on the path is the left or right child\n     * @param instRoots: root of the merkle tree contains all instructions\n     * @param blkData: merkle has of the block body\n     * @param sigIdxs: indices of the validators who signed this block\n     * @param sigVs: part of the signatures of the validators\n     * @param sigRs: part of the signatures of the validators\n     * @param sigSs: part of the signatures of the validators\n     */\n    function withdraw(\n        bytes memory inst,\n        uint heights,\n        bytes32[] memory instPaths,\n        bool[] memory instPathIsLefts,\n        bytes32 instRoots,\n        bytes32 blkData,\n        uint[] memory sigIdxs,\n        uint8[] memory sigVs,\n        bytes32[] memory sigRs,\n        bytes32[] memory sigSs\n    ) public nonReentrant {\n        require(inst.length >= 130);\n        BurnInstData memory data = parseBurnInst(inst);\n        require(data.meta == 241 && data.shard == 1); // Check instruction type\n\n        // Not withdrawed\n        require(!isWithdrawed(data.itx), errorToString(Errors.ALREADY_USED));\n        withdrawed[data.itx] = true;\n\n        // Check if balance is enough\n        if (data.token == ETH_TOKEN) {\n            require(address(this).balance >= data.amount.safeAdd(totalDepositedToSCAmount[data.token]), errorToString(Errors.TOKEN_NOT_ENOUGH));\n        } else {\n            uint8 decimals = getDecimals(data.token);\n            if (decimals > 9) {\n                data.amount = data.amount * (10 ** (uint(decimals) - 9));\n            }\n            require(IERC20(data.token).balanceOf(address(this)) >= data.amount.safeAdd(totalDepositedToSCAmount[data.token]), errorToString(Errors.TOKEN_NOT_ENOUGH));\n        }\n\n        verifyInst(\n            inst,\n            heights,\n            instPaths,\n            instPathIsLefts,\n            instRoots,\n            blkData,\n            sigIdxs,\n            sigVs,\n            sigRs,\n            sigSs\n        );\n\n        // Send and notify\n        if (data.token == ETH_TOKEN) {\n          (bool success, ) =  data.to.call{value: data.amount}(\"\");\n          require(success, errorToString(Errors.INTERNAL_TX_ERROR));\n        } else {\n            IERC20(data.token).transfer(data.to, data.amount);\n            require(checkSuccess(), errorToString(Errors.INTERNAL_TX_ERROR));\n        }\n        emit Withdraw(data.token, data.to, data.amount);\n    }\n\n    /**\n     * @dev Burnt Proof is submited to store burnt amount of p-token/p-ETH and receiver's address\n     * Receiver then can call withdrawRequest to withdraw these token to he/she incognito address.\n     * @notice This function takes a burn instruction on Incognito Chain, checks\n     * for its validity and returns the token back to ETH chain\n     * @notice This only works when the contract is not Paused\n     * @param inst: the decoded instruction as a list of bytes\n     * @param heights: the blocks containing the instruction\n     * @param instPaths: merkle path of the instruction\n     * @param instPathIsLefts: whether each node on the path is the left or right child\n     * @param instRoots: root of the merkle tree contains all instructions\n     * @param blkData: merkle has of the block body\n     * @param sigIdxs: indices of the validators who signed this block\n     * @param sigVs: part of the signatures of the validators\n     * @param sigRs: part of the signatures of the validators\n     * @param sigSs: part of the signatures of the validators\n     */\n    function submitBurnProof(\n        bytes memory inst,\n        uint heights,\n        bytes32[] memory instPaths,\n        bool[] memory instPathIsLefts,\n        bytes32 instRoots,\n        bytes32 blkData,\n        uint[] memory sigIdxs,\n        uint8[] memory sigVs,\n        bytes32[] memory sigRs,\n        bytes32[] memory sigSs\n    ) public nonReentrant {\n        require(inst.length >= 130);\n        BurnInstData memory data = parseBurnInst(inst);\n        require(data.meta == 243 && data.shard == 1); // Check instruction type\n\n        // Not withdrawed\n        require(!isWithdrawed(data.itx), errorToString(Errors.ALREADY_USED));\n        withdrawed[data.itx] = true;\n\n        // Check if balance is enough\n        if (data.token == ETH_TOKEN) {\n            require(address(this).balance >= data.amount.safeAdd(totalDepositedToSCAmount[data.token]), errorToString(Errors.TOKEN_NOT_ENOUGH));\n        } else {\n            uint8 decimals = getDecimals(data.token);\n            if (decimals > 9) {\n                // SWC-101-Integer Overflow and Underflow: L409\n                data.amount = data.amount * (10 ** (uint(decimals) - 9));\n            }\n            require(IERC20(data.token).balanceOf(address(this)) >= data.amount.safeAdd(totalDepositedToSCAmount[data.token]), errorToString(Errors.TOKEN_NOT_ENOUGH));\n        }\n\n        verifyInst(\n            inst,\n            heights,\n            instPaths,\n            instPathIsLefts,\n            instRoots,\n            blkData,\n            sigIdxs,\n            sigVs,\n            sigRs,\n            sigSs\n        );\n\n        withdrawRequests[data.to][data.token] = withdrawRequests[data.to][data.token].safeAdd(data.amount);\n        totalDepositedToSCAmount[data.token] = totalDepositedToSCAmount[data.token].safeAdd(data.amount);\n    }\n\n    /**\n     * @dev generate address from signature data and hash.\n     */\n    function sigToAddress(bytes memory signData, bytes32 hash) public pure returns (address) {\n        bytes32 s;\n        bytes32 r;\n        uint8 v;\n        assembly {\n            r := mload(add(signData, 0x20))\n            s := mload(add(signData, 0x40))\n        }\n        v = uint8(signData[64]) + 27;\n        return ecrecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Checks if a sig data has been used before\n     * @notice First, we check inside the storage of this contract itself. If the\n     * hash has been used before, we return the result. Otherwise, we query\n     * previous vault recursively until the first Vault (prevVault address is 0x0)\n     * @param hash: of the sig data\n     * @return bool: whether the sig data has been used or not\n     */\n    function isSigDataUsed(bytes32 hash) public view returns(bool) {\n        if (sigDataUsed[hash]) {\n            return true;\n        } else if (address(prevVault) == address(0)) {\n            return false;\n        }\n        return prevVault.isSigDataUsed(hash);\n    }\n\n    /**\n     * @dev User requests withdraw token contains in withdrawRequests.\n     * Deposit event will be emitted to let incognito recognize and mint new p-tokens for the user.\n     * @param incognitoAddress: incognito's address that will receive minted p-tokens.\n     * @param token: ethereum's token address (eg., ETH, DAI, ...)\n     * @param amount: amount of the token in ethereum's denomination\n     * @param signData: signature of an unique data that is signed by an account which is generated from user's incognito privkey\n     * @param timestamp: unique data generated from client (timestamp for example)\n     */\n    function requestWithdraw(\n        string calldata incognitoAddress,\n        address token,\n        uint amount,\n        bytes calldata signData,\n        bytes calldata timestamp\n    ) external nonReentrant {\n        // verify owner signs data\n        address verifier = verifySignData(abi.encode(incognitoAddress, token, timestamp, amount), signData);\n\n        // migrate from preVault\n        migrateBalance(verifier, token);\n\n        require(withdrawRequests[verifier][token] >= amount, errorToString(Errors.WITHDRAW_REQUEST_TOKEN_NOT_ENOUGH));\n        withdrawRequests[verifier][token] = withdrawRequests[verifier][token].safeSub(amount);\n        totalDepositedToSCAmount[token] = totalDepositedToSCAmount[token].safeSub(amount);\n\n        // convert denomination from ethereum's to incognito's (pcoin)\n        uint emitAmount = amount;\n        if (token != ETH_TOKEN) {\n            uint8 decimals = getDecimals(token);\n            if (decimals > 9) {\n                emitAmount = amount / (10 ** (uint(decimals) - 9));\n            }\n        }\n\n        emit Deposit(token, incognitoAddress, emitAmount);\n    }\n\n    /**\n     * @dev execute is a general function that plays a role as proxy to interact to other smart contracts.\n     * @param token: ethereum's token address (eg., ETH, DAI, ...)\n     * @param amount: amount of the token in ethereum's denomination\n     * @param recipientToken: received token address.\n     * @param exchangeAddress: address of targeting smart contract that actually executes the desired logics like trade, invest, borrow and so on.\n     * @param callData: encoded with signature and params of function from targeting smart contract.\n     * @param timestamp: unique data generated from client (timestamp for example)\n     * @param signData: signature of an unique data that is signed by an account which is generated from user's incognito privkey\n     */\n    //  SWC-114-Transaction Order Dependence: L512 - L547\n    // SWC-105-Unprotected Ether Withdrawal: L513 - 548\n    function execute(\n        address token,\n        uint amount,\n        address recipientToken,\n        address exchangeAddress,\n        bytes calldata callData,\n        bytes calldata timestamp,\n        bytes calldata signData\n    ) external payable nonReentrant {\n        //verify ower signs data from input\n        address verifier = verifySignData(abi.encode(exchangeAddress, callData, timestamp, amount), signData);\n\n        // migrate from preVault\n        migrateBalance(verifier, token);\n        require(withdrawRequests[verifier][token] >= amount, errorToString(Errors.WITHDRAW_REQUEST_TOKEN_NOT_ENOUGH));\n\n        // update balance of verifier\n        totalDepositedToSCAmount[token] = totalDepositedToSCAmount[token].safeSub(amount);\n        withdrawRequests[verifier][token] = withdrawRequests[verifier][token].safeSub(amount);\n\n        // define number of eth spent for forwarder.\n        uint ethAmount = msg.value;\n        if (token == ETH_TOKEN) {\n            ethAmount = ethAmount.safeAdd(amount);\n        } else {\n            // transfer token to exchangeAddress.\n            require(IERC20(token).balanceOf(address(this)) >= amount, errorToString(Errors.TOKEN_NOT_ENOUGH));\n            IERC20(token).transfer(exchangeAddress, amount);\n            require(checkSuccess(), errorToString(Errors.INTERNAL_TX_ERROR));\n        }\n        uint returnedAmount = callExtFunc(recipientToken, ethAmount, callData, exchangeAddress);\n\n        // update withdrawRequests\n        withdrawRequests[verifier][recipientToken] = withdrawRequests[verifier][recipientToken].safeAdd(returnedAmount);\n        totalDepositedToSCAmount[recipientToken] = totalDepositedToSCAmount[recipientToken].safeAdd(returnedAmount);\n    }\n\n    /**\n     * @dev single trade\n     */\n    function callExtFunc(address recipientToken, uint ethAmount, bytes memory callData, address exchangeAddress) internal returns (uint) {\n         // get balance of recipient token before trade to compare after trade.\n        uint balanceBeforeTrade = balanceOf(recipientToken);\n        if (recipientToken == ETH_TOKEN) {\n            balanceBeforeTrade = balanceBeforeTrade.safeSub(msg.value);\n        }\n        require(address(this).balance >= ethAmount, errorToString(Errors.TOKEN_NOT_ENOUGH));\n        (bool success, bytes memory result) = exchangeAddress.call{value: ethAmount}(callData);\n        require(success);\n\n        (address returnedTokenAddress, uint returnedAmount) = abi.decode(result, (address, uint));\n        require(returnedTokenAddress == recipientToken && balanceOf(recipientToken).safeSub(balanceBeforeTrade) == returnedAmount, errorToString(Errors.INVALID_RETURN_DATA));\n\n        return returnedAmount;\n    }\n\n    /**\n     * @dev verify sign data\n     */\n     function verifySignData(bytes memory data, bytes memory signData) internal returns(address){\n        bytes32 hash = keccak256(data);\n        require(!isSigDataUsed(hash), errorToString(Errors.ALREADY_USED));\n        address verifier = sigToAddress(signData, hash);\n       // mark data hash of sig as used\n        sigDataUsed[hash] = true;\n\n        return verifier;\n     }\n\n    /**\n      * @dev migrate balance from previous vault\n      * Note: uncomment for next version\n      */\n    function migrateBalance(address owner, address token) internal {\n        if (address(prevVault) != address(0x0) && !migration[owner][token]) {\n            withdrawRequests[owner][token] = withdrawRequests[owner][token].safeAdd(prevVault.getDepositedBalance(token, owner));\n  \t        migration[owner][token] = true;\n  \t   }\n    }\n\n    /**\n     * @dev Get the amount of specific coin for specific wallet\n     */\n    function getDepositedBalance(\n        address token,\n        address owner\n    ) public view returns (uint) {\n        if (address(prevVault) != address(0x0) && !migration[owner][token]) {\n \t        return withdrawRequests[owner][token].safeAdd(prevVault.getDepositedBalance(token, owner));\n \t    }\n        return withdrawRequests[owner][token];\n    }\n\n    /**\n     * @dev Move total number of assets to newVault\n     * @notice This only works when the preVault is Paused\n     * @notice This can only be called by preVault\n     * @param assets: address of the ERC20 tokens to move, 0x0 for ETH\n     * @param amounts: total number of the ERC20 tokens to move, 0x0 for ETH\n     */\n    function updateAssets(address[] calldata assets, uint[] calldata amounts) external onlyPreVault returns(bool) {\n        require(assets.length == amounts.length,  errorToString(Errors.NOT_EQUAL));\n        require(Withdrawable(prevVault).paused(), errorToString(Errors.PREVAULT_NOT_PAUSED));\n        for (uint i = 0; i < assets.length; i++) {\n            totalDepositedToSCAmount[assets[i]] = totalDepositedToSCAmount[assets[i]].safeAdd(amounts[i]);\n        }\n        emit UpdateTokenTotal(assets, amounts);\n\n        return true;\n    }\n\n    /**\n     * @dev Payable receive function to receive Ether from oldVault when migrating\n     */\n    receive() external payable {}\n\n    /**\n     * @dev Check if transfer() and transferFrom() of ERC20 succeeded or not\n     * This check is needed to fix https://github.com/ethereum/solidity/issues/4116\n     * This function is copied from https://github.com/AdExNetwork/adex-protocol-eth/blob/master/contracts/libs/SafeERC20.sol\n     */\n    function checkSuccess() private pure returns (bool) {\n\t\tuint256 returnValue = 0;\n\t\tassembly {\n\t\t\t// check number of bytes returned from last function call\n\t\t\tswitch returndatasize()\n\n\t\t\t// no bytes returned: assume success\n\t\t\tcase 0x0 {\n\t\t\t\treturnValue := 1\n\t\t\t}\n\n\t\t\t// 32 bytes returned: check if non-zero\n\t\t\tcase 0x20 {\n\t\t\t\t// copy 32 bytes into scratch space\n\t\t\t\treturndatacopy(0x0, 0x0, 0x20)\n\n\t\t\t\t// load those bytes into returnValue\n\t\t\t\treturnValue := mload(0x0)\n\t\t\t}\n\n\t\t\t// not sure what was returned: don't mark as success\n\t\t\tdefault { }\n\t\t}\n\t\treturn returnValue != 0;\n\t}\n\n    /**\n     * @dev convert enum to string value\n     */\n     function errorToString(Errors error) internal pure returns(string memory) {\n        uint8 erroNum = uint8(error);\n        uint maxlength = 10;\n        bytes memory reversed = new bytes(maxlength);\n        uint i = 0;\n        while (erroNum != 0) {\n            uint8 remainder = erroNum % 10;\n            erroNum = erroNum / 10;\n            reversed[i++] = byte(48 + remainder);\n        }\n        bytes memory s = new bytes(i + 1);\n        for (uint j = 0; j <= i; j++) {\n            s[j] = reversed[i - j];\n        }\n        return string(s);\n    }\n\n    /**\n     * @dev Get the decimals of an ERC20 token, return 0 if it isn't defined\n     * We check the returndatasize to covert both cases that the token has\n     * and doesn't have the function decimals()\n     */\n    function getDecimals(address token) public view returns (uint8) {\n        IERC20 erc20 = IERC20(token);\n        return uint8(erc20.decimals());\n    }\n\n    /**\n     * @dev Get the amount of coin deposited to this smartcontract\n     */\n    function balanceOf(address token) public view returns (uint) {\n        if (token == ETH_TOKEN) {\n            return address(this).balance;\n        }\n        return IERC20(token).balanceOf(address(this));\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinspect-Incognito Audit/bridge-eth-4879219669a38d601265582f815596b6775855b6/bridge/contracts/vault.sol",
        "vulnerability": "Assertion Failure",
        "check": "FP",
        "response": "Answer: No\nReason: No assertions (e.g., \"assert(condition)\") are present in the code, so no \"Assertion Failure\" vulnerability exists."
    },
    {
        "code_segment": "contract Vault {\n    using SafeMath for uint;\n    /**\n     * @dev Storage slot with the incognito proxy.\n     * This is the keccak-256 hash of \"eip1967.proxy.incognito.\" subtracted by 1\n     */\n    bytes32 private constant _INCOGNITO_SLOT = 0x62135fc083646fdb4e1a9d700e351b886a4a5a39da980650269edd1ade91ffd2;\n    address constant public ETH_TOKEN = 0x0000000000000000000000000000000000000000;\n    mapping(bytes32 => bool) public withdrawed;\n    mapping(bytes32 => bool) public sigDataUsed;\n    // address => token => amount\n    mapping(address => mapping(address => uint)) public withdrawRequests;\n    mapping(address => mapping(address => bool)) public migration;\n    mapping(address => uint) public totalDepositedToSCAmount;\n    Withdrawable public prevVault;\n    bool public notEntered = true;\n    bool public isInitialized = false;\n\n    struct BurnInstData {\n        uint8 meta; // type of the instruction\n        uint8 shard; // ID of the Incognito shard containing the instruction, must be 1\n        address token; // ETH address of the token contract (0x0 for ETH)\n        address payable to; // ETH address of the receiver of the token\n        uint amount; // burned amount (on Incognito)\n        bytes32 itx; // Incognito's burning tx\n    }\n\n    // error code\n    enum Errors {\n        EMPTY,\n        NO_REENTRANCE,\n        MAX_UINT_REACHED,\n        VALUE_OVER_FLOW,\n        INTERNAL_TX_ERROR,\n        ALREADY_USED,\n        INVALID_DATA,\n        TOKEN_NOT_ENOUGH,\n        WITHDRAW_REQUEST_TOKEN_NOT_ENOUGH,\n        INVALID_RETURN_DATA,\n        NOT_EQUAL,\n        NULL_VALUE,\n        ONLY_PREVAULT,\n        PREVAULT_NOT_PAUSED\n    }\n\n    event Deposit(address token, string incognitoAddress, uint amount);\n    event Withdraw(address token, address to, uint amount);\n    event UpdateTokenTotal(address[] assets, uint[] amounts);\n    event UpdateIncognitoProxy(address newIncognitoProxy);\n\n    /**\n     * modifier for contract version\n     */\n     modifier onlyPreVault(){\n        require(address(prevVault) != address(0x0) && msg.sender == address(prevVault), errorToString(Errors.ONLY_PREVAULT));\n        _;\n     }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, notEntered will be true\n        require(notEntered, errorToString(Errors.NO_REENTRANCE));\n\n        // Any calls to nonReentrant after this point will fail\n        notEntered = false;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        notEntered = true;\n    }\n\n    /**\n     * @dev Creates new Vault to hold assets for Incognito Chain\n     * @param _prevVault: previous version of the Vault to refer back if necessary\n     * After migrating all assets to a new Vault, we still need to refer\n     * back to previous Vault to make sure old withdrawals aren't being reused\n     */\n    function initialize(address _prevVault) external {\n        require(!isInitialized);\n        prevVault = Withdrawable(_prevVault);\n        isInitialized = true;\n        notEntered = true;\n    }\n\n    /**\n     * @dev Returns the current incognito proxy.\n     */\n    function _incognito() internal view returns (address icg) {\n        bytes32 slot = _INCOGNITO_SLOT;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            icg := sload(slot)\n        }\n    }\n\n    /**\n     * @dev Makes a ETH deposit to the vault to mint pETH over at Incognito Chain\n     * @notice This only works when the contract is not Paused\n     * @notice The maximum amount to deposit is capped since Incognito balance is stored as uint64\n     * @param incognitoAddress: Incognito Address to receive pETH\n     */\n    function deposit(string calldata incognitoAddress) external payable nonReentrant {\n        require(address(this).balance <= 10 ** 27, errorToString(Errors.MAX_UINT_REACHED));\n        emit Deposit(ETH_TOKEN, incognitoAddress, msg.value);\n    }\n\n    /**\n     * @dev Makes a ERC20 deposit to the vault to mint pERC20 over at Incognito Chain\n     * @notice This only works when the contract is not Paused\n     * @notice The maximum amount to deposit is capped since Incognito balance is stored as uint64\n     * @notice Before calling this function, enough ERC20 must be allowed to\n     * tranfer from msg.sender to this contract\n     * @param token: address of the ERC20 token\n     * @param amount: to deposit to the vault and mint on Incognito Chain\n     * @param incognitoAddress: Incognito Address to receive pERC20\n     */\n    function depositERC20(address token, uint amount, string calldata incognitoAddress) external payable nonReentrant {\n        IERC20 erc20Interface = IERC20(token);\n        uint8 decimals = getDecimals(address(token));\n        uint tokenBalance = erc20Interface.balanceOf(address(this));\n        uint beforeTransfer = tokenBalance;\n        uint emitAmount = amount;\n        if (decimals > 9) {\n            emitAmount = emitAmount / (10 ** (uint(decimals) - 9));\n            tokenBalance = tokenBalance / (10 ** (uint(decimals) - 9));\n        }\n        require(emitAmount <= 10 ** 18 && tokenBalance <= 10 ** 18 && emitAmount.safeAdd(tokenBalance) <= 10 ** 18, errorToString(Errors.VALUE_OVER_FLOW));\n        erc20Interface.transferFrom(msg.sender, address(this), amount);\n        require(checkSuccess(), errorToString(Errors.INTERNAL_TX_ERROR));\n        require(balanceOf(token).safeSub(beforeTransfer) == amount, errorToString(Errors.NOT_EQUAL));\n\n        emit Deposit(token, incognitoAddress, emitAmount);\n    }\n\n    /**\n     * @dev Checks if a burn proof has been used before\n     * @notice First, we check inside the storage of this contract itself. If the\n     * hash has been used before, we return the result. Otherwise, we query\n     * previous vault recursively until the first Vault (prevVault address is 0x0)\n     * @param hash: of the burn proof\n     * @return bool: whether the proof has been used or not\n     */\n    function isWithdrawed(bytes32 hash) public view returns(bool) {\n        if (withdrawed[hash]) {\n            return true;\n        } else if (address(prevVault) == address(0)) {\n            return false;\n        }\n        return prevVault.isWithdrawed(hash);\n    }\n\n    /**\n     * @dev Parses a burn instruction and returns the components\n     * @param inst: the full instruction, containing both metadata and body\n     */\n    function parseBurnInst(bytes memory inst) public pure returns (BurnInstData memory) {\n        BurnInstData memory data;\n        data.meta = uint8(inst[0]);\n        data.shard = uint8(inst[1]);\n        address token;\n        address payable to;\n        uint amount;\n        bytes32 itx;\n        assembly {\n            // skip first 0x20 bytes (stored length of inst)\n            token := mload(add(inst, 0x22)) // [3:34]\n            to := mload(add(inst, 0x42)) // [34:66]\n            amount := mload(add(inst, 0x62)) // [66:98]\n            itx := mload(add(inst, 0x82)) // [98:130]\n        }\n        data.token = token;\n        data.to = to;\n        data.amount = amount;\n        data.itx = itx;\n        return data;\n    }\n\n    /**\n     * @dev Verifies that a burn instruction is valid\n     * @notice All params except inst are the list of 2 elements corresponding to\n     * the proof on beacon and bridge\n     * @notice All params are the same as in `withdraw`\n     */\n    function verifyInst(\n        bytes memory inst,\n        uint heights,\n        bytes32[] memory instPaths,\n        bool[] memory instPathIsLefts,\n        bytes32 instRoots,\n        bytes32 blkData,\n        uint[] memory sigIdxs,\n        uint8[] memory sigVs,\n        bytes32[] memory sigRs,\n        bytes32[] memory sigSs\n    ) view internal {\n        // Each instruction can only by redeemed once\n        bytes32 beaconInstHash = keccak256(abi.encodePacked(inst, heights));\n\n        // Verify instruction on beacon\n        require(Incognito(_incognito()).instructionApproved(\n            true, // Only check instruction on beacon\n            beaconInstHash,\n            heights,\n            instPaths,\n            instPathIsLefts,\n            instRoots,\n            blkData,\n            sigIdxs,\n            sigVs,\n            sigRs,\n            sigSs\n        ), errorToString(Errors.INVALID_DATA));\n    }\n\n    /**\n     * @dev Withdraws pETH/pIERC20 by providing a burn proof over at Incognito Chain\n     * @notice This function takes a burn instruction on Incognito Chain, checks\n     * for its validity and returns the token back to ETH chain\n     * @notice This only works when the contract is not Paused\n     * @param inst: the decoded instruction as a list of bytes\n     * @param heights: the blocks containing the instruction\n     * @param instPaths: merkle path of the instruction\n     * @param instPathIsLefts: whether each node on the path is the left or right child\n     * @param instRoots: root of the merkle tree contains all instructions\n     * @param blkData: merkle has of the block body\n     * @param sigIdxs: indices of the validators who signed this block\n     * @param sigVs: part of the signatures of the validators\n     * @param sigRs: part of the signatures of the validators\n     * @param sigSs: part of the signatures of the validators\n     */\n    function withdraw(\n        bytes memory inst,\n        uint heights,\n        bytes32[] memory instPaths,\n        bool[] memory instPathIsLefts,\n        bytes32 instRoots,\n        bytes32 blkData,\n        uint[] memory sigIdxs,\n        uint8[] memory sigVs,\n        bytes32[] memory sigRs,\n        bytes32[] memory sigSs\n    ) public nonReentrant {\n        require(inst.length >= 130);\n        BurnInstData memory data = parseBurnInst(inst);\n        require(data.meta == 241 && data.shard == 1); // Check instruction type\n\n        // Not withdrawed\n        require(!isWithdrawed(data.itx), errorToString(Errors.ALREADY_USED));\n        withdrawed[data.itx] = true;\n\n        // Check if balance is enough\n        if (data.token == ETH_TOKEN) {\n            require(address(this).balance >= data.amount.safeAdd(totalDepositedToSCAmount[data.token]), errorToString(Errors.TOKEN_NOT_ENOUGH));\n        } else {\n            uint8 decimals = getDecimals(data.token);\n            if (decimals > 9) {\n                data.amount = data.amount * (10 ** (uint(decimals) - 9));\n            }\n            require(IERC20(data.token).balanceOf(address(this)) >= data.amount.safeAdd(totalDepositedToSCAmount[data.token]), errorToString(Errors.TOKEN_NOT_ENOUGH));\n        }\n\n        verifyInst(\n            inst,\n            heights,\n            instPaths,\n            instPathIsLefts,\n            instRoots,\n            blkData,\n            sigIdxs,\n            sigVs,\n            sigRs,\n            sigSs\n        );\n\n        // Send and notify\n        if (data.token == ETH_TOKEN) {\n          (bool success, ) =  data.to.call{value: data.amount}(\"\");\n          require(success, errorToString(Errors.INTERNAL_TX_ERROR));\n        } else {\n            IERC20(data.token).transfer(data.to, data.amount);\n            require(checkSuccess(), errorToString(Errors.INTERNAL_TX_ERROR));\n        }\n        emit Withdraw(data.token, data.to, data.amount);\n    }\n\n    /**\n     * @dev Burnt Proof is submited to store burnt amount of p-token/p-ETH and receiver's address\n     * Receiver then can call withdrawRequest to withdraw these token to he/she incognito address.\n     * @notice This function takes a burn instruction on Incognito Chain, checks\n     * for its validity and returns the token back to ETH chain\n     * @notice This only works when the contract is not Paused\n     * @param inst: the decoded instruction as a list of bytes\n     * @param heights: the blocks containing the instruction\n     * @param instPaths: merkle path of the instruction\n     * @param instPathIsLefts: whether each node on the path is the left or right child\n     * @param instRoots: root of the merkle tree contains all instructions\n     * @param blkData: merkle has of the block body\n     * @param sigIdxs: indices of the validators who signed this block\n     * @param sigVs: part of the signatures of the validators\n     * @param sigRs: part of the signatures of the validators\n     * @param sigSs: part of the signatures of the validators\n     */\n    function submitBurnProof(\n        bytes memory inst,\n        uint heights,\n        bytes32[] memory instPaths,\n        bool[] memory instPathIsLefts,\n        bytes32 instRoots,\n        bytes32 blkData,\n        uint[] memory sigIdxs,\n        uint8[] memory sigVs,\n        bytes32[] memory sigRs,\n        bytes32[] memory sigSs\n    ) public nonReentrant {\n        require(inst.length >= 130);\n        BurnInstData memory data = parseBurnInst(inst);\n        require(data.meta == 243 && data.shard == 1); // Check instruction type\n\n        // Not withdrawed\n        require(!isWithdrawed(data.itx), errorToString(Errors.ALREADY_USED));\n        withdrawed[data.itx] = true;\n\n        // Check if balance is enough\n        if (data.token == ETH_TOKEN) {\n            require(address(this).balance >= data.amount.safeAdd(totalDepositedToSCAmount[data.token]), errorToString(Errors.TOKEN_NOT_ENOUGH));\n        } else {\n            uint8 decimals = getDecimals(data.token);\n            if (decimals > 9) {\n                // SWC-101-Integer Overflow and Underflow: L409\n                data.amount = data.amount * (10 ** (uint(decimals) - 9));\n            }\n            require(IERC20(data.token).balanceOf(address(this)) >= data.amount.safeAdd(totalDepositedToSCAmount[data.token]), errorToString(Errors.TOKEN_NOT_ENOUGH));\n        }\n\n        verifyInst(\n            inst,\n            heights,\n            instPaths,\n            instPathIsLefts,\n            instRoots,\n            blkData,\n            sigIdxs,\n            sigVs,\n            sigRs,\n            sigSs\n        );\n\n        withdrawRequests[data.to][data.token] = withdrawRequests[data.to][data.token].safeAdd(data.amount);\n        totalDepositedToSCAmount[data.token] = totalDepositedToSCAmount[data.token].safeAdd(data.amount);\n    }\n\n    /**\n     * @dev generate address from signature data and hash.\n     */\n    function sigToAddress(bytes memory signData, bytes32 hash) public pure returns (address) {\n        bytes32 s;\n        bytes32 r;\n        uint8 v;\n        assembly {\n            r := mload(add(signData, 0x20))\n            s := mload(add(signData, 0x40))\n        }\n        v = uint8(signData[64]) + 27;\n        return ecrecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Checks if a sig data has been used before\n     * @notice First, we check inside the storage of this contract itself. If the\n     * hash has been used before, we return the result. Otherwise, we query\n     * previous vault recursively until the first Vault (prevVault address is 0x0)\n     * @param hash: of the sig data\n     * @return bool: whether the sig data has been used or not\n     */\n    function isSigDataUsed(bytes32 hash) public view returns(bool) {\n        if (sigDataUsed[hash]) {\n            return true;\n        } else if (address(prevVault) == address(0)) {\n            return false;\n        }\n        return prevVault.isSigDataUsed(hash);\n    }\n\n    /**\n     * @dev User requests withdraw token contains in withdrawRequests.\n     * Deposit event will be emitted to let incognito recognize and mint new p-tokens for the user.\n     * @param incognitoAddress: incognito's address that will receive minted p-tokens.\n     * @param token: ethereum's token address (eg., ETH, DAI, ...)\n     * @param amount: amount of the token in ethereum's denomination\n     * @param signData: signature of an unique data that is signed by an account which is generated from user's incognito privkey\n     * @param timestamp: unique data generated from client (timestamp for example)\n     */\n    function requestWithdraw(\n        string calldata incognitoAddress,\n        address token,\n        uint amount,\n        bytes calldata signData,\n        bytes calldata timestamp\n    ) external nonReentrant {\n        // verify owner signs data\n        address verifier = verifySignData(abi.encode(incognitoAddress, token, timestamp, amount), signData);\n\n        // migrate from preVault\n        migrateBalance(verifier, token);\n\n        require(withdrawRequests[verifier][token] >= amount, errorToString(Errors.WITHDRAW_REQUEST_TOKEN_NOT_ENOUGH));\n        withdrawRequests[verifier][token] = withdrawRequests[verifier][token].safeSub(amount);\n        totalDepositedToSCAmount[token] = totalDepositedToSCAmount[token].safeSub(amount);\n\n        // convert denomination from ethereum's to incognito's (pcoin)\n        uint emitAmount = amount;\n        if (token != ETH_TOKEN) {\n            uint8 decimals = getDecimals(token);\n            if (decimals > 9) {\n                emitAmount = amount / (10 ** (uint(decimals) - 9));\n            }\n        }\n\n        emit Deposit(token, incognitoAddress, emitAmount);\n    }\n\n    /**\n     * @dev execute is a general function that plays a role as proxy to interact to other smart contracts.\n     * @param token: ethereum's token address (eg., ETH, DAI, ...)\n     * @param amount: amount of the token in ethereum's denomination\n     * @param recipientToken: received token address.\n     * @param exchangeAddress: address of targeting smart contract that actually executes the desired logics like trade, invest, borrow and so on.\n     * @param callData: encoded with signature and params of function from targeting smart contract.\n     * @param timestamp: unique data generated from client (timestamp for example)\n     * @param signData: signature of an unique data that is signed by an account which is generated from user's incognito privkey\n     */\n    //  SWC-114-Transaction Order Dependence: L512 - L547\n    // SWC-105-Unprotected Ether Withdrawal: L513 - 548\n    function execute(\n        address token,\n        uint amount,\n        address recipientToken,\n        address exchangeAddress,\n        bytes calldata callData,\n        bytes calldata timestamp,\n        bytes calldata signData\n    ) external payable nonReentrant {\n        //verify ower signs data from input\n        address verifier = verifySignData(abi.encode(exchangeAddress, callData, timestamp, amount), signData);\n\n        // migrate from preVault\n        migrateBalance(verifier, token);\n        require(withdrawRequests[verifier][token] >= amount, errorToString(Errors.WITHDRAW_REQUEST_TOKEN_NOT_ENOUGH));\n\n        // update balance of verifier\n        totalDepositedToSCAmount[token] = totalDepositedToSCAmount[token].safeSub(amount);\n        withdrawRequests[verifier][token] = withdrawRequests[verifier][token].safeSub(amount);\n\n        // define number of eth spent for forwarder.\n        uint ethAmount = msg.value;\n        if (token == ETH_TOKEN) {\n            ethAmount = ethAmount.safeAdd(amount);\n        } else {\n            // transfer token to exchangeAddress.\n            require(IERC20(token).balanceOf(address(this)) >= amount, errorToString(Errors.TOKEN_NOT_ENOUGH));\n            IERC20(token).transfer(exchangeAddress, amount);\n            require(checkSuccess(), errorToString(Errors.INTERNAL_TX_ERROR));\n        }\n        uint returnedAmount = callExtFunc(recipientToken, ethAmount, callData, exchangeAddress);\n\n        // update withdrawRequests\n        withdrawRequests[verifier][recipientToken] = withdrawRequests[verifier][recipientToken].safeAdd(returnedAmount);\n        totalDepositedToSCAmount[recipientToken] = totalDepositedToSCAmount[recipientToken].safeAdd(returnedAmount);\n    }\n\n    /**\n     * @dev single trade\n     */\n    function callExtFunc(address recipientToken, uint ethAmount, bytes memory callData, address exchangeAddress) internal returns (uint) {\n         // get balance of recipient token before trade to compare after trade.\n        uint balanceBeforeTrade = balanceOf(recipientToken);\n        if (recipientToken == ETH_TOKEN) {\n            balanceBeforeTrade = balanceBeforeTrade.safeSub(msg.value);\n        }\n        require(address(this).balance >= ethAmount, errorToString(Errors.TOKEN_NOT_ENOUGH));\n        (bool success, bytes memory result) = exchangeAddress.call{value: ethAmount}(callData);\n        require(success);\n\n        (address returnedTokenAddress, uint returnedAmount) = abi.decode(result, (address, uint));\n        require(returnedTokenAddress == recipientToken && balanceOf(recipientToken).safeSub(balanceBeforeTrade) == returnedAmount, errorToString(Errors.INVALID_RETURN_DATA));\n\n        return returnedAmount;\n    }\n\n    /**\n     * @dev verify sign data\n     */\n     function verifySignData(bytes memory data, bytes memory signData) internal returns(address){\n        bytes32 hash = keccak256(data);\n        require(!isSigDataUsed(hash), errorToString(Errors.ALREADY_USED));\n        address verifier = sigToAddress(signData, hash);\n       // mark data hash of sig as used\n        sigDataUsed[hash] = true;\n\n        return verifier;\n     }\n\n    /**\n      * @dev migrate balance from previous vault\n      * Note: uncomment for next version\n      */\n    function migrateBalance(address owner, address token) internal {\n        if (address(prevVault) != address(0x0) && !migration[owner][token]) {\n            withdrawRequests[owner][token] = withdrawRequests[owner][token].safeAdd(prevVault.getDepositedBalance(token, owner));\n  \t        migration[owner][token] = true;\n  \t   }\n    }\n\n    /**\n     * @dev Get the amount of specific coin for specific wallet\n     */\n    function getDepositedBalance(\n        address token,\n        address owner\n    ) public view returns (uint) {\n        if (address(prevVault) != address(0x0) && !migration[owner][token]) {\n \t        return withdrawRequests[owner][token].safeAdd(prevVault.getDepositedBalance(token, owner));\n \t    }\n        return withdrawRequests[owner][token];\n    }\n\n    /**\n     * @dev Move total number of assets to newVault\n     * @notice This only works when the preVault is Paused\n     * @notice This can only be called by preVault\n     * @param assets: address of the ERC20 tokens to move, 0x0 for ETH\n     * @param amounts: total number of the ERC20 tokens to move, 0x0 for ETH\n     */\n    function updateAssets(address[] calldata assets, uint[] calldata amounts) external onlyPreVault returns(bool) {\n        require(assets.length == amounts.length,  errorToString(Errors.NOT_EQUAL));\n        require(Withdrawable(prevVault).paused(), errorToString(Errors.PREVAULT_NOT_PAUSED));\n        for (uint i = 0; i < assets.length; i++) {\n            totalDepositedToSCAmount[assets[i]] = totalDepositedToSCAmount[assets[i]].safeAdd(amounts[i]);\n        }\n        emit UpdateTokenTotal(assets, amounts);\n\n        return true;\n    }\n\n    /**\n     * @dev Payable receive function to receive Ether from oldVault when migrating\n     */\n    receive() external payable {}\n\n    /**\n     * @dev Check if transfer() and transferFrom() of ERC20 succeeded or not\n     * This check is needed to fix https://github.com/ethereum/solidity/issues/4116\n     * This function is copied from https://github.com/AdExNetwork/adex-protocol-eth/blob/master/contracts/libs/SafeERC20.sol\n     */\n    function checkSuccess() private pure returns (bool) {\n\t\tuint256 returnValue = 0;\n\t\tassembly {\n\t\t\t// check number of bytes returned from last function call\n\t\t\tswitch returndatasize()\n\n\t\t\t// no bytes returned: assume success\n\t\t\tcase 0x0 {\n\t\t\t\treturnValue := 1\n\t\t\t}\n\n\t\t\t// 32 bytes returned: check if non-zero\n\t\t\tcase 0x20 {\n\t\t\t\t// copy 32 bytes into scratch space\n\t\t\t\treturndatacopy(0x0, 0x0, 0x20)\n\n\t\t\t\t// load those bytes into returnValue\n\t\t\t\treturnValue := mload(0x0)\n\t\t\t}\n\n\t\t\t// not sure what was returned: don't mark as success\n\t\t\tdefault { }\n\t\t}\n\t\treturn returnValue != 0;\n\t}\n\n    /**\n     * @dev convert enum to string value\n     */\n     function errorToString(Errors error) internal pure returns(string memory) {\n        uint8 erroNum = uint8(error);\n        uint maxlength = 10;\n        bytes memory reversed = new bytes(maxlength);\n        uint i = 0;\n        while (erroNum != 0) {\n            uint8 remainder = erroNum % 10;\n            erroNum = erroNum / 10;\n            reversed[i++] = byte(48 + remainder);\n        }\n        bytes memory s = new bytes(i + 1);\n        for (uint j = 0; j <= i; j++) {\n            s[j] = reversed[i - j];\n        }\n        return string(s);\n    }\n\n    /**\n     * @dev Get the decimals of an ERC20 token, return 0 if it isn't defined\n     * We check the returndatasize to covert both cases that the token has\n     * and doesn't have the function decimals()\n     */\n    function getDecimals(address token) public view returns (uint8) {\n        IERC20 erc20 = IERC20(token);\n        return uint8(erc20.decimals());\n    }\n\n    /**\n     * @dev Get the amount of coin deposited to this smartcontract\n     */\n    function balanceOf(address token) public view returns (uint) {\n        if (token == ETH_TOKEN) {\n            return address(this).balance;\n        }\n        return IERC20(token).balanceOf(address(this));\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinspect-Incognito Audit/bridge-eth-4879219669a38d601265582f815596b6775855b6/bridge/contracts/vault.sol",
        "vulnerability": "Assertion Failure",
        "check": "FP",
        "response": "Answer: No\nReason: The contract uses assertions and require statements appropriately to handle different conditions, and there are no unchecked assertions that could potentially always fail."
    },
    {
        "code_segment": "contract BEP20Token is Context, IBEP20, Ownable {\n  using SafeMath for uint256;\n\n  mapping (address => uint256) private _balances;\n\n  mapping (address => mapping (address => uint256)) private _allowances;\n\n  uint256 private _totalSupply;\n  uint8 private _decimals;\n  string private _symbol;\n  string private _name;\n\n  constructor() public {\n    _name = \"April Token\";\n    _symbol = \"APRIL\";\n    _decimals = 18;\n    _totalSupply = 125000000000000000000000000;\n    _balances[msg.sender] = _totalSupply;\n\n    emit Transfer(address(0), msg.sender, _totalSupply);\n  }\n\n  /**\n   * @dev Returns the bep token owner.\n   */\n  function getOwner() external view returns (address) {\n    return owner();\n  }\n\n  /**\n   * @dev Returns the token decimals.\n   */\n  function decimals() external view returns (uint8) {\n    return _decimals;\n  }\n\n  /**\n   * @dev Returns the token symbol.\n   */\n  function symbol() external view returns (string memory) {\n    return _symbol;\n  }\n\n  /**\n  * @dev Returns the token name.\n  */\n  function name() external view returns (string memory) {\n    return _name;\n  }\n\n  /**\n   * @dev See {BEP20-totalSupply}.\n   */\n  function totalSupply() external view returns (uint256) {\n    return _totalSupply;\n  }\n\n  /**\n   * @dev See {BEP20-balanceOf}.\n   */\n  function balanceOf(address account) external view returns (uint256) {\n    return _balances[account];\n  }\n\n  /**\n   * @dev See {BEP20-transfer}.\n   *\n   * Requirements:\n   *\n   * - `recipient` cannot be the zero address.\n   * - the caller must have a balance of at least `amount`.\n   */\n  function transfer(address recipient, uint256 amount) external returns (bool) {\n    _transfer(_msgSender(), recipient, amount);\n    return true;\n  }\n\n  /**\n   * @dev See {BEP20-allowance}.\n   */\n  function allowance(address owner, address spender) external view returns (uint256) {\n    return _allowances[owner][spender];\n  }\n\n  /**\n   * @dev See {BEP20-approve}.\n   *\n   * Requirements:\n   *\n   * - `spender` cannot be the zero address.\n   */\n  function approve(address spender, uint256 amount) external returns (bool) {\n    _approve(_msgSender(), spender, amount);\n    return true;\n  }\n\n  /**\n   * @dev See {BEP20-transferFrom}.\n   *\n   * Emits an {Approval} event indicating the updated allowance. This is not\n   * required by the EIP. See the note at the beginning of {BEP20};\n   *\n   * Requirements:\n   * - `sender` and `recipient` cannot be the zero address.\n   * - `sender` must have a balance of at least `amount`.\n   * - the caller must have allowance for `sender`'s tokens of at least\n   * `amount`.\n   */\n  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool) {\n    _transfer(sender, recipient, amount);\n    _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"BEP20: transfer amount exceeds allowance\"));\n    return true;\n  }\n\n  /**\n   * @dev Atomically increases the allowance granted to `spender` by the caller.\n   *\n   * This is an alternative to {approve} that can be used as a mitigation for\n   * problems described in {BEP20-approve}.\n   *\n   * Emits an {Approval} event indicating the updated allowance.\n   *\n   * Requirements:\n   *\n   * - `spender` cannot be the zero address.\n   */\n  function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n    _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n    return true;\n  }\n\n  /**\n   * @dev Atomically decreases the allowance granted to `spender` by the caller.\n   *\n   * This is an alternative to {approve} that can be used as a mitigation for\n   * problems described in {BEP20-approve}.\n   *\n   * Emits an {Approval} event indicating the updated allowance.\n   *\n   * Requirements:\n   *\n   * - `spender` cannot be the zero address.\n   * - `spender` must have allowance for the caller of at least\n   * `subtractedValue`.\n   */\n  function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n    _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"BEP20: decreased allowance below zero\"));\n    return true;\n  }\n  /**\n   * @dev Moves tokens `amount` from `sender` to `recipient`.\n   *\n   * This is internal function is equivalent to {transfer}, and can be used to\n   * e.g. implement automatic token fees, slashing mechanisms, etc.\n   *\n   * Emits a {Transfer} event.\n   *\n   * Requirements:\n   *\n   * - `sender` cannot be the zero address.\n   * - `recipient` cannot be the zero address.\n   * - `sender` must have a balance of at least `amount`.\n   */\n  function _transfer(address sender, address recipient, uint256 amount) internal {\n    require(sender != address(0), \"BEP20: transfer from the zero address\");\n    require(recipient != address(0), \"BEP20: transfer to the zero address\");\n\n    _balances[sender] = _balances[sender].sub(amount, \"BEP20: transfer amount exceeds balance\");\n    _balances[recipient] = _balances[recipient].add(amount);\n    emit Transfer(sender, recipient, amount);\n  }\n\n  /**\n   * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\n   *\n   * This is internal function is equivalent to `approve`, and can be used to\n   * e.g. set automatic allowances for certain subsystems, etc.\n   *\n   * Emits an {Approval} event.\n   *\n   * Requirements:\n   *\n   * - `owner` cannot be the zero address.\n   * - `spender` cannot be the zero address.\n   */\n  function _approve(address owner, address spender, uint256 amount) internal {\n    require(owner != address(0), \"BEP20: approve from the zero address\");\n    require(spender != address(0), \"BEP20: approve to the zero address\");\n\n    _allowances[owner][spender] = amount;\n    emit Approval(owner, spender, amount);\n  }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/QuillAudits-April Smart Contract/code/BEP20Token.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No\nReason: The contract uses SafeMath library for arithmetic operations, which protects against integer overflow vulnerabilities."
    },
    {
        "code_segment": "contract ProjectKudos {\n    \n    // votes limit for judge\n    uint KUDOS_LIMIT_JUDGE = 1000;\n\n    // votes limit for regular user\n    uint KUDOS_LIMIT_USER  = 10;\n\n    // enumerates reasons \n    // which additional votes can be granted for\n    enum GrantReason {\n        Facebook,\n        Twitter, \n        Fake\n    }\n//    SWC-135-Code With No Effects:L20-24,281-303,313-320\n    // keeps project votes data\n    struct ProjectInfo {\n        mapping(address => uint) kudosByUser;\n        uint kudosTotal;\n    }\n\n    // keeps user votes data\n    struct UserInfo {\n        uint kudosLimit;\n        uint kudosGiven;\n        bool isJudge;\n        mapping(uint => bool) grant;\n    }\n\n    // keeps links between user's votes \n    // and projects he voted for\n    struct UserIndex {\n        bytes32[] projects;\n        uint[] kudos;\n        mapping(bytes32 => uint) kudosIdx;\n    }\n    \n    // keeps time frames for vote period \n    struct VotePeriod {\n        uint start;\n        uint end;\n    }\n    \n    // contract creator's address\n    address owner;\n    \n    // vote period\n    VotePeriod votePeriod;\n\n    // user votes mapping\n    mapping(address => UserInfo) users;\n\n    // user index, \n    // helps to get votes given by one user for every project\n    mapping(address => UserIndex) usersIndex;\n\n    // project votes mapping\n    mapping(bytes32 => ProjectInfo) projects;\n    \n    // emitted when vote is done\n    event Vote(\n        // address of voter\n        address indexed voter,\n        // sha3 of project code\n        bytes32 indexed projectCode,\n        // votes given\n        uint indexed count\n    );\n    \n    /**\n     * @dev Contract's constructor.\n     * Stores contract's owner and sets up vote period\n     */\n    function ProjectKudos() {\n        \n        owner = msg.sender;\n        \n        votePeriod = VotePeriod(\n            1479996000,     // GMT: 24-Nov-2016 14:00, Voting starts, 1st week passed\n            1482415200      // GMT: 22-Dec-2016 14:00, Voting ends, Hackathon ends\n        );\n    }\n\n    /**\n     * @dev Registers voter to the event.\n     * Executable only by contract's owner.\n     *\n     * @param userAddres address of the user to register\n     * @param isJudge should be true if user is judge, false otherwise\n     */\n    function register(address userAddres, bool isJudge) onlyOwner {\n                            \n        UserInfo user = users[userAddres];\n\n        if (user.kudosLimit > 0) throw;\n\n        if (isJudge)\n            user.kudosLimit = KUDOS_LIMIT_JUDGE;\n        else \n            user.kudosLimit = KUDOS_LIMIT_USER;\n        \n        user.isJudge = isJudge;\n        \n        users[userAddres] = user;\n    }\n    \n    /**\n     *  @dev Gives votes to the project.\n     *  Can only be executed within vote period.\n     *  User signed the Tx becomes votes giver.\n     *\n     *  @param projectCode code of the project, must be less than or equal to 32 bytes\n     *  @param kudos - votes to be given\n     */\n    function giveKudos(string projectCode, uint kudos) duringVote {\n        \n        UserInfo giver = users[msg.sender];\n\n        if (giver.kudosGiven + kudos > giver.kudosLimit) throw;\n        \n        bytes32 code = strToBytes(projectCode);\n        ProjectInfo project = projects[code];\n\n        giver.kudosGiven += kudos;\n        project.kudosTotal += kudos;\n        project.kudosByUser[msg.sender] += kudos;\n\n        // save index of user voting history\n        updateUsersIndex(code, project.kudosByUser[msg.sender]);\n        \n        Vote(msg.sender, sha3(projectCode), kudos);\n    }\n\n    /**\n     * @dev Grants extra kudos for identity proof.\n     *\n     * @param userToGrant address of user to grant additional \n     * votes for social proof\n     * \n     * @param reason granting reason, \n     * possible reasons are listed in GrantReason enum\n     */         \n    function grantKudos(address userToGrant, uint reason) onlyOwner {\n    \n        UserInfo user = users[userToGrant];\n    \n        GrantReason grantReason = grantUintToReason(reason);\n        \n        if (grantReason != GrantReason.Facebook &&\n            grantReason != GrantReason.Twitter) throw;\n    \n        // if user is judge his identity is known\n        // not reasonble to grant more kudos for social \n        // proof.\n        if (user.isJudge) throw;\n        \n        // if not granted for that reason yet\n        if (user.grant[reason]) throw;\n        \n        // grant 100 votes\n        user.kudosLimit += 100;\n        \n        // mark reason \n        user.grant[reason] = true;\n    }\n    \n    \n    // ********************* //\n    // *   Constant Calls  * //\n    // ********************* //\n    \n    /**\n     * @dev Returns total votes given to the project\n     * \n     * @param projectCode project's code\n     * \n     * @return number of give votes\n     */\n    function getProjectKudos(string projectCode) constant returns(uint) {\n        bytes32 code = strToBytes(projectCode);\n        ProjectInfo project = projects[code];\n        return project.kudosTotal;\n    }\n\n    /**\n     * @dev Returns an array of votes given to the project\n     * corresponding to array of users passed in function call\n     * \n     * @param projectCode project's code\n     * @param users array of user addresses\n     * \n     * @return array of votes given by passed users\n     */\n    function getProjectKudosByUsers(string projectCode, address[] users) constant returns(uint[]) {\n        bytes32 code = strToBytes(projectCode);\n        ProjectInfo project = projects[code];\n        mapping(address => uint) kudosByUser = project.kudosByUser;\n        uint[] memory userKudos = new uint[](users.length);\n        for (uint i = 0; i < users.length; i++) {\n            userKudos[i] = kudosByUser[users[i]];    \n       }\n       \n       return userKudos;\n    }\n\n    /**\n     * @dev Returns votes given by speicified user \n     * to the list of projects ever voted by that user\n     * \n     * @param giver user's address\n     * @return projects array of project codes represented by bytes32 array\n     * @return kudos array of votes given by user, \n     *         index of vote corresponds to index of project from projects array\n     */\n    function getKudosPerProject(address giver) constant returns (bytes32[] projects, uint[] kudos) {\n        UserIndex idx = usersIndex[giver];\n        projects = idx.projects;\n        kudos = idx.kudos;\n    }\n\n    /**\n     * @dev Returns votes allowed to be given by user\n     * \n     * @param addr user's address\n     * @return number of votes left\n     */\n    function getKudosLeft(address addr) constant returns(uint) {\n        UserInfo user = users[addr];\n        return user.kudosLimit - user.kudosGiven;\n    }\n\n    /**\n     * @dev Returns votes given by user\n     * \n     * @param addr user's address\n     * @return number of votes given\n     */\n    function getKudosGiven(address addr) constant returns(uint) {\n        UserInfo user = users[addr];\n        return user.kudosGiven;\n    }\n\n   \n    // ********************* //\n    // *   Private Calls   * //\n    // ********************* //\n    \n    /**\n     * @dev Private function. Updates users index\n     * \n     * @param code project code represented by bytes32 array\n     * @param kudos votes total given to the project by sender\n     */\n    function updateUsersIndex(bytes32 code, uint kudos) private {\n        \n        UserIndex idx = usersIndex[msg.sender];\n        uint i = idx.kudosIdx[code];\n        \n        // add new entry to index\n        if (i == 0) {\n            i = idx.projects.length + 1;\n            idx.projects.length += 1;\n            idx.kudos.length += 1;\n            idx.projects[i - 1] = code;\n            idx.kudosIdx[code] = i;\n        }\n\n        idx.kudos[i - 1] = kudos;\n    }\n    \n    /**\n     * @dev Translates GrantReason code to GrantReason\n     * \n     * @param reason the code of the reason\n     * @return GrantReason corresponding to the code\n     */\n    function grantUintToReason(uint reason) private returns (GrantReason result) {\n        if (reason == 0)  return GrantReason.Facebook;\n        if (reason == 1)  return GrantReason.Twitter;\n        return GrantReason.Fake;\n    }\n    \n    /**\n     * @dev Translates GrantReason to its code\n     * \n     * @param reason GrantReason instance\n     * @return corresponding reason code\n     */\n    function grantReasonToUint(GrantReason reason) private returns (uint result) {\n        if (reason == GrantReason.Facebook) return 0;\n        if (reason == GrantReason.Twitter)  return 1;\n        return 3;\n    }\n    \n    /**\n     * @dev Low level function.\n     * Converts string to bytes32 array.\n     * Throws if string length is more than 32 bytes\n     * \n     * @param str string\n     * @return bytes32 representation of str\n     */\n    function strToBytes(string str) private returns (bytes32 ret) {\n        \n        if (bytes(str).length > 32) throw;\n        \n        assembly {\n            ret := mload(add(str, 32))\n        }\n    } \n\n    \n    // ********************* //\n    // *     Modifiers     * //\n    // ********************* //\n//    SWC-135-Code With No Effects:L330-334\n    /**\n     * @dev Throws if called not during the vote period\n     */\n    modifier duringVote() {\n        if (now < votePeriod.start) throw;\n        if (now >= votePeriod.end) throw;\n        _;\n    }\n//    SWC-116-Block values as a proxy for time:L331,332\n    /**\n     * @dev Throws if called not by contract's owner\n     */\n    modifier onlyOwner() { \n        if (msg.sender != owner) throw;\n        _;\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/openzeppelin-EtherCamp_ProjectKudos_public_code/virtual-accelerator-6665fdd4b71088443a74d1ed9fda52c6a8c8b975/ProjectKudos.sol",
        "vulnerability": "Block Dependency",
        "check": "TP",
        "response": "Answer: Yes\nDescription: The `duringVote` modifier uses `now`, a block timestamp, to determine whether the function can execute, leading to block dependency."
    },
    {
        "code_segment": "contract BlockhashRegistry {\n\n    \n    event LogBlockhashAdded(uint indexed blockNr, bytes32 indexed bhash);\n\n    \n    mapping(uint => bytes32) public blockhashMapping;\n\n    \n    \n    constructor() public {\n        snapshot();\n    }\n\n    \n    \n    \n    \n    function searchForAvailableBlock(uint _startNumber, uint _numBlocks) external view returns (uint) {\n\n        for (uint i = _startNumber; i <= (_numBlocks + _startNumber); i++) {\n            if (blockhashMapping[i] != 0x0) {\n                return i;\n            }\n        }\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    function recreateBlockheaders(uint _blockNumber, bytes[] memory _blockheaders) public {\n\n        bytes32 currentBlockhash = blockhashMapping[_blockNumber];\n        require(currentBlockhash != 0x0, \"parentBlock is not available\");\n\n        bytes32 calculatedHash = reCalculateBlockheaders(_blockheaders, currentBlockhash);\n        require(calculatedHash != 0x0, \"invalid headers\");\n\n        \n        assert(_blockNumber > _blockheaders.length);\n        uint bnr = _blockNumber - _blockheaders.length;\n        blockhashMapping[bnr] = calculatedHash;\n        emit LogBlockhashAdded(bnr, calculatedHash);\n    }\n\n    \n    \n    \n    function saveBlockNumber(uint _blockNumber) public {\n\n        bytes32 bHash = blockhash(_blockNumber);\n\n        require(bHash != 0x0, \"block not available\");\n\n        blockhashMapping[_blockNumber] = bHash;\n        emit LogBlockhashAdded(_blockNumber, bHash);\n    }\n\n    \n    function snapshot() public {\n        \n        saveBlockNumber(block.number-1);\n    }\n\n    \n    \n    \n    function getParentAndBlockhash(bytes memory _blockheader) public pure returns (bytes32 parentHash, bytes32 bhash) {\n\n        \n        uint8 first = uint8(_blockheader[0]);\n\n        \n        \n        \n        require(first > 0xf7, \"invalid offset\");\n        uint8 offset = first - 0xf7 + 2;\n\n        \n        // solium-disable-next-line security/no-inline-assembly\n        assembly { // solhint-disable-line no-inline-assembly\n            // mstore to get the memory pointer of the blockheader to 0x20\n            mstore(0x20, _blockheader)\n\n            // we load the pointer we just stored\n            // then we add 0x20 (32 bytes) to get to the start of the blockheader\n            // then we add the offset we calculated\n            // and load it to the parentHash variable\n            parentHash :=mload(\n                add(\n                    add(\n                        mload(0x20), 0x20\n                    ), offset)\n            )\n        }\n        bhash = keccak256(_blockheader);\n    }\n\n    \n    \n    \n    \n    \n    function reCalculateBlockheaders(bytes[] memory _blockheaders, bytes32 _bHash) public pure returns (bytes32 bhash) {\n\n        bytes32 currentBlockhash = _bHash;\n        bytes32 calcParent = 0x0;\n        bytes32 calcBlockhash = 0x0;\n\n        \n        for (uint i = 0; i < _blockheaders.length; i++) {\n            (calcParent, calcBlockhash) = getParentAndBlockhash(_blockheaders[i]);\n            if (calcBlockhash != currentBlockhash) {\n                return 0x0;\n            }\n            currentBlockhash = calcParent;\n        }\n\n        return currentBlockhash;\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/consensys-Slockit_Incubed3/in3-contracts-e25c758a115aef0c0640bc446027259aa7cb1a52/contracts/NodeRegistry.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: Yes\nDescription: Potential for integer overflow in the \"searchForAvailableBlock\" function where \"_numBlocks + _startNumber\" might overflow."
    },
    {
        "code_segment": "contract BlockhashRegistry {\n\n    \n    event LogBlockhashAdded(uint indexed blockNr, bytes32 indexed bhash);\n\n    \n    mapping(uint => bytes32) public blockhashMapping;\n\n    \n    \n    constructor() public {\n        snapshot();\n    }\n\n    \n    \n    \n    \n    function searchForAvailableBlock(uint _startNumber, uint _numBlocks) external view returns (uint) {\n\n        for (uint i = _startNumber; i <= (_numBlocks + _startNumber); i++) {\n            if (blockhashMapping[i] != 0x0) {\n                return i;\n            }\n        }\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    function recreateBlockheaders(uint _blockNumber, bytes[] memory _blockheaders) public {\n\n        bytes32 currentBlockhash = blockhashMapping[_blockNumber];\n        require(currentBlockhash != 0x0, \"parentBlock is not available\");\n\n        bytes32 calculatedHash = reCalculateBlockheaders(_blockheaders, currentBlockhash);\n        require(calculatedHash != 0x0, \"invalid headers\");\n\n        \n        assert(_blockNumber > _blockheaders.length);\n        uint bnr = _blockNumber - _blockheaders.length;\n        blockhashMapping[bnr] = calculatedHash;\n        emit LogBlockhashAdded(bnr, calculatedHash);\n    }\n\n    \n    \n    \n    function saveBlockNumber(uint _blockNumber) public {\n\n        bytes32 bHash = blockhash(_blockNumber);\n\n        require(bHash != 0x0, \"block not available\");\n\n        blockhashMapping[_blockNumber] = bHash;\n        emit LogBlockhashAdded(_blockNumber, bHash);\n    }\n\n    \n    function snapshot() public {\n        \n        saveBlockNumber(block.number-1);\n    }\n\n    \n    \n    \n    function getParentAndBlockhash(bytes memory _blockheader) public pure returns (bytes32 parentHash, bytes32 bhash) {\n\n        \n        uint8 first = uint8(_blockheader[0]);\n\n        \n        \n        \n        require(first > 0xf7, \"invalid offset\");\n        uint8 offset = first - 0xf7 + 2;\n\n        \n        // solium-disable-next-line security/no-inline-assembly\n        assembly { // solhint-disable-line no-inline-assembly\n            // mstore to get the memory pointer of the blockheader to 0x20\n            mstore(0x20, _blockheader)\n\n            // we load the pointer we just stored\n            // then we add 0x20 (32 bytes) to get to the start of the blockheader\n            // then we add the offset we calculated\n            // and load it to the parentHash variable\n            parentHash :=mload(\n                add(\n                    add(\n                        mload(0x20), 0x20\n                    ), offset)\n            )\n        }\n        bhash = keccak256(_blockheader);\n    }\n\n    \n    \n    \n    \n    \n    function reCalculateBlockheaders(bytes[] memory _blockheaders, bytes32 _bHash) public pure returns (bytes32 bhash) {\n\n        bytes32 currentBlockhash = _bHash;\n        bytes32 calcParent = 0x0;\n        bytes32 calcBlockhash = 0x0;\n\n        \n        for (uint i = 0; i < _blockheaders.length; i++) {\n            (calcParent, calcBlockhash) = getParentAndBlockhash(_blockheaders[i]);\n            if (calcBlockhash != currentBlockhash) {\n                return 0x0;\n            }\n            currentBlockhash = calcParent;\n        }\n\n        return currentBlockhash;\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/consensys-Slockit_Incubed3/in3-contracts-e25c758a115aef0c0640bc446027259aa7cb1a52/contracts/NodeRegistry.sol",
        "vulnerability": "Assertion Failure",
        "check": "FP",
        "response": "Answer: Yes\nDescription: The assertion `assert(_blockNumber > _blockheaders.length);` may fail if `_blockNumber` is less than or equal to `_blockheaders.length`."
    },
    {
        "code_segment": "contract XSwap is DSAuth {\n\tusing DSMath for uint256;\n\n\tuint256 constant internal OFFSET = 10 ** 18;\n\t//Mainnet\n\t// address private chai = 0x06AF07097C9Eeb7fD685c692751D5C66dB49c215;\n\t// address private dai  = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n\n\t//Rinkeby\n\taddress private chai = 0x8a5C1BD4D75e168a4f65eB902c289400B90FD980;\n\taddress private dai  = 0xA3A59273494BB5B8F0a8FAcf21B3f666A47d6140;\n\n\tbool private actived;\n\taddress public lendFMe;\n\tbool public isOpen;\n\tmapping(address => mapping(address => uint256)) public prices; // 1 tokenA = ? tokenB\n\tmapping(address => mapping(address => uint256)) public fee;   // fee from tokenA to tokenB\n\tmapping(address => bool) public supportLending;\n\tmapping(address => uint256) public decimals;\n\n\tconstructor() public {\n\t}\n\n\tfunction active(address _lendFMe) public {\n\t\trequire(actived == false, \"already actived.\");\n\t\towner = msg.sender;\n\t\tisOpen = true;\n\t\tlendFMe = _lendFMe;\n\t\tactived = true;\n\t}\n\n\t// trade _inputAmount of _input token to get _output token\n\tfunction trade(address _input, address _output, uint256 _inputAmount) public returns (bool) {\n\t\treturn trade(_input, _output, _inputAmount, msg.sender);\n\t}\n\n\tfunction trade(address _input, address _output, uint256 _inputAmount, address _receiver) public returns (bool) {\n\t\trequire(isOpen, \"not open\");\n\t\trequire(prices[_input][_output] != 0, \"invalid token address\");\n\t\trequire(decimals[_input] != 0, \"input decimal not setteled\");\n\t\trequire(decimals[_output] != 0, \"output decimal not setteled\");\n\n\t\tNonStandardIERC20Token(_input).transferFrom(msg.sender, address(this), _inputAmount);\n\t\tif(supportLending[_input]) {\n\t\t\tif (_input == dai) {\n\t\t\t\tIChai(chai).join(address(this), _inputAmount);\n\t\t\t\tILendFMe(lendFMe).supply(chai, IERC20Token(chai).balanceOf(address(this)));\n\t\t\t}\n\t\t\telse\n\t\t\t\tILendFMe(lendFMe).supply(_input, _inputAmount);\n\t\t}\n\t\tuint256 _tokenAmount = normalizeToken(_input, _inputAmount).mul(prices[_input][_output]).div(OFFSET);\n\t\tuint256 _fee = _tokenAmount.mul(fee[_input][_output]).div(OFFSET);\n\t\tuint256 _amountToUser = _tokenAmount.sub(_fee);\n\n\t\tif(supportLending[_output]) {\n\t\t\tif (_output == dai) {\n\t\t\t\tILendFMe(lendFMe).withdraw(chai, _amountToUser); //assume chai / dai >= 1;\n\t\t\t\tIChai(chai).draw(address(this), _amountToUser);\n\t\t\t}\n\t\t\telse\n\t\t\t\tILendFMe(lendFMe).withdraw(_output, denormalizedToken(_output, _amountToUser));\n\t\t}\n\t\tNonStandardIERC20Token(_output).transfer(_receiver, denormalizedToken(_output, _amountToUser));\n\t\treturn true;\n\t}\n\n\tfunction getTokenLiquidation(address _token) public view returns (uint256) {\n\t\tuint256 balanceInDefi = ILendFMe(lendFMe).getSupplyBalance(address(this), _token);\n\t\treturn balanceInDefi.add(NonStandardIERC20Token(_token).balanceOf(address(this)));\n\t}\n\n\tfunction setLendFMe(address _lendFMe) public auth returns (bool) {\n\t\tlendFMe = _lendFMe;\n\t\treturn true;\n\t}\n\n\tfunction enableLending(address _token) public auth returns (bool) {\n\t\trequire(!supportLending[_token], \"the token is already supported lending\");\n\t\tsupportLending[_token] = true;\n\n\t\tif (_token == dai) {\n\t\t\tIERC20Token(_token).approve(chai, uint256(-1));\n\t\t\tIERC20Token(chai).approve(lendFMe, uint256(-1));\n\t\t}\n\t\telse {\n\t\t\tNonStandardIERC20Token(_token).approve(lendFMe, uint256(-1));\n\t\t}\n\n\t\tuint256 _balance = NonStandardIERC20Token(_token).balanceOf(address(this));\n\t\tif(_balance > 0) {\n\t\t\tif (_token == dai) {\n\t\t\t\tIChai(chai).join(address(this), _balance);\n\t\t\t\tILendFMe(lendFMe).supply(chai, IERC20Token(chai).balanceOf(address(this)));\n\t\t\t}\n\t\t\telse\n\t\t\t\tILendFMe(lendFMe).supply(_token, _balance);\n\t\t}\n\t\treturn true;\n\t}\n\n\tfunction disableLending(address _token) public auth returns (bool) {\n\t\trequire(supportLending[_token], \"the token doesnt support lending\");\n\t\tsupportLending[_token] = false;\n\n\t\tif (_token == dai) {\n\t\t\tILendFMe(lendFMe).withdraw(chai, uint256(-1));\n\t\t\tIChai(chai).exit(address(this), IERC20Token(chai).balanceOf(address(this)));\n\t\t}\n\t\telse\n\t\t\tILendFMe(lendFMe).withdraw(_token, uint256(-1));\n\n\t\treturn true;\n\t}\n\n\t// create new pairs\n\tfunction createPair(address _input, address _output, uint256 _priceInOut, uint256 _priceOutIn, uint256 _fee) external auth returns (bool) {\n\t\tsetPrices(_input, _output, _priceInOut, _priceOutIn);\n\t\tsetFee(_input, _output, _fee);\n\t\treturn true;\n\t}\n\n\tfunction setPrices(address _input, address _output, uint256 _priceInOut, uint256 _priceOutIn) public auth returns (bool) {\n\t\tsetPrices(_input, _output, _priceInOut);\n\t\tsetPrices(_output, _input, _priceOutIn);\n\t\treturn true;\n\t}\n\t//SWC-101-Integer Overflow and Underflow: L152\n\tfunction setPrices(address _input, address _output, uint256 _price) public auth returns (bool) {\n\t\tprices[_input][_output] = _price;\n\t\treturn true;\n\t}\n\n\tfunction setFee(address _input, address _output, uint256 _fee) public auth returns (bool) {\n\t\tfee[_input][_output] = _fee;\n\t\tfee[_output][_input] = _fee;\n\t\treturn true;\n\t}\n\n\tfunction setTokenDecimals(address _token, uint256 _decimals) public auth returns (bool){\n\t\trequire(_decimals <= 18, \"not supported decimal\");\n\t\tdecimals[_token] = _decimals;\n\t\treturn true;\n\t}\n\n\tfunction emergencyStop(bool _open) external auth returns (bool) {\n\t\tisOpen = _open;\n\t\treturn true;\n\t}\n\n\tfunction transferOut(address _token, address _receiver, uint256 _amount) external auth returns (bool) {\n\t\tif(supportLending[_token]) {\n\t\t\tif (_token == dai) {\n\t\t\t\tILendFMe(lendFMe).withdraw(chai, _amount);\n\t\t\t\tIChai(chai).draw(address(this), _amount);\n\t\t\t}\n\t\t\telse\n\t\t\t\tILendFMe(lendFMe).withdraw(_token, _amount);\n\t\t}\n\t\tuint256 _balance = NonStandardIERC20Token(_token).balanceOf(address(this));\n\t\tif(_balance >= _amount) {\n\t\t\tNonStandardIERC20Token(_token).transfer(_receiver, _amount);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tfunction transferOutALL(address _token, address _receiver) external auth returns (bool) {\n\t\tif(supportLending[_token]) {\n\t\t\tif (_token == dai) {\n\t\t\t\tILendFMe(lendFMe).withdraw(chai, uint256(-1));\n\t\t\t\tIChai(chai).exit(address(this), IERC20Token(chai).balanceOf(address(this)));\n\t\t\t}\n\t\t\telse\n\t\t\t\tILendFMe(lendFMe).withdraw(_token, uint256(-1));\n\t\t}\n\t\tuint256 _balance = NonStandardIERC20Token(_token).balanceOf(address(this));\n\t\tif(_balance > 0) {\n\t\t\tNonStandardIERC20Token(_token).transfer(_receiver, _balance);\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tfunction transferIn(address _token, uint256 _amount) external auth returns (bool) {\n\t\tNonStandardIERC20Token(_token).transferFrom(msg.sender, address(this), _amount);\n\t\tif(supportLending[_token]) {\n\t\t\tif (_token == dai) {\n\t\t\t\tIChai(chai).join(address(this), NonStandardIERC20Token(dai).balanceOf(address(this)));\n\t\t\t\tILendFMe(lendFMe).supply(chai, IERC20Token(chai).balanceOf(address(this)));\n\t\t\t}\n\t\t\telse\n\t\t\t\tILendFMe(lendFMe).supply(_token, NonStandardIERC20Token(_token).balanceOf(address(this)));\n\t\t}\n\t    return true;\n\t}\n\n\tfunction normalizeToken(address _token, uint256 _amount) internal view returns (uint256) {\n\t\tuint256 n = 18;\n\t\treturn _amount.mul((10 ** (n.sub(decimals[_token]))));\n\t}\n\n\tfunction denormalizedToken(address _token, uint256 _amount) internal view returns (uint256) {\n\t\tuint256 n = 18;\n\t\treturn _amount.div((10 ** (n.sub(decimals[_token]))));\n\t}\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/PeckShield-XSwap/xswap-326a3246b327cd2b8481fd8c22fe8d864e43b0da/contracts/XSwap.sol",
        "vulnerability": "Reentrancy",
        "check": "FP",
        "response": "Answer: No\nReason: The contract follows the check-effects-interactions pattern, calling external contracts after making state changes."
    },
    {
        "code_segment": "contract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20Upgradeable, IERC20MetadataUpgradeable {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    function __ERC20_init(string memory name_, string memory symbol_) internal initializer {\n        __Context_init_unchained();\n        __ERC20_init_unchained(name_, symbol_);\n    }\n\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal initializer {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n        unchecked {\n            _approve(sender, _msgSender(), currentAllowance - amount);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[sender] = senderBalance - amount;\n        }\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n\n        _afterTokenTransfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n     function _premint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n    uint256[45] private __gap;\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Hacken-DeHealth HLT Network/code/DeHealthToken.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: Yes\nDescription: There is a potential for integer overflow in the `_mint` and `_premint` functions when adding to `_totalSupply` and `_balances`. Using unchecked contexts in other functions can also leave room for similar vulnerabilities."
    },
    {
        "code_segment": "contract KOK_Contract is ERC20Interface, Owned {\n\tstring public constant symbol = \"KOK\";\n\tstring public constant name = \"KOK Coin\";\n\tuint8 public constant decimals = 18;\n\tuint256 public constant totalSupply = 5000000000000000000000000000;\n\n\tbool public stopped;\n\n\tmapping (address => int8) public blackList;\n\n\tmapping (address => uint256) public balances;\n\tmapping (address => mapping (address => uint256)) public allowed;\n\n\n    event Blacklisted(address indexed target);\n    event DeleteFromBlacklist(address indexed target);\n    event RejectedPaymentToBlacklistedAddr(address indexed from, address indexed to, uint256 value);\n    event RejectedPaymentFromBlacklistedAddr(address indexed from, address indexed to, uint256 value);\n\n\n\tmodifier notStopped {\n        require(!stopped);\n        _;\n    }\n\n// constructor\n// SWC-118-Incorrect Constructor Name: L63\n\tfunction KOKContract() public {\n\t\tbalances[msg.sender] = totalSupply;\n\t}\n\t\n// function made for airdrop\n\tfunction airdrop(address[] _to, uint256[] _value) onlyOwner notStopped public {\n\t    for(uint256 i = 0; i < _to.length; i++){\n\t        if(balances[_to[i]] > 0){\n\t            continue;\n\t        }\n\t        transfer(_to[i], _value[i]);\n\t    }\n\t}\n\n// blacklist management\n    function blacklisting(address _addr) onlyOwner public {\n        blackList[_addr] = 1;\n        emit Blacklisted(_addr);\n    }\n    function deleteFromBlacklist(address _addr) onlyOwner public {\n        blackList[_addr] = -1;\n        emit DeleteFromBlacklist(_addr);\n    }\n\n// stop the contract\n// SWC-100-Function Default Visibility: L88\n\tfunction stop() onlyOwner {\n        stopped = true;\n    }\n// SWC-100-Function Default Visibility: L92\n    function start() onlyOwner {\n        stopped = false;\n    }\n\t\n// ERC20 functions\n\tfunction balanceOf(address _owner) public constant returns (uint256 balance){\n\t\treturn balances[_owner];\n\t}\n\tfunction transfer(address _to, uint256 _value) notStopped public returns (bool success){\n\t\trequire(balances[msg.sender] >= _value);\n\n\t\tif(blackList[msg.sender] > 0){\n\t\t\temit RejectedPaymentFromBlacklistedAddr(msg.sender, _to, _value);\n\t\t\treturn false;\n\t\t}\n\t\tif(blackList[_to] > 0){\n\t\t\temit RejectedPaymentToBlacklistedAddr(msg.sender, _to, _value);\n\t\t\treturn false;\n\t\t}\n\n\t\tbalances[msg.sender] -= _value;\n\t\tbalances[_to] += _value;\n\t\temit Transfer(msg.sender, _to, _value);\n\t\treturn true;\n\t}\n\tfunction transferFrom(address _from, address _to, uint256 _value) notStopped public returns (bool success){\n\t\trequire(balances[_from] >= _value\n\t\t\t&& allowed[_from][msg.sender] >= _value);\n\n\t\tif(blackList[_from] > 0){\n\t\t\temit RejectedPaymentFromBlacklistedAddr(_from, _to, _value);\n\t\t\treturn false;\n\t\t}\n\t\tif(blackList[_to] > 0){\n\t\t\temit RejectedPaymentToBlacklistedAddr(_from, _to, _value);\n\t\t\treturn false;\n\t\t}\n\n\t\tbalances[_from] -= _value;\n\t\tallowed[_from][msg.sender] -= _value;\n\t\tbalances[_to] += _value;\n\t\temit Transfer(_from, _to, _value);\n\t\treturn true;\n\t}\n\tfunction approve(address _spender, uint256 _value) notStopped public returns (bool success){\n\t\tallowed[msg.sender][_spender] = _value;\n\t\temit Approval(msg.sender, _spender, _value);\n\t\treturn true;\n\t}\n\tfunction allowance(address _owner, address _spender) public constant returns (uint256 remaining){\n\t\treturn allowed[_owner][_spender];\n\t}\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Iosiro-KOK Token Smart Contract Audit/ERC-20-55a501fde12e782b99fe9d5756388c0de82f45ba/contract.sol",
        "vulnerability": "Assertion Failure",
        "check": "FP",
        "response": "Answer: No\nReason: The code does not contain any assertions, hence there is no potential for an \"Assertion Failure\" vulnerability."
    },
    {
        "code_segment": "contract Citrus is TimeLock {\n\n    constructor() {\n        symbol = \"CTS\";\n        name = \"Citrus\";\n        decimals = 18;                                    \n        totalSupply = 383000000 * 10**18;           \n       \n        owner = msg.sender;\n        balances[owner] = totalSupply;\n    }\n    \n    function mint(address to, uint amount) external {\n        require(msg.sender == owner, 'only admin');\n        _mint(to, amount);\n    }\n\n    function burn(address from, uint amount) external {\n        require(msg.sender == owner, 'only admin');\n        _burn(from, amount);\n    }\n   \n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/QuillAudits-Citrus Smart Contract/CitrusTechContract-e50a2a983928c10b76e6bc374ae6267f51af99b6/CitrusToken.sol",
        "vulnerability": "Block Dependency",
        "check": "FP",
        "response": "Answer: No\nReason: The provided contract code does not rely on block-specific variables such as block.timestamp or block.number, which are typically associated with \"Block Dependency\" vulnerabilities."
    },
    {
        "code_segment": "contract Citrus is TimeLock {\n\n    constructor() {\n        symbol = \"CTS\";\n        name = \"Citrus\";\n        decimals = 18;                                    \n        totalSupply = 383000000 * 10**18;           \n       \n        owner = msg.sender;\n        balances[owner] = totalSupply;\n    }\n    \n    function mint(address to, uint amount) external {\n        require(msg.sender == owner, 'only admin');\n        _mint(to, amount);\n    }\n\n    function burn(address from, uint amount) external {\n        require(msg.sender == owner, 'only admin');\n        _burn(from, amount);\n    }\n   \n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/QuillAudits-Citrus Smart Contract/CitrusTechContract-e50a2a983928c10b76e6bc374ae6267f51af99b6/CitrusToken.sol",
        "vulnerability": "Block Dependency",
        "check": "FP",
        "response": "Answer: No\nReason: The code does not rely on block properties such as block number or timestamp to determine logic flow or make critical decisions, mitigating the risk of block dependency."
    },
    {
        "code_segment": "contract Citrus is TimeLock {\n\n    constructor() {\n        symbol = \"CTS\";\n        name = \"Citrus\";\n        decimals = 18;                                    \n        totalSupply = 383000000 * 10**18;           \n       \n        owner = msg.sender;\n        balances[owner] = totalSupply;\n    }\n    \n    function mint(address to, uint amount) external {\n        require(msg.sender == owner, 'only admin');\n        _mint(to, amount);\n    }\n\n    function burn(address from, uint amount) external {\n        require(msg.sender == owner, 'only admin');\n        _burn(from, amount);\n    }\n   \n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/QuillAudits-Citrus Smart Contract/CitrusTechContract-e50a2a983928c10b76e6bc374ae6267f51af99b6/CitrusToken.sol",
        "vulnerability": "Block Dependency",
        "check": "FP",
        "response": "Answer: No\nReason: The code does not use block.timestamp or block.number, which are typical indicators of block dependency issues."
    },
    {
        "code_segment": "contract BMath is BBronze, BConst, BNum {\n    /**********************************************************************************************\n    // calcSpotPrice                                                                             //\n    // sP = spotPrice                                                                            //\n    // bI = tokenBalanceIn                ( bI / wI )         1                                  //\n    // bO = tokenBalanceOut         sP =  -----------  *  ----------                             //\n    // wI = tokenWeightIn                 ( bO / wO )     ( 1 - sF )                             //\n    // wO = tokenWeightOut                                                                       //\n    // sF = swapFee                                                                              //\n    **********************************************************************************************/\n    function calcSpotPrice(\n        uint tokenBalanceIn,\n        uint tokenWeightIn,\n        uint tokenBalanceOut,\n        uint tokenWeightOut,\n        uint swapFee\n    )\n        public pure\n        returns (uint spotPrice)\n    {\n        uint numer = bdiv(tokenBalanceIn, tokenWeightIn);\n        uint denom = bdiv(tokenBalanceOut, tokenWeightOut);\n        uint ratio = bdiv(numer, denom);\n        uint scale = bdiv(BONE, bsub(BONE, swapFee));\n        return  (spotPrice = bmul(ratio, scale));\n    }\n\n    /**********************************************************************************************\n    // calcOutGivenIn                                                                            //\n    // aO = tokenAmountOut                                                                       //\n    // bO = tokenBalanceOut                                                                      //\n    // bI = tokenBalanceIn              /      /            bI             \\    (wI / wO) \\      //\n    // aI = tokenAmountIn    aO = bO * |  1 - | --------------------------  | ^            |     //\n    // wI = tokenWeightIn               \\      \\ ( bI + ( aI * ( 1 - sF )) /              /      //\n    // wO = tokenWeightOut                                                                       //\n    // sF = swapFee                                                                              //\n    **********************************************************************************************/\n    function calcOutGivenIn(\n        uint tokenBalanceIn,\n        uint tokenWeightIn,\n        uint tokenBalanceOut,\n        uint tokenWeightOut,\n        uint tokenAmountIn,\n        uint swapFee\n    )\n        public pure\n        returns (uint tokenAmountOut)\n    {\n        uint weightRatio = bdiv(tokenWeightIn, tokenWeightOut);\n        uint adjustedIn = bsub(BONE, swapFee);\n        adjustedIn = bmul(tokenAmountIn, adjustedIn);\n        uint y = bdiv(tokenBalanceIn, badd(tokenBalanceIn, adjustedIn));\n        uint foo = bpow(y, weightRatio);\n        uint bar = bsub(BONE, foo);\n        tokenAmountOut = bmul(tokenBalanceOut, bar);\n        return tokenAmountOut;\n    }\n\n    /**********************************************************************************************\n    // calcInGivenOut                                                                            //\n    // aI = tokenAmountIn                                                                        //\n    // bO = tokenBalanceOut               /  /     bO      \\    (wO / wI)      \\                 //\n    // bI = tokenBalanceIn          bI * |  | ------------  | ^            - 1  |                //\n    // aO = tokenAmountOut    aI =        \\  \\ ( bO - aO ) /                   /                 //\n    // wI = tokenWeightIn           --------------------------------------------                 //\n    // wO = tokenWeightOut                          ( 1 - sF )                                   //\n    // sF = swapFee                                                                              //\n    **********************************************************************************************/\n    function calcInGivenOut(\n        uint tokenBalanceIn,\n        uint tokenWeightIn,\n        uint tokenBalanceOut,\n        uint tokenWeightOut,\n        uint tokenAmountOut,\n        uint swapFee\n    )\n        public pure\n        returns (uint tokenAmountIn)\n    {\n        uint weightRatio = bdiv(tokenWeightOut, tokenWeightIn);\n        uint diff = bsub(tokenBalanceOut, tokenAmountOut);\n        uint y = bdiv(tokenBalanceOut, diff);\n        uint foo = bpow(y, weightRatio);\n        foo = bsub(foo, BONE);\n        tokenAmountIn = bsub(BONE, swapFee);\n        tokenAmountIn = bdiv(bmul(tokenBalanceIn, foo), tokenAmountIn);\n        return tokenAmountIn;\n    }\n\n    /**********************************************************************************************\n    // calcPoolOutGivenSingleIn                                                                  //\n    // pAo = poolAmountOut         /                                              \\              //\n    // tAi = tokenAmountIn        \n    // wI = tokenWeightIn        //| tAi *| 1 - || 1 - --  | * sF || + tBi \\    --  \\            //\n    // tW = totalWeight     pAo=||  \\      \\     \\\\    tW /      //         | ^ tW   | * pS - pS //\n    // tBi = tokenBalanceIn      \\\\  ------------------------------------- /        /            //\n    // pS = poolSupply            \\\\                    tBi               /        /             //\n    // sF = swapFee                \\                                              /              //\n    **********************************************************************************************/\n    function calcPoolOutGivenSingleIn(\n        uint tokenBalanceIn,\n        uint tokenWeightIn,\n        uint poolSupply,\n        uint totalWeight,\n        uint tokenAmountIn,\n        uint swapFee\n    )\n        public pure\n        returns (uint poolAmountOut)\n    {\n        // Charge the trading fee for the proportion of tokenAi\n        \n        // That proportion is (1- weightTokenIn)\n        // tokenAiAfterFee = tAi * (1 - (1-weightTi) * poolFee);\n        uint normalizedWeight = bdiv(tokenWeightIn, totalWeight);\n        uint zaz = bmul(bsub(BONE, normalizedWeight), swapFee); \n        uint tokenAmountInAfterFee = bmul(tokenAmountIn, bsub(BONE, zaz));\n\n        uint newTokenBalanceIn = badd(tokenBalanceIn, tokenAmountInAfterFee);\n        uint tokenInRatio = bdiv(newTokenBalanceIn, tokenBalanceIn);\n\n        // uint newPoolSupply = (ratioTi ^ weightTi) * poolSupply;\n        uint poolRatio = bpow(tokenInRatio, normalizedWeight);\n        // SWC-101-Integer Overflow and Underflow: L143\n        uint newPoolSupply = bmul(poolRatio, poolSupply);\n        poolAmountOut = bsub(newPoolSupply, poolSupply);\n        return poolAmountOut;\n    }\n\n    /**********************************************************************************************\n    // calcSingleInGivenPoolOut                                                                  //\n    // tAi = tokenAmountIn              //(pS + pAo)\\     /    1    \\\\                           //\n    // pS = poolSupply                 || ---------  | ^ | --------- || * bI - bI                //\n    // pAo = poolAmountOut              \\\\    pS    /     \\(wI / tW)//                           //\n    // bI = balanceIn          tAi =  --------------------------------------------               //\n    // wI = weightIn                              /      wI  \\                                   //\n    // tW = totalWeight                          |  1 - ----  |  * sF                            //\n    // sF = swapFee                               \\      tW  /                                   //\n    **********************************************************************************************/\n    function calcSingleInGivenPoolOut(\n        uint tokenBalanceIn,\n        uint tokenWeightIn,\n        uint poolSupply,\n        uint totalWeight,\n        uint poolAmountOut,\n        uint swapFee\n    )\n        public pure\n        returns (uint tokenAmountIn)\n    {\n        uint normalizedWeight = bdiv(tokenWeightIn, totalWeight);\n        uint newPoolSupply = badd(poolSupply, poolAmountOut);\n        uint poolRatio = bdiv(newPoolSupply, poolSupply);\n      \n        //uint newBalTi = poolRatio^(1/weightTi) * balTi;\n        uint boo = bdiv(BONE, normalizedWeight); \n        uint tokenInRatio = bpow(poolRatio, boo);\n        uint newTokenBalanceIn = bmul(tokenInRatio, tokenBalanceIn);\n        uint tokenAmountInAfterFee = bsub(newTokenBalanceIn, tokenBalanceIn);\n        // Do reverse order of fees charged in joinswap_ExternAmountIn, this way \n        //     ``` pAo == joinswap_ExternAmountIn(Ti, joinswap_PoolAmountOut(pAo, Ti)) ```\n        //uint tAi = tAiAfterFee / (1 - (1-weightTi) * swapFee) ;\n        uint zar = bmul(bsub(BONE, normalizedWeight), swapFee);\n        tokenAmountIn = bdiv(tokenAmountInAfterFee, bsub(BONE, zar));\n        return tokenAmountIn;\n    }\n\n    /**********************************************************************************************\n    // calcSingleOutGivenPoolIn                                                                  //\n    // tAo = tokenAmountOut            /      /                                             \\\\   //\n    // bO = tokenBalanceOut           /      // pS - (pAi * (1 - eF)) \\     /    1    \\      \\\\  //\n    // pAi = poolAmountIn            | bO - || ----------------------- | ^ | --------- | * b0 || //\n    // ps = poolSupply                \\      \\\\          pS           /     \\(wO / tW)/      //  //\n    // wI = tokenWeightIn      tAo =   \\      \\                                             //   //\n    // tW = totalWeight                    /     /      wO \\       \\                             //\n    // sF = swapFee                    *  | 1 - |  1 - ---- | * sF  |                            //\n    // eF = exitFee                        \\     \\      tW /       /                             //\n    **********************************************************************************************/\n    function calcSingleOutGivenPoolIn(\n        uint tokenBalanceOut,\n        uint tokenWeightOut,\n        uint poolSupply,\n        uint totalWeight,\n        uint poolAmountIn,\n        uint swapFee\n    )\n        public pure\n        returns (uint tokenAmountOut)\n    {\n        uint normalizedWeight = bdiv(tokenWeightOut, totalWeight);\n        // charge exit fee on the pool token side\n        // pAiAfterExitFee = pAi*(1-exitFee)\n        uint poolAmountInAfterExitFee = bmul(poolAmountIn, bsub(BONE, EXIT_FEE));\n        uint newPoolSupply = bsub(poolSupply, poolAmountInAfterExitFee);\n        uint poolRatio = bdiv(newPoolSupply, poolSupply);\n     \n        // newBalTo = poolRatio^(1/weightTo) * balTo;\n        uint tokenOutRatio = bpow(poolRatio, bdiv(BONE, normalizedWeight));\n        uint newTokenBalanceOut = bmul(tokenOutRatio, tokenBalanceOut);\n\n        uint tokenAmountOutBeforeSwapFee = bsub(tokenBalanceOut, newTokenBalanceOut);\n\n        // charge swap fee on the output token side \n        //uint tAo = tAoBeforeSwapFee * (1 - (1-weightTo) * swapFee)\n        uint zaz = bmul(bsub(BONE, normalizedWeight), swapFee); \n        tokenAmountOut = bmul(tokenAmountOutBeforeSwapFee, bsub(BONE, zaz));\n        return tokenAmountOut;\n    }\n\n    /**********************************************************************************************\n    // calcPoolInGivenSingleOut                                                                  //\n    // pAi = poolAmountIn               // /               tAo             \\\\     / wO \\     \\   //\n    // bO = tokenBalanceOut            // | bO - -------------------------- |\\   | ---- |     \\  //\n    // tAo = tokenAmountOut      pS - ||   \\     1 - ((1 - (tO / tW)) * sF)/  | ^ \\ tW /  * pS | //\n    // ps = poolSupply                 \\\\ -----------------------------------/                /  //\n    // wO = tokenWeightOut  pAi =       \\\\               bO                 /                /   //\n    // tW = totalWeight           -------------------------------------------------------------  //\n    // sF = swapFee                                        ( 1 - eF )                            //\n    // eF = exitFee                                                                              //\n    **********************************************************************************************/\n    function calcPoolInGivenSingleOut(\n        uint tokenBalanceOut,\n        uint tokenWeightOut,\n        uint poolSupply,\n        uint totalWeight,\n        uint tokenAmountOut,\n        uint swapFee\n    )\n        public pure\n        returns (uint poolAmountIn)\n    {\n\n        // charge swap fee on the output token side \n        uint normalizedWeight = bdiv(tokenWeightOut, totalWeight);\n        //uint tAoBeforeSwapFee = tAo / (1 - (1-weightTo) * swapFee) ;\n        uint zoo = bsub(BONE, normalizedWeight);\n        uint zar = bmul(zoo, swapFee); \n        uint tokenAmountOutBeforeSwapFee = bdiv(tokenAmountOut, bsub(BONE, zar));\n\n        uint newTokenBalanceOut = bsub(tokenBalanceOut, tokenAmountOutBeforeSwapFee);\n        uint tokenOutRatio = bdiv(newTokenBalanceOut, tokenBalanceOut);\n\n        //uint newPoolSupply = (ratioTo ^ weightTo) * poolSupply;\n        uint poolRatio = bpow(tokenOutRatio, normalizedWeight);\n        uint newPoolSupply = bmul(poolRatio, poolSupply);\n        uint poolAmountInAfterExitFee = bsub(poolSupply, newPoolSupply);\n\n        // charge exit fee on the pool token side\n        // pAi = pAiAfterExitFee/(1-exitFee)\n        poolAmountIn = bdiv(poolAmountInAfterExitFee, bsub(BONE, EXIT_FEE));\n        return poolAmountIn;\n    }\n\n\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-BalancerCore/balancer-core-942a51e202cc5bf9158bad77162bc72aa0a8afaf/contracts/BPool.sol",
        "vulnerability": "Integer Overflow",
        "check": "TP",
        "response": "Answer: No\nReason: Comprehensive usage of safe mathematics functions (badd, bsub, bmul, bdiv) prevents integer overflows."
    },
    {
        "code_segment": "contract BMath is BBronze, BConst, BNum {\n    /**********************************************************************************************\n    // calcSpotPrice                                                                             //\n    // sP = spotPrice                                                                            //\n    // bI = tokenBalanceIn                ( bI / wI )         1                                  //\n    // bO = tokenBalanceOut         sP =  -----------  *  ----------                             //\n    // wI = tokenWeightIn                 ( bO / wO )     ( 1 - sF )                             //\n    // wO = tokenWeightOut                                                                       //\n    // sF = swapFee                                                                              //\n    **********************************************************************************************/\n    function calcSpotPrice(\n        uint tokenBalanceIn,\n        uint tokenWeightIn,\n        uint tokenBalanceOut,\n        uint tokenWeightOut,\n        uint swapFee\n    )\n        public pure\n        returns (uint spotPrice)\n    {\n        uint numer = bdiv(tokenBalanceIn, tokenWeightIn);\n        uint denom = bdiv(tokenBalanceOut, tokenWeightOut);\n        uint ratio = bdiv(numer, denom);\n        uint scale = bdiv(BONE, bsub(BONE, swapFee));\n        return  (spotPrice = bmul(ratio, scale));\n    }\n\n    /**********************************************************************************************\n    // calcOutGivenIn                                                                            //\n    // aO = tokenAmountOut                                                                       //\n    // bO = tokenBalanceOut                                                                      //\n    // bI = tokenBalanceIn              /      /            bI             \\    (wI / wO) \\      //\n    // aI = tokenAmountIn    aO = bO * |  1 - | --------------------------  | ^            |     //\n    // wI = tokenWeightIn               \\      \\ ( bI + ( aI * ( 1 - sF )) /              /      //\n    // wO = tokenWeightOut                                                                       //\n    // sF = swapFee                                                                              //\n    **********************************************************************************************/\n    function calcOutGivenIn(\n        uint tokenBalanceIn,\n        uint tokenWeightIn,\n        uint tokenBalanceOut,\n        uint tokenWeightOut,\n        uint tokenAmountIn,\n        uint swapFee\n    )\n        public pure\n        returns (uint tokenAmountOut)\n    {\n        uint weightRatio = bdiv(tokenWeightIn, tokenWeightOut);\n        uint adjustedIn = bsub(BONE, swapFee);\n        adjustedIn = bmul(tokenAmountIn, adjustedIn);\n        uint y = bdiv(tokenBalanceIn, badd(tokenBalanceIn, adjustedIn));\n        uint foo = bpow(y, weightRatio);\n        uint bar = bsub(BONE, foo);\n        tokenAmountOut = bmul(tokenBalanceOut, bar);\n        return tokenAmountOut;\n    }\n\n    /**********************************************************************************************\n    // calcInGivenOut                                                                            //\n    // aI = tokenAmountIn                                                                        //\n    // bO = tokenBalanceOut               /  /     bO      \\    (wO / wI)      \\                 //\n    // bI = tokenBalanceIn          bI * |  | ------------  | ^            - 1  |                //\n    // aO = tokenAmountOut    aI =        \\  \\ ( bO - aO ) /                   /                 //\n    // wI = tokenWeightIn           --------------------------------------------                 //\n    // wO = tokenWeightOut                          ( 1 - sF )                                   //\n    // sF = swapFee                                                                              //\n    **********************************************************************************************/\n    function calcInGivenOut(\n        uint tokenBalanceIn,\n        uint tokenWeightIn,\n        uint tokenBalanceOut,\n        uint tokenWeightOut,\n        uint tokenAmountOut,\n        uint swapFee\n    )\n        public pure\n        returns (uint tokenAmountIn)\n    {\n        uint weightRatio = bdiv(tokenWeightOut, tokenWeightIn);\n        uint diff = bsub(tokenBalanceOut, tokenAmountOut);\n        uint y = bdiv(tokenBalanceOut, diff);\n        uint foo = bpow(y, weightRatio);\n        foo = bsub(foo, BONE);\n        tokenAmountIn = bsub(BONE, swapFee);\n        tokenAmountIn = bdiv(bmul(tokenBalanceIn, foo), tokenAmountIn);\n        return tokenAmountIn;\n    }\n\n    /**********************************************************************************************\n    // calcPoolOutGivenSingleIn                                                                  //\n    // pAo = poolAmountOut         /                                              \\              //\n    // tAi = tokenAmountIn        \n    // wI = tokenWeightIn        //| tAi *| 1 - || 1 - --  | * sF || + tBi \\    --  \\            //\n    // tW = totalWeight     pAo=||  \\      \\     \\\\    tW /      //         | ^ tW   | * pS - pS //\n    // tBi = tokenBalanceIn      \\\\  ------------------------------------- /        /            //\n    // pS = poolSupply            \\\\                    tBi               /        /             //\n    // sF = swapFee                \\                                              /              //\n    **********************************************************************************************/\n    function calcPoolOutGivenSingleIn(\n        uint tokenBalanceIn,\n        uint tokenWeightIn,\n        uint poolSupply,\n        uint totalWeight,\n        uint tokenAmountIn,\n        uint swapFee\n    )\n        public pure\n        returns (uint poolAmountOut)\n    {\n        // Charge the trading fee for the proportion of tokenAi\n        \n        // That proportion is (1- weightTokenIn)\n        // tokenAiAfterFee = tAi * (1 - (1-weightTi) * poolFee);\n        uint normalizedWeight = bdiv(tokenWeightIn, totalWeight);\n        uint zaz = bmul(bsub(BONE, normalizedWeight), swapFee); \n        uint tokenAmountInAfterFee = bmul(tokenAmountIn, bsub(BONE, zaz));\n\n        uint newTokenBalanceIn = badd(tokenBalanceIn, tokenAmountInAfterFee);\n        uint tokenInRatio = bdiv(newTokenBalanceIn, tokenBalanceIn);\n\n        // uint newPoolSupply = (ratioTi ^ weightTi) * poolSupply;\n        uint poolRatio = bpow(tokenInRatio, normalizedWeight);\n        // SWC-101-Integer Overflow and Underflow: L143\n        uint newPoolSupply = bmul(poolRatio, poolSupply);\n        poolAmountOut = bsub(newPoolSupply, poolSupply);\n        return poolAmountOut;\n    }\n\n    /**********************************************************************************************\n    // calcSingleInGivenPoolOut                                                                  //\n    // tAi = tokenAmountIn              //(pS + pAo)\\     /    1    \\\\                           //\n    // pS = poolSupply                 || ---------  | ^ | --------- || * bI - bI                //\n    // pAo = poolAmountOut              \\\\    pS    /     \\(wI / tW)//                           //\n    // bI = balanceIn          tAi =  --------------------------------------------               //\n    // wI = weightIn                              /      wI  \\                                   //\n    // tW = totalWeight                          |  1 - ----  |  * sF                            //\n    // sF = swapFee                               \\      tW  /                                   //\n    **********************************************************************************************/\n    function calcSingleInGivenPoolOut(\n        uint tokenBalanceIn,\n        uint tokenWeightIn,\n        uint poolSupply,\n        uint totalWeight,\n        uint poolAmountOut,\n        uint swapFee\n    )\n        public pure\n        returns (uint tokenAmountIn)\n    {\n        uint normalizedWeight = bdiv(tokenWeightIn, totalWeight);\n        uint newPoolSupply = badd(poolSupply, poolAmountOut);\n        uint poolRatio = bdiv(newPoolSupply, poolSupply);\n      \n        //uint newBalTi = poolRatio^(1/weightTi) * balTi;\n        uint boo = bdiv(BONE, normalizedWeight); \n        uint tokenInRatio = bpow(poolRatio, boo);\n        uint newTokenBalanceIn = bmul(tokenInRatio, tokenBalanceIn);\n        uint tokenAmountInAfterFee = bsub(newTokenBalanceIn, tokenBalanceIn);\n        // Do reverse order of fees charged in joinswap_ExternAmountIn, this way \n        //     ``` pAo == joinswap_ExternAmountIn(Ti, joinswap_PoolAmountOut(pAo, Ti)) ```\n        //uint tAi = tAiAfterFee / (1 - (1-weightTi) * swapFee) ;\n        uint zar = bmul(bsub(BONE, normalizedWeight), swapFee);\n        tokenAmountIn = bdiv(tokenAmountInAfterFee, bsub(BONE, zar));\n        return tokenAmountIn;\n    }\n\n    /**********************************************************************************************\n    // calcSingleOutGivenPoolIn                                                                  //\n    // tAo = tokenAmountOut            /      /                                             \\\\   //\n    // bO = tokenBalanceOut           /      // pS - (pAi * (1 - eF)) \\     /    1    \\      \\\\  //\n    // pAi = poolAmountIn            | bO - || ----------------------- | ^ | --------- | * b0 || //\n    // ps = poolSupply                \\      \\\\          pS           /     \\(wO / tW)/      //  //\n    // wI = tokenWeightIn      tAo =   \\      \\                                             //   //\n    // tW = totalWeight                    /     /      wO \\       \\                             //\n    // sF = swapFee                    *  | 1 - |  1 - ---- | * sF  |                            //\n    // eF = exitFee                        \\     \\      tW /       /                             //\n    **********************************************************************************************/\n    function calcSingleOutGivenPoolIn(\n        uint tokenBalanceOut,\n        uint tokenWeightOut,\n        uint poolSupply,\n        uint totalWeight,\n        uint poolAmountIn,\n        uint swapFee\n    )\n        public pure\n        returns (uint tokenAmountOut)\n    {\n        uint normalizedWeight = bdiv(tokenWeightOut, totalWeight);\n        // charge exit fee on the pool token side\n        // pAiAfterExitFee = pAi*(1-exitFee)\n        uint poolAmountInAfterExitFee = bmul(poolAmountIn, bsub(BONE, EXIT_FEE));\n        uint newPoolSupply = bsub(poolSupply, poolAmountInAfterExitFee);\n        uint poolRatio = bdiv(newPoolSupply, poolSupply);\n     \n        // newBalTo = poolRatio^(1/weightTo) * balTo;\n        uint tokenOutRatio = bpow(poolRatio, bdiv(BONE, normalizedWeight));\n        uint newTokenBalanceOut = bmul(tokenOutRatio, tokenBalanceOut);\n\n        uint tokenAmountOutBeforeSwapFee = bsub(tokenBalanceOut, newTokenBalanceOut);\n\n        // charge swap fee on the output token side \n        //uint tAo = tAoBeforeSwapFee * (1 - (1-weightTo) * swapFee)\n        uint zaz = bmul(bsub(BONE, normalizedWeight), swapFee); \n        tokenAmountOut = bmul(tokenAmountOutBeforeSwapFee, bsub(BONE, zaz));\n        return tokenAmountOut;\n    }\n\n    /**********************************************************************************************\n    // calcPoolInGivenSingleOut                                                                  //\n    // pAi = poolAmountIn               // /               tAo             \\\\     / wO \\     \\   //\n    // bO = tokenBalanceOut            // | bO - -------------------------- |\\   | ---- |     \\  //\n    // tAo = tokenAmountOut      pS - ||   \\     1 - ((1 - (tO / tW)) * sF)/  | ^ \\ tW /  * pS | //\n    // ps = poolSupply                 \\\\ -----------------------------------/                /  //\n    // wO = tokenWeightOut  pAi =       \\\\               bO                 /                /   //\n    // tW = totalWeight           -------------------------------------------------------------  //\n    // sF = swapFee                                        ( 1 - eF )                            //\n    // eF = exitFee                                                                              //\n    **********************************************************************************************/\n    function calcPoolInGivenSingleOut(\n        uint tokenBalanceOut,\n        uint tokenWeightOut,\n        uint poolSupply,\n        uint totalWeight,\n        uint tokenAmountOut,\n        uint swapFee\n    )\n        public pure\n        returns (uint poolAmountIn)\n    {\n\n        // charge swap fee on the output token side \n        uint normalizedWeight = bdiv(tokenWeightOut, totalWeight);\n        //uint tAoBeforeSwapFee = tAo / (1 - (1-weightTo) * swapFee) ;\n        uint zoo = bsub(BONE, normalizedWeight);\n        uint zar = bmul(zoo, swapFee); \n        uint tokenAmountOutBeforeSwapFee = bdiv(tokenAmountOut, bsub(BONE, zar));\n\n        uint newTokenBalanceOut = bsub(tokenBalanceOut, tokenAmountOutBeforeSwapFee);\n        uint tokenOutRatio = bdiv(newTokenBalanceOut, tokenBalanceOut);\n\n        //uint newPoolSupply = (ratioTo ^ weightTo) * poolSupply;\n        uint poolRatio = bpow(tokenOutRatio, normalizedWeight);\n        uint newPoolSupply = bmul(poolRatio, poolSupply);\n        uint poolAmountInAfterExitFee = bsub(poolSupply, newPoolSupply);\n\n        // charge exit fee on the pool token side\n        // pAi = pAiAfterExitFee/(1-exitFee)\n        poolAmountIn = bdiv(poolAmountInAfterExitFee, bsub(BONE, EXIT_FEE));\n        return poolAmountIn;\n    }\n\n\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-BalancerCore/balancer-core-942a51e202cc5bf9158bad77162bc72aa0a8afaf/contracts/BMath.sol",
        "vulnerability": "Integer Overflow",
        "check": "TP",
        "response": "Answer: Yes\nDescription: Potential integer overflow in function calcPoolOutGivenSingleIn due to lack of safe math operations."
    },
    {
        "code_segment": "contract FinToken is StandardToken {\n\taddress public owner;\n\t\n\tstring public constant name = \"FIN Token\"; \n\tstring public constant symbol = \"FIN\";\n\tuint8 public constant decimals = 18;\n\n// SWC-101-Integer Overflow and Underflow: L225\n\tuint256 public constant INITIAL_SUPPLY = 2623304 * (10 ** uint256(decimals));\n\t\n\tmapping (address => bool) internal verificatorAddresses;\n\tmapping (address => bool) internal verifiedAddresses;\n\t\n\tevent AddVerificator(address indexed verificator);\n\tevent RemoveVerificator(address indexed verificator);\n\t\n\tevent AddVerified(address indexed verificatorAddress, address indexed verified);\n\tevent RemoveVerified(address indexed verificatorAddress, address indexed verified);\n\t\n\tevent Mint(address indexed to, uint256 amount);\n\t\n\tmodifier onlyOwner() {\n\t\trequire(msg.sender == owner);\n\t\t_;\n\t}\n\t\n\tmodifier onlyVerificator() {\n\t\trequire(isVerificator(msg.sender));\n\t\t_;\n\t}\n\t\n\tmodifier onlyVerified(address _from, address _to) {\n\t\trequire(isVerified(_from));\n\t\trequire(isVerified(_to));\n\t\t_;\n\t}\n\n\tfunction FinToken() public {\n\t\towner = msg.sender;\n\t\ttotalSupply_ = INITIAL_SUPPLY;\n\t\tbalances[msg.sender] = INITIAL_SUPPLY;\n\t\temit Transfer(0x0, msg.sender, INITIAL_SUPPLY);\n\t}\n\t\n\tfunction addVerificatorAddress(address addr) public onlyOwner {\n\t\tverificatorAddresses[addr] = true;\n\t\temit AddVerificator(addr);\n\t}\n\t\n\tfunction removeVerificatorAddress(address addr) public onlyOwner {\n\t\tdelete verificatorAddresses[addr];\n\t\temit RemoveVerificator(addr);\n\t}\n\t\n\tfunction isVerificator(address addr) public constant returns (bool) {\n\t\treturn verificatorAddresses[addr];\n\t}\n\t\t\n\tfunction addVerifiedAddress(address addr) public onlyVerificator {\n\t\tverifiedAddresses[addr] = true;\n\t\temit AddVerified(msg.sender, addr);\n\t}\n\t\n\tfunction removeVerifiedAddress(address addr) public onlyVerificator {\n\t\tdelete verifiedAddresses[addr];\n\t\temit RemoveVerified(msg.sender, addr);\n\t}\n\t\n\tfunction isVerified(address addr) public constant returns (bool) {\n\t\treturn verifiedAddresses[addr];\n\t}\n\t\n\tfunction transfer(address _to, uint256 _value) public onlyVerified(msg.sender, _to) returns (bool) {\n\t\tsuper.transfer(_to, _value);\n\t}\n\t\n\tfunction transferFrom(address _from, address _to, uint256 _value) public onlyVerified(_from, _to) returns (bool) {\n\t    super.transferFrom(_from, _to, _value);\n\t}\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Chainsulting-FIN/FinToken/FinToken.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No\nReason: The multiplication done to compute INITIAL_SUPPLY uses constant values that are known at compile time, ensuring that the result fits within the uint256 limit, thus preventing integer overflow."
    },
    {
        "code_segment": "contract FinToken is StandardToken {\n\taddress public owner;\n\t\n\tstring public constant name = \"FIN Token\"; \n\tstring public constant symbol = \"FIN\";\n\tuint8 public constant decimals = 18;\n\n// SWC-101-Integer Overflow and Underflow: L225\n\tuint256 public constant INITIAL_SUPPLY = 2623304 * (10 ** uint256(decimals));\n\t\n\tmapping (address => bool) internal verificatorAddresses;\n\tmapping (address => bool) internal verifiedAddresses;\n\t\n\tevent AddVerificator(address indexed verificator);\n\tevent RemoveVerificator(address indexed verificator);\n\t\n\tevent AddVerified(address indexed verificatorAddress, address indexed verified);\n\tevent RemoveVerified(address indexed verificatorAddress, address indexed verified);\n\t\n\tevent Mint(address indexed to, uint256 amount);\n\t\n\tmodifier onlyOwner() {\n\t\trequire(msg.sender == owner);\n\t\t_;\n\t}\n\t\n\tmodifier onlyVerificator() {\n\t\trequire(isVerificator(msg.sender));\n\t\t_;\n\t}\n\t\n\tmodifier onlyVerified(address _from, address _to) {\n\t\trequire(isVerified(_from));\n\t\trequire(isVerified(_to));\n\t\t_;\n\t}\n\n\tfunction FinToken() public {\n\t\towner = msg.sender;\n\t\ttotalSupply_ = INITIAL_SUPPLY;\n\t\tbalances[msg.sender] = INITIAL_SUPPLY;\n\t\temit Transfer(0x0, msg.sender, INITIAL_SUPPLY);\n\t}\n\t\n\tfunction addVerificatorAddress(address addr) public onlyOwner {\n\t\tverificatorAddresses[addr] = true;\n\t\temit AddVerificator(addr);\n\t}\n\t\n\tfunction removeVerificatorAddress(address addr) public onlyOwner {\n\t\tdelete verificatorAddresses[addr];\n\t\temit RemoveVerificator(addr);\n\t}\n\t\n\tfunction isVerificator(address addr) public constant returns (bool) {\n\t\treturn verificatorAddresses[addr];\n\t}\n\t\t\n\tfunction addVerifiedAddress(address addr) public onlyVerificator {\n\t\tverifiedAddresses[addr] = true;\n\t\temit AddVerified(msg.sender, addr);\n\t}\n\t\n\tfunction removeVerifiedAddress(address addr) public onlyVerificator {\n\t\tdelete verifiedAddresses[addr];\n\t\temit RemoveVerified(msg.sender, addr);\n\t}\n\t\n\tfunction isVerified(address addr) public constant returns (bool) {\n\t\treturn verifiedAddresses[addr];\n\t}\n\t\n\tfunction transfer(address _to, uint256 _value) public onlyVerified(msg.sender, _to) returns (bool) {\n\t\tsuper.transfer(_to, _value);\n\t}\n\t\n\tfunction transferFrom(address _from, address _to, uint256 _value) public onlyVerified(_from, _to) returns (bool) {\n\t    super.transferFrom(_from, _to, _value);\n\t}\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Chainsulting-FIN/FinToken/FinToken.sol",
        "vulnerability": "Assertion Failure",
        "check": "FP",
        "response": "Answer: Yes\nDescription: The contract doesn't handle integer overflow in the calculation of `INITIAL_SUPPLY`, which can lead to unexpected values causing assertion failure when values exceed specified limits."
    },
    {
        "code_segment": "contract StandardToken is ERC20, BasicToken {\n\n\tmapping (address => mapping (address => uint256)) internal allowed;\n\n\n\t/**\n\t * @dev Transfer tokens from one address to another\n\t * @param _from address The address which you want to send tokens from\n\t * @param _to address The address which you want to transfer to\n\t * @param _value uint256 the amount of tokens to be transferred\n\t */\n\tfunction transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n\t\trequire(_to != address(0));\n\t\trequire(_value <= balances[_from]);\n\t\trequire(_value <= allowed[_from][msg.sender]);\n\n\t\tbalances[_from] = balances[_from].sub(_value);\n\t\tbalances[_to] = balances[_to].add(_value);\n\t\tallowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n\t\temit Transfer(_from, _to, _value);\n\t\treturn true;\n\t}\n\n\t/**\n\t * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n\t *\n\t * Beware that changing an allowance with this method brings the risk that someone may use both the old\n\t * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n\t * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n\t * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n\t * @param _spender The address which will spend the funds.\n\t * @param _value The amount of tokens to be spent.\n\t */\n\tfunction approve(address _spender, uint256 _value) public returns (bool) {\n\t\tallowed[msg.sender][_spender] = _value;\n\t\temit Approval(msg.sender, _spender, _value);\n\t\treturn true;\n\t}\n\n\t/**\n\t * @dev Function to check the amount of tokens that an owner allowed to a spender.\n\t * @param _owner address The address which owns the funds.\n\t * @param _spender address The address which will spend the funds.\n\t * @return A uint256 specifying the amount of tokens still available for the spender.\n\t */\n\tfunction allowance(address _owner, address _spender) public view returns (uint256) {\n\t\treturn allowed[_owner][_spender];\n\t}\n\n\t/**\n\t * @dev Increase the amount of tokens that an owner allowed to a spender.\n\t *\n\t * approve should be called when allowed[_spender] == 0. To increment\n\t * allowed value is better to use this function to avoid 2 calls (and wait until\n\t * the first transaction is mined)\n\t * From MonolithDAO Token.sol\n\t * @param _spender The address which will spend the funds.\n\t * @param _addedValue The amount of tokens to increase the allowance by.\n\t */\n\tfunction increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n\t\tallowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n\t\temit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n\t\treturn true;\n\t}\n\n\t/**\n\t * @dev Decrease the amount of tokens that an owner allowed to a spender.\n\t *\n\t * approve should be called when allowed[_spender] == 0. To decrement\n\t * allowed value is better to use this function to avoid 2 calls (and wait until\n\t * the first transaction is mined)\n\t * From MonolithDAO Token.sol\n\t * @param _spender The address which will spend the funds.\n\t * @param _subtractedValue The amount of tokens to decrease the allowance by.\n\t */\n\tfunction decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n\t\tuint oldValue = allowed[msg.sender][_spender];\n\t\tif (_subtractedValue > oldValue) {\n\t\t\tallowed[msg.sender][_spender] = 0;\n\t\t} else {\n\t\t\tallowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n\t\t}\n\t\temit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n\t\treturn true;\n\t}\n\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Chainsulting-FIN/FinToken/FinToken.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No\nReason: The contract uses the SafeMath library for arithmetic operations, which prevents integer overflow."
    },
    {
        "code_segment": "contract StandardToken is ERC20, BasicToken {\n\n\tmapping (address => mapping (address => uint256)) internal allowed;\n\n\n\t/**\n\t * @dev Transfer tokens from one address to another\n\t * @param _from address The address which you want to send tokens from\n\t * @param _to address The address which you want to transfer to\n\t * @param _value uint256 the amount of tokens to be transferred\n\t */\n\tfunction transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n\t\trequire(_to != address(0));\n\t\trequire(_value <= balances[_from]);\n\t\trequire(_value <= allowed[_from][msg.sender]);\n\n\t\tbalances[_from] = balances[_from].sub(_value);\n\t\tbalances[_to] = balances[_to].add(_value);\n\t\tallowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n\t\temit Transfer(_from, _to, _value);\n\t\treturn true;\n\t}\n\n\t/**\n\t * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n\t *\n\t * Beware that changing an allowance with this method brings the risk that someone may use both the old\n\t * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n\t * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n\t * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n\t * @param _spender The address which will spend the funds.\n\t * @param _value The amount of tokens to be spent.\n\t */\n\tfunction approve(address _spender, uint256 _value) public returns (bool) {\n\t\tallowed[msg.sender][_spender] = _value;\n\t\temit Approval(msg.sender, _spender, _value);\n\t\treturn true;\n\t}\n\n\t/**\n\t * @dev Function to check the amount of tokens that an owner allowed to a spender.\n\t * @param _owner address The address which owns the funds.\n\t * @param _spender address The address which will spend the funds.\n\t * @return A uint256 specifying the amount of tokens still available for the spender.\n\t */\n\tfunction allowance(address _owner, address _spender) public view returns (uint256) {\n\t\treturn allowed[_owner][_spender];\n\t}\n\n\t/**\n\t * @dev Increase the amount of tokens that an owner allowed to a spender.\n\t *\n\t * approve should be called when allowed[_spender] == 0. To increment\n\t * allowed value is better to use this function to avoid 2 calls (and wait until\n\t * the first transaction is mined)\n\t * From MonolithDAO Token.sol\n\t * @param _spender The address which will spend the funds.\n\t * @param _addedValue The amount of tokens to increase the allowance by.\n\t */\n\tfunction increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n\t\tallowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n\t\temit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n\t\treturn true;\n\t}\n\n\t/**\n\t * @dev Decrease the amount of tokens that an owner allowed to a spender.\n\t *\n\t * approve should be called when allowed[_spender] == 0. To decrement\n\t * allowed value is better to use this function to avoid 2 calls (and wait until\n\t * the first transaction is mined)\n\t * From MonolithDAO Token.sol\n\t * @param _spender The address which will spend the funds.\n\t * @param _subtractedValue The amount of tokens to decrease the allowance by.\n\t */\n\tfunction decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n\t\tuint oldValue = allowed[msg.sender][_spender];\n\t\tif (_subtractedValue > oldValue) {\n\t\t\tallowed[msg.sender][_spender] = 0;\n\t\t} else {\n\t\t\tallowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n\t\t}\n\t\temit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n\t\treturn true;\n\t}\n\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Chainsulting-FIN/FinToken/FinToken.sol",
        "vulnerability": "Assertion Failure",
        "check": "FP",
        "response": "Answer: No\nReason: The code does not contain any assertions using the `assert` statement. All checks are done using `require`, which reverts the transaction without causing an assertion failure."
    },
    {
        "code_segment": "contract OwnerManager is SelfAuthorized {\n\n    event AddedOwner(address owner);\n    event RemovedOwner(address owner);\n    event ChangedThreshold(uint256 threshold);\n\n    address public constant SENTINEL_OWNERS = address(0x1);\n\n    mapping(address => address) internal owners;\n    uint256 ownerCount;\n    uint256 internal threshold;\n\n    \n    \n    \n    function setupOwners(address[] memory _owners, uint256 _threshold)\n        internal\n    {\n        // Threshold can only be 0 at initialization.\n        // Check ensures that setup function can only be called once.\n        require(threshold == 0, \"Owners have already been setup\");\n        // Validate that threshold is smaller than number of added owners.\n        require(_threshold <= _owners.length, \"Threshold cannot exceed owner count\");\n        // There has to be at least one Safe owner.\n        require(_threshold >= 1, \"Threshold needs to be greater than 0\");\n        // Initializing Safe owners.\n        address currentOwner = SENTINEL_OWNERS;\n        for (uint256 i = 0; i < _owners.length; i++) {\n            // Owner address cannot be null.\n            address owner = _owners[i];\n            require(owner != address(0) && owner != SENTINEL_OWNERS, \"Invalid owner address provided\");\n            // No duplicate owners allowed.\n            require(owners[owner] == address(0), \"Duplicate owner address provided\");\n            owners[currentOwner] = owner;\n            currentOwner = owner;\n        }\n        owners[currentOwner] = SENTINEL_OWNERS;\n        ownerCount = _owners.length;\n        threshold = _threshold;\n    }\n\n    \n    \n    \n    \n    // SWC-114-Transaction Order Dependence: L53 - L68\n    function addOwnerWithThreshold(address owner, uint256 _threshold)\n        public\n        authorized\n    {\n        // Owner address cannot be null.\n        require(owner != address(0) && owner != SENTINEL_OWNERS, \"Invalid owner address provided\");\n        // No duplicate owners allowed.\n        require(owners[owner] == address(0), \"Address is already an owner\");\n        owners[owner] = owners[SENTINEL_OWNERS];\n        owners[SENTINEL_OWNERS] = owner;\n        // SWC-101-Integer Overflow and Underflow: L64\n        ownerCount++;\n        emit AddedOwner(owner);\n        // Change threshold if threshold was changed.\n        if (threshold != _threshold)\n            changeThreshold(_threshold);\n    }\n\n    \n    \n    \n    \n    \n    function removeOwner(address prevOwner, address owner, uint256 _threshold)\n        public\n        authorized\n    {\n        // Only allow to remove an owner, if threshold can still be reached.\n        // SWC-101-Integer Overflow and Underflow: L82\n        require(ownerCount - 1 >= _threshold, \"New owner count needs to be larger than new threshold\");\n        // Validate owner address and check that it corresponds to owner index.\n        require(owner != address(0) && owner != SENTINEL_OWNERS, \"Invalid owner address provided\");\n        require(owners[prevOwner] == owner, \"Invalid prevOwner, owner pair provided\");\n        owners[prevOwner] = owners[owner];\n        owners[owner] = address(0);\n        // SWC-101-Integer Overflow and Underflow: L89\n        ownerCount--;\n        emit RemovedOwner(owner);\n        // Change threshold if threshold was changed.\n        if (threshold != _threshold)\n            changeThreshold(_threshold);\n    }\n\n    \n    \n    \n    \n    \n    function swapOwner(address prevOwner, address oldOwner, address newOwner)\n        public\n        authorized\n    {\n        // Owner address cannot be null.\n        require(newOwner != address(0) && newOwner != SENTINEL_OWNERS, \"Invalid owner address provided\");\n        // No duplicate owners allowed.\n        require(owners[newOwner] == address(0), \"Address is already an owner\");\n        // Validate oldOwner address and check that it corresponds to owner index.\n        require(oldOwner != address(0) && oldOwner != SENTINEL_OWNERS, \"Invalid owner address provided\");\n        require(owners[prevOwner] == oldOwner, \"Invalid prevOwner, owner pair provided\");\n        owners[newOwner] = owners[oldOwner];\n        owners[prevOwner] = newOwner;\n        owners[oldOwner] = address(0);\n        emit RemovedOwner(oldOwner);\n        emit AddedOwner(newOwner);\n    }\n\n    \n    \n    \n    function changeThreshold(uint256 _threshold)\n        public\n        authorized\n    {\n        // Validate that threshold is smaller than number of owners.\n        require(_threshold <= ownerCount, \"Threshold cannot exceed owner count\");\n        // There has to be at least one Safe owner.\n        require(_threshold >= 1, \"Threshold needs to be greater than 0\");\n        threshold = _threshold;\n        emit ChangedThreshold(threshold);\n    }\n\n    function getThreshold()\n        public\n        view\n        returns (uint256)\n    {\n        return threshold;\n    }\n\n    function isOwner(address owner)\n        public\n        view\n        returns (bool)\n    {\n        return owners[owner] != address(0);\n    }\n\n    \n    \n    function getOwners()\n        public\n        view\n        returns (address[] memory)\n    {\n        address[] memory array = new address[](ownerCount);\n\n        // populate return array\n        uint256 index = 0;\n        address currentOwner = owners[SENTINEL_OWNERS];\n        while(currentOwner != SENTINEL_OWNERS) {\n            array[index] = currentOwner;\n            currentOwner = owners[currentOwner];\n            index ++;\n        }\n        return array;\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Runtime_Vеrification-GnosisSafe/safe-contracts-427d6f7e779431333c54bcb4d4cde31e4d57ce96/contracts/base/OwnerManager.sol",
        "vulnerability": "Assertion Failure",
        "check": "FP",
        "response": "Answer: No\nReason: The code has assert statements but their fail conditions are checked with require() statements beforehand."
    },
    {
        "code_segment": "contract OwnerManager is SelfAuthorized {\n\n    event AddedOwner(address owner);\n    event RemovedOwner(address owner);\n    event ChangedThreshold(uint256 threshold);\n\n    address public constant SENTINEL_OWNERS = address(0x1);\n\n    mapping(address => address) internal owners;\n    uint256 ownerCount;\n    uint256 internal threshold;\n\n    \n    \n    \n    function setupOwners(address[] memory _owners, uint256 _threshold)\n        internal\n    {\n        // Threshold can only be 0 at initialization.\n        // Check ensures that setup function can only be called once.\n        require(threshold == 0, \"Owners have already been setup\");\n        // Validate that threshold is smaller than number of added owners.\n        require(_threshold <= _owners.length, \"Threshold cannot exceed owner count\");\n        // There has to be at least one Safe owner.\n        require(_threshold >= 1, \"Threshold needs to be greater than 0\");\n        // Initializing Safe owners.\n        address currentOwner = SENTINEL_OWNERS;\n        for (uint256 i = 0; i < _owners.length; i++) {\n            // Owner address cannot be null.\n            address owner = _owners[i];\n            require(owner != address(0) && owner != SENTINEL_OWNERS, \"Invalid owner address provided\");\n            // No duplicate owners allowed.\n            require(owners[owner] == address(0), \"Duplicate owner address provided\");\n            owners[currentOwner] = owner;\n            currentOwner = owner;\n        }\n        owners[currentOwner] = SENTINEL_OWNERS;\n        ownerCount = _owners.length;\n        threshold = _threshold;\n    }\n\n    \n    \n    \n    \n    // SWC-114-Transaction Order Dependence: L53 - L68\n    function addOwnerWithThreshold(address owner, uint256 _threshold)\n        public\n        authorized\n    {\n        // Owner address cannot be null.\n        require(owner != address(0) && owner != SENTINEL_OWNERS, \"Invalid owner address provided\");\n        // No duplicate owners allowed.\n        require(owners[owner] == address(0), \"Address is already an owner\");\n        owners[owner] = owners[SENTINEL_OWNERS];\n        owners[SENTINEL_OWNERS] = owner;\n        // SWC-101-Integer Overflow and Underflow: L64\n        ownerCount++;\n        emit AddedOwner(owner);\n        // Change threshold if threshold was changed.\n        if (threshold != _threshold)\n            changeThreshold(_threshold);\n    }\n\n    \n    \n    \n    \n    \n    function removeOwner(address prevOwner, address owner, uint256 _threshold)\n        public\n        authorized\n    {\n        // Only allow to remove an owner, if threshold can still be reached.\n        // SWC-101-Integer Overflow and Underflow: L82\n        require(ownerCount - 1 >= _threshold, \"New owner count needs to be larger than new threshold\");\n        // Validate owner address and check that it corresponds to owner index.\n        require(owner != address(0) && owner != SENTINEL_OWNERS, \"Invalid owner address provided\");\n        require(owners[prevOwner] == owner, \"Invalid prevOwner, owner pair provided\");\n        owners[prevOwner] = owners[owner];\n        owners[owner] = address(0);\n        // SWC-101-Integer Overflow and Underflow: L89\n        ownerCount--;\n        emit RemovedOwner(owner);\n        // Change threshold if threshold was changed.\n        if (threshold != _threshold)\n            changeThreshold(_threshold);\n    }\n\n    \n    \n    \n    \n    \n    function swapOwner(address prevOwner, address oldOwner, address newOwner)\n        public\n        authorized\n    {\n        // Owner address cannot be null.\n        require(newOwner != address(0) && newOwner != SENTINEL_OWNERS, \"Invalid owner address provided\");\n        // No duplicate owners allowed.\n        require(owners[newOwner] == address(0), \"Address is already an owner\");\n        // Validate oldOwner address and check that it corresponds to owner index.\n        require(oldOwner != address(0) && oldOwner != SENTINEL_OWNERS, \"Invalid owner address provided\");\n        require(owners[prevOwner] == oldOwner, \"Invalid prevOwner, owner pair provided\");\n        owners[newOwner] = owners[oldOwner];\n        owners[prevOwner] = newOwner;\n        owners[oldOwner] = address(0);\n        emit RemovedOwner(oldOwner);\n        emit AddedOwner(newOwner);\n    }\n\n    \n    \n    \n    function changeThreshold(uint256 _threshold)\n        public\n        authorized\n    {\n        // Validate that threshold is smaller than number of owners.\n        require(_threshold <= ownerCount, \"Threshold cannot exceed owner count\");\n        // There has to be at least one Safe owner.\n        require(_threshold >= 1, \"Threshold needs to be greater than 0\");\n        threshold = _threshold;\n        emit ChangedThreshold(threshold);\n    }\n\n    function getThreshold()\n        public\n        view\n        returns (uint256)\n    {\n        return threshold;\n    }\n\n    function isOwner(address owner)\n        public\n        view\n        returns (bool)\n    {\n        return owners[owner] != address(0);\n    }\n\n    \n    \n    function getOwners()\n        public\n        view\n        returns (address[] memory)\n    {\n        address[] memory array = new address[](ownerCount);\n\n        // populate return array\n        uint256 index = 0;\n        address currentOwner = owners[SENTINEL_OWNERS];\n        while(currentOwner != SENTINEL_OWNERS) {\n            array[index] = currentOwner;\n            currentOwner = owners[currentOwner];\n            index ++;\n        }\n        return array;\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Runtime_Vеrification-GnosisSafe/safe-contracts-427d6f7e779431333c54bcb4d4cde31e4d57ce96/contracts/base/OwnerManager.sol",
        "vulnerability": "Integer Overflow",
        "check": "TP",
        "response": "Answer: No\nReason: The code uses \"require\" statements to control the increment and decrement of `ownerCount`, preventing overflow."
    },
    {
        "code_segment": "contract SpaceMonkey is SpaceMonkeyStorage, IERC20 {\n  using Address for address;\n  \n  constructor() {\n    _tTotal = 0;\n    _name= \"\";\n    _symbol=\"\";\n  }\n\n  modifier onlyOwnerOrMaster() {\n    require(_msgSender() == owner() || _msgSender() == _secondOwner);\n    _;\n  }\n\n  function name() public view returns (string memory) {\n    return _name;\n  }\n\n  function symbol() public view returns (string memory) {\n    return _symbol;\n  }\n\n  function decimals() public view returns (uint8) {\n    return _decimals;\n  }\n\n  function totalSupply() public view override returns (uint256) {\n    return _tTotal - balanceOf(deadAddress);\n  }\n\n  function balanceOf(address account) public view override returns (uint256) {\n    if (_isExcluded[account]) return _tOwned[account];\n    return tokenFromReflection(_rOwned[account]);\n  }\n\n  function transfer(address recipient, uint256 amount)\n    public\n    override\n    returns (bool)\n  {\n    _transfer(_msgSender(), recipient, amount);\n    return true;\n  }\n\n// SWC-107-Reentrancy: L53 - L64\n  function transfer(address recipient, uint256 amount, bytes calldata data) external returns (bool) {\n      if(recipient.isContract()) {\n          require(_msgSender() != address(0), \"ERC20: transfer from the zero address\");\n          require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n          _transfer(_msgSender(), recipient, amount);\n          IERC223Recipient(recipient).tokenFallback(_msgSender(), amount, data);\n      } else {\n          _transfer(_msgSender(), recipient, amount);\n      }\n      return true;\n  }\n\n// SWC-119-Shadowing State Variables: L66\n  function allowance(address owner, address spender)\n    public\n    view\n    override\n    returns (uint256)\n  {\n    return _allowances[owner][spender];\n  }\n\n  function approve(address spender, uint256 amount)\n    public\n    override\n    returns (bool)\n  {\n    _approve(_msgSender(), spender, amount);\n    return true;\n  }\n\n  function transferFrom(\n    address sender,\n    address recipient,\n    uint256 amount\n  ) public override returns (bool) {\n    _transfer(sender, recipient, amount);\n    _approve(\n      sender,\n      _msgSender(),\n      _allowances[sender][_msgSender()]-amount\n    );\n    return true;\n  }\n\n  function increaseAllowance(address spender, uint256 addedValue)\n    external\n    virtual\n    returns (bool)\n  {\n    _approve(\n      _msgSender(),\n      spender,\n      _allowances[_msgSender()][spender]+(addedValue)\n    );\n    return true;\n  }\n\n  function decreaseAllowance(address spender, uint256 subtractedValue)\n    external\n    virtual\n    returns (bool)\n  {\n    _approve(\n      _msgSender(),\n      spender,\n      _allowances[_msgSender()][spender]-\n        subtractedValue\n    );\n    return true;\n  }\n\n  function deliver(uint256 tAmount) external {\n    address sender = _msgSender();\n    require(\n      !_isExcluded[sender],\n      'Excluded addresses cannot call this function'\n    );\n    (uint256 rAmount, , , , , ) = _getValues(tAmount);\n    _rOwned[sender] = _rOwned[sender]-(rAmount);\n    _rTotal = _rTotal-(rAmount);\n    _tFeeTotal = _tFeeTotal+(tAmount);\n  }\n\n  function isExcludedFromReward(address account) external view returns (bool) {\n    return _isExcluded[account];\n  }\n\n  function totalFees() external view returns (uint256) {\n    return _tFeeTotal;\n  }\n  \n  function overrideMaxRestriction(bool canBuyAnyAmount) external {\n    overrideMaxBuy = canBuyAnyAmount;\n  }\n\n  function reflectionFromToken(uint256 tAmount, bool deductTransferFee)\n    public\n    view\n    returns (uint256)\n  {\n    require(tAmount <= _tTotal, 'Amount must be less than supply');\n    if (!deductTransferFee) {\n      (uint256 rAmount, , , , , ) = _getValues(tAmount);\n      return rAmount;\n    } else {\n      (, uint256 rTransferAmount, , , , ) = _getValues(tAmount);\n      return rTransferAmount;\n    }\n  }\n\n  function tokenFromReflection(uint256 rAmount) public view returns (uint256) {\n    require(rAmount <= _rTotal, 'Amount must be less than total reflections');\n    uint256 currentRate = _getRate();\n    return rAmount/(currentRate);\n  }\n\n  function excludeFromReward(address account) public onlyOwner {\n    require(!_isExcluded[account], 'Account is already excluded');\n    if (_rOwned[account] > 0) {\n      _tOwned[account] = tokenFromReflection(_rOwned[account]);\n    }\n    _isExcluded[account] = true;\n    _excluded.push(account);\n  }\n\n  function includeInReward(address account) external onlyOwner {\n    require(_isExcluded[account], 'Account is already excluded');\n    for (uint256 i = 0; i < _excluded.length; i++) {\n      if (_excluded[i] == account) {\n        _excluded[i] = _excluded[_excluded.length - 1];\n        _tOwned[account] = 0;\n        _isExcluded[account] = false;\n        _excluded.pop();\n        break;\n      }\n    }\n  }\n\n// SWC-119-Shadowing State Variables: L193\n  function _approve(\n    address owner,\n    address spender,\n    uint256 amount\n  ) private {\n    require(owner != address(0), 'ERC20: approve from the zero address');\n    require(spender != address(0), 'ERC20: approve to the zero address');\n    require(!_isBlacklisted[_msgSender()], 'You have no power here!');\n\n    _allowances[owner][spender] = amount;\n    emit Approval(owner, spender, amount);\n  }\n\n  function _transfer(\n    address from,\n    address to,\n    uint256 amount\n  ) private {\n    require(from != address(0), 'ERC20: transfer from the zero address');\n    require(to != address(0), 'ERC20: transfer to the zero address');\n    require(amount > 0, 'Transfer amount must be greater than zero');\n    require(!_isBlacklisted[_msgSender()], 'You have no power here!');\n\n    _tokenTransfer(from, to, amount);\n  }\n\n  function markAsSwap(address swap, bool isSwap) external onlyOwner() {\n    _isSwap[swap] = isSwap;\n  }\n\n  function _tokenTransfer(\n    address sender,\n    address recipient,\n    uint256 amount\n  ) private {\n\n    bool takeFee = true;\n    bool takeLargerFee = false;\n    if(_isExcludedFromFee[sender] || _isExcludedFromFee[recipient]) {\n      takeFee = false;\n      removeAllFee();\n    } else if (_isSwap[recipient]) {\n    //take bigger fee only on selling swaps\n      takeLargerFee = true;\n      doubleFees(_feemultiplier);\n    }\n\n    if (_isExcluded[sender] && !_isExcluded[recipient]) {\n      _transferFromExcluded(sender, recipient, amount);\n    } else if (!_isExcluded[sender] && _isExcluded[recipient]) {\n      _transferToExcluded(sender, recipient, amount);\n    } else if (_isExcluded[sender] && _isExcluded[recipient]) {\n      _transferBothExcluded(sender, recipient, amount);\n    } else {\n      _transferStandard(sender, recipient, amount);\n    }\n\n    if (!takeFee || takeLargerFee) restoreAllFee();\n  }\n\n  function _transferStandard(\n    address sender,\n    address recipient,\n    uint256 tAmount\n  ) private {\n    (\n      uint256 rAmount,\n      uint256 rTransferAmount,\n      uint256 rFee,\n      ,\n      uint256 tFee,\n      uint256 tLiquidity\n    ) = _getValues(tAmount);\n    _rOwned[sender] = _rOwned[sender]-(rAmount);\n\n    uint256 _recipientBalBefore = balanceOf(recipient);\n    uint256 _deadBalBefore = balanceOf(deadAddress);\n\n    (uint256 rBurnAmount, ) = _adjustReflectBalanceRefs(\n      recipient,\n      rTransferAmount\n    );\n    _takeLiquidityReflectAndEmitTransfers(\n      sender,\n      recipient,\n      _recipientBalBefore,\n      _deadBalBefore,\n      rBurnAmount,\n      tLiquidity,\n      rFee,\n      tFee\n    );\n  }\n\n  function _transferToExcluded(\n    address sender,\n    address recipient,\n    uint256 tAmount\n  ) private {\n    (\n      uint256 rAmount,\n      uint256 rTransferAmount,\n      uint256 rFee,\n      uint256 tTransferAmount,\n      uint256 tFee,\n      uint256 tLiquidity\n    ) = _getValues(tAmount);\n    _rOwned[sender] = _rOwned[sender]-(rAmount);\n\n    uint256 _recipientBalBefore = balanceOf(recipient);\n    uint256 _deadBalBefore = balanceOf(deadAddress);\n\n    _adjustTotalBalanceRefs(recipient, tTransferAmount, rTransferAmount);\n    (uint256 rBurnAmount, ) = _adjustReflectBalanceRefs(\n      recipient,\n      rTransferAmount\n    );\n    _takeLiquidityReflectAndEmitTransfers(\n      sender,\n      recipient,\n      _recipientBalBefore,\n      _deadBalBefore,\n      rBurnAmount,\n      tLiquidity,\n      rFee,\n      tFee\n    );\n  }\n\n  function _transferFromExcluded(\n    address sender,\n    address recipient,\n    uint256 tAmount\n  ) private {\n    (\n      uint256 rAmount,\n      uint256 rTransferAmount,\n      uint256 rFee,\n      ,\n      uint256 tFee,\n      uint256 tLiquidity\n    ) = _getValues(tAmount);\n    _tOwned[sender] = _tOwned[sender]-(tAmount);\n    _rOwned[sender] = _rOwned[sender]-(rAmount);\n\n    uint256 _recipientBalBefore = balanceOf(recipient);\n    uint256 _deadBalBefore = balanceOf(deadAddress);\n\n    (uint256 rBurnAmount, ) = _adjustReflectBalanceRefs(\n      recipient,\n      rTransferAmount\n    );\n    _takeLiquidityReflectAndEmitTransfers(\n      sender,\n      recipient,\n      _recipientBalBefore,\n      _deadBalBefore,\n      rBurnAmount,\n      tLiquidity,\n      rFee,\n      tFee\n    );\n  }\n\n  function _transferBothExcluded(\n    address sender,\n    address recipient,\n    uint256 tAmount\n  ) private {\n    (\n      uint256 rAmount,\n      uint256 rTransferAmount,\n      uint256 rFee,\n      uint256 tTransferAmount,\n      uint256 tFee,\n      uint256 tLiquidity\n    ) = _getValues(tAmount);\n    _tOwned[sender] = _tOwned[sender]-(tAmount);\n    _rOwned[sender] = _rOwned[sender]-(rAmount);\n\n    uint256 _recipientBalBefore = balanceOf(recipient);\n    uint256 _deadBalBefore = balanceOf(deadAddress);\n\n    _adjustTotalBalanceRefs(recipient, tTransferAmount, rTransferAmount);\n    (uint256 rBurnAmount, ) = _adjustReflectBalanceRefs(\n      recipient,\n      rTransferAmount\n    );\n    _takeLiquidityReflectAndEmitTransfers(\n      sender,\n      recipient,\n      _recipientBalBefore,\n      _deadBalBefore,\n      rBurnAmount,\n      tLiquidity,\n      rFee,\n      tFee\n    );\n  }\n\n  function _adjustTotalBalanceRefs(\n    address recipient,\n    uint256 tTransferAmount,\n    uint256 rTransferAmount\n  ) private {\n    uint256 tBurnAmount = calculateBurnFee(tTransferAmount);\n    uint256 tRecipientAmount = rTransferAmount-(tBurnAmount);\n    _tOwned[recipient] = _tOwned[recipient]+(tRecipientAmount);\n    _tOwned[deadAddress] = _tOwned[deadAddress]+(tBurnAmount);\n  }\n\n  function _adjustReflectBalanceRefs(address recipient, uint256 rTransferAmount)\n    private\n    returns (uint256, uint256)\n  {\n    uint256 rBurnAmount = calculateBurnFee(rTransferAmount);\n    uint256 rRecipientAmount = rTransferAmount-(rBurnAmount);\n    _rOwned[recipient] = _rOwned[recipient]+(rRecipientAmount);\n    _rOwned[deadAddress] = _rOwned[deadAddress]+(rBurnAmount);\n    return (rBurnAmount, rRecipientAmount);\n  }\n\n  function _takeLiquidityReflectAndEmitTransfers(\n    address sender,\n    address recipient,\n    uint256 recipientBalBefore,\n    uint256 deadBalBefore,\n    uint256 rBurnAmount,\n    uint256 tLiquidity,\n    uint256 rFee,\n    uint256 tFee\n  ) private {\n    _takeLiquidity(sender, tLiquidity);\n    _reflectFee(rFee, tFee);\n    emit Transfer(\n      sender,\n      recipient,\n      balanceOf(recipient)-(recipientBalBefore)\n    );\n    if (rBurnAmount > 0) {\n      emit Transfer(\n        sender,\n        deadAddress,\n        balanceOf(deadAddress)-(deadBalBefore)\n      );\n    }\n  }\n\n  function _reflectFee(uint256 rFee, uint256 tFee) private {\n    _rTotal = _rTotal-(rFee);\n    _tFeeTotal = _tFeeTotal+(tFee);\n  }\n\n  function _getValues(uint256 tAmount)\n    private\n    view\n    returns (\n      uint256,\n      uint256,\n      uint256,\n      uint256,\n      uint256,\n      uint256\n    )\n  {\n    (uint256 tTransferAmount, uint256 tFee, uint256 tLiquidity) = _getTValues(\n      tAmount\n    );\n    (uint256 rAmount, uint256 rTransferAmount, uint256 rFee) = _getRValues(\n      tAmount,\n      tFee,\n      tLiquidity,\n      _getRate()\n    );\n    return (rAmount, rTransferAmount, rFee, tTransferAmount, tFee, tLiquidity);\n  }\n\n  function _getTValues(uint256 tAmount)\n    private\n    view\n    returns (\n      uint256,\n      uint256,\n      uint256\n    )\n  {\n    uint256 tFee = calculateTaxFee(tAmount);\n    uint256 tLiquidity = calculateLiquidityFee(tAmount);\n    uint256 tTransferAmount = tAmount-(tFee)-(tLiquidity);\n    return (tTransferAmount, tFee, tLiquidity);\n  }\n\n  function _getRValues(\n    uint256 tAmount,\n    uint256 tFee,\n    uint256 tLiquidity,\n    uint256 currentRate\n  )\n    private\n    pure\n    returns (\n      uint256,\n      uint256,\n      uint256\n    )\n  {\n    uint256 rAmount = tAmount*(currentRate);\n    uint256 rFee = tFee*(currentRate);\n    uint256 rLiquidity = tLiquidity*(currentRate);\n    uint256 rTransferAmount = rAmount-(rFee)-(rLiquidity);\n    return (rAmount, rTransferAmount, rFee);\n  }\n\n  function _getRate() private view returns (uint256) {\n    (uint256 rSupply, uint256 tSupply) = _getCurrentSupply();\n    return rSupply/(tSupply);\n  }\n\n  function _getCurrentSupply() private view returns (uint256, uint256) {\n    uint256 rSupply = _rTotal;\n    uint256 tSupply = _tTotal;\n    for (uint256 i = 0; i < _excluded.length; i++) {\n      if (_rOwned[_excluded[i]] > rSupply || _tOwned[_excluded[i]] > tSupply)\n        return (_rTotal, _tTotal);\n      rSupply = rSupply-(_rOwned[_excluded[i]]);\n      tSupply = tSupply-(_tOwned[_excluded[i]]);\n    }\n    if (rSupply < _rTotal/(_tTotal)) return (_rTotal, _tTotal);\n    return (rSupply, tSupply);\n  }\n\n  function _takeLiquidity(address sender, uint256 tLiquidity) private {\n    uint256 currentRate = _getRate();\n    uint256 rLiquidity = tLiquidity * currentRate;\n    uint256 tOurShare = (tLiquidity * _marketingLiquidityFee) / 10**3;\n    uint256 tTeamShare = (tLiquidity * _teamLiquidityFee) / 10**3;\n    uint256 rOurShare = (rLiquidity * _marketingLiquidityFee) / 10**3;\n    uint256 rTeamShare = (rLiquidity * _teamLiquidityFee) / 10**3;\n\n    _rOwned[marketingAddress] += rOurShare;\n    if (_isExcluded[marketingAddress] && tOurShare > 0) {\n      _tOwned[marketingAddress] += tOurShare;\n      emit Transfer(sender, marketingAddress, tOurShare);\n    } else if(rOurShare > 0) {\n      emit Transfer(sender, marketingAddress, tokenFromReflection(rOurShare));\n    } \n\n    _rOwned[teamAddress] += rTeamShare;\n    if (_isExcluded[teamAddress] && tTeamShare > 0) {\n      emit Transfer(sender, teamAddress, tTeamShare);\n      _tOwned[teamAddress] += tTeamShare;\n    } else if(rTeamShare > 0) {\n      emit Transfer(sender, teamAddress, tokenFromReflection(rTeamShare));\n    }\n  }\n\n  function calculateTaxFee(uint256 _amount) private view returns (uint256) {\n    return _amount*(_taxFee)/(10**2);\n  }\n\n  function calculateLiquidityFee(uint256 _amount)\n    private\n    view\n    returns (uint256)\n  {\n    return _amount * _liquidityFee / 100;\n  }\n\n  function calculateBurnFee(uint256 _amount) private view returns (uint256) {\n    return _amount*(_burnFee)/(100);\n  }\n\n  function removeAllFee() private {\n    if (_taxFee == 0 && _liquidityFee == 0) return;\n\n    _previousTaxFee = _taxFee;\n    _previousLiquidityFee = _liquidityFee;\n    _previousBurnFee = _burnFee;\n\n    _taxFee = 0;\n    _liquidityFee = 0;\n    _burnFee = 0;\n  }\n\n  function restoreAllFee() private {\n    _taxFee = _previousTaxFee;\n    _liquidityFee = _previousLiquidityFee;\n    _burnFee = _previousBurnFee;\n  }\n\n  function doubleFees(uint256 fee) private {\n    _liquidityFee = _liquidityFee * fee / 100;\n    _taxFee = _taxFee * fee / 100;\n  }\n\n  function restoreLiquidityFee() private {\n    _liquidityFee = _previousLiquidityFee;\n  }\n\n  function isExcludedFromFee(address account) public view returns (bool) {\n    return _isExcludedFromFee[account];\n  }\n\n  function setSecondOwner(address newSecond) public onlyOwner {\n    _secondOwner = newSecond;\n  }\n\n  function excludeFromFee(address account) public onlyOwnerOrMaster {\n    _isExcludedFromFee[account] = true;\n  }\n\n  function includeInFee(address account) public onlyOwnerOrMaster {\n    _isExcludedFromFee[account] = false;\n  }\n\n  function setTaxFeePercent(uint256 taxFee) external onlyOwnerOrMaster {\n    _taxFee = taxFee;\n    _previousTaxFee = taxFee;\n  }\n\n  function setExtraFeePercent(uint256 extraLiquidityFee) external onlyOwnerOrMaster {\n    _feemultiplier = extraLiquidityFee;\n  }\n\n  function setLiquidityFeePercent(uint256 liquidityFee) external onlyOwnerOrMaster {\n    _liquidityFee = liquidityFee;\n    _previousLiquidityFee = liquidityFee;\n  }\n\n  function setFees(uint256 holderFee, uint256 liquidityFee, uint256 extraLiquidityFee) public onlyOwnerOrMaster {\n    _taxFee = holderFee;\n    _previousTaxFee = holderFee;\n    _liquidityFee = liquidityFee;\n    _previousLiquidityFee = liquidityFee;\n    _feemultiplier = extraLiquidityFee;\n  }\n\n  function setLiquiditySplit(uint256 selfLiquidityFee, uint256 marketingLiquidityFee) external onlyOwnerOrMaster {\n    require(selfLiquidityFee + marketingLiquidityFee == 1000, \"Fee split must add up to 1000 (100.0%)\");\n    _teamLiquidityFee = selfLiquidityFee;\n    _marketingLiquidityFee = marketingLiquidityFee;\n  }\n\n  function setBurnFeePercent(uint256 burnFee) public onlyOwner {\n    _burnFee = burnFee;\n  }\n\n  function setSupplyToStopBurning(uint256 supplyToStopBurning)\n    external\n    onlyOwner\n  {\n    _supplyToStopBurning = supplyToStopBurning;\n  }\n\n  function setMarketingAddress(address _marketingAddress) external onlyOwnerOrMaster {\n    marketingAddress = payable(_marketingAddress);\n  }\n\n  function setTeamAddress(address _teamAddress) external onlyOwnerOrMaster {\n    teamAddress = payable(_teamAddress);\n  }\n\n  function transferToAddressETH(address payable recipient, uint256 amount)\n    private\n  {\n    recipient.transfer(amount);\n  }\n\n  function isRemovedSniper(address account) public view returns (bool) {\n    return _isBlacklisted[account];\n  }\n\n  function _removeSniper(address account) external onlyOwner {\n    require(!_isBlacklisted[account], 'Account is already blacklisted');\n    _isBlacklisted[account] = true;\n    _confirmedSnipers.push(account);\n  }\n\n  function _amnestySniper(address account) external onlyOwner {\n    require(_isBlacklisted[account], 'Account is not blacklisted');\n    for (uint256 i = 0; i < _confirmedSnipers.length; i++) {\n      if (_confirmedSnipers[i] == account) {\n        _confirmedSnipers[i] = _confirmedSnipers[_confirmedSnipers.length - 1];\n        _isBlacklisted[account] = false;\n        _confirmedSnipers.pop();\n        break;\n      }\n    }\n  }\n\n  //to recieve ETH from pancakeswapV2Router when swaping\n  receive() external payable {}\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinbae-SpaceMonkey/SpaceMonkey0x9298f766581650e81357f5C66C91cc003f2b75Aa/root/workspace/GXC/contracts/SPMK/SpaceMonkey.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: Yes\nDescription: The arithmetic operations in functions like `_transfer`, `increaseAllowance`, `decreaseAllowance`, `_reflectFee`, `deliver`, and similar functions are not checked for overflow conditions which can lead to integer overflow vulnerabilities.\n"
    },
    {
        "code_segment": "contract SpaceMonkey is SpaceMonkeyStorage, IERC20 {\n  using Address for address;\n  \n  constructor() {\n    _tTotal = 0;\n    _name= \"\";\n    _symbol=\"\";\n  }\n\n  modifier onlyOwnerOrMaster() {\n    require(_msgSender() == owner() || _msgSender() == _secondOwner);\n    _;\n  }\n\n  function name() public view returns (string memory) {\n    return _name;\n  }\n\n  function symbol() public view returns (string memory) {\n    return _symbol;\n  }\n\n  function decimals() public view returns (uint8) {\n    return _decimals;\n  }\n\n  function totalSupply() public view override returns (uint256) {\n    return _tTotal - balanceOf(deadAddress);\n  }\n\n  function balanceOf(address account) public view override returns (uint256) {\n    if (_isExcluded[account]) return _tOwned[account];\n    return tokenFromReflection(_rOwned[account]);\n  }\n\n  function transfer(address recipient, uint256 amount)\n    public\n    override\n    returns (bool)\n  {\n    _transfer(_msgSender(), recipient, amount);\n    return true;\n  }\n\n// SWC-107-Reentrancy: L53 - L64\n  function transfer(address recipient, uint256 amount, bytes calldata data) external returns (bool) {\n      if(recipient.isContract()) {\n          require(_msgSender() != address(0), \"ERC20: transfer from the zero address\");\n          require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n          _transfer(_msgSender(), recipient, amount);\n          IERC223Recipient(recipient).tokenFallback(_msgSender(), amount, data);\n      } else {\n          _transfer(_msgSender(), recipient, amount);\n      }\n      return true;\n  }\n\n// SWC-119-Shadowing State Variables: L66\n  function allowance(address owner, address spender)\n    public\n    view\n    override\n    returns (uint256)\n  {\n    return _allowances[owner][spender];\n  }\n\n  function approve(address spender, uint256 amount)\n    public\n    override\n    returns (bool)\n  {\n    _approve(_msgSender(), spender, amount);\n    return true;\n  }\n\n  function transferFrom(\n    address sender,\n    address recipient,\n    uint256 amount\n  ) public override returns (bool) {\n    _transfer(sender, recipient, amount);\n    _approve(\n      sender,\n      _msgSender(),\n      _allowances[sender][_msgSender()]-amount\n    );\n    return true;\n  }\n\n  function increaseAllowance(address spender, uint256 addedValue)\n    external\n    virtual\n    returns (bool)\n  {\n    _approve(\n      _msgSender(),\n      spender,\n      _allowances[_msgSender()][spender]+(addedValue)\n    );\n    return true;\n  }\n\n  function decreaseAllowance(address spender, uint256 subtractedValue)\n    external\n    virtual\n    returns (bool)\n  {\n    _approve(\n      _msgSender(),\n      spender,\n      _allowances[_msgSender()][spender]-\n        subtractedValue\n    );\n    return true;\n  }\n\n  function deliver(uint256 tAmount) external {\n    address sender = _msgSender();\n    require(\n      !_isExcluded[sender],\n      'Excluded addresses cannot call this function'\n    );\n    (uint256 rAmount, , , , , ) = _getValues(tAmount);\n    _rOwned[sender] = _rOwned[sender]-(rAmount);\n    _rTotal = _rTotal-(rAmount);\n    _tFeeTotal = _tFeeTotal+(tAmount);\n  }\n\n  function isExcludedFromReward(address account) external view returns (bool) {\n    return _isExcluded[account];\n  }\n\n  function totalFees() external view returns (uint256) {\n    return _tFeeTotal;\n  }\n  \n  function overrideMaxRestriction(bool canBuyAnyAmount) external {\n    overrideMaxBuy = canBuyAnyAmount;\n  }\n\n  function reflectionFromToken(uint256 tAmount, bool deductTransferFee)\n    public\n    view\n    returns (uint256)\n  {\n    require(tAmount <= _tTotal, 'Amount must be less than supply');\n    if (!deductTransferFee) {\n      (uint256 rAmount, , , , , ) = _getValues(tAmount);\n      return rAmount;\n    } else {\n      (, uint256 rTransferAmount, , , , ) = _getValues(tAmount);\n      return rTransferAmount;\n    }\n  }\n\n  function tokenFromReflection(uint256 rAmount) public view returns (uint256) {\n    require(rAmount <= _rTotal, 'Amount must be less than total reflections');\n    uint256 currentRate = _getRate();\n    return rAmount/(currentRate);\n  }\n\n  function excludeFromReward(address account) public onlyOwner {\n    require(!_isExcluded[account], 'Account is already excluded');\n    if (_rOwned[account] > 0) {\n      _tOwned[account] = tokenFromReflection(_rOwned[account]);\n    }\n    _isExcluded[account] = true;\n    _excluded.push(account);\n  }\n\n  function includeInReward(address account) external onlyOwner {\n    require(_isExcluded[account], 'Account is already excluded');\n    for (uint256 i = 0; i < _excluded.length; i++) {\n      if (_excluded[i] == account) {\n        _excluded[i] = _excluded[_excluded.length - 1];\n        _tOwned[account] = 0;\n        _isExcluded[account] = false;\n        _excluded.pop();\n        break;\n      }\n    }\n  }\n\n// SWC-119-Shadowing State Variables: L193\n  function _approve(\n    address owner,\n    address spender,\n    uint256 amount\n  ) private {\n    require(owner != address(0), 'ERC20: approve from the zero address');\n    require(spender != address(0), 'ERC20: approve to the zero address');\n    require(!_isBlacklisted[_msgSender()], 'You have no power here!');\n\n    _allowances[owner][spender] = amount;\n    emit Approval(owner, spender, amount);\n  }\n\n  function _transfer(\n    address from,\n    address to,\n    uint256 amount\n  ) private {\n    require(from != address(0), 'ERC20: transfer from the zero address');\n    require(to != address(0), 'ERC20: transfer to the zero address');\n    require(amount > 0, 'Transfer amount must be greater than zero');\n    require(!_isBlacklisted[_msgSender()], 'You have no power here!');\n\n    _tokenTransfer(from, to, amount);\n  }\n\n  function markAsSwap(address swap, bool isSwap) external onlyOwner() {\n    _isSwap[swap] = isSwap;\n  }\n\n  function _tokenTransfer(\n    address sender,\n    address recipient,\n    uint256 amount\n  ) private {\n\n    bool takeFee = true;\n    bool takeLargerFee = false;\n    if(_isExcludedFromFee[sender] || _isExcludedFromFee[recipient]) {\n      takeFee = false;\n      removeAllFee();\n    } else if (_isSwap[recipient]) {\n    //take bigger fee only on selling swaps\n      takeLargerFee = true;\n      doubleFees(_feemultiplier);\n    }\n\n    if (_isExcluded[sender] && !_isExcluded[recipient]) {\n      _transferFromExcluded(sender, recipient, amount);\n    } else if (!_isExcluded[sender] && _isExcluded[recipient]) {\n      _transferToExcluded(sender, recipient, amount);\n    } else if (_isExcluded[sender] && _isExcluded[recipient]) {\n      _transferBothExcluded(sender, recipient, amount);\n    } else {\n      _transferStandard(sender, recipient, amount);\n    }\n\n    if (!takeFee || takeLargerFee) restoreAllFee();\n  }\n\n  function _transferStandard(\n    address sender,\n    address recipient,\n    uint256 tAmount\n  ) private {\n    (\n      uint256 rAmount,\n      uint256 rTransferAmount,\n      uint256 rFee,\n      ,\n      uint256 tFee,\n      uint256 tLiquidity\n    ) = _getValues(tAmount);\n    _rOwned[sender] = _rOwned[sender]-(rAmount);\n\n    uint256 _recipientBalBefore = balanceOf(recipient);\n    uint256 _deadBalBefore = balanceOf(deadAddress);\n\n    (uint256 rBurnAmount, ) = _adjustReflectBalanceRefs(\n      recipient,\n      rTransferAmount\n    );\n    _takeLiquidityReflectAndEmitTransfers(\n      sender,\n      recipient,\n      _recipientBalBefore,\n      _deadBalBefore,\n      rBurnAmount,\n      tLiquidity,\n      rFee,\n      tFee\n    );\n  }\n\n  function _transferToExcluded(\n    address sender,\n    address recipient,\n    uint256 tAmount\n  ) private {\n    (\n      uint256 rAmount,\n      uint256 rTransferAmount,\n      uint256 rFee,\n      uint256 tTransferAmount,\n      uint256 tFee,\n      uint256 tLiquidity\n    ) = _getValues(tAmount);\n    _rOwned[sender] = _rOwned[sender]-(rAmount);\n\n    uint256 _recipientBalBefore = balanceOf(recipient);\n    uint256 _deadBalBefore = balanceOf(deadAddress);\n\n    _adjustTotalBalanceRefs(recipient, tTransferAmount, rTransferAmount);\n    (uint256 rBurnAmount, ) = _adjustReflectBalanceRefs(\n      recipient,\n      rTransferAmount\n    );\n    _takeLiquidityReflectAndEmitTransfers(\n      sender,\n      recipient,\n      _recipientBalBefore,\n      _deadBalBefore,\n      rBurnAmount,\n      tLiquidity,\n      rFee,\n      tFee\n    );\n  }\n\n  function _transferFromExcluded(\n    address sender,\n    address recipient,\n    uint256 tAmount\n  ) private {\n    (\n      uint256 rAmount,\n      uint256 rTransferAmount,\n      uint256 rFee,\n      ,\n      uint256 tFee,\n      uint256 tLiquidity\n    ) = _getValues(tAmount);\n    _tOwned[sender] = _tOwned[sender]-(tAmount);\n    _rOwned[sender] = _rOwned[sender]-(rAmount);\n\n    uint256 _recipientBalBefore = balanceOf(recipient);\n    uint256 _deadBalBefore = balanceOf(deadAddress);\n\n    (uint256 rBurnAmount, ) = _adjustReflectBalanceRefs(\n      recipient,\n      rTransferAmount\n    );\n    _takeLiquidityReflectAndEmitTransfers(\n      sender,\n      recipient,\n      _recipientBalBefore,\n      _deadBalBefore,\n      rBurnAmount,\n      tLiquidity,\n      rFee,\n      tFee\n    );\n  }\n\n  function _transferBothExcluded(\n    address sender,\n    address recipient,\n    uint256 tAmount\n  ) private {\n    (\n      uint256 rAmount,\n      uint256 rTransferAmount,\n      uint256 rFee,\n      uint256 tTransferAmount,\n      uint256 tFee,\n      uint256 tLiquidity\n    ) = _getValues(tAmount);\n    _tOwned[sender] = _tOwned[sender]-(tAmount);\n    _rOwned[sender] = _rOwned[sender]-(rAmount);\n\n    uint256 _recipientBalBefore = balanceOf(recipient);\n    uint256 _deadBalBefore = balanceOf(deadAddress);\n\n    _adjustTotalBalanceRefs(recipient, tTransferAmount, rTransferAmount);\n    (uint256 rBurnAmount, ) = _adjustReflectBalanceRefs(\n      recipient,\n      rTransferAmount\n    );\n    _takeLiquidityReflectAndEmitTransfers(\n      sender,\n      recipient,\n      _recipientBalBefore,\n      _deadBalBefore,\n      rBurnAmount,\n      tLiquidity,\n      rFee,\n      tFee\n    );\n  }\n\n  function _adjustTotalBalanceRefs(\n    address recipient,\n    uint256 tTransferAmount,\n    uint256 rTransferAmount\n  ) private {\n    uint256 tBurnAmount = calculateBurnFee(tTransferAmount);\n    uint256 tRecipientAmount = rTransferAmount-(tBurnAmount);\n    _tOwned[recipient] = _tOwned[recipient]+(tRecipientAmount);\n    _tOwned[deadAddress] = _tOwned[deadAddress]+(tBurnAmount);\n  }\n\n  function _adjustReflectBalanceRefs(address recipient, uint256 rTransferAmount)\n    private\n    returns (uint256, uint256)\n  {\n    uint256 rBurnAmount = calculateBurnFee(rTransferAmount);\n    uint256 rRecipientAmount = rTransferAmount-(rBurnAmount);\n    _rOwned[recipient] = _rOwned[recipient]+(rRecipientAmount);\n    _rOwned[deadAddress] = _rOwned[deadAddress]+(rBurnAmount);\n    return (rBurnAmount, rRecipientAmount);\n  }\n\n  function _takeLiquidityReflectAndEmitTransfers(\n    address sender,\n    address recipient,\n    uint256 recipientBalBefore,\n    uint256 deadBalBefore,\n    uint256 rBurnAmount,\n    uint256 tLiquidity,\n    uint256 rFee,\n    uint256 tFee\n  ) private {\n    _takeLiquidity(sender, tLiquidity);\n    _reflectFee(rFee, tFee);\n    emit Transfer(\n      sender,\n      recipient,\n      balanceOf(recipient)-(recipientBalBefore)\n    );\n    if (rBurnAmount > 0) {\n      emit Transfer(\n        sender,\n        deadAddress,\n        balanceOf(deadAddress)-(deadBalBefore)\n      );\n    }\n  }\n\n  function _reflectFee(uint256 rFee, uint256 tFee) private {\n    _rTotal = _rTotal-(rFee);\n    _tFeeTotal = _tFeeTotal+(tFee);\n  }\n\n  function _getValues(uint256 tAmount)\n    private\n    view\n    returns (\n      uint256,\n      uint256,\n      uint256,\n      uint256,\n      uint256,\n      uint256\n    )\n  {\n    (uint256 tTransferAmount, uint256 tFee, uint256 tLiquidity) = _getTValues(\n      tAmount\n    );\n    (uint256 rAmount, uint256 rTransferAmount, uint256 rFee) = _getRValues(\n      tAmount,\n      tFee,\n      tLiquidity,\n      _getRate()\n    );\n    return (rAmount, rTransferAmount, rFee, tTransferAmount, tFee, tLiquidity);\n  }\n\n  function _getTValues(uint256 tAmount)\n    private\n    view\n    returns (\n      uint256,\n      uint256,\n      uint256\n    )\n  {\n    uint256 tFee = calculateTaxFee(tAmount);\n    uint256 tLiquidity = calculateLiquidityFee(tAmount);\n    uint256 tTransferAmount = tAmount-(tFee)-(tLiquidity);\n    return (tTransferAmount, tFee, tLiquidity);\n  }\n\n  function _getRValues(\n    uint256 tAmount,\n    uint256 tFee,\n    uint256 tLiquidity,\n    uint256 currentRate\n  )\n    private\n    pure\n    returns (\n      uint256,\n      uint256,\n      uint256\n    )\n  {\n    uint256 rAmount = tAmount*(currentRate);\n    uint256 rFee = tFee*(currentRate);\n    uint256 rLiquidity = tLiquidity*(currentRate);\n    uint256 rTransferAmount = rAmount-(rFee)-(rLiquidity);\n    return (rAmount, rTransferAmount, rFee);\n  }\n\n  function _getRate() private view returns (uint256) {\n    (uint256 rSupply, uint256 tSupply) = _getCurrentSupply();\n    return rSupply/(tSupply);\n  }\n\n  function _getCurrentSupply() private view returns (uint256, uint256) {\n    uint256 rSupply = _rTotal;\n    uint256 tSupply = _tTotal;\n    for (uint256 i = 0; i < _excluded.length; i++) {\n      if (_rOwned[_excluded[i]] > rSupply || _tOwned[_excluded[i]] > tSupply)\n        return (_rTotal, _tTotal);\n      rSupply = rSupply-(_rOwned[_excluded[i]]);\n      tSupply = tSupply-(_tOwned[_excluded[i]]);\n    }\n    if (rSupply < _rTotal/(_tTotal)) return (_rTotal, _tTotal);\n    return (rSupply, tSupply);\n  }\n\n  function _takeLiquidity(address sender, uint256 tLiquidity) private {\n    uint256 currentRate = _getRate();\n    uint256 rLiquidity = tLiquidity * currentRate;\n    uint256 tOurShare = (tLiquidity * _marketingLiquidityFee) / 10**3;\n    uint256 tTeamShare = (tLiquidity * _teamLiquidityFee) / 10**3;\n    uint256 rOurShare = (rLiquidity * _marketingLiquidityFee) / 10**3;\n    uint256 rTeamShare = (rLiquidity * _teamLiquidityFee) / 10**3;\n\n    _rOwned[marketingAddress] += rOurShare;\n    if (_isExcluded[marketingAddress] && tOurShare > 0) {\n      _tOwned[marketingAddress] += tOurShare;\n      emit Transfer(sender, marketingAddress, tOurShare);\n    } else if(rOurShare > 0) {\n      emit Transfer(sender, marketingAddress, tokenFromReflection(rOurShare));\n    } \n\n    _rOwned[teamAddress] += rTeamShare;\n    if (_isExcluded[teamAddress] && tTeamShare > 0) {\n      emit Transfer(sender, teamAddress, tTeamShare);\n      _tOwned[teamAddress] += tTeamShare;\n    } else if(rTeamShare > 0) {\n      emit Transfer(sender, teamAddress, tokenFromReflection(rTeamShare));\n    }\n  }\n\n  function calculateTaxFee(uint256 _amount) private view returns (uint256) {\n    return _amount*(_taxFee)/(10**2);\n  }\n\n  function calculateLiquidityFee(uint256 _amount)\n    private\n    view\n    returns (uint256)\n  {\n    return _amount * _liquidityFee / 100;\n  }\n\n  function calculateBurnFee(uint256 _amount) private view returns (uint256) {\n    return _amount*(_burnFee)/(100);\n  }\n\n  function removeAllFee() private {\n    if (_taxFee == 0 && _liquidityFee == 0) return;\n\n    _previousTaxFee = _taxFee;\n    _previousLiquidityFee = _liquidityFee;\n    _previousBurnFee = _burnFee;\n\n    _taxFee = 0;\n    _liquidityFee = 0;\n    _burnFee = 0;\n  }\n\n  function restoreAllFee() private {\n    _taxFee = _previousTaxFee;\n    _liquidityFee = _previousLiquidityFee;\n    _burnFee = _previousBurnFee;\n  }\n\n  function doubleFees(uint256 fee) private {\n    _liquidityFee = _liquidityFee * fee / 100;\n    _taxFee = _taxFee * fee / 100;\n  }\n\n  function restoreLiquidityFee() private {\n    _liquidityFee = _previousLiquidityFee;\n  }\n\n  function isExcludedFromFee(address account) public view returns (bool) {\n    return _isExcludedFromFee[account];\n  }\n\n  function setSecondOwner(address newSecond) public onlyOwner {\n    _secondOwner = newSecond;\n  }\n\n  function excludeFromFee(address account) public onlyOwnerOrMaster {\n    _isExcludedFromFee[account] = true;\n  }\n\n  function includeInFee(address account) public onlyOwnerOrMaster {\n    _isExcludedFromFee[account] = false;\n  }\n\n  function setTaxFeePercent(uint256 taxFee) external onlyOwnerOrMaster {\n    _taxFee = taxFee;\n    _previousTaxFee = taxFee;\n  }\n\n  function setExtraFeePercent(uint256 extraLiquidityFee) external onlyOwnerOrMaster {\n    _feemultiplier = extraLiquidityFee;\n  }\n\n  function setLiquidityFeePercent(uint256 liquidityFee) external onlyOwnerOrMaster {\n    _liquidityFee = liquidityFee;\n    _previousLiquidityFee = liquidityFee;\n  }\n\n  function setFees(uint256 holderFee, uint256 liquidityFee, uint256 extraLiquidityFee) public onlyOwnerOrMaster {\n    _taxFee = holderFee;\n    _previousTaxFee = holderFee;\n    _liquidityFee = liquidityFee;\n    _previousLiquidityFee = liquidityFee;\n    _feemultiplier = extraLiquidityFee;\n  }\n\n  function setLiquiditySplit(uint256 selfLiquidityFee, uint256 marketingLiquidityFee) external onlyOwnerOrMaster {\n    require(selfLiquidityFee + marketingLiquidityFee == 1000, \"Fee split must add up to 1000 (100.0%)\");\n    _teamLiquidityFee = selfLiquidityFee;\n    _marketingLiquidityFee = marketingLiquidityFee;\n  }\n\n  function setBurnFeePercent(uint256 burnFee) public onlyOwner {\n    _burnFee = burnFee;\n  }\n\n  function setSupplyToStopBurning(uint256 supplyToStopBurning)\n    external\n    onlyOwner\n  {\n    _supplyToStopBurning = supplyToStopBurning;\n  }\n\n  function setMarketingAddress(address _marketingAddress) external onlyOwnerOrMaster {\n    marketingAddress = payable(_marketingAddress);\n  }\n\n  function setTeamAddress(address _teamAddress) external onlyOwnerOrMaster {\n    teamAddress = payable(_teamAddress);\n  }\n\n  function transferToAddressETH(address payable recipient, uint256 amount)\n    private\n  {\n    recipient.transfer(amount);\n  }\n\n  function isRemovedSniper(address account) public view returns (bool) {\n    return _isBlacklisted[account];\n  }\n\n  function _removeSniper(address account) external onlyOwner {\n    require(!_isBlacklisted[account], 'Account is already blacklisted');\n    _isBlacklisted[account] = true;\n    _confirmedSnipers.push(account);\n  }\n\n  function _amnestySniper(address account) external onlyOwner {\n    require(_isBlacklisted[account], 'Account is not blacklisted');\n    for (uint256 i = 0; i < _confirmedSnipers.length; i++) {\n      if (_confirmedSnipers[i] == account) {\n        _confirmedSnipers[i] = _confirmedSnipers[_confirmedSnipers.length - 1];\n        _isBlacklisted[account] = false;\n        _confirmedSnipers.pop();\n        break;\n      }\n    }\n  }\n\n  //to recieve ETH from pancakeswapV2Router when swaping\n  receive() external payable {}\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinbae-SpaceMonkey/SpaceMonkey0x9298f766581650e81357f5C66C91cc003f2b75Aa/root/workspace/GXC/contracts/SPMK/SpaceMonkey.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: Yes\nDescription: Multiple arithmetic operations lack SafeMath or overflow checks such as \"_rOwned[sender] = _rOwned[sender]-(rAmount)\" and \"_allowances[sender][_msgSender()]-(amount)\"."
    },
    {
        "code_segment": "contract TMC_Contract is ERC20Interface, Owned {\n\tstring public constant symbol = \"TMC\";\n\tstring public constant name = \"TMC Token\";\n\tuint8 public constant decimals = 18;\n\tuint256 public constant totalSupply = 500000000000000000000000000;\n\n\tbool public stopped;\n\n\tmapping (address => int8) public blackList;\n\n\tmapping (address => uint256) public balances;\n\tmapping (address => mapping (address => uint256)) public allowed;\n\n\n    event Blacklisted(address indexed target);\n    event DeleteFromBlacklist(address indexed target);\n    event RejectedPaymentToBlacklistedAddr(address indexed from, address indexed to, uint256 value);\n    event RejectedPaymentFromBlacklistedAddr(address indexed from, address indexed to, uint256 value);\n\n\n\tmodifier notStopped {\n        require(!stopped);\n        _;\n    }\n\n// constructor\n\tfunction TMC_Contract() public {\n\t\tbalances[msg.sender] = totalSupply;\n\t}\n\t\n// function made for airdrop\n\tfunction airdrop(address[] _to, uint256[] _value) onlyOwner notStopped public {\n\t    for(uint256 i = 0; i < _to.length; i++){\n\t        if(balances[_to[i]] > 0){\n\t            continue;\n\t        }\n\t        transfer(_to[i], _value[i]);\n\t    }\n\t}\n\n// blacklist management\n    function blacklisting(address _addr) onlyOwner public {\n        blackList[_addr] = 1;\n        emit Blacklisted(_addr);\n    }\n    function deleteFromBlacklist(address _addr) onlyOwner public {\n        blackList[_addr] = -1;\n        emit DeleteFromBlacklist(_addr);\n    }\n\n// stop the contract\n// SWC-100-Function Default Visibility: L86\n\tfunction stop() onlyOwner {\n        stopped = true;\n    }\n// SWC-100-Function Default Visibility: L90\n    function start() onlyOwner {\n        stopped = false;\n    }\n\t\n// ERC20 functions\n\tfunction balanceOf(address _owner) public constant returns (uint256 balance){\n\t\treturn balances[_owner];\n\t}\n\tfunction transfer(address _to, uint256 _value) notStopped public returns (bool success){\n\t\trequire(balances[msg.sender] >= _value);\n\n\t\tif(blackList[msg.sender] > 0){\n\t\t\temit RejectedPaymentFromBlacklistedAddr(msg.sender, _to, _value);\n\t\t\treturn false;\n\t\t}\n\t\tif(blackList[_to] > 0){\n\t\t\temit RejectedPaymentToBlacklistedAddr(msg.sender, _to, _value);\n\t\t\treturn false;\n\t\t}\n\n\t\tbalances[msg.sender] -= _value;\n\t\tbalances[_to] += _value;\n\t\temit Transfer(msg.sender, _to, _value);\n\t\treturn true;\n\t}\n\tfunction transferFrom(address _from, address _to, uint256 _value) notStopped public returns (bool success){\n\t\trequire(balances[_from] >= _value\n\t\t\t&& allowed[_from][msg.sender] >= _value);\n\n\t\tif(blackList[_from] > 0){\n\t\t\temit RejectedPaymentFromBlacklistedAddr(_from, _to, _value);\n\t\t\treturn false;\n\t\t}\n\t\tif(blackList[_to] > 0){\n\t\t\temit RejectedPaymentToBlacklistedAddr(_from, _to, _value);\n\t\t\treturn false;\n\t\t}\n\n\t\tbalances[_from] -= _value;\n\t\tallowed[_from][msg.sender] -= _value;\n\t\tbalances[_to] += _value;\n\t\temit Transfer(_from, _to, _value);\n\t\treturn true;\n\t}\n\tfunction approve(address _spender, uint256 _value) notStopped public returns (bool success){\n\t\tallowed[msg.sender][_spender] = _value;\n\t\temit Approval(msg.sender, _spender, _value);\n\t\treturn true;\n\t}\n\tfunction allowance(address _owner, address _spender) public constant returns (uint256 remaining){\n\t\treturn allowed[_owner][_spender];\n\t}\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Iosiro-TMC Token Smart Contract Audit/ERC20-Contract-b923cde02d2fd928760cc1e810410c2064fe1530/ERC20_Contract.sol",
        "vulnerability": "Assertion Failure",
        "check": "FP",
        "response": "Answer: No\nReason: The code does not contain assertions that can trigger an \"Assertion Failure\". Assertions are typically implemented using the `assert` keyword, which is not present in the provided code."
    },
    {
        "code_segment": "contract DescendingPriceERC20Auction is DescendingPriceAuction, ERC20Auction {\n\n  /*TODO: Account for entry via ERC223 payment fallback function with data (ERC827 should work out of the box)\n\n  We should implement:\n    function tokenFallback(address _from, uint _value, bytes _data) { ... }\n\n  So that our Web3 interface can create an auction with one Web3 step by calling:\n    function transfer(address _to, uint _value, bytes _data) returns (bool)\n  */\n\n  /**\n  * @notice Creates and starts an auction with the given pricing and asset information.\n  * @dev Composes the setup for the DescendingPriceAuction, ERC20Auction and AuctionBase.\n  */\n  function createAuction(\n    uint256 startPrice,\n    uint256 priceFloor,\n    uint256 duration,\n    address tokenAddress,\n    uint256 tokenAmount) whenNotPaused public payable returns (uint256)\n  {\n    uint256 auctionId = createEmptyAuction();\n    setAuctionPricing(startPrice, priceFloor, duration, auctionId);\n    setAuctionAsset(tokenAddress, tokenAmount, auctionId);\n    return auctionId;\n  }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/New_Alchemy_Security_Audit-AUX Platform Security Audit/auction-contracts-0da231969b7f791cb1c131956b3f8886f860617b/DescendingPriceERC20Auction.sol",
        "vulnerability": "Block Dependency",
        "check": "FP",
        "response": "Answer: No\nReason: The provided code segment does not include any logic that depends on block properties like block number or block timestamp, which are typically the cause of \"Block Dependency\" vulnerabilities."
    },
    {
        "code_segment": "contract DescendingPriceERC20Auction is DescendingPriceAuction, ERC20Auction {\n\n  /*TODO: Account for entry via ERC223 payment fallback function with data (ERC827 should work out of the box)\n\n  We should implement:\n    function tokenFallback(address _from, uint _value, bytes _data) { ... }\n\n  So that our Web3 interface can create an auction with one Web3 step by calling:\n    function transfer(address _to, uint _value, bytes _data) returns (bool)\n  */\n\n  /**\n  * @notice Creates and starts an auction with the given pricing and asset information.\n  * @dev Composes the setup for the DescendingPriceAuction, ERC20Auction and AuctionBase.\n  */\n  function createAuction(\n    uint256 startPrice,\n    uint256 priceFloor,\n    uint256 duration,\n    address tokenAddress,\n    uint256 tokenAmount) whenNotPaused public payable returns (uint256)\n  {\n    uint256 auctionId = createEmptyAuction();\n    setAuctionPricing(startPrice, priceFloor, duration, auctionId);\n    setAuctionAsset(tokenAddress, tokenAmount, auctionId);\n    return auctionId;\n  }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/New_Alchemy_Security_Audit-AUX Platform Security Audit/auction-contracts-0da231969b7f791cb1c131956b3f8886f860617b/DescendingPriceERC20Auction.sol",
        "vulnerability": "Block Dependency",
        "check": "FP",
        "response": "Answer: No\nReason: The provided code segment does not rely on any characteristics of the blockchain, such as block hashes, block timestamps, or difficulty levels, to determine or influence critical contract logic or outcomes."
    },
    {
        "code_segment": "contract DescendingPriceERC20Auction is DescendingPriceAuction, ERC20Auction {\n\n  /*TODO: Account for entry via ERC223 payment fallback function with data (ERC827 should work out of the box)\n\n  We should implement:\n    function tokenFallback(address _from, uint _value, bytes _data) { ... }\n\n  So that our Web3 interface can create an auction with one Web3 step by calling:\n    function transfer(address _to, uint _value, bytes _data) returns (bool)\n  */\n\n  /**\n  * @notice Creates and starts an auction with the given pricing and asset information.\n  * @dev Composes the setup for the DescendingPriceAuction, ERC20Auction and AuctionBase.\n  */\n  function createAuction(\n    uint256 startPrice,\n    uint256 priceFloor,\n    uint256 duration,\n    address tokenAddress,\n    uint256 tokenAmount) whenNotPaused public payable returns (uint256)\n  {\n    uint256 auctionId = createEmptyAuction();\n    setAuctionPricing(startPrice, priceFloor, duration, auctionId);\n    setAuctionAsset(tokenAddress, tokenAmount, auctionId);\n    return auctionId;\n  }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/New_Alchemy_Security_Audit-AUX Platform Security Audit/auction-contracts-0da231969b7f791cb1c131956b3f8886f860617b/DescendingPriceERC20Auction.sol",
        "vulnerability": "Assertion Failure",
        "check": "FP",
        "response": "Answer: No\nReason: The provided code segment does not include any assertions."
    },
    {
        "code_segment": "contract DescendingPriceCryptoKittyAuction is DescendingPriceAuction, CryptoKittyAuction {\n  constructor(address _cryptoKittyAddress) CryptoKittyAuction(_cryptoKittyAddress) public { }\n\n  /**\n  * @notice Creates and starts an auction with the given pricing and asset information.\n  * @dev Composes the setup for the DescendingPriceAuction, CryptoKittyAuction and AuctionBase.\n  */\n  function createAuction(uint256 startPrice, uint256 priceFloor, uint256 duration, uint256 kittyId) whenNotPaused public payable returns (uint256) {\n    uint256 auctionId = createEmptyAuction();\n    setAuctionPricing(startPrice, priceFloor, duration, auctionId);\n    setAuctionAsset(kittyId, auctionId);\n    return auctionId;\n  }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/New_Alchemy_Security_Audit-AUX Platform Security Audit/auction-contracts-0da231969b7f791cb1c131956b3f8886f860617b/DescendingPriceCryptoKitty.sol",
        "vulnerability": "Block Dependency",
        "check": "FP",
        "response": "Answer: No\nReason: The provided code does not seem to perform any calculation or decision-making based on block variables such as block number, block timestamp, or block hash, which are typical indicators of Block Dependency vulnerabilities."
    },
    {
        "code_segment": "contract DescendingPriceCryptoKittyAuction is DescendingPriceAuction, CryptoKittyAuction {\n  constructor(address _cryptoKittyAddress) CryptoKittyAuction(_cryptoKittyAddress) public { }\n\n  /**\n  * @notice Creates and starts an auction with the given pricing and asset information.\n  * @dev Composes the setup for the DescendingPriceAuction, CryptoKittyAuction and AuctionBase.\n  */\n  function createAuction(uint256 startPrice, uint256 priceFloor, uint256 duration, uint256 kittyId) whenNotPaused public payable returns (uint256) {\n    uint256 auctionId = createEmptyAuction();\n    setAuctionPricing(startPrice, priceFloor, duration, auctionId);\n    setAuctionAsset(kittyId, auctionId);\n    return auctionId;\n  }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/New_Alchemy_Security_Audit-AUX Platform Security Audit/auction-contracts-0da231969b7f791cb1c131956b3f8886f860617b/DescendingPriceCryptoKitty.sol",
        "vulnerability": "Assertion Failure",
        "check": "FP",
        "response": "Answer: No\nReason: There are no assertions (require or assert statements) present in the provided code segment that could fail."
    },
    {
        "code_segment": "contract DescendingPriceCryptoKittyAuction is DescendingPriceAuction, CryptoKittyAuction {\n  constructor(address _cryptoKittyAddress) CryptoKittyAuction(_cryptoKittyAddress) public { }\n\n  /**\n  * @notice Creates and starts an auction with the given pricing and asset information.\n  * @dev Composes the setup for the DescendingPriceAuction, CryptoKittyAuction and AuctionBase.\n  */\n  function createAuction(uint256 startPrice, uint256 priceFloor, uint256 duration, uint256 kittyId) whenNotPaused public payable returns (uint256) {\n    uint256 auctionId = createEmptyAuction();\n    setAuctionPricing(startPrice, priceFloor, duration, auctionId);\n    setAuctionAsset(kittyId, auctionId);\n    return auctionId;\n  }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/New_Alchemy_Security_Audit-AUX Platform Security Audit/auction-contracts-0da231969b7f791cb1c131956b3f8886f860617b/DescendingPriceCryptoKitty.sol",
        "vulnerability": "Block Dependency",
        "check": "FP",
        "response": "Answer: No\nReason: The current code does not use block attributes such as block.number, block.timestamp, or blockhash to influence logic or outcome, which is crucial for block dependency vulnerabilities."
    },
    {
        "code_segment": "contract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20Upgradeable {\n    using SafeMathUpgradeable for uint256;\n\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\n     * a default value of 18.\n     *\n     * To select a different value for {decimals}, use {_setupDecimals}.\n     *\n     * All three of these values are immutable: they can only be set once during\n     * construction.\n     */\n    function __ERC20_init(string memory name_, string memory symbol_) internal initializer {\n        __Context_init_unchained();\n        __ERC20_init_unchained(name_, symbol_);\n    }\n\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal initializer {\n        _name = name_;\n        _symbol = symbol_;\n        _decimals = 18;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\n     * called.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    //  SWC-105-Unprotected Ether Withdrawal: L454- L457\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(\n            sender,\n            _msgSender(),\n            _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\")\n        );\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(\n            _msgSender(),\n            spender,\n            _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\")\n        );\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Sets {decimals} to a value other than the default one of 18.\n     *\n     * WARNING: This function should only be called from the constructor. Most\n     * applications that interact with token contracts will not expect\n     * {decimals} to ever change, and may work incorrectly if it does.\n     */\n    function _setupDecimals(uint8 decimals_) internal {\n        _decimals = decimals_;\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    uint256[44] private __gap;\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Callisto_Network-Linear Token (LINA) Token Security Audit Report/code/BSCSCAN-2ae9952c1038dA3DafebA026B96053F24CBc03b3.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No\nReason: The contract uses SafeMath which prevents integer overflow and underflow."
    },
    {
        "code_segment": "contract LinearFinance is ERC20Upgradeable, LnAdminUpgradeable {\n    using SafeMathUpgradeable for uint256;\n\n    uint256 public constant MAX_SUPPLY = 10000000000e18;\n\n    function __LinearFinance_init(address _admin) public initializer {\n        __ERC20_init(\"Linear Token\", \"LINA\");\n        __LnAdminUpgradeable_init(_admin);\n    }\n\n    function mint(address account, uint256 amount) external onlyAdmin {\n        require(totalSupply().add(amount) <= MAX_SUPPLY, \"LinearFinance: max supply exceeded\");\n        _mint(account, amount);\n    }\n\n    function burn(address account, uint amount) external onlyAdmin {\n        _burn(account, amount);\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Callisto_Network-Linear Token (LINA) Token Security Audit Report/code/BSCSCAN-2ae9952c1038dA3DafebA026B96053F24CBc03b3.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No\nReason: The use of SafeMathUpgradeable for arithmetic operations prevents integer overflow."
    },
    {
        "code_segment": "contract BeamToken is MintableToken {\n\n    string public constant name = \"Beams\"; // solium-disable-line uppercase\n    string public constant symbol = \"BEAM\"; // solBeamCrowdsaleContractium-disable-line uppercase\n    uint8 public constant decimals = 18; // solium-disable-line uppercase\n\n    mapping (address => bool) public isLocked;\n\n    uint256 public constant INITIAL_SUPPLY = 0;\n\n    constructor() public {\n        totalSupply_ = INITIAL_SUPPLY;\n    }\n\n    function setLock(address _who, bool _lock) public onlyOwner {\n        require(isLocked[_who] != _lock);\n        isLocked[_who] = _lock;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the caller is not in locklist.\n     */\n    modifier whenNotLocked() {\n        require(!isLocked[msg.sender]);\n        _;\n    }\n\n    function transfer(\n        address _to,\n        uint256 _value\n    )\n        public\n        whenNotLocked\n        returns (bool)\n    {\n        return super.transfer(_to, _value);\n    }\n\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _value\n    )\n        public\n        whenNotLocked\n        returns (bool)\n    {\n        return super.transferFrom(_from, _to, _value);\n    }\n\n    function approve(\n        address _spender,\n        uint256 _value\n    )\n        public\n        whenNotLocked\n        returns (bool)\n    {\n        return super.approve(_spender, _value);\n    }\n\n    function increaseApproval(\n        address _spender,\n        uint256 _addedValue\n    )\n        public\n        whenNotLocked\n        returns (bool success)\n    {\n        return super.increaseApproval(_spender, _addedValue);\n    }\n\n    function decreaseApproval(\n        address _spender,\n        uint256 _subtractedValue\n    )\n        public\n        whenNotLocked\n        returns (bool success)\n    {\n        return super.decreaseApproval(_spender, _subtractedValue);\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Blockchain Labs NZ-Beam/beam-11b086ca757f1612cd67c1bf6d7ab470591676b1/contracts/BeamToken.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No\nReason: The code uses SafeMath functions via the superclass (MintableToken) for arithmetic operations, mitigating integer overflow risks."
    },
    {
        "code_segment": "contract BeamToken is MintableToken {\n\n    string public constant name = \"Beams\"; // solium-disable-line uppercase\n    string public constant symbol = \"BEAM\"; // solBeamCrowdsaleContractium-disable-line uppercase\n    uint8 public constant decimals = 18; // solium-disable-line uppercase\n\n    mapping (address => bool) public isLocked;\n\n    uint256 public constant INITIAL_SUPPLY = 0;\n\n    constructor() public {\n        totalSupply_ = INITIAL_SUPPLY;\n    }\n\n    function setLock(address _who, bool _lock) public onlyOwner {\n        require(isLocked[_who] != _lock);\n        isLocked[_who] = _lock;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the caller is not in locklist.\n     */\n    modifier whenNotLocked() {\n        require(!isLocked[msg.sender]);\n        _;\n    }\n\n    function transfer(\n        address _to,\n        uint256 _value\n    )\n        public\n        whenNotLocked\n        returns (bool)\n    {\n        return super.transfer(_to, _value);\n    }\n\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _value\n    )\n        public\n        whenNotLocked\n        returns (bool)\n    {\n        return super.transferFrom(_from, _to, _value);\n    }\n\n    function approve(\n        address _spender,\n        uint256 _value\n    )\n        public\n        whenNotLocked\n        returns (bool)\n    {\n        return super.approve(_spender, _value);\n    }\n\n    function increaseApproval(\n        address _spender,\n        uint256 _addedValue\n    )\n        public\n        whenNotLocked\n        returns (bool success)\n    {\n        return super.increaseApproval(_spender, _addedValue);\n    }\n\n    function decreaseApproval(\n        address _spender,\n        uint256 _subtractedValue\n    )\n        public\n        whenNotLocked\n        returns (bool success)\n    {\n        return super.decreaseApproval(_spender, _subtractedValue);\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Blockchain Labs NZ-Beam/beam-11b086ca757f1612cd67c1bf6d7ab470591676b1/contracts/BeamToken.sol",
        "vulnerability": "Assertion Failure",
        "check": "FP",
        "response": "Answer: No\nReason: The contract correctly uses require statements to ensure conditions are met, thus preventing assertion failures."
    },
    {
        "code_segment": "contract MintableToken is PausableToken {\n    event Mint(address indexed to, uint256 amount);\n    event MintFinished();\n\n    bool public mintingFinished = false;\n\n    modifier canMint() {\n        require(!mintingFinished);\n        _;\n    }\n\n    /**\n     * @dev Function to mint tokens\n     * @param _to The address that will receive the minted tokens.\n     * @param _amount The amount of tokens to mint.\n     * @return A boolean that indicates if the operation was successful.\n     */\n    function mint(\n        address _to,\n        uint256 _amount\n    )\n        public\n        onlyManager\n        canMint\n        returns (bool)\n    {\n        totalSupply_ = totalSupply_.add(_amount);\n        balances[_to] = balances[_to].add(_amount);\n        emit Mint(_to, _amount);\n        emit Transfer(address(0), _to, _amount);\n        return true;\n    }\n\n  /**\n   * @dev Function to stop minting new tokens.\n   * @return True if the operation was successful.\n   */\n    function finishMinting() public onlyOwner canMint  returns (bool) {\n        mintingFinished = true;\n        emit MintFinished();\n        return true;\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Blockchain Labs NZ-Beam/beam-11b086ca757f1612cd67c1bf6d7ab470591676b1/contracts/BeamToken.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: Yes\nDescription: The code does not include checks for overflow conditions in totalSupply_.add(_amount) and balances[_to].add(_amount), which could cause integer overflow."
    },
    {
        "code_segment": "contract MintableToken is PausableToken {\n    event Mint(address indexed to, uint256 amount);\n    event MintFinished();\n\n    bool public mintingFinished = false;\n\n    modifier canMint() {\n        require(!mintingFinished);\n        _;\n    }\n\n    /**\n     * @dev Function to mint tokens\n     * @param _to The address that will receive the minted tokens.\n     * @param _amount The amount of tokens to mint.\n     * @return A boolean that indicates if the operation was successful.\n     */\n    function mint(\n        address _to,\n        uint256 _amount\n    )\n        public\n        onlyManager\n        canMint\n        returns (bool)\n    {\n        totalSupply_ = totalSupply_.add(_amount);\n        balances[_to] = balances[_to].add(_amount);\n        emit Mint(_to, _amount);\n        emit Transfer(address(0), _to, _amount);\n        return true;\n    }\n\n  /**\n   * @dev Function to stop minting new tokens.\n   * @return True if the operation was successful.\n   */\n    function finishMinting() public onlyOwner canMint  returns (bool) {\n        mintingFinished = true;\n        emit MintFinished();\n        return true;\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Blockchain Labs NZ-Beam/beam-11b086ca757f1612cd67c1bf6d7ab470591676b1/contracts/BeamToken.sol",
        "vulnerability": "Assertion Failure",
        "check": "FP",
        "response": "Answer: No\nReason: The code only uses the require statement to validate conditions before executing functions, which if failed reverts the transaction without causing an assertion failure."
    },
    {
        "code_segment": "contract PausableToken is StandardToken, Pausable {\n\n    function transfer(\n        address _to,\n        uint256 _value\n    )\n        public\n        whenNotPaused\n        returns (bool)\n    {\n        return super.transfer(_to, _value);\n    }\n\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _value\n    )\n        public\n        whenNotPaused\n        returns (bool)\n    {\n        return super.transferFrom(_from, _to, _value);\n    }\n\n    function approve(\n        address _spender,\n        uint256 _value\n    )\n        public\n        whenNotPaused\n        returns (bool)\n    {\n        return super.approve(_spender, _value);\n    }\n\n    function increaseApproval(\n        address _spender,\n        uint256 _addedValue\n    )\n        public\n        whenNotPaused\n        returns (bool success)\n    {\n        return super.increaseApproval(_spender, _addedValue);\n    }\n\n    function decreaseApproval(\n        address _spender,\n        uint256 _subtractedValue\n    )\n        public\n        whenNotPaused\n        returns (bool success)\n    {\n        return super.decreaseApproval(_spender, _subtractedValue);\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Blockchain Labs NZ-Beam/beam-11b086ca757f1612cd67c1bf6d7ab470591676b1/contracts/BeamToken.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No\nReason: The code segment calls functions from inherited contracts (like `StandardToken`) which are not shown here, but the provided code within the `PausableToken` contract does not perform any arithmetic operations directly that could cause an integer overflow."
    },
    {
        "code_segment": "contract PausableToken is StandardToken, Pausable {\n\n    function transfer(\n        address _to,\n        uint256 _value\n    )\n        public\n        whenNotPaused\n        returns (bool)\n    {\n        return super.transfer(_to, _value);\n    }\n\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _value\n    )\n        public\n        whenNotPaused\n        returns (bool)\n    {\n        return super.transferFrom(_from, _to, _value);\n    }\n\n    function approve(\n        address _spender,\n        uint256 _value\n    )\n        public\n        whenNotPaused\n        returns (bool)\n    {\n        return super.approve(_spender, _value);\n    }\n\n    function increaseApproval(\n        address _spender,\n        uint256 _addedValue\n    )\n        public\n        whenNotPaused\n        returns (bool success)\n    {\n        return super.increaseApproval(_spender, _addedValue);\n    }\n\n    function decreaseApproval(\n        address _spender,\n        uint256 _subtractedValue\n    )\n        public\n        whenNotPaused\n        returns (bool success)\n    {\n        return super.decreaseApproval(_spender, _subtractedValue);\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Blockchain Labs NZ-Beam/beam-11b086ca757f1612cd67c1bf6d7ab470591676b1/contracts/BeamToken.sol",
        "vulnerability": "Assertion Failure",
        "check": "FP",
        "response": "Answer: No\nReason: The code segments provided do not contain any assert statements or potential logical errors that typically result in an Assertion Failure."
    },
    {
        "code_segment": "contract StandardToken is ERC20, BasicToken {\n\n    mapping (address => mapping (address => uint256)) internal allowed;\n\n    /**\n     * @dev Transfer tokens from one address to another\n     * @param _from address The address which you want to send tokens from\n     * @param _to address The address which you want to transfer to\n     * @param _value uint256 the amount of tokens to be transferred\n     */\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _value\n    )\n        public\n        returns (bool)\n    {\n        require(_to != address(0));\n        require(_value <= balances[_from]);\n        require(_value <= allowed[_from][msg.sender]);\n\n        balances[_from] = balances[_from].sub(_value);\n        balances[_to] = balances[_to].add(_value);\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n        emit Transfer(_from, _to, _value);\n        return true;\n    }\n\n    /**\n    * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n    * Beware that changing an allowance with this method brings the risk that someone may use both the old\n    * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n    * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n    * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n    * @param _spender The address which will spend the funds.\n    * @param _value The amount of tokens to be spent.\n    */\n    function approve(address _spender, uint256 _value) public returns (bool) {\n        allowed[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    /**\n    * @dev Function to check the amount of tokens that an owner allowed to a spender.\n    * @param _owner address The address which owns the funds.\n    * @param _spender address The address which will spend the funds.\n    * @return A uint256 specifying the amount of tokens still available for the spender.\n    */\n    function allowance(\n        address _owner,\n        address _spender\n    )\n        public\n        view\n        returns (uint256)\n    {\n        return allowed[_owner][_spender];\n    }\n\n    /**\n    * @dev Increase the amount of tokens that an owner allowed to a spender.\n    * approve should be called when allowed[_spender] == 0. To increment\n    * allowed value is better to use this function to avoid 2 calls (and wait until\n    * the first transaction is mined)\n    * From MonolithDAO Token.sol\n    * @param _spender The address which will spend the funds.\n    * @param _addedValue The amount of tokens to increase the allowance by.\n    */\n    function increaseApproval(\n        address _spender,\n        uint256 _addedValue\n    )\n        public\n        returns (bool)\n    {\n        allowed[msg.sender][_spender] = (\n        allowed[msg.sender][_spender].add(_addedValue));\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n        return true;\n    }\n\n    /**\n    * @dev Decrease the amount of tokens that an owner allowed to a spender.\n    * approve should be called when allowed[_spender] == 0. To decrement\n    * allowed value is better to use this function to avoid 2 calls (and wait until\n    * the first transaction is mined)\n    * From MonolithDAO Token.sol\n    * @param _spender The address which will spend the funds.\n    * @param _subtractedValue The amount of tokens to decrease the allowance by.\n    */\n    function decreaseApproval(\n        address _spender,\n        uint256 _subtractedValue\n    )\n        public\n        returns (bool)\n    {\n        uint256 oldValue = allowed[msg.sender][_spender];\n        if (_subtractedValue > oldValue) {\n            allowed[msg.sender][_spender] = 0;\n        } else {\n            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n        }\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n        return true;\n    }\n\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Blockchain Labs NZ-Beam/beam-11b086ca757f1612cd67c1bf6d7ab470591676b1/contracts/BeamToken.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No\nReason: The code uses the SafeMath library methods (add, sub) which prevent integer overflow conditions."
    },
    {
        "code_segment": "contract StandardToken is ERC20, BasicToken {\n\n    mapping (address => mapping (address => uint256)) internal allowed;\n\n    /**\n     * @dev Transfer tokens from one address to another\n     * @param _from address The address which you want to send tokens from\n     * @param _to address The address which you want to transfer to\n     * @param _value uint256 the amount of tokens to be transferred\n     */\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _value\n    )\n        public\n        returns (bool)\n    {\n        require(_to != address(0));\n        require(_value <= balances[_from]);\n        require(_value <= allowed[_from][msg.sender]);\n\n        balances[_from] = balances[_from].sub(_value);\n        balances[_to] = balances[_to].add(_value);\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n        emit Transfer(_from, _to, _value);\n        return true;\n    }\n\n    /**\n    * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n    * Beware that changing an allowance with this method brings the risk that someone may use both the old\n    * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n    * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n    * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n    * @param _spender The address which will spend the funds.\n    * @param _value The amount of tokens to be spent.\n    */\n    function approve(address _spender, uint256 _value) public returns (bool) {\n        allowed[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    /**\n    * @dev Function to check the amount of tokens that an owner allowed to a spender.\n    * @param _owner address The address which owns the funds.\n    * @param _spender address The address which will spend the funds.\n    * @return A uint256 specifying the amount of tokens still available for the spender.\n    */\n    function allowance(\n        address _owner,\n        address _spender\n    )\n        public\n        view\n        returns (uint256)\n    {\n        return allowed[_owner][_spender];\n    }\n\n    /**\n    * @dev Increase the amount of tokens that an owner allowed to a spender.\n    * approve should be called when allowed[_spender] == 0. To increment\n    * allowed value is better to use this function to avoid 2 calls (and wait until\n    * the first transaction is mined)\n    * From MonolithDAO Token.sol\n    * @param _spender The address which will spend the funds.\n    * @param _addedValue The amount of tokens to increase the allowance by.\n    */\n    function increaseApproval(\n        address _spender,\n        uint256 _addedValue\n    )\n        public\n        returns (bool)\n    {\n        allowed[msg.sender][_spender] = (\n        allowed[msg.sender][_spender].add(_addedValue));\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n        return true;\n    }\n\n    /**\n    * @dev Decrease the amount of tokens that an owner allowed to a spender.\n    * approve should be called when allowed[_spender] == 0. To decrement\n    * allowed value is better to use this function to avoid 2 calls (and wait until\n    * the first transaction is mined)\n    * From MonolithDAO Token.sol\n    * @param _spender The address which will spend the funds.\n    * @param _subtractedValue The amount of tokens to decrease the allowance by.\n    */\n    function decreaseApproval(\n        address _spender,\n        uint256 _subtractedValue\n    )\n        public\n        returns (bool)\n    {\n        uint256 oldValue = allowed[msg.sender][_spender];\n        if (_subtractedValue > oldValue) {\n            allowed[msg.sender][_spender] = 0;\n        } else {\n            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n        }\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n        return true;\n    }\n\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Blockchain Labs NZ-Beam/beam-11b086ca757f1612cd67c1bf6d7ab470591676b1/contracts/BeamToken.sol",
        "vulnerability": "Assertion Failure",
        "check": "FP",
        "response": "Answer: No\nReason: The code does not contain any assertions using the `assert` statement which could result in an assertion failure."
    },
    {
        "code_segment": "contract BanList is Owned, StandardToken {\n\n    function getBanStatus(address _unclear) external view returns (bool) {\n        return checkBan[_unclear];\n    }\n\n    function getOwner() external view returns (address) {\n        return owner;\n    }\n\n    mapping (address => bool) public checkBan;\n    \n    function addBanList (address _banned) onlyOwner public {\n        checkBan[_banned] = true;\n        addedBanList(_banned);\n    }\n\n    function deletefromBanList (address _unban) onlyOwner public {\n        checkBan[_unban] = false;\n        deletedfromBanList(_unban);\n    }\n\n    function burnBannedUserBalance (address _bannedUser) onlyOwner public {\n        require(checkBan[_bannedUser]);\n        uint BannedUserBalance = balanceOf(_bannedUser);\n        balances[_bannedUser] = 0;\n        tokensIssuedTotal = tokensIssuedTotal.sub(BannedUserBalance);\n        burnedBannedUserBalance(_bannedUser, BannedUserBalance);\n    }\n\n    event burnedBannedUserBalance(address _bannedUser, uint _balance);\n\n    event addedBanList(address _user);\n\n    event deletedfromBanList(address _user);\n\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinfabrik-Bitpara Smart Contract Audit/bitpara-master/bitpara.sol",
        "vulnerability": "Assertion Failure",
        "check": "FP",
        "response": "Answer: No\nReason: There are no assertions in the code that could lead to an assertion failure. The code uses `require` for condition checks instead."
    },
    {
        "code_segment": "contract Bitpara is BurnableToken {\n\n    /**\n     * @dev It will transfer to owner a specific amount of tokens.\n     * @param _value The amount of token to be transferred.\n     */\n\n  function transferToOwner(address _from, uint256 _value) onlyOwner public returns (bool) {\n    balances[_from] = balances[_from].sub(_value);\n    balances[owner] = balances[owner].add(_value);\n    Transfer(_from, owner, _value);\n    return true;\n  }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinfabrik-Bitpara Smart Contract Audit/bitpara-master/bitpara.sol",
        "vulnerability": "Assertion Failure",
        "check": "FP",
        "response": "Answer: No\nReason: The code does not include any assert statements that could lead to an assertion failure."
    },
    {
        "code_segment": "contract Bitpara is BurnableToken {\n\n    /**\n     * @dev It will transfer to owner a specific amount of tokens.\n     * @param _value The amount of token to be transferred.\n     */\n\n  function transferToOwner(address _from, uint256 _value) onlyOwner public returns (bool) {\n    balances[_from] = balances[_from].sub(_value);\n    balances[owner] = balances[owner].add(_value);\n    Transfer(_from, owner, _value);\n    return true;\n  }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinfabrik-Bitpara Smart Contract Audit/bitpara-master/bitpara.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No\nReason: The code uses safe math operations provided by the SafeMath library (`sub` and `add`), which protect against integer overflow and underflow vulnerabilities."
    },
    {
        "code_segment": "contract Bitpara is BurnableToken {\n\n    /**\n     * @dev It will transfer to owner a specific amount of tokens.\n     * @param _value The amount of token to be transferred.\n     */\n\n  function transferToOwner(address _from, uint256 _value) onlyOwner public returns (bool) {\n    balances[_from] = balances[_from].sub(_value);\n    balances[owner] = balances[owner].add(_value);\n    Transfer(_from, owner, _value);\n    return true;\n  }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinfabrik-Bitpara Smart Contract Audit/bitpara-master/bitpara.sol",
        "vulnerability": "Assertion Failure",
        "check": "FP",
        "response": "Answer: No\nReason: The provided code segment does not contain any assertions. The logic seems focused on transferring tokens and does not include assert statements that could fail."
    },
    {
        "code_segment": "contract BurnableToken is MintableToken {\n\n    event Burn(address indexed owner, uint256 _value);\n    \n    /**\n     * @dev Burns a specific amount of tokens.\n     * @param _value The amount of token to be burned.\n     */\n     \n    function burn(uint256 _value) onlyOwner public returns (bool) {\n        require(_value > 0);\n        balances[owner] = balances[owner].sub(_value);\n        tokensIssuedTotal = tokensIssuedTotal.sub(_value);\n        Burn(owner, _value);\n        return true;\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinfabrik-Bitpara Smart Contract Audit/bitpara-master/bitpara.sol",
        "vulnerability": "Assertion Failure",
        "check": "FP",
        "response": "Answer: No\nReason: The code does not contain any assertion statements, so an assertion failure vulnerability is not applicable in this case."
    },
    {
        "code_segment": "contract BurnableToken is MintableToken {\n\n    event Burn(address indexed owner, uint256 _value);\n    \n    /**\n     * @dev Burns a specific amount of tokens.\n     * @param _value The amount of token to be burned.\n     */\n     \n    function burn(uint256 _value) onlyOwner public returns (bool) {\n        require(_value > 0);\n        balances[owner] = balances[owner].sub(_value);\n        tokensIssuedTotal = tokensIssuedTotal.sub(_value);\n        Burn(owner, _value);\n        return true;\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinfabrik-Bitpara Smart Contract Audit/bitpara-master/bitpara.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No\nReason: The code uses SafeMath's `sub` function, which prevents integer overflows and underflows."
    },
    {
        "code_segment": "contract BurnableToken is MintableToken {\n\n    event Burn(address indexed owner, uint256 _value);\n    \n    /**\n     * @dev Burns a specific amount of tokens.\n     * @param _value The amount of token to be burned.\n     */\n     \n    function burn(uint256 _value) onlyOwner public returns (bool) {\n        require(_value > 0);\n        balances[owner] = balances[owner].sub(_value);\n        tokensIssuedTotal = tokensIssuedTotal.sub(_value);\n        Burn(owner, _value);\n        return true;\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinfabrik-Bitpara Smart Contract Audit/bitpara-master/bitpara.sol",
        "vulnerability": "Assertion Failure",
        "check": "FP",
        "response": "Answer: No\nReason: There are no assertions in the code that could fail. The burn function uses require statements which revert the transaction on failure, preventing assertion failures."
    },
    {
        "code_segment": "contract MintableToken is PausableToken {\n   event Mint(address indexed owner, uint _amount);\n\n  /**\n   * @dev Function to mint tokens\n   * @return A boolean that indicates if the operation was successful.\n   */\n   \n   \n  function mint(uint256 _amount) onlyOwner public returns (bool) {\n    tokensIssuedTotal = tokensIssuedTotal.add(_amount);\n    balances[owner] = balances[owner].add(_amount);\n    Mint(owner, _amount);\n    Transfer(0, owner, _amount);\n    return true;\n  }\n  \n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinfabrik-Bitpara Smart Contract Audit/bitpara-master/bitpara.sol",
        "vulnerability": "Assertion Failure",
        "check": "FP",
        "response": "Answer: No\nReason: The code segment doesn't contain any assertions that could fail or be incorrect, indicating no \"Assertion Failure\" vulnerability."
    },
    {
        "code_segment": "contract MintableToken is PausableToken {\n   event Mint(address indexed owner, uint _amount);\n\n  /**\n   * @dev Function to mint tokens\n   * @return A boolean that indicates if the operation was successful.\n   */\n   \n   \n  function mint(uint256 _amount) onlyOwner public returns (bool) {\n    tokensIssuedTotal = tokensIssuedTotal.add(_amount);\n    balances[owner] = balances[owner].add(_amount);\n    Mint(owner, _amount);\n    Transfer(0, owner, _amount);\n    return true;\n  }\n  \n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinfabrik-Bitpara Smart Contract Audit/bitpara-master/bitpara.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: Yes\nDescription: The code uses addition directly on the `tokensIssuedTotal` and `balances[owner]` variables without checking for possible integer overflows."
    },
    {
        "code_segment": "contract MintableToken is PausableToken {\n   event Mint(address indexed owner, uint _amount);\n\n  /**\n   * @dev Function to mint tokens\n   * @return A boolean that indicates if the operation was successful.\n   */\n   \n   \n  function mint(uint256 _amount) onlyOwner public returns (bool) {\n    tokensIssuedTotal = tokensIssuedTotal.add(_amount);\n    balances[owner] = balances[owner].add(_amount);\n    Mint(owner, _amount);\n    Transfer(0, owner, _amount);\n    return true;\n  }\n  \n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinfabrik-Bitpara Smart Contract Audit/bitpara-master/bitpara.sol",
        "vulnerability": "Assertion Failure",
        "check": "FP",
        "response": "Answer: No\nReason: The provided code segment does not contain any assert statements that would lead to an Assertion Failure."
    },
    {
        "code_segment": "contract PausableToken is BanList, Pausable {\n\n  function transfer(address _to, uint256 _value) public whenNotPaused returns (bool) {\n    require(!checkBan[msg.sender]);\n    return super.transfer(_to, _value);\n  }\n\n  function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool) {\n    require(!checkBan[_from]);\n    return super.transferFrom(_from, _to, _value);\n  }\n\n  function approve(address _spender, uint256 _value) public whenNotPaused returns (bool) {\n    return super.approve(_spender, _value);\n  }\n\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinfabrik-Bitpara Smart Contract Audit/bitpara-master/bitpara.sol",
        "vulnerability": "Assertion Failure",
        "check": "FP",
        "response": "Answer: No\nReason: The provided code contains no assertions that could lead to an assertion failure. The functions use only `require` statements for validation."
    },
    {
        "code_segment": "contract StandardToken is BasicToken {\n \n \n  mapping (address => mapping (address => uint256)) internal allowed;\n\n\n   /**\n    * @dev Transfer tokens from one address to another\n    * @param _from address The address which you want to send tokens from\n    * @param _to address The address which you want to transfer to\n    * @param _value uint the amount of tokens to be transferred\n    */\n    \n   \n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n\n    balances[_from] = balances[_from].sub(_value);\n    uint256 netbakiye = _value.sub(fee);\n    balances[_to] = balances[_to].add(netbakiye);\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n    Transfer(_from, _to, netbakiye);\n    if (fee > 0) {\n    balances[owner] = balances[owner].add(fee);\n    Transfer(_from, owner, fee);\n    }\n    return true;\n  }\n\n   /**\n    * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n    *\n    * Beware that changing an allowance with this method brings the risk that someone may use both the old\n    * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n    * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n    * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n    * @param _spender The address which will spend the funds.\n    * @param _value The amount of tokens to be spent.\n    */\n   \n  function approve(address _spender, uint256 _value) public returns (bool) {\n    allowed[msg.sender][_spender] = _value;\n    Approval(msg.sender, _spender, _value);\n    return true;\n  }\n\n   /**\n    * @dev Function to check the amount of tokens that an owner allowed to a spender.\n    * @param _owner address The address which owns the funds.\n    * @param _spender address The address which will spend the funds.\n    * @return A uint256 specifying the amount of tokens still available for the spender.\n    */\n\n  function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\n    return allowed[_owner][_spender];\n  }\n\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinfabrik-Bitpara Smart Contract Audit/bitpara-master/bitpara.sol",
        "vulnerability": "Assertion Failure",
        "check": "FP",
        "response": "Answer: Yes\nDescription: The code does not check if \"_value\" is greater than \"balances[_from]\" before subtracting, leading to potential underflow and assertion failure."
    },
    {
        "code_segment": "contract BsktEthLPPool is LPTokenWrapper {\n    \n    IERC20 public STAKEBSKT = IERC20(0x3d3c60970D3369e48f79664787433fc0d2B7C44b); // Basket token address\n    \n    uint256 public constant duration = 100 days;     //-----| Pool Duration |-----       \n    uint256 public starttime = 0;                    //-----| Pool will start once notify the reward |-----                           \n    uint256 public periodFinish = 0;\n    uint256 public rewardRate = 0;\n    uint256 public lastUpdateTime;\n    uint256 public rewardPerTokenStored;\n\n    bool firstNotify;\n  \n    mapping(address => uint256) public userRewardPerTokenPaid;\n    mapping(address => uint256) public rewards;\n    mapping(address => bool) public minimumBsktStakingEntry;\n\n    event Staked(address indexed user, uint256 amount);\n    event Withdrawn(address indexed user, uint256 amount);\n    event Rewarded(address indexed from, address indexed to, uint256 value);\n\n    modifier checkStart() {\n        require(\n            block.timestamp >= starttime,\n            \"Error:Pool not started yet.\"\n        );\n        _;\n    }\n//SWC-116-Block values as a proxy for time: L400, L417\n    modifier updateReward(address account) {\n        rewardPerTokenStored = rewardPerToken();\n        lastUpdateTime = lastTimeRewardApplicable();\n        if (account != address(0)) {\n            rewards[account] = earned(account);\n            userRewardPerTokenPaid[account] = rewardPerTokenStored;\n        }\n        _;\n    }\n    \n    function lastTimeRewardApplicable() public view returns (uint256) {\n        return Math.min(block.timestamp, periodFinish);\n    }\n\n    function rewardPerToken() public view returns (uint256) {\n        if (totalSupply() == 0) {\n            return rewardPerTokenStored;\n        }\n        return\n            rewardPerTokenStored.add(\n                lastTimeRewardApplicable()\n                    .sub(lastUpdateTime)\n                    .mul(rewardRate)\n                    .mul(1e18)\n                    .div(totalSupply())\n            );\n    }\n\n    function earned(address account) public view returns (uint256) {\n        return balanceOf(account)\n                .mul(rewardPerToken().sub(userRewardPerTokenPaid[account]))\n                .div(1e18)\n                .add(rewards[account]);\n    }\n\n    function stake(uint256 amount) public updateReward(_msgSender()) checkStart {\n        require(amount > 0, \"Cannot stake 0\");\n        super.stake(amount);\n        \n        emit Staked(_msgSender(), amount);\n    }\n\n    function withdraw(uint256 amount)\n        public\n        updateReward(_msgSender())\n    {\n        require(amount > 0, \"Cannot withdraw 0\");\n        super.withdraw(amount);\n        \n        emit Withdrawn(_msgSender(), amount);\n    }\n//SWC-107-Reentrancy: L459-462\n    // Withdraw staked lp token and earned reward immediately\n    function exit() nonReentrant external {\n        withdraw(balanceOf(_msgSender()));\n        getReward();\n    }\n    \n    // Withdraw earned reward\n    function getReward() public nonReentrant updateReward(_msgSender()){\n        uint256 reward = earned(_msgSender());\n\n        if (reward > 0) {\n            rewards[_msgSender()] = 0;\n        \n            STAKEBSKT.safeTransfer(_msgSender(), reward);\n            \n            emit Rewarded(address(this), _msgSender(), reward);\n        }\n        \n    }\n\n    // Notify reward set for duration\n    function notifyRewardRate(uint256 _reward) public updateReward(address(0)) onlyOwner{\n       \n        require(!firstNotify, \"Error : Notify rewards allowed once only\");\n        \n        rewardRate = _reward.div(duration);\n       \n        lastUpdateTime = block.timestamp;\n        starttime = block.timestamp; \n        periodFinish = block.timestamp.add(duration);\n\n        firstNotify = true;\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/QuillAudits-BsktEthLPPool Smart Contract/code/BsktEthLPPool.sol",
        "vulnerability": "Block Dependency",
        "check": "FP",
        "response": "Answer: Yes\nDescription: The contract uses `block.timestamp` to control the start and end times of the pool and to calculate rewards, making it vulnerable to manipulation by miners who can influence timestamps."
    },
    {
        "code_segment": "contract BsktEthLPPool is LPTokenWrapper {\n    \n    IERC20 public STAKEBSKT = IERC20(0x3d3c60970D3369e48f79664787433fc0d2B7C44b); // Basket token address\n    \n    uint256 public constant duration = 100 days;     //-----| Pool Duration |-----       \n    uint256 public starttime = 0;                    //-----| Pool will start once notify the reward |-----                           \n    uint256 public periodFinish = 0;\n    uint256 public rewardRate = 0;\n    uint256 public lastUpdateTime;\n    uint256 public rewardPerTokenStored;\n\n    bool firstNotify;\n  \n    mapping(address => uint256) public userRewardPerTokenPaid;\n    mapping(address => uint256) public rewards;\n    mapping(address => bool) public minimumBsktStakingEntry;\n\n    event Staked(address indexed user, uint256 amount);\n    event Withdrawn(address indexed user, uint256 amount);\n    event Rewarded(address indexed from, address indexed to, uint256 value);\n\n    modifier checkStart() {\n        require(\n            block.timestamp >= starttime,\n            \"Error:Pool not started yet.\"\n        );\n        _;\n    }\n//SWC-116-Block values as a proxy for time: L400, L417\n    modifier updateReward(address account) {\n        rewardPerTokenStored = rewardPerToken();\n        lastUpdateTime = lastTimeRewardApplicable();\n        if (account != address(0)) {\n            rewards[account] = earned(account);\n            userRewardPerTokenPaid[account] = rewardPerTokenStored;\n        }\n        _;\n    }\n    \n    function lastTimeRewardApplicable() public view returns (uint256) {\n        return Math.min(block.timestamp, periodFinish);\n    }\n\n    function rewardPerToken() public view returns (uint256) {\n        if (totalSupply() == 0) {\n            return rewardPerTokenStored;\n        }\n        return\n            rewardPerTokenStored.add(\n                lastTimeRewardApplicable()\n                    .sub(lastUpdateTime)\n                    .mul(rewardRate)\n                    .mul(1e18)\n                    .div(totalSupply())\n            );\n    }\n\n    function earned(address account) public view returns (uint256) {\n        return balanceOf(account)\n                .mul(rewardPerToken().sub(userRewardPerTokenPaid[account]))\n                .div(1e18)\n                .add(rewards[account]);\n    }\n\n    function stake(uint256 amount) public updateReward(_msgSender()) checkStart {\n        require(amount > 0, \"Cannot stake 0\");\n        super.stake(amount);\n        \n        emit Staked(_msgSender(), amount);\n    }\n\n    function withdraw(uint256 amount)\n        public\n        updateReward(_msgSender())\n    {\n        require(amount > 0, \"Cannot withdraw 0\");\n        super.withdraw(amount);\n        \n        emit Withdrawn(_msgSender(), amount);\n    }\n//SWC-107-Reentrancy: L459-462\n    // Withdraw staked lp token and earned reward immediately\n    function exit() nonReentrant external {\n        withdraw(balanceOf(_msgSender()));\n        getReward();\n    }\n    \n    // Withdraw earned reward\n    function getReward() public nonReentrant updateReward(_msgSender()){\n        uint256 reward = earned(_msgSender());\n\n        if (reward > 0) {\n            rewards[_msgSender()] = 0;\n        \n            STAKEBSKT.safeTransfer(_msgSender(), reward);\n            \n            emit Rewarded(address(this), _msgSender(), reward);\n        }\n        \n    }\n\n    // Notify reward set for duration\n    function notifyRewardRate(uint256 _reward) public updateReward(address(0)) onlyOwner{\n       \n        require(!firstNotify, \"Error : Notify rewards allowed once only\");\n        \n        rewardRate = _reward.div(duration);\n       \n        lastUpdateTime = block.timestamp;\n        starttime = block.timestamp; \n        periodFinish = block.timestamp.add(duration);\n\n        firstNotify = true;\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/QuillAudits-BsktEthLPPool Smart Contract/code/BsktEthLPPool.sol",
        "vulnerability": "Block Dependency",
        "check": "FP",
        "response": "Answer: Yes\nDescription: The use of `block.timestamp` in multiple places, including `lastTimeRewardApplicable` and `notifyRewardRate`, makes the logic dependent on the block's timestamp, which can be manipulated by miners."
    },
    {
        "code_segment": "contract BsktEthLPPool is LPTokenWrapper {\n    \n    IERC20 public STAKEBSKT = IERC20(0x3d3c60970D3369e48f79664787433fc0d2B7C44b); // Basket token address\n    \n    uint256 public constant duration = 100 days;     //-----| Pool Duration |-----       \n    uint256 public starttime = 0;                    //-----| Pool will start once notify the reward |-----                           \n    uint256 public periodFinish = 0;\n    uint256 public rewardRate = 0;\n    uint256 public lastUpdateTime;\n    uint256 public rewardPerTokenStored;\n\n    bool firstNotify;\n  \n    mapping(address => uint256) public userRewardPerTokenPaid;\n    mapping(address => uint256) public rewards;\n    mapping(address => bool) public minimumBsktStakingEntry;\n\n    event Staked(address indexed user, uint256 amount);\n    event Withdrawn(address indexed user, uint256 amount);\n    event Rewarded(address indexed from, address indexed to, uint256 value);\n\n    modifier checkStart() {\n        require(\n            block.timestamp >= starttime,\n            \"Error:Pool not started yet.\"\n        );\n        _;\n    }\n//SWC-116-Block values as a proxy for time: L400, L417\n    modifier updateReward(address account) {\n        rewardPerTokenStored = rewardPerToken();\n        lastUpdateTime = lastTimeRewardApplicable();\n        if (account != address(0)) {\n            rewards[account] = earned(account);\n            userRewardPerTokenPaid[account] = rewardPerTokenStored;\n        }\n        _;\n    }\n    \n    function lastTimeRewardApplicable() public view returns (uint256) {\n        return Math.min(block.timestamp, periodFinish);\n    }\n\n    function rewardPerToken() public view returns (uint256) {\n        if (totalSupply() == 0) {\n            return rewardPerTokenStored;\n        }\n        return\n            rewardPerTokenStored.add(\n                lastTimeRewardApplicable()\n                    .sub(lastUpdateTime)\n                    .mul(rewardRate)\n                    .mul(1e18)\n                    .div(totalSupply())\n            );\n    }\n\n    function earned(address account) public view returns (uint256) {\n        return balanceOf(account)\n                .mul(rewardPerToken().sub(userRewardPerTokenPaid[account]))\n                .div(1e18)\n                .add(rewards[account]);\n    }\n\n    function stake(uint256 amount) public updateReward(_msgSender()) checkStart {\n        require(amount > 0, \"Cannot stake 0\");\n        super.stake(amount);\n        \n        emit Staked(_msgSender(), amount);\n    }\n\n    function withdraw(uint256 amount)\n        public\n        updateReward(_msgSender())\n    {\n        require(amount > 0, \"Cannot withdraw 0\");\n        super.withdraw(amount);\n        \n        emit Withdrawn(_msgSender(), amount);\n    }\n//SWC-107-Reentrancy: L459-462\n    // Withdraw staked lp token and earned reward immediately\n    function exit() nonReentrant external {\n        withdraw(balanceOf(_msgSender()));\n        getReward();\n    }\n    \n    // Withdraw earned reward\n    function getReward() public nonReentrant updateReward(_msgSender()){\n        uint256 reward = earned(_msgSender());\n\n        if (reward > 0) {\n            rewards[_msgSender()] = 0;\n        \n            STAKEBSKT.safeTransfer(_msgSender(), reward);\n            \n            emit Rewarded(address(this), _msgSender(), reward);\n        }\n        \n    }\n\n    // Notify reward set for duration\n    function notifyRewardRate(uint256 _reward) public updateReward(address(0)) onlyOwner{\n       \n        require(!firstNotify, \"Error : Notify rewards allowed once only\");\n        \n        rewardRate = _reward.div(duration);\n       \n        lastUpdateTime = block.timestamp;\n        starttime = block.timestamp; \n        periodFinish = block.timestamp.add(duration);\n\n        firstNotify = true;\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/QuillAudits-BsktEthLPPool Smart Contract/code/BsktEthLPPool.sol",
        "vulnerability": "Block Dependency",
        "check": "FP",
        "response": "Answer: Yes\nDescription: The contract relies on `block.timestamp` to manage timing for rewards and staking periods, which can be influenced by miners for short intervals, leading to potential manipulation."
    },
    {
        "code_segment": "contract BMath is BConst, BNum, BMathInterface {\n    /**********************************************************************************************\n    // calcSpotPrice                                                                             //\n    // sP = spotPrice                                                                            //\n    // bI = tokenBalanceIn                ( bI / wI )         1                                  //\n    // bO = tokenBalanceOut         sP =  -----------  *  ----------                             //\n    // wI = tokenWeightIn                 ( bO / wO )     ( 1 - sF )                             //\n    // wO = tokenWeightOut                                                                       //\n    // sF = swapFee                                                                              //\n    **********************************************************************************************/\n    function calcSpotPrice(\n        uint tokenBalanceIn,\n        uint tokenWeightIn,\n        uint tokenBalanceOut,\n        uint tokenWeightOut,\n        uint swapFee\n    )\n        public pure virtual\n        returns (uint spotPrice)\n    {\n        uint numer = bdiv(tokenBalanceIn, tokenWeightIn);\n        uint denom = bdiv(tokenBalanceOut, tokenWeightOut);\n        uint ratio = bdiv(numer, denom);\n        uint scale = bdiv(BONE, bsub(BONE, swapFee));\n        return  (spotPrice = bmul(ratio, scale));\n    }\n\n    /**********************************************************************************************\n    // calcOutGivenIn                                                                            //\n    // aO = tokenAmountOut                                                                       //\n    // bO = tokenBalanceOut                                                                      //\n    // bI = tokenBalanceIn              /      /            bI             \\    (wI / wO) \\      //\n    // aI = tokenAmountIn    aO = bO * |  1 - | --------------------------  | ^            |     //\n    // wI = tokenWeightIn               \\      \\ ( bI + ( aI * ( 1 - sF )) /              /      //\n    // wO = tokenWeightOut                                                                       //\n    // sF = swapFee                                                                              //\n    **********************************************************************************************/\n    function calcOutGivenIn(\n        uint tokenBalanceIn,\n        uint tokenWeightIn,\n        uint tokenBalanceOut,\n        uint tokenWeightOut,\n        uint tokenAmountIn,\n        uint swapFee\n    )\n        public pure virtual\n        returns (uint tokenAmountOut)\n    {\n        uint weightRatio = bdiv(tokenWeightIn, tokenWeightOut);\n        uint adjustedIn = bsub(BONE, swapFee);\n        adjustedIn = bmul(tokenAmountIn, adjustedIn);\n        uint y = bdiv(tokenBalanceIn, badd(tokenBalanceIn, adjustedIn));\n        uint foo = bpow(y, weightRatio);\n        uint bar = bsub(BONE, foo);\n        tokenAmountOut = bmul(tokenBalanceOut, bar);\n        return tokenAmountOut;\n    }\n\n    /**********************************************************************************************\n    // calcInGivenOut                                                                            //\n    // aI = tokenAmountIn                                                                        //\n    // bO = tokenBalanceOut               /  /     bO      \\    (wO / wI)      \\                 //\n    // bI = tokenBalanceIn          bI * |  | ------------  | ^            - 1  |                //\n    // aO = tokenAmountOut    aI =        \\  \\ ( bO - aO ) /                   /                 //\n    // wI = tokenWeightIn           --------------------------------------------                 //\n    // wO = tokenWeightOut                          ( 1 - sF )                                   //\n    // sF = swapFee                                                                              //\n    **********************************************************************************************/\n    function calcInGivenOut(\n        uint tokenBalanceIn,\n        uint tokenWeightIn,\n        uint tokenBalanceOut,\n        uint tokenWeightOut,\n        uint tokenAmountOut,\n        uint swapFee\n    )\n        public pure virtual override\n        returns (uint tokenAmountIn)\n    {\n        uint weightRatio = bdiv(tokenWeightOut, tokenWeightIn);\n        uint diff = bsub(tokenBalanceOut, tokenAmountOut);\n        uint y = bdiv(tokenBalanceOut, diff);\n        uint foo = bpow(y, weightRatio);\n        foo = bsub(foo, BONE);\n        tokenAmountIn = bsub(BONE, swapFee);\n        tokenAmountIn = bdiv(bmul(tokenBalanceIn, foo), tokenAmountIn);\n        return tokenAmountIn;\n    }\n\n    /**********************************************************************************************\n    // calcPoolOutGivenSingleIn                                                                  //\n    // pAo = poolAmountOut         /                                              \\              //\n    // tAi = tokenAmountIn        \n    // wI = tokenWeightIn        //| tAi *| 1 - || 1 - --  | * sF || + tBi \\    --  \\            //\n    // tW = totalWeight     pAo=||  \\      \\     \\\\    tW /      //         | ^ tW   | * pS - pS //\n    // tBi = tokenBalanceIn      \\\\  ------------------------------------- /        /            //\n    // pS = poolSupply            \\\\                    tBi               /        /             //\n    // sF = swapFee                \\                                              /              //\n    **********************************************************************************************/\n    function calcPoolOutGivenSingleIn(\n        uint tokenBalanceIn,\n        uint tokenWeightIn,\n        uint poolSupply,\n        uint totalWeight,\n        uint tokenAmountIn,\n        uint swapFee\n    )\n        public pure virtual\n        returns (uint poolAmountOut)\n    {\n        // Charge the trading fee for the proportion of tokenAi\n        \n        // That proportion is (1- weightTokenIn)\n        // tokenAiAfterFee = tAi * (1 - (1-weightTi) * poolFee);\n        uint normalizedWeight = bdiv(tokenWeightIn, totalWeight);\n        uint zaz = bmul(bsub(BONE, normalizedWeight), swapFee);\n        uint tokenAmountInAfterFee = bmul(tokenAmountIn, bsub(BONE, zaz));\n\n        uint newTokenBalanceIn = badd(tokenBalanceIn, tokenAmountInAfterFee);\n        uint tokenInRatio = bdiv(newTokenBalanceIn, tokenBalanceIn);\n\n        // uint newPoolSupply = (ratioTi ^ weightTi) * poolSupply;\n        uint poolRatio = bpow(tokenInRatio, normalizedWeight);\n        uint newPoolSupply = bmul(poolRatio, poolSupply);\n        poolAmountOut = bsub(newPoolSupply, poolSupply);\n        return poolAmountOut;\n    }\n\n    /**********************************************************************************************\n    // calcSingleInGivenPoolOut                                                                  //\n    // tAi = tokenAmountIn              //(pS + pAo)\\     /    1    \\\\                           //\n    // pS = poolSupply                 || ---------  | ^ | --------- || * bI - bI                //\n    // pAo = poolAmountOut              \\\\    pS    /     \\(wI / tW)//                           //\n    // bI = balanceIn          tAi =  --------------------------------------------               //\n    // wI = weightIn                              /      wI  \\                                   //\n    // tW = totalWeight                          |  1 - ----  |  * sF                            //\n    // sF = swapFee                               \\      tW  /                                   //\n    **********************************************************************************************/\n    function calcSingleInGivenPoolOut(\n        uint tokenBalanceIn,\n        uint tokenWeightIn,\n        uint poolSupply,\n        uint totalWeight,\n        uint poolAmountOut,\n        uint swapFee\n    )\n        public pure virtual override\n        returns (uint tokenAmountIn)\n    {\n        uint normalizedWeight = bdiv(tokenWeightIn, totalWeight);\n        uint newPoolSupply = badd(poolSupply, poolAmountOut);\n        uint poolRatio = bdiv(newPoolSupply, poolSupply);\n\n        //uint newBalTi = poolRatio^(1/weightTi) * balTi;\n        uint boo = bdiv(BONE, normalizedWeight);\n        uint tokenInRatio = bpow(poolRatio, boo);\n        uint newTokenBalanceIn = bmul(tokenInRatio, tokenBalanceIn);\n        uint tokenAmountInAfterFee = bsub(newTokenBalanceIn, tokenBalanceIn);\n        // Do reverse order of fees charged in joinswap_ExternAmountIn, this way\n        //     ``` pAo == joinswap_ExternAmountIn(Ti, joinswap_PoolAmountOut(pAo, Ti)) ```\n        //uint tAi = tAiAfterFee / (1 - (1-weightTi) * swapFee) ;\n        uint zar = bmul(bsub(BONE, normalizedWeight), swapFee);\n        tokenAmountIn = bdiv(tokenAmountInAfterFee, bsub(BONE, zar));\n        return tokenAmountIn;\n    }\n\n    /**********************************************************************************************\n    // calcSingleOutGivenPoolIn                                                                  //\n    // tAo = tokenAmountOut            /      /                                             \\\\   //\n    // bO = tokenBalanceOut           /      //       pS - pAi        \\     /    1    \\      \\\\  //\n    // pAi = poolAmountIn            | bO - || ----------------------- | ^ | --------- | * b0 || //\n    // ps = poolSupply                \\      \\\\          pS           /     \\(wO / tW)/      //  //\n    // wI = tokenWeightIn      tAo =   \\      \\                                             //   //\n    // tW = totalWeight                    /     /      wO \\       \\                             //\n    // sF = swapFee                    *  | 1 - |  1 - ---- | * sF  |                            //\n    // eF = exitFee                        \\     \\      tW /       /                             //\n    **********************************************************************************************/\n    function calcSingleOutGivenPoolIn(\n        uint tokenBalanceOut,\n        uint tokenWeightOut,\n        uint poolSupply,\n        uint totalWeight,\n        uint poolAmountIn,\n        uint swapFee\n    )\n        public pure virtual\n        returns (uint tokenAmountOut)\n    {\n        uint normalizedWeight = bdiv(tokenWeightOut, totalWeight);\n        uint newPoolSupply = bsub(poolSupply, poolAmountIn);\n        uint poolRatio = bdiv(newPoolSupply, poolSupply);\n\n        // newBalTo = poolRatio^(1/weightTo) * balTo;\n        uint tokenOutRatio = bpow(poolRatio, bdiv(BONE, normalizedWeight));\n        uint newTokenBalanceOut = bmul(tokenOutRatio, tokenBalanceOut);\n\n        uint tokenAmountOutBeforeSwapFee = bsub(tokenBalanceOut, newTokenBalanceOut);\n\n        // charge swap fee on the output token side\n        //uint tAo = tAoBeforeSwapFee * (1 - (1-weightTo) * swapFee)\n        uint zaz = bmul(bsub(BONE, normalizedWeight), swapFee);\n        tokenAmountOut = bmul(tokenAmountOutBeforeSwapFee, bsub(BONE, zaz));\n        return tokenAmountOut;\n    }\n\n    /**********************************************************************************************\n    // calcPoolInGivenSingleOut                                                                  //\n    // pAi = poolAmountIn               // /               tAo             \\\\     / wO \\     \\   //\n    // bO = tokenBalanceOut            // | bO - -------------------------- |\\   | ---- |     \\  //\n    // tAo = tokenAmountOut      pS - ||   \\     1 - ((1 - (tO / tW)) * sF)/  | ^ \\ tW /  * pS | //\n    // ps = poolSupply                 \\\\ -----------------------------------/                /  //\n    // wO = tokenWeightOut  pAi =       \\\\               bO                 /                /   //\n    // tW = totalWeight                                                                          //\n    // sF = swapFee                                                                              //\n    **********************************************************************************************/\n    function calcPoolInGivenSingleOut(\n        uint tokenBalanceOut,\n        uint tokenWeightOut,\n        uint poolSupply,\n        uint totalWeight,\n        uint tokenAmountOut,\n        uint swapFee\n    )\n        public pure virtual\n        returns (uint poolAmountIn)\n    {\n\n        // charge swap fee on the output token side\n        uint normalizedWeight = bdiv(tokenWeightOut, totalWeight);\n        //uint tAoBeforeSwapFee = tAo / (1 - (1-weightTo) * swapFee) ;\n        uint zoo = bsub(BONE, normalizedWeight);\n        uint zar = bmul(zoo, swapFee);\n        uint tokenAmountOutBeforeSwapFee = bdiv(tokenAmountOut, bsub(BONE, zar));\n\n        uint newTokenBalanceOut = bsub(tokenBalanceOut, tokenAmountOutBeforeSwapFee);\n        uint tokenOutRatio = bdiv(newTokenBalanceOut, tokenBalanceOut);\n\n        //uint newPoolSupply = (ratioTo ^ weightTo) * poolSupply;\n        uint poolRatio = bpow(tokenOutRatio, normalizedWeight);\n        uint newPoolSupply = bmul(poolRatio, poolSupply);\n        uint poolAmountIn = bsub(poolSupply, newPoolSupply);\n        return poolAmountIn;\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/QuillAudits-MatrixETF Smart Contract/MatrixETF-Pool-V2-2d5c5252e17f91680645fc6fb0d2108ff681037b/contracts/balancer-core/BPool.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No  \nReason: The provided code uses fixed-point arithmetic functions (like `bmul`, `bdiv`, etc.) which handle overflow checks internally."
    },
    {
        "code_segment": "contract BEP20Token is Context, IBEP20, Ownable {\n  using SafeMath for uint256;\n\n  mapping (address => uint256) private _balances;\n\n  mapping (address => mapping (address => uint256)) private _allowances;\n\n  uint256 private _totalSupply;\n  uint8 private _decimals;\n  string private _symbol;\n  string private _name;\n\n  constructor() public {\n    _name = \"AGRO GLOBAL\";\n    _symbol = \"AGRO\";\n    _decimals = 4;\n    _totalSupply = 95000000000 * 10 ** 4;\n    _balances[msg.sender] = _totalSupply;\n\n    emit Transfer(address(0), msg.sender, _totalSupply);\n  }\n\n  /**\n   * @dev Returns the bep token owner.\n   */\n  function getOwner() external view returns (address) {\n    return owner();\n  }\n\n  /**\n   * @dev Returns the token decimals.\n   */\n  function decimals() external view returns (uint8) {\n    return _decimals;\n  }\n\n  /**\n   * @dev Returns the token symbol.\n   */\n  function symbol() external view returns (string memory) {\n    return _symbol;\n  }\n\n  /**\n  * @dev Returns the token name.\n  */\n  function name() external view returns (string memory) {\n    return _name;\n  }\n\n  /**\n   * @dev See {BEP20-totalSupply}.\n   */\n  function totalSupply() external view returns (uint256) {\n    return _totalSupply;\n  }\n\n  /**\n   * @dev See {BEP20-balanceOf}.\n   */\n  function balanceOf(address account) external view returns (uint256) {\n    return _balances[account];\n  }\n\n  /**\n   * @dev See {BEP20-transfer}.\n   *\n   * Requirements:\n   *\n   * - `recipient` cannot be the zero address.\n   * - the caller must have a balance of at least `amount`.\n   */\n  function transfer(address recipient, uint256 amount) external returns (bool) {\n    _transfer(_msgSender(), recipient, amount);\n    return true;\n  }\n\n  /**\n   * @dev See {BEP20-allowance}.\n   */\n  function allowance(address owner, address spender) external view returns (uint256) {\n    return _allowances[owner][spender];\n  }\n\n  /**\n   * @dev See {BEP20-approve}.\n   *\n   * Requirements:\n   *\n   * - `spender` cannot be the zero address.\n   */\n  function approve(address spender, uint256 amount) external returns (bool) {\n    _approve(_msgSender(), spender, amount);\n    return true;\n  }\n\n  /**\n   * @dev See {BEP20-transferFrom}.\n   *\n   * Emits an {Approval} event indicating the updated allowance. This is not\n   * required by the EIP. See the note at the beginning of {BEP20};\n   *\n   * Requirements:\n   * - `sender` and `recipient` cannot be the zero address.\n   * - `sender` must have a balance of at least `amount`.\n   * - the caller must have allowance for `sender`'s tokens of at least\n   * `amount`.\n   */\n  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool) {\n    _transfer(sender, recipient, amount);\n    _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"BEP20: transfer amount exceeds allowance\"));\n    return true;\n  }\n\n  /**\n   * @dev Atomically increases the allowance granted to `spender` by the caller.\n   *\n   * This is an alternative to {approve} that can be used as a mitigation for\n   * problems described in {BEP20-approve}.\n   *\n   * Emits an {Approval} event indicating the updated allowance.\n   *\n   * Requirements:\n   *\n   * - `spender` cannot be the zero address.\n   */\n  function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n    _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n    return true;\n  }\n\n  /**\n   * @dev Atomically decreases the allowance granted to `spender` by the caller.\n   *\n   * This is an alternative to {approve} that can be used as a mitigation for\n   * problems described in {BEP20-approve}.\n   *\n   * Emits an {Approval} event indicating the updated allowance.\n   *\n   * Requirements:\n   *\n   * - `spender` cannot be the zero address.\n   * - `spender` must have allowance for the caller of at least\n   * `subtractedValue`.\n   */\n  function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n    _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"BEP20: decreased allowance below zero\"));\n    return true;\n  }\n\n  /**\n   * @dev Creates `amount` tokens and assigns them to `msg.sender`, increasing\n   * the total supply.\n   *\n   * Requirements\n   *\n   * - `msg.sender` must be the token owner\n   */\n  function mint(uint256 amount) public onlyOwner returns (bool) {\n    _mint(_msgSender(), amount);\n    return true;\n  }\n\n  /**\n   * @dev Moves tokens `amount` from `sender` to `recipient`.\n   *\n   * This is internal function is equivalent to {transfer}, and can be used to\n   * e.g. implement automatic token fees, slashing mechanisms, etc.\n   *\n   * Emits a {Transfer} event.\n   *\n   * Requirements:\n   *\n   * - `sender` cannot be the zero address.\n   * - `recipient` cannot be the zero address.\n   * - `sender` must have a balance of at least `amount`.\n   */\n  function _transfer(address sender, address recipient, uint256 amount) internal {\n    require(sender != address(0), \"BEP20: transfer from the zero address\");\n    require(recipient != address(0), \"BEP20: transfer to the zero address\");\n\n    _balances[sender] = _balances[sender].sub(amount, \"BEP20: transfer amount exceeds balance\");\n    _balances[recipient] = _balances[recipient].add(amount);\n    emit Transfer(sender, recipient, amount);\n  }\n\n  /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n   * the total supply.\n   *\n   * Emits a {Transfer} event with `from` set to the zero address.\n   *\n   * Requirements\n   *\n   * - `to` cannot be the zero address.\n   */\n  function _mint(address account, uint256 amount) internal {\n    require(account != address(0), \"BEP20: mint to the zero address\");\n\n    _totalSupply = _totalSupply.add(amount);\n    _balances[account] = _balances[account].add(amount);\n    emit Transfer(address(0), account, amount);\n  }\n\n  /**\n   * @dev Destroys `amount` tokens from `account`, reducing the\n   * total supply.\n   *\n   * Emits a {Transfer} event with `to` set to the zero address.\n   *\n   * Requirements\n   *\n   * - `account` cannot be the zero address.\n   * - `account` must have at least `amount` tokens.\n   */\n  function _burn(address account, uint256 amount) internal {\n    require(account != address(0), \"BEP20: burn from the zero address\");\n\n    _balances[account] = _balances[account].sub(amount, \"BEP20: burn amount exceeds balance\");\n    _totalSupply = _totalSupply.sub(amount);\n    emit Transfer(account, address(0), amount);\n  }\n\n  /**\n   * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\n   *\n   * This is internal function is equivalent to `approve`, and can be used to\n   * e.g. set automatic allowances for certain subsystems, etc.\n   *\n   * Emits an {Approval} event.\n   *\n   * Requirements:\n   *\n   * - `owner` cannot be the zero address.\n   * - `spender` cannot be the zero address.\n   */\n  function _approve(address owner, address spender, uint256 amount) internal {\n    require(owner != address(0), \"BEP20: approve from the zero address\");\n    require(spender != address(0), \"BEP20: approve to the zero address\");\n\n    _allowances[owner][spender] = amount;\n    emit Approval(owner, spender, amount);\n  }\n\n  /**\n   * @dev Destroys `amount` tokens from `account`.`amount` is then deducted\n   * from the caller's allowance.\n   *\n   * See {_burn} and {_approve}.\n   */\n  //  SWC-135-Code With No Effects: L592 - L594\n  function _burnFrom(address account, uint256 amount) internal {\n    _burn(account, amount);\n    _approve(account, _msgSender(), _allowances[account][_msgSender()].sub(amount, \"BEP20: burn amount exceeds allowance\"));\n  }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/PeckShield-ERC20_AGRO/code/code.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No\nReason: The contract uses the SafeMath library for all arithmetic operations to prevent integer overflow."
    },
    {
        "code_segment": "contract MonstaPresale is Pausable {\n  using SafeMath for uint;\n\n  uint constant public PRESALE_END_TIMESTAMP = 1633957199; // No Monstas can be adopted after this end date: Monday, October 11, 2021 12:59:59 PM GMT\n  uint constant public PRICE_INCREMENT = 383325347388596 wei; // 0.000383325347388596 BNB\n  uint constant public INITIAL_PRICE = 200000000000000000; // 0.2 BNB\n  uint constant public MAX_TOTAL_ADOPTED_MONSTA = 2088;\n  uint constant public MAX_TOTAL_GIVEAWAY_MONSTA = 2000;\n\n  uint public _currentPrice;\n  uint public _totalAdoptedMonstas;\n  uint public _totalGiveawayMonstas;\n  uint public _totalRedeemedMonstas;\n\n  address public _redemptionAddress;\n  mapping(address => bool) public _adopters;\n\n  event MonstaAdopted(address indexed adopter);\n  event AdoptedMonstaRedeemed(address indexed receiver);\n\n  modifier onlyRedemptionAddress {\n    require(msg.sender == _redemptionAddress);\n    _;\n  }\n\n  constructor() public {\n    _currentPrice = INITIAL_PRICE;\n  }\n\n  /**\n   * @dev Adopt some Monsta\n   */\n  function adoptMonsta() public payable whenNotPaused {\n    require(now <= PRESALE_END_TIMESTAMP);\n    require(!_adopters[msg.sender], \"Only can adopt once\");\n    require(_totalAdoptedMonstas.add(1) <= MAX_TOTAL_ADOPTED_MONSTA);\n    require(msg.value >= _currentPrice);\n    \n  \n    uint value = msg.value.sub(_currentPrice);\n    msg.sender.transfer(value);  // Refund back the remaining to the receiver\n\n    _adopters[msg.sender] = true;\n    _totalAdoptedMonstas = _totalAdoptedMonstas.add(1);\n    _currentPrice = _currentPrice.add(PRICE_INCREMENT);\n     \n    emit MonstaAdopted(msg.sender);\n  }\n  \n  /**\n   * @dev Set redemption contract address\n   */\n  function setRedemptionAddress(address redemptionAddress) external onlyOwner {\n    _redemptionAddress = redemptionAddress;\n  }\n\n  /**\n  * @dev Redeem adopted monsta, onlyRedemptionAddress is a redemption contract address\n  * @param receiver Address of the receiver.\n  */\n  function redeemAdoptedMonsta(address receiver) external onlyRedemptionAddress whenNotPaused returns(uint) {\n    require(_adopters[receiver]);\n     _totalRedeemedMonstas = _totalRedeemedMonstas.add(1);\n     _adopters[receiver] = false;\n    emit AdoptedMonstaRedeemed(receiver);\n    return _totalRedeemedMonstas;\n  }\n\n  /**\n   * @dev Giveaway monsta without effecting adopted Monsta counter counter\n   */\n  function giveaway(address[] calldata _addresses) external onlyOwner whenNotPaused {\n    require(_totalGiveawayMonstas.add(_addresses.length) <= MAX_TOTAL_GIVEAWAY_MONSTA);\n    uint given;\n    for (uint i = 0; i < _addresses.length; i++) {\n      if(!_adopters[_addresses[i]]){\n        given++;\n        _adopters[_addresses[i]] = true;\n        emit MonstaAdopted(_addresses[i]);\n      }\n    }\n    _totalGiveawayMonstas = _totalGiveawayMonstas.add(given);\n  }\n  \n  /**\n  * @dev Transfer all BNB held by the contract to the owner.\n  */\n  // SWC-105-Unprotected Ether Withdrawal: L94-197\n  function reclaimBNB() external onlyOwner {\n    owner.transfer(address(this).balance);\n  }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Callisto_Network-Monsta Infinite Inception Security Audit Report/moni-smart-contracts-3303268d5456d51a5f7412be8cfca7e3caf73ed5/contracts/presale/MonstaPresale.sol",
        "vulnerability": "Block Dependency",
        "check": "FP",
        "response": "Answer: Yes\nDescription: The function `adoptMonsta` relies on `now` to set a condition, which is susceptible to minor manipulation by miners, leading to a Block Dependency vulnerability."
    },
    {
        "code_segment": "contract ERC20 is IERC20 {\n\n    using SafeMath for uint256;\n\n\n\n    mapping (address => uint256) private _balances;\n\n\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n\n\n    uint256 private _totalSupply;\n\n\n\n    /**\n\n     * @dev See `IERC20.totalSupply`.\n\n     */\n\n    function totalSupply() public view returns (uint256) {\n\n        return _totalSupply;\n\n    }\n\n\n\n    /**\n\n     * @dev See `IERC20.balanceOf`.\n\n     */\n\n    function balanceOf(address account) public view returns (uint256) {\n\n        return _balances[account];\n\n    }\n\n\n\n    /**\n\n     * @dev See `IERC20.transfer`.\n\n     *\n\n     * Requirements:\n\n     *\n\n     * - `recipient` cannot be the zero address.\n\n     * - the caller must have a balance of at least `amount`.\n\n     */\n\n    function transfer(address recipient, uint256 amount) public returns (bool) {\n\n        _transfer(msg.sender, recipient, amount);\n\n        return true;\n\n    }\n\n\n\n    /**\n\n     * @dev See `IERC20.allowance`.\n\n     */\n\n    function allowance(address owner, address spender) public view returns (uint256) {\n\n        return _allowances[owner][spender];\n\n    }\n\n\n\n    /**\n\n     * @dev See `IERC20.approve`.\n\n     *\n\n     * Requirements:\n\n     *\n\n     * - `spender` cannot be the zero address.\n\n     */\n\n    function approve(address spender, uint256 value) public returns (bool) {\n\n        _approve(msg.sender, spender, value);\n\n        return true;\n\n    }\n\n\n\n    /**\n\n     * @dev See `IERC20.transferFrom`.\n\n     *\n\n     * Emits an `Approval` event indicating the updated allowance. This is not\n\n     * required by the EIP. See the note at the beginning of `ERC20`;\n\n     *\n\n     * Requirements:\n\n     * - `sender` and `recipient` cannot be the zero address.\n\n     * - `sender` must have a balance of at least `value`.\n\n     * - the caller must have allowance for `sender`'s tokens of at least\n\n     * `amount`.\n\n     */\n\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\n\n        _transfer(sender, recipient, amount);\n\n        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount));\n\n        return true;\n\n    }\n\n\n\n    /**\n\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n\n     *\n\n     * This is an alternative to `approve` that can be used as a mitigation for\n\n     * problems described in `IERC20.approve`.\n\n     *\n\n     * Emits an `Approval` event indicating the updated allowance.\n\n     *\n\n     * Requirements:\n\n     *\n\n     * - `spender` cannot be the zero address.\n\n     */\n\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));\n\n        return true;\n\n    }\n\n\n\n    /**\n\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n\n     *\n\n     * This is an alternative to `approve` that can be used as a mitigation for\n\n     * problems described in `IERC20.approve`.\n\n     *\n\n     * Emits an `Approval` event indicating the updated allowance.\n\n     *\n\n     * Requirements:\n\n     *\n\n     * - `spender` cannot be the zero address.\n\n     * - `spender` must have allowance for the caller of at least\n\n     * `subtractedValue`.\n\n     */\n\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue));\n\n        return true;\n\n    }\n\n\n\n    /**\n\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n\n     *\n\n     * This is internal function is equivalent to `transfer`, and can be used to\n\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n\n     *\n\n     * Emits a `Transfer` event.\n\n     *\n\n     * Requirements:\n\n     *\n\n     * - `sender` cannot be the zero address.\n\n     * - `recipient` cannot be the zero address.\n\n     * - `sender` must have a balance of at least `amount`.\n\n     */\n\n    function _transfer(address sender, address recipient, uint256 amount) internal {\n\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n\n\n        _balances[sender] = _balances[sender].sub(amount);\n\n        _balances[recipient] = _balances[recipient].add(amount);\n\n        emit Transfer(sender, recipient, amount);\n\n    }\n\n\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n\n     * the total supply.\n\n     *\n\n     * Emits a `Transfer` event with `from` set to the zero address.\n\n     *\n\n     * Requirements\n\n     *\n\n     * - `to` cannot be the zero address.\n\n     */\n\n    function _mint(address account, uint256 amount) internal {\n\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n\n\n        _totalSupply = _totalSupply.add(amount);\n\n        _balances[account] = _balances[account].add(amount);\n\n        emit Transfer(address(0), account, amount);\n\n    }\n\n\n\n     /**\n\n     * @dev Destroys `amount` tokens from `account`, reducing the\n\n     * total supply.\n\n     *\n\n     * Emits a `Transfer` event with `to` set to the zero address.\n\n     *\n\n     * Requirements\n\n     *\n\n     * - `account` cannot be the zero address.\n\n     * - `account` must have at least `amount` tokens.\n\n     */\n\n    function _burn(address account, uint256 value) internal {\n\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n\n\n        _totalSupply = _totalSupply.sub(value);\n\n        _balances[account] = _balances[account].sub(value);\n\n        emit Transfer(account, address(0), value);\n\n    }\n\n\n\n    /**\n\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\n\n     *\n\n     * This is internal function is equivalent to `approve`, and can be used to\n\n     * e.g. set automatic allowances for certain subsystems, etc.\n\n     *\n\n     * Emits an `Approval` event.\n\n     *\n\n     * Requirements:\n\n     *\n\n     * - `owner` cannot be the zero address.\n\n     * - `spender` cannot be the zero address.\n\n     */\n\n    function _approve(address owner, address spender, uint256 value) internal {\n\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n\n\n        _allowances[owner][spender] = value;\n\n        emit Approval(owner, spender, value);\n\n    }\n\n\n\n    /**\n\n     * @dev Destoys `amount` tokens from `account`.`amount` is then deducted\n\n     * from the caller's allowance.\n\n     *\n\n     * See `_burn` and `_approve`.\n\n     */\n\n    function _burnFrom(address account, uint256 amount) internal {\n\n        _burn(account, amount);\n\n        _approve(account, msg.sender, _allowances[account][msg.sender].sub(amount));\n\n    }\n\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Hacken-Sekuritance/TokenMintERC20Token0x887168120cb89Fb06F3E74Dc4AF20D67dF0977f6/TokenMintERC20Token0x887168120cb89Fb06F3E74Dc4AF20D67dF0977f6.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No\nReason: The contract uses the SafeMath library for arithmetic operations, which prevents integer overflow and underflow."
    },
    {
        "code_segment": "contract AidusToken is ERC20Frozenable, ERC20Detailed {\n\n    constructor()\n    ERC20Detailed(\"AIDUS TOKEN\", \"AIDUS\", 18)\n    public {\n        uint256 supply = 10000000000;\n        uint256 initialSupply = supply * uint(10) ** decimals();\n        _mint(msg.sender, initialSupply);\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/QuillAudits-AIDUS Smart Contract/code/Etherscan-0xa957045A12D270e2eE0dcA9A3340c340e05d4670.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No  \nReason: The solidity version is not specified and modern compilers automatically include overflow checks with SafeMath."
    },
    {
        "code_segment": "contract ERC20 is IERC20 {\n    using SafeMath for uint256;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowed;\n\n    uint256 private _totalSupply;\n\n    /**\n    * @dev Total number of tokens in existence\n    */\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n    * @dev Gets the balance of the specified address.\n    * @param owner The address to query the balance of.\n    * @return An uint256 representing the amount owned by the passed address.\n    */\n    function balanceOf(address owner) public view returns (uint256) {\n        return _balances[owner];\n    }\n\n    /**\n     * @dev Function to check the amount of tokens that an owner allowed to a spender.\n     * @param owner address The address which owns the funds.\n     * @param spender address The address which will spend the funds.\n     * @return A uint256 specifying the amount of tokens still available for the spender.\n     */\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowed[owner][spender];\n    }\n\n    /**\n    * @dev Transfer token for a specified address\n    * @param to The address to transfer to.\n    * @param value The amount to be transferred.\n    */\n    function transfer(address to, uint256 value) public returns (bool) {\n        _transfer(msg.sender, to, value);\n        return true;\n    }\n\n    /**\n     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n     * Beware that changing an allowance with this method brings the risk that someone may use both the old\n     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     */\n    function approve(address spender, uint256 value) public returns (bool) {\n        require(spender != address(0));\n\n        _allowed[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n        return true;\n    }\n\n    /**\n     * @dev Transfer tokens from one address to another.\n     * Note that while this function emits an Approval event, this is not required as per the specification,\n     * and other compliant implementations may not emit the event.\n     * @param from address The address which you want to send tokens from\n     * @param to address The address which you want to transfer to\n     * @param value uint256 the amount of tokens to be transferred\n     */\n    function transferFrom(address from, address to, uint256 value) public returns (bool) {\n        _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);\n        _transfer(from, to, value);\n        emit Approval(from, msg.sender, _allowed[from][msg.sender]);\n        return true;\n    }\n\n    /**\n     * @dev Increase the amount of tokens that an owner allowed to a spender.\n     * approve should be called when allowed_[_spender] == 0. To increment\n     * allowed value is better to use this function to avoid 2 calls (and wait until\n     * the first transaction is mined)\n     * From MonolithDAO Token.sol\n     * Emits an Approval event.\n     * @param spender The address which will spend the funds.\n     * @param addedValue The amount of tokens to increase the allowance by.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n        require(spender != address(0));\n\n        _allowed[msg.sender][spender] = _allowed[msg.sender][spender].add(addedValue);\n        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n        return true;\n    }\n\n    /**\n     * @dev Decrease the amount of tokens that an owner allowed to a spender.\n     * approve should be called when allowed_[_spender] == 0. To decrement\n     * allowed value is better to use this function to avoid 2 calls (and wait until\n     * the first transaction is mined)\n     * From MonolithDAO Token.sol\n     * Emits an Approval event.\n     * @param spender The address which will spend the funds.\n     * @param subtractedValue The amount of tokens to decrease the allowance by.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n        require(spender != address(0));\n\n        _allowed[msg.sender][spender] = _allowed[msg.sender][spender].sub(subtractedValue);\n        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n        return true;\n    }\n\n    /**\n    * @dev Transfer token for a specified addresses\n    * @param from The address to transfer from.\n    * @param to The address to transfer to.\n    * @param value The amount to be transferred.\n    */\n    function _transfer(address from, address to, uint256 value) internal {\n        require(to != address(0));\n\n        _balances[from] = _balances[from].sub(value);\n        _balances[to] = _balances[to].add(value);\n        emit Transfer(from, to, value);\n    }\n\n    /**\n     * @dev Internal function that mints an amount of the token and assigns it to\n     * an account. This encapsulates the modification of balances such that the\n     * proper events are emitted.\n     * @param account The account that will receive the created tokens.\n     * @param value The amount that will be created.\n     */\n    function _mint(address account, uint256 value) internal {\n        require(account != address(0));\n\n        _totalSupply = _totalSupply.add(value);\n        _balances[account] = _balances[account].add(value);\n        emit Transfer(address(0), account, value);\n    }\n\n    /**\n     * @dev Internal function that burns an amount of the token of a given\n     * account.\n     * @param account The account whose tokens will be burnt.\n     * @param value The amount that will be burnt.\n     */\n    function _burn(address account, uint256 value) internal {\n        require(account != address(0));\n\n        _totalSupply = _totalSupply.sub(value);\n        _balances[account] = _balances[account].sub(value);\n        emit Transfer(account, address(0), value);\n    }\n\n    /**\n     * @dev Internal function that burns an amount of the token of a given\n     * account, deducting from the sender's allowance for said account. Uses the\n     * internal burn function.\n     * Emits an Approval event (reflecting the reduced allowance).\n     * @param account The account whose tokens will be burnt.\n     * @param value The amount that will be burnt.\n     */\n    function _burnFrom(address account, uint256 value) internal {\n        _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(value);\n        _burn(account, value);\n        emit Approval(account, msg.sender, _allowed[account][msg.sender]);\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/QuillAudits-AIDUS Smart Contract/code/Etherscan-0xa957045A12D270e2eE0dcA9A3340c340e05d4670.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No\nReason: The code uses SafeMath for uint256 operations which prevents integer overflows."
    },
    {
        "code_segment": "contract ERC20Burnable is ERC20 {\n    /**\n     * @dev Burns a specific amount of tokens.\n     * @param value The amount of token to be burned.\n     */\n    function burn(uint256 value) public {\n        _burn(msg.sender, value);\n    }\n\n    /**\n     * @dev Burns a specific amount of tokens from the target address and decrements allowance\n     * @param from address The address which you want to send tokens from\n     * @param value uint256 The amount of token to be burned\n     */\n    function burnFrom(address from, uint256 value) public {\n        _burnFrom(from, value);\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/QuillAudits-AIDUS Smart Contract/code/Etherscan-0xa957045A12D270e2eE0dcA9A3340c340e05d4670.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No\nReason: The provided code does not include any arithmetic operations that could cause an integer overflow. The burn functions simply call other internal functions to handle the burning process."
    },
    {
        "code_segment": "contract ERC20Frozenable is ERC20Burnable, ERC20Mintable, Ownable {\n    mapping (address => bool) private _frozenAccount;\n    event FrozenFunds(address target, bool frozen);\n\n\n    function frozenAccount(address _address) public view returns(bool isFrozen) {\n        return _frozenAccount[_address];\n    }\n\n    function freezeAccount(address target, bool freeze)  public onlyOwner {\n        require(_frozenAccount[target] != freeze, \"Same as current\");\n        _frozenAccount[target] = freeze;\n        emit FrozenFunds(target, freeze);\n    }\n\n    function _transfer(address from, address to, uint256 value) internal {\n        require(!_frozenAccount[from], \"error - frozen\");\n        require(!_frozenAccount[to], \"error - frozen\");\n        super._transfer(from, to, value);\n    }\n\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/QuillAudits-AIDUS Smart Contract/code/Etherscan-0xa957045A12D270e2eE0dcA9A3340c340e05d4670.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No\nReason: The provided code does not include any arithmetic operations which are typically where integer overflows could occur. The operations shown involve checking and setting boolean states and enforcing ownership rules."
    },
    {
        "code_segment": "contract ERC20Mintable is ERC20, MinterRole {\n    /**\n     * @dev Function to mint tokens\n     * @param to The address that will receive the minted tokens.\n     * @param value The amount of tokens to mint.\n     * @return A boolean that indicates if the operation was successful.\n     */\n    function mint(address to, uint256 value) public onlyMinter returns (bool) {\n        _mint(to, value);\n        return true;\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/QuillAudits-AIDUS Smart Contract/code/Etherscan-0xa957045A12D270e2eE0dcA9A3340c340e05d4670.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No\nReason: The code uses a safemath library converting ERC20 token standards, which handle integer overflow issues."
    },
    {
        "code_segment": "contract DMToken is Vesting {\n\n    string public name = \"DMarket Token\";\n    string public symbol = \"DMT\";\n    uint256 public decimals = 8;\n\n    function DMToken() public {\n        hardCap = 15644283100000000;\n    }\n\n    function multiTransfer(address[] recipients, uint256[] amounts) public {\n        require(recipients.length == amounts.length);\n        for (uint i = 0; i < recipients.length; i++) {\n            transfer(recipients[i], amounts[i]);\n        }\n    }\n\n    function multiVesting(\n        address[] _address,\n        uint256[] _amount,\n        uint256[] _start,\n        uint256[] _end\n    ) public onlyOwner {\n        require(\n            _address.length == _amount.length &&\n            _address.length == _start.length &&\n            _address.length == _end.length\n        );\n        for (uint i = 0; i < _address.length; i++) {\n            addVestingMember(_address[i], _amount[i], _start[i], _end[i]);\n        }\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinfabrik-DMToken Security Audit V2 2019 Updated/code/code.sol",
        "vulnerability": "Assertion Failure",
        "check": "FP",
        "response": "Answer: No\nReason: The code does not contain any assert statements that could cause an assertion failure."
    },
    {
        "code_segment": "contract DMToken is Vesting {\n\n    string public name = \"DMarket Token\";\n    string public symbol = \"DMT\";\n    uint256 public decimals = 8;\n\n    function DMToken() public {\n        hardCap = 15644283100000000;\n    }\n\n    function multiTransfer(address[] recipients, uint256[] amounts) public {\n        require(recipients.length == amounts.length);\n        for (uint i = 0; i < recipients.length; i++) {\n            transfer(recipients[i], amounts[i]);\n        }\n    }\n\n    function multiVesting(\n        address[] _address,\n        uint256[] _amount,\n        uint256[] _start,\n        uint256[] _end\n    ) public onlyOwner {\n        require(\n            _address.length == _amount.length &&\n            _address.length == _start.length &&\n            _address.length == _end.length\n        );\n        for (uint i = 0; i < _address.length; i++) {\n            addVestingMember(_address[i], _amount[i], _start[i], _end[i]);\n        }\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinfabrik-DMToken Security Audit V2 2019 Updated/code/code.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No\nReason: No arithmetic operations like addition or multiplication that would typically cause an integer overflow are performed within the provided code segment."
    },
    {
        "code_segment": "contract DMToken is Vesting {\n\n    string public name = \"DMarket Token\";\n    string public symbol = \"DMT\";\n    uint256 public decimals = 8;\n\n    function DMToken() public {\n        hardCap = 15644283100000000;\n    }\n\n    function multiTransfer(address[] recipients, uint256[] amounts) public {\n        require(recipients.length == amounts.length);\n        for (uint i = 0; i < recipients.length; i++) {\n            transfer(recipients[i], amounts[i]);\n        }\n    }\n\n    function multiVesting(\n        address[] _address,\n        uint256[] _amount,\n        uint256[] _start,\n        uint256[] _end\n    ) public onlyOwner {\n        require(\n            _address.length == _amount.length &&\n            _address.length == _start.length &&\n            _address.length == _end.length\n        );\n        for (uint i = 0; i < _address.length; i++) {\n            addVestingMember(_address[i], _amount[i], _start[i], _end[i]);\n        }\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinfabrik-DMToken Security Audit V2 2019 Updated/code/code.sol",
        "vulnerability": "Assertion Failure",
        "check": "FP",
        "response": "Answer: No\nReason: The provided code uses proper require statements to validate input array lengths before processing. This protects against potential assertion failures as the loops and function calls operate on correctly sized arrays."
    },
    {
        "code_segment": "contract Vesting is MintableToken {\n\n    event VestingMemberAdded(address indexed _address, uint256 _amount, uint _start, uint _end);\n\n    struct _Vesting {\n        uint256 totalSum;     //total amount\n        uint256 start;        //start block\n        uint256 end;          //end block\n        uint256 usedAmount;   //the amount of paid payments\n    }\n\n    mapping (address => _Vesting ) public vestingMembers;\n\n    function addVestingMember(\n        address _address,\n        uint256 _amount,\n        uint256 _start,\n        uint256 _end\n    ) onlyOwner public returns (bool) {\n        require(\n            _address != address(0) &&\n            _amount > 0 &&\n            _start < _end &&\n            vestingMembers[_address].totalSum == 0 &&\n            balances[msg.sender] > _amount\n        );\n\n        balances[msg.sender] = balances[msg.sender].sub(_amount);\n\n        vestingMembers[_address].totalSum = _amount;    //total amount\n        vestingMembers[_address].start = _start;        //start block\n        vestingMembers[_address].end = _end;            //end block\n        vestingMembers[_address].usedAmount = 0;        //the amount of paid payments\n\n        VestingMemberAdded(_address, _amount, _start, _end);\n\n        return true;\n    }\n\n    function currentPart(address _address) private constant returns (uint256) {\n        if (vestingMembers[_address].totalSum == 0 || block.number <= vestingMembers[_address].start) {\n            return 0;\n        }\n        if (block.number >= vestingMembers[_address].end) {\n            return vestingMembers[_address].totalSum.sub(vestingMembers[_address].usedAmount);\n        }\n\n        return vestingMembers[_address].totalSum\n        .mul(block.number - vestingMembers[_address].start)\n        .div(vestingMembers[_address].end - vestingMembers[_address].start)\n        .sub(vestingMembers[_address].usedAmount);\n    }\n\n    function subFromBalance(address _address, uint256 _amount) private returns (uint256) {\n        require(_address != address(0));\n\n        if (vestingMembers[_address].totalSum == 0) {\n            balances[_address] = balances[_address].sub(_amount);\n            return balances[_address];\n        }\n        uint256 summary = balanceOf(_address);\n        require(summary >= _amount);\n\n        if (balances[_address] > _amount) {\n            balances[_address] = balances[_address].sub(_amount);\n        } else {\n            uint256 part = currentPart(_address);\n            if (block.number >= vestingMembers[_address].end) {\n                vestingMembers[_address].totalSum = 0;          //total amount\n                vestingMembers[_address].start = 0;             //start block\n                vestingMembers[_address].end = 0;               //end block\n                vestingMembers[_address].usedAmount = 0;        //the amount of paid payments\n            } else {\n                vestingMembers[_address].usedAmount = vestingMembers[_address].usedAmount.add(part);\n            }\n            balances[_address] = balances[_address].add(part).sub(_amount);\n        }\n\n        return balances[_address];\n    }\n\n    function balanceOf(address _owner) public constant returns (uint256 balance) {\n        if (vestingMembers[_owner].totalSum == 0) {\n            return balances[_owner];\n        } else {\n            return balances[_owner].add(currentPart(_owner));\n        }\n    }\n\n    function transfer(address _to, uint256 _value) public returns (bool) {\n        require(_to != address(0));\n        require(_value <= balanceOf(msg.sender));\n\n        subFromBalance(msg.sender, _value);\n\n        balances[_to] = balances[_to].add(_value);\n        Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n        require(_to != address(0));\n\n        uint256 _allowance = allowed[_from][msg.sender];\n\n        subFromBalance(_from, _value);\n\n        balances[_to] = balances[_to].add(_value);\n        allowed[_from][msg.sender] = _allowance.sub(_value);\n        Transfer(_from, _to, _value);\n        return true;\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinfabrik-DMToken Security Audit V2 2019 Updated/code/code.sol",
        "vulnerability": "Assertion Failure",
        "check": "FP",
        "response": "Answer: No\nReason: The provided smart contract code does not contain any assertion statements that could fail. It uses require statements to validate inputs, which ensure conditions are met or revert the transaction if they are not."
    },
    {
        "code_segment": "contract Vesting is MintableToken {\n\n    event VestingMemberAdded(address indexed _address, uint256 _amount, uint _start, uint _end);\n\n    struct _Vesting {\n        uint256 totalSum;     //total amount\n        uint256 start;        //start block\n        uint256 end;          //end block\n        uint256 usedAmount;   //the amount of paid payments\n    }\n\n    mapping (address => _Vesting ) public vestingMembers;\n\n    function addVestingMember(\n        address _address,\n        uint256 _amount,\n        uint256 _start,\n        uint256 _end\n    ) onlyOwner public returns (bool) {\n        require(\n            _address != address(0) &&\n            _amount > 0 &&\n            _start < _end &&\n            vestingMembers[_address].totalSum == 0 &&\n            balances[msg.sender] > _amount\n        );\n\n        balances[msg.sender] = balances[msg.sender].sub(_amount);\n\n        vestingMembers[_address].totalSum = _amount;    //total amount\n        vestingMembers[_address].start = _start;        //start block\n        vestingMembers[_address].end = _end;            //end block\n        vestingMembers[_address].usedAmount = 0;        //the amount of paid payments\n\n        VestingMemberAdded(_address, _amount, _start, _end);\n\n        return true;\n    }\n\n    function currentPart(address _address) private constant returns (uint256) {\n        if (vestingMembers[_address].totalSum == 0 || block.number <= vestingMembers[_address].start) {\n            return 0;\n        }\n        if (block.number >= vestingMembers[_address].end) {\n            return vestingMembers[_address].totalSum.sub(vestingMembers[_address].usedAmount);\n        }\n\n        return vestingMembers[_address].totalSum\n        .mul(block.number - vestingMembers[_address].start)\n        .div(vestingMembers[_address].end - vestingMembers[_address].start)\n        .sub(vestingMembers[_address].usedAmount);\n    }\n\n    function subFromBalance(address _address, uint256 _amount) private returns (uint256) {\n        require(_address != address(0));\n\n        if (vestingMembers[_address].totalSum == 0) {\n            balances[_address] = balances[_address].sub(_amount);\n            return balances[_address];\n        }\n        uint256 summary = balanceOf(_address);\n        require(summary >= _amount);\n\n        if (balances[_address] > _amount) {\n            balances[_address] = balances[_address].sub(_amount);\n        } else {\n            uint256 part = currentPart(_address);\n            if (block.number >= vestingMembers[_address].end) {\n                vestingMembers[_address].totalSum = 0;          //total amount\n                vestingMembers[_address].start = 0;             //start block\n                vestingMembers[_address].end = 0;               //end block\n                vestingMembers[_address].usedAmount = 0;        //the amount of paid payments\n            } else {\n                vestingMembers[_address].usedAmount = vestingMembers[_address].usedAmount.add(part);\n            }\n            balances[_address] = balances[_address].add(part).sub(_amount);\n        }\n\n        return balances[_address];\n    }\n\n    function balanceOf(address _owner) public constant returns (uint256 balance) {\n        if (vestingMembers[_owner].totalSum == 0) {\n            return balances[_owner];\n        } else {\n            return balances[_owner].add(currentPart(_owner));\n        }\n    }\n\n    function transfer(address _to, uint256 _value) public returns (bool) {\n        require(_to != address(0));\n        require(_value <= balanceOf(msg.sender));\n\n        subFromBalance(msg.sender, _value);\n\n        balances[_to] = balances[_to].add(_value);\n        Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n        require(_to != address(0));\n\n        uint256 _allowance = allowed[_from][msg.sender];\n\n        subFromBalance(_from, _value);\n\n        balances[_to] = balances[_to].add(_value);\n        allowed[_from][msg.sender] = _allowance.sub(_value);\n        Transfer(_from, _to, _value);\n        return true;\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinfabrik-DMToken Security Audit V2 2019 Updated/code/code.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No\nReason: The code uses SafeMath library functions 'add', 'sub', 'mul', and 'div', which handle integer overflow and underflow."
    },
    {
        "code_segment": "contract Vesting is MintableToken {\n\n    event VestingMemberAdded(address indexed _address, uint256 _amount, uint _start, uint _end);\n\n    struct _Vesting {\n        uint256 totalSum;     //total amount\n        uint256 start;        //start block\n        uint256 end;          //end block\n        uint256 usedAmount;   //the amount of paid payments\n    }\n\n    mapping (address => _Vesting ) public vestingMembers;\n\n    function addVestingMember(\n        address _address,\n        uint256 _amount,\n        uint256 _start,\n        uint256 _end\n    ) onlyOwner public returns (bool) {\n        require(\n            _address != address(0) &&\n            _amount > 0 &&\n            _start < _end &&\n            vestingMembers[_address].totalSum == 0 &&\n            balances[msg.sender] > _amount\n        );\n\n        balances[msg.sender] = balances[msg.sender].sub(_amount);\n\n        vestingMembers[_address].totalSum = _amount;    //total amount\n        vestingMembers[_address].start = _start;        //start block\n        vestingMembers[_address].end = _end;            //end block\n        vestingMembers[_address].usedAmount = 0;        //the amount of paid payments\n\n        VestingMemberAdded(_address, _amount, _start, _end);\n\n        return true;\n    }\n\n    function currentPart(address _address) private constant returns (uint256) {\n        if (vestingMembers[_address].totalSum == 0 || block.number <= vestingMembers[_address].start) {\n            return 0;\n        }\n        if (block.number >= vestingMembers[_address].end) {\n            return vestingMembers[_address].totalSum.sub(vestingMembers[_address].usedAmount);\n        }\n\n        return vestingMembers[_address].totalSum\n        .mul(block.number - vestingMembers[_address].start)\n        .div(vestingMembers[_address].end - vestingMembers[_address].start)\n        .sub(vestingMembers[_address].usedAmount);\n    }\n\n    function subFromBalance(address _address, uint256 _amount) private returns (uint256) {\n        require(_address != address(0));\n\n        if (vestingMembers[_address].totalSum == 0) {\n            balances[_address] = balances[_address].sub(_amount);\n            return balances[_address];\n        }\n        uint256 summary = balanceOf(_address);\n        require(summary >= _amount);\n\n        if (balances[_address] > _amount) {\n            balances[_address] = balances[_address].sub(_amount);\n        } else {\n            uint256 part = currentPart(_address);\n            if (block.number >= vestingMembers[_address].end) {\n                vestingMembers[_address].totalSum = 0;          //total amount\n                vestingMembers[_address].start = 0;             //start block\n                vestingMembers[_address].end = 0;               //end block\n                vestingMembers[_address].usedAmount = 0;        //the amount of paid payments\n            } else {\n                vestingMembers[_address].usedAmount = vestingMembers[_address].usedAmount.add(part);\n            }\n            balances[_address] = balances[_address].add(part).sub(_amount);\n        }\n\n        return balances[_address];\n    }\n\n    function balanceOf(address _owner) public constant returns (uint256 balance) {\n        if (vestingMembers[_owner].totalSum == 0) {\n            return balances[_owner];\n        } else {\n            return balances[_owner].add(currentPart(_owner));\n        }\n    }\n\n    function transfer(address _to, uint256 _value) public returns (bool) {\n        require(_to != address(0));\n        require(_value <= balanceOf(msg.sender));\n\n        subFromBalance(msg.sender, _value);\n\n        balances[_to] = balances[_to].add(_value);\n        Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n        require(_to != address(0));\n\n        uint256 _allowance = allowed[_from][msg.sender];\n\n        subFromBalance(_from, _value);\n\n        balances[_to] = balances[_to].add(_value);\n        allowed[_from][msg.sender] = _allowance.sub(_value);\n        Transfer(_from, _to, _value);\n        return true;\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinfabrik-DMToken Security Audit V2 2019 Updated/code/code.sol",
        "vulnerability": "Assertion Failure",
        "check": "FP",
        "response": "Answer: No\nReason: No explicit use of the assert function in the provided code."
    },
    {
        "code_segment": "contract LockedTokens is SafeMath {\n    struct Tokens {\n        uint256 amount;\n        uint256 lockEndTime;\n        bool released;\n    }\n\n    event TokensUnlocked(address _to, uint256 _value);\n\n    IERC20Token public token;\n    address public crowdsaleAddress;\n    mapping(address => Tokens[]) public walletTokens;\n\n    /**\n     * @dev LockedTokens constructor\n     * @param _token ERC20 compatible token contract\n     * @param _crowdsaleAddress Crowdsale contract address\n     */\n    function LockedTokens(IERC20Token _token, address _crowdsaleAddress) public {\n        token = _token;\n        crowdsaleAddress = _crowdsaleAddress;\n    }\n\n    /**\n     * @dev Functions locks tokens\n     * @param _to Wallet address to transfer tokens after _lockEndTime\n     * @param _amount Amount of tokens to lock\n     * @param _lockEndTime End of lock period\n     */\n    function addTokens(address _to, uint256 _amount, uint256 _lockEndTime) external {\n        require(msg.sender == crowdsaleAddress);\n        walletTokens[_to].push(Tokens({amount: _amount, lockEndTime: _lockEndTime, released: false}));\n    }\n\n    /**\n     * @dev Called by owner of locked tokens to release them\n     */\n    function releaseTokens() public {\n        require(walletTokens[msg.sender].length > 0);\n\n        for(uint256 i = 0; i < walletTokens[msg.sender].length; i++) {\n            if(!walletTokens[msg.sender][i].released && now >= walletTokens[msg.sender][i].lockEndTime) {\n                walletTokens[msg.sender][i].released = true;\n                token.transfer(msg.sender, walletTokens[msg.sender][i].amount);\n                TokensUnlocked(msg.sender, walletTokens[msg.sender][i].amount);\n            }\n        }\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/New_Alchemy_Security_Audit-The Abyss DAICO Smart Contract Audit (New)/abyss-daico-21d6232a802cd966b86629cadeac0b7f3816f719/Crowdsale.sol",
        "vulnerability": "Assertion Failure",
        "check": "FP",
        "response": "Answer: No\nReason: The code does not use the assert function, which is necessary for an assertion failure vulnerability."
    },
    {
        "code_segment": "contract ManagedToken is ERC20Token, MultiOwnable {\n    bool public allowTransfers = false;\n    bool public issuanceFinished = false;\n\n    ITokenEventListener public eventListener;\n\n    event AllowTransfersChanged(bool _newState);\n    event Issue(address indexed _to, uint256 _value);\n    event Destroy(address indexed _from, uint256 _value);\n    event IssuanceFinished();\n\n    modifier transfersAllowed() {\n        require(allowTransfers);\n        _;\n    }\n\n    modifier canIssue() {\n        require(!issuanceFinished);\n        _;\n    }\n\n    /**\n     * @dev ManagedToken constructor\n     * @param _listener Token listener(address can be 0x0)\n     * @param _owners Owners list\n     */\n    function ManagedToken(address _listener, address[] _owners) public {\n        if(_listener != address(0)) {\n            eventListener = ITokenEventListener(_listener);\n        }\n        _setOwners(_owners);\n    }\n\n    /**\n     * @dev Enable/disable token transfers. Can be called only by owners\n     * @param _allowTransfers True - allow False - disable\n     */\n    function setAllowTransfers(bool _allowTransfers) external onlyOwner {\n        allowTransfers = _allowTransfers;\n        AllowTransfersChanged(_allowTransfers);\n    }\n\n    /**\n     * @dev Set/remove token event listener\n     * @param _listener Listener address (Contract must implement ITokenEventListener interface)\n     */\n    function setListener(address _listener) public onlyOwner {\n        if(_listener != address(0)) {\n            eventListener = ITokenEventListener(_listener);\n        } else {\n            delete eventListener;\n        }\n    }\n\n    function transfer(address _to, uint256 _value) public transfersAllowed returns (bool) {\n        bool success = super.transfer(_to, _value);\n        if(hasListener() && success) {\n            eventListener.onTokenTransfer(msg.sender, _to, _value);\n        }\n        return success;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) public transfersAllowed returns (bool) {\n        bool success = super.transferFrom(_from, _to, _value);\n        if(hasListener() && success) {\n            eventListener.onTokenTransfer(_from, _to, _value);\n        }\n        return success;\n    }\n\n    function hasListener() internal view returns(bool) {\n        if(eventListener == address(0)) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * @dev Issue tokens to specified wallet\n     * @param _to Wallet address\n     * @param _value Amount of tokens\n     */\n    function issue(address _to, uint256 _value) external onlyOwner canIssue {\n        totalSupply = safeAdd(totalSupply, _value);\n        balances[_to] = safeAdd(balances[_to], _value);\n        Issue(_to, _value);\n        Transfer(address(0), _to, _value);\n    }\n\n    /**\n     * @dev Destroy tokens on specified address (Called by owner or token holder)\n     * @dev Fund contract address must be in the list of owners to burn token during refund\n     * @param _from Wallet address\n     * @param _value Amount of tokens to destroy\n     */\n    function destroy(address _from, uint256 _value) external {\n        require(ownerByAddress[msg.sender] || msg.sender == _from);\n        require(balances[_from] >= _value);\n        totalSupply = safeSub(totalSupply, _value);\n        balances[_from] = safeSub(balances[_from], _value);\n        Transfer(_from, address(0), _value);\n        Destroy(_from, _value);\n    }\n\n    /**\n     * @dev Increase the amount of tokens that an owner allowed to a spender.\n     *\n     * approve should be called when allowed[_spender] == 0. To increment\n     * allowed value is better to use this function to avoid 2 calls (and wait until\n     * the first transaction is mined)\n     * From OpenZeppelin StandardToken.sol\n     * @param _spender The address which will spend the funds.\n     * @param _addedValue The amount of tokens to increase the allowance by.\n     */\n    function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n        allowed[msg.sender][_spender] = safeAdd(allowed[msg.sender][_spender], _addedValue);\n        Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n        return true;\n    }\n\n    /**\n     * @dev Decrease the amount of tokens that an owner allowed to a spender.\n     *\n     * approve should be called when allowed[_spender] == 0. To decrement\n     * allowed value is better to use this function to avoid 2 calls (and wait until\n     * the first transaction is mined)\n     * From OpenZeppelin StandardToken.sol\n     * @param _spender The address which will spend the funds.\n     * @param _subtractedValue The amount of tokens to decrease the allowance by.\n     */\n    function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n        uint oldValue = allowed[msg.sender][_spender];\n        if (_subtractedValue > oldValue) {\n            allowed[msg.sender][_spender] = 0;\n        } else {\n            allowed[msg.sender][_spender] = safeSub(oldValue, _subtractedValue);\n        }\n        Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n        return true;\n    }\n\n    /**\n     * @dev Finish token issuance\n     * @return True if success\n     */\n    function finishIssuance() public onlyOwner returns (bool) {\n        issuanceFinished = true;\n        IssuanceFinished();\n        return true;\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/New_Alchemy_Security_Audit-The Abyss DAICO Smart Contract Audit (New)/abyss-daico-21d6232a802cd966b86629cadeac0b7f3816f719/Crowdsale.sol",
        "vulnerability": "Assertion Failure",
        "check": "FP",
        "response": "Answer: No\nReason: The smart contract does not contain any assertions that could trigger an assertion failure. The conditions are checked using `require`, which will revert the transaction without throwing an assertion error."
    },
    {
        "code_segment": "contract ManagedToken is ERC20Token, MultiOwnable {\n    bool public allowTransfers = false;\n    bool public issuanceFinished = false;\n\n    ITokenEventListener public eventListener;\n\n    event AllowTransfersChanged(bool _newState);\n    event Issue(address indexed _to, uint256 _value);\n    event Destroy(address indexed _from, uint256 _value);\n    event IssuanceFinished();\n\n    modifier transfersAllowed() {\n        require(allowTransfers);\n        _;\n    }\n\n    modifier canIssue() {\n        require(!issuanceFinished);\n        _;\n    }\n\n    /**\n     * @dev ManagedToken constructor\n     * @param _listener Token listener(address can be 0x0)\n     * @param _owners Owners list\n     */\n    function ManagedToken(address _listener, address[] _owners) public {\n        if(_listener != address(0)) {\n            eventListener = ITokenEventListener(_listener);\n        }\n        _setOwners(_owners);\n    }\n\n    /**\n     * @dev Enable/disable token transfers. Can be called only by owners\n     * @param _allowTransfers True - allow False - disable\n     */\n    function setAllowTransfers(bool _allowTransfers) external onlyOwner {\n        allowTransfers = _allowTransfers;\n        AllowTransfersChanged(_allowTransfers);\n    }\n\n    /**\n     * @dev Set/remove token event listener\n     * @param _listener Listener address (Contract must implement ITokenEventListener interface)\n     */\n    function setListener(address _listener) public onlyOwner {\n        if(_listener != address(0)) {\n            eventListener = ITokenEventListener(_listener);\n        } else {\n            delete eventListener;\n        }\n    }\n\n    function transfer(address _to, uint256 _value) public transfersAllowed returns (bool) {\n        bool success = super.transfer(_to, _value);\n        if(hasListener() && success) {\n            eventListener.onTokenTransfer(msg.sender, _to, _value);\n        }\n        return success;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) public transfersAllowed returns (bool) {\n        bool success = super.transferFrom(_from, _to, _value);\n        if(hasListener() && success) {\n            eventListener.onTokenTransfer(_from, _to, _value);\n        }\n        return success;\n    }\n\n    function hasListener() internal view returns(bool) {\n        if(eventListener == address(0)) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * @dev Issue tokens to specified wallet\n     * @param _to Wallet address\n     * @param _value Amount of tokens\n     */\n    function issue(address _to, uint256 _value) external onlyOwner canIssue {\n        totalSupply = safeAdd(totalSupply, _value);\n        balances[_to] = safeAdd(balances[_to], _value);\n        Issue(_to, _value);\n        Transfer(address(0), _to, _value);\n    }\n\n    /**\n     * @dev Destroy tokens on specified address (Called by owner or token holder)\n     * @dev Fund contract address must be in the list of owners to burn token during refund\n     * @param _from Wallet address\n     * @param _value Amount of tokens to destroy\n     */\n    function destroy(address _from, uint256 _value) external {\n        require(ownerByAddress[msg.sender] || msg.sender == _from);\n        require(balances[_from] >= _value);\n        totalSupply = safeSub(totalSupply, _value);\n        balances[_from] = safeSub(balances[_from], _value);\n        Transfer(_from, address(0), _value);\n        Destroy(_from, _value);\n    }\n\n    /**\n     * @dev Increase the amount of tokens that an owner allowed to a spender.\n     *\n     * approve should be called when allowed[_spender] == 0. To increment\n     * allowed value is better to use this function to avoid 2 calls (and wait until\n     * the first transaction is mined)\n     * From OpenZeppelin StandardToken.sol\n     * @param _spender The address which will spend the funds.\n     * @param _addedValue The amount of tokens to increase the allowance by.\n     */\n    function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n        allowed[msg.sender][_spender] = safeAdd(allowed[msg.sender][_spender], _addedValue);\n        Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n        return true;\n    }\n\n    /**\n     * @dev Decrease the amount of tokens that an owner allowed to a spender.\n     *\n     * approve should be called when allowed[_spender] == 0. To decrement\n     * allowed value is better to use this function to avoid 2 calls (and wait until\n     * the first transaction is mined)\n     * From OpenZeppelin StandardToken.sol\n     * @param _spender The address which will spend the funds.\n     * @param _subtractedValue The amount of tokens to decrease the allowance by.\n     */\n    function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n        uint oldValue = allowed[msg.sender][_spender];\n        if (_subtractedValue > oldValue) {\n            allowed[msg.sender][_spender] = 0;\n        } else {\n            allowed[msg.sender][_spender] = safeSub(oldValue, _subtractedValue);\n        }\n        Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n        return true;\n    }\n\n    /**\n     * @dev Finish token issuance\n     * @return True if success\n     */\n    function finishIssuance() public onlyOwner returns (bool) {\n        issuanceFinished = true;\n        IssuanceFinished();\n        return true;\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/New_Alchemy_Security_Audit-The Abyss DAICO Smart Contract Audit (New)/abyss-daico-21d6232a802cd966b86629cadeac0b7f3816f719/Crowdsale.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No\nReason: The code uses safeAdd and safeSub functions for arithmetic operations, mitigating integer overflow risks."
    },
    {
        "code_segment": "contract ManagedToken is ERC20Token, MultiOwnable {\n    bool public allowTransfers = false;\n    bool public issuanceFinished = false;\n\n    ITokenEventListener public eventListener;\n\n    event AllowTransfersChanged(bool _newState);\n    event Issue(address indexed _to, uint256 _value);\n    event Destroy(address indexed _from, uint256 _value);\n    event IssuanceFinished();\n\n    modifier transfersAllowed() {\n        require(allowTransfers);\n        _;\n    }\n\n    modifier canIssue() {\n        require(!issuanceFinished);\n        _;\n    }\n\n    /**\n     * @dev ManagedToken constructor\n     * @param _listener Token listener(address can be 0x0)\n     * @param _owners Owners list\n     */\n    function ManagedToken(address _listener, address[] _owners) public {\n        if(_listener != address(0)) {\n            eventListener = ITokenEventListener(_listener);\n        }\n        _setOwners(_owners);\n    }\n\n    /**\n     * @dev Enable/disable token transfers. Can be called only by owners\n     * @param _allowTransfers True - allow False - disable\n     */\n    function setAllowTransfers(bool _allowTransfers) external onlyOwner {\n        allowTransfers = _allowTransfers;\n        AllowTransfersChanged(_allowTransfers);\n    }\n\n    /**\n     * @dev Set/remove token event listener\n     * @param _listener Listener address (Contract must implement ITokenEventListener interface)\n     */\n    function setListener(address _listener) public onlyOwner {\n        if(_listener != address(0)) {\n            eventListener = ITokenEventListener(_listener);\n        } else {\n            delete eventListener;\n        }\n    }\n\n    function transfer(address _to, uint256 _value) public transfersAllowed returns (bool) {\n        bool success = super.transfer(_to, _value);\n        if(hasListener() && success) {\n            eventListener.onTokenTransfer(msg.sender, _to, _value);\n        }\n        return success;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) public transfersAllowed returns (bool) {\n        bool success = super.transferFrom(_from, _to, _value);\n        if(hasListener() && success) {\n            eventListener.onTokenTransfer(_from, _to, _value);\n        }\n        return success;\n    }\n\n    function hasListener() internal view returns(bool) {\n        if(eventListener == address(0)) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * @dev Issue tokens to specified wallet\n     * @param _to Wallet address\n     * @param _value Amount of tokens\n     */\n    function issue(address _to, uint256 _value) external onlyOwner canIssue {\n        totalSupply = safeAdd(totalSupply, _value);\n        balances[_to] = safeAdd(balances[_to], _value);\n        Issue(_to, _value);\n        Transfer(address(0), _to, _value);\n    }\n\n    /**\n     * @dev Destroy tokens on specified address (Called by owner or token holder)\n     * @dev Fund contract address must be in the list of owners to burn token during refund\n     * @param _from Wallet address\n     * @param _value Amount of tokens to destroy\n     */\n    function destroy(address _from, uint256 _value) external {\n        require(ownerByAddress[msg.sender] || msg.sender == _from);\n        require(balances[_from] >= _value);\n        totalSupply = safeSub(totalSupply, _value);\n        balances[_from] = safeSub(balances[_from], _value);\n        Transfer(_from, address(0), _value);\n        Destroy(_from, _value);\n    }\n\n    /**\n     * @dev Increase the amount of tokens that an owner allowed to a spender.\n     *\n     * approve should be called when allowed[_spender] == 0. To increment\n     * allowed value is better to use this function to avoid 2 calls (and wait until\n     * the first transaction is mined)\n     * From OpenZeppelin StandardToken.sol\n     * @param _spender The address which will spend the funds.\n     * @param _addedValue The amount of tokens to increase the allowance by.\n     */\n    function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n        allowed[msg.sender][_spender] = safeAdd(allowed[msg.sender][_spender], _addedValue);\n        Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n        return true;\n    }\n\n    /**\n     * @dev Decrease the amount of tokens that an owner allowed to a spender.\n     *\n     * approve should be called when allowed[_spender] == 0. To decrement\n     * allowed value is better to use this function to avoid 2 calls (and wait until\n     * the first transaction is mined)\n     * From OpenZeppelin StandardToken.sol\n     * @param _spender The address which will spend the funds.\n     * @param _subtractedValue The amount of tokens to decrease the allowance by.\n     */\n    function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n        uint oldValue = allowed[msg.sender][_spender];\n        if (_subtractedValue > oldValue) {\n            allowed[msg.sender][_spender] = 0;\n        } else {\n            allowed[msg.sender][_spender] = safeSub(oldValue, _subtractedValue);\n        }\n        Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n        return true;\n    }\n\n    /**\n     * @dev Finish token issuance\n     * @return True if success\n     */\n    function finishIssuance() public onlyOwner returns (bool) {\n        issuanceFinished = true;\n        IssuanceFinished();\n        return true;\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/New_Alchemy_Security_Audit-The Abyss DAICO Smart Contract Audit (New)/abyss-daico-21d6232a802cd966b86629cadeac0b7f3816f719/Crowdsale.sol",
        "vulnerability": "Assertion Failure",
        "check": "FP",
        "response": "Answer: No\nReason: The code uses require statements to prevent assertion failures. Each function checks its conditions properly."
    },
    {
        "code_segment": "contract MultiOwnable {\n    address public manager; // address used to set owners\n    address[] public owners;\n    mapping(address => bool) public ownerByAddress;\n\n    event SetOwners(address[] owners);\n\n    modifier onlyOwner() {\n        require(ownerByAddress[msg.sender] == true);\n        _;\n    }\n\n    /**\n     * @dev MultiOwnable constructor sets the manager\n     */\n    function MultiOwnable() public {\n        manager = msg.sender;\n    }\n\n    /**\n     * @dev Function to set owners addresses\n     */\n    function setOwners(address[] _owners) public {\n        require(msg.sender == manager);\n        _setOwners(_owners);\n\n    }\n\n    function _setOwners(address[] _owners) internal {\n        for(uint256 i = 0; i < owners.length; i++) {\n            ownerByAddress[owners[i]] = false;\n        }\n\n\n        for(uint256 j = 0; j < _owners.length; j++) {\n            ownerByAddress[_owners[j]] = true;\n        }\n        owners = _owners;\n        SetOwners(_owners);\n    }\n\n    function getOwners() public constant returns (address[]) {\n        return owners;\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/New_Alchemy_Security_Audit-The Abyss DAICO Smart Contract Audit (New)/abyss-daico-21d6232a802cd966b86629cadeac0b7f3816f719/Crowdsale.sol",
        "vulnerability": "Assertion Failure",
        "check": "FP",
        "response": "Answer: No\nReason: The contract does not use `assert` statements, which are required to trigger an \"Assertion Failure\" vulnerability. The only check present is `require` to validate conditions."
    },
    {
        "code_segment": "contract TransferLimitedToken is ManagedToken {\n    uint256 public constant LIMIT_TRANSFERS_PERIOD = 365 days;\n\n    mapping(address => bool) public limitedWallets;\n    uint256 public limitEndDate;\n    address public limitedWalletsManager;\n    bool public isLimitEnabled;\n\n    modifier onlyManager() {\n        require(msg.sender == limitedWalletsManager);\n        _;\n    }\n\n    /**\n     * @dev Check if transfer between addresses is available\n     * @param _from From address\n     * @param _to To address\n     */\n    modifier canTransfer(address _from, address _to)  {\n        require(now >= limitEndDate || !isLimitEnabled || (!limitedWallets[_from] && !limitedWallets[_to]));\n        _;\n    }\n\n    /**\n     * @dev TransferLimitedToken constructor\n     * @param _limitStartDate Limit start date\n     * @param _listener Token listener(address can be 0x0)\n     * @param _owners Owners list\n     * @param _limitedWalletsManager Address used to add/del wallets from limitedWallets\n     */\n    function TransferLimitedToken(\n        uint256 _limitStartDate,\n        address _listener,\n        address[] _owners,\n        address _limitedWalletsManager\n    ) public ManagedToken(_listener, _owners)\n    {\n        limitEndDate = _limitStartDate + LIMIT_TRANSFERS_PERIOD;\n        isLimitEnabled = true;\n        limitedWalletsManager = _limitedWalletsManager;\n    }\n\n    /**\n     * @dev Add address to limitedWallets\n     * @dev Can be called only by manager\n     */\n    function addLimitedWalletAddress(address _wallet) public {\n        require(msg.sender == limitedWalletsManager || ownerByAddress[msg.sender]);\n        limitedWallets[_wallet] = true;\n    }\n\n    /**\n     * @dev Del address from limitedWallets\n     * @dev Can be called only by manager\n     */\n    function delLimitedWalletAddress(address _wallet) public onlyManager {\n        limitedWallets[_wallet] = false;\n    }\n\n    /**\n     * @dev Disable transfer limit manually. Can be called only by manager\n     */\n    function disableLimit() public onlyManager {\n        isLimitEnabled = false;\n    }\n\n    function transfer(address _to, uint256 _value) public canTransfer(msg.sender, _to) returns (bool) {\n        return super.transfer(_to, _value);\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) public canTransfer(_from, _to) returns (bool) {\n        return super.transferFrom(_from, _to, _value);\n    }\n\n    function approve(address _spender, uint256 _value) public canTransfer(msg.sender, _spender) returns (bool) {\n        return super.approve(_spender,_value);\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/New_Alchemy_Security_Audit-The Abyss DAICO Smart Contract Audit (New)/abyss-daico-21d6232a802cd966b86629cadeac0b7f3816f719/Crowdsale.sol",
        "vulnerability": "Block Dependency",
        "check": "FP",
        "response": "Answer: Yes\nDescription: The contract uses the 'now' or 'block.timestamp' variable to determine transfer eligibility, making it vulnerable to block timestamp manipulation by miners."
    },
    {
        "code_segment": "contract TransferLimitedToken is ManagedToken {\n    uint256 public constant LIMIT_TRANSFERS_PERIOD = 365 days;\n\n    mapping(address => bool) public limitedWallets;\n    uint256 public limitEndDate;\n    address public limitedWalletsManager;\n    bool public isLimitEnabled;\n\n    modifier onlyManager() {\n        require(msg.sender == limitedWalletsManager);\n        _;\n    }\n\n    /**\n     * @dev Check if transfer between addresses is available\n     * @param _from From address\n     * @param _to To address\n     */\n    modifier canTransfer(address _from, address _to)  {\n        require(now >= limitEndDate || !isLimitEnabled || (!limitedWallets[_from] && !limitedWallets[_to]));\n        _;\n    }\n\n    /**\n     * @dev TransferLimitedToken constructor\n     * @param _limitStartDate Limit start date\n     * @param _listener Token listener(address can be 0x0)\n     * @param _owners Owners list\n     * @param _limitedWalletsManager Address used to add/del wallets from limitedWallets\n     */\n    function TransferLimitedToken(\n        uint256 _limitStartDate,\n        address _listener,\n        address[] _owners,\n        address _limitedWalletsManager\n    ) public ManagedToken(_listener, _owners)\n    {\n        limitEndDate = _limitStartDate + LIMIT_TRANSFERS_PERIOD;\n        isLimitEnabled = true;\n        limitedWalletsManager = _limitedWalletsManager;\n    }\n\n    /**\n     * @dev Add address to limitedWallets\n     * @dev Can be called only by manager\n     */\n    function addLimitedWalletAddress(address _wallet) public {\n        require(msg.sender == limitedWalletsManager || ownerByAddress[msg.sender]);\n        limitedWallets[_wallet] = true;\n    }\n\n    /**\n     * @dev Del address from limitedWallets\n     * @dev Can be called only by manager\n     */\n    function delLimitedWalletAddress(address _wallet) public onlyManager {\n        limitedWallets[_wallet] = false;\n    }\n\n    /**\n     * @dev Disable transfer limit manually. Can be called only by manager\n     */\n    function disableLimit() public onlyManager {\n        isLimitEnabled = false;\n    }\n\n    function transfer(address _to, uint256 _value) public canTransfer(msg.sender, _to) returns (bool) {\n        return super.transfer(_to, _value);\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) public canTransfer(_from, _to) returns (bool) {\n        return super.transferFrom(_from, _to, _value);\n    }\n\n    function approve(address _spender, uint256 _value) public canTransfer(msg.sender, _spender) returns (bool) {\n        return super.approve(_spender,_value);\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/New_Alchemy_Security_Audit-The Abyss DAICO Smart Contract Audit (New)/abyss-daico-21d6232a802cd966b86629cadeac0b7f3816f719/Crowdsale.sol",
        "vulnerability": "Assertion Failure",
        "check": "FP",
        "response": "Answer: No\nReason: The code does not contain any assert statements that could lead to assertion failures. The logic relies on require statements, which throw exceptions but do not cause assertion failures."
    },
    {
        "code_segment": "contract TransferLimitedToken is ManagedToken {\n    uint256 public constant LIMIT_TRANSFERS_PERIOD = 365 days;\n\n    mapping(address => bool) public limitedWallets;\n    uint256 public limitEndDate;\n    address public limitedWalletsManager;\n    bool public isLimitEnabled;\n\n    modifier onlyManager() {\n        require(msg.sender == limitedWalletsManager);\n        _;\n    }\n\n    /**\n     * @dev Check if transfer between addresses is available\n     * @param _from From address\n     * @param _to To address\n     */\n    modifier canTransfer(address _from, address _to)  {\n        require(now >= limitEndDate || !isLimitEnabled || (!limitedWallets[_from] && !limitedWallets[_to]));\n        _;\n    }\n\n    /**\n     * @dev TransferLimitedToken constructor\n     * @param _limitStartDate Limit start date\n     * @param _listener Token listener(address can be 0x0)\n     * @param _owners Owners list\n     * @param _limitedWalletsManager Address used to add/del wallets from limitedWallets\n     */\n    function TransferLimitedToken(\n        uint256 _limitStartDate,\n        address _listener,\n        address[] _owners,\n        address _limitedWalletsManager\n    ) public ManagedToken(_listener, _owners)\n    {\n        limitEndDate = _limitStartDate + LIMIT_TRANSFERS_PERIOD;\n        isLimitEnabled = true;\n        limitedWalletsManager = _limitedWalletsManager;\n    }\n\n    /**\n     * @dev Add address to limitedWallets\n     * @dev Can be called only by manager\n     */\n    function addLimitedWalletAddress(address _wallet) public {\n        require(msg.sender == limitedWalletsManager || ownerByAddress[msg.sender]);\n        limitedWallets[_wallet] = true;\n    }\n\n    /**\n     * @dev Del address from limitedWallets\n     * @dev Can be called only by manager\n     */\n    function delLimitedWalletAddress(address _wallet) public onlyManager {\n        limitedWallets[_wallet] = false;\n    }\n\n    /**\n     * @dev Disable transfer limit manually. Can be called only by manager\n     */\n    function disableLimit() public onlyManager {\n        isLimitEnabled = false;\n    }\n\n    function transfer(address _to, uint256 _value) public canTransfer(msg.sender, _to) returns (bool) {\n        return super.transfer(_to, _value);\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) public canTransfer(_from, _to) returns (bool) {\n        return super.transferFrom(_from, _to, _value);\n    }\n\n    function approve(address _spender, uint256 _value) public canTransfer(msg.sender, _spender) returns (bool) {\n        return super.approve(_spender,_value);\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/New_Alchemy_Security_Audit-The Abyss DAICO Smart Contract Audit (New)/abyss-daico-21d6232a802cd966b86629cadeac0b7f3816f719/Crowdsale.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No\nReason: The code uses uint256 for all arithmetic operations, which prevents integer overflow in Solidity 0.8.0 and later, as overflow checks are included by default."
    },
    {
        "code_segment": "contract TransferLimitedToken is ManagedToken {\n    uint256 public constant LIMIT_TRANSFERS_PERIOD = 365 days;\n\n    mapping(address => bool) public limitedWallets;\n    uint256 public limitEndDate;\n    address public limitedWalletsManager;\n    bool public isLimitEnabled;\n\n    modifier onlyManager() {\n        require(msg.sender == limitedWalletsManager);\n        _;\n    }\n\n    /**\n     * @dev Check if transfer between addresses is available\n     * @param _from From address\n     * @param _to To address\n     */\n    modifier canTransfer(address _from, address _to)  {\n        require(now >= limitEndDate || !isLimitEnabled || (!limitedWallets[_from] && !limitedWallets[_to]));\n        _;\n    }\n\n    /**\n     * @dev TransferLimitedToken constructor\n     * @param _limitStartDate Limit start date\n     * @param _listener Token listener(address can be 0x0)\n     * @param _owners Owners list\n     * @param _limitedWalletsManager Address used to add/del wallets from limitedWallets\n     */\n    function TransferLimitedToken(\n        uint256 _limitStartDate,\n        address _listener,\n        address[] _owners,\n        address _limitedWalletsManager\n    ) public ManagedToken(_listener, _owners)\n    {\n        limitEndDate = _limitStartDate + LIMIT_TRANSFERS_PERIOD;\n        isLimitEnabled = true;\n        limitedWalletsManager = _limitedWalletsManager;\n    }\n\n    /**\n     * @dev Add address to limitedWallets\n     * @dev Can be called only by manager\n     */\n    function addLimitedWalletAddress(address _wallet) public {\n        require(msg.sender == limitedWalletsManager || ownerByAddress[msg.sender]);\n        limitedWallets[_wallet] = true;\n    }\n\n    /**\n     * @dev Del address from limitedWallets\n     * @dev Can be called only by manager\n     */\n    function delLimitedWalletAddress(address _wallet) public onlyManager {\n        limitedWallets[_wallet] = false;\n    }\n\n    /**\n     * @dev Disable transfer limit manually. Can be called only by manager\n     */\n    function disableLimit() public onlyManager {\n        isLimitEnabled = false;\n    }\n\n    function transfer(address _to, uint256 _value) public canTransfer(msg.sender, _to) returns (bool) {\n        return super.transfer(_to, _value);\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) public canTransfer(_from, _to) returns (bool) {\n        return super.transferFrom(_from, _to, _value);\n    }\n\n    function approve(address _spender, uint256 _value) public canTransfer(msg.sender, _spender) returns (bool) {\n        return super.approve(_spender,_value);\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/New_Alchemy_Security_Audit-The Abyss DAICO Smart Contract Audit (New)/abyss-daico-21d6232a802cd966b86629cadeac0b7f3816f719/Crowdsale.sol",
        "vulnerability": "Assertion Failure",
        "check": "FP",
        "response": "Answer: No\nReason: The contract uses `require` statements to enforce conditions that prevent any possible assertion failures."
    },
    {
        "code_segment": "contract TransferLimitedToken is ManagedToken {\n    uint256 public constant LIMIT_TRANSFERS_PERIOD = 365 days;\n\n    mapping(address => bool) public limitedWallets;\n    uint256 public limitEndDate;\n    address public limitedWalletsManager;\n    bool public isLimitEnabled;\n\n    modifier onlyManager() {\n        require(msg.sender == limitedWalletsManager);\n        _;\n    }\n\n    /**\n     * @dev Check if transfer between addresses is available\n     * @param _from From address\n     * @param _to To address\n     */\n    modifier canTransfer(address _from, address _to)  {\n        require(now >= limitEndDate || !isLimitEnabled || (!limitedWallets[_from] && !limitedWallets[_to]));\n        _;\n    }\n\n    /**\n     * @dev TransferLimitedToken constructor\n     * @param _limitStartDate Limit start date\n     * @param _listener Token listener(address can be 0x0)\n     * @param _owners Owners list\n     * @param _limitedWalletsManager Address used to add/del wallets from limitedWallets\n     */\n    function TransferLimitedToken(\n        uint256 _limitStartDate,\n        address _listener,\n        address[] _owners,\n        address _limitedWalletsManager\n    ) public ManagedToken(_listener, _owners)\n    {\n        limitEndDate = _limitStartDate + LIMIT_TRANSFERS_PERIOD;\n        isLimitEnabled = true;\n        limitedWalletsManager = _limitedWalletsManager;\n    }\n\n    /**\n     * @dev Add address to limitedWallets\n     * @dev Can be called only by manager\n     */\n    function addLimitedWalletAddress(address _wallet) public {\n        require(msg.sender == limitedWalletsManager || ownerByAddress[msg.sender]);\n        limitedWallets[_wallet] = true;\n    }\n\n    /**\n     * @dev Del address from limitedWallets\n     * @dev Can be called only by manager\n     */\n    function delLimitedWalletAddress(address _wallet) public onlyManager {\n        limitedWallets[_wallet] = false;\n    }\n\n    /**\n     * @dev Disable transfer limit manually. Can be called only by manager\n     */\n    function disableLimit() public onlyManager {\n        isLimitEnabled = false;\n    }\n\n    function transfer(address _to, uint256 _value) public canTransfer(msg.sender, _to) returns (bool) {\n        return super.transfer(_to, _value);\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) public canTransfer(_from, _to) returns (bool) {\n        return super.transferFrom(_from, _to, _value);\n    }\n\n    function approve(address _spender, uint256 _value) public canTransfer(msg.sender, _spender) returns (bool) {\n        return super.approve(_spender,_value);\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/New_Alchemy_Security_Audit-The Abyss DAICO Smart Contract Audit (New)/abyss-daico-21d6232a802cd966b86629cadeac0b7f3816f719/Crowdsale.sol",
        "vulnerability": "Block Dependency",
        "check": "FP",
        "response": "Answer: Yes\nDescription: The code relies on the `now` (or `block.timestamp`) to enforce the transfer limitations, creating potential block dependency as miners can manipulate the timestamp."
    },
    {
        "code_segment": "contract BMON_Z1 is IERC20, Ownable {\n\n    string private constant _name = \"Binamon Z1 Planet\";\n    string private constant _symbol = \"BMON-Z1\";\n    uint8 private constant _decimals = 18;\n    uint256 private _totalSupply = 3 * 10**8 * 10**18;\n\n    mapping(address => uint256) private balances;\n    mapping(address => mapping (address => uint256)) private allowed;\n    mapping(address => address) private boosterBuyingAllowed;\n\n    // listing restrictions\n    uint256 private restrictionLiftTime;\n    uint256 private maxRestrictionAmount = 3 * 10**9 * 10**18;\n    mapping (address => bool) private isBlacklisted;\n    mapping (address => uint256) private lastTx;\n    // end restrictions\n\n    using SafeMath for uint256;\n\n    enum State {\n        Locked,\n        Restricted, // Bot protection for liquidity pool\n        Unlocked\n    }\n    State public state;\n\n    constructor() {\n        state = State.Locked;\n        balances[msg.sender] = _totalSupply;\n        emit Transfer(address(0), msg.sender, _totalSupply);\n    }\n\n    function name() public pure returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public pure returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() public pure returns (uint8) {\n        return _decimals;\n    }\n\n    function totalSupply() public override view returns (uint256) {\n\t    return _totalSupply;\n    }\n\n    function balanceOf(address tokenOwner) public override view returns (uint256) {\n        return balances[tokenOwner];\n    }\n\n    function transfer(address receiver, uint256 numTokens) public override launchRestrict(msg.sender, receiver, numTokens) returns (bool) {\n        require(numTokens > 0, \"Transfer amount must be greater than zero\");\n        require(numTokens <= balances[msg.sender]);\n        balances[msg.sender] = balances[msg.sender].sub(numTokens);\n        balances[receiver] = balances[receiver].add(numTokens);\n        emit Transfer(msg.sender, receiver, numTokens);\n        return true;\n    }\n//SWC-100-Function Default Visibility: L104\n    function approve(address delegate, uint256 numTokens) public override returns (bool) {\n        allowed[msg.sender][delegate] = numTokens;\n        emit Approval(msg.sender, delegate, numTokens);\n        return true;\n    }\n\n    function allowance(address owner, address delegate) public override view returns (uint256) {\n        return allowed[owner][delegate];\n    }\n\n    function transferFrom(address owner, address receiver, uint256 numTokens) public override launchRestrict(owner, receiver, numTokens) returns (bool) {\n        require(numTokens <= balances[owner]);\n        require(boosterBuyingAllowed[owner] == msg.sender || numTokens <= allowed[owner][msg.sender]);\n\n        balances[owner] = balances[owner].sub(numTokens);\n        if (boosterBuyingAllowed[owner] != msg.sender) {\n            allowed[owner][msg.sender] = allowed[owner][msg.sender].sub(numTokens);\n            balances[receiver] = balances[receiver].add(numTokens);\n            emit Transfer(owner, receiver, numTokens);\n        } else {\n            _totalSupply = _totalSupply.sub(numTokens);\n            emit Transfer(owner, address(0), numTokens);\n        }\n        return true;\n    }\n\n    function boosterBuyingAllowance(address owner) public view returns (bool) {\n        return boosterBuyingAllowance(owner, msg.sender);\n    }\n\n    function boosterBuyingAllowance(address owner, address delegate) public view returns (bool) {\n        if (boosterBuyingAllowed[owner] == delegate) return true;\n        else return false;\n    }\n\n    function allowBuyingBoosters(address bmonc) public returns (bool) {\n        boosterBuyingAllowed[msg.sender] = bmonc;\n        return true;\n    }\n\n    function burn(uint256 numTokens) public onlyOwner returns(bool) {\n        require(numTokens <= balances[msg.sender]);\n        balances[msg.sender] = balances[msg.sender].sub(numTokens);\n        _totalSupply = _totalSupply.sub(numTokens);\n        emit Transfer(msg.sender, address(0), numTokens);\n        return true;\n    }\n\n    // Security from bots\n\n    // enable/disable works only once, token never returns to Locked\n    function setBotProtection(bool enable) public onlyOwner() {\n        if (enable && state == State.Locked) state = State.Restricted;\n        if (!enable) state = State.Unlocked;\n    }\n\n    function setRestrictionAmount(uint256 amount) public onlyOwner() {\n        maxRestrictionAmount = amount;\n    }\n\n    function blacklistAccount(address account, bool ban) public onlyOwner() {\n        isBlacklisted[account] = ban;\n    }\n\n    modifier launchRestrict(address sender, address recipient, uint256 amount) {\n        if (state == State.Locked) {\n            require(sender == owner(), \"Tokens are locked\");\n        }\n        if (state == State.Restricted) {\n            require(amount <= maxRestrictionAmount, \"Amount greater than max limit in restricted mode\");\n            require(lastTx[sender].add(60) <= block.timestamp && lastTx[recipient].add(60) <= block.timestamp, \"BMON: only one tx/min in restricted mode\");\n            lastTx[sender] = block.timestamp;\n            lastTx[recipient] = block.timestamp;\n        }\n        if (state == State.Unlocked) {\n            if (isBlacklisted[recipient]) {\n                require(lastTx[recipient] + 30 days <= block.timestamp, \"Only one tx/month in banned mode\");\n                lastTx[recipient] = block.timestamp;\n            } else if (isBlacklisted[sender]) {\n                require(lastTx[sender] + 30 days <= block.timestamp, \"Only one tx/month in banned mode\");\n                lastTx[sender] = block.timestamp;\n            }\n        }\n        _;\n    }\n\n    // Bot security end\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/QuillAudits-Binamon Z1 Smart Contract/code/BMON_Z1.sol",
        "vulnerability": "Block Dependency",
        "check": "FP",
        "response": "Answer: No  \nReason: There are no calculations or decisions made in the contract based on any current block details (like block number, block hash, or block timestamp) that can cause block dependency vulnerability."
    },
    {
        "code_segment": "contract StandardToken is ERC20, BasicToken {\n\n  mapping (address => mapping (address => uint256)) internal allowed;\n\n\n  /**\n   * @dev Transfer tokens from one address to another\n   * @param _from address The address which you want to send tokens from\n   * @param _to address The address which you want to transfer to\n   * @param _value uint256 the amount of tokens to be transferred\n   */\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value <= balances[_from]);\n    require(_value <= allowed[_from][msg.sender]);\n\n    balances[_from] = balances[_from].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n    Transfer(_from, _to, _value);\n    return true;\n  }\n\n  /**\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n   *\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   * @param _spender The address which will spend the funds.\n   * @param _value The amount of tokens to be spent.\n   */\n  function approve(address _spender, uint256 _value) public returns (bool) {\n    allowed[msg.sender][_spender] = _value;\n    Approval(msg.sender, _spender, _value);\n    return true;\n  }\n\n  /**\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n   * @param _owner address The address which owns the funds.\n   * @param _spender address The address which will spend the funds.\n   * @return A uint256 specifying the amount of tokens still available for the spender.\n   */\n  function allowance(address _owner, address _spender) public view returns (uint256) {\n    return allowed[_owner][_spender];\n  }\n\n  /**\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\n   *\n   * approve should be called when allowed[_spender] == 0. To increment\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _addedValue The amount of tokens to increase the allowance by.\n   */\n  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n  /**\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n   *\n   * approve should be called when allowed[_spender] == 0. To decrement\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n   */\n  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n    uint oldValue = allowed[msg.sender][_spender];\n    if (_subtractedValue > oldValue) {\n      allowed[msg.sender][_spender] = 0;\n    } else {\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n    }\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/TokenProxy.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No\nReason: The code uses SafeMath's .add and .sub methods to handle arithmetic operations, preventing integer overflow vulnerabilities."
    },
    {
        "code_segment": "contract StandardToken is ERC20, BasicToken {\n\n  mapping (address => mapping (address => uint256)) internal allowed;\n\n\n  /**\n   * @dev Transfer tokens from one address to another\n   * @param _from address The address which you want to send tokens from\n   * @param _to address The address which you want to transfer to\n   * @param _value uint256 the amount of tokens to be transferred\n   */\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value <= balances[_from]);\n    require(_value <= allowed[_from][msg.sender]);\n\n    balances[_from] = balances[_from].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n    Transfer(_from, _to, _value);\n    return true;\n  }\n\n  /**\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n   *\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   * @param _spender The address which will spend the funds.\n   * @param _value The amount of tokens to be spent.\n   */\n  function approve(address _spender, uint256 _value) public returns (bool) {\n    allowed[msg.sender][_spender] = _value;\n    Approval(msg.sender, _spender, _value);\n    return true;\n  }\n\n  /**\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n   * @param _owner address The address which owns the funds.\n   * @param _spender address The address which will spend the funds.\n   * @return A uint256 specifying the amount of tokens still available for the spender.\n   */\n  function allowance(address _owner, address _spender) public view returns (uint256) {\n    return allowed[_owner][_spender];\n  }\n\n  /**\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\n   *\n   * approve should be called when allowed[_spender] == 0. To increment\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _addedValue The amount of tokens to increase the allowance by.\n   */\n  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n  /**\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n   *\n   * approve should be called when allowed[_spender] == 0. To decrement\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n   */\n  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n    uint oldValue = allowed[msg.sender][_spender];\n    if (_subtractedValue > oldValue) {\n      allowed[msg.sender][_spender] = 0;\n    } else {\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n    }\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/TokenProxy.sol",
        "vulnerability": "Assertion Failure",
        "check": "FP",
        "response": "Answer: No\nReason: The contract code uses `require` statements for checks and doesn't have assert statements that could lead to assertion failures."
    },
    {
        "code_segment": "contract TokenProxy is StandardToken {\n\n    ERC20Basic public TOKEN;\n\n    mapping(address => address) private gates;\n\n\n    event GateOpened(address indexed gate, address indexed user);\n\n    event Minted(address indexed to, uint256 amount);\n\n    event Burned(address indexed from, uint256 amount);\n\n    function TokenProxy(ERC20Basic _token) public {\n        TOKEN = _token;\n    }\n\n    function getGateAddress(address _user) external view returns (address) {\n        return gates[_user];\n    }\n\n    \n    function openGate() external {\n        address user = msg.sender;\n\n        // Do not allow creating more than one Gate per User.\n        require(gates[user] == 0);\n\n        // Create new Gate.\n        address gate = new Gate(TOKEN, this);\n\n        // Remember User - Gate relationship.\n        gates[user] = gate;\n\n        GateOpened(gate, user);\n    }\n\n    function transferFromGate() external {\n        address user = msg.sender;\n\n        address gate = gates[user];\n\n        // Make sure the User's Gate exists.\n        require(gate != 0);\n\n        uint256 value = TOKEN.balanceOf(gate);\n\n        Gate(gate).transferToProxy(value);\n\n        // Handle the information about the amount of migrated tokens.\n        // This is a trusted information becase it comes from the Gate.\n        totalSupply_ += value;\n        balances[user] += value;\n\n        Minted(user, value);\n    }\n\n    function withdraw(uint256 _value) external {\n      withdrawTo(_value, msg.sender);\n    }\n\n    function withdrawTo(uint256 _value, address _destination) public {\n        address user = msg.sender;\n        uint256 balance = balances[user];\n        require(_value <= balance);\n\n        balances[user] = (balance - _value);\n        totalSupply_ -= _value;\n\n        TOKEN.transfer(_destination, _value);\n\n        Burned(user, _value);\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/TokenProxy.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: Yes\nDescription: There is a potential integer overflow in the `totalSupply_ += value;` and `balances[user] += value;` statements in the `transferFromGate` function."
    },
    {
        "code_segment": "contract TokenProxy is StandardToken {\n\n    ERC20Basic public TOKEN;\n\n    mapping(address => address) private gates;\n\n\n    event GateOpened(address indexed gate, address indexed user);\n\n    event Minted(address indexed to, uint256 amount);\n\n    event Burned(address indexed from, uint256 amount);\n\n    function TokenProxy(ERC20Basic _token) public {\n        TOKEN = _token;\n    }\n\n    function getGateAddress(address _user) external view returns (address) {\n        return gates[_user];\n    }\n\n    \n    function openGate() external {\n        address user = msg.sender;\n\n        // Do not allow creating more than one Gate per User.\n        require(gates[user] == 0);\n\n        // Create new Gate.\n        address gate = new Gate(TOKEN, this);\n\n        // Remember User - Gate relationship.\n        gates[user] = gate;\n\n        GateOpened(gate, user);\n    }\n\n    function transferFromGate() external {\n        address user = msg.sender;\n\n        address gate = gates[user];\n\n        // Make sure the User's Gate exists.\n        require(gate != 0);\n\n        uint256 value = TOKEN.balanceOf(gate);\n\n        Gate(gate).transferToProxy(value);\n\n        // Handle the information about the amount of migrated tokens.\n        // This is a trusted information becase it comes from the Gate.\n        totalSupply_ += value;\n        balances[user] += value;\n\n        Minted(user, value);\n    }\n\n    function withdraw(uint256 _value) external {\n      withdrawTo(_value, msg.sender);\n    }\n\n    function withdrawTo(uint256 _value, address _destination) public {\n        address user = msg.sender;\n        uint256 balance = balances[user];\n        require(_value <= balance);\n\n        balances[user] = (balance - _value);\n        totalSupply_ -= _value;\n\n        TOKEN.transfer(_destination, _value);\n\n        Burned(user, _value);\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/TokenProxy.sol",
        "vulnerability": "Assertion Failure",
        "check": "FP",
        "response": "Answer: Yes\nDescription: The `require(gates[user] == 0)` statement in the `openGate` function uses `0` instead of `address(0)`, leading to an assertion failure when comparing an address directly with an integer."
    },
    {
        "code_segment": "contract GolemNetworkTokenBatching is TokenProxy {\n\n    string public constant name = \"Golem Network Token Batching\";\n    string public constant symbol = \"GNTB\";\n    uint8 public constant decimals = 18;\n\n\n    event BatchTransfer(address indexed from, address indexed to, uint256 value,\n        uint64 closureTime);\n\n    function GolemNetworkTokenBatching(ERC20Basic _gntToken) TokenProxy(_gntToken) public {\n    }\n\n    function batchTransfer(bytes32[] payments, uint64 closureTime) external {\n        require(block.timestamp >= closureTime);\n\n        uint balance = balances[msg.sender];\n\n        for (uint i = 0; i < payments.length; ++i) {\n            // A payment contains compressed data:\n            // first 96 bits (12 bytes) is a value,\n            // following 160 bits (20 bytes) is an address.\n            bytes32 payment = payments[i];\n            address addr = address(payment);\n            uint v = uint(payment) / 2**160;\n            require(v <= balance);\n            balances[addr] += v;\n            balance -= v;\n            BatchTransfer(msg.sender, addr, v, closureTime);\n        }\n\n        balances[msg.sender] = balance;\n    }\n\n    function transferAndCall(address to, uint256 value, bytes data) external {\n      // Transfer always returns true so no need to check return value\n      transfer(to, value);\n\n      // No need to check whether recipient is a contract, this method is\n      // supposed to used only with contract recipients\n      ReceivingContract(to).onTokenReceived(msg.sender, value, data);\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GolemNetworkTokenBatching.sol",
        "vulnerability": "Block Dependency",
        "check": "FP",
        "response": "Answer: Yes\nDescription: `batchTransfer` function depends on `block.timestamp` for closure time checks, which introduces block dependency as miners can manipulate the `timestamp` minimally."
    },
    {
        "code_segment": "contract GolemNetworkTokenBatching is TokenProxy {\n\n    string public constant name = \"Golem Network Token Batching\";\n    string public constant symbol = \"GNTB\";\n    uint8 public constant decimals = 18;\n\n\n    event BatchTransfer(address indexed from, address indexed to, uint256 value,\n        uint64 closureTime);\n\n    function GolemNetworkTokenBatching(ERC20Basic _gntToken) TokenProxy(_gntToken) public {\n    }\n\n    function batchTransfer(bytes32[] payments, uint64 closureTime) external {\n        require(block.timestamp >= closureTime);\n\n        uint balance = balances[msg.sender];\n\n        for (uint i = 0; i < payments.length; ++i) {\n            // A payment contains compressed data:\n            // first 96 bits (12 bytes) is a value,\n            // following 160 bits (20 bytes) is an address.\n            bytes32 payment = payments[i];\n            address addr = address(payment);\n            uint v = uint(payment) / 2**160;\n            require(v <= balance);\n            balances[addr] += v;\n            balance -= v;\n            BatchTransfer(msg.sender, addr, v, closureTime);\n        }\n\n        balances[msg.sender] = balance;\n    }\n\n    function transferAndCall(address to, uint256 value, bytes data) external {\n      // Transfer always returns true so no need to check return value\n      transfer(to, value);\n\n      // No need to check whether recipient is a contract, this method is\n      // supposed to used only with contract recipients\n      ReceivingContract(to).onTokenReceived(msg.sender, value, data);\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GolemNetworkTokenBatching.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: Yes\nDescription: The potential integer overflow/underflow occurs when adding to `balances[addr]` and subtracting from `balance` without checked arithmetic."
    },
    {
        "code_segment": "contract GolemNetworkTokenBatching is TokenProxy {\n\n    string public constant name = \"Golem Network Token Batching\";\n    string public constant symbol = \"GNTB\";\n    uint8 public constant decimals = 18;\n\n\n    event BatchTransfer(address indexed from, address indexed to, uint256 value,\n        uint64 closureTime);\n\n    function GolemNetworkTokenBatching(ERC20Basic _gntToken) TokenProxy(_gntToken) public {\n    }\n\n    function batchTransfer(bytes32[] payments, uint64 closureTime) external {\n        require(block.timestamp >= closureTime);\n\n        uint balance = balances[msg.sender];\n\n        for (uint i = 0; i < payments.length; ++i) {\n            // A payment contains compressed data:\n            // first 96 bits (12 bytes) is a value,\n            // following 160 bits (20 bytes) is an address.\n            bytes32 payment = payments[i];\n            address addr = address(payment);\n            uint v = uint(payment) / 2**160;\n            require(v <= balance);\n            balances[addr] += v;\n            balance -= v;\n            BatchTransfer(msg.sender, addr, v, closureTime);\n        }\n\n        balances[msg.sender] = balance;\n    }\n\n    function transferAndCall(address to, uint256 value, bytes data) external {\n      // Transfer always returns true so no need to check return value\n      transfer(to, value);\n\n      // No need to check whether recipient is a contract, this method is\n      // supposed to used only with contract recipients\n      ReceivingContract(to).onTokenReceived(msg.sender, value, data);\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GolemNetworkTokenBatching.sol",
        "vulnerability": "Assertion Failure",
        "check": "FP",
        "response": "Answer: No\nReason: The code does not contain any assertions (`assert`) which could directly lead to an assertion failure vulnerability."
    },
    {
        "code_segment": "contract StandardToken is ERC20, BasicToken {\n\n  mapping (address => mapping (address => uint256)) internal allowed;\n\n\n  /**\n   * @dev Transfer tokens from one address to another\n   * @param _from address The address which you want to send tokens from\n   * @param _to address The address which you want to transfer to\n   * @param _value uint256 the amount of tokens to be transferred\n   */\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value <= balances[_from]);\n    require(_value <= allowed[_from][msg.sender]);\n\n    balances[_from] = balances[_from].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n    Transfer(_from, _to, _value);\n    return true;\n  }\n\n  /**\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n   *\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   * @param _spender The address which will spend the funds.\n   * @param _value The amount of tokens to be spent.\n   */\n  function approve(address _spender, uint256 _value) public returns (bool) {\n    allowed[msg.sender][_spender] = _value;\n    Approval(msg.sender, _spender, _value);\n    return true;\n  }\n\n  /**\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n   * @param _owner address The address which owns the funds.\n   * @param _spender address The address which will spend the funds.\n   * @return A uint256 specifying the amount of tokens still available for the spender.\n   */\n  function allowance(address _owner, address _spender) public view returns (uint256) {\n    return allowed[_owner][_spender];\n  }\n\n  /**\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\n   *\n   * approve should be called when allowed[_spender] == 0. To increment\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _addedValue The amount of tokens to increase the allowance by.\n   */\n  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n  /**\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n   *\n   * approve should be called when allowed[_spender] == 0. To decrement\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n   */\n  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n    uint oldValue = allowed[msg.sender][_spender];\n    if (_subtractedValue > oldValue) {\n      allowed[msg.sender][_spender] = 0;\n    } else {\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n    }\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GolemNetworkTokenBatching.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No\nReason: The code uses SafeMath's `.sub()` and `.add()` functions which include checks to prevent integer overflow and underflow."
    },
    {
        "code_segment": "contract StandardToken is ERC20, BasicToken {\n\n  mapping (address => mapping (address => uint256)) internal allowed;\n\n\n  /**\n   * @dev Transfer tokens from one address to another\n   * @param _from address The address which you want to send tokens from\n   * @param _to address The address which you want to transfer to\n   * @param _value uint256 the amount of tokens to be transferred\n   */\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value <= balances[_from]);\n    require(_value <= allowed[_from][msg.sender]);\n\n    balances[_from] = balances[_from].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n    Transfer(_from, _to, _value);\n    return true;\n  }\n\n  /**\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n   *\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   * @param _spender The address which will spend the funds.\n   * @param _value The amount of tokens to be spent.\n   */\n  function approve(address _spender, uint256 _value) public returns (bool) {\n    allowed[msg.sender][_spender] = _value;\n    Approval(msg.sender, _spender, _value);\n    return true;\n  }\n\n  /**\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n   * @param _owner address The address which owns the funds.\n   * @param _spender address The address which will spend the funds.\n   * @return A uint256 specifying the amount of tokens still available for the spender.\n   */\n  function allowance(address _owner, address _spender) public view returns (uint256) {\n    return allowed[_owner][_spender];\n  }\n\n  /**\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\n   *\n   * approve should be called when allowed[_spender] == 0. To increment\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _addedValue The amount of tokens to increase the allowance by.\n   */\n  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n  /**\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n   *\n   * approve should be called when allowed[_spender] == 0. To decrement\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n   */\n  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n    uint oldValue = allowed[msg.sender][_spender];\n    if (_subtractedValue > oldValue) {\n      allowed[msg.sender][_spender] = 0;\n    } else {\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n    }\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GolemNetworkTokenBatching.sol",
        "vulnerability": "Assertion Failure",
        "check": "FP",
        "response": "Answer: No\nReason: The code has checks in place to ensure balances and allowances are sufficient before transactions occur, preventing assertion failures."
    },
    {
        "code_segment": "contract TokenProxy is StandardToken {\n\n    ERC20Basic public TOKEN;\n\n    mapping(address => address) private gates;\n\n\n    event GateOpened(address indexed gate, address indexed user);\n\n    event Minted(address indexed to, uint256 amount);\n\n    event Burned(address indexed from, uint256 amount);\n\n    function TokenProxy(ERC20Basic _token) public {\n        TOKEN = _token;\n    }\n\n    function getGateAddress(address _user) external view returns (address) {\n        return gates[_user];\n    }\n\n    \n    function openGate() external {\n        address user = msg.sender;\n\n        // Do not allow creating more than one Gate per User.\n        require(gates[user] == 0);\n\n        // Create new Gate.\n        address gate = new Gate(TOKEN, this);\n\n        // Remember User - Gate relationship.\n        gates[user] = gate;\n\n        GateOpened(gate, user);\n    }\n\n    function transferFromGate() external {\n        address user = msg.sender;\n\n        address gate = gates[user];\n\n        // Make sure the User's Gate exists.\n        require(gate != 0);\n\n        uint256 value = TOKEN.balanceOf(gate);\n\n        Gate(gate).transferToProxy(value);\n\n        // Handle the information about the amount of migrated tokens.\n        // This is a trusted information becase it comes from the Gate.\n        totalSupply_ += value;\n        balances[user] += value;\n\n        Minted(user, value);\n    }\n\n    function withdraw(uint256 _value) external {\n      withdrawTo(_value, msg.sender);\n    }\n\n    function withdrawTo(uint256 _value, address _destination) public {\n        address user = msg.sender;\n        uint256 balance = balances[user];\n        require(_value <= balance);\n\n        balances[user] = (balance - _value);\n        totalSupply_ -= _value;\n\n        TOKEN.transfer(_destination, _value);\n\n        Burned(user, _value);\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GolemNetworkTokenBatching.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: Yes\nDescription: The operations \"totalSupply_ += value;\" and \"balances[user] += value;\" may cause an integer overflow if 'value' is large enough."
    },
    {
        "code_segment": "contract TokenProxy is StandardToken {\n\n    ERC20Basic public TOKEN;\n\n    mapping(address => address) private gates;\n\n\n    event GateOpened(address indexed gate, address indexed user);\n\n    event Minted(address indexed to, uint256 amount);\n\n    event Burned(address indexed from, uint256 amount);\n\n    function TokenProxy(ERC20Basic _token) public {\n        TOKEN = _token;\n    }\n\n    function getGateAddress(address _user) external view returns (address) {\n        return gates[_user];\n    }\n\n    \n    function openGate() external {\n        address user = msg.sender;\n\n        // Do not allow creating more than one Gate per User.\n        require(gates[user] == 0);\n\n        // Create new Gate.\n        address gate = new Gate(TOKEN, this);\n\n        // Remember User - Gate relationship.\n        gates[user] = gate;\n\n        GateOpened(gate, user);\n    }\n\n    function transferFromGate() external {\n        address user = msg.sender;\n\n        address gate = gates[user];\n\n        // Make sure the User's Gate exists.\n        require(gate != 0);\n\n        uint256 value = TOKEN.balanceOf(gate);\n\n        Gate(gate).transferToProxy(value);\n\n        // Handle the information about the amount of migrated tokens.\n        // This is a trusted information becase it comes from the Gate.\n        totalSupply_ += value;\n        balances[user] += value;\n\n        Minted(user, value);\n    }\n\n    function withdraw(uint256 _value) external {\n      withdrawTo(_value, msg.sender);\n    }\n\n    function withdrawTo(uint256 _value, address _destination) public {\n        address user = msg.sender;\n        uint256 balance = balances[user];\n        require(_value <= balance);\n\n        balances[user] = (balance - _value);\n        totalSupply_ -= _value;\n\n        TOKEN.transfer(_destination, _value);\n\n        Burned(user, _value);\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GolemNetworkTokenBatching.sol",
        "vulnerability": "Assertion Failure",
        "check": "FP",
        "response": "Answer: Yes\nDescription: The condition `require(gates[user] == 0);` could potentially fail due to the use of '0' instead of 'address(0)', which is the default value for an uninitialized address in Solidity. This can lead to an \"Assertion Failure\"."
    },
    {
        "code_segment": "contract GNTDeposit is ReceivingContract {\n    address public concent;\n    address public coldwallet;\n    uint256 public withdrawal_delay;\n\n    ERC20 public token;\n    // owner => amount\n    mapping (address => uint256) public balances;\n    // owner => timestamp after which withdraw is possible\n    //        | 0 if locked\n    mapping (address => uint256) public locked_until;\n\n    event Deposit(address indexed _owner, uint256 _amount);\n    event Withdraw(address indexed _from, address indexed _to, uint256 _amount);\n    event Lock(address indexed _owner);\n    event Unlock(address indexed _owner);\n    event Burn(address indexed _who, uint256 _amount);\n    event ReimburseForSubtask(address indexed _requestor, address indexed _provider, uint256 _amount, bytes32 _subtask_id);\n    event ReimburseForNoPayment(address indexed _requestor, address indexed _provider, uint256 _amount, uint256 _closure_time);\n    event ReimburseForVerificationCosts(address indexed _from, uint256 _amount, bytes32 _subtask_id);\n\n    function GNTDeposit(\n        ERC20 _token,\n        address _concent,\n        address _coldwallet,\n        uint256 _withdrawal_delay\n    )\n        public\n    {\n        token = _token;\n        concent = _concent;\n        coldwallet = _coldwallet;\n        withdrawal_delay = _withdrawal_delay;\n    }\n\n    // modifiers\n\n    modifier onlyUnlocked() {\n        require(isUnlocked(msg.sender));\n        _;\n    }\n\n    modifier onlyConcent() {\n        require(msg.sender == concent);\n        _;\n    }\n\n    modifier onlyToken() {\n        require(msg.sender == address(token));\n        _;\n    }\n\n    // views\n\n    function balanceOf(address _owner) external view returns (uint256) {\n        return balances[_owner];\n    }\n\n    function isLocked(address _owner) external view returns (bool) {\n        return locked_until[_owner] == 0;\n    }\n\n    function isTimeLocked(address _owner) external view returns (bool) {\n        return locked_until[_owner] > block.timestamp;\n    }\n\n    function isUnlocked(address _owner) public view returns (bool) {\n        return locked_until[_owner] != 0 && locked_until[_owner] < block.timestamp;\n    }\n\n    function getTimelock(address _owner) external view returns (uint256) {\n        return locked_until[_owner];\n    }\n\n    // deposit API\n\n    function unlock() external {\n        locked_until[msg.sender] = block.timestamp + withdrawal_delay;\n        Unlock(msg.sender);\n    }\n\n    function lock() external {\n        locked_until[msg.sender] = 0;\n        Lock(msg.sender);\n    }\n\n    function onTokenReceived(address _from, uint _amount, bytes /* _data */) public onlyToken {\n        balances[_from] += _amount;\n        Deposit(_from, _amount);\n    }\n\n    function withdraw(address _to) onlyUnlocked external {\n        var _amount = balances[msg.sender];\n        balances[msg.sender] = 0;\n        locked_until[msg.sender] = 0;\n        require(token.transfer(_to, _amount));\n        Withdraw(msg.sender, _to, _amount);\n    }\n\n    function burn(address _whom, uint256 _burn) onlyConcent external {\n        _reimburse(_whom, 0xdeadbeef, _burn);\n        Burn(_whom, _burn);\n    }\n\n    function reimburseForSubtask(\n        address _requestor,\n        address _provider,\n        uint256 _amount,\n        bytes32 _subtask_id\n    )\n        onlyConcent\n        external\n    {\n        _reimburse(_requestor, _provider, _amount);\n        ReimburseForSubtask(_requestor, _provider, _amount, _subtask_id);\n    }\n\n    function reimburseForNoPayment(\n        address _requestor,\n        address _provider,\n        uint256 _amount,\n        uint256 _closure_time\n    )\n        onlyConcent\n        external\n    {\n        _reimburse(_requestor, _provider, _amount);\n        ReimburseForNoPayment(_requestor, _provider, _amount, _closure_time);\n    }\n\n    function reimburseForVerificationCosts(\n        address _from,\n        uint256 _amount,\n        bytes32 _subtask_id\n    )\n        onlyConcent\n        external\n    {\n        _reimburse(_from, coldwallet, _amount);\n        ReimburseForVerificationCosts(_from, _amount, _subtask_id);\n    }\n\n    // internals\n\n    function _reimburse(address _from, address _to, uint256 _amount) private {\n        require(balances[_from] >= _amount);\n        balances[_from] -= _amount;\n        if (balances[_from] == 0) {\n            locked_until[_from] = 0;\n        }\n        require(token.transfer(_to, _amount));\n    }\n\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GNTDeposit.sol",
        "vulnerability": "Block Dependency",
        "check": "FP",
        "response": "Answer: Yes\nDescription: The contract uses `block.timestamp` to manage the `locked_until` mechanism, which is susceptible to block timestamp manipulation by miners."
    },
    {
        "code_segment": "contract GNTDeposit is ReceivingContract {\n    address public concent;\n    address public coldwallet;\n    uint256 public withdrawal_delay;\n\n    ERC20 public token;\n    // owner => amount\n    mapping (address => uint256) public balances;\n    // owner => timestamp after which withdraw is possible\n    //        | 0 if locked\n    mapping (address => uint256) public locked_until;\n\n    event Deposit(address indexed _owner, uint256 _amount);\n    event Withdraw(address indexed _from, address indexed _to, uint256 _amount);\n    event Lock(address indexed _owner);\n    event Unlock(address indexed _owner);\n    event Burn(address indexed _who, uint256 _amount);\n    event ReimburseForSubtask(address indexed _requestor, address indexed _provider, uint256 _amount, bytes32 _subtask_id);\n    event ReimburseForNoPayment(address indexed _requestor, address indexed _provider, uint256 _amount, uint256 _closure_time);\n    event ReimburseForVerificationCosts(address indexed _from, uint256 _amount, bytes32 _subtask_id);\n\n    function GNTDeposit(\n        ERC20 _token,\n        address _concent,\n        address _coldwallet,\n        uint256 _withdrawal_delay\n    )\n        public\n    {\n        token = _token;\n        concent = _concent;\n        coldwallet = _coldwallet;\n        withdrawal_delay = _withdrawal_delay;\n    }\n\n    // modifiers\n\n    modifier onlyUnlocked() {\n        require(isUnlocked(msg.sender));\n        _;\n    }\n\n    modifier onlyConcent() {\n        require(msg.sender == concent);\n        _;\n    }\n\n    modifier onlyToken() {\n        require(msg.sender == address(token));\n        _;\n    }\n\n    // views\n\n    function balanceOf(address _owner) external view returns (uint256) {\n        return balances[_owner];\n    }\n\n    function isLocked(address _owner) external view returns (bool) {\n        return locked_until[_owner] == 0;\n    }\n\n    function isTimeLocked(address _owner) external view returns (bool) {\n        return locked_until[_owner] > block.timestamp;\n    }\n\n    function isUnlocked(address _owner) public view returns (bool) {\n        return locked_until[_owner] != 0 && locked_until[_owner] < block.timestamp;\n    }\n\n    function getTimelock(address _owner) external view returns (uint256) {\n        return locked_until[_owner];\n    }\n\n    // deposit API\n\n    function unlock() external {\n        locked_until[msg.sender] = block.timestamp + withdrawal_delay;\n        Unlock(msg.sender);\n    }\n\n    function lock() external {\n        locked_until[msg.sender] = 0;\n        Lock(msg.sender);\n    }\n\n    function onTokenReceived(address _from, uint _amount, bytes /* _data */) public onlyToken {\n        balances[_from] += _amount;\n        Deposit(_from, _amount);\n    }\n\n    function withdraw(address _to) onlyUnlocked external {\n        var _amount = balances[msg.sender];\n        balances[msg.sender] = 0;\n        locked_until[msg.sender] = 0;\n        require(token.transfer(_to, _amount));\n        Withdraw(msg.sender, _to, _amount);\n    }\n\n    function burn(address _whom, uint256 _burn) onlyConcent external {\n        _reimburse(_whom, 0xdeadbeef, _burn);\n        Burn(_whom, _burn);\n    }\n\n    function reimburseForSubtask(\n        address _requestor,\n        address _provider,\n        uint256 _amount,\n        bytes32 _subtask_id\n    )\n        onlyConcent\n        external\n    {\n        _reimburse(_requestor, _provider, _amount);\n        ReimburseForSubtask(_requestor, _provider, _amount, _subtask_id);\n    }\n\n    function reimburseForNoPayment(\n        address _requestor,\n        address _provider,\n        uint256 _amount,\n        uint256 _closure_time\n    )\n        onlyConcent\n        external\n    {\n        _reimburse(_requestor, _provider, _amount);\n        ReimburseForNoPayment(_requestor, _provider, _amount, _closure_time);\n    }\n\n    function reimburseForVerificationCosts(\n        address _from,\n        uint256 _amount,\n        bytes32 _subtask_id\n    )\n        onlyConcent\n        external\n    {\n        _reimburse(_from, coldwallet, _amount);\n        ReimburseForVerificationCosts(_from, _amount, _subtask_id);\n    }\n\n    // internals\n\n    function _reimburse(address _from, address _to, uint256 _amount) private {\n        require(balances[_from] >= _amount);\n        balances[_from] -= _amount;\n        if (balances[_from] == 0) {\n            locked_until[_from] = 0;\n        }\n        require(token.transfer(_to, _amount));\n    }\n\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GNTDeposit.sol",
        "vulnerability": "Block Dependency",
        "check": "FP",
        "response": "Answer: Yes\nDescription: The function `unlock` relies on `block.timestamp` which can be influenced by miners, leading to potential block dependency issues."
    },
    {
        "code_segment": "contract GNTDeposit is ReceivingContract {\n    address public concent;\n    address public coldwallet;\n    uint256 public withdrawal_delay;\n\n    ERC20 public token;\n    // owner => amount\n    mapping (address => uint256) public balances;\n    // owner => timestamp after which withdraw is possible\n    //        | 0 if locked\n    mapping (address => uint256) public locked_until;\n\n    event Deposit(address indexed _owner, uint256 _amount);\n    event Withdraw(address indexed _from, address indexed _to, uint256 _amount);\n    event Lock(address indexed _owner);\n    event Unlock(address indexed _owner);\n    event Burn(address indexed _who, uint256 _amount);\n    event ReimburseForSubtask(address indexed _requestor, address indexed _provider, uint256 _amount, bytes32 _subtask_id);\n    event ReimburseForNoPayment(address indexed _requestor, address indexed _provider, uint256 _amount, uint256 _closure_time);\n    event ReimburseForVerificationCosts(address indexed _from, uint256 _amount, bytes32 _subtask_id);\n\n    function GNTDeposit(\n        ERC20 _token,\n        address _concent,\n        address _coldwallet,\n        uint256 _withdrawal_delay\n    )\n        public\n    {\n        token = _token;\n        concent = _concent;\n        coldwallet = _coldwallet;\n        withdrawal_delay = _withdrawal_delay;\n    }\n\n    // modifiers\n\n    modifier onlyUnlocked() {\n        require(isUnlocked(msg.sender));\n        _;\n    }\n\n    modifier onlyConcent() {\n        require(msg.sender == concent);\n        _;\n    }\n\n    modifier onlyToken() {\n        require(msg.sender == address(token));\n        _;\n    }\n\n    // views\n\n    function balanceOf(address _owner) external view returns (uint256) {\n        return balances[_owner];\n    }\n\n    function isLocked(address _owner) external view returns (bool) {\n        return locked_until[_owner] == 0;\n    }\n\n    function isTimeLocked(address _owner) external view returns (bool) {\n        return locked_until[_owner] > block.timestamp;\n    }\n\n    function isUnlocked(address _owner) public view returns (bool) {\n        return locked_until[_owner] != 0 && locked_until[_owner] < block.timestamp;\n    }\n\n    function getTimelock(address _owner) external view returns (uint256) {\n        return locked_until[_owner];\n    }\n\n    // deposit API\n\n    function unlock() external {\n        locked_until[msg.sender] = block.timestamp + withdrawal_delay;\n        Unlock(msg.sender);\n    }\n\n    function lock() external {\n        locked_until[msg.sender] = 0;\n        Lock(msg.sender);\n    }\n\n    function onTokenReceived(address _from, uint _amount, bytes /* _data */) public onlyToken {\n        balances[_from] += _amount;\n        Deposit(_from, _amount);\n    }\n\n    function withdraw(address _to) onlyUnlocked external {\n        var _amount = balances[msg.sender];\n        balances[msg.sender] = 0;\n        locked_until[msg.sender] = 0;\n        require(token.transfer(_to, _amount));\n        Withdraw(msg.sender, _to, _amount);\n    }\n\n    function burn(address _whom, uint256 _burn) onlyConcent external {\n        _reimburse(_whom, 0xdeadbeef, _burn);\n        Burn(_whom, _burn);\n    }\n\n    function reimburseForSubtask(\n        address _requestor,\n        address _provider,\n        uint256 _amount,\n        bytes32 _subtask_id\n    )\n        onlyConcent\n        external\n    {\n        _reimburse(_requestor, _provider, _amount);\n        ReimburseForSubtask(_requestor, _provider, _amount, _subtask_id);\n    }\n\n    function reimburseForNoPayment(\n        address _requestor,\n        address _provider,\n        uint256 _amount,\n        uint256 _closure_time\n    )\n        onlyConcent\n        external\n    {\n        _reimburse(_requestor, _provider, _amount);\n        ReimburseForNoPayment(_requestor, _provider, _amount, _closure_time);\n    }\n\n    function reimburseForVerificationCosts(\n        address _from,\n        uint256 _amount,\n        bytes32 _subtask_id\n    )\n        onlyConcent\n        external\n    {\n        _reimburse(_from, coldwallet, _amount);\n        ReimburseForVerificationCosts(_from, _amount, _subtask_id);\n    }\n\n    // internals\n\n    function _reimburse(address _from, address _to, uint256 _amount) private {\n        require(balances[_from] >= _amount);\n        balances[_from] -= _amount;\n        if (balances[_from] == 0) {\n            locked_until[_from] = 0;\n        }\n        require(token.transfer(_to, _amount));\n    }\n\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GNTDeposit.sol",
        "vulnerability": "Block Dependency",
        "check": "FP",
        "response": "Answer: Yes\nDescription: The functions `isTimeLocked`, `isUnlocked`, and `unlock` depend on `block.timestamp`, which can be manipulated by miners, leading to block dependency issues."
    },
    {
        "code_segment": "contract GNTPaymentChannels is ReceivingContract {\n\n    GolemNetworkTokenBatching public token;\n\n    struct PaymentChannel {\n        address owner;\n        address receiver;\n        uint256 deposited;\n        // withdrawn <= deposited (less or equal)\n        uint256 withdrawn;\n        //   0, if locked\n        // | timestamp, after which withdraw is possible\n        uint256 locked_until;\n    }\n\n    uint256 id;\n    mapping (bytes32 => PaymentChannel) public channels;\n    uint256 close_delay;\n\n    event NewChannel(address indexed _owner, address indexed _receiver, bytes32 _channel);\n    event Fund(address indexed _receiver, bytes32 indexed _channel, uint256 amount);\n    event Withdraw(address indexed _owner, address indexed _receiver);\n    event TimeLocked(address indexed _owner, address indexed _receiver, bytes32 _channel);\n    event Close(address indexed _owner, address indexed _receiver, bytes32 _channel);\n    event ForceClose(address indexed _owner, address indexed _receiver, bytes32 _channel);\n\n    function GNTPaymentChannels(address _token, uint256 _close_delay)\n        public {\n        token = GolemNetworkTokenBatching(_token);\n        id = 0;\n        close_delay = _close_delay;\n    }\n\n    modifier onlyToken() {\n        require(msg.sender == address(token));\n        _;\n    }\n\n    modifier onlyValidSig(bytes32 _ch, uint _value,\n                      uint8 _v, bytes32 _r, bytes32 _s) {\n        require(isValidSig(_ch, _value, _v, _r, _s));\n        _;\n    }\n\n    modifier onlyOwner(bytes32 _channel) {\n        require(msg.sender == channels[_channel].owner);\n        _;\n    }\n\n    modifier unlocked(bytes32 _channel) {\n        require(isUnlocked(_channel));\n        _;\n    }\n\n    // helpers: check channel status\n\n    function getDeposited(bytes32 _channel)\n        external\n        view\n        returns (uint256) {\n        PaymentChannel ch = channels[_channel];\n        return ch.deposited;\n    }\n\n    function getWithdrawn(bytes32 _channel)\n        external\n        view\n        returns (uint256) {\n        return channels[_channel].withdrawn;\n    }\n\n    function getOwner(bytes32 _channel)\n        external\n        view\n        returns (address) {\n        return channels[_channel].owner;\n    }\n\n    function getReceiver(bytes32 _channel)\n        external\n        view\n        returns (address) {\n        return channels[_channel].receiver;\n    }\n\n    function isLocked(bytes32 _channel) public returns (bool) {\n        return channels[_channel].locked_until == 0;\n    }\n\n    function isTimeLocked(bytes32 _channel) public view returns (bool) {\n        return channels[_channel].locked_until >= block.timestamp;\n    }\n\n    function isUnlocked(bytes32 _channel) public view returns (bool) {\n        return ((channels[_channel].locked_until != 0) &&\n                (channels[_channel].locked_until < block.timestamp));\n    }\n\n    function isValidSig(bytes32 _ch, uint _value,\n                        uint8 _v, bytes32 _r, bytes32 _s) view returns (bool) {\n        return (channels[_ch].owner) == (ecrecover(sha3(_ch, _value), _v, _r, _s));\n    }\n\n    // functions that modify state\n\n    // FIXME: Channel needs to be created before it can be funded.\n    function createChannel(address _receiver)\n        external {\n        bytes32 channel = sha3(id++);\n        channels[channel] = PaymentChannel(msg.sender, _receiver, 0, 0, 0);\n        NewChannel(msg.sender, _receiver, channel); // event\n    }\n\n    // Fund existing channel; can be done multiple times.\n    function onTokenReceived(address _from, uint _value, bytes _data) {\n        bytes32 channel;\n        assembly {\n          channel := mload(add(_data, 32))\n        }\n        PaymentChannel ch = channels[channel];\n        require(_from == ch.owner);\n        ch.deposited += _value;\n        Fund(ch.receiver, channel, _value);\n    }\n\n    // Fund existing channel; can be done multiple times.\n    // Uses ERC20 token API\n    function fund(bytes32 _channel, uint256 _amount)\n        returns (bool) {\n        PaymentChannel ch = channels[_channel];\n        // check if channel exists\n        // this prevents fund loss\n        require(ch.receiver != address(0));\n        if (token.transferFrom(msg.sender, address(this), _amount)) {\n            ch.deposited += _amount;\n            ch.locked_until = 0;\n            Fund(ch.receiver, _channel, _amount); // event\n            return true;\n        }\n        return false;\n    }\n\n    // Receiver can withdraw multiple times without closing the channel\n    function withdraw(bytes32 _channel, uint256 _value,\n                      uint8 _v, bytes32 _r, bytes32 _s)\n        external\n        onlyValidSig(_channel, _value, _v, _r, _s)\n        returns (bool) {\n        PaymentChannel ch = channels[_channel];\n        require(ch.withdrawn < _value); // <- STRICT less than!\n        var amount = _value - ch.withdrawn;\n        // Receiver has been cheated! Withdraw as much as possible.\n        if (ch.deposited - ch.withdrawn < amount)\n            amount = ch.deposited - ch.withdrawn;\n        return _do_withdraw(_channel, amount);\n    }\n\n    // If receiver does not want to close channel, owner can do that\n    // by calling unlock and waiting for grace period (close_delay).\n    function unlock(bytes32 _channel)\n        external\n        onlyOwner(_channel) {\n        PaymentChannel ch = channels[_channel];\n        ch.locked_until = block.timestamp + close_delay;\n        TimeLocked(ch.owner, ch.receiver, _channel);\n    }\n\n    // Owner can close channel to reclaim its money.\n    function close(bytes32 _channel)\n        external\n        onlyOwner(_channel)\n        unlocked(_channel)\n        returns (bool) {\n        return _do_close(_channel, false);\n    }\n\n    // Receiver can close channel and return owner all of the funds.\n    // Receiver should `withdraw` its own funds first!\n    function forceClose(bytes32 _channel)\n        external\n        returns (bool) {\n        require(msg.sender == channels[_channel].receiver);\n        return _do_close(_channel, true);\n    }\n\n    // internals\n\n    function _do_withdraw(bytes32 _channel, uint256 _amount)\n        private\n        returns (bool) {\n\n        PaymentChannel ch = channels[_channel];\n        if (token.transfer(ch.receiver, _amount)) {\n            ch.withdrawn += _amount;\n            Withdraw(ch.owner, ch.receiver);\n            return true;\n        }\n        return false;\n    }\n\n    function _do_close(bytes32 _channel, bool force)\n        private\n        returns (bool) {\n\n        PaymentChannel ch = channels[_channel];\n        var amount = ch.deposited - ch.withdrawn;\n        if (token.transfer(ch.owner, amount)) {\n            if (force)\n                { ForceClose(ch.owner, ch.receiver, _channel); }\n            else\n                { Close(ch.owner, ch.receiver, _channel); }\n            delete channels[_channel];\n            return true;\n        }\n        return false;\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GNTPaymentChannels.sol",
        "vulnerability": "Block Dependency",
        "check": "FP",
        "response": "Answer: Yes\nDescription: The use of \"block.timestamp\" for time-locking channels introduces block dependency, as the timestamp can be manipulated slightly by miners."
    },
    {
        "code_segment": "contract GNTPaymentChannels is ReceivingContract {\n\n    GolemNetworkTokenBatching public token;\n\n    struct PaymentChannel {\n        address owner;\n        address receiver;\n        uint256 deposited;\n        // withdrawn <= deposited (less or equal)\n        uint256 withdrawn;\n        //   0, if locked\n        // | timestamp, after which withdraw is possible\n        uint256 locked_until;\n    }\n\n    uint256 id;\n    mapping (bytes32 => PaymentChannel) public channels;\n    uint256 close_delay;\n\n    event NewChannel(address indexed _owner, address indexed _receiver, bytes32 _channel);\n    event Fund(address indexed _receiver, bytes32 indexed _channel, uint256 amount);\n    event Withdraw(address indexed _owner, address indexed _receiver);\n    event TimeLocked(address indexed _owner, address indexed _receiver, bytes32 _channel);\n    event Close(address indexed _owner, address indexed _receiver, bytes32 _channel);\n    event ForceClose(address indexed _owner, address indexed _receiver, bytes32 _channel);\n\n    function GNTPaymentChannels(address _token, uint256 _close_delay)\n        public {\n        token = GolemNetworkTokenBatching(_token);\n        id = 0;\n        close_delay = _close_delay;\n    }\n\n    modifier onlyToken() {\n        require(msg.sender == address(token));\n        _;\n    }\n\n    modifier onlyValidSig(bytes32 _ch, uint _value,\n                      uint8 _v, bytes32 _r, bytes32 _s) {\n        require(isValidSig(_ch, _value, _v, _r, _s));\n        _;\n    }\n\n    modifier onlyOwner(bytes32 _channel) {\n        require(msg.sender == channels[_channel].owner);\n        _;\n    }\n\n    modifier unlocked(bytes32 _channel) {\n        require(isUnlocked(_channel));\n        _;\n    }\n\n    // helpers: check channel status\n\n    function getDeposited(bytes32 _channel)\n        external\n        view\n        returns (uint256) {\n        PaymentChannel ch = channels[_channel];\n        return ch.deposited;\n    }\n\n    function getWithdrawn(bytes32 _channel)\n        external\n        view\n        returns (uint256) {\n        return channels[_channel].withdrawn;\n    }\n\n    function getOwner(bytes32 _channel)\n        external\n        view\n        returns (address) {\n        return channels[_channel].owner;\n    }\n\n    function getReceiver(bytes32 _channel)\n        external\n        view\n        returns (address) {\n        return channels[_channel].receiver;\n    }\n\n    function isLocked(bytes32 _channel) public returns (bool) {\n        return channels[_channel].locked_until == 0;\n    }\n\n    function isTimeLocked(bytes32 _channel) public view returns (bool) {\n        return channels[_channel].locked_until >= block.timestamp;\n    }\n\n    function isUnlocked(bytes32 _channel) public view returns (bool) {\n        return ((channels[_channel].locked_until != 0) &&\n                (channels[_channel].locked_until < block.timestamp));\n    }\n\n    function isValidSig(bytes32 _ch, uint _value,\n                        uint8 _v, bytes32 _r, bytes32 _s) view returns (bool) {\n        return (channels[_ch].owner) == (ecrecover(sha3(_ch, _value), _v, _r, _s));\n    }\n\n    // functions that modify state\n\n    // FIXME: Channel needs to be created before it can be funded.\n    function createChannel(address _receiver)\n        external {\n        bytes32 channel = sha3(id++);\n        channels[channel] = PaymentChannel(msg.sender, _receiver, 0, 0, 0);\n        NewChannel(msg.sender, _receiver, channel); // event\n    }\n\n    // Fund existing channel; can be done multiple times.\n    function onTokenReceived(address _from, uint _value, bytes _data) {\n        bytes32 channel;\n        assembly {\n          channel := mload(add(_data, 32))\n        }\n        PaymentChannel ch = channels[channel];\n        require(_from == ch.owner);\n        ch.deposited += _value;\n        Fund(ch.receiver, channel, _value);\n    }\n\n    // Fund existing channel; can be done multiple times.\n    // Uses ERC20 token API\n    function fund(bytes32 _channel, uint256 _amount)\n        returns (bool) {\n        PaymentChannel ch = channels[_channel];\n        // check if channel exists\n        // this prevents fund loss\n        require(ch.receiver != address(0));\n        if (token.transferFrom(msg.sender, address(this), _amount)) {\n            ch.deposited += _amount;\n            ch.locked_until = 0;\n            Fund(ch.receiver, _channel, _amount); // event\n            return true;\n        }\n        return false;\n    }\n\n    // Receiver can withdraw multiple times without closing the channel\n    function withdraw(bytes32 _channel, uint256 _value,\n                      uint8 _v, bytes32 _r, bytes32 _s)\n        external\n        onlyValidSig(_channel, _value, _v, _r, _s)\n        returns (bool) {\n        PaymentChannel ch = channels[_channel];\n        require(ch.withdrawn < _value); // <- STRICT less than!\n        var amount = _value - ch.withdrawn;\n        // Receiver has been cheated! Withdraw as much as possible.\n        if (ch.deposited - ch.withdrawn < amount)\n            amount = ch.deposited - ch.withdrawn;\n        return _do_withdraw(_channel, amount);\n    }\n\n    // If receiver does not want to close channel, owner can do that\n    // by calling unlock and waiting for grace period (close_delay).\n    function unlock(bytes32 _channel)\n        external\n        onlyOwner(_channel) {\n        PaymentChannel ch = channels[_channel];\n        ch.locked_until = block.timestamp + close_delay;\n        TimeLocked(ch.owner, ch.receiver, _channel);\n    }\n\n    // Owner can close channel to reclaim its money.\n    function close(bytes32 _channel)\n        external\n        onlyOwner(_channel)\n        unlocked(_channel)\n        returns (bool) {\n        return _do_close(_channel, false);\n    }\n\n    // Receiver can close channel and return owner all of the funds.\n    // Receiver should `withdraw` its own funds first!\n    function forceClose(bytes32 _channel)\n        external\n        returns (bool) {\n        require(msg.sender == channels[_channel].receiver);\n        return _do_close(_channel, true);\n    }\n\n    // internals\n\n    function _do_withdraw(bytes32 _channel, uint256 _amount)\n        private\n        returns (bool) {\n\n        PaymentChannel ch = channels[_channel];\n        if (token.transfer(ch.receiver, _amount)) {\n            ch.withdrawn += _amount;\n            Withdraw(ch.owner, ch.receiver);\n            return true;\n        }\n        return false;\n    }\n\n    function _do_close(bytes32 _channel, bool force)\n        private\n        returns (bool) {\n\n        PaymentChannel ch = channels[_channel];\n        var amount = ch.deposited - ch.withdrawn;\n        if (token.transfer(ch.owner, amount)) {\n            if (force)\n                { ForceClose(ch.owner, ch.receiver, _channel); }\n            else\n                { Close(ch.owner, ch.receiver, _channel); }\n            delete channels[_channel];\n            return true;\n        }\n        return false;\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GNTPaymentChannels.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: Yes\nDescription: The operations such as `id++` and `ch.deposited += _value` are susceptible to integer overflow."
    },
    {
        "code_segment": "contract StandardToken is ERC20, BasicToken {\n\n  mapping (address => mapping (address => uint256)) internal allowed;\n\n\n  /**\n   * @dev Transfer tokens from one address to another\n   * @param _from address The address which you want to send tokens from\n   * @param _to address The address which you want to transfer to\n   * @param _value uint256 the amount of tokens to be transferred\n   */\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value <= balances[_from]);\n    require(_value <= allowed[_from][msg.sender]);\n\n    balances[_from] = balances[_from].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n    Transfer(_from, _to, _value);\n    return true;\n  }\n\n  /**\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n   *\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   * @param _spender The address which will spend the funds.\n   * @param _value The amount of tokens to be spent.\n   */\n  function approve(address _spender, uint256 _value) public returns (bool) {\n    allowed[msg.sender][_spender] = _value;\n    Approval(msg.sender, _spender, _value);\n    return true;\n  }\n\n  /**\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n   * @param _owner address The address which owns the funds.\n   * @param _spender address The address which will spend the funds.\n   * @return A uint256 specifying the amount of tokens still available for the spender.\n   */\n  function allowance(address _owner, address _spender) public view returns (uint256) {\n    return allowed[_owner][_spender];\n  }\n\n  /**\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\n   *\n   * approve should be called when allowed[_spender] == 0. To increment\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _addedValue The amount of tokens to increase the allowance by.\n   */\n  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n  /**\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n   *\n   * approve should be called when allowed[_spender] == 0. To decrement\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n   */\n  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n    uint oldValue = allowed[msg.sender][_spender];\n    if (_subtractedValue > oldValue) {\n      allowed[msg.sender][_spender] = 0;\n    } else {\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n    }\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GNTPaymentChannels.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No\nReason: The code uses SafeMath functions `add` and `sub` to handle arithmetic operations, which protects against integer overflow."
    },
    {
        "code_segment": "contract StandardToken is ERC20, BasicToken {\n\n  mapping (address => mapping (address => uint256)) internal allowed;\n\n\n  /**\n   * @dev Transfer tokens from one address to another\n   * @param _from address The address which you want to send tokens from\n   * @param _to address The address which you want to transfer to\n   * @param _value uint256 the amount of tokens to be transferred\n   */\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value <= balances[_from]);\n    require(_value <= allowed[_from][msg.sender]);\n\n    balances[_from] = balances[_from].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n    Transfer(_from, _to, _value);\n    return true;\n  }\n\n  /**\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n   *\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   * @param _spender The address which will spend the funds.\n   * @param _value The amount of tokens to be spent.\n   */\n  function approve(address _spender, uint256 _value) public returns (bool) {\n    allowed[msg.sender][_spender] = _value;\n    Approval(msg.sender, _spender, _value);\n    return true;\n  }\n\n  /**\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n   * @param _owner address The address which owns the funds.\n   * @param _spender address The address which will spend the funds.\n   * @return A uint256 specifying the amount of tokens still available for the spender.\n   */\n  function allowance(address _owner, address _spender) public view returns (uint256) {\n    return allowed[_owner][_spender];\n  }\n\n  /**\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\n   *\n   * approve should be called when allowed[_spender] == 0. To increment\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _addedValue The amount of tokens to increase the allowance by.\n   */\n  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n  /**\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n   *\n   * approve should be called when allowed[_spender] == 0. To decrement\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n   */\n  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n    uint oldValue = allowed[msg.sender][_spender];\n    if (_subtractedValue > oldValue) {\n      allowed[msg.sender][_spender] = 0;\n    } else {\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n    }\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GNTPaymentChannels.sol",
        "vulnerability": "Assertion Failure",
        "check": "FP",
        "response": "Answer: No\nReason: The code does not contain any assert statement that could lead to an assertion failure. All conditions are checked using require statements, which revert the transaction if the conditions are not met, preventing any assertion failure."
    },
    {
        "code_segment": "contract TokenProxy is StandardToken {\n\n    ERC20Basic public TOKEN;\n\n    mapping(address => address) private gates;\n\n\n    event GateOpened(address indexed gate, address indexed user);\n\n    event Minted(address indexed to, uint256 amount);\n\n    event Burned(address indexed from, uint256 amount);\n\n    function TokenProxy(ERC20Basic _token) public {\n        TOKEN = _token;\n    }\n\n    function getGateAddress(address _user) external view returns (address) {\n        return gates[_user];\n    }\n\n    \n    function openGate() external {\n        address user = msg.sender;\n\n        // Do not allow creating more than one Gate per User.\n        require(gates[user] == 0);\n\n        // Create new Gate.\n        address gate = new Gate(TOKEN, this);\n\n        // Remember User - Gate relationship.\n        gates[user] = gate;\n\n        GateOpened(gate, user);\n    }\n\n    function transferFromGate() external {\n        address user = msg.sender;\n\n        address gate = gates[user];\n\n        // Make sure the User's Gate exists.\n        require(gate != 0);\n\n        uint256 value = TOKEN.balanceOf(gate);\n\n        Gate(gate).transferToProxy(value);\n\n        // Handle the information about the amount of migrated tokens.\n        // This is a trusted information becase it comes from the Gate.\n        totalSupply_ += value;\n        balances[user] += value;\n\n        Minted(user, value);\n    }\n\n    function withdraw(uint256 _value) external {\n      withdrawTo(_value, msg.sender);\n    }\n\n    function withdrawTo(uint256 _value, address _destination) public {\n        address user = msg.sender;\n        uint256 balance = balances[user];\n        require(_value <= balance);\n\n        balances[user] = (balance - _value);\n        totalSupply_ -= _value;\n\n        TOKEN.transfer(_destination, _value);\n\n        Burned(user, _value);\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GNTPaymentChannels.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: Yes\nDescription: The line `totalSupply_ += value;` and `balances[user] += value;` in the `transferFromGate` function can cause an integer overflow if `value` is large enough. The Ethereum Virtual Machine (EVM) does not automatically check for overflow, so using unchecked arithmetic here could lead to a significant security vulnerability."
    },
    {
        "code_segment": "contract TokenProxy is StandardToken {\n\n    ERC20Basic public TOKEN;\n\n    mapping(address => address) private gates;\n\n\n    event GateOpened(address indexed gate, address indexed user);\n\n    event Minted(address indexed to, uint256 amount);\n\n    event Burned(address indexed from, uint256 amount);\n\n    function TokenProxy(ERC20Basic _token) public {\n        TOKEN = _token;\n    }\n\n    function getGateAddress(address _user) external view returns (address) {\n        return gates[_user];\n    }\n\n    \n    function openGate() external {\n        address user = msg.sender;\n\n        // Do not allow creating more than one Gate per User.\n        require(gates[user] == 0);\n\n        // Create new Gate.\n        address gate = new Gate(TOKEN, this);\n\n        // Remember User - Gate relationship.\n        gates[user] = gate;\n\n        GateOpened(gate, user);\n    }\n\n    function transferFromGate() external {\n        address user = msg.sender;\n\n        address gate = gates[user];\n\n        // Make sure the User's Gate exists.\n        require(gate != 0);\n\n        uint256 value = TOKEN.balanceOf(gate);\n\n        Gate(gate).transferToProxy(value);\n\n        // Handle the information about the amount of migrated tokens.\n        // This is a trusted information becase it comes from the Gate.\n        totalSupply_ += value;\n        balances[user] += value;\n\n        Minted(user, value);\n    }\n\n    function withdraw(uint256 _value) external {\n      withdrawTo(_value, msg.sender);\n    }\n\n    function withdrawTo(uint256 _value, address _destination) public {\n        address user = msg.sender;\n        uint256 balance = balances[user];\n        require(_value <= balance);\n\n        balances[user] = (balance - _value);\n        totalSupply_ -= _value;\n\n        TOKEN.transfer(_destination, _value);\n\n        Burned(user, _value);\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GNTPaymentChannels.sol",
        "vulnerability": "Assertion Failure",
        "check": "FP",
        "response": "Answer: Yes\nDescription: The require statement `require(gates[user] == 0);` can cause an assertion failure if `user` already has a gate open because `gates[user]` will not be zero."
    },
    {
        "code_segment": "contract BEP20Token is Context, IBEP20, Ownable {\n  using SafeMath for uint256;\n\n  mapping (address => uint256) private _balances;\n\n  mapping (address => mapping (address => uint256)) private _allowances;\n\n  uint256 private _totalSupply;\n  uint8 private _decimals;\n  string private _symbol;\n  string private _name;\n\n  constructor() public {\n    _name = \"ButterCup\";\n    _symbol =  \"BuCu\";\n    _decimals = 18;\n    _totalSupply =10000000000000 *10 ** 18;\n    _balances[msg.sender] = _totalSupply;\n\n    emit Transfer(address(0), msg.sender, _totalSupply);\n  }\n\n  /**\n   * @dev Returns the bep token owner.\n   */\n  function getOwner() external view returns (address) {\n    return owner();\n  }\n//SWC-135-Code With No Effects: L368-370\n  /**\n   * @dev Returns the token decimals.\n   */\n  function decimals() external view returns (uint8) {\n    return _decimals;\n  }\n\n  /**\n   * @dev Returns the token symbol.\n   */\n  function symbol() external view returns (string memory) {\n    return _symbol;\n  }\n\n  /**\n  * @dev Returns the token name.\n  */\n  function name() external view returns (string memory) {\n    return _name;\n  }\n\n  /**\n   * @dev See {BEP20-totalSupply}.\n   */\n  function totalSupply() external view returns (uint256) {\n    return _totalSupply;\n  }\n\n  /**\n   * @dev See {BEP20-balanceOf}.\n   */\n  function balanceOf(address account) external view returns (uint256) {\n    return _balances[account];\n  }\n\n  /**\n   * @dev See {BEP20-transfer}.\n   *\n   * Requirements:\n   *\n   * - `recipient` cannot be the zero address.\n   * - the caller must have a balance of at least `amount`.\n   */\n  function transfer(address recipient, uint256 amount) external returns (bool) {\n    _transfer(_msgSender(), recipient, amount);\n    return true;\n  }\n\n  /**\n   * @dev See {BEP20-allowance}.\n   */\n  function allowance(address owner, address spender) external view returns (uint256) {\n    return _allowances[owner][spender];\n  }\n\n  /**\n   * @dev See {BEP20-approve}.\n   *\n   * Requirements:\n   *\n   * - `spender` cannot be the zero address.\n   */\n  function approve(address spender, uint256 amount) external returns (bool) {\n    _approve(_msgSender(), spender, amount);\n    return true;\n  }\n\n  /**\n   * @dev See {BEP20-transferFrom}.\n   *\n   * Emits an {Approval} event indicating the updated allowance. This is not\n   * required by the EIP. See the note at the beginning of {BEP20};\n   *\n   * Requirements:\n   * - `sender` and `recipient` cannot be the zero address.\n   * - `sender` must have a balance of at least `amount`.\n   * - the caller must have allowance for `sender`'s tokens of at least\n   * `amount`.\n   */\n  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool) {\n    _transfer(sender, recipient, amount);\n    _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"BEP20: transfer amount exceeds allowance\"));\n    return true;\n  }\n\n  /**\n   * @dev Atomically increases the allowance granted to `spender` by the caller.\n   *\n   * This is an alternative to {approve} that can be used as a mitigation for\n   * problems described in {BEP20-approve}.\n   *\n   * Emits an {Approval} event indicating the updated allowance.\n   *\n   * Requirements:\n   *\n   * - `spender` cannot be the zero address.\n   */\n  function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n    _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n    return true;\n  }\n\n  /**\n   * @dev Atomically decreases the allowance granted to `spender` by the caller.\n   *\n   * This is an alternative to {approve} that can be used as a mitigation for\n   * problems described in {BEP20-approve}.\n   *\n   * Emits an {Approval} event indicating the updated allowance.\n   *\n   * Requirements:\n   *\n   * - `spender` cannot be the zero address.\n   * - `spender` must have allowance for the caller of at least\n   * `subtractedValue`.\n   */\n  function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n    _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"BEP20: decreased allowance below zero\"));\n    return true;\n  }\n\n  /**\n   * @dev Creates `amount` tokens and assigns them to `msg.sender`, increasing\n   * the total supply.\n   *\n   * Requirements\n   *\n   * - `msg.sender` must be the token owner\n   */\n  function mint(uint256 amount) public onlyOwner returns (bool) {\n    _mint(_msgSender(), amount);\n    return true;\n  }\n\n  /**\n   * @dev Moves tokens `amount` from `sender` to `recipient`.\n   *\n   * This is internal function is equivalent to {transfer}, and can be used to\n   * e.g. implement automatic token fees, slashing mechanisms, etc.\n   *\n   * Emits a {Transfer} event.\n   *\n   * Requirements:\n   *\n   * - `sender` cannot be the zero address.\n   * - `recipient` cannot be the zero address.\n   * - `sender` must have a balance of at least `amount`.\n   */\n  function _transfer(address sender, address recipient, uint256 amount) internal {\n    require(sender != address(0), \"BEP20: transfer from the zero address\");\n    require(recipient != address(0), \"BEP20: transfer to the zero address\");\n\n    _balances[sender] = _balances[sender].sub(amount, \"BEP20: transfer amount exceeds balance\");\n    _balances[recipient] = _balances[recipient].add(amount);\n    emit Transfer(sender, recipient, amount);\n  }\n\n  /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n   * the total supply.\n   *\n   * Emits a {Transfer} event with `from` set to the zero address.\n   *\n   * Requirements\n   *\n   * - `to` cannot be the zero address.\n   */\n  function _mint(address account, uint256 amount) internal {\n    require(account != address(0), \"BEP20: mint to the zero address\");\n\n    _totalSupply = _totalSupply.add(amount);\n    _balances[account] = _balances[account].add(amount);\n    emit Transfer(address(0), account, amount);\n  }\n\n  /**\n   * @dev Destroys `amount` tokens from `account`, reducing the\n   * total supply.\n   *\n   * Emits a {Transfer} event with `to` set to the zero address.\n   *\n   * Requirements\n   *\n   * - `account` cannot be the zero address.\n   * - `account` must have at least `amount` tokens.\n   */\n  function _burn(address account, uint256 amount) internal {\n    require(account != address(0), \"BEP20: burn from the zero address\");\n\n    _balances[account] = _balances[account].sub(amount, \"BEP20: burn amount exceeds balance\");\n    _totalSupply = _totalSupply.sub(amount);\n    emit Transfer(account, address(0), amount);\n  }\n//SWC-135-Code With No Effects: L557-563\n  /**\n   * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\n   *\n   * This is internal function is equivalent to `approve`, and can be used to\n   * e.g. set automatic allowances for certain subsystems, etc.\n   *\n   * Emits an {Approval} event.\n   *\n   * Requirements:\n   *\n   * - `owner` cannot be the zero address.\n   * - `spender` cannot be the zero address.\n   */\n  function _approve(address owner, address spender, uint256 amount) internal {\n    require(owner != address(0), \"BEP20: approve from the zero address\");\n    require(spender != address(0), \"BEP20: approve to the zero address\");\n\n    _allowances[owner][spender] = amount;\n    emit Approval(owner, spender, amount);\n  }\n//SWC-135-Code With No Effects: L592-595\n  /**\n   * @dev Destroys `amount` tokens from `account`.`amount` is then deducted\n   * from the caller's allowance.\n   *\n   * See {_burn} and {_approve}.\n   */\n  function _burnFrom(address account, uint256 amount) internal {\n    _burn(account, amount);\n    _approve(account, _msgSender(), _allowances[account][_msgSender()].sub(amount, \"BEP20: burn amount exceeds allowance\"));\n  }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/QuillAudits-Buttercup Smart Contract/BEP20Token/BEP20Token.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No\nReason: The use of SafeMath for arithmetic operations prevents integer overflow and underflow vulnerabilities."
    },
    {
        "code_segment": "contract BaseMine is InitializableOwnable {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    // ============ Storage ============\n\n    struct RewardTokenInfo {\n        address rewardToken;\n        uint256 startBlock;\n        uint256 endBlock;\n        address rewardVault;\n        uint256 rewardPerBlock;\n        uint256 accRewardPerShare;\n        uint256 lastRewardBlock;\n        uint256 workThroughReward;\n        uint256 lastFlagBlock;\n        mapping(address => uint256) userRewardPerSharePaid;\n        mapping(address => uint256) userRewards;\n    }\n\n    RewardTokenInfo[] public rewardTokenInfos;\n\n    uint256 internal _totalSupply;\n    mapping(address => uint256) internal _balances;\n\n    // ============ Event =============\n\n    event Claim(uint256 indexed i, address indexed user, uint256 reward);\n    event UpdateReward(uint256 indexed i, uint256 rewardPerBlock);\n    event UpdateEndBlock(uint256 indexed i, uint256 endBlock);\n    event NewRewardToken(uint256 indexed i, address rewardToken);\n    event RemoveRewardToken(address rewardToken);\n    event WithdrawLeftOver(address owner, uint256 i);\n\n    // ============ View  ============\n\n    function getPendingReward(address user, uint256 i) public view returns (uint256) {\n        require(i<rewardTokenInfos.length, \"DODOMineV3: REWARD_ID_NOT_FOUND\");\n        RewardTokenInfo storage rt = rewardTokenInfos[i];\n        uint256 accRewardPerShare = rt.accRewardPerShare;\n        if (rt.lastRewardBlock != block.number) {\n            accRewardPerShare = _getAccRewardPerShare(i);\n        }\n        return\n            DecimalMath.mulFloor(\n                balanceOf(user), \n                accRewardPerShare.sub(rt.userRewardPerSharePaid[user])\n            ).add(rt.userRewards[user]);\n    }\n\n    function getPendingRewardByToken(address user, address rewardToken) external view returns (uint256) {\n        return getPendingReward(user, getIdByRewardToken(rewardToken));\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address user) public view returns (uint256) {\n        return _balances[user];\n    }\n\n    function getRewardTokenById(uint256 i) external view returns (address) {\n        require(i<rewardTokenInfos.length, \"DODOMineV3: REWARD_ID_NOT_FOUND\");\n        RewardTokenInfo memory rt = rewardTokenInfos[i];\n        return rt.rewardToken;\n    }\n\n    function getIdByRewardToken(address rewardToken) public view returns(uint256) {\n        uint256 len = rewardTokenInfos.length;\n        for (uint256 i = 0; i < len; i++) {\n            if (rewardToken == rewardTokenInfos[i].rewardToken) {\n                return i;\n            }\n        }\n        require(false, \"DODOMineV3: TOKEN_NOT_FOUND\");\n    }\n\n    function getRewardNum() external view returns(uint256) {\n        return rewardTokenInfos.length;\n    }\n\n    function getVaultByRewardToken(address rewardToken) public view returns(address) {\n        uint256 len = rewardTokenInfos.length;\n        for (uint256 i = 0; i < len; i++) {\n            if (rewardToken == rewardTokenInfos[i].rewardToken) {\n                return rewardTokenInfos[i].rewardVault;\n            }\n        }\n        require(false, \"DODOMineV3: TOKEN_NOT_FOUND\");\n    }\n\n    function getVaultDebtByRewardToken(address rewardToken) public view returns(uint256) {\n        uint256 len = rewardTokenInfos.length;\n        for (uint256 i = 0; i < len; i++) {\n            if (rewardToken == rewardTokenInfos[i].rewardToken) {\n                uint256 totalDepositReward = IRewardVault(rewardTokenInfos[i].rewardVault)._TOTAL_REWARD_();\n                uint256 gap = rewardTokenInfos[i].endBlock.sub(rewardTokenInfos[i].lastFlagBlock);\n                uint256 totalReward = rewardTokenInfos[i].workThroughReward.add(gap.mul(rewardTokenInfos[i].rewardPerBlock));\n                if(totalDepositReward >= totalReward) {\n                    return 0;\n                }else {\n                    return totalReward.sub(totalDepositReward);\n                }\n            }\n        }\n        require(false, \"DODOMineV3: TOKEN_NOT_FOUND\");\n    }\n\n    // ============ Claim ============\n\n    function claimReward(uint256 i) public {\n        require(i<rewardTokenInfos.length, \"DODOMineV3: REWARD_ID_NOT_FOUND\");\n        _updateReward(msg.sender, i);\n        RewardTokenInfo storage rt = rewardTokenInfos[i];\n        uint256 reward = rt.userRewards[msg.sender];\n        if (reward > 0) {\n            rt.userRewards[msg.sender] = 0;\n            IRewardVault(rt.rewardVault).reward(msg.sender, reward);\n            emit Claim(i, msg.sender, reward);\n        }\n    }\n\n    function claimAllRewards() external {\n        uint256 len = rewardTokenInfos.length;\n        for (uint256 i = 0; i < len; i++) {\n            claimReward(i);\n        }\n    }\n\n    // =============== Ownable  ================\n\n    function addRewardToken(\n        address rewardToken,\n        uint256 rewardPerBlock,\n        uint256 startBlock,\n        uint256 endBlock\n    ) external onlyOwner {\n        require(rewardToken != address(0), \"DODOMineV3: TOKEN_INVALID\");\n        require(startBlock > block.number, \"DODOMineV3: START_BLOCK_INVALID\");\n        require(endBlock > startBlock, \"DODOMineV3: DURATION_INVALID\");\n\n        uint256 len = rewardTokenInfos.length;\n        for (uint256 i = 0; i < len; i++) {\n            require(\n                rewardToken != rewardTokenInfos[i].rewardToken,\n                \"DODOMineV3: TOKEN_ALREADY_ADDED\"\n            );\n        }\n\n        RewardTokenInfo storage rt = rewardTokenInfos.push();\n        rt.rewardToken = rewardToken;\n        rt.startBlock = startBlock;\n        rt.lastFlagBlock = startBlock;\n        rt.endBlock = endBlock;\n        rt.rewardPerBlock = rewardPerBlock;\n        rt.rewardVault = address(new RewardVault(rewardToken));\n\n        uint256 rewardAmount = rewardPerBlock.mul(endBlock.sub(startBlock));\n        IERC20(rewardToken).transfer(rt.rewardVault, rewardAmount);\n        RewardVault(rt.rewardVault).syncValue();\n\n        emit NewRewardToken(len, rewardToken);\n    }\n\n    function setEndBlock(uint256 i, uint256 newEndBlock)\n        external\n        onlyOwner\n    {\n        require(i < rewardTokenInfos.length, \"DODOMineV3: REWARD_ID_NOT_FOUND\");\n        _updateReward(address(0), i);\n        RewardTokenInfo storage rt = rewardTokenInfos[i];\n\n\n        uint256 totalDepositReward = RewardVault(rt.rewardVault)._TOTAL_REWARD_();\n        uint256 gap = newEndBlock.sub(rt.lastFlagBlock);\n        uint256 totalReward = rt.workThroughReward.add(gap.mul(rt.rewardPerBlock));\n        require(totalDepositReward >= totalReward, \"DODOMineV3: REWARD_NOT_ENOUGH\");\n\n        require(block.number < newEndBlock, \"DODOMineV3: END_BLOCK_INVALID\");\n        require(block.number > rt.startBlock, \"DODOMineV3: NOT_START\");\n        require(block.number < rt.endBlock, \"DODOMineV3: ALREADY_CLOSE\");\n\n        rt.endBlock = newEndBlock;\n        emit UpdateEndBlock(i, newEndBlock);\n    }\n\n    function setReward(uint256 i, uint256 newRewardPerBlock)\n        external\n        onlyOwner\n    {\n        require(i < rewardTokenInfos.length, \"DODOMineV3: REWARD_ID_NOT_FOUND\");\n        _updateReward(address(0), i);\n        RewardTokenInfo storage rt = rewardTokenInfos[i];\n        \n        require(block.number < rt.endBlock, \"DODOMineV3: ALREADY_CLOSE\");\n        \n        rt.workThroughReward = rt.workThroughReward.add((block.number.sub(rt.lastFlagBlock)).mul(rt.rewardPerBlock));\n        rt.rewardPerBlock = newRewardPerBlock;\n        rt.lastFlagBlock = block.number;\n\n        uint256 totalDepositReward = RewardVault(rt.rewardVault)._TOTAL_REWARD_();\n        uint256 gap = rt.endBlock.sub(block.number);\n        uint256 totalReward = rt.workThroughReward.add(gap.mul(newRewardPerBlock));\n        require(totalDepositReward >= totalReward, \"DODOMineV3: REWARD_NOT_ENOUGH\");\n\n        emit UpdateReward(i, newRewardPerBlock);\n    }\n\n    function withdrawLeftOver(uint256 i, uint256 amount) external onlyOwner {\n        require(i < rewardTokenInfos.length, \"DODOMineV3: REWARD_ID_NOT_FOUND\");\n        \n        RewardTokenInfo storage rt = rewardTokenInfos[i];\n        require(block.number > rt.endBlock, \"DODOMineV3: MINING_NOT_FINISHED\");\n\n        IRewardVault(rt.rewardVault).withdrawLeftOver(msg.sender,amount);\n\n        emit WithdrawLeftOver(msg.sender, i);\n    }\n\n\n    function directTransferOwnership(address newOwner) external onlyOwner {\n        require(newOwner != address(0), \"DODOMineV3: ZERO_ADDRESS\");\n        emit OwnershipTransferred(_OWNER_, newOwner);\n        _OWNER_ = newOwner;\n    }\n\n    // ============ Internal  ============\n\n    function _updateReward(address user, uint256 i) internal {\n        RewardTokenInfo storage rt = rewardTokenInfos[i];\n        if (rt.lastRewardBlock != block.number){\n            rt.accRewardPerShare = _getAccRewardPerShare(i);\n            rt.lastRewardBlock = block.number;\n        }\n        if (user != address(0)) {\n            rt.userRewards[user] = getPendingReward(user, i);\n            rt.userRewardPerSharePaid[user] = rt.accRewardPerShare;\n        }\n    }\n    // SWC-128-DoS With Block Gas Limit: L260-L262\n    function _updateAllReward(address user) internal {\n        uint256 len = rewardTokenInfos.length;\n        for (uint256 i = 0; i < len; i++) {\n            _updateReward(user, i);\n        }\n    }\n\n    function _getUnrewardBlockNum(uint256 i) internal view returns (uint256) {\n        RewardTokenInfo memory rt = rewardTokenInfos[i];\n        if (block.number < rt.startBlock || rt.lastRewardBlock > rt.endBlock) {\n            return 0;\n        }\n        uint256 start = rt.lastRewardBlock < rt.startBlock ? rt.startBlock : rt.lastRewardBlock;\n        uint256 end = rt.endBlock < block.number ? rt.endBlock : block.number;\n        return end.sub(start);\n    }\n\n    function _getAccRewardPerShare(uint256 i) internal view returns (uint256) {\n        RewardTokenInfo memory rt = rewardTokenInfos[i];\n        if (totalSupply() == 0) {\n            return rt.accRewardPerShare;\n        }\n        return\n            rt.accRewardPerShare.add(\n                DecimalMath.divFloor(_getUnrewardBlockNum(i).mul(rt.rewardPerBlock), totalSupply())\n            );\n    }\n\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/SlowMist-DODO-MiningV3 and NFT Smart Contract Security Audit Report/contractV2-c7202eeae724783f572232a1d80b6b9082ee90b1/contracts/DODOToken/DODOMineV3/BaseMine.sol",
        "vulnerability": "Assertion Failure",
        "check": "FP",
        "response": "Answer: Yes\nDescription: The `require(false, \"DODOMineV3: TOKEN_NOT_FOUND\");` statements in `getIdByRewardToken`, `getVaultByRewardToken`, and `getVaultDebtByRewardToken` functions will always cause an assertion failure if the token is not found."
    },
    {
        "code_segment": "contract BaseMine is InitializableOwnable {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    // ============ Storage ============\n\n    struct RewardTokenInfo {\n        address rewardToken;\n        uint256 startBlock;\n        uint256 endBlock;\n        address rewardVault;\n        uint256 rewardPerBlock;\n        uint256 accRewardPerShare;\n        uint256 lastRewardBlock;\n        uint256 workThroughReward;\n        uint256 lastFlagBlock;\n        mapping(address => uint256) userRewardPerSharePaid;\n        mapping(address => uint256) userRewards;\n    }\n\n    RewardTokenInfo[] public rewardTokenInfos;\n\n    uint256 internal _totalSupply;\n    mapping(address => uint256) internal _balances;\n\n    // ============ Event =============\n\n    event Claim(uint256 indexed i, address indexed user, uint256 reward);\n    event UpdateReward(uint256 indexed i, uint256 rewardPerBlock);\n    event UpdateEndBlock(uint256 indexed i, uint256 endBlock);\n    event NewRewardToken(uint256 indexed i, address rewardToken);\n    event RemoveRewardToken(address rewardToken);\n    event WithdrawLeftOver(address owner, uint256 i);\n\n    // ============ View  ============\n\n    function getPendingReward(address user, uint256 i) public view returns (uint256) {\n        require(i<rewardTokenInfos.length, \"DODOMineV3: REWARD_ID_NOT_FOUND\");\n        RewardTokenInfo storage rt = rewardTokenInfos[i];\n        uint256 accRewardPerShare = rt.accRewardPerShare;\n        if (rt.lastRewardBlock != block.number) {\n            accRewardPerShare = _getAccRewardPerShare(i);\n        }\n        return\n            DecimalMath.mulFloor(\n                balanceOf(user), \n                accRewardPerShare.sub(rt.userRewardPerSharePaid[user])\n            ).add(rt.userRewards[user]);\n    }\n\n    function getPendingRewardByToken(address user, address rewardToken) external view returns (uint256) {\n        return getPendingReward(user, getIdByRewardToken(rewardToken));\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address user) public view returns (uint256) {\n        return _balances[user];\n    }\n\n    function getRewardTokenById(uint256 i) external view returns (address) {\n        require(i<rewardTokenInfos.length, \"DODOMineV3: REWARD_ID_NOT_FOUND\");\n        RewardTokenInfo memory rt = rewardTokenInfos[i];\n        return rt.rewardToken;\n    }\n\n    function getIdByRewardToken(address rewardToken) public view returns(uint256) {\n        uint256 len = rewardTokenInfos.length;\n        for (uint256 i = 0; i < len; i++) {\n            if (rewardToken == rewardTokenInfos[i].rewardToken) {\n                return i;\n            }\n        }\n        require(false, \"DODOMineV3: TOKEN_NOT_FOUND\");\n    }\n\n    function getRewardNum() external view returns(uint256) {\n        return rewardTokenInfos.length;\n    }\n\n    function getVaultByRewardToken(address rewardToken) public view returns(address) {\n        uint256 len = rewardTokenInfos.length;\n        for (uint256 i = 0; i < len; i++) {\n            if (rewardToken == rewardTokenInfos[i].rewardToken) {\n                return rewardTokenInfos[i].rewardVault;\n            }\n        }\n        require(false, \"DODOMineV3: TOKEN_NOT_FOUND\");\n    }\n\n    function getVaultDebtByRewardToken(address rewardToken) public view returns(uint256) {\n        uint256 len = rewardTokenInfos.length;\n        for (uint256 i = 0; i < len; i++) {\n            if (rewardToken == rewardTokenInfos[i].rewardToken) {\n                uint256 totalDepositReward = IRewardVault(rewardTokenInfos[i].rewardVault)._TOTAL_REWARD_();\n                uint256 gap = rewardTokenInfos[i].endBlock.sub(rewardTokenInfos[i].lastFlagBlock);\n                uint256 totalReward = rewardTokenInfos[i].workThroughReward.add(gap.mul(rewardTokenInfos[i].rewardPerBlock));\n                if(totalDepositReward >= totalReward) {\n                    return 0;\n                }else {\n                    return totalReward.sub(totalDepositReward);\n                }\n            }\n        }\n        require(false, \"DODOMineV3: TOKEN_NOT_FOUND\");\n    }\n\n    // ============ Claim ============\n\n    function claimReward(uint256 i) public {\n        require(i<rewardTokenInfos.length, \"DODOMineV3: REWARD_ID_NOT_FOUND\");\n        _updateReward(msg.sender, i);\n        RewardTokenInfo storage rt = rewardTokenInfos[i];\n        uint256 reward = rt.userRewards[msg.sender];\n        if (reward > 0) {\n            rt.userRewards[msg.sender] = 0;\n            IRewardVault(rt.rewardVault).reward(msg.sender, reward);\n            emit Claim(i, msg.sender, reward);\n        }\n    }\n\n    function claimAllRewards() external {\n        uint256 len = rewardTokenInfos.length;\n        for (uint256 i = 0; i < len; i++) {\n            claimReward(i);\n        }\n    }\n\n    // =============== Ownable  ================\n\n    function addRewardToken(\n        address rewardToken,\n        uint256 rewardPerBlock,\n        uint256 startBlock,\n        uint256 endBlock\n    ) external onlyOwner {\n        require(rewardToken != address(0), \"DODOMineV3: TOKEN_INVALID\");\n        require(startBlock > block.number, \"DODOMineV3: START_BLOCK_INVALID\");\n        require(endBlock > startBlock, \"DODOMineV3: DURATION_INVALID\");\n\n        uint256 len = rewardTokenInfos.length;\n        for (uint256 i = 0; i < len; i++) {\n            require(\n                rewardToken != rewardTokenInfos[i].rewardToken,\n                \"DODOMineV3: TOKEN_ALREADY_ADDED\"\n            );\n        }\n\n        RewardTokenInfo storage rt = rewardTokenInfos.push();\n        rt.rewardToken = rewardToken;\n        rt.startBlock = startBlock;\n        rt.lastFlagBlock = startBlock;\n        rt.endBlock = endBlock;\n        rt.rewardPerBlock = rewardPerBlock;\n        rt.rewardVault = address(new RewardVault(rewardToken));\n\n        uint256 rewardAmount = rewardPerBlock.mul(endBlock.sub(startBlock));\n        IERC20(rewardToken).transfer(rt.rewardVault, rewardAmount);\n        RewardVault(rt.rewardVault).syncValue();\n\n        emit NewRewardToken(len, rewardToken);\n    }\n\n    function setEndBlock(uint256 i, uint256 newEndBlock)\n        external\n        onlyOwner\n    {\n        require(i < rewardTokenInfos.length, \"DODOMineV3: REWARD_ID_NOT_FOUND\");\n        _updateReward(address(0), i);\n        RewardTokenInfo storage rt = rewardTokenInfos[i];\n\n\n        uint256 totalDepositReward = RewardVault(rt.rewardVault)._TOTAL_REWARD_();\n        uint256 gap = newEndBlock.sub(rt.lastFlagBlock);\n        uint256 totalReward = rt.workThroughReward.add(gap.mul(rt.rewardPerBlock));\n        require(totalDepositReward >= totalReward, \"DODOMineV3: REWARD_NOT_ENOUGH\");\n\n        require(block.number < newEndBlock, \"DODOMineV3: END_BLOCK_INVALID\");\n        require(block.number > rt.startBlock, \"DODOMineV3: NOT_START\");\n        require(block.number < rt.endBlock, \"DODOMineV3: ALREADY_CLOSE\");\n\n        rt.endBlock = newEndBlock;\n        emit UpdateEndBlock(i, newEndBlock);\n    }\n\n    function setReward(uint256 i, uint256 newRewardPerBlock)\n        external\n        onlyOwner\n    {\n        require(i < rewardTokenInfos.length, \"DODOMineV3: REWARD_ID_NOT_FOUND\");\n        _updateReward(address(0), i);\n        RewardTokenInfo storage rt = rewardTokenInfos[i];\n        \n        require(block.number < rt.endBlock, \"DODOMineV3: ALREADY_CLOSE\");\n        \n        rt.workThroughReward = rt.workThroughReward.add((block.number.sub(rt.lastFlagBlock)).mul(rt.rewardPerBlock));\n        rt.rewardPerBlock = newRewardPerBlock;\n        rt.lastFlagBlock = block.number;\n\n        uint256 totalDepositReward = RewardVault(rt.rewardVault)._TOTAL_REWARD_();\n        uint256 gap = rt.endBlock.sub(block.number);\n        uint256 totalReward = rt.workThroughReward.add(gap.mul(newRewardPerBlock));\n        require(totalDepositReward >= totalReward, \"DODOMineV3: REWARD_NOT_ENOUGH\");\n\n        emit UpdateReward(i, newRewardPerBlock);\n    }\n\n    function withdrawLeftOver(uint256 i, uint256 amount) external onlyOwner {\n        require(i < rewardTokenInfos.length, \"DODOMineV3: REWARD_ID_NOT_FOUND\");\n        \n        RewardTokenInfo storage rt = rewardTokenInfos[i];\n        require(block.number > rt.endBlock, \"DODOMineV3: MINING_NOT_FINISHED\");\n\n        IRewardVault(rt.rewardVault).withdrawLeftOver(msg.sender,amount);\n\n        emit WithdrawLeftOver(msg.sender, i);\n    }\n\n\n    function directTransferOwnership(address newOwner) external onlyOwner {\n        require(newOwner != address(0), \"DODOMineV3: ZERO_ADDRESS\");\n        emit OwnershipTransferred(_OWNER_, newOwner);\n        _OWNER_ = newOwner;\n    }\n\n    // ============ Internal  ============\n\n    function _updateReward(address user, uint256 i) internal {\n        RewardTokenInfo storage rt = rewardTokenInfos[i];\n        if (rt.lastRewardBlock != block.number){\n            rt.accRewardPerShare = _getAccRewardPerShare(i);\n            rt.lastRewardBlock = block.number;\n        }\n        if (user != address(0)) {\n            rt.userRewards[user] = getPendingReward(user, i);\n            rt.userRewardPerSharePaid[user] = rt.accRewardPerShare;\n        }\n    }\n    // SWC-128-DoS With Block Gas Limit: L260-L262\n    function _updateAllReward(address user) internal {\n        uint256 len = rewardTokenInfos.length;\n        for (uint256 i = 0; i < len; i++) {\n            _updateReward(user, i);\n        }\n    }\n\n    function _getUnrewardBlockNum(uint256 i) internal view returns (uint256) {\n        RewardTokenInfo memory rt = rewardTokenInfos[i];\n        if (block.number < rt.startBlock || rt.lastRewardBlock > rt.endBlock) {\n            return 0;\n        }\n        uint256 start = rt.lastRewardBlock < rt.startBlock ? rt.startBlock : rt.lastRewardBlock;\n        uint256 end = rt.endBlock < block.number ? rt.endBlock : block.number;\n        return end.sub(start);\n    }\n\n    function _getAccRewardPerShare(uint256 i) internal view returns (uint256) {\n        RewardTokenInfo memory rt = rewardTokenInfos[i];\n        if (totalSupply() == 0) {\n            return rt.accRewardPerShare;\n        }\n        return\n            rt.accRewardPerShare.add(\n                DecimalMath.divFloor(_getUnrewardBlockNum(i).mul(rt.rewardPerBlock), totalSupply())\n            );\n    }\n\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/SlowMist-DODO-MiningV3 and NFT Smart Contract Security Audit Report/contractV2-c7202eeae724783f572232a1d80b6b9082ee90b1/contracts/DODOToken/DODOMineV3/BaseMine.sol",
        "vulnerability": "Block Dependency",
        "check": "FP",
        "response": "Answer: Yes\nDescription: The contract utilizes block numbers in functions like `getPendingReward`, potentially allowing manipulation of timing-dependent logic for reward calculations."
    },
    {
        "code_segment": "contract DODODrops is InitializableMintableERC20, ReentrancyGuard {\n    using SafeMath for uint256;\n    using Address for address;\n    using UniversalERC20 for IERC20;\n\n    // ============ Storage ============\n    address constant _BASE_COIN_ = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    \n    address public _BUY_TOKEN_;\n    uint256 public _BUY_TOKEN_RESERVE_;\n    address public _FEE_MODEL_;\n    address payable public _MAINTAINER_;\n    address public _NFT_TOKEN_;\n\n    uint256 public _TICKET_UNIT_ = 1; // ticket consumed in a single lottery\n    \n    uint256 [] public _SELLING_TIME_INTERVAL_;\n    uint256 [] public _SELLING_PRICE_SET_;\n    uint256 [] public _SELLING_AMOUNT_SET_;\n    uint256 public _REDEEM_ALLOWED_TIME_;\n\n    uint256[] public _PROB_INTERVAL_; // index => Interval probability (Only For ProbMode)  \n    uint256[][] public _TOKEN_ID_MAP_; // Interval index => tokenIds (Only For ProbMode)\n    \n    uint256[] public _TOKEN_ID_LIST_; //index => tokenId (Only For FixedAmount mode)\n\n    bool public _IS_PROB_MODE_; // false = FixedAmount mode,  true = ProbMode\n    bool public _IS_REVEAL_MODE_;\n    uint256 public _REVEAL_RN_ = 0; \n    address public _RNG_;\n\n    fallback() external payable {}\n\n    receive() external payable {}\n\n    // ============ Modifiers ============\n\n    modifier notStart() {\n        require(block.timestamp < _SELLING_TIME_INTERVAL_[0] || _SELLING_TIME_INTERVAL_[0]  == 0, \"ALREADY_START\");\n        _;\n    }\n\n    // ============ Event =============\n    event BuyTicket(address account, uint256 payAmount, uint256 feeAmount, uint256 ticketAmount);\n    event RedeemPrize(address account, uint256 tokenId, address referer);\n\n    event ChangeRNG(address rng);\n    event ChangeRedeemTime(uint256 redeemTime);\n    event ChangeTicketUnit(uint256 newTicketUnit);\n    event Withdraw(address account, uint256 amount);\n    event SetReveal();\n\n    event SetSellingInfo();\n    event SetProbInfo(); // only for ProbMode\n    event SetTokenIdMapByIndex(uint256 index); // only for ProbMode\n    event SetFixedAmountInfo(); // only for FixedAmount mode\n\n\n    function init(\n        address[] memory addrList, //0 owner, 1 buyToken, 2 feeModel, 3 defaultMaintainer 4 rng 5 nftToken\n        uint256[] memory sellingTimeInterval,\n        uint256[] memory sellingPrice,\n        uint256[] memory sellingAmount,\n        uint256 redeemAllowedTime,\n        bool isRevealMode,\n        bool isProbMode\n    ) public {\n        _BUY_TOKEN_ = addrList[1];\n        _FEE_MODEL_ = addrList[2];\n        _MAINTAINER_ = payable(addrList[3]);\n        _RNG_ = addrList[4];\n        _NFT_TOKEN_ = addrList[5];\n\n        _IS_REVEAL_MODE_ = isRevealMode;\n        _IS_PROB_MODE_ = isProbMode;\n        _REDEEM_ALLOWED_TIME_ = redeemAllowedTime;\n\n        if(sellingTimeInterval.length > 0) _setSellingInfo(sellingTimeInterval, sellingPrice, sellingAmount);\n        \n        string memory prefix = \"DROPS_\";\n        name = string(abi.encodePacked(prefix, addressToShortString(address(this))));\n        symbol = name;\n        decimals = 0;\n\n        //init Owner\n        super.init(addrList[0], 0, name, symbol, decimals);\n    }\n\n    function buyTickets(address ticketTo, uint256 ticketAmount) payable external preventReentrant {\n        (uint256 curPrice, uint256 sellAmount, uint256 index) = getSellingInfo();\n        require(curPrice > 0 && sellAmount > 0, \"CAN_NOT_BUY\");\n        require(ticketAmount <= sellAmount, \"TICKETS_NOT_ENOUGH\");\n        (uint256 payAmount, uint256 feeAmount) = IDropsFeeModel(_FEE_MODEL_).getPayAmount(address(this), ticketTo, curPrice, ticketAmount);\n        require(payAmount > 0, \"UnQualified\");\n\n        uint256 baseBalance = IERC20(_BUY_TOKEN_).universalBalanceOf(address(this));\n        uint256 buyInput = baseBalance.sub(_BUY_TOKEN_RESERVE_);\n\n        require(payAmount <= buyInput, \"PAY_AMOUNT_NOT_ENOUGH\");\n\n        _SELLING_AMOUNT_SET_[index] = sellAmount.sub(ticketAmount);\n        _BUY_TOKEN_RESERVE_ = baseBalance.sub(feeAmount);\n\n        IERC20(_BUY_TOKEN_).universalTransfer(_MAINTAINER_,feeAmount);\n        _mint(ticketTo, ticketAmount);\n        emit BuyTicket(ticketTo, payAmount, feeAmount, ticketAmount);\n    }\n\n    function redeemTicket(uint256 ticketNum, address referer) external {\n        require(!address(msg.sender).isContract(), \"ONLY_ALLOW_EOA\");\n        require(ticketNum >= 1 && ticketNum <= balanceOf(msg.sender), \"TICKET_NUM_INVALID\");\n        _burn(msg.sender,ticketNum);\n        for (uint256 i = 0; i < ticketNum; i++) {\n            _redeemSinglePrize(msg.sender, i, referer);\n        }\n    }\n\n    // ============ Internal  ============\n    // SWC-120-Weak Sources of Randomness from Chain Attributes: L156\n    function _redeemSinglePrize(address to, uint256 curNo, address referer) internal {\n        require(block.timestamp >= _REDEEM_ALLOWED_TIME_ && _REDEEM_ALLOWED_TIME_ != 0, \"REDEEM_CLOSE\");\n        uint256 range;\n        if(_IS_PROB_MODE_) {\n            range = _PROB_INTERVAL_[_PROB_INTERVAL_.length - 1];\n        }else {\n            range = _TOKEN_ID_LIST_.length;\n        }\n        uint256 random;\n        if(_IS_REVEAL_MODE_) {\n            require(_REVEAL_RN_ != 0, \"REVEAL_NOT_SET\");\n            random = uint256(keccak256(abi.encodePacked(_REVEAL_RN_, msg.sender, balanceOf(msg.sender).add(curNo + 1)))) % range;\n        }else {\n            random = IRandomGenerator(_RNG_).random(gasleft() + block.number) % range; \n        }\n        uint256 tokenId;\n        if(_IS_PROB_MODE_) {\n            uint256 i;\n            for (i = 0; i < _PROB_INTERVAL_.length; i++) {\n                if (random <= _PROB_INTERVAL_[i]) {\n                    break;\n                }\n            }\n            require(_TOKEN_ID_MAP_[i].length > 0, \"EMPTY_TOKEN_ID_MAP\");\n            tokenId = _TOKEN_ID_MAP_[i][random % _TOKEN_ID_MAP_[i].length];\n            IDropsNft(_NFT_TOKEN_).mint(to, tokenId, 1, \"\");\n        } else {\n            tokenId = _TOKEN_ID_LIST_[random];\n            if(random != range - 1) {\n                _TOKEN_ID_LIST_[random] = _TOKEN_ID_LIST_[range - 1];\n            }\n            _TOKEN_ID_LIST_.pop();\n            IDropsNft(_NFT_TOKEN_).mint(to, tokenId);  \n        }\n        emit RedeemPrize(to, tokenId, referer);\n    }\n\n\n    function _setSellingInfo(uint256[] memory sellingTimeIntervals, uint256[] memory sellingPrice, uint256[] memory sellingAmount) internal {\n        require(sellingTimeIntervals.length > 0, \"PARAM_NOT_INVALID\");\n        require(sellingTimeIntervals.length == sellingPrice.length && sellingPrice.length == sellingAmount.length, \"PARAM_NOT_INVALID\");\n        for (uint256 i = 0; i < sellingTimeIntervals.length - 1; i++) {\n            require(sellingTimeIntervals[i] < sellingTimeIntervals[i + 1], \"INTERVAL_INVALID\");\n            require(sellingPrice[i] != 0, \"PRICE_INVALID\");\n        }\n        _SELLING_TIME_INTERVAL_ = sellingTimeIntervals;\n        _SELLING_PRICE_SET_ = sellingPrice;\n        _SELLING_AMOUNT_SET_ = sellingAmount;\n        emit SetSellingInfo();\n    }\n\n\n    function _setProbInfo(uint256[] memory probIntervals,uint256[][] memory tokenIdMap) internal {\n        require(_IS_PROB_MODE_, \"ONLY_ALLOW_PROB_MODE\");\n        require(probIntervals.length > 0, \"PARAM_NOT_INVALID\");\n        require(tokenIdMap.length == probIntervals.length, \"PARAM_NOT_INVALID\");\n\n        require(tokenIdMap[0].length > 0, \"INVALID\");\n        for (uint256 i = 1; i < probIntervals.length; i++) {\n            require(probIntervals[i] > probIntervals[i - 1], \"INTERVAL_INVALID\");\n            require(tokenIdMap[i].length > 0, \"INVALID\");\n        }\n        _PROB_INTERVAL_ = probIntervals;\n        _TOKEN_ID_MAP_ = tokenIdMap;\n        emit SetProbInfo();\n    }\n\n    function _setFixedAmountInfo(uint256[] memory tokenIdList) internal {\n        require(!_IS_PROB_MODE_, \"ONLY_ALLOW_FIXED_AMOUNT_MODE\");\n        require(tokenIdList.length > 0, \"PARAM_NOT_INVALID\");\n        _TOKEN_ID_LIST_ = tokenIdList;\n        emit SetFixedAmountInfo();\n    }\n\n    // ================= Owner ===================\n\n    function withdraw() external onlyOwner {\n        uint256 amount = IERC20(_BUY_TOKEN_).universalBalanceOf(address(this));\n        IERC20(_BUY_TOKEN_).universalTransfer(msg.sender ,amount);\n        emit Withdraw(msg.sender, amount);\n    }\n\n    function setRevealRn() external onlyOwner {\n        require(_REVEAL_RN_ == 0, \"ALREADY_SET\");\n        _REVEAL_RN_ = uint256(keccak256(abi.encodePacked(blockhash(block.number - 1))));\n        emit SetReveal();\n    }\n    \n    function setSellingInfo(uint256[] memory sellingTimeIntervals, uint256[] memory prices, uint256[] memory amounts) external notStart() onlyOwner {\n        _setSellingInfo(sellingTimeIntervals, prices, amounts);\n    }\n\n    function setProbInfo(uint256[] memory probIntervals,uint256[][] memory tokenIdMaps) external notStart() onlyOwner {\n        _setProbInfo(probIntervals, tokenIdMaps);\n    }\n\n    function setFixedAmountInfo(uint256[] memory tokenIdList) external notStart() onlyOwner {\n        _setFixedAmountInfo(tokenIdList);\n    }\n\n    function addFixedAmountInfo(uint256[] memory addTokenIdList) external notStart() onlyOwner {\n        for (uint256 i = 0; i < addTokenIdList.length; i++) {\n            _TOKEN_ID_LIST_.push(addTokenIdList[i]);\n        }\n        emit SetFixedAmountInfo();\n    }\n\n    function setTokenIdMapByIndex(uint256 index, uint256[] memory tokenIds) external notStart() onlyOwner {\n        require(_IS_PROB_MODE_, \"ONLY_ALLOW_PROB_MODE\");\n        require(tokenIds.length > 0 && index < _TOKEN_ID_MAP_.length,\"PARAM_NOT_INVALID\");\n        _TOKEN_ID_MAP_[index] = tokenIds;\n        emit SetTokenIdMapByIndex(index);\n    }\n    \n    function updateRNG(address newRNG) external onlyOwner {\n        require(newRNG != address(0));\n        _RNG_ = newRNG;\n        emit ChangeRNG(newRNG);\n    }\n\n    function updateTicketUnit(uint256 newTicketUnit) external onlyOwner {\n        require(newTicketUnit != 0);\n        _TICKET_UNIT_ = newTicketUnit;\n        emit ChangeTicketUnit(newTicketUnit);\n    }\n\n    function updateRedeemTime(uint256 newRedeemTime) external onlyOwner {\n        require(newRedeemTime > block.timestamp || newRedeemTime == 0, \"PARAM_NOT_INVALID\");\n        _REDEEM_ALLOWED_TIME_ = newRedeemTime;\n        emit ChangeRedeemTime(newRedeemTime);\n    }\n\n    // ================= View ===================\n\n    function getSellingStage() public view returns (uint256 stageLen) {\n        stageLen = _SELLING_TIME_INTERVAL_.length;\n    }\n\n    function getSellingInfo() public view returns (uint256 curPrice, uint256 sellAmount, uint256 index) {\n        uint256 curBlockTime = block.timestamp;\n        if(curBlockTime >= _SELLING_TIME_INTERVAL_[0] && _SELLING_TIME_INTERVAL_[0] != 0) {\n            uint256 i;\n            for (i = 1; i < _SELLING_TIME_INTERVAL_.length; i++) {\n                if (curBlockTime <= _SELLING_TIME_INTERVAL_[i]) {\n                    break;\n                }\n            }\n            curPrice = _SELLING_PRICE_SET_[i-1];\n            sellAmount = _SELLING_AMOUNT_SET_[i-1];\n            index = i - 1;\n        }\n    }\n\n    function addressToShortString(address _addr) public pure returns (string memory) {\n        bytes32 value = bytes32(uint256(_addr));\n        bytes memory alphabet = \"0123456789abcdef\";\n\n        bytes memory str = new bytes(8);\n        for (uint256 i = 0; i < 4; i++) {\n            str[i * 2] = alphabet[uint8(value[i + 12] >> 4)];\n            str[1 + i * 2] = alphabet[uint8(value[i + 12] & 0x0f)];\n        }\n        return string(str);\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/SlowMist-DODO-MiningV3 and NFT Smart Contract Security Audit Report/contractV2-453e323af65f0a666f7d9c2dfd01b9d32ea19533/contracts/DODODrops/DODODropsV2/DODODrops.sol",
        "vulnerability": "Assertion Failure",
        "check": "FP",
        "response": "Answer: No\nReason: The contract code does not contain any evident assertions using the `assert` statement, which would lead to an assertion failure vulnerability."
    },
    {
        "code_segment": "contract DODODrops is InitializableMintableERC20, ReentrancyGuard {\n    using SafeMath for uint256;\n    using Address for address;\n    using UniversalERC20 for IERC20;\n\n    // ============ Storage ============\n    address constant _BASE_COIN_ = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    \n    address public _BUY_TOKEN_;\n    uint256 public _BUY_TOKEN_RESERVE_;\n    address public _FEE_MODEL_;\n    address payable public _MAINTAINER_;\n    address public _NFT_TOKEN_;\n\n    uint256 public _TICKET_UNIT_ = 1; // ticket consumed in a single lottery\n    \n    uint256 [] public _SELLING_TIME_INTERVAL_;\n    uint256 [] public _SELLING_PRICE_SET_;\n    uint256 [] public _SELLING_AMOUNT_SET_;\n    uint256 public _REDEEM_ALLOWED_TIME_;\n\n    uint256[] public _PROB_INTERVAL_; // index => Interval probability (Only For ProbMode)  \n    uint256[][] public _TOKEN_ID_MAP_; // Interval index => tokenIds (Only For ProbMode)\n    \n    uint256[] public _TOKEN_ID_LIST_; //index => tokenId (Only For FixedAmount mode)\n\n    bool public _IS_PROB_MODE_; // false = FixedAmount mode,  true = ProbMode\n    bool public _IS_REVEAL_MODE_;\n    uint256 public _REVEAL_RN_ = 0; \n    address public _RNG_;\n\n    fallback() external payable {}\n\n    receive() external payable {}\n\n    // ============ Modifiers ============\n\n    modifier notStart() {\n        require(block.timestamp < _SELLING_TIME_INTERVAL_[0] || _SELLING_TIME_INTERVAL_[0]  == 0, \"ALREADY_START\");\n        _;\n    }\n\n    // ============ Event =============\n    event BuyTicket(address account, uint256 payAmount, uint256 feeAmount, uint256 ticketAmount);\n    event RedeemPrize(address account, uint256 tokenId, address referer);\n\n    event ChangeRNG(address rng);\n    event ChangeRedeemTime(uint256 redeemTime);\n    event ChangeTicketUnit(uint256 newTicketUnit);\n    event Withdraw(address account, uint256 amount);\n    event SetReveal();\n\n    event SetSellingInfo();\n    event SetProbInfo(); // only for ProbMode\n    event SetTokenIdMapByIndex(uint256 index); // only for ProbMode\n    event SetFixedAmountInfo(); // only for FixedAmount mode\n\n\n    function init(\n        address[] memory addrList, //0 owner, 1 buyToken, 2 feeModel, 3 defaultMaintainer 4 rng 5 nftToken\n        uint256[] memory sellingTimeInterval,\n        uint256[] memory sellingPrice,\n        uint256[] memory sellingAmount,\n        uint256 redeemAllowedTime,\n        bool isRevealMode,\n        bool isProbMode\n    ) public {\n        _BUY_TOKEN_ = addrList[1];\n        _FEE_MODEL_ = addrList[2];\n        _MAINTAINER_ = payable(addrList[3]);\n        _RNG_ = addrList[4];\n        _NFT_TOKEN_ = addrList[5];\n\n        _IS_REVEAL_MODE_ = isRevealMode;\n        _IS_PROB_MODE_ = isProbMode;\n        _REDEEM_ALLOWED_TIME_ = redeemAllowedTime;\n\n        if(sellingTimeInterval.length > 0) _setSellingInfo(sellingTimeInterval, sellingPrice, sellingAmount);\n        \n        string memory prefix = \"DROPS_\";\n        name = string(abi.encodePacked(prefix, addressToShortString(address(this))));\n        symbol = name;\n        decimals = 0;\n\n        //init Owner\n        super.init(addrList[0], 0, name, symbol, decimals);\n    }\n\n    function buyTickets(address ticketTo, uint256 ticketAmount) payable external preventReentrant {\n        (uint256 curPrice, uint256 sellAmount, uint256 index) = getSellingInfo();\n        require(curPrice > 0 && sellAmount > 0, \"CAN_NOT_BUY\");\n        require(ticketAmount <= sellAmount, \"TICKETS_NOT_ENOUGH\");\n        (uint256 payAmount, uint256 feeAmount) = IDropsFeeModel(_FEE_MODEL_).getPayAmount(address(this), ticketTo, curPrice, ticketAmount);\n        require(payAmount > 0, \"UnQualified\");\n\n        uint256 baseBalance = IERC20(_BUY_TOKEN_).universalBalanceOf(address(this));\n        uint256 buyInput = baseBalance.sub(_BUY_TOKEN_RESERVE_);\n\n        require(payAmount <= buyInput, \"PAY_AMOUNT_NOT_ENOUGH\");\n\n        _SELLING_AMOUNT_SET_[index] = sellAmount.sub(ticketAmount);\n        _BUY_TOKEN_RESERVE_ = baseBalance.sub(feeAmount);\n\n        IERC20(_BUY_TOKEN_).universalTransfer(_MAINTAINER_,feeAmount);\n        _mint(ticketTo, ticketAmount);\n        emit BuyTicket(ticketTo, payAmount, feeAmount, ticketAmount);\n    }\n\n    function redeemTicket(uint256 ticketNum, address referer) external {\n        require(!address(msg.sender).isContract(), \"ONLY_ALLOW_EOA\");\n        require(ticketNum >= 1 && ticketNum <= balanceOf(msg.sender), \"TICKET_NUM_INVALID\");\n        _burn(msg.sender,ticketNum);\n        for (uint256 i = 0; i < ticketNum; i++) {\n            _redeemSinglePrize(msg.sender, i, referer);\n        }\n    }\n\n    // ============ Internal  ============\n    // SWC-120-Weak Sources of Randomness from Chain Attributes: L156\n    function _redeemSinglePrize(address to, uint256 curNo, address referer) internal {\n        require(block.timestamp >= _REDEEM_ALLOWED_TIME_ && _REDEEM_ALLOWED_TIME_ != 0, \"REDEEM_CLOSE\");\n        uint256 range;\n        if(_IS_PROB_MODE_) {\n            range = _PROB_INTERVAL_[_PROB_INTERVAL_.length - 1];\n        }else {\n            range = _TOKEN_ID_LIST_.length;\n        }\n        uint256 random;\n        if(_IS_REVEAL_MODE_) {\n            require(_REVEAL_RN_ != 0, \"REVEAL_NOT_SET\");\n            random = uint256(keccak256(abi.encodePacked(_REVEAL_RN_, msg.sender, balanceOf(msg.sender).add(curNo + 1)))) % range;\n        }else {\n            random = IRandomGenerator(_RNG_).random(gasleft() + block.number) % range; \n        }\n        uint256 tokenId;\n        if(_IS_PROB_MODE_) {\n            uint256 i;\n            for (i = 0; i < _PROB_INTERVAL_.length; i++) {\n                if (random <= _PROB_INTERVAL_[i]) {\n                    break;\n                }\n            }\n            require(_TOKEN_ID_MAP_[i].length > 0, \"EMPTY_TOKEN_ID_MAP\");\n            tokenId = _TOKEN_ID_MAP_[i][random % _TOKEN_ID_MAP_[i].length];\n            IDropsNft(_NFT_TOKEN_).mint(to, tokenId, 1, \"\");\n        } else {\n            tokenId = _TOKEN_ID_LIST_[random];\n            if(random != range - 1) {\n                _TOKEN_ID_LIST_[random] = _TOKEN_ID_LIST_[range - 1];\n            }\n            _TOKEN_ID_LIST_.pop();\n            IDropsNft(_NFT_TOKEN_).mint(to, tokenId);  \n        }\n        emit RedeemPrize(to, tokenId, referer);\n    }\n\n\n    function _setSellingInfo(uint256[] memory sellingTimeIntervals, uint256[] memory sellingPrice, uint256[] memory sellingAmount) internal {\n        require(sellingTimeIntervals.length > 0, \"PARAM_NOT_INVALID\");\n        require(sellingTimeIntervals.length == sellingPrice.length && sellingPrice.length == sellingAmount.length, \"PARAM_NOT_INVALID\");\n        for (uint256 i = 0; i < sellingTimeIntervals.length - 1; i++) {\n            require(sellingTimeIntervals[i] < sellingTimeIntervals[i + 1], \"INTERVAL_INVALID\");\n            require(sellingPrice[i] != 0, \"PRICE_INVALID\");\n        }\n        _SELLING_TIME_INTERVAL_ = sellingTimeIntervals;\n        _SELLING_PRICE_SET_ = sellingPrice;\n        _SELLING_AMOUNT_SET_ = sellingAmount;\n        emit SetSellingInfo();\n    }\n\n\n    function _setProbInfo(uint256[] memory probIntervals,uint256[][] memory tokenIdMap) internal {\n        require(_IS_PROB_MODE_, \"ONLY_ALLOW_PROB_MODE\");\n        require(probIntervals.length > 0, \"PARAM_NOT_INVALID\");\n        require(tokenIdMap.length == probIntervals.length, \"PARAM_NOT_INVALID\");\n\n        require(tokenIdMap[0].length > 0, \"INVALID\");\n        for (uint256 i = 1; i < probIntervals.length; i++) {\n            require(probIntervals[i] > probIntervals[i - 1], \"INTERVAL_INVALID\");\n            require(tokenIdMap[i].length > 0, \"INVALID\");\n        }\n        _PROB_INTERVAL_ = probIntervals;\n        _TOKEN_ID_MAP_ = tokenIdMap;\n        emit SetProbInfo();\n    }\n\n    function _setFixedAmountInfo(uint256[] memory tokenIdList) internal {\n        require(!_IS_PROB_MODE_, \"ONLY_ALLOW_FIXED_AMOUNT_MODE\");\n        require(tokenIdList.length > 0, \"PARAM_NOT_INVALID\");\n        _TOKEN_ID_LIST_ = tokenIdList;\n        emit SetFixedAmountInfo();\n    }\n\n    // ================= Owner ===================\n\n    function withdraw() external onlyOwner {\n        uint256 amount = IERC20(_BUY_TOKEN_).universalBalanceOf(address(this));\n        IERC20(_BUY_TOKEN_).universalTransfer(msg.sender ,amount);\n        emit Withdraw(msg.sender, amount);\n    }\n\n    function setRevealRn() external onlyOwner {\n        require(_REVEAL_RN_ == 0, \"ALREADY_SET\");\n        _REVEAL_RN_ = uint256(keccak256(abi.encodePacked(blockhash(block.number - 1))));\n        emit SetReveal();\n    }\n    \n    function setSellingInfo(uint256[] memory sellingTimeIntervals, uint256[] memory prices, uint256[] memory amounts) external notStart() onlyOwner {\n        _setSellingInfo(sellingTimeIntervals, prices, amounts);\n    }\n\n    function setProbInfo(uint256[] memory probIntervals,uint256[][] memory tokenIdMaps) external notStart() onlyOwner {\n        _setProbInfo(probIntervals, tokenIdMaps);\n    }\n\n    function setFixedAmountInfo(uint256[] memory tokenIdList) external notStart() onlyOwner {\n        _setFixedAmountInfo(tokenIdList);\n    }\n\n    function addFixedAmountInfo(uint256[] memory addTokenIdList) external notStart() onlyOwner {\n        for (uint256 i = 0; i < addTokenIdList.length; i++) {\n            _TOKEN_ID_LIST_.push(addTokenIdList[i]);\n        }\n        emit SetFixedAmountInfo();\n    }\n\n    function setTokenIdMapByIndex(uint256 index, uint256[] memory tokenIds) external notStart() onlyOwner {\n        require(_IS_PROB_MODE_, \"ONLY_ALLOW_PROB_MODE\");\n        require(tokenIds.length > 0 && index < _TOKEN_ID_MAP_.length,\"PARAM_NOT_INVALID\");\n        _TOKEN_ID_MAP_[index] = tokenIds;\n        emit SetTokenIdMapByIndex(index);\n    }\n    \n    function updateRNG(address newRNG) external onlyOwner {\n        require(newRNG != address(0));\n        _RNG_ = newRNG;\n        emit ChangeRNG(newRNG);\n    }\n\n    function updateTicketUnit(uint256 newTicketUnit) external onlyOwner {\n        require(newTicketUnit != 0);\n        _TICKET_UNIT_ = newTicketUnit;\n        emit ChangeTicketUnit(newTicketUnit);\n    }\n\n    function updateRedeemTime(uint256 newRedeemTime) external onlyOwner {\n        require(newRedeemTime > block.timestamp || newRedeemTime == 0, \"PARAM_NOT_INVALID\");\n        _REDEEM_ALLOWED_TIME_ = newRedeemTime;\n        emit ChangeRedeemTime(newRedeemTime);\n    }\n\n    // ================= View ===================\n\n    function getSellingStage() public view returns (uint256 stageLen) {\n        stageLen = _SELLING_TIME_INTERVAL_.length;\n    }\n\n    function getSellingInfo() public view returns (uint256 curPrice, uint256 sellAmount, uint256 index) {\n        uint256 curBlockTime = block.timestamp;\n        if(curBlockTime >= _SELLING_TIME_INTERVAL_[0] && _SELLING_TIME_INTERVAL_[0] != 0) {\n            uint256 i;\n            for (i = 1; i < _SELLING_TIME_INTERVAL_.length; i++) {\n                if (curBlockTime <= _SELLING_TIME_INTERVAL_[i]) {\n                    break;\n                }\n            }\n            curPrice = _SELLING_PRICE_SET_[i-1];\n            sellAmount = _SELLING_AMOUNT_SET_[i-1];\n            index = i - 1;\n        }\n    }\n\n    function addressToShortString(address _addr) public pure returns (string memory) {\n        bytes32 value = bytes32(uint256(_addr));\n        bytes memory alphabet = \"0123456789abcdef\";\n\n        bytes memory str = new bytes(8);\n        for (uint256 i = 0; i < 4; i++) {\n            str[i * 2] = alphabet[uint8(value[i + 12] >> 4)];\n            str[1 + i * 2] = alphabet[uint8(value[i + 12] & 0x0f)];\n        }\n        return string(str);\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/SlowMist-DODO-MiningV3 and NFT Smart Contract Security Audit Report/contractV2-453e323af65f0a666f7d9c2dfd01b9d32ea19533/contracts/DODODrops/DODODropsV2/DODODrops.sol",
        "vulnerability": "Assertion Failure",
        "check": "FP",
        "response": "Answer: No\nReason: The code does not explicitly use \"assert\" statements or similar unchecked operations that could cause assertion failures."
    },
    {
        "code_segment": "contract DODODrops is InitializableMintableERC20, ReentrancyGuard {\n    using SafeMath for uint256;\n    using Address for address;\n    using UniversalERC20 for IERC20;\n\n    // ============ Storage ============\n    address constant _BASE_COIN_ = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    \n    address public _BUY_TOKEN_;\n    uint256 public _BUY_TOKEN_RESERVE_;\n    address public _FEE_MODEL_;\n    address payable public _MAINTAINER_;\n    address public _NFT_TOKEN_;\n\n    uint256 public _TICKET_UNIT_ = 1; // ticket consumed in a single lottery\n    \n    uint256 [] public _SELLING_TIME_INTERVAL_;\n    uint256 [] public _SELLING_PRICE_SET_;\n    uint256 [] public _SELLING_AMOUNT_SET_;\n    uint256 public _REDEEM_ALLOWED_TIME_;\n\n    uint256[] public _PROB_INTERVAL_; // index => Interval probability (Only For ProbMode)  \n    uint256[][] public _TOKEN_ID_MAP_; // Interval index => tokenIds (Only For ProbMode)\n    \n    uint256[] public _TOKEN_ID_LIST_; //index => tokenId (Only For FixedAmount mode)\n\n    bool public _IS_PROB_MODE_; // false = FixedAmount mode,  true = ProbMode\n    bool public _IS_REVEAL_MODE_;\n    uint256 public _REVEAL_RN_ = 0; \n    address public _RNG_;\n\n    fallback() external payable {}\n\n    receive() external payable {}\n\n    // ============ Modifiers ============\n\n    modifier notStart() {\n        require(block.timestamp < _SELLING_TIME_INTERVAL_[0] || _SELLING_TIME_INTERVAL_[0]  == 0, \"ALREADY_START\");\n        _;\n    }\n\n    // ============ Event =============\n    event BuyTicket(address account, uint256 payAmount, uint256 feeAmount, uint256 ticketAmount);\n    event RedeemPrize(address account, uint256 tokenId, address referer);\n\n    event ChangeRNG(address rng);\n    event ChangeRedeemTime(uint256 redeemTime);\n    event ChangeTicketUnit(uint256 newTicketUnit);\n    event Withdraw(address account, uint256 amount);\n    event SetReveal();\n\n    event SetSellingInfo();\n    event SetProbInfo(); // only for ProbMode\n    event SetTokenIdMapByIndex(uint256 index); // only for ProbMode\n    event SetFixedAmountInfo(); // only for FixedAmount mode\n\n\n    function init(\n        address[] memory addrList, //0 owner, 1 buyToken, 2 feeModel, 3 defaultMaintainer 4 rng 5 nftToken\n        uint256[] memory sellingTimeInterval,\n        uint256[] memory sellingPrice,\n        uint256[] memory sellingAmount,\n        uint256 redeemAllowedTime,\n        bool isRevealMode,\n        bool isProbMode\n    ) public {\n        _BUY_TOKEN_ = addrList[1];\n        _FEE_MODEL_ = addrList[2];\n        _MAINTAINER_ = payable(addrList[3]);\n        _RNG_ = addrList[4];\n        _NFT_TOKEN_ = addrList[5];\n\n        _IS_REVEAL_MODE_ = isRevealMode;\n        _IS_PROB_MODE_ = isProbMode;\n        _REDEEM_ALLOWED_TIME_ = redeemAllowedTime;\n\n        if(sellingTimeInterval.length > 0) _setSellingInfo(sellingTimeInterval, sellingPrice, sellingAmount);\n        \n        string memory prefix = \"DROPS_\";\n        name = string(abi.encodePacked(prefix, addressToShortString(address(this))));\n        symbol = name;\n        decimals = 0;\n\n        //init Owner\n        super.init(addrList[0], 0, name, symbol, decimals);\n    }\n\n    function buyTickets(address ticketTo, uint256 ticketAmount) payable external preventReentrant {\n        (uint256 curPrice, uint256 sellAmount, uint256 index) = getSellingInfo();\n        require(curPrice > 0 && sellAmount > 0, \"CAN_NOT_BUY\");\n        require(ticketAmount <= sellAmount, \"TICKETS_NOT_ENOUGH\");\n        (uint256 payAmount, uint256 feeAmount) = IDropsFeeModel(_FEE_MODEL_).getPayAmount(address(this), ticketTo, curPrice, ticketAmount);\n        require(payAmount > 0, \"UnQualified\");\n\n        uint256 baseBalance = IERC20(_BUY_TOKEN_).universalBalanceOf(address(this));\n        uint256 buyInput = baseBalance.sub(_BUY_TOKEN_RESERVE_);\n\n        require(payAmount <= buyInput, \"PAY_AMOUNT_NOT_ENOUGH\");\n\n        _SELLING_AMOUNT_SET_[index] = sellAmount.sub(ticketAmount);\n        _BUY_TOKEN_RESERVE_ = baseBalance.sub(feeAmount);\n\n        IERC20(_BUY_TOKEN_).universalTransfer(_MAINTAINER_,feeAmount);\n        _mint(ticketTo, ticketAmount);\n        emit BuyTicket(ticketTo, payAmount, feeAmount, ticketAmount);\n    }\n\n    function redeemTicket(uint256 ticketNum, address referer) external {\n        require(!address(msg.sender).isContract(), \"ONLY_ALLOW_EOA\");\n        require(ticketNum >= 1 && ticketNum <= balanceOf(msg.sender), \"TICKET_NUM_INVALID\");\n        _burn(msg.sender,ticketNum);\n        for (uint256 i = 0; i < ticketNum; i++) {\n            _redeemSinglePrize(msg.sender, i, referer);\n        }\n    }\n\n    // ============ Internal  ============\n    // SWC-120-Weak Sources of Randomness from Chain Attributes: L156\n    function _redeemSinglePrize(address to, uint256 curNo, address referer) internal {\n        require(block.timestamp >= _REDEEM_ALLOWED_TIME_ && _REDEEM_ALLOWED_TIME_ != 0, \"REDEEM_CLOSE\");\n        uint256 range;\n        if(_IS_PROB_MODE_) {\n            range = _PROB_INTERVAL_[_PROB_INTERVAL_.length - 1];\n        }else {\n            range = _TOKEN_ID_LIST_.length;\n        }\n        uint256 random;\n        if(_IS_REVEAL_MODE_) {\n            require(_REVEAL_RN_ != 0, \"REVEAL_NOT_SET\");\n            random = uint256(keccak256(abi.encodePacked(_REVEAL_RN_, msg.sender, balanceOf(msg.sender).add(curNo + 1)))) % range;\n        }else {\n            random = IRandomGenerator(_RNG_).random(gasleft() + block.number) % range; \n        }\n        uint256 tokenId;\n        if(_IS_PROB_MODE_) {\n            uint256 i;\n            for (i = 0; i < _PROB_INTERVAL_.length; i++) {\n                if (random <= _PROB_INTERVAL_[i]) {\n                    break;\n                }\n            }\n            require(_TOKEN_ID_MAP_[i].length > 0, \"EMPTY_TOKEN_ID_MAP\");\n            tokenId = _TOKEN_ID_MAP_[i][random % _TOKEN_ID_MAP_[i].length];\n            IDropsNft(_NFT_TOKEN_).mint(to, tokenId, 1, \"\");\n        } else {\n            tokenId = _TOKEN_ID_LIST_[random];\n            if(random != range - 1) {\n                _TOKEN_ID_LIST_[random] = _TOKEN_ID_LIST_[range - 1];\n            }\n            _TOKEN_ID_LIST_.pop();\n            IDropsNft(_NFT_TOKEN_).mint(to, tokenId);  \n        }\n        emit RedeemPrize(to, tokenId, referer);\n    }\n\n\n    function _setSellingInfo(uint256[] memory sellingTimeIntervals, uint256[] memory sellingPrice, uint256[] memory sellingAmount) internal {\n        require(sellingTimeIntervals.length > 0, \"PARAM_NOT_INVALID\");\n        require(sellingTimeIntervals.length == sellingPrice.length && sellingPrice.length == sellingAmount.length, \"PARAM_NOT_INVALID\");\n        for (uint256 i = 0; i < sellingTimeIntervals.length - 1; i++) {\n            require(sellingTimeIntervals[i] < sellingTimeIntervals[i + 1], \"INTERVAL_INVALID\");\n            require(sellingPrice[i] != 0, \"PRICE_INVALID\");\n        }\n        _SELLING_TIME_INTERVAL_ = sellingTimeIntervals;\n        _SELLING_PRICE_SET_ = sellingPrice;\n        _SELLING_AMOUNT_SET_ = sellingAmount;\n        emit SetSellingInfo();\n    }\n\n\n    function _setProbInfo(uint256[] memory probIntervals,uint256[][] memory tokenIdMap) internal {\n        require(_IS_PROB_MODE_, \"ONLY_ALLOW_PROB_MODE\");\n        require(probIntervals.length > 0, \"PARAM_NOT_INVALID\");\n        require(tokenIdMap.length == probIntervals.length, \"PARAM_NOT_INVALID\");\n\n        require(tokenIdMap[0].length > 0, \"INVALID\");\n        for (uint256 i = 1; i < probIntervals.length; i++) {\n            require(probIntervals[i] > probIntervals[i - 1], \"INTERVAL_INVALID\");\n            require(tokenIdMap[i].length > 0, \"INVALID\");\n        }\n        _PROB_INTERVAL_ = probIntervals;\n        _TOKEN_ID_MAP_ = tokenIdMap;\n        emit SetProbInfo();\n    }\n\n    function _setFixedAmountInfo(uint256[] memory tokenIdList) internal {\n        require(!_IS_PROB_MODE_, \"ONLY_ALLOW_FIXED_AMOUNT_MODE\");\n        require(tokenIdList.length > 0, \"PARAM_NOT_INVALID\");\n        _TOKEN_ID_LIST_ = tokenIdList;\n        emit SetFixedAmountInfo();\n    }\n\n    // ================= Owner ===================\n\n    function withdraw() external onlyOwner {\n        uint256 amount = IERC20(_BUY_TOKEN_).universalBalanceOf(address(this));\n        IERC20(_BUY_TOKEN_).universalTransfer(msg.sender ,amount);\n        emit Withdraw(msg.sender, amount);\n    }\n\n    function setRevealRn() external onlyOwner {\n        require(_REVEAL_RN_ == 0, \"ALREADY_SET\");\n        _REVEAL_RN_ = uint256(keccak256(abi.encodePacked(blockhash(block.number - 1))));\n        emit SetReveal();\n    }\n    \n    function setSellingInfo(uint256[] memory sellingTimeIntervals, uint256[] memory prices, uint256[] memory amounts) external notStart() onlyOwner {\n        _setSellingInfo(sellingTimeIntervals, prices, amounts);\n    }\n\n    function setProbInfo(uint256[] memory probIntervals,uint256[][] memory tokenIdMaps) external notStart() onlyOwner {\n        _setProbInfo(probIntervals, tokenIdMaps);\n    }\n\n    function setFixedAmountInfo(uint256[] memory tokenIdList) external notStart() onlyOwner {\n        _setFixedAmountInfo(tokenIdList);\n    }\n\n    function addFixedAmountInfo(uint256[] memory addTokenIdList) external notStart() onlyOwner {\n        for (uint256 i = 0; i < addTokenIdList.length; i++) {\n            _TOKEN_ID_LIST_.push(addTokenIdList[i]);\n        }\n        emit SetFixedAmountInfo();\n    }\n\n    function setTokenIdMapByIndex(uint256 index, uint256[] memory tokenIds) external notStart() onlyOwner {\n        require(_IS_PROB_MODE_, \"ONLY_ALLOW_PROB_MODE\");\n        require(tokenIds.length > 0 && index < _TOKEN_ID_MAP_.length,\"PARAM_NOT_INVALID\");\n        _TOKEN_ID_MAP_[index] = tokenIds;\n        emit SetTokenIdMapByIndex(index);\n    }\n    \n    function updateRNG(address newRNG) external onlyOwner {\n        require(newRNG != address(0));\n        _RNG_ = newRNG;\n        emit ChangeRNG(newRNG);\n    }\n\n    function updateTicketUnit(uint256 newTicketUnit) external onlyOwner {\n        require(newTicketUnit != 0);\n        _TICKET_UNIT_ = newTicketUnit;\n        emit ChangeTicketUnit(newTicketUnit);\n    }\n\n    function updateRedeemTime(uint256 newRedeemTime) external onlyOwner {\n        require(newRedeemTime > block.timestamp || newRedeemTime == 0, \"PARAM_NOT_INVALID\");\n        _REDEEM_ALLOWED_TIME_ = newRedeemTime;\n        emit ChangeRedeemTime(newRedeemTime);\n    }\n\n    // ================= View ===================\n\n    function getSellingStage() public view returns (uint256 stageLen) {\n        stageLen = _SELLING_TIME_INTERVAL_.length;\n    }\n\n    function getSellingInfo() public view returns (uint256 curPrice, uint256 sellAmount, uint256 index) {\n        uint256 curBlockTime = block.timestamp;\n        if(curBlockTime >= _SELLING_TIME_INTERVAL_[0] && _SELLING_TIME_INTERVAL_[0] != 0) {\n            uint256 i;\n            for (i = 1; i < _SELLING_TIME_INTERVAL_.length; i++) {\n                if (curBlockTime <= _SELLING_TIME_INTERVAL_[i]) {\n                    break;\n                }\n            }\n            curPrice = _SELLING_PRICE_SET_[i-1];\n            sellAmount = _SELLING_AMOUNT_SET_[i-1];\n            index = i - 1;\n        }\n    }\n\n    function addressToShortString(address _addr) public pure returns (string memory) {\n        bytes32 value = bytes32(uint256(_addr));\n        bytes memory alphabet = \"0123456789abcdef\";\n\n        bytes memory str = new bytes(8);\n        for (uint256 i = 0; i < 4; i++) {\n            str[i * 2] = alphabet[uint8(value[i + 12] >> 4)];\n            str[1 + i * 2] = alphabet[uint8(value[i + 12] & 0x0f)];\n        }\n        return string(str);\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/SlowMist-DODO-MiningV3 and NFT Smart Contract Security Audit Report/contractV2-453e323af65f0a666f7d9c2dfd01b9d32ea19533/contracts/DODODrops/DODODropsV2/DODODrops.sol",
        "vulnerability": "Assertion Failure",
        "check": "FP",
        "response": "Answer: No\nReason: The provided smart contract code does not include any assert statements that could cause an assertion failure."
    },
    {
        "code_segment": "contract DODODrops is InitializableMintableERC20, ReentrancyGuard {\n    using SafeMath for uint256;\n    using Address for address;\n    using UniversalERC20 for IERC20;\n\n    // ============ Storage ============\n    address constant _BASE_COIN_ = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    \n    address public _BUY_TOKEN_;\n    uint256 public _BUY_TOKEN_RESERVE_;\n    address public _FEE_MODEL_;\n    address payable public _MAINTAINER_;\n    address public _NFT_TOKEN_;\n\n    uint256 public _TICKET_UNIT_ = 1; // ticket consumed in a single lottery\n    \n    uint256 [] public _SELLING_TIME_INTERVAL_;\n    uint256 [] public _SELLING_PRICE_SET_;\n    uint256 [] public _SELLING_AMOUNT_SET_;\n    uint256 public _REDEEM_ALLOWED_TIME_;\n\n    uint256[] public _PROB_INTERVAL_; // index => Interval probability (Only For ProbMode)  \n    uint256[][] public _TOKEN_ID_MAP_; // Interval index => tokenIds (Only For ProbMode)\n    \n    uint256[] public _TOKEN_ID_LIST_; //index => tokenId (Only For FixedAmount mode)\n\n    bool public _IS_PROB_MODE_; // false = FixedAmount mode,  true = ProbMode\n    bool public _IS_REVEAL_MODE_;\n    uint256 public _REVEAL_RN_ = 0; \n    address public _RNG_;\n\n    fallback() external payable {}\n\n    receive() external payable {}\n\n    // ============ Modifiers ============\n\n    modifier notStart() {\n        require(block.timestamp < _SELLING_TIME_INTERVAL_[0] || _SELLING_TIME_INTERVAL_[0]  == 0, \"ALREADY_START\");\n        _;\n    }\n\n    // ============ Event =============\n    event BuyTicket(address account, uint256 payAmount, uint256 feeAmount, uint256 ticketAmount);\n    event RedeemPrize(address account, uint256 tokenId, address referer);\n\n    event ChangeRNG(address rng);\n    event ChangeRedeemTime(uint256 redeemTime);\n    event ChangeTicketUnit(uint256 newTicketUnit);\n    event Withdraw(address account, uint256 amount);\n    event SetReveal();\n\n    event SetSellingInfo();\n    event SetProbInfo(); // only for ProbMode\n    event SetTokenIdMapByIndex(uint256 index); // only for ProbMode\n    event SetFixedAmountInfo(); // only for FixedAmount mode\n\n\n    function init(\n        address[] memory addrList, //0 owner, 1 buyToken, 2 feeModel, 3 defaultMaintainer 4 rng 5 nftToken\n        uint256[] memory sellingTimeInterval,\n        uint256[] memory sellingPrice,\n        uint256[] memory sellingAmount,\n        uint256 redeemAllowedTime,\n        bool isRevealMode,\n        bool isProbMode\n    ) public {\n        _BUY_TOKEN_ = addrList[1];\n        _FEE_MODEL_ = addrList[2];\n        _MAINTAINER_ = payable(addrList[3]);\n        _RNG_ = addrList[4];\n        _NFT_TOKEN_ = addrList[5];\n\n        _IS_REVEAL_MODE_ = isRevealMode;\n        _IS_PROB_MODE_ = isProbMode;\n        _REDEEM_ALLOWED_TIME_ = redeemAllowedTime;\n\n        if(sellingTimeInterval.length > 0) _setSellingInfo(sellingTimeInterval, sellingPrice, sellingAmount);\n        \n        string memory prefix = \"DROPS_\";\n        name = string(abi.encodePacked(prefix, addressToShortString(address(this))));\n        symbol = name;\n        decimals = 0;\n\n        //init Owner\n        super.init(addrList[0], 0, name, symbol, decimals);\n    }\n\n    function buyTickets(address ticketTo, uint256 ticketAmount) payable external preventReentrant {\n        (uint256 curPrice, uint256 sellAmount, uint256 index) = getSellingInfo();\n        require(curPrice > 0 && sellAmount > 0, \"CAN_NOT_BUY\");\n        require(ticketAmount <= sellAmount, \"TICKETS_NOT_ENOUGH\");\n        (uint256 payAmount, uint256 feeAmount) = IDropsFeeModel(_FEE_MODEL_).getPayAmount(address(this), ticketTo, curPrice, ticketAmount);\n        require(payAmount > 0, \"UnQualified\");\n\n        uint256 baseBalance = IERC20(_BUY_TOKEN_).universalBalanceOf(address(this));\n        uint256 buyInput = baseBalance.sub(_BUY_TOKEN_RESERVE_);\n\n        require(payAmount <= buyInput, \"PAY_AMOUNT_NOT_ENOUGH\");\n\n        _SELLING_AMOUNT_SET_[index] = sellAmount.sub(ticketAmount);\n        _BUY_TOKEN_RESERVE_ = baseBalance.sub(feeAmount);\n\n        IERC20(_BUY_TOKEN_).universalTransfer(_MAINTAINER_,feeAmount);\n        _mint(ticketTo, ticketAmount);\n        emit BuyTicket(ticketTo, payAmount, feeAmount, ticketAmount);\n    }\n\n    function redeemTicket(uint256 ticketNum, address referer) external {\n        require(!address(msg.sender).isContract(), \"ONLY_ALLOW_EOA\");\n        require(ticketNum >= 1 && ticketNum <= balanceOf(msg.sender), \"TICKET_NUM_INVALID\");\n        _burn(msg.sender,ticketNum);\n        for (uint256 i = 0; i < ticketNum; i++) {\n            _redeemSinglePrize(msg.sender, i, referer);\n        }\n    }\n\n    // ============ Internal  ============\n    // SWC-120-Weak Sources of Randomness from Chain Attributes: L156\n    function _redeemSinglePrize(address to, uint256 curNo, address referer) internal {\n        require(block.timestamp >= _REDEEM_ALLOWED_TIME_ && _REDEEM_ALLOWED_TIME_ != 0, \"REDEEM_CLOSE\");\n        uint256 range;\n        if(_IS_PROB_MODE_) {\n            range = _PROB_INTERVAL_[_PROB_INTERVAL_.length - 1];\n        }else {\n            range = _TOKEN_ID_LIST_.length;\n        }\n        uint256 random;\n        if(_IS_REVEAL_MODE_) {\n            require(_REVEAL_RN_ != 0, \"REVEAL_NOT_SET\");\n            random = uint256(keccak256(abi.encodePacked(_REVEAL_RN_, msg.sender, balanceOf(msg.sender).add(curNo + 1)))) % range;\n        }else {\n            random = IRandomGenerator(_RNG_).random(gasleft() + block.number) % range; \n        }\n        uint256 tokenId;\n        if(_IS_PROB_MODE_) {\n            uint256 i;\n            for (i = 0; i < _PROB_INTERVAL_.length; i++) {\n                if (random <= _PROB_INTERVAL_[i]) {\n                    break;\n                }\n            }\n            require(_TOKEN_ID_MAP_[i].length > 0, \"EMPTY_TOKEN_ID_MAP\");\n            tokenId = _TOKEN_ID_MAP_[i][random % _TOKEN_ID_MAP_[i].length];\n            IDropsNft(_NFT_TOKEN_).mint(to, tokenId, 1, \"\");\n        } else {\n            tokenId = _TOKEN_ID_LIST_[random];\n            if(random != range - 1) {\n                _TOKEN_ID_LIST_[random] = _TOKEN_ID_LIST_[range - 1];\n            }\n            _TOKEN_ID_LIST_.pop();\n            IDropsNft(_NFT_TOKEN_).mint(to, tokenId);  \n        }\n        emit RedeemPrize(to, tokenId, referer);\n    }\n\n\n    function _setSellingInfo(uint256[] memory sellingTimeIntervals, uint256[] memory sellingPrice, uint256[] memory sellingAmount) internal {\n        require(sellingTimeIntervals.length > 0, \"PARAM_NOT_INVALID\");\n        require(sellingTimeIntervals.length == sellingPrice.length && sellingPrice.length == sellingAmount.length, \"PARAM_NOT_INVALID\");\n        for (uint256 i = 0; i < sellingTimeIntervals.length - 1; i++) {\n            require(sellingTimeIntervals[i] < sellingTimeIntervals[i + 1], \"INTERVAL_INVALID\");\n            require(sellingPrice[i] != 0, \"PRICE_INVALID\");\n        }\n        _SELLING_TIME_INTERVAL_ = sellingTimeIntervals;\n        _SELLING_PRICE_SET_ = sellingPrice;\n        _SELLING_AMOUNT_SET_ = sellingAmount;\n        emit SetSellingInfo();\n    }\n\n\n    function _setProbInfo(uint256[] memory probIntervals,uint256[][] memory tokenIdMap) internal {\n        require(_IS_PROB_MODE_, \"ONLY_ALLOW_PROB_MODE\");\n        require(probIntervals.length > 0, \"PARAM_NOT_INVALID\");\n        require(tokenIdMap.length == probIntervals.length, \"PARAM_NOT_INVALID\");\n\n        require(tokenIdMap[0].length > 0, \"INVALID\");\n        for (uint256 i = 1; i < probIntervals.length; i++) {\n            require(probIntervals[i] > probIntervals[i - 1], \"INTERVAL_INVALID\");\n            require(tokenIdMap[i].length > 0, \"INVALID\");\n        }\n        _PROB_INTERVAL_ = probIntervals;\n        _TOKEN_ID_MAP_ = tokenIdMap;\n        emit SetProbInfo();\n    }\n\n    function _setFixedAmountInfo(uint256[] memory tokenIdList) internal {\n        require(!_IS_PROB_MODE_, \"ONLY_ALLOW_FIXED_AMOUNT_MODE\");\n        require(tokenIdList.length > 0, \"PARAM_NOT_INVALID\");\n        _TOKEN_ID_LIST_ = tokenIdList;\n        emit SetFixedAmountInfo();\n    }\n\n    // ================= Owner ===================\n\n    function withdraw() external onlyOwner {\n        uint256 amount = IERC20(_BUY_TOKEN_).universalBalanceOf(address(this));\n        IERC20(_BUY_TOKEN_).universalTransfer(msg.sender ,amount);\n        emit Withdraw(msg.sender, amount);\n    }\n\n    function setRevealRn() external onlyOwner {\n        require(_REVEAL_RN_ == 0, \"ALREADY_SET\");\n        _REVEAL_RN_ = uint256(keccak256(abi.encodePacked(blockhash(block.number - 1))));\n        emit SetReveal();\n    }\n    \n    function setSellingInfo(uint256[] memory sellingTimeIntervals, uint256[] memory prices, uint256[] memory amounts) external notStart() onlyOwner {\n        _setSellingInfo(sellingTimeIntervals, prices, amounts);\n    }\n\n    function setProbInfo(uint256[] memory probIntervals,uint256[][] memory tokenIdMaps) external notStart() onlyOwner {\n        _setProbInfo(probIntervals, tokenIdMaps);\n    }\n\n    function setFixedAmountInfo(uint256[] memory tokenIdList) external notStart() onlyOwner {\n        _setFixedAmountInfo(tokenIdList);\n    }\n\n    function addFixedAmountInfo(uint256[] memory addTokenIdList) external notStart() onlyOwner {\n        for (uint256 i = 0; i < addTokenIdList.length; i++) {\n            _TOKEN_ID_LIST_.push(addTokenIdList[i]);\n        }\n        emit SetFixedAmountInfo();\n    }\n\n    function setTokenIdMapByIndex(uint256 index, uint256[] memory tokenIds) external notStart() onlyOwner {\n        require(_IS_PROB_MODE_, \"ONLY_ALLOW_PROB_MODE\");\n        require(tokenIds.length > 0 && index < _TOKEN_ID_MAP_.length,\"PARAM_NOT_INVALID\");\n        _TOKEN_ID_MAP_[index] = tokenIds;\n        emit SetTokenIdMapByIndex(index);\n    }\n    \n    function updateRNG(address newRNG) external onlyOwner {\n        require(newRNG != address(0));\n        _RNG_ = newRNG;\n        emit ChangeRNG(newRNG);\n    }\n\n    function updateTicketUnit(uint256 newTicketUnit) external onlyOwner {\n        require(newTicketUnit != 0);\n        _TICKET_UNIT_ = newTicketUnit;\n        emit ChangeTicketUnit(newTicketUnit);\n    }\n\n    function updateRedeemTime(uint256 newRedeemTime) external onlyOwner {\n        require(newRedeemTime > block.timestamp || newRedeemTime == 0, \"PARAM_NOT_INVALID\");\n        _REDEEM_ALLOWED_TIME_ = newRedeemTime;\n        emit ChangeRedeemTime(newRedeemTime);\n    }\n\n    // ================= View ===================\n\n    function getSellingStage() public view returns (uint256 stageLen) {\n        stageLen = _SELLING_TIME_INTERVAL_.length;\n    }\n\n    function getSellingInfo() public view returns (uint256 curPrice, uint256 sellAmount, uint256 index) {\n        uint256 curBlockTime = block.timestamp;\n        if(curBlockTime >= _SELLING_TIME_INTERVAL_[0] && _SELLING_TIME_INTERVAL_[0] != 0) {\n            uint256 i;\n            for (i = 1; i < _SELLING_TIME_INTERVAL_.length; i++) {\n                if (curBlockTime <= _SELLING_TIME_INTERVAL_[i]) {\n                    break;\n                }\n            }\n            curPrice = _SELLING_PRICE_SET_[i-1];\n            sellAmount = _SELLING_AMOUNT_SET_[i-1];\n            index = i - 1;\n        }\n    }\n\n    function addressToShortString(address _addr) public pure returns (string memory) {\n        bytes32 value = bytes32(uint256(_addr));\n        bytes memory alphabet = \"0123456789abcdef\";\n\n        bytes memory str = new bytes(8);\n        for (uint256 i = 0; i < 4; i++) {\n            str[i * 2] = alphabet[uint8(value[i + 12] >> 4)];\n            str[1 + i * 2] = alphabet[uint8(value[i + 12] & 0x0f)];\n        }\n        return string(str);\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/SlowMist-DODO-MiningV3 and NFT Smart Contract Security Audit Report/contractV2-453e323af65f0a666f7d9c2dfd01b9d32ea19533/contracts/DODODrops/DODODropsV2/DODODrops.sol",
        "vulnerability": "Assertion Failure",
        "check": "FP",
        "response": "Answer: Yes\nDescription: Blockhash used in `setRevealRn` can lead to assertion failure."
    },
    {
        "code_segment": "contract DODODrops is InitializableMintableERC20, ReentrancyGuard {\n    using SafeMath for uint256;\n    using Address for address;\n    using UniversalERC20 for IERC20;\n\n    // ============ Storage ============\n    address constant _BASE_COIN_ = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    \n    address public _BUY_TOKEN_;\n    uint256 public _BUY_TOKEN_RESERVE_;\n    address public _FEE_MODEL_;\n    address payable public _MAINTAINER_;\n    address public _NFT_TOKEN_;\n\n    uint256 public _TICKET_UNIT_ = 1; // ticket consumed in a single lottery\n    \n    uint256 [] public _SELLING_TIME_INTERVAL_;\n    uint256 [] public _SELLING_PRICE_SET_;\n    uint256 [] public _SELLING_AMOUNT_SET_;\n    uint256 public _REDEEM_ALLOWED_TIME_;\n\n    uint256[] public _PROB_INTERVAL_; // index => Interval probability (Only For ProbMode)  \n    uint256[][] public _TOKEN_ID_MAP_; // Interval index => tokenIds (Only For ProbMode)\n    \n    uint256[] public _TOKEN_ID_LIST_; //index => tokenId (Only For FixedAmount mode)\n\n    bool public _IS_PROB_MODE_; // false = FixedAmount mode,  true = ProbMode\n    bool public _IS_REVEAL_MODE_;\n    uint256 public _REVEAL_RN_ = 0; \n    address public _RNG_;\n\n    fallback() external payable {}\n\n    receive() external payable {}\n\n    // ============ Modifiers ============\n\n    modifier notStart() {\n        require(block.timestamp < _SELLING_TIME_INTERVAL_[0] || _SELLING_TIME_INTERVAL_[0]  == 0, \"ALREADY_START\");\n        _;\n    }\n\n    // ============ Event =============\n    event BuyTicket(address account, uint256 payAmount, uint256 feeAmount, uint256 ticketAmount);\n    event RedeemPrize(address account, uint256 tokenId, address referer);\n\n    event ChangeRNG(address rng);\n    event ChangeRedeemTime(uint256 redeemTime);\n    event ChangeTicketUnit(uint256 newTicketUnit);\n    event Withdraw(address account, uint256 amount);\n    event SetReveal();\n\n    event SetSellingInfo();\n    event SetProbInfo(); // only for ProbMode\n    event SetTokenIdMapByIndex(uint256 index); // only for ProbMode\n    event SetFixedAmountInfo(); // only for FixedAmount mode\n\n\n    function init(\n        address[] memory addrList, //0 owner, 1 buyToken, 2 feeModel, 3 defaultMaintainer 4 rng 5 nftToken\n        uint256[] memory sellingTimeInterval,\n        uint256[] memory sellingPrice,\n        uint256[] memory sellingAmount,\n        uint256 redeemAllowedTime,\n        bool isRevealMode,\n        bool isProbMode\n    ) public {\n        _BUY_TOKEN_ = addrList[1];\n        _FEE_MODEL_ = addrList[2];\n        _MAINTAINER_ = payable(addrList[3]);\n        _RNG_ = addrList[4];\n        _NFT_TOKEN_ = addrList[5];\n\n        _IS_REVEAL_MODE_ = isRevealMode;\n        _IS_PROB_MODE_ = isProbMode;\n        _REDEEM_ALLOWED_TIME_ = redeemAllowedTime;\n\n        if(sellingTimeInterval.length > 0) _setSellingInfo(sellingTimeInterval, sellingPrice, sellingAmount);\n        \n        string memory prefix = \"DROPS_\";\n        name = string(abi.encodePacked(prefix, addressToShortString(address(this))));\n        symbol = name;\n        decimals = 0;\n\n        //init Owner\n        super.init(addrList[0], 0, name, symbol, decimals);\n    }\n\n    function buyTickets(address ticketTo, uint256 ticketAmount) payable external preventReentrant {\n        (uint256 curPrice, uint256 sellAmount, uint256 index) = getSellingInfo();\n        require(curPrice > 0 && sellAmount > 0, \"CAN_NOT_BUY\");\n        require(ticketAmount <= sellAmount, \"TICKETS_NOT_ENOUGH\");\n        (uint256 payAmount, uint256 feeAmount) = IDropsFeeModel(_FEE_MODEL_).getPayAmount(address(this), ticketTo, curPrice, ticketAmount);\n        require(payAmount > 0, \"UnQualified\");\n\n        uint256 baseBalance = IERC20(_BUY_TOKEN_).universalBalanceOf(address(this));\n        uint256 buyInput = baseBalance.sub(_BUY_TOKEN_RESERVE_);\n\n        require(payAmount <= buyInput, \"PAY_AMOUNT_NOT_ENOUGH\");\n\n        _SELLING_AMOUNT_SET_[index] = sellAmount.sub(ticketAmount);\n        _BUY_TOKEN_RESERVE_ = baseBalance.sub(feeAmount);\n\n        IERC20(_BUY_TOKEN_).universalTransfer(_MAINTAINER_,feeAmount);\n        _mint(ticketTo, ticketAmount);\n        emit BuyTicket(ticketTo, payAmount, feeAmount, ticketAmount);\n    }\n\n    function redeemTicket(uint256 ticketNum, address referer) external {\n        require(!address(msg.sender).isContract(), \"ONLY_ALLOW_EOA\");\n        require(ticketNum >= 1 && ticketNum <= balanceOf(msg.sender), \"TICKET_NUM_INVALID\");\n        _burn(msg.sender,ticketNum);\n        for (uint256 i = 0; i < ticketNum; i++) {\n            _redeemSinglePrize(msg.sender, i, referer);\n        }\n    }\n\n    // ============ Internal  ============\n    // SWC-120-Weak Sources of Randomness from Chain Attributes: L156\n    function _redeemSinglePrize(address to, uint256 curNo, address referer) internal {\n        require(block.timestamp >= _REDEEM_ALLOWED_TIME_ && _REDEEM_ALLOWED_TIME_ != 0, \"REDEEM_CLOSE\");\n        uint256 range;\n        if(_IS_PROB_MODE_) {\n            range = _PROB_INTERVAL_[_PROB_INTERVAL_.length - 1];\n        }else {\n            range = _TOKEN_ID_LIST_.length;\n        }\n        uint256 random;\n        if(_IS_REVEAL_MODE_) {\n            require(_REVEAL_RN_ != 0, \"REVEAL_NOT_SET\");\n            random = uint256(keccak256(abi.encodePacked(_REVEAL_RN_, msg.sender, balanceOf(msg.sender).add(curNo + 1)))) % range;\n        }else {\n            random = IRandomGenerator(_RNG_).random(gasleft() + block.number) % range; \n        }\n        uint256 tokenId;\n        if(_IS_PROB_MODE_) {\n            uint256 i;\n            for (i = 0; i < _PROB_INTERVAL_.length; i++) {\n                if (random <= _PROB_INTERVAL_[i]) {\n                    break;\n                }\n            }\n            require(_TOKEN_ID_MAP_[i].length > 0, \"EMPTY_TOKEN_ID_MAP\");\n            tokenId = _TOKEN_ID_MAP_[i][random % _TOKEN_ID_MAP_[i].length];\n            IDropsNft(_NFT_TOKEN_).mint(to, tokenId, 1, \"\");\n        } else {\n            tokenId = _TOKEN_ID_LIST_[random];\n            if(random != range - 1) {\n                _TOKEN_ID_LIST_[random] = _TOKEN_ID_LIST_[range - 1];\n            }\n            _TOKEN_ID_LIST_.pop();\n            IDropsNft(_NFT_TOKEN_).mint(to, tokenId);  \n        }\n        emit RedeemPrize(to, tokenId, referer);\n    }\n\n\n    function _setSellingInfo(uint256[] memory sellingTimeIntervals, uint256[] memory sellingPrice, uint256[] memory sellingAmount) internal {\n        require(sellingTimeIntervals.length > 0, \"PARAM_NOT_INVALID\");\n        require(sellingTimeIntervals.length == sellingPrice.length && sellingPrice.length == sellingAmount.length, \"PARAM_NOT_INVALID\");\n        for (uint256 i = 0; i < sellingTimeIntervals.length - 1; i++) {\n            require(sellingTimeIntervals[i] < sellingTimeIntervals[i + 1], \"INTERVAL_INVALID\");\n            require(sellingPrice[i] != 0, \"PRICE_INVALID\");\n        }\n        _SELLING_TIME_INTERVAL_ = sellingTimeIntervals;\n        _SELLING_PRICE_SET_ = sellingPrice;\n        _SELLING_AMOUNT_SET_ = sellingAmount;\n        emit SetSellingInfo();\n    }\n\n\n    function _setProbInfo(uint256[] memory probIntervals,uint256[][] memory tokenIdMap) internal {\n        require(_IS_PROB_MODE_, \"ONLY_ALLOW_PROB_MODE\");\n        require(probIntervals.length > 0, \"PARAM_NOT_INVALID\");\n        require(tokenIdMap.length == probIntervals.length, \"PARAM_NOT_INVALID\");\n\n        require(tokenIdMap[0].length > 0, \"INVALID\");\n        for (uint256 i = 1; i < probIntervals.length; i++) {\n            require(probIntervals[i] > probIntervals[i - 1], \"INTERVAL_INVALID\");\n            require(tokenIdMap[i].length > 0, \"INVALID\");\n        }\n        _PROB_INTERVAL_ = probIntervals;\n        _TOKEN_ID_MAP_ = tokenIdMap;\n        emit SetProbInfo();\n    }\n\n    function _setFixedAmountInfo(uint256[] memory tokenIdList) internal {\n        require(!_IS_PROB_MODE_, \"ONLY_ALLOW_FIXED_AMOUNT_MODE\");\n        require(tokenIdList.length > 0, \"PARAM_NOT_INVALID\");\n        _TOKEN_ID_LIST_ = tokenIdList;\n        emit SetFixedAmountInfo();\n    }\n\n    // ================= Owner ===================\n\n    function withdraw() external onlyOwner {\n        uint256 amount = IERC20(_BUY_TOKEN_).universalBalanceOf(address(this));\n        IERC20(_BUY_TOKEN_).universalTransfer(msg.sender ,amount);\n        emit Withdraw(msg.sender, amount);\n    }\n\n    function setRevealRn() external onlyOwner {\n        require(_REVEAL_RN_ == 0, \"ALREADY_SET\");\n        _REVEAL_RN_ = uint256(keccak256(abi.encodePacked(blockhash(block.number - 1))));\n        emit SetReveal();\n    }\n    \n    function setSellingInfo(uint256[] memory sellingTimeIntervals, uint256[] memory prices, uint256[] memory amounts) external notStart() onlyOwner {\n        _setSellingInfo(sellingTimeIntervals, prices, amounts);\n    }\n\n    function setProbInfo(uint256[] memory probIntervals,uint256[][] memory tokenIdMaps) external notStart() onlyOwner {\n        _setProbInfo(probIntervals, tokenIdMaps);\n    }\n\n    function setFixedAmountInfo(uint256[] memory tokenIdList) external notStart() onlyOwner {\n        _setFixedAmountInfo(tokenIdList);\n    }\n\n    function addFixedAmountInfo(uint256[] memory addTokenIdList) external notStart() onlyOwner {\n        for (uint256 i = 0; i < addTokenIdList.length; i++) {\n            _TOKEN_ID_LIST_.push(addTokenIdList[i]);\n        }\n        emit SetFixedAmountInfo();\n    }\n\n    function setTokenIdMapByIndex(uint256 index, uint256[] memory tokenIds) external notStart() onlyOwner {\n        require(_IS_PROB_MODE_, \"ONLY_ALLOW_PROB_MODE\");\n        require(tokenIds.length > 0 && index < _TOKEN_ID_MAP_.length,\"PARAM_NOT_INVALID\");\n        _TOKEN_ID_MAP_[index] = tokenIds;\n        emit SetTokenIdMapByIndex(index);\n    }\n    \n    function updateRNG(address newRNG) external onlyOwner {\n        require(newRNG != address(0));\n        _RNG_ = newRNG;\n        emit ChangeRNG(newRNG);\n    }\n\n    function updateTicketUnit(uint256 newTicketUnit) external onlyOwner {\n        require(newTicketUnit != 0);\n        _TICKET_UNIT_ = newTicketUnit;\n        emit ChangeTicketUnit(newTicketUnit);\n    }\n\n    function updateRedeemTime(uint256 newRedeemTime) external onlyOwner {\n        require(newRedeemTime > block.timestamp || newRedeemTime == 0, \"PARAM_NOT_INVALID\");\n        _REDEEM_ALLOWED_TIME_ = newRedeemTime;\n        emit ChangeRedeemTime(newRedeemTime);\n    }\n\n    // ================= View ===================\n\n    function getSellingStage() public view returns (uint256 stageLen) {\n        stageLen = _SELLING_TIME_INTERVAL_.length;\n    }\n\n    function getSellingInfo() public view returns (uint256 curPrice, uint256 sellAmount, uint256 index) {\n        uint256 curBlockTime = block.timestamp;\n        if(curBlockTime >= _SELLING_TIME_INTERVAL_[0] && _SELLING_TIME_INTERVAL_[0] != 0) {\n            uint256 i;\n            for (i = 1; i < _SELLING_TIME_INTERVAL_.length; i++) {\n                if (curBlockTime <= _SELLING_TIME_INTERVAL_[i]) {\n                    break;\n                }\n            }\n            curPrice = _SELLING_PRICE_SET_[i-1];\n            sellAmount = _SELLING_AMOUNT_SET_[i-1];\n            index = i - 1;\n        }\n    }\n\n    function addressToShortString(address _addr) public pure returns (string memory) {\n        bytes32 value = bytes32(uint256(_addr));\n        bytes memory alphabet = \"0123456789abcdef\";\n\n        bytes memory str = new bytes(8);\n        for (uint256 i = 0; i < 4; i++) {\n            str[i * 2] = alphabet[uint8(value[i + 12] >> 4)];\n            str[1 + i * 2] = alphabet[uint8(value[i + 12] & 0x0f)];\n        }\n        return string(str);\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/SlowMist-DODO-MiningV3 and NFT Smart Contract Security Audit Report/contractV2-453e323af65f0a666f7d9c2dfd01b9d32ea19533/contracts/DODODrops/DODODropsV2/DODODrops.sol",
        "vulnerability": "Assertion Failure",
        "check": "FP",
        "response": "Answer: Yes\nDescription: The contract lacks an assertion directive, but contains multiple require statements used for validations. If these fail, they will revert the transaction, which is functionally similar to an assertion failure."
    },
    {
        "code_segment": "contract DODODrops is InitializableMintableERC20, ReentrancyGuard {\n    using SafeMath for uint256;\n    using Address for address;\n    using UniversalERC20 for IERC20;\n\n    // ============ Storage ============\n    address constant _BASE_COIN_ = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    \n    address public _BUY_TOKEN_;\n    uint256 public _BUY_TOKEN_RESERVE_;\n    address public _FEE_MODEL_;\n    address payable public _MAINTAINER_;\n    address public _NFT_TOKEN_;\n\n    uint256 public _TICKET_UNIT_ = 1; // ticket consumed in a single lottery\n    \n    uint256 [] public _SELLING_TIME_INTERVAL_;\n    uint256 [] public _SELLING_PRICE_SET_;\n    uint256 [] public _SELLING_AMOUNT_SET_;\n    uint256 public _REDEEM_ALLOWED_TIME_;\n\n    uint256[] public _PROB_INTERVAL_; // index => Interval probability (Only For ProbMode)  \n    uint256[][] public _TOKEN_ID_MAP_; // Interval index => tokenIds (Only For ProbMode)\n    \n    uint256[] public _TOKEN_ID_LIST_; //index => tokenId (Only For FixedAmount mode)\n\n    bool public _IS_PROB_MODE_; // false = FixedAmount mode,  true = ProbMode\n    bool public _IS_REVEAL_MODE_;\n    uint256 public _REVEAL_RN_ = 0; \n    address public _RNG_;\n\n    fallback() external payable {}\n\n    receive() external payable {}\n\n    // ============ Modifiers ============\n\n    modifier notStart() {\n        require(block.timestamp < _SELLING_TIME_INTERVAL_[0] || _SELLING_TIME_INTERVAL_[0]  == 0, \"ALREADY_START\");\n        _;\n    }\n\n    // ============ Event =============\n    event BuyTicket(address account, uint256 payAmount, uint256 feeAmount, uint256 ticketAmount);\n    event RedeemPrize(address account, uint256 tokenId, address referer);\n\n    event ChangeRNG(address rng);\n    event ChangeRedeemTime(uint256 redeemTime);\n    event ChangeTicketUnit(uint256 newTicketUnit);\n    event Withdraw(address account, uint256 amount);\n    event SetReveal();\n\n    event SetSellingInfo();\n    event SetProbInfo(); // only for ProbMode\n    event SetTokenIdMapByIndex(uint256 index); // only for ProbMode\n    event SetFixedAmountInfo(); // only for FixedAmount mode\n\n\n    function init(\n        address[] memory addrList, //0 owner, 1 buyToken, 2 feeModel, 3 defaultMaintainer 4 rng 5 nftToken\n        uint256[] memory sellingTimeInterval,\n        uint256[] memory sellingPrice,\n        uint256[] memory sellingAmount,\n        uint256 redeemAllowedTime,\n        bool isRevealMode,\n        bool isProbMode\n    ) public {\n        _BUY_TOKEN_ = addrList[1];\n        _FEE_MODEL_ = addrList[2];\n        _MAINTAINER_ = payable(addrList[3]);\n        _RNG_ = addrList[4];\n        _NFT_TOKEN_ = addrList[5];\n\n        _IS_REVEAL_MODE_ = isRevealMode;\n        _IS_PROB_MODE_ = isProbMode;\n        _REDEEM_ALLOWED_TIME_ = redeemAllowedTime;\n\n        if(sellingTimeInterval.length > 0) _setSellingInfo(sellingTimeInterval, sellingPrice, sellingAmount);\n        \n        string memory prefix = \"DROPS_\";\n        name = string(abi.encodePacked(prefix, addressToShortString(address(this))));\n        symbol = name;\n        decimals = 0;\n\n        //init Owner\n        super.init(addrList[0], 0, name, symbol, decimals);\n    }\n\n    function buyTickets(address ticketTo, uint256 ticketAmount) payable external preventReentrant {\n        (uint256 curPrice, uint256 sellAmount, uint256 index) = getSellingInfo();\n        require(curPrice > 0 && sellAmount > 0, \"CAN_NOT_BUY\");\n        require(ticketAmount <= sellAmount, \"TICKETS_NOT_ENOUGH\");\n        (uint256 payAmount, uint256 feeAmount) = IDropsFeeModel(_FEE_MODEL_).getPayAmount(address(this), ticketTo, curPrice, ticketAmount);\n        require(payAmount > 0, \"UnQualified\");\n\n        uint256 baseBalance = IERC20(_BUY_TOKEN_).universalBalanceOf(address(this));\n        uint256 buyInput = baseBalance.sub(_BUY_TOKEN_RESERVE_);\n\n        require(payAmount <= buyInput, \"PAY_AMOUNT_NOT_ENOUGH\");\n\n        _SELLING_AMOUNT_SET_[index] = sellAmount.sub(ticketAmount);\n        _BUY_TOKEN_RESERVE_ = baseBalance.sub(feeAmount);\n\n        IERC20(_BUY_TOKEN_).universalTransfer(_MAINTAINER_,feeAmount);\n        _mint(ticketTo, ticketAmount);\n        emit BuyTicket(ticketTo, payAmount, feeAmount, ticketAmount);\n    }\n\n    function redeemTicket(uint256 ticketNum, address referer) external {\n        require(!address(msg.sender).isContract(), \"ONLY_ALLOW_EOA\");\n        require(ticketNum >= 1 && ticketNum <= balanceOf(msg.sender), \"TICKET_NUM_INVALID\");\n        _burn(msg.sender,ticketNum);\n        for (uint256 i = 0; i < ticketNum; i++) {\n            _redeemSinglePrize(msg.sender, i, referer);\n        }\n    }\n\n    // ============ Internal  ============\n    // SWC-120-Weak Sources of Randomness from Chain Attributes: L156\n    function _redeemSinglePrize(address to, uint256 curNo, address referer) internal {\n        require(block.timestamp >= _REDEEM_ALLOWED_TIME_ && _REDEEM_ALLOWED_TIME_ != 0, \"REDEEM_CLOSE\");\n        uint256 range;\n        if(_IS_PROB_MODE_) {\n            range = _PROB_INTERVAL_[_PROB_INTERVAL_.length - 1];\n        }else {\n            range = _TOKEN_ID_LIST_.length;\n        }\n        uint256 random;\n        if(_IS_REVEAL_MODE_) {\n            require(_REVEAL_RN_ != 0, \"REVEAL_NOT_SET\");\n            random = uint256(keccak256(abi.encodePacked(_REVEAL_RN_, msg.sender, balanceOf(msg.sender).add(curNo + 1)))) % range;\n        }else {\n            random = IRandomGenerator(_RNG_).random(gasleft() + block.number) % range; \n        }\n        uint256 tokenId;\n        if(_IS_PROB_MODE_) {\n            uint256 i;\n            for (i = 0; i < _PROB_INTERVAL_.length; i++) {\n                if (random <= _PROB_INTERVAL_[i]) {\n                    break;\n                }\n            }\n            require(_TOKEN_ID_MAP_[i].length > 0, \"EMPTY_TOKEN_ID_MAP\");\n            tokenId = _TOKEN_ID_MAP_[i][random % _TOKEN_ID_MAP_[i].length];\n            IDropsNft(_NFT_TOKEN_).mint(to, tokenId, 1, \"\");\n        } else {\n            tokenId = _TOKEN_ID_LIST_[random];\n            if(random != range - 1) {\n                _TOKEN_ID_LIST_[random] = _TOKEN_ID_LIST_[range - 1];\n            }\n            _TOKEN_ID_LIST_.pop();\n            IDropsNft(_NFT_TOKEN_).mint(to, tokenId);  \n        }\n        emit RedeemPrize(to, tokenId, referer);\n    }\n\n\n    function _setSellingInfo(uint256[] memory sellingTimeIntervals, uint256[] memory sellingPrice, uint256[] memory sellingAmount) internal {\n        require(sellingTimeIntervals.length > 0, \"PARAM_NOT_INVALID\");\n        require(sellingTimeIntervals.length == sellingPrice.length && sellingPrice.length == sellingAmount.length, \"PARAM_NOT_INVALID\");\n        for (uint256 i = 0; i < sellingTimeIntervals.length - 1; i++) {\n            require(sellingTimeIntervals[i] < sellingTimeIntervals[i + 1], \"INTERVAL_INVALID\");\n            require(sellingPrice[i] != 0, \"PRICE_INVALID\");\n        }\n        _SELLING_TIME_INTERVAL_ = sellingTimeIntervals;\n        _SELLING_PRICE_SET_ = sellingPrice;\n        _SELLING_AMOUNT_SET_ = sellingAmount;\n        emit SetSellingInfo();\n    }\n\n\n    function _setProbInfo(uint256[] memory probIntervals,uint256[][] memory tokenIdMap) internal {\n        require(_IS_PROB_MODE_, \"ONLY_ALLOW_PROB_MODE\");\n        require(probIntervals.length > 0, \"PARAM_NOT_INVALID\");\n        require(tokenIdMap.length == probIntervals.length, \"PARAM_NOT_INVALID\");\n\n        require(tokenIdMap[0].length > 0, \"INVALID\");\n        for (uint256 i = 1; i < probIntervals.length; i++) {\n            require(probIntervals[i] > probIntervals[i - 1], \"INTERVAL_INVALID\");\n            require(tokenIdMap[i].length > 0, \"INVALID\");\n        }\n        _PROB_INTERVAL_ = probIntervals;\n        _TOKEN_ID_MAP_ = tokenIdMap;\n        emit SetProbInfo();\n    }\n\n    function _setFixedAmountInfo(uint256[] memory tokenIdList) internal {\n        require(!_IS_PROB_MODE_, \"ONLY_ALLOW_FIXED_AMOUNT_MODE\");\n        require(tokenIdList.length > 0, \"PARAM_NOT_INVALID\");\n        _TOKEN_ID_LIST_ = tokenIdList;\n        emit SetFixedAmountInfo();\n    }\n\n    // ================= Owner ===================\n\n    function withdraw() external onlyOwner {\n        uint256 amount = IERC20(_BUY_TOKEN_).universalBalanceOf(address(this));\n        IERC20(_BUY_TOKEN_).universalTransfer(msg.sender ,amount);\n        emit Withdraw(msg.sender, amount);\n    }\n\n    function setRevealRn() external onlyOwner {\n        require(_REVEAL_RN_ == 0, \"ALREADY_SET\");\n        _REVEAL_RN_ = uint256(keccak256(abi.encodePacked(blockhash(block.number - 1))));\n        emit SetReveal();\n    }\n    \n    function setSellingInfo(uint256[] memory sellingTimeIntervals, uint256[] memory prices, uint256[] memory amounts) external notStart() onlyOwner {\n        _setSellingInfo(sellingTimeIntervals, prices, amounts);\n    }\n\n    function setProbInfo(uint256[] memory probIntervals,uint256[][] memory tokenIdMaps) external notStart() onlyOwner {\n        _setProbInfo(probIntervals, tokenIdMaps);\n    }\n\n    function setFixedAmountInfo(uint256[] memory tokenIdList) external notStart() onlyOwner {\n        _setFixedAmountInfo(tokenIdList);\n    }\n\n    function addFixedAmountInfo(uint256[] memory addTokenIdList) external notStart() onlyOwner {\n        for (uint256 i = 0; i < addTokenIdList.length; i++) {\n            _TOKEN_ID_LIST_.push(addTokenIdList[i]);\n        }\n        emit SetFixedAmountInfo();\n    }\n\n    function setTokenIdMapByIndex(uint256 index, uint256[] memory tokenIds) external notStart() onlyOwner {\n        require(_IS_PROB_MODE_, \"ONLY_ALLOW_PROB_MODE\");\n        require(tokenIds.length > 0 && index < _TOKEN_ID_MAP_.length,\"PARAM_NOT_INVALID\");\n        _TOKEN_ID_MAP_[index] = tokenIds;\n        emit SetTokenIdMapByIndex(index);\n    }\n    \n    function updateRNG(address newRNG) external onlyOwner {\n        require(newRNG != address(0));\n        _RNG_ = newRNG;\n        emit ChangeRNG(newRNG);\n    }\n\n    function updateTicketUnit(uint256 newTicketUnit) external onlyOwner {\n        require(newTicketUnit != 0);\n        _TICKET_UNIT_ = newTicketUnit;\n        emit ChangeTicketUnit(newTicketUnit);\n    }\n\n    function updateRedeemTime(uint256 newRedeemTime) external onlyOwner {\n        require(newRedeemTime > block.timestamp || newRedeemTime == 0, \"PARAM_NOT_INVALID\");\n        _REDEEM_ALLOWED_TIME_ = newRedeemTime;\n        emit ChangeRedeemTime(newRedeemTime);\n    }\n\n    // ================= View ===================\n\n    function getSellingStage() public view returns (uint256 stageLen) {\n        stageLen = _SELLING_TIME_INTERVAL_.length;\n    }\n\n    function getSellingInfo() public view returns (uint256 curPrice, uint256 sellAmount, uint256 index) {\n        uint256 curBlockTime = block.timestamp;\n        if(curBlockTime >= _SELLING_TIME_INTERVAL_[0] && _SELLING_TIME_INTERVAL_[0] != 0) {\n            uint256 i;\n            for (i = 1; i < _SELLING_TIME_INTERVAL_.length; i++) {\n                if (curBlockTime <= _SELLING_TIME_INTERVAL_[i]) {\n                    break;\n                }\n            }\n            curPrice = _SELLING_PRICE_SET_[i-1];\n            sellAmount = _SELLING_AMOUNT_SET_[i-1];\n            index = i - 1;\n        }\n    }\n\n    function addressToShortString(address _addr) public pure returns (string memory) {\n        bytes32 value = bytes32(uint256(_addr));\n        bytes memory alphabet = \"0123456789abcdef\";\n\n        bytes memory str = new bytes(8);\n        for (uint256 i = 0; i < 4; i++) {\n            str[i * 2] = alphabet[uint8(value[i + 12] >> 4)];\n            str[1 + i * 2] = alphabet[uint8(value[i + 12] & 0x0f)];\n        }\n        return string(str);\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/SlowMist-DODO-MiningV3 and NFT Smart Contract Security Audit Report/contractV2-453e323af65f0a666f7d9c2dfd01b9d32ea19533/contracts/DODODrops/DODODropsV2/DODODrops.sol",
        "vulnerability": "Assertion Failure",
        "check": "FP",
        "response": "Answer: No\nReason: The code does not contain any assertions (e.g., `assert`) that could potentially fail, and hence there's no \"Assertion Failure\" vulnerability present."
    },
    {
        "code_segment": "contract DODODrops is InitializableMintableERC20, ReentrancyGuard {\n    using SafeMath for uint256;\n    using Address for address;\n    using UniversalERC20 for IERC20;\n\n    // ============ Storage ============\n    address constant _BASE_COIN_ = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    \n    address public _BUY_TOKEN_;\n    uint256 public _BUY_TOKEN_RESERVE_;\n    address public _FEE_MODEL_;\n    address payable public _MAINTAINER_;\n    address public _NFT_TOKEN_;\n\n    uint256 public _TICKET_UNIT_ = 1; // ticket consumed in a single lottery\n    \n    uint256 [] public _SELLING_TIME_INTERVAL_;\n    uint256 [] public _SELLING_PRICE_SET_;\n    uint256 [] public _SELLING_AMOUNT_SET_;\n    uint256 public _REDEEM_ALLOWED_TIME_;\n\n    uint256[] public _PROB_INTERVAL_; // index => Interval probability (Only For ProbMode)  \n    uint256[][] public _TOKEN_ID_MAP_; // Interval index => tokenIds (Only For ProbMode)\n    \n    uint256[] public _TOKEN_ID_LIST_; //index => tokenId (Only For FixedAmount mode)\n\n    bool public _IS_PROB_MODE_; // false = FixedAmount mode,  true = ProbMode\n    bool public _IS_REVEAL_MODE_;\n    uint256 public _REVEAL_RN_ = 0; \n    address public _RNG_;\n\n    fallback() external payable {}\n\n    receive() external payable {}\n\n    // ============ Modifiers ============\n\n    modifier notStart() {\n        require(block.timestamp < _SELLING_TIME_INTERVAL_[0] || _SELLING_TIME_INTERVAL_[0]  == 0, \"ALREADY_START\");\n        _;\n    }\n\n    // ============ Event =============\n    event BuyTicket(address account, uint256 payAmount, uint256 feeAmount, uint256 ticketAmount);\n    event RedeemPrize(address account, uint256 tokenId, address referer);\n\n    event ChangeRNG(address rng);\n    event ChangeRedeemTime(uint256 redeemTime);\n    event ChangeTicketUnit(uint256 newTicketUnit);\n    event Withdraw(address account, uint256 amount);\n    event SetReveal();\n\n    event SetSellingInfo();\n    event SetProbInfo(); // only for ProbMode\n    event SetTokenIdMapByIndex(uint256 index); // only for ProbMode\n    event SetFixedAmountInfo(); // only for FixedAmount mode\n\n\n    function init(\n        address[] memory addrList, //0 owner, 1 buyToken, 2 feeModel, 3 defaultMaintainer 4 rng 5 nftToken\n        uint256[] memory sellingTimeInterval,\n        uint256[] memory sellingPrice,\n        uint256[] memory sellingAmount,\n        uint256 redeemAllowedTime,\n        bool isRevealMode,\n        bool isProbMode\n    ) public {\n        _BUY_TOKEN_ = addrList[1];\n        _FEE_MODEL_ = addrList[2];\n        _MAINTAINER_ = payable(addrList[3]);\n        _RNG_ = addrList[4];\n        _NFT_TOKEN_ = addrList[5];\n\n        _IS_REVEAL_MODE_ = isRevealMode;\n        _IS_PROB_MODE_ = isProbMode;\n        _REDEEM_ALLOWED_TIME_ = redeemAllowedTime;\n\n        if(sellingTimeInterval.length > 0) _setSellingInfo(sellingTimeInterval, sellingPrice, sellingAmount);\n        \n        string memory prefix = \"DROPS_\";\n        name = string(abi.encodePacked(prefix, addressToShortString(address(this))));\n        symbol = name;\n        decimals = 0;\n\n        //init Owner\n        super.init(addrList[0], 0, name, symbol, decimals);\n    }\n\n    function buyTickets(address ticketTo, uint256 ticketAmount) payable external preventReentrant {\n        (uint256 curPrice, uint256 sellAmount, uint256 index) = getSellingInfo();\n        require(curPrice > 0 && sellAmount > 0, \"CAN_NOT_BUY\");\n        require(ticketAmount <= sellAmount, \"TICKETS_NOT_ENOUGH\");\n        (uint256 payAmount, uint256 feeAmount) = IDropsFeeModel(_FEE_MODEL_).getPayAmount(address(this), ticketTo, curPrice, ticketAmount);\n        require(payAmount > 0, \"UnQualified\");\n\n        uint256 baseBalance = IERC20(_BUY_TOKEN_).universalBalanceOf(address(this));\n        uint256 buyInput = baseBalance.sub(_BUY_TOKEN_RESERVE_);\n\n        require(payAmount <= buyInput, \"PAY_AMOUNT_NOT_ENOUGH\");\n\n        _SELLING_AMOUNT_SET_[index] = sellAmount.sub(ticketAmount);\n        _BUY_TOKEN_RESERVE_ = baseBalance.sub(feeAmount);\n\n        IERC20(_BUY_TOKEN_).universalTransfer(_MAINTAINER_,feeAmount);\n        _mint(ticketTo, ticketAmount);\n        emit BuyTicket(ticketTo, payAmount, feeAmount, ticketAmount);\n    }\n\n    function redeemTicket(uint256 ticketNum, address referer) external {\n        require(!address(msg.sender).isContract(), \"ONLY_ALLOW_EOA\");\n        require(ticketNum >= 1 && ticketNum <= balanceOf(msg.sender), \"TICKET_NUM_INVALID\");\n        _burn(msg.sender,ticketNum);\n        for (uint256 i = 0; i < ticketNum; i++) {\n            _redeemSinglePrize(msg.sender, i, referer);\n        }\n    }\n\n    // ============ Internal  ============\n    // SWC-120-Weak Sources of Randomness from Chain Attributes: L156\n    function _redeemSinglePrize(address to, uint256 curNo, address referer) internal {\n        require(block.timestamp >= _REDEEM_ALLOWED_TIME_ && _REDEEM_ALLOWED_TIME_ != 0, \"REDEEM_CLOSE\");\n        uint256 range;\n        if(_IS_PROB_MODE_) {\n            range = _PROB_INTERVAL_[_PROB_INTERVAL_.length - 1];\n        }else {\n            range = _TOKEN_ID_LIST_.length;\n        }\n        uint256 random;\n        if(_IS_REVEAL_MODE_) {\n            require(_REVEAL_RN_ != 0, \"REVEAL_NOT_SET\");\n            random = uint256(keccak256(abi.encodePacked(_REVEAL_RN_, msg.sender, balanceOf(msg.sender).add(curNo + 1)))) % range;\n        }else {\n            random = IRandomGenerator(_RNG_).random(gasleft() + block.number) % range; \n        }\n        uint256 tokenId;\n        if(_IS_PROB_MODE_) {\n            uint256 i;\n            for (i = 0; i < _PROB_INTERVAL_.length; i++) {\n                if (random <= _PROB_INTERVAL_[i]) {\n                    break;\n                }\n            }\n            require(_TOKEN_ID_MAP_[i].length > 0, \"EMPTY_TOKEN_ID_MAP\");\n            tokenId = _TOKEN_ID_MAP_[i][random % _TOKEN_ID_MAP_[i].length];\n            IDropsNft(_NFT_TOKEN_).mint(to, tokenId, 1, \"\");\n        } else {\n            tokenId = _TOKEN_ID_LIST_[random];\n            if(random != range - 1) {\n                _TOKEN_ID_LIST_[random] = _TOKEN_ID_LIST_[range - 1];\n            }\n            _TOKEN_ID_LIST_.pop();\n            IDropsNft(_NFT_TOKEN_).mint(to, tokenId);  \n        }\n        emit RedeemPrize(to, tokenId, referer);\n    }\n\n\n    function _setSellingInfo(uint256[] memory sellingTimeIntervals, uint256[] memory sellingPrice, uint256[] memory sellingAmount) internal {\n        require(sellingTimeIntervals.length > 0, \"PARAM_NOT_INVALID\");\n        require(sellingTimeIntervals.length == sellingPrice.length && sellingPrice.length == sellingAmount.length, \"PARAM_NOT_INVALID\");\n        for (uint256 i = 0; i < sellingTimeIntervals.length - 1; i++) {\n            require(sellingTimeIntervals[i] < sellingTimeIntervals[i + 1], \"INTERVAL_INVALID\");\n            require(sellingPrice[i] != 0, \"PRICE_INVALID\");\n        }\n        _SELLING_TIME_INTERVAL_ = sellingTimeIntervals;\n        _SELLING_PRICE_SET_ = sellingPrice;\n        _SELLING_AMOUNT_SET_ = sellingAmount;\n        emit SetSellingInfo();\n    }\n\n\n    function _setProbInfo(uint256[] memory probIntervals,uint256[][] memory tokenIdMap) internal {\n        require(_IS_PROB_MODE_, \"ONLY_ALLOW_PROB_MODE\");\n        require(probIntervals.length > 0, \"PARAM_NOT_INVALID\");\n        require(tokenIdMap.length == probIntervals.length, \"PARAM_NOT_INVALID\");\n\n        require(tokenIdMap[0].length > 0, \"INVALID\");\n        for (uint256 i = 1; i < probIntervals.length; i++) {\n            require(probIntervals[i] > probIntervals[i - 1], \"INTERVAL_INVALID\");\n            require(tokenIdMap[i].length > 0, \"INVALID\");\n        }\n        _PROB_INTERVAL_ = probIntervals;\n        _TOKEN_ID_MAP_ = tokenIdMap;\n        emit SetProbInfo();\n    }\n\n    function _setFixedAmountInfo(uint256[] memory tokenIdList) internal {\n        require(!_IS_PROB_MODE_, \"ONLY_ALLOW_FIXED_AMOUNT_MODE\");\n        require(tokenIdList.length > 0, \"PARAM_NOT_INVALID\");\n        _TOKEN_ID_LIST_ = tokenIdList;\n        emit SetFixedAmountInfo();\n    }\n\n    // ================= Owner ===================\n\n    function withdraw() external onlyOwner {\n        uint256 amount = IERC20(_BUY_TOKEN_).universalBalanceOf(address(this));\n        IERC20(_BUY_TOKEN_).universalTransfer(msg.sender ,amount);\n        emit Withdraw(msg.sender, amount);\n    }\n\n    function setRevealRn() external onlyOwner {\n        require(_REVEAL_RN_ == 0, \"ALREADY_SET\");\n        _REVEAL_RN_ = uint256(keccak256(abi.encodePacked(blockhash(block.number - 1))));\n        emit SetReveal();\n    }\n    \n    function setSellingInfo(uint256[] memory sellingTimeIntervals, uint256[] memory prices, uint256[] memory amounts) external notStart() onlyOwner {\n        _setSellingInfo(sellingTimeIntervals, prices, amounts);\n    }\n\n    function setProbInfo(uint256[] memory probIntervals,uint256[][] memory tokenIdMaps) external notStart() onlyOwner {\n        _setProbInfo(probIntervals, tokenIdMaps);\n    }\n\n    function setFixedAmountInfo(uint256[] memory tokenIdList) external notStart() onlyOwner {\n        _setFixedAmountInfo(tokenIdList);\n    }\n\n    function addFixedAmountInfo(uint256[] memory addTokenIdList) external notStart() onlyOwner {\n        for (uint256 i = 0; i < addTokenIdList.length; i++) {\n            _TOKEN_ID_LIST_.push(addTokenIdList[i]);\n        }\n        emit SetFixedAmountInfo();\n    }\n\n    function setTokenIdMapByIndex(uint256 index, uint256[] memory tokenIds) external notStart() onlyOwner {\n        require(_IS_PROB_MODE_, \"ONLY_ALLOW_PROB_MODE\");\n        require(tokenIds.length > 0 && index < _TOKEN_ID_MAP_.length,\"PARAM_NOT_INVALID\");\n        _TOKEN_ID_MAP_[index] = tokenIds;\n        emit SetTokenIdMapByIndex(index);\n    }\n    \n    function updateRNG(address newRNG) external onlyOwner {\n        require(newRNG != address(0));\n        _RNG_ = newRNG;\n        emit ChangeRNG(newRNG);\n    }\n\n    function updateTicketUnit(uint256 newTicketUnit) external onlyOwner {\n        require(newTicketUnit != 0);\n        _TICKET_UNIT_ = newTicketUnit;\n        emit ChangeTicketUnit(newTicketUnit);\n    }\n\n    function updateRedeemTime(uint256 newRedeemTime) external onlyOwner {\n        require(newRedeemTime > block.timestamp || newRedeemTime == 0, \"PARAM_NOT_INVALID\");\n        _REDEEM_ALLOWED_TIME_ = newRedeemTime;\n        emit ChangeRedeemTime(newRedeemTime);\n    }\n\n    // ================= View ===================\n\n    function getSellingStage() public view returns (uint256 stageLen) {\n        stageLen = _SELLING_TIME_INTERVAL_.length;\n    }\n\n    function getSellingInfo() public view returns (uint256 curPrice, uint256 sellAmount, uint256 index) {\n        uint256 curBlockTime = block.timestamp;\n        if(curBlockTime >= _SELLING_TIME_INTERVAL_[0] && _SELLING_TIME_INTERVAL_[0] != 0) {\n            uint256 i;\n            for (i = 1; i < _SELLING_TIME_INTERVAL_.length; i++) {\n                if (curBlockTime <= _SELLING_TIME_INTERVAL_[i]) {\n                    break;\n                }\n            }\n            curPrice = _SELLING_PRICE_SET_[i-1];\n            sellAmount = _SELLING_AMOUNT_SET_[i-1];\n            index = i - 1;\n        }\n    }\n\n    function addressToShortString(address _addr) public pure returns (string memory) {\n        bytes32 value = bytes32(uint256(_addr));\n        bytes memory alphabet = \"0123456789abcdef\";\n\n        bytes memory str = new bytes(8);\n        for (uint256 i = 0; i < 4; i++) {\n            str[i * 2] = alphabet[uint8(value[i + 12] >> 4)];\n            str[1 + i * 2] = alphabet[uint8(value[i + 12] & 0x0f)];\n        }\n        return string(str);\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/SlowMist-DODO-MiningV3 and NFT Smart Contract Security Audit Report/contractV2-453e323af65f0a666f7d9c2dfd01b9d32ea19533/contracts/DODODrops/DODODropsV2/DODODrops.sol",
        "vulnerability": "Assertion Failure",
        "check": "FP",
        "response": "Answer: No\nReason: The code does not contain any assertions that could fail."
    },
    {
        "code_segment": "contract DODODrops is InitializableMintableERC20, ReentrancyGuard {\n    using SafeMath for uint256;\n    using Address for address;\n    using UniversalERC20 for IERC20;\n\n    // ============ Storage ============\n    address constant _BASE_COIN_ = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    \n    address public _BUY_TOKEN_;\n    uint256 public _BUY_TOKEN_RESERVE_;\n    address public _FEE_MODEL_;\n    address payable public _MAINTAINER_;\n    address public _NFT_TOKEN_;\n\n    uint256 public _TICKET_UNIT_ = 1; // ticket consumed in a single lottery\n    \n    uint256 [] public _SELLING_TIME_INTERVAL_;\n    uint256 [] public _SELLING_PRICE_SET_;\n    uint256 [] public _SELLING_AMOUNT_SET_;\n    uint256 public _REDEEM_ALLOWED_TIME_;\n\n    uint256[] public _PROB_INTERVAL_; // index => Interval probability (Only For ProbMode)  \n    uint256[][] public _TOKEN_ID_MAP_; // Interval index => tokenIds (Only For ProbMode)\n    \n    uint256[] public _TOKEN_ID_LIST_; //index => tokenId (Only For FixedAmount mode)\n\n    bool public _IS_PROB_MODE_; // false = FixedAmount mode,  true = ProbMode\n    bool public _IS_REVEAL_MODE_;\n    uint256 public _REVEAL_RN_ = 0; \n    address public _RNG_;\n\n    fallback() external payable {}\n\n    receive() external payable {}\n\n    // ============ Modifiers ============\n\n    modifier notStart() {\n        require(block.timestamp < _SELLING_TIME_INTERVAL_[0] || _SELLING_TIME_INTERVAL_[0]  == 0, \"ALREADY_START\");\n        _;\n    }\n\n    // ============ Event =============\n    event BuyTicket(address account, uint256 payAmount, uint256 feeAmount, uint256 ticketAmount);\n    event RedeemPrize(address account, uint256 tokenId, address referer);\n\n    event ChangeRNG(address rng);\n    event ChangeRedeemTime(uint256 redeemTime);\n    event ChangeTicketUnit(uint256 newTicketUnit);\n    event Withdraw(address account, uint256 amount);\n    event SetReveal();\n\n    event SetSellingInfo();\n    event SetProbInfo(); // only for ProbMode\n    event SetTokenIdMapByIndex(uint256 index); // only for ProbMode\n    event SetFixedAmountInfo(); // only for FixedAmount mode\n\n\n    function init(\n        address[] memory addrList, //0 owner, 1 buyToken, 2 feeModel, 3 defaultMaintainer 4 rng 5 nftToken\n        uint256[] memory sellingTimeInterval,\n        uint256[] memory sellingPrice,\n        uint256[] memory sellingAmount,\n        uint256 redeemAllowedTime,\n        bool isRevealMode,\n        bool isProbMode\n    ) public {\n        _BUY_TOKEN_ = addrList[1];\n        _FEE_MODEL_ = addrList[2];\n        _MAINTAINER_ = payable(addrList[3]);\n        _RNG_ = addrList[4];\n        _NFT_TOKEN_ = addrList[5];\n\n        _IS_REVEAL_MODE_ = isRevealMode;\n        _IS_PROB_MODE_ = isProbMode;\n        _REDEEM_ALLOWED_TIME_ = redeemAllowedTime;\n\n        if(sellingTimeInterval.length > 0) _setSellingInfo(sellingTimeInterval, sellingPrice, sellingAmount);\n        \n        string memory prefix = \"DROPS_\";\n        name = string(abi.encodePacked(prefix, addressToShortString(address(this))));\n        symbol = name;\n        decimals = 0;\n\n        //init Owner\n        super.init(addrList[0], 0, name, symbol, decimals);\n    }\n\n    function buyTickets(address ticketTo, uint256 ticketAmount) payable external preventReentrant {\n        (uint256 curPrice, uint256 sellAmount, uint256 index) = getSellingInfo();\n        require(curPrice > 0 && sellAmount > 0, \"CAN_NOT_BUY\");\n        require(ticketAmount <= sellAmount, \"TICKETS_NOT_ENOUGH\");\n        (uint256 payAmount, uint256 feeAmount) = IDropsFeeModel(_FEE_MODEL_).getPayAmount(address(this), ticketTo, curPrice, ticketAmount);\n        require(payAmount > 0, \"UnQualified\");\n\n        uint256 baseBalance = IERC20(_BUY_TOKEN_).universalBalanceOf(address(this));\n        uint256 buyInput = baseBalance.sub(_BUY_TOKEN_RESERVE_);\n\n        require(payAmount <= buyInput, \"PAY_AMOUNT_NOT_ENOUGH\");\n\n        _SELLING_AMOUNT_SET_[index] = sellAmount.sub(ticketAmount);\n        _BUY_TOKEN_RESERVE_ = baseBalance.sub(feeAmount);\n\n        IERC20(_BUY_TOKEN_).universalTransfer(_MAINTAINER_,feeAmount);\n        _mint(ticketTo, ticketAmount);\n        emit BuyTicket(ticketTo, payAmount, feeAmount, ticketAmount);\n    }\n\n    function redeemTicket(uint256 ticketNum, address referer) external {\n        require(!address(msg.sender).isContract(), \"ONLY_ALLOW_EOA\");\n        require(ticketNum >= 1 && ticketNum <= balanceOf(msg.sender), \"TICKET_NUM_INVALID\");\n        _burn(msg.sender,ticketNum);\n        for (uint256 i = 0; i < ticketNum; i++) {\n            _redeemSinglePrize(msg.sender, i, referer);\n        }\n    }\n\n    // ============ Internal  ============\n    // SWC-120-Weak Sources of Randomness from Chain Attributes: L156\n    function _redeemSinglePrize(address to, uint256 curNo, address referer) internal {\n        require(block.timestamp >= _REDEEM_ALLOWED_TIME_ && _REDEEM_ALLOWED_TIME_ != 0, \"REDEEM_CLOSE\");\n        uint256 range;\n        if(_IS_PROB_MODE_) {\n            range = _PROB_INTERVAL_[_PROB_INTERVAL_.length - 1];\n        }else {\n            range = _TOKEN_ID_LIST_.length;\n        }\n        uint256 random;\n        if(_IS_REVEAL_MODE_) {\n            require(_REVEAL_RN_ != 0, \"REVEAL_NOT_SET\");\n            random = uint256(keccak256(abi.encodePacked(_REVEAL_RN_, msg.sender, balanceOf(msg.sender).add(curNo + 1)))) % range;\n        }else {\n            random = IRandomGenerator(_RNG_).random(gasleft() + block.number) % range; \n        }\n        uint256 tokenId;\n        if(_IS_PROB_MODE_) {\n            uint256 i;\n            for (i = 0; i < _PROB_INTERVAL_.length; i++) {\n                if (random <= _PROB_INTERVAL_[i]) {\n                    break;\n                }\n            }\n            require(_TOKEN_ID_MAP_[i].length > 0, \"EMPTY_TOKEN_ID_MAP\");\n            tokenId = _TOKEN_ID_MAP_[i][random % _TOKEN_ID_MAP_[i].length];\n            IDropsNft(_NFT_TOKEN_).mint(to, tokenId, 1, \"\");\n        } else {\n            tokenId = _TOKEN_ID_LIST_[random];\n            if(random != range - 1) {\n                _TOKEN_ID_LIST_[random] = _TOKEN_ID_LIST_[range - 1];\n            }\n            _TOKEN_ID_LIST_.pop();\n            IDropsNft(_NFT_TOKEN_).mint(to, tokenId);  \n        }\n        emit RedeemPrize(to, tokenId, referer);\n    }\n\n\n    function _setSellingInfo(uint256[] memory sellingTimeIntervals, uint256[] memory sellingPrice, uint256[] memory sellingAmount) internal {\n        require(sellingTimeIntervals.length > 0, \"PARAM_NOT_INVALID\");\n        require(sellingTimeIntervals.length == sellingPrice.length && sellingPrice.length == sellingAmount.length, \"PARAM_NOT_INVALID\");\n        for (uint256 i = 0; i < sellingTimeIntervals.length - 1; i++) {\n            require(sellingTimeIntervals[i] < sellingTimeIntervals[i + 1], \"INTERVAL_INVALID\");\n            require(sellingPrice[i] != 0, \"PRICE_INVALID\");\n        }\n        _SELLING_TIME_INTERVAL_ = sellingTimeIntervals;\n        _SELLING_PRICE_SET_ = sellingPrice;\n        _SELLING_AMOUNT_SET_ = sellingAmount;\n        emit SetSellingInfo();\n    }\n\n\n    function _setProbInfo(uint256[] memory probIntervals,uint256[][] memory tokenIdMap) internal {\n        require(_IS_PROB_MODE_, \"ONLY_ALLOW_PROB_MODE\");\n        require(probIntervals.length > 0, \"PARAM_NOT_INVALID\");\n        require(tokenIdMap.length == probIntervals.length, \"PARAM_NOT_INVALID\");\n\n        require(tokenIdMap[0].length > 0, \"INVALID\");\n        for (uint256 i = 1; i < probIntervals.length; i++) {\n            require(probIntervals[i] > probIntervals[i - 1], \"INTERVAL_INVALID\");\n            require(tokenIdMap[i].length > 0, \"INVALID\");\n        }\n        _PROB_INTERVAL_ = probIntervals;\n        _TOKEN_ID_MAP_ = tokenIdMap;\n        emit SetProbInfo();\n    }\n\n    function _setFixedAmountInfo(uint256[] memory tokenIdList) internal {\n        require(!_IS_PROB_MODE_, \"ONLY_ALLOW_FIXED_AMOUNT_MODE\");\n        require(tokenIdList.length > 0, \"PARAM_NOT_INVALID\");\n        _TOKEN_ID_LIST_ = tokenIdList;\n        emit SetFixedAmountInfo();\n    }\n\n    // ================= Owner ===================\n\n    function withdraw() external onlyOwner {\n        uint256 amount = IERC20(_BUY_TOKEN_).universalBalanceOf(address(this));\n        IERC20(_BUY_TOKEN_).universalTransfer(msg.sender ,amount);\n        emit Withdraw(msg.sender, amount);\n    }\n\n    function setRevealRn() external onlyOwner {\n        require(_REVEAL_RN_ == 0, \"ALREADY_SET\");\n        _REVEAL_RN_ = uint256(keccak256(abi.encodePacked(blockhash(block.number - 1))));\n        emit SetReveal();\n    }\n    \n    function setSellingInfo(uint256[] memory sellingTimeIntervals, uint256[] memory prices, uint256[] memory amounts) external notStart() onlyOwner {\n        _setSellingInfo(sellingTimeIntervals, prices, amounts);\n    }\n\n    function setProbInfo(uint256[] memory probIntervals,uint256[][] memory tokenIdMaps) external notStart() onlyOwner {\n        _setProbInfo(probIntervals, tokenIdMaps);\n    }\n\n    function setFixedAmountInfo(uint256[] memory tokenIdList) external notStart() onlyOwner {\n        _setFixedAmountInfo(tokenIdList);\n    }\n\n    function addFixedAmountInfo(uint256[] memory addTokenIdList) external notStart() onlyOwner {\n        for (uint256 i = 0; i < addTokenIdList.length; i++) {\n            _TOKEN_ID_LIST_.push(addTokenIdList[i]);\n        }\n        emit SetFixedAmountInfo();\n    }\n\n    function setTokenIdMapByIndex(uint256 index, uint256[] memory tokenIds) external notStart() onlyOwner {\n        require(_IS_PROB_MODE_, \"ONLY_ALLOW_PROB_MODE\");\n        require(tokenIds.length > 0 && index < _TOKEN_ID_MAP_.length,\"PARAM_NOT_INVALID\");\n        _TOKEN_ID_MAP_[index] = tokenIds;\n        emit SetTokenIdMapByIndex(index);\n    }\n    \n    function updateRNG(address newRNG) external onlyOwner {\n        require(newRNG != address(0));\n        _RNG_ = newRNG;\n        emit ChangeRNG(newRNG);\n    }\n\n    function updateTicketUnit(uint256 newTicketUnit) external onlyOwner {\n        require(newTicketUnit != 0);\n        _TICKET_UNIT_ = newTicketUnit;\n        emit ChangeTicketUnit(newTicketUnit);\n    }\n\n    function updateRedeemTime(uint256 newRedeemTime) external onlyOwner {\n        require(newRedeemTime > block.timestamp || newRedeemTime == 0, \"PARAM_NOT_INVALID\");\n        _REDEEM_ALLOWED_TIME_ = newRedeemTime;\n        emit ChangeRedeemTime(newRedeemTime);\n    }\n\n    // ================= View ===================\n\n    function getSellingStage() public view returns (uint256 stageLen) {\n        stageLen = _SELLING_TIME_INTERVAL_.length;\n    }\n\n    function getSellingInfo() public view returns (uint256 curPrice, uint256 sellAmount, uint256 index) {\n        uint256 curBlockTime = block.timestamp;\n        if(curBlockTime >= _SELLING_TIME_INTERVAL_[0] && _SELLING_TIME_INTERVAL_[0] != 0) {\n            uint256 i;\n            for (i = 1; i < _SELLING_TIME_INTERVAL_.length; i++) {\n                if (curBlockTime <= _SELLING_TIME_INTERVAL_[i]) {\n                    break;\n                }\n            }\n            curPrice = _SELLING_PRICE_SET_[i-1];\n            sellAmount = _SELLING_AMOUNT_SET_[i-1];\n            index = i - 1;\n        }\n    }\n\n    function addressToShortString(address _addr) public pure returns (string memory) {\n        bytes32 value = bytes32(uint256(_addr));\n        bytes memory alphabet = \"0123456789abcdef\";\n\n        bytes memory str = new bytes(8);\n        for (uint256 i = 0; i < 4; i++) {\n            str[i * 2] = alphabet[uint8(value[i + 12] >> 4)];\n            str[1 + i * 2] = alphabet[uint8(value[i + 12] & 0x0f)];\n        }\n        return string(str);\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/SlowMist-DODO-MiningV3 and NFT Smart Contract Security Audit Report/contractV2-453e323af65f0a666f7d9c2dfd01b9d32ea19533/contracts/DODODrops/DODODropsV2/DODODrops.sol",
        "vulnerability": "Assertion Failure",
        "check": "FP",
        "response": "Answer: No\nReason: No assert statements are used in the given smart contract, avoiding the potential for assertion failures."
    },
    {
        "code_segment": "contract DODODrops is InitializableMintableERC20, ReentrancyGuard {\n    using SafeMath for uint256;\n    using Address for address;\n    using UniversalERC20 for IERC20;\n\n    // ============ Storage ============\n    address constant _BASE_COIN_ = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    \n    address public _BUY_TOKEN_;\n    uint256 public _BUY_TOKEN_RESERVE_;\n    address public _FEE_MODEL_;\n    address payable public _MAINTAINER_;\n    address public _NFT_TOKEN_;\n\n    uint256 public _TICKET_UNIT_ = 1; // ticket consumed in a single lottery\n    \n    uint256 [] public _SELLING_TIME_INTERVAL_;\n    uint256 [] public _SELLING_PRICE_SET_;\n    uint256 [] public _SELLING_AMOUNT_SET_;\n    uint256 public _REDEEM_ALLOWED_TIME_;\n\n    uint256[] public _PROB_INTERVAL_; // index => Interval probability (Only For ProbMode)  \n    uint256[][] public _TOKEN_ID_MAP_; // Interval index => tokenIds (Only For ProbMode)\n    \n    uint256[] public _TOKEN_ID_LIST_; //index => tokenId (Only For FixedAmount mode)\n\n    bool public _IS_PROB_MODE_; // false = FixedAmount mode,  true = ProbMode\n    bool public _IS_REVEAL_MODE_;\n    uint256 public _REVEAL_RN_ = 0; \n    address public _RNG_;\n\n    fallback() external payable {}\n\n    receive() external payable {}\n\n    // ============ Modifiers ============\n\n    modifier notStart() {\n        require(block.timestamp < _SELLING_TIME_INTERVAL_[0] || _SELLING_TIME_INTERVAL_[0]  == 0, \"ALREADY_START\");\n        _;\n    }\n\n    // ============ Event =============\n    event BuyTicket(address account, uint256 payAmount, uint256 feeAmount, uint256 ticketAmount);\n    event RedeemPrize(address account, uint256 tokenId, address referer);\n\n    event ChangeRNG(address rng);\n    event ChangeRedeemTime(uint256 redeemTime);\n    event ChangeTicketUnit(uint256 newTicketUnit);\n    event Withdraw(address account, uint256 amount);\n    event SetReveal();\n\n    event SetSellingInfo();\n    event SetProbInfo(); // only for ProbMode\n    event SetTokenIdMapByIndex(uint256 index); // only for ProbMode\n    event SetFixedAmountInfo(); // only for FixedAmount mode\n\n\n    function init(\n        address[] memory addrList, //0 owner, 1 buyToken, 2 feeModel, 3 defaultMaintainer 4 rng 5 nftToken\n        uint256[] memory sellingTimeInterval,\n        uint256[] memory sellingPrice,\n        uint256[] memory sellingAmount,\n        uint256 redeemAllowedTime,\n        bool isRevealMode,\n        bool isProbMode\n    ) public {\n        _BUY_TOKEN_ = addrList[1];\n        _FEE_MODEL_ = addrList[2];\n        _MAINTAINER_ = payable(addrList[3]);\n        _RNG_ = addrList[4];\n        _NFT_TOKEN_ = addrList[5];\n\n        _IS_REVEAL_MODE_ = isRevealMode;\n        _IS_PROB_MODE_ = isProbMode;\n        _REDEEM_ALLOWED_TIME_ = redeemAllowedTime;\n\n        if(sellingTimeInterval.length > 0) _setSellingInfo(sellingTimeInterval, sellingPrice, sellingAmount);\n        \n        string memory prefix = \"DROPS_\";\n        name = string(abi.encodePacked(prefix, addressToShortString(address(this))));\n        symbol = name;\n        decimals = 0;\n\n        //init Owner\n        super.init(addrList[0], 0, name, symbol, decimals);\n    }\n\n    function buyTickets(address ticketTo, uint256 ticketAmount) payable external preventReentrant {\n        (uint256 curPrice, uint256 sellAmount, uint256 index) = getSellingInfo();\n        require(curPrice > 0 && sellAmount > 0, \"CAN_NOT_BUY\");\n        require(ticketAmount <= sellAmount, \"TICKETS_NOT_ENOUGH\");\n        (uint256 payAmount, uint256 feeAmount) = IDropsFeeModel(_FEE_MODEL_).getPayAmount(address(this), ticketTo, curPrice, ticketAmount);\n        require(payAmount > 0, \"UnQualified\");\n\n        uint256 baseBalance = IERC20(_BUY_TOKEN_).universalBalanceOf(address(this));\n        uint256 buyInput = baseBalance.sub(_BUY_TOKEN_RESERVE_);\n\n        require(payAmount <= buyInput, \"PAY_AMOUNT_NOT_ENOUGH\");\n\n        _SELLING_AMOUNT_SET_[index] = sellAmount.sub(ticketAmount);\n        _BUY_TOKEN_RESERVE_ = baseBalance.sub(feeAmount);\n\n        IERC20(_BUY_TOKEN_).universalTransfer(_MAINTAINER_,feeAmount);\n        _mint(ticketTo, ticketAmount);\n        emit BuyTicket(ticketTo, payAmount, feeAmount, ticketAmount);\n    }\n\n    function redeemTicket(uint256 ticketNum, address referer) external {\n        require(!address(msg.sender).isContract(), \"ONLY_ALLOW_EOA\");\n        require(ticketNum >= 1 && ticketNum <= balanceOf(msg.sender), \"TICKET_NUM_INVALID\");\n        _burn(msg.sender,ticketNum);\n        for (uint256 i = 0; i < ticketNum; i++) {\n            _redeemSinglePrize(msg.sender, i, referer);\n        }\n    }\n\n    // ============ Internal  ============\n    // SWC-120-Weak Sources of Randomness from Chain Attributes: L156\n    function _redeemSinglePrize(address to, uint256 curNo, address referer) internal {\n        require(block.timestamp >= _REDEEM_ALLOWED_TIME_ && _REDEEM_ALLOWED_TIME_ != 0, \"REDEEM_CLOSE\");\n        uint256 range;\n        if(_IS_PROB_MODE_) {\n            range = _PROB_INTERVAL_[_PROB_INTERVAL_.length - 1];\n        }else {\n            range = _TOKEN_ID_LIST_.length;\n        }\n        uint256 random;\n        if(_IS_REVEAL_MODE_) {\n            require(_REVEAL_RN_ != 0, \"REVEAL_NOT_SET\");\n            random = uint256(keccak256(abi.encodePacked(_REVEAL_RN_, msg.sender, balanceOf(msg.sender).add(curNo + 1)))) % range;\n        }else {\n            random = IRandomGenerator(_RNG_).random(gasleft() + block.number) % range; \n        }\n        uint256 tokenId;\n        if(_IS_PROB_MODE_) {\n            uint256 i;\n            for (i = 0; i < _PROB_INTERVAL_.length; i++) {\n                if (random <= _PROB_INTERVAL_[i]) {\n                    break;\n                }\n            }\n            require(_TOKEN_ID_MAP_[i].length > 0, \"EMPTY_TOKEN_ID_MAP\");\n            tokenId = _TOKEN_ID_MAP_[i][random % _TOKEN_ID_MAP_[i].length];\n            IDropsNft(_NFT_TOKEN_).mint(to, tokenId, 1, \"\");\n        } else {\n            tokenId = _TOKEN_ID_LIST_[random];\n            if(random != range - 1) {\n                _TOKEN_ID_LIST_[random] = _TOKEN_ID_LIST_[range - 1];\n            }\n            _TOKEN_ID_LIST_.pop();\n            IDropsNft(_NFT_TOKEN_).mint(to, tokenId);  \n        }\n        emit RedeemPrize(to, tokenId, referer);\n    }\n\n\n    function _setSellingInfo(uint256[] memory sellingTimeIntervals, uint256[] memory sellingPrice, uint256[] memory sellingAmount) internal {\n        require(sellingTimeIntervals.length > 0, \"PARAM_NOT_INVALID\");\n        require(sellingTimeIntervals.length == sellingPrice.length && sellingPrice.length == sellingAmount.length, \"PARAM_NOT_INVALID\");\n        for (uint256 i = 0; i < sellingTimeIntervals.length - 1; i++) {\n            require(sellingTimeIntervals[i] < sellingTimeIntervals[i + 1], \"INTERVAL_INVALID\");\n            require(sellingPrice[i] != 0, \"PRICE_INVALID\");\n        }\n        _SELLING_TIME_INTERVAL_ = sellingTimeIntervals;\n        _SELLING_PRICE_SET_ = sellingPrice;\n        _SELLING_AMOUNT_SET_ = sellingAmount;\n        emit SetSellingInfo();\n    }\n\n\n    function _setProbInfo(uint256[] memory probIntervals,uint256[][] memory tokenIdMap) internal {\n        require(_IS_PROB_MODE_, \"ONLY_ALLOW_PROB_MODE\");\n        require(probIntervals.length > 0, \"PARAM_NOT_INVALID\");\n        require(tokenIdMap.length == probIntervals.length, \"PARAM_NOT_INVALID\");\n\n        require(tokenIdMap[0].length > 0, \"INVALID\");\n        for (uint256 i = 1; i < probIntervals.length; i++) {\n            require(probIntervals[i] > probIntervals[i - 1], \"INTERVAL_INVALID\");\n            require(tokenIdMap[i].length > 0, \"INVALID\");\n        }\n        _PROB_INTERVAL_ = probIntervals;\n        _TOKEN_ID_MAP_ = tokenIdMap;\n        emit SetProbInfo();\n    }\n\n    function _setFixedAmountInfo(uint256[] memory tokenIdList) internal {\n        require(!_IS_PROB_MODE_, \"ONLY_ALLOW_FIXED_AMOUNT_MODE\");\n        require(tokenIdList.length > 0, \"PARAM_NOT_INVALID\");\n        _TOKEN_ID_LIST_ = tokenIdList;\n        emit SetFixedAmountInfo();\n    }\n\n    // ================= Owner ===================\n\n    function withdraw() external onlyOwner {\n        uint256 amount = IERC20(_BUY_TOKEN_).universalBalanceOf(address(this));\n        IERC20(_BUY_TOKEN_).universalTransfer(msg.sender ,amount);\n        emit Withdraw(msg.sender, amount);\n    }\n\n    function setRevealRn() external onlyOwner {\n        require(_REVEAL_RN_ == 0, \"ALREADY_SET\");\n        _REVEAL_RN_ = uint256(keccak256(abi.encodePacked(blockhash(block.number - 1))));\n        emit SetReveal();\n    }\n    \n    function setSellingInfo(uint256[] memory sellingTimeIntervals, uint256[] memory prices, uint256[] memory amounts) external notStart() onlyOwner {\n        _setSellingInfo(sellingTimeIntervals, prices, amounts);\n    }\n\n    function setProbInfo(uint256[] memory probIntervals,uint256[][] memory tokenIdMaps) external notStart() onlyOwner {\n        _setProbInfo(probIntervals, tokenIdMaps);\n    }\n\n    function setFixedAmountInfo(uint256[] memory tokenIdList) external notStart() onlyOwner {\n        _setFixedAmountInfo(tokenIdList);\n    }\n\n    function addFixedAmountInfo(uint256[] memory addTokenIdList) external notStart() onlyOwner {\n        for (uint256 i = 0; i < addTokenIdList.length; i++) {\n            _TOKEN_ID_LIST_.push(addTokenIdList[i]);\n        }\n        emit SetFixedAmountInfo();\n    }\n\n    function setTokenIdMapByIndex(uint256 index, uint256[] memory tokenIds) external notStart() onlyOwner {\n        require(_IS_PROB_MODE_, \"ONLY_ALLOW_PROB_MODE\");\n        require(tokenIds.length > 0 && index < _TOKEN_ID_MAP_.length,\"PARAM_NOT_INVALID\");\n        _TOKEN_ID_MAP_[index] = tokenIds;\n        emit SetTokenIdMapByIndex(index);\n    }\n    \n    function updateRNG(address newRNG) external onlyOwner {\n        require(newRNG != address(0));\n        _RNG_ = newRNG;\n        emit ChangeRNG(newRNG);\n    }\n\n    function updateTicketUnit(uint256 newTicketUnit) external onlyOwner {\n        require(newTicketUnit != 0);\n        _TICKET_UNIT_ = newTicketUnit;\n        emit ChangeTicketUnit(newTicketUnit);\n    }\n\n    function updateRedeemTime(uint256 newRedeemTime) external onlyOwner {\n        require(newRedeemTime > block.timestamp || newRedeemTime == 0, \"PARAM_NOT_INVALID\");\n        _REDEEM_ALLOWED_TIME_ = newRedeemTime;\n        emit ChangeRedeemTime(newRedeemTime);\n    }\n\n    // ================= View ===================\n\n    function getSellingStage() public view returns (uint256 stageLen) {\n        stageLen = _SELLING_TIME_INTERVAL_.length;\n    }\n\n    function getSellingInfo() public view returns (uint256 curPrice, uint256 sellAmount, uint256 index) {\n        uint256 curBlockTime = block.timestamp;\n        if(curBlockTime >= _SELLING_TIME_INTERVAL_[0] && _SELLING_TIME_INTERVAL_[0] != 0) {\n            uint256 i;\n            for (i = 1; i < _SELLING_TIME_INTERVAL_.length; i++) {\n                if (curBlockTime <= _SELLING_TIME_INTERVAL_[i]) {\n                    break;\n                }\n            }\n            curPrice = _SELLING_PRICE_SET_[i-1];\n            sellAmount = _SELLING_AMOUNT_SET_[i-1];\n            index = i - 1;\n        }\n    }\n\n    function addressToShortString(address _addr) public pure returns (string memory) {\n        bytes32 value = bytes32(uint256(_addr));\n        bytes memory alphabet = \"0123456789abcdef\";\n\n        bytes memory str = new bytes(8);\n        for (uint256 i = 0; i < 4; i++) {\n            str[i * 2] = alphabet[uint8(value[i + 12] >> 4)];\n            str[1 + i * 2] = alphabet[uint8(value[i + 12] & 0x0f)];\n        }\n        return string(str);\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/SlowMist-DODO-MiningV3 and NFT Smart Contract Security Audit Report/contractV2-453e323af65f0a666f7d9c2dfd01b9d32ea19533/contracts/DODODrops/DODODropsV2/DODODrops.sol",
        "vulnerability": "Assertion Failure",
        "check": "FP",
        "response": "Answer: No\nReason: Reviewed code does not contain any assert statements that could result in \"Assertion Failure\"."
    },
    {
        "code_segment": "contract DODODrops is InitializableMintableERC20, ReentrancyGuard {\n    using SafeMath for uint256;\n    using Address for address;\n    using UniversalERC20 for IERC20;\n\n    // ============ Storage ============\n    address constant _BASE_COIN_ = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    \n    address public _BUY_TOKEN_;\n    uint256 public _BUY_TOKEN_RESERVE_;\n    address public _FEE_MODEL_;\n    address payable public _MAINTAINER_;\n    address public _NFT_TOKEN_;\n\n    uint256 public _TICKET_UNIT_ = 1; // ticket consumed in a single lottery\n    \n    uint256 [] public _SELLING_TIME_INTERVAL_;\n    uint256 [] public _SELLING_PRICE_SET_;\n    uint256 [] public _SELLING_AMOUNT_SET_;\n    uint256 public _REDEEM_ALLOWED_TIME_;\n\n    uint256[] public _PROB_INTERVAL_; // index => Interval probability (Only For ProbMode)  \n    uint256[][] public _TOKEN_ID_MAP_; // Interval index => tokenIds (Only For ProbMode)\n    \n    uint256[] public _TOKEN_ID_LIST_; //index => tokenId (Only For FixedAmount mode)\n\n    bool public _IS_PROB_MODE_; // false = FixedAmount mode,  true = ProbMode\n    bool public _IS_REVEAL_MODE_;\n    uint256 public _REVEAL_RN_ = 0; \n    address public _RNG_;\n\n    fallback() external payable {}\n\n    receive() external payable {}\n\n    // ============ Modifiers ============\n\n    modifier notStart() {\n        require(block.timestamp < _SELLING_TIME_INTERVAL_[0] || _SELLING_TIME_INTERVAL_[0]  == 0, \"ALREADY_START\");\n        _;\n    }\n\n    // ============ Event =============\n    event BuyTicket(address account, uint256 payAmount, uint256 feeAmount, uint256 ticketAmount);\n    event RedeemPrize(address account, uint256 tokenId, address referer);\n\n    event ChangeRNG(address rng);\n    event ChangeRedeemTime(uint256 redeemTime);\n    event ChangeTicketUnit(uint256 newTicketUnit);\n    event Withdraw(address account, uint256 amount);\n    event SetReveal();\n\n    event SetSellingInfo();\n    event SetProbInfo(); // only for ProbMode\n    event SetTokenIdMapByIndex(uint256 index); // only for ProbMode\n    event SetFixedAmountInfo(); // only for FixedAmount mode\n\n\n    function init(\n        address[] memory addrList, //0 owner, 1 buyToken, 2 feeModel, 3 defaultMaintainer 4 rng 5 nftToken\n        uint256[] memory sellingTimeInterval,\n        uint256[] memory sellingPrice,\n        uint256[] memory sellingAmount,\n        uint256 redeemAllowedTime,\n        bool isRevealMode,\n        bool isProbMode\n    ) public {\n        _BUY_TOKEN_ = addrList[1];\n        _FEE_MODEL_ = addrList[2];\n        _MAINTAINER_ = payable(addrList[3]);\n        _RNG_ = addrList[4];\n        _NFT_TOKEN_ = addrList[5];\n\n        _IS_REVEAL_MODE_ = isRevealMode;\n        _IS_PROB_MODE_ = isProbMode;\n        _REDEEM_ALLOWED_TIME_ = redeemAllowedTime;\n\n        if(sellingTimeInterval.length > 0) _setSellingInfo(sellingTimeInterval, sellingPrice, sellingAmount);\n        \n        string memory prefix = \"DROPS_\";\n        name = string(abi.encodePacked(prefix, addressToShortString(address(this))));\n        symbol = name;\n        decimals = 0;\n\n        //init Owner\n        super.init(addrList[0], 0, name, symbol, decimals);\n    }\n\n    function buyTickets(address ticketTo, uint256 ticketAmount) payable external preventReentrant {\n        (uint256 curPrice, uint256 sellAmount, uint256 index) = getSellingInfo();\n        require(curPrice > 0 && sellAmount > 0, \"CAN_NOT_BUY\");\n        require(ticketAmount <= sellAmount, \"TICKETS_NOT_ENOUGH\");\n        (uint256 payAmount, uint256 feeAmount) = IDropsFeeModel(_FEE_MODEL_).getPayAmount(address(this), ticketTo, curPrice, ticketAmount);\n        require(payAmount > 0, \"UnQualified\");\n\n        uint256 baseBalance = IERC20(_BUY_TOKEN_).universalBalanceOf(address(this));\n        uint256 buyInput = baseBalance.sub(_BUY_TOKEN_RESERVE_);\n\n        require(payAmount <= buyInput, \"PAY_AMOUNT_NOT_ENOUGH\");\n\n        _SELLING_AMOUNT_SET_[index] = sellAmount.sub(ticketAmount);\n        _BUY_TOKEN_RESERVE_ = baseBalance.sub(feeAmount);\n\n        IERC20(_BUY_TOKEN_).universalTransfer(_MAINTAINER_,feeAmount);\n        _mint(ticketTo, ticketAmount);\n        emit BuyTicket(ticketTo, payAmount, feeAmount, ticketAmount);\n    }\n\n    function redeemTicket(uint256 ticketNum, address referer) external {\n        require(!address(msg.sender).isContract(), \"ONLY_ALLOW_EOA\");\n        require(ticketNum >= 1 && ticketNum <= balanceOf(msg.sender), \"TICKET_NUM_INVALID\");\n        _burn(msg.sender,ticketNum);\n        for (uint256 i = 0; i < ticketNum; i++) {\n            _redeemSinglePrize(msg.sender, i, referer);\n        }\n    }\n\n    // ============ Internal  ============\n    // SWC-120-Weak Sources of Randomness from Chain Attributes: L156\n    function _redeemSinglePrize(address to, uint256 curNo, address referer) internal {\n        require(block.timestamp >= _REDEEM_ALLOWED_TIME_ && _REDEEM_ALLOWED_TIME_ != 0, \"REDEEM_CLOSE\");\n        uint256 range;\n        if(_IS_PROB_MODE_) {\n            range = _PROB_INTERVAL_[_PROB_INTERVAL_.length - 1];\n        }else {\n            range = _TOKEN_ID_LIST_.length;\n        }\n        uint256 random;\n        if(_IS_REVEAL_MODE_) {\n            require(_REVEAL_RN_ != 0, \"REVEAL_NOT_SET\");\n            random = uint256(keccak256(abi.encodePacked(_REVEAL_RN_, msg.sender, balanceOf(msg.sender).add(curNo + 1)))) % range;\n        }else {\n            random = IRandomGenerator(_RNG_).random(gasleft() + block.number) % range; \n        }\n        uint256 tokenId;\n        if(_IS_PROB_MODE_) {\n            uint256 i;\n            for (i = 0; i < _PROB_INTERVAL_.length; i++) {\n                if (random <= _PROB_INTERVAL_[i]) {\n                    break;\n                }\n            }\n            require(_TOKEN_ID_MAP_[i].length > 0, \"EMPTY_TOKEN_ID_MAP\");\n            tokenId = _TOKEN_ID_MAP_[i][random % _TOKEN_ID_MAP_[i].length];\n            IDropsNft(_NFT_TOKEN_).mint(to, tokenId, 1, \"\");\n        } else {\n            tokenId = _TOKEN_ID_LIST_[random];\n            if(random != range - 1) {\n                _TOKEN_ID_LIST_[random] = _TOKEN_ID_LIST_[range - 1];\n            }\n            _TOKEN_ID_LIST_.pop();\n            IDropsNft(_NFT_TOKEN_).mint(to, tokenId);  \n        }\n        emit RedeemPrize(to, tokenId, referer);\n    }\n\n\n    function _setSellingInfo(uint256[] memory sellingTimeIntervals, uint256[] memory sellingPrice, uint256[] memory sellingAmount) internal {\n        require(sellingTimeIntervals.length > 0, \"PARAM_NOT_INVALID\");\n        require(sellingTimeIntervals.length == sellingPrice.length && sellingPrice.length == sellingAmount.length, \"PARAM_NOT_INVALID\");\n        for (uint256 i = 0; i < sellingTimeIntervals.length - 1; i++) {\n            require(sellingTimeIntervals[i] < sellingTimeIntervals[i + 1], \"INTERVAL_INVALID\");\n            require(sellingPrice[i] != 0, \"PRICE_INVALID\");\n        }\n        _SELLING_TIME_INTERVAL_ = sellingTimeIntervals;\n        _SELLING_PRICE_SET_ = sellingPrice;\n        _SELLING_AMOUNT_SET_ = sellingAmount;\n        emit SetSellingInfo();\n    }\n\n\n    function _setProbInfo(uint256[] memory probIntervals,uint256[][] memory tokenIdMap) internal {\n        require(_IS_PROB_MODE_, \"ONLY_ALLOW_PROB_MODE\");\n        require(probIntervals.length > 0, \"PARAM_NOT_INVALID\");\n        require(tokenIdMap.length == probIntervals.length, \"PARAM_NOT_INVALID\");\n\n        require(tokenIdMap[0].length > 0, \"INVALID\");\n        for (uint256 i = 1; i < probIntervals.length; i++) {\n            require(probIntervals[i] > probIntervals[i - 1], \"INTERVAL_INVALID\");\n            require(tokenIdMap[i].length > 0, \"INVALID\");\n        }\n        _PROB_INTERVAL_ = probIntervals;\n        _TOKEN_ID_MAP_ = tokenIdMap;\n        emit SetProbInfo();\n    }\n\n    function _setFixedAmountInfo(uint256[] memory tokenIdList) internal {\n        require(!_IS_PROB_MODE_, \"ONLY_ALLOW_FIXED_AMOUNT_MODE\");\n        require(tokenIdList.length > 0, \"PARAM_NOT_INVALID\");\n        _TOKEN_ID_LIST_ = tokenIdList;\n        emit SetFixedAmountInfo();\n    }\n\n    // ================= Owner ===================\n\n    function withdraw() external onlyOwner {\n        uint256 amount = IERC20(_BUY_TOKEN_).universalBalanceOf(address(this));\n        IERC20(_BUY_TOKEN_).universalTransfer(msg.sender ,amount);\n        emit Withdraw(msg.sender, amount);\n    }\n\n    function setRevealRn() external onlyOwner {\n        require(_REVEAL_RN_ == 0, \"ALREADY_SET\");\n        _REVEAL_RN_ = uint256(keccak256(abi.encodePacked(blockhash(block.number - 1))));\n        emit SetReveal();\n    }\n    \n    function setSellingInfo(uint256[] memory sellingTimeIntervals, uint256[] memory prices, uint256[] memory amounts) external notStart() onlyOwner {\n        _setSellingInfo(sellingTimeIntervals, prices, amounts);\n    }\n\n    function setProbInfo(uint256[] memory probIntervals,uint256[][] memory tokenIdMaps) external notStart() onlyOwner {\n        _setProbInfo(probIntervals, tokenIdMaps);\n    }\n\n    function setFixedAmountInfo(uint256[] memory tokenIdList) external notStart() onlyOwner {\n        _setFixedAmountInfo(tokenIdList);\n    }\n\n    function addFixedAmountInfo(uint256[] memory addTokenIdList) external notStart() onlyOwner {\n        for (uint256 i = 0; i < addTokenIdList.length; i++) {\n            _TOKEN_ID_LIST_.push(addTokenIdList[i]);\n        }\n        emit SetFixedAmountInfo();\n    }\n\n    function setTokenIdMapByIndex(uint256 index, uint256[] memory tokenIds) external notStart() onlyOwner {\n        require(_IS_PROB_MODE_, \"ONLY_ALLOW_PROB_MODE\");\n        require(tokenIds.length > 0 && index < _TOKEN_ID_MAP_.length,\"PARAM_NOT_INVALID\");\n        _TOKEN_ID_MAP_[index] = tokenIds;\n        emit SetTokenIdMapByIndex(index);\n    }\n    \n    function updateRNG(address newRNG) external onlyOwner {\n        require(newRNG != address(0));\n        _RNG_ = newRNG;\n        emit ChangeRNG(newRNG);\n    }\n\n    function updateTicketUnit(uint256 newTicketUnit) external onlyOwner {\n        require(newTicketUnit != 0);\n        _TICKET_UNIT_ = newTicketUnit;\n        emit ChangeTicketUnit(newTicketUnit);\n    }\n\n    function updateRedeemTime(uint256 newRedeemTime) external onlyOwner {\n        require(newRedeemTime > block.timestamp || newRedeemTime == 0, \"PARAM_NOT_INVALID\");\n        _REDEEM_ALLOWED_TIME_ = newRedeemTime;\n        emit ChangeRedeemTime(newRedeemTime);\n    }\n\n    // ================= View ===================\n\n    function getSellingStage() public view returns (uint256 stageLen) {\n        stageLen = _SELLING_TIME_INTERVAL_.length;\n    }\n\n    function getSellingInfo() public view returns (uint256 curPrice, uint256 sellAmount, uint256 index) {\n        uint256 curBlockTime = block.timestamp;\n        if(curBlockTime >= _SELLING_TIME_INTERVAL_[0] && _SELLING_TIME_INTERVAL_[0] != 0) {\n            uint256 i;\n            for (i = 1; i < _SELLING_TIME_INTERVAL_.length; i++) {\n                if (curBlockTime <= _SELLING_TIME_INTERVAL_[i]) {\n                    break;\n                }\n            }\n            curPrice = _SELLING_PRICE_SET_[i-1];\n            sellAmount = _SELLING_AMOUNT_SET_[i-1];\n            index = i - 1;\n        }\n    }\n\n    function addressToShortString(address _addr) public pure returns (string memory) {\n        bytes32 value = bytes32(uint256(_addr));\n        bytes memory alphabet = \"0123456789abcdef\";\n\n        bytes memory str = new bytes(8);\n        for (uint256 i = 0; i < 4; i++) {\n            str[i * 2] = alphabet[uint8(value[i + 12] >> 4)];\n            str[1 + i * 2] = alphabet[uint8(value[i + 12] & 0x0f)];\n        }\n        return string(str);\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/SlowMist-DODO-MiningV3 and NFT Smart Contract Security Audit Report/contractV2-453e323af65f0a666f7d9c2dfd01b9d32ea19533/contracts/DODODrops/DODODropsV2/DODODrops.sol",
        "vulnerability": "Assertion Failure",
        "check": "FP",
        "response": "Answer: No\nReason: The code uses assertions in the form of require statements, which are standard practice in Solidity to verify conditions and prevent unexpected behavior. There doesn't appear to be a misuse or misconfiguration that would lead to an \"Assertion Failure\" vulnerability."
    },
    {
        "code_segment": "contract DODODrops is InitializableMintableERC20, ReentrancyGuard {\n    using SafeMath for uint256;\n    using Address for address;\n    using UniversalERC20 for IERC20;\n\n    // ============ Storage ============\n    address constant _BASE_COIN_ = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    \n    address public _BUY_TOKEN_;\n    uint256 public _BUY_TOKEN_RESERVE_;\n    address public _FEE_MODEL_;\n    address payable public _MAINTAINER_;\n    address public _NFT_TOKEN_;\n\n    uint256 public _TICKET_UNIT_ = 1; // ticket consumed in a single lottery\n    \n    uint256 [] public _SELLING_TIME_INTERVAL_;\n    uint256 [] public _SELLING_PRICE_SET_;\n    uint256 [] public _SELLING_AMOUNT_SET_;\n    uint256 public _REDEEM_ALLOWED_TIME_;\n\n    uint256[] public _PROB_INTERVAL_; // index => Interval probability (Only For ProbMode)  \n    uint256[][] public _TOKEN_ID_MAP_; // Interval index => tokenIds (Only For ProbMode)\n    \n    uint256[] public _TOKEN_ID_LIST_; //index => tokenId (Only For FixedAmount mode)\n\n    bool public _IS_PROB_MODE_; // false = FixedAmount mode,  true = ProbMode\n    bool public _IS_REVEAL_MODE_;\n    uint256 public _REVEAL_RN_ = 0; \n    address public _RNG_;\n\n    fallback() external payable {}\n\n    receive() external payable {}\n\n    // ============ Modifiers ============\n\n    modifier notStart() {\n        require(block.timestamp < _SELLING_TIME_INTERVAL_[0] || _SELLING_TIME_INTERVAL_[0]  == 0, \"ALREADY_START\");\n        _;\n    }\n\n    // ============ Event =============\n    event BuyTicket(address account, uint256 payAmount, uint256 feeAmount, uint256 ticketAmount);\n    event RedeemPrize(address account, uint256 tokenId, address referer);\n\n    event ChangeRNG(address rng);\n    event ChangeRedeemTime(uint256 redeemTime);\n    event ChangeTicketUnit(uint256 newTicketUnit);\n    event Withdraw(address account, uint256 amount);\n    event SetReveal();\n\n    event SetSellingInfo();\n    event SetProbInfo(); // only for ProbMode\n    event SetTokenIdMapByIndex(uint256 index); // only for ProbMode\n    event SetFixedAmountInfo(); // only for FixedAmount mode\n\n\n    function init(\n        address[] memory addrList, //0 owner, 1 buyToken, 2 feeModel, 3 defaultMaintainer 4 rng 5 nftToken\n        uint256[] memory sellingTimeInterval,\n        uint256[] memory sellingPrice,\n        uint256[] memory sellingAmount,\n        uint256 redeemAllowedTime,\n        bool isRevealMode,\n        bool isProbMode\n    ) public {\n        _BUY_TOKEN_ = addrList[1];\n        _FEE_MODEL_ = addrList[2];\n        _MAINTAINER_ = payable(addrList[3]);\n        _RNG_ = addrList[4];\n        _NFT_TOKEN_ = addrList[5];\n\n        _IS_REVEAL_MODE_ = isRevealMode;\n        _IS_PROB_MODE_ = isProbMode;\n        _REDEEM_ALLOWED_TIME_ = redeemAllowedTime;\n\n        if(sellingTimeInterval.length > 0) _setSellingInfo(sellingTimeInterval, sellingPrice, sellingAmount);\n        \n        string memory prefix = \"DROPS_\";\n        name = string(abi.encodePacked(prefix, addressToShortString(address(this))));\n        symbol = name;\n        decimals = 0;\n\n        //init Owner\n        super.init(addrList[0], 0, name, symbol, decimals);\n    }\n\n    function buyTickets(address ticketTo, uint256 ticketAmount) payable external preventReentrant {\n        (uint256 curPrice, uint256 sellAmount, uint256 index) = getSellingInfo();\n        require(curPrice > 0 && sellAmount > 0, \"CAN_NOT_BUY\");\n        require(ticketAmount <= sellAmount, \"TICKETS_NOT_ENOUGH\");\n        (uint256 payAmount, uint256 feeAmount) = IDropsFeeModel(_FEE_MODEL_).getPayAmount(address(this), ticketTo, curPrice, ticketAmount);\n        require(payAmount > 0, \"UnQualified\");\n\n        uint256 baseBalance = IERC20(_BUY_TOKEN_).universalBalanceOf(address(this));\n        uint256 buyInput = baseBalance.sub(_BUY_TOKEN_RESERVE_);\n\n        require(payAmount <= buyInput, \"PAY_AMOUNT_NOT_ENOUGH\");\n\n        _SELLING_AMOUNT_SET_[index] = sellAmount.sub(ticketAmount);\n        _BUY_TOKEN_RESERVE_ = baseBalance.sub(feeAmount);\n\n        IERC20(_BUY_TOKEN_).universalTransfer(_MAINTAINER_,feeAmount);\n        _mint(ticketTo, ticketAmount);\n        emit BuyTicket(ticketTo, payAmount, feeAmount, ticketAmount);\n    }\n\n    function redeemTicket(uint256 ticketNum, address referer) external {\n        require(!address(msg.sender).isContract(), \"ONLY_ALLOW_EOA\");\n        require(ticketNum >= 1 && ticketNum <= balanceOf(msg.sender), \"TICKET_NUM_INVALID\");\n        _burn(msg.sender,ticketNum);\n        for (uint256 i = 0; i < ticketNum; i++) {\n            _redeemSinglePrize(msg.sender, i, referer);\n        }\n    }\n\n    // ============ Internal  ============\n    // SWC-120-Weak Sources of Randomness from Chain Attributes: L156\n    function _redeemSinglePrize(address to, uint256 curNo, address referer) internal {\n        require(block.timestamp >= _REDEEM_ALLOWED_TIME_ && _REDEEM_ALLOWED_TIME_ != 0, \"REDEEM_CLOSE\");\n        uint256 range;\n        if(_IS_PROB_MODE_) {\n            range = _PROB_INTERVAL_[_PROB_INTERVAL_.length - 1];\n        }else {\n            range = _TOKEN_ID_LIST_.length;\n        }\n        uint256 random;\n        if(_IS_REVEAL_MODE_) {\n            require(_REVEAL_RN_ != 0, \"REVEAL_NOT_SET\");\n            random = uint256(keccak256(abi.encodePacked(_REVEAL_RN_, msg.sender, balanceOf(msg.sender).add(curNo + 1)))) % range;\n        }else {\n            random = IRandomGenerator(_RNG_).random(gasleft() + block.number) % range; \n        }\n        uint256 tokenId;\n        if(_IS_PROB_MODE_) {\n            uint256 i;\n            for (i = 0; i < _PROB_INTERVAL_.length; i++) {\n                if (random <= _PROB_INTERVAL_[i]) {\n                    break;\n                }\n            }\n            require(_TOKEN_ID_MAP_[i].length > 0, \"EMPTY_TOKEN_ID_MAP\");\n            tokenId = _TOKEN_ID_MAP_[i][random % _TOKEN_ID_MAP_[i].length];\n            IDropsNft(_NFT_TOKEN_).mint(to, tokenId, 1, \"\");\n        } else {\n            tokenId = _TOKEN_ID_LIST_[random];\n            if(random != range - 1) {\n                _TOKEN_ID_LIST_[random] = _TOKEN_ID_LIST_[range - 1];\n            }\n            _TOKEN_ID_LIST_.pop();\n            IDropsNft(_NFT_TOKEN_).mint(to, tokenId);  \n        }\n        emit RedeemPrize(to, tokenId, referer);\n    }\n\n\n    function _setSellingInfo(uint256[] memory sellingTimeIntervals, uint256[] memory sellingPrice, uint256[] memory sellingAmount) internal {\n        require(sellingTimeIntervals.length > 0, \"PARAM_NOT_INVALID\");\n        require(sellingTimeIntervals.length == sellingPrice.length && sellingPrice.length == sellingAmount.length, \"PARAM_NOT_INVALID\");\n        for (uint256 i = 0; i < sellingTimeIntervals.length - 1; i++) {\n            require(sellingTimeIntervals[i] < sellingTimeIntervals[i + 1], \"INTERVAL_INVALID\");\n            require(sellingPrice[i] != 0, \"PRICE_INVALID\");\n        }\n        _SELLING_TIME_INTERVAL_ = sellingTimeIntervals;\n        _SELLING_PRICE_SET_ = sellingPrice;\n        _SELLING_AMOUNT_SET_ = sellingAmount;\n        emit SetSellingInfo();\n    }\n\n\n    function _setProbInfo(uint256[] memory probIntervals,uint256[][] memory tokenIdMap) internal {\n        require(_IS_PROB_MODE_, \"ONLY_ALLOW_PROB_MODE\");\n        require(probIntervals.length > 0, \"PARAM_NOT_INVALID\");\n        require(tokenIdMap.length == probIntervals.length, \"PARAM_NOT_INVALID\");\n\n        require(tokenIdMap[0].length > 0, \"INVALID\");\n        for (uint256 i = 1; i < probIntervals.length; i++) {\n            require(probIntervals[i] > probIntervals[i - 1], \"INTERVAL_INVALID\");\n            require(tokenIdMap[i].length > 0, \"INVALID\");\n        }\n        _PROB_INTERVAL_ = probIntervals;\n        _TOKEN_ID_MAP_ = tokenIdMap;\n        emit SetProbInfo();\n    }\n\n    function _setFixedAmountInfo(uint256[] memory tokenIdList) internal {\n        require(!_IS_PROB_MODE_, \"ONLY_ALLOW_FIXED_AMOUNT_MODE\");\n        require(tokenIdList.length > 0, \"PARAM_NOT_INVALID\");\n        _TOKEN_ID_LIST_ = tokenIdList;\n        emit SetFixedAmountInfo();\n    }\n\n    // ================= Owner ===================\n\n    function withdraw() external onlyOwner {\n        uint256 amount = IERC20(_BUY_TOKEN_).universalBalanceOf(address(this));\n        IERC20(_BUY_TOKEN_).universalTransfer(msg.sender ,amount);\n        emit Withdraw(msg.sender, amount);\n    }\n\n    function setRevealRn() external onlyOwner {\n        require(_REVEAL_RN_ == 0, \"ALREADY_SET\");\n        _REVEAL_RN_ = uint256(keccak256(abi.encodePacked(blockhash(block.number - 1))));\n        emit SetReveal();\n    }\n    \n    function setSellingInfo(uint256[] memory sellingTimeIntervals, uint256[] memory prices, uint256[] memory amounts) external notStart() onlyOwner {\n        _setSellingInfo(sellingTimeIntervals, prices, amounts);\n    }\n\n    function setProbInfo(uint256[] memory probIntervals,uint256[][] memory tokenIdMaps) external notStart() onlyOwner {\n        _setProbInfo(probIntervals, tokenIdMaps);\n    }\n\n    function setFixedAmountInfo(uint256[] memory tokenIdList) external notStart() onlyOwner {\n        _setFixedAmountInfo(tokenIdList);\n    }\n\n    function addFixedAmountInfo(uint256[] memory addTokenIdList) external notStart() onlyOwner {\n        for (uint256 i = 0; i < addTokenIdList.length; i++) {\n            _TOKEN_ID_LIST_.push(addTokenIdList[i]);\n        }\n        emit SetFixedAmountInfo();\n    }\n\n    function setTokenIdMapByIndex(uint256 index, uint256[] memory tokenIds) external notStart() onlyOwner {\n        require(_IS_PROB_MODE_, \"ONLY_ALLOW_PROB_MODE\");\n        require(tokenIds.length > 0 && index < _TOKEN_ID_MAP_.length,\"PARAM_NOT_INVALID\");\n        _TOKEN_ID_MAP_[index] = tokenIds;\n        emit SetTokenIdMapByIndex(index);\n    }\n    \n    function updateRNG(address newRNG) external onlyOwner {\n        require(newRNG != address(0));\n        _RNG_ = newRNG;\n        emit ChangeRNG(newRNG);\n    }\n\n    function updateTicketUnit(uint256 newTicketUnit) external onlyOwner {\n        require(newTicketUnit != 0);\n        _TICKET_UNIT_ = newTicketUnit;\n        emit ChangeTicketUnit(newTicketUnit);\n    }\n\n    function updateRedeemTime(uint256 newRedeemTime) external onlyOwner {\n        require(newRedeemTime > block.timestamp || newRedeemTime == 0, \"PARAM_NOT_INVALID\");\n        _REDEEM_ALLOWED_TIME_ = newRedeemTime;\n        emit ChangeRedeemTime(newRedeemTime);\n    }\n\n    // ================= View ===================\n\n    function getSellingStage() public view returns (uint256 stageLen) {\n        stageLen = _SELLING_TIME_INTERVAL_.length;\n    }\n\n    function getSellingInfo() public view returns (uint256 curPrice, uint256 sellAmount, uint256 index) {\n        uint256 curBlockTime = block.timestamp;\n        if(curBlockTime >= _SELLING_TIME_INTERVAL_[0] && _SELLING_TIME_INTERVAL_[0] != 0) {\n            uint256 i;\n            for (i = 1; i < _SELLING_TIME_INTERVAL_.length; i++) {\n                if (curBlockTime <= _SELLING_TIME_INTERVAL_[i]) {\n                    break;\n                }\n            }\n            curPrice = _SELLING_PRICE_SET_[i-1];\n            sellAmount = _SELLING_AMOUNT_SET_[i-1];\n            index = i - 1;\n        }\n    }\n\n    function addressToShortString(address _addr) public pure returns (string memory) {\n        bytes32 value = bytes32(uint256(_addr));\n        bytes memory alphabet = \"0123456789abcdef\";\n\n        bytes memory str = new bytes(8);\n        for (uint256 i = 0; i < 4; i++) {\n            str[i * 2] = alphabet[uint8(value[i + 12] >> 4)];\n            str[1 + i * 2] = alphabet[uint8(value[i + 12] & 0x0f)];\n        }\n        return string(str);\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/SlowMist-DODO-MiningV3 and NFT Smart Contract Security Audit Report/contractV2-453e323af65f0a666f7d9c2dfd01b9d32ea19533/contracts/DODODrops/DODODropsV2/DODODrops.sol",
        "vulnerability": "Assertion Failure",
        "check": "FP",
        "response": "Answer: Yes\nDescription: The use of `assert` statements is missing in the provided code segment, which may result in unhandled edge cases where invalid conditions go unchecked."
    },
    {
        "code_segment": "contract DODODrops is InitializableMintableERC20, ReentrancyGuard {\n    using SafeMath for uint256;\n    using Address for address;\n    using UniversalERC20 for IERC20;\n\n    // ============ Storage ============\n    address constant _BASE_COIN_ = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    \n    address public _BUY_TOKEN_;\n    uint256 public _BUY_TOKEN_RESERVE_;\n    address public _FEE_MODEL_;\n    address payable public _MAINTAINER_;\n    address public _NFT_TOKEN_;\n\n    uint256 public _TICKET_UNIT_ = 1; // ticket consumed in a single lottery\n    \n    uint256 [] public _SELLING_TIME_INTERVAL_;\n    uint256 [] public _SELLING_PRICE_SET_;\n    uint256 [] public _SELLING_AMOUNT_SET_;\n    uint256 public _REDEEM_ALLOWED_TIME_;\n\n    uint256[] public _PROB_INTERVAL_; // index => Interval probability (Only For ProbMode)  \n    uint256[][] public _TOKEN_ID_MAP_; // Interval index => tokenIds (Only For ProbMode)\n    \n    uint256[] public _TOKEN_ID_LIST_; //index => tokenId (Only For FixedAmount mode)\n\n    bool public _IS_PROB_MODE_; // false = FixedAmount mode,  true = ProbMode\n    bool public _IS_REVEAL_MODE_;\n    uint256 public _REVEAL_RN_ = 0; \n    address public _RNG_;\n\n    fallback() external payable {}\n\n    receive() external payable {}\n\n    // ============ Modifiers ============\n\n    modifier notStart() {\n        require(block.timestamp < _SELLING_TIME_INTERVAL_[0] || _SELLING_TIME_INTERVAL_[0]  == 0, \"ALREADY_START\");\n        _;\n    }\n\n    // ============ Event =============\n    event BuyTicket(address account, uint256 payAmount, uint256 feeAmount, uint256 ticketAmount);\n    event RedeemPrize(address account, uint256 tokenId, address referer);\n\n    event ChangeRNG(address rng);\n    event ChangeRedeemTime(uint256 redeemTime);\n    event ChangeTicketUnit(uint256 newTicketUnit);\n    event Withdraw(address account, uint256 amount);\n    event SetReveal();\n\n    event SetSellingInfo();\n    event SetProbInfo(); // only for ProbMode\n    event SetTokenIdMapByIndex(uint256 index); // only for ProbMode\n    event SetFixedAmountInfo(); // only for FixedAmount mode\n\n\n    function init(\n        address[] memory addrList, //0 owner, 1 buyToken, 2 feeModel, 3 defaultMaintainer 4 rng 5 nftToken\n        uint256[] memory sellingTimeInterval,\n        uint256[] memory sellingPrice,\n        uint256[] memory sellingAmount,\n        uint256 redeemAllowedTime,\n        bool isRevealMode,\n        bool isProbMode\n    ) public {\n        _BUY_TOKEN_ = addrList[1];\n        _FEE_MODEL_ = addrList[2];\n        _MAINTAINER_ = payable(addrList[3]);\n        _RNG_ = addrList[4];\n        _NFT_TOKEN_ = addrList[5];\n\n        _IS_REVEAL_MODE_ = isRevealMode;\n        _IS_PROB_MODE_ = isProbMode;\n        _REDEEM_ALLOWED_TIME_ = redeemAllowedTime;\n\n        if(sellingTimeInterval.length > 0) _setSellingInfo(sellingTimeInterval, sellingPrice, sellingAmount);\n        \n        string memory prefix = \"DROPS_\";\n        name = string(abi.encodePacked(prefix, addressToShortString(address(this))));\n        symbol = name;\n        decimals = 0;\n\n        //init Owner\n        super.init(addrList[0], 0, name, symbol, decimals);\n    }\n\n    function buyTickets(address ticketTo, uint256 ticketAmount) payable external preventReentrant {\n        (uint256 curPrice, uint256 sellAmount, uint256 index) = getSellingInfo();\n        require(curPrice > 0 && sellAmount > 0, \"CAN_NOT_BUY\");\n        require(ticketAmount <= sellAmount, \"TICKETS_NOT_ENOUGH\");\n        (uint256 payAmount, uint256 feeAmount) = IDropsFeeModel(_FEE_MODEL_).getPayAmount(address(this), ticketTo, curPrice, ticketAmount);\n        require(payAmount > 0, \"UnQualified\");\n\n        uint256 baseBalance = IERC20(_BUY_TOKEN_).universalBalanceOf(address(this));\n        uint256 buyInput = baseBalance.sub(_BUY_TOKEN_RESERVE_);\n\n        require(payAmount <= buyInput, \"PAY_AMOUNT_NOT_ENOUGH\");\n\n        _SELLING_AMOUNT_SET_[index] = sellAmount.sub(ticketAmount);\n        _BUY_TOKEN_RESERVE_ = baseBalance.sub(feeAmount);\n\n        IERC20(_BUY_TOKEN_).universalTransfer(_MAINTAINER_,feeAmount);\n        _mint(ticketTo, ticketAmount);\n        emit BuyTicket(ticketTo, payAmount, feeAmount, ticketAmount);\n    }\n\n    function redeemTicket(uint256 ticketNum, address referer) external {\n        require(!address(msg.sender).isContract(), \"ONLY_ALLOW_EOA\");\n        require(ticketNum >= 1 && ticketNum <= balanceOf(msg.sender), \"TICKET_NUM_INVALID\");\n        _burn(msg.sender,ticketNum);\n        for (uint256 i = 0; i < ticketNum; i++) {\n            _redeemSinglePrize(msg.sender, i, referer);\n        }\n    }\n\n    // ============ Internal  ============\n    // SWC-120-Weak Sources of Randomness from Chain Attributes: L156\n    function _redeemSinglePrize(address to, uint256 curNo, address referer) internal {\n        require(block.timestamp >= _REDEEM_ALLOWED_TIME_ && _REDEEM_ALLOWED_TIME_ != 0, \"REDEEM_CLOSE\");\n        uint256 range;\n        if(_IS_PROB_MODE_) {\n            range = _PROB_INTERVAL_[_PROB_INTERVAL_.length - 1];\n        }else {\n            range = _TOKEN_ID_LIST_.length;\n        }\n        uint256 random;\n        if(_IS_REVEAL_MODE_) {\n            require(_REVEAL_RN_ != 0, \"REVEAL_NOT_SET\");\n            random = uint256(keccak256(abi.encodePacked(_REVEAL_RN_, msg.sender, balanceOf(msg.sender).add(curNo + 1)))) % range;\n        }else {\n            random = IRandomGenerator(_RNG_).random(gasleft() + block.number) % range; \n        }\n        uint256 tokenId;\n        if(_IS_PROB_MODE_) {\n            uint256 i;\n            for (i = 0; i < _PROB_INTERVAL_.length; i++) {\n                if (random <= _PROB_INTERVAL_[i]) {\n                    break;\n                }\n            }\n            require(_TOKEN_ID_MAP_[i].length > 0, \"EMPTY_TOKEN_ID_MAP\");\n            tokenId = _TOKEN_ID_MAP_[i][random % _TOKEN_ID_MAP_[i].length];\n            IDropsNft(_NFT_TOKEN_).mint(to, tokenId, 1, \"\");\n        } else {\n            tokenId = _TOKEN_ID_LIST_[random];\n            if(random != range - 1) {\n                _TOKEN_ID_LIST_[random] = _TOKEN_ID_LIST_[range - 1];\n            }\n            _TOKEN_ID_LIST_.pop();\n            IDropsNft(_NFT_TOKEN_).mint(to, tokenId);  \n        }\n        emit RedeemPrize(to, tokenId, referer);\n    }\n\n\n    function _setSellingInfo(uint256[] memory sellingTimeIntervals, uint256[] memory sellingPrice, uint256[] memory sellingAmount) internal {\n        require(sellingTimeIntervals.length > 0, \"PARAM_NOT_INVALID\");\n        require(sellingTimeIntervals.length == sellingPrice.length && sellingPrice.length == sellingAmount.length, \"PARAM_NOT_INVALID\");\n        for (uint256 i = 0; i < sellingTimeIntervals.length - 1; i++) {\n            require(sellingTimeIntervals[i] < sellingTimeIntervals[i + 1], \"INTERVAL_INVALID\");\n            require(sellingPrice[i] != 0, \"PRICE_INVALID\");\n        }\n        _SELLING_TIME_INTERVAL_ = sellingTimeIntervals;\n        _SELLING_PRICE_SET_ = sellingPrice;\n        _SELLING_AMOUNT_SET_ = sellingAmount;\n        emit SetSellingInfo();\n    }\n\n\n    function _setProbInfo(uint256[] memory probIntervals,uint256[][] memory tokenIdMap) internal {\n        require(_IS_PROB_MODE_, \"ONLY_ALLOW_PROB_MODE\");\n        require(probIntervals.length > 0, \"PARAM_NOT_INVALID\");\n        require(tokenIdMap.length == probIntervals.length, \"PARAM_NOT_INVALID\");\n\n        require(tokenIdMap[0].length > 0, \"INVALID\");\n        for (uint256 i = 1; i < probIntervals.length; i++) {\n            require(probIntervals[i] > probIntervals[i - 1], \"INTERVAL_INVALID\");\n            require(tokenIdMap[i].length > 0, \"INVALID\");\n        }\n        _PROB_INTERVAL_ = probIntervals;\n        _TOKEN_ID_MAP_ = tokenIdMap;\n        emit SetProbInfo();\n    }\n\n    function _setFixedAmountInfo(uint256[] memory tokenIdList) internal {\n        require(!_IS_PROB_MODE_, \"ONLY_ALLOW_FIXED_AMOUNT_MODE\");\n        require(tokenIdList.length > 0, \"PARAM_NOT_INVALID\");\n        _TOKEN_ID_LIST_ = tokenIdList;\n        emit SetFixedAmountInfo();\n    }\n\n    // ================= Owner ===================\n\n    function withdraw() external onlyOwner {\n        uint256 amount = IERC20(_BUY_TOKEN_).universalBalanceOf(address(this));\n        IERC20(_BUY_TOKEN_).universalTransfer(msg.sender ,amount);\n        emit Withdraw(msg.sender, amount);\n    }\n\n    function setRevealRn() external onlyOwner {\n        require(_REVEAL_RN_ == 0, \"ALREADY_SET\");\n        _REVEAL_RN_ = uint256(keccak256(abi.encodePacked(blockhash(block.number - 1))));\n        emit SetReveal();\n    }\n    \n    function setSellingInfo(uint256[] memory sellingTimeIntervals, uint256[] memory prices, uint256[] memory amounts) external notStart() onlyOwner {\n        _setSellingInfo(sellingTimeIntervals, prices, amounts);\n    }\n\n    function setProbInfo(uint256[] memory probIntervals,uint256[][] memory tokenIdMaps) external notStart() onlyOwner {\n        _setProbInfo(probIntervals, tokenIdMaps);\n    }\n\n    function setFixedAmountInfo(uint256[] memory tokenIdList) external notStart() onlyOwner {\n        _setFixedAmountInfo(tokenIdList);\n    }\n\n    function addFixedAmountInfo(uint256[] memory addTokenIdList) external notStart() onlyOwner {\n        for (uint256 i = 0; i < addTokenIdList.length; i++) {\n            _TOKEN_ID_LIST_.push(addTokenIdList[i]);\n        }\n        emit SetFixedAmountInfo();\n    }\n\n    function setTokenIdMapByIndex(uint256 index, uint256[] memory tokenIds) external notStart() onlyOwner {\n        require(_IS_PROB_MODE_, \"ONLY_ALLOW_PROB_MODE\");\n        require(tokenIds.length > 0 && index < _TOKEN_ID_MAP_.length,\"PARAM_NOT_INVALID\");\n        _TOKEN_ID_MAP_[index] = tokenIds;\n        emit SetTokenIdMapByIndex(index);\n    }\n    \n    function updateRNG(address newRNG) external onlyOwner {\n        require(newRNG != address(0));\n        _RNG_ = newRNG;\n        emit ChangeRNG(newRNG);\n    }\n\n    function updateTicketUnit(uint256 newTicketUnit) external onlyOwner {\n        require(newTicketUnit != 0);\n        _TICKET_UNIT_ = newTicketUnit;\n        emit ChangeTicketUnit(newTicketUnit);\n    }\n\n    function updateRedeemTime(uint256 newRedeemTime) external onlyOwner {\n        require(newRedeemTime > block.timestamp || newRedeemTime == 0, \"PARAM_NOT_INVALID\");\n        _REDEEM_ALLOWED_TIME_ = newRedeemTime;\n        emit ChangeRedeemTime(newRedeemTime);\n    }\n\n    // ================= View ===================\n\n    function getSellingStage() public view returns (uint256 stageLen) {\n        stageLen = _SELLING_TIME_INTERVAL_.length;\n    }\n\n    function getSellingInfo() public view returns (uint256 curPrice, uint256 sellAmount, uint256 index) {\n        uint256 curBlockTime = block.timestamp;\n        if(curBlockTime >= _SELLING_TIME_INTERVAL_[0] && _SELLING_TIME_INTERVAL_[0] != 0) {\n            uint256 i;\n            for (i = 1; i < _SELLING_TIME_INTERVAL_.length; i++) {\n                if (curBlockTime <= _SELLING_TIME_INTERVAL_[i]) {\n                    break;\n                }\n            }\n            curPrice = _SELLING_PRICE_SET_[i-1];\n            sellAmount = _SELLING_AMOUNT_SET_[i-1];\n            index = i - 1;\n        }\n    }\n\n    function addressToShortString(address _addr) public pure returns (string memory) {\n        bytes32 value = bytes32(uint256(_addr));\n        bytes memory alphabet = \"0123456789abcdef\";\n\n        bytes memory str = new bytes(8);\n        for (uint256 i = 0; i < 4; i++) {\n            str[i * 2] = alphabet[uint8(value[i + 12] >> 4)];\n            str[1 + i * 2] = alphabet[uint8(value[i + 12] & 0x0f)];\n        }\n        return string(str);\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/SlowMist-DODO-MiningV3 and NFT Smart Contract Security Audit Report/contractV2-453e323af65f0a666f7d9c2dfd01b9d32ea19533/contracts/DODODrops/DODODropsV2/DODODrops.sol",
        "vulnerability": "Assertion Failure",
        "check": "FP",
        "response": "Answer: Yes  \nDescription: Potential assertion failures can occur due to unchecked array access in `_SELLING_TIME_INTERVAL_`, `_SELLING_AMOUNT_SET_`, `_PROB_INTERVAL_`, and `_TOKEN_ID_MAP_` which can lead to out-of-bound errors if the arrays are not properly initialized or managed."
    },
    {
        "code_segment": "contract DODODrops is InitializableMintableERC20, ReentrancyGuard {\n    using SafeMath for uint256;\n    using Address for address;\n    using UniversalERC20 for IERC20;\n\n    // ============ Storage ============\n    address constant _BASE_COIN_ = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    \n    address public _BUY_TOKEN_;\n    uint256 public _BUY_TOKEN_RESERVE_;\n    address public _FEE_MODEL_;\n    address payable public _MAINTAINER_;\n    address public _NFT_TOKEN_;\n\n    uint256 public _TICKET_UNIT_ = 1; // ticket consumed in a single lottery\n    \n    uint256 [] public _SELLING_TIME_INTERVAL_;\n    uint256 [] public _SELLING_PRICE_SET_;\n    uint256 [] public _SELLING_AMOUNT_SET_;\n    uint256 public _REDEEM_ALLOWED_TIME_;\n\n    uint256[] public _PROB_INTERVAL_; // index => Interval probability (Only For ProbMode)  \n    uint256[][] public _TOKEN_ID_MAP_; // Interval index => tokenIds (Only For ProbMode)\n    \n    uint256[] public _TOKEN_ID_LIST_; //index => tokenId (Only For FixedAmount mode)\n\n    bool public _IS_PROB_MODE_; // false = FixedAmount mode,  true = ProbMode\n    bool public _IS_REVEAL_MODE_;\n    uint256 public _REVEAL_RN_ = 0; \n    address public _RNG_;\n\n    fallback() external payable {}\n\n    receive() external payable {}\n\n    // ============ Modifiers ============\n\n    modifier notStart() {\n        require(block.timestamp < _SELLING_TIME_INTERVAL_[0] || _SELLING_TIME_INTERVAL_[0]  == 0, \"ALREADY_START\");\n        _;\n    }\n\n    // ============ Event =============\n    event BuyTicket(address account, uint256 payAmount, uint256 feeAmount, uint256 ticketAmount);\n    event RedeemPrize(address account, uint256 tokenId, address referer);\n\n    event ChangeRNG(address rng);\n    event ChangeRedeemTime(uint256 redeemTime);\n    event ChangeTicketUnit(uint256 newTicketUnit);\n    event Withdraw(address account, uint256 amount);\n    event SetReveal();\n\n    event SetSellingInfo();\n    event SetProbInfo(); // only for ProbMode\n    event SetTokenIdMapByIndex(uint256 index); // only for ProbMode\n    event SetFixedAmountInfo(); // only for FixedAmount mode\n\n\n    function init(\n        address[] memory addrList, //0 owner, 1 buyToken, 2 feeModel, 3 defaultMaintainer 4 rng 5 nftToken\n        uint256[] memory sellingTimeInterval,\n        uint256[] memory sellingPrice,\n        uint256[] memory sellingAmount,\n        uint256 redeemAllowedTime,\n        bool isRevealMode,\n        bool isProbMode\n    ) public {\n        _BUY_TOKEN_ = addrList[1];\n        _FEE_MODEL_ = addrList[2];\n        _MAINTAINER_ = payable(addrList[3]);\n        _RNG_ = addrList[4];\n        _NFT_TOKEN_ = addrList[5];\n\n        _IS_REVEAL_MODE_ = isRevealMode;\n        _IS_PROB_MODE_ = isProbMode;\n        _REDEEM_ALLOWED_TIME_ = redeemAllowedTime;\n\n        if(sellingTimeInterval.length > 0) _setSellingInfo(sellingTimeInterval, sellingPrice, sellingAmount);\n        \n        string memory prefix = \"DROPS_\";\n        name = string(abi.encodePacked(prefix, addressToShortString(address(this))));\n        symbol = name;\n        decimals = 0;\n\n        //init Owner\n        super.init(addrList[0], 0, name, symbol, decimals);\n    }\n\n    function buyTickets(address ticketTo, uint256 ticketAmount) payable external preventReentrant {\n        (uint256 curPrice, uint256 sellAmount, uint256 index) = getSellingInfo();\n        require(curPrice > 0 && sellAmount > 0, \"CAN_NOT_BUY\");\n        require(ticketAmount <= sellAmount, \"TICKETS_NOT_ENOUGH\");\n        (uint256 payAmount, uint256 feeAmount) = IDropsFeeModel(_FEE_MODEL_).getPayAmount(address(this), ticketTo, curPrice, ticketAmount);\n        require(payAmount > 0, \"UnQualified\");\n\n        uint256 baseBalance = IERC20(_BUY_TOKEN_).universalBalanceOf(address(this));\n        uint256 buyInput = baseBalance.sub(_BUY_TOKEN_RESERVE_);\n\n        require(payAmount <= buyInput, \"PAY_AMOUNT_NOT_ENOUGH\");\n\n        _SELLING_AMOUNT_SET_[index] = sellAmount.sub(ticketAmount);\n        _BUY_TOKEN_RESERVE_ = baseBalance.sub(feeAmount);\n\n        IERC20(_BUY_TOKEN_).universalTransfer(_MAINTAINER_,feeAmount);\n        _mint(ticketTo, ticketAmount);\n        emit BuyTicket(ticketTo, payAmount, feeAmount, ticketAmount);\n    }\n\n    function redeemTicket(uint256 ticketNum, address referer) external {\n        require(!address(msg.sender).isContract(), \"ONLY_ALLOW_EOA\");\n        require(ticketNum >= 1 && ticketNum <= balanceOf(msg.sender), \"TICKET_NUM_INVALID\");\n        _burn(msg.sender,ticketNum);\n        for (uint256 i = 0; i < ticketNum; i++) {\n            _redeemSinglePrize(msg.sender, i, referer);\n        }\n    }\n\n    // ============ Internal  ============\n    // SWC-120-Weak Sources of Randomness from Chain Attributes: L156\n    function _redeemSinglePrize(address to, uint256 curNo, address referer) internal {\n        require(block.timestamp >= _REDEEM_ALLOWED_TIME_ && _REDEEM_ALLOWED_TIME_ != 0, \"REDEEM_CLOSE\");\n        uint256 range;\n        if(_IS_PROB_MODE_) {\n            range = _PROB_INTERVAL_[_PROB_INTERVAL_.length - 1];\n        }else {\n            range = _TOKEN_ID_LIST_.length;\n        }\n        uint256 random;\n        if(_IS_REVEAL_MODE_) {\n            require(_REVEAL_RN_ != 0, \"REVEAL_NOT_SET\");\n            random = uint256(keccak256(abi.encodePacked(_REVEAL_RN_, msg.sender, balanceOf(msg.sender).add(curNo + 1)))) % range;\n        }else {\n            random = IRandomGenerator(_RNG_).random(gasleft() + block.number) % range; \n        }\n        uint256 tokenId;\n        if(_IS_PROB_MODE_) {\n            uint256 i;\n            for (i = 0; i < _PROB_INTERVAL_.length; i++) {\n                if (random <= _PROB_INTERVAL_[i]) {\n                    break;\n                }\n            }\n            require(_TOKEN_ID_MAP_[i].length > 0, \"EMPTY_TOKEN_ID_MAP\");\n            tokenId = _TOKEN_ID_MAP_[i][random % _TOKEN_ID_MAP_[i].length];\n            IDropsNft(_NFT_TOKEN_).mint(to, tokenId, 1, \"\");\n        } else {\n            tokenId = _TOKEN_ID_LIST_[random];\n            if(random != range - 1) {\n                _TOKEN_ID_LIST_[random] = _TOKEN_ID_LIST_[range - 1];\n            }\n            _TOKEN_ID_LIST_.pop();\n            IDropsNft(_NFT_TOKEN_).mint(to, tokenId);  \n        }\n        emit RedeemPrize(to, tokenId, referer);\n    }\n\n\n    function _setSellingInfo(uint256[] memory sellingTimeIntervals, uint256[] memory sellingPrice, uint256[] memory sellingAmount) internal {\n        require(sellingTimeIntervals.length > 0, \"PARAM_NOT_INVALID\");\n        require(sellingTimeIntervals.length == sellingPrice.length && sellingPrice.length == sellingAmount.length, \"PARAM_NOT_INVALID\");\n        for (uint256 i = 0; i < sellingTimeIntervals.length - 1; i++) {\n            require(sellingTimeIntervals[i] < sellingTimeIntervals[i + 1], \"INTERVAL_INVALID\");\n            require(sellingPrice[i] != 0, \"PRICE_INVALID\");\n        }\n        _SELLING_TIME_INTERVAL_ = sellingTimeIntervals;\n        _SELLING_PRICE_SET_ = sellingPrice;\n        _SELLING_AMOUNT_SET_ = sellingAmount;\n        emit SetSellingInfo();\n    }\n\n\n    function _setProbInfo(uint256[] memory probIntervals,uint256[][] memory tokenIdMap) internal {\n        require(_IS_PROB_MODE_, \"ONLY_ALLOW_PROB_MODE\");\n        require(probIntervals.length > 0, \"PARAM_NOT_INVALID\");\n        require(tokenIdMap.length == probIntervals.length, \"PARAM_NOT_INVALID\");\n\n        require(tokenIdMap[0].length > 0, \"INVALID\");\n        for (uint256 i = 1; i < probIntervals.length; i++) {\n            require(probIntervals[i] > probIntervals[i - 1], \"INTERVAL_INVALID\");\n            require(tokenIdMap[i].length > 0, \"INVALID\");\n        }\n        _PROB_INTERVAL_ = probIntervals;\n        _TOKEN_ID_MAP_ = tokenIdMap;\n        emit SetProbInfo();\n    }\n\n    function _setFixedAmountInfo(uint256[] memory tokenIdList) internal {\n        require(!_IS_PROB_MODE_, \"ONLY_ALLOW_FIXED_AMOUNT_MODE\");\n        require(tokenIdList.length > 0, \"PARAM_NOT_INVALID\");\n        _TOKEN_ID_LIST_ = tokenIdList;\n        emit SetFixedAmountInfo();\n    }\n\n    // ================= Owner ===================\n\n    function withdraw() external onlyOwner {\n        uint256 amount = IERC20(_BUY_TOKEN_).universalBalanceOf(address(this));\n        IERC20(_BUY_TOKEN_).universalTransfer(msg.sender ,amount);\n        emit Withdraw(msg.sender, amount);\n    }\n\n    function setRevealRn() external onlyOwner {\n        require(_REVEAL_RN_ == 0, \"ALREADY_SET\");\n        _REVEAL_RN_ = uint256(keccak256(abi.encodePacked(blockhash(block.number - 1))));\n        emit SetReveal();\n    }\n    \n    function setSellingInfo(uint256[] memory sellingTimeIntervals, uint256[] memory prices, uint256[] memory amounts) external notStart() onlyOwner {\n        _setSellingInfo(sellingTimeIntervals, prices, amounts);\n    }\n\n    function setProbInfo(uint256[] memory probIntervals,uint256[][] memory tokenIdMaps) external notStart() onlyOwner {\n        _setProbInfo(probIntervals, tokenIdMaps);\n    }\n\n    function setFixedAmountInfo(uint256[] memory tokenIdList) external notStart() onlyOwner {\n        _setFixedAmountInfo(tokenIdList);\n    }\n\n    function addFixedAmountInfo(uint256[] memory addTokenIdList) external notStart() onlyOwner {\n        for (uint256 i = 0; i < addTokenIdList.length; i++) {\n            _TOKEN_ID_LIST_.push(addTokenIdList[i]);\n        }\n        emit SetFixedAmountInfo();\n    }\n\n    function setTokenIdMapByIndex(uint256 index, uint256[] memory tokenIds) external notStart() onlyOwner {\n        require(_IS_PROB_MODE_, \"ONLY_ALLOW_PROB_MODE\");\n        require(tokenIds.length > 0 && index < _TOKEN_ID_MAP_.length,\"PARAM_NOT_INVALID\");\n        _TOKEN_ID_MAP_[index] = tokenIds;\n        emit SetTokenIdMapByIndex(index);\n    }\n    \n    function updateRNG(address newRNG) external onlyOwner {\n        require(newRNG != address(0));\n        _RNG_ = newRNG;\n        emit ChangeRNG(newRNG);\n    }\n\n    function updateTicketUnit(uint256 newTicketUnit) external onlyOwner {\n        require(newTicketUnit != 0);\n        _TICKET_UNIT_ = newTicketUnit;\n        emit ChangeTicketUnit(newTicketUnit);\n    }\n\n    function updateRedeemTime(uint256 newRedeemTime) external onlyOwner {\n        require(newRedeemTime > block.timestamp || newRedeemTime == 0, \"PARAM_NOT_INVALID\");\n        _REDEEM_ALLOWED_TIME_ = newRedeemTime;\n        emit ChangeRedeemTime(newRedeemTime);\n    }\n\n    // ================= View ===================\n\n    function getSellingStage() public view returns (uint256 stageLen) {\n        stageLen = _SELLING_TIME_INTERVAL_.length;\n    }\n\n    function getSellingInfo() public view returns (uint256 curPrice, uint256 sellAmount, uint256 index) {\n        uint256 curBlockTime = block.timestamp;\n        if(curBlockTime >= _SELLING_TIME_INTERVAL_[0] && _SELLING_TIME_INTERVAL_[0] != 0) {\n            uint256 i;\n            for (i = 1; i < _SELLING_TIME_INTERVAL_.length; i++) {\n                if (curBlockTime <= _SELLING_TIME_INTERVAL_[i]) {\n                    break;\n                }\n            }\n            curPrice = _SELLING_PRICE_SET_[i-1];\n            sellAmount = _SELLING_AMOUNT_SET_[i-1];\n            index = i - 1;\n        }\n    }\n\n    function addressToShortString(address _addr) public pure returns (string memory) {\n        bytes32 value = bytes32(uint256(_addr));\n        bytes memory alphabet = \"0123456789abcdef\";\n\n        bytes memory str = new bytes(8);\n        for (uint256 i = 0; i < 4; i++) {\n            str[i * 2] = alphabet[uint8(value[i + 12] >> 4)];\n            str[1 + i * 2] = alphabet[uint8(value[i + 12] & 0x0f)];\n        }\n        return string(str);\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/SlowMist-DODO-MiningV3 and NFT Smart Contract Security Audit Report/contractV2-453e323af65f0a666f7d9c2dfd01b9d32ea19533/contracts/DODODrops/DODODropsV2/DODODrops.sol",
        "vulnerability": "Assertion Failure",
        "check": "FP",
        "response": "Answer: No\nReason: No assert statements are present in the code."
    },
    {
        "code_segment": "contract DODODrops is InitializableMintableERC20, ReentrancyGuard {\n    using SafeMath for uint256;\n    using Address for address;\n    using UniversalERC20 for IERC20;\n\n    // ============ Storage ============\n    address constant _BASE_COIN_ = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    \n    address public _BUY_TOKEN_;\n    uint256 public _BUY_TOKEN_RESERVE_;\n    address public _FEE_MODEL_;\n    address payable public _MAINTAINER_;\n    address public _NFT_TOKEN_;\n\n    uint256 public _TICKET_UNIT_ = 1; // ticket consumed in a single lottery\n    \n    uint256 [] public _SELLING_TIME_INTERVAL_;\n    uint256 [] public _SELLING_PRICE_SET_;\n    uint256 [] public _SELLING_AMOUNT_SET_;\n    uint256 public _REDEEM_ALLOWED_TIME_;\n\n    uint256[] public _PROB_INTERVAL_; // index => Interval probability (Only For ProbMode)  \n    uint256[][] public _TOKEN_ID_MAP_; // Interval index => tokenIds (Only For ProbMode)\n    \n    uint256[] public _TOKEN_ID_LIST_; //index => tokenId (Only For FixedAmount mode)\n\n    bool public _IS_PROB_MODE_; // false = FixedAmount mode,  true = ProbMode\n    bool public _IS_REVEAL_MODE_;\n    uint256 public _REVEAL_RN_ = 0; \n    address public _RNG_;\n\n    fallback() external payable {}\n\n    receive() external payable {}\n\n    // ============ Modifiers ============\n\n    modifier notStart() {\n        require(block.timestamp < _SELLING_TIME_INTERVAL_[0] || _SELLING_TIME_INTERVAL_[0]  == 0, \"ALREADY_START\");\n        _;\n    }\n\n    // ============ Event =============\n    event BuyTicket(address account, uint256 payAmount, uint256 feeAmount, uint256 ticketAmount);\n    event RedeemPrize(address account, uint256 tokenId, address referer);\n\n    event ChangeRNG(address rng);\n    event ChangeRedeemTime(uint256 redeemTime);\n    event ChangeTicketUnit(uint256 newTicketUnit);\n    event Withdraw(address account, uint256 amount);\n    event SetReveal();\n\n    event SetSellingInfo();\n    event SetProbInfo(); // only for ProbMode\n    event SetTokenIdMapByIndex(uint256 index); // only for ProbMode\n    event SetFixedAmountInfo(); // only for FixedAmount mode\n\n\n    function init(\n        address[] memory addrList, //0 owner, 1 buyToken, 2 feeModel, 3 defaultMaintainer 4 rng 5 nftToken\n        uint256[] memory sellingTimeInterval,\n        uint256[] memory sellingPrice,\n        uint256[] memory sellingAmount,\n        uint256 redeemAllowedTime,\n        bool isRevealMode,\n        bool isProbMode\n    ) public {\n        _BUY_TOKEN_ = addrList[1];\n        _FEE_MODEL_ = addrList[2];\n        _MAINTAINER_ = payable(addrList[3]);\n        _RNG_ = addrList[4];\n        _NFT_TOKEN_ = addrList[5];\n\n        _IS_REVEAL_MODE_ = isRevealMode;\n        _IS_PROB_MODE_ = isProbMode;\n        _REDEEM_ALLOWED_TIME_ = redeemAllowedTime;\n\n        if(sellingTimeInterval.length > 0) _setSellingInfo(sellingTimeInterval, sellingPrice, sellingAmount);\n        \n        string memory prefix = \"DROPS_\";\n        name = string(abi.encodePacked(prefix, addressToShortString(address(this))));\n        symbol = name;\n        decimals = 0;\n\n        //init Owner\n        super.init(addrList[0], 0, name, symbol, decimals);\n    }\n\n    function buyTickets(address ticketTo, uint256 ticketAmount) payable external preventReentrant {\n        (uint256 curPrice, uint256 sellAmount, uint256 index) = getSellingInfo();\n        require(curPrice > 0 && sellAmount > 0, \"CAN_NOT_BUY\");\n        require(ticketAmount <= sellAmount, \"TICKETS_NOT_ENOUGH\");\n        (uint256 payAmount, uint256 feeAmount) = IDropsFeeModel(_FEE_MODEL_).getPayAmount(address(this), ticketTo, curPrice, ticketAmount);\n        require(payAmount > 0, \"UnQualified\");\n\n        uint256 baseBalance = IERC20(_BUY_TOKEN_).universalBalanceOf(address(this));\n        uint256 buyInput = baseBalance.sub(_BUY_TOKEN_RESERVE_);\n\n        require(payAmount <= buyInput, \"PAY_AMOUNT_NOT_ENOUGH\");\n\n        _SELLING_AMOUNT_SET_[index] = sellAmount.sub(ticketAmount);\n        _BUY_TOKEN_RESERVE_ = baseBalance.sub(feeAmount);\n\n        IERC20(_BUY_TOKEN_).universalTransfer(_MAINTAINER_,feeAmount);\n        _mint(ticketTo, ticketAmount);\n        emit BuyTicket(ticketTo, payAmount, feeAmount, ticketAmount);\n    }\n\n    function redeemTicket(uint256 ticketNum, address referer) external {\n        require(!address(msg.sender).isContract(), \"ONLY_ALLOW_EOA\");\n        require(ticketNum >= 1 && ticketNum <= balanceOf(msg.sender), \"TICKET_NUM_INVALID\");\n        _burn(msg.sender,ticketNum);\n        for (uint256 i = 0; i < ticketNum; i++) {\n            _redeemSinglePrize(msg.sender, i, referer);\n        }\n    }\n\n    // ============ Internal  ============\n    // SWC-120-Weak Sources of Randomness from Chain Attributes: L156\n    function _redeemSinglePrize(address to, uint256 curNo, address referer) internal {\n        require(block.timestamp >= _REDEEM_ALLOWED_TIME_ && _REDEEM_ALLOWED_TIME_ != 0, \"REDEEM_CLOSE\");\n        uint256 range;\n        if(_IS_PROB_MODE_) {\n            range = _PROB_INTERVAL_[_PROB_INTERVAL_.length - 1];\n        }else {\n            range = _TOKEN_ID_LIST_.length;\n        }\n        uint256 random;\n        if(_IS_REVEAL_MODE_) {\n            require(_REVEAL_RN_ != 0, \"REVEAL_NOT_SET\");\n            random = uint256(keccak256(abi.encodePacked(_REVEAL_RN_, msg.sender, balanceOf(msg.sender).add(curNo + 1)))) % range;\n        }else {\n            random = IRandomGenerator(_RNG_).random(gasleft() + block.number) % range; \n        }\n        uint256 tokenId;\n        if(_IS_PROB_MODE_) {\n            uint256 i;\n            for (i = 0; i < _PROB_INTERVAL_.length; i++) {\n                if (random <= _PROB_INTERVAL_[i]) {\n                    break;\n                }\n            }\n            require(_TOKEN_ID_MAP_[i].length > 0, \"EMPTY_TOKEN_ID_MAP\");\n            tokenId = _TOKEN_ID_MAP_[i][random % _TOKEN_ID_MAP_[i].length];\n            IDropsNft(_NFT_TOKEN_).mint(to, tokenId, 1, \"\");\n        } else {\n            tokenId = _TOKEN_ID_LIST_[random];\n            if(random != range - 1) {\n                _TOKEN_ID_LIST_[random] = _TOKEN_ID_LIST_[range - 1];\n            }\n            _TOKEN_ID_LIST_.pop();\n            IDropsNft(_NFT_TOKEN_).mint(to, tokenId);  \n        }\n        emit RedeemPrize(to, tokenId, referer);\n    }\n\n\n    function _setSellingInfo(uint256[] memory sellingTimeIntervals, uint256[] memory sellingPrice, uint256[] memory sellingAmount) internal {\n        require(sellingTimeIntervals.length > 0, \"PARAM_NOT_INVALID\");\n        require(sellingTimeIntervals.length == sellingPrice.length && sellingPrice.length == sellingAmount.length, \"PARAM_NOT_INVALID\");\n        for (uint256 i = 0; i < sellingTimeIntervals.length - 1; i++) {\n            require(sellingTimeIntervals[i] < sellingTimeIntervals[i + 1], \"INTERVAL_INVALID\");\n            require(sellingPrice[i] != 0, \"PRICE_INVALID\");\n        }\n        _SELLING_TIME_INTERVAL_ = sellingTimeIntervals;\n        _SELLING_PRICE_SET_ = sellingPrice;\n        _SELLING_AMOUNT_SET_ = sellingAmount;\n        emit SetSellingInfo();\n    }\n\n\n    function _setProbInfo(uint256[] memory probIntervals,uint256[][] memory tokenIdMap) internal {\n        require(_IS_PROB_MODE_, \"ONLY_ALLOW_PROB_MODE\");\n        require(probIntervals.length > 0, \"PARAM_NOT_INVALID\");\n        require(tokenIdMap.length == probIntervals.length, \"PARAM_NOT_INVALID\");\n\n        require(tokenIdMap[0].length > 0, \"INVALID\");\n        for (uint256 i = 1; i < probIntervals.length; i++) {\n            require(probIntervals[i] > probIntervals[i - 1], \"INTERVAL_INVALID\");\n            require(tokenIdMap[i].length > 0, \"INVALID\");\n        }\n        _PROB_INTERVAL_ = probIntervals;\n        _TOKEN_ID_MAP_ = tokenIdMap;\n        emit SetProbInfo();\n    }\n\n    function _setFixedAmountInfo(uint256[] memory tokenIdList) internal {\n        require(!_IS_PROB_MODE_, \"ONLY_ALLOW_FIXED_AMOUNT_MODE\");\n        require(tokenIdList.length > 0, \"PARAM_NOT_INVALID\");\n        _TOKEN_ID_LIST_ = tokenIdList;\n        emit SetFixedAmountInfo();\n    }\n\n    // ================= Owner ===================\n\n    function withdraw() external onlyOwner {\n        uint256 amount = IERC20(_BUY_TOKEN_).universalBalanceOf(address(this));\n        IERC20(_BUY_TOKEN_).universalTransfer(msg.sender ,amount);\n        emit Withdraw(msg.sender, amount);\n    }\n\n    function setRevealRn() external onlyOwner {\n        require(_REVEAL_RN_ == 0, \"ALREADY_SET\");\n        _REVEAL_RN_ = uint256(keccak256(abi.encodePacked(blockhash(block.number - 1))));\n        emit SetReveal();\n    }\n    \n    function setSellingInfo(uint256[] memory sellingTimeIntervals, uint256[] memory prices, uint256[] memory amounts) external notStart() onlyOwner {\n        _setSellingInfo(sellingTimeIntervals, prices, amounts);\n    }\n\n    function setProbInfo(uint256[] memory probIntervals,uint256[][] memory tokenIdMaps) external notStart() onlyOwner {\n        _setProbInfo(probIntervals, tokenIdMaps);\n    }\n\n    function setFixedAmountInfo(uint256[] memory tokenIdList) external notStart() onlyOwner {\n        _setFixedAmountInfo(tokenIdList);\n    }\n\n    function addFixedAmountInfo(uint256[] memory addTokenIdList) external notStart() onlyOwner {\n        for (uint256 i = 0; i < addTokenIdList.length; i++) {\n            _TOKEN_ID_LIST_.push(addTokenIdList[i]);\n        }\n        emit SetFixedAmountInfo();\n    }\n\n    function setTokenIdMapByIndex(uint256 index, uint256[] memory tokenIds) external notStart() onlyOwner {\n        require(_IS_PROB_MODE_, \"ONLY_ALLOW_PROB_MODE\");\n        require(tokenIds.length > 0 && index < _TOKEN_ID_MAP_.length,\"PARAM_NOT_INVALID\");\n        _TOKEN_ID_MAP_[index] = tokenIds;\n        emit SetTokenIdMapByIndex(index);\n    }\n    \n    function updateRNG(address newRNG) external onlyOwner {\n        require(newRNG != address(0));\n        _RNG_ = newRNG;\n        emit ChangeRNG(newRNG);\n    }\n\n    function updateTicketUnit(uint256 newTicketUnit) external onlyOwner {\n        require(newTicketUnit != 0);\n        _TICKET_UNIT_ = newTicketUnit;\n        emit ChangeTicketUnit(newTicketUnit);\n    }\n\n    function updateRedeemTime(uint256 newRedeemTime) external onlyOwner {\n        require(newRedeemTime > block.timestamp || newRedeemTime == 0, \"PARAM_NOT_INVALID\");\n        _REDEEM_ALLOWED_TIME_ = newRedeemTime;\n        emit ChangeRedeemTime(newRedeemTime);\n    }\n\n    // ================= View ===================\n\n    function getSellingStage() public view returns (uint256 stageLen) {\n        stageLen = _SELLING_TIME_INTERVAL_.length;\n    }\n\n    function getSellingInfo() public view returns (uint256 curPrice, uint256 sellAmount, uint256 index) {\n        uint256 curBlockTime = block.timestamp;\n        if(curBlockTime >= _SELLING_TIME_INTERVAL_[0] && _SELLING_TIME_INTERVAL_[0] != 0) {\n            uint256 i;\n            for (i = 1; i < _SELLING_TIME_INTERVAL_.length; i++) {\n                if (curBlockTime <= _SELLING_TIME_INTERVAL_[i]) {\n                    break;\n                }\n            }\n            curPrice = _SELLING_PRICE_SET_[i-1];\n            sellAmount = _SELLING_AMOUNT_SET_[i-1];\n            index = i - 1;\n        }\n    }\n\n    function addressToShortString(address _addr) public pure returns (string memory) {\n        bytes32 value = bytes32(uint256(_addr));\n        bytes memory alphabet = \"0123456789abcdef\";\n\n        bytes memory str = new bytes(8);\n        for (uint256 i = 0; i < 4; i++) {\n            str[i * 2] = alphabet[uint8(value[i + 12] >> 4)];\n            str[1 + i * 2] = alphabet[uint8(value[i + 12] & 0x0f)];\n        }\n        return string(str);\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/SlowMist-DODO-MiningV3 and NFT Smart Contract Security Audit Report/contractV2-453e323af65f0a666f7d9c2dfd01b9d32ea19533/contracts/DODODrops/DODODropsV2/DODODrops.sol",
        "vulnerability": "Assertion Failure",
        "check": "FP",
        "response": "Answer: Yes\nDescription: The contract uses assertions with \"require\" statements extensively; these assertions could fail due to incorrect assumptions, leading to potential vulnerabilities."
    },
    {
        "code_segment": "contract DODODrops is InitializableMintableERC20, ReentrancyGuard {\n    using SafeMath for uint256;\n    using Address for address;\n    using UniversalERC20 for IERC20;\n\n    // ============ Storage ============\n    address constant _BASE_COIN_ = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    \n    address public _BUY_TOKEN_;\n    uint256 public _BUY_TOKEN_RESERVE_;\n    address public _FEE_MODEL_;\n    address payable public _MAINTAINER_;\n    address public _NFT_TOKEN_;\n\n    uint256 public _TICKET_UNIT_ = 1; // ticket consumed in a single lottery\n    \n    uint256 [] public _SELLING_TIME_INTERVAL_;\n    uint256 [] public _SELLING_PRICE_SET_;\n    uint256 [] public _SELLING_AMOUNT_SET_;\n    uint256 public _REDEEM_ALLOWED_TIME_;\n\n    uint256[] public _PROB_INTERVAL_; // index => Interval probability (Only For ProbMode)  \n    uint256[][] public _TOKEN_ID_MAP_; // Interval index => tokenIds (Only For ProbMode)\n    \n    uint256[] public _TOKEN_ID_LIST_; //index => tokenId (Only For FixedAmount mode)\n\n    bool public _IS_PROB_MODE_; // false = FixedAmount mode,  true = ProbMode\n    bool public _IS_REVEAL_MODE_;\n    uint256 public _REVEAL_RN_ = 0; \n    address public _RNG_;\n\n    fallback() external payable {}\n\n    receive() external payable {}\n\n    // ============ Modifiers ============\n\n    modifier notStart() {\n        require(block.timestamp < _SELLING_TIME_INTERVAL_[0] || _SELLING_TIME_INTERVAL_[0]  == 0, \"ALREADY_START\");\n        _;\n    }\n\n    // ============ Event =============\n    event BuyTicket(address account, uint256 payAmount, uint256 feeAmount, uint256 ticketAmount);\n    event RedeemPrize(address account, uint256 tokenId, address referer);\n\n    event ChangeRNG(address rng);\n    event ChangeRedeemTime(uint256 redeemTime);\n    event ChangeTicketUnit(uint256 newTicketUnit);\n    event Withdraw(address account, uint256 amount);\n    event SetReveal();\n\n    event SetSellingInfo();\n    event SetProbInfo(); // only for ProbMode\n    event SetTokenIdMapByIndex(uint256 index); // only for ProbMode\n    event SetFixedAmountInfo(); // only for FixedAmount mode\n\n\n    function init(\n        address[] memory addrList, //0 owner, 1 buyToken, 2 feeModel, 3 defaultMaintainer 4 rng 5 nftToken\n        uint256[] memory sellingTimeInterval,\n        uint256[] memory sellingPrice,\n        uint256[] memory sellingAmount,\n        uint256 redeemAllowedTime,\n        bool isRevealMode,\n        bool isProbMode\n    ) public {\n        _BUY_TOKEN_ = addrList[1];\n        _FEE_MODEL_ = addrList[2];\n        _MAINTAINER_ = payable(addrList[3]);\n        _RNG_ = addrList[4];\n        _NFT_TOKEN_ = addrList[5];\n\n        _IS_REVEAL_MODE_ = isRevealMode;\n        _IS_PROB_MODE_ = isProbMode;\n        _REDEEM_ALLOWED_TIME_ = redeemAllowedTime;\n\n        if(sellingTimeInterval.length > 0) _setSellingInfo(sellingTimeInterval, sellingPrice, sellingAmount);\n        \n        string memory prefix = \"DROPS_\";\n        name = string(abi.encodePacked(prefix, addressToShortString(address(this))));\n        symbol = name;\n        decimals = 0;\n\n        //init Owner\n        super.init(addrList[0], 0, name, symbol, decimals);\n    }\n\n    function buyTickets(address ticketTo, uint256 ticketAmount) payable external preventReentrant {\n        (uint256 curPrice, uint256 sellAmount, uint256 index) = getSellingInfo();\n        require(curPrice > 0 && sellAmount > 0, \"CAN_NOT_BUY\");\n        require(ticketAmount <= sellAmount, \"TICKETS_NOT_ENOUGH\");\n        (uint256 payAmount, uint256 feeAmount) = IDropsFeeModel(_FEE_MODEL_).getPayAmount(address(this), ticketTo, curPrice, ticketAmount);\n        require(payAmount > 0, \"UnQualified\");\n\n        uint256 baseBalance = IERC20(_BUY_TOKEN_).universalBalanceOf(address(this));\n        uint256 buyInput = baseBalance.sub(_BUY_TOKEN_RESERVE_);\n\n        require(payAmount <= buyInput, \"PAY_AMOUNT_NOT_ENOUGH\");\n\n        _SELLING_AMOUNT_SET_[index] = sellAmount.sub(ticketAmount);\n        _BUY_TOKEN_RESERVE_ = baseBalance.sub(feeAmount);\n\n        IERC20(_BUY_TOKEN_).universalTransfer(_MAINTAINER_,feeAmount);\n        _mint(ticketTo, ticketAmount);\n        emit BuyTicket(ticketTo, payAmount, feeAmount, ticketAmount);\n    }\n\n    function redeemTicket(uint256 ticketNum, address referer) external {\n        require(!address(msg.sender).isContract(), \"ONLY_ALLOW_EOA\");\n        require(ticketNum >= 1 && ticketNum <= balanceOf(msg.sender), \"TICKET_NUM_INVALID\");\n        _burn(msg.sender,ticketNum);\n        for (uint256 i = 0; i < ticketNum; i++) {\n            _redeemSinglePrize(msg.sender, i, referer);\n        }\n    }\n\n    // ============ Internal  ============\n    // SWC-120-Weak Sources of Randomness from Chain Attributes: L156\n    function _redeemSinglePrize(address to, uint256 curNo, address referer) internal {\n        require(block.timestamp >= _REDEEM_ALLOWED_TIME_ && _REDEEM_ALLOWED_TIME_ != 0, \"REDEEM_CLOSE\");\n        uint256 range;\n        if(_IS_PROB_MODE_) {\n            range = _PROB_INTERVAL_[_PROB_INTERVAL_.length - 1];\n        }else {\n            range = _TOKEN_ID_LIST_.length;\n        }\n        uint256 random;\n        if(_IS_REVEAL_MODE_) {\n            require(_REVEAL_RN_ != 0, \"REVEAL_NOT_SET\");\n            random = uint256(keccak256(abi.encodePacked(_REVEAL_RN_, msg.sender, balanceOf(msg.sender).add(curNo + 1)))) % range;\n        }else {\n            random = IRandomGenerator(_RNG_).random(gasleft() + block.number) % range; \n        }\n        uint256 tokenId;\n        if(_IS_PROB_MODE_) {\n            uint256 i;\n            for (i = 0; i < _PROB_INTERVAL_.length; i++) {\n                if (random <= _PROB_INTERVAL_[i]) {\n                    break;\n                }\n            }\n            require(_TOKEN_ID_MAP_[i].length > 0, \"EMPTY_TOKEN_ID_MAP\");\n            tokenId = _TOKEN_ID_MAP_[i][random % _TOKEN_ID_MAP_[i].length];\n            IDropsNft(_NFT_TOKEN_).mint(to, tokenId, 1, \"\");\n        } else {\n            tokenId = _TOKEN_ID_LIST_[random];\n            if(random != range - 1) {\n                _TOKEN_ID_LIST_[random] = _TOKEN_ID_LIST_[range - 1];\n            }\n            _TOKEN_ID_LIST_.pop();\n            IDropsNft(_NFT_TOKEN_).mint(to, tokenId);  \n        }\n        emit RedeemPrize(to, tokenId, referer);\n    }\n\n\n    function _setSellingInfo(uint256[] memory sellingTimeIntervals, uint256[] memory sellingPrice, uint256[] memory sellingAmount) internal {\n        require(sellingTimeIntervals.length > 0, \"PARAM_NOT_INVALID\");\n        require(sellingTimeIntervals.length == sellingPrice.length && sellingPrice.length == sellingAmount.length, \"PARAM_NOT_INVALID\");\n        for (uint256 i = 0; i < sellingTimeIntervals.length - 1; i++) {\n            require(sellingTimeIntervals[i] < sellingTimeIntervals[i + 1], \"INTERVAL_INVALID\");\n            require(sellingPrice[i] != 0, \"PRICE_INVALID\");\n        }\n        _SELLING_TIME_INTERVAL_ = sellingTimeIntervals;\n        _SELLING_PRICE_SET_ = sellingPrice;\n        _SELLING_AMOUNT_SET_ = sellingAmount;\n        emit SetSellingInfo();\n    }\n\n\n    function _setProbInfo(uint256[] memory probIntervals,uint256[][] memory tokenIdMap) internal {\n        require(_IS_PROB_MODE_, \"ONLY_ALLOW_PROB_MODE\");\n        require(probIntervals.length > 0, \"PARAM_NOT_INVALID\");\n        require(tokenIdMap.length == probIntervals.length, \"PARAM_NOT_INVALID\");\n\n        require(tokenIdMap[0].length > 0, \"INVALID\");\n        for (uint256 i = 1; i < probIntervals.length; i++) {\n            require(probIntervals[i] > probIntervals[i - 1], \"INTERVAL_INVALID\");\n            require(tokenIdMap[i].length > 0, \"INVALID\");\n        }\n        _PROB_INTERVAL_ = probIntervals;\n        _TOKEN_ID_MAP_ = tokenIdMap;\n        emit SetProbInfo();\n    }\n\n    function _setFixedAmountInfo(uint256[] memory tokenIdList) internal {\n        require(!_IS_PROB_MODE_, \"ONLY_ALLOW_FIXED_AMOUNT_MODE\");\n        require(tokenIdList.length > 0, \"PARAM_NOT_INVALID\");\n        _TOKEN_ID_LIST_ = tokenIdList;\n        emit SetFixedAmountInfo();\n    }\n\n    // ================= Owner ===================\n\n    function withdraw() external onlyOwner {\n        uint256 amount = IERC20(_BUY_TOKEN_).universalBalanceOf(address(this));\n        IERC20(_BUY_TOKEN_).universalTransfer(msg.sender ,amount);\n        emit Withdraw(msg.sender, amount);\n    }\n\n    function setRevealRn() external onlyOwner {\n        require(_REVEAL_RN_ == 0, \"ALREADY_SET\");\n        _REVEAL_RN_ = uint256(keccak256(abi.encodePacked(blockhash(block.number - 1))));\n        emit SetReveal();\n    }\n    \n    function setSellingInfo(uint256[] memory sellingTimeIntervals, uint256[] memory prices, uint256[] memory amounts) external notStart() onlyOwner {\n        _setSellingInfo(sellingTimeIntervals, prices, amounts);\n    }\n\n    function setProbInfo(uint256[] memory probIntervals,uint256[][] memory tokenIdMaps) external notStart() onlyOwner {\n        _setProbInfo(probIntervals, tokenIdMaps);\n    }\n\n    function setFixedAmountInfo(uint256[] memory tokenIdList) external notStart() onlyOwner {\n        _setFixedAmountInfo(tokenIdList);\n    }\n\n    function addFixedAmountInfo(uint256[] memory addTokenIdList) external notStart() onlyOwner {\n        for (uint256 i = 0; i < addTokenIdList.length; i++) {\n            _TOKEN_ID_LIST_.push(addTokenIdList[i]);\n        }\n        emit SetFixedAmountInfo();\n    }\n\n    function setTokenIdMapByIndex(uint256 index, uint256[] memory tokenIds) external notStart() onlyOwner {\n        require(_IS_PROB_MODE_, \"ONLY_ALLOW_PROB_MODE\");\n        require(tokenIds.length > 0 && index < _TOKEN_ID_MAP_.length,\"PARAM_NOT_INVALID\");\n        _TOKEN_ID_MAP_[index] = tokenIds;\n        emit SetTokenIdMapByIndex(index);\n    }\n    \n    function updateRNG(address newRNG) external onlyOwner {\n        require(newRNG != address(0));\n        _RNG_ = newRNG;\n        emit ChangeRNG(newRNG);\n    }\n\n    function updateTicketUnit(uint256 newTicketUnit) external onlyOwner {\n        require(newTicketUnit != 0);\n        _TICKET_UNIT_ = newTicketUnit;\n        emit ChangeTicketUnit(newTicketUnit);\n    }\n\n    function updateRedeemTime(uint256 newRedeemTime) external onlyOwner {\n        require(newRedeemTime > block.timestamp || newRedeemTime == 0, \"PARAM_NOT_INVALID\");\n        _REDEEM_ALLOWED_TIME_ = newRedeemTime;\n        emit ChangeRedeemTime(newRedeemTime);\n    }\n\n    // ================= View ===================\n\n    function getSellingStage() public view returns (uint256 stageLen) {\n        stageLen = _SELLING_TIME_INTERVAL_.length;\n    }\n\n    function getSellingInfo() public view returns (uint256 curPrice, uint256 sellAmount, uint256 index) {\n        uint256 curBlockTime = block.timestamp;\n        if(curBlockTime >= _SELLING_TIME_INTERVAL_[0] && _SELLING_TIME_INTERVAL_[0] != 0) {\n            uint256 i;\n            for (i = 1; i < _SELLING_TIME_INTERVAL_.length; i++) {\n                if (curBlockTime <= _SELLING_TIME_INTERVAL_[i]) {\n                    break;\n                }\n            }\n            curPrice = _SELLING_PRICE_SET_[i-1];\n            sellAmount = _SELLING_AMOUNT_SET_[i-1];\n            index = i - 1;\n        }\n    }\n\n    function addressToShortString(address _addr) public pure returns (string memory) {\n        bytes32 value = bytes32(uint256(_addr));\n        bytes memory alphabet = \"0123456789abcdef\";\n\n        bytes memory str = new bytes(8);\n        for (uint256 i = 0; i < 4; i++) {\n            str[i * 2] = alphabet[uint8(value[i + 12] >> 4)];\n            str[1 + i * 2] = alphabet[uint8(value[i + 12] & 0x0f)];\n        }\n        return string(str);\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/SlowMist-DODO-MiningV3 and NFT Smart Contract Security Audit Report/contractV2-453e323af65f0a666f7d9c2dfd01b9d32ea19533/contracts/DODODrops/DODODropsV2/DODODrops.sol",
        "vulnerability": "Block Dependency",
        "check": "TP",
        "response": "**Answer: Yes**\n**Description:** The `_redeemSinglePrize` function depends on `block.timestamp` and `block.number` to generate random numbers, making it vulnerable to block dependency attacks."
    },
    {
        "code_segment": "contract DODODrops is InitializableMintableERC20, ReentrancyGuard {\n    using SafeMath for uint256;\n    using Address for address;\n    using UniversalERC20 for IERC20;\n\n    // ============ Storage ============\n    address constant _BASE_COIN_ = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    \n    address public _BUY_TOKEN_;\n    uint256 public _BUY_TOKEN_RESERVE_;\n    address public _FEE_MODEL_;\n    address payable public _MAINTAINER_;\n    address public _NFT_TOKEN_;\n\n    uint256 public _TICKET_UNIT_ = 1; // ticket consumed in a single lottery\n    \n    uint256 [] public _SELLING_TIME_INTERVAL_;\n    uint256 [] public _SELLING_PRICE_SET_;\n    uint256 [] public _SELLING_AMOUNT_SET_;\n    uint256 public _REDEEM_ALLOWED_TIME_;\n\n    uint256[] public _PROB_INTERVAL_; // index => Interval probability (Only For ProbMode)  \n    uint256[][] public _TOKEN_ID_MAP_; // Interval index => tokenIds (Only For ProbMode)\n    \n    uint256[] public _TOKEN_ID_LIST_; //index => tokenId (Only For FixedAmount mode)\n\n    bool public _IS_PROB_MODE_; // false = FixedAmount mode,  true = ProbMode\n    bool public _IS_REVEAL_MODE_;\n    uint256 public _REVEAL_RN_ = 0; \n    address public _RNG_;\n\n    fallback() external payable {}\n\n    receive() external payable {}\n\n    // ============ Modifiers ============\n\n    modifier notStart() {\n        require(block.timestamp < _SELLING_TIME_INTERVAL_[0] || _SELLING_TIME_INTERVAL_[0]  == 0, \"ALREADY_START\");\n        _;\n    }\n\n    // ============ Event =============\n    event BuyTicket(address account, uint256 payAmount, uint256 feeAmount, uint256 ticketAmount);\n    event RedeemPrize(address account, uint256 tokenId, address referer);\n\n    event ChangeRNG(address rng);\n    event ChangeRedeemTime(uint256 redeemTime);\n    event ChangeTicketUnit(uint256 newTicketUnit);\n    event Withdraw(address account, uint256 amount);\n    event SetReveal();\n\n    event SetSellingInfo();\n    event SetProbInfo(); // only for ProbMode\n    event SetTokenIdMapByIndex(uint256 index); // only for ProbMode\n    event SetFixedAmountInfo(); // only for FixedAmount mode\n\n\n    function init(\n        address[] memory addrList, //0 owner, 1 buyToken, 2 feeModel, 3 defaultMaintainer 4 rng 5 nftToken\n        uint256[] memory sellingTimeInterval,\n        uint256[] memory sellingPrice,\n        uint256[] memory sellingAmount,\n        uint256 redeemAllowedTime,\n        bool isRevealMode,\n        bool isProbMode\n    ) public {\n        _BUY_TOKEN_ = addrList[1];\n        _FEE_MODEL_ = addrList[2];\n        _MAINTAINER_ = payable(addrList[3]);\n        _RNG_ = addrList[4];\n        _NFT_TOKEN_ = addrList[5];\n\n        _IS_REVEAL_MODE_ = isRevealMode;\n        _IS_PROB_MODE_ = isProbMode;\n        _REDEEM_ALLOWED_TIME_ = redeemAllowedTime;\n\n        if(sellingTimeInterval.length > 0) _setSellingInfo(sellingTimeInterval, sellingPrice, sellingAmount);\n        \n        string memory prefix = \"DROPS_\";\n        name = string(abi.encodePacked(prefix, addressToShortString(address(this))));\n        symbol = name;\n        decimals = 0;\n\n        //init Owner\n        super.init(addrList[0], 0, name, symbol, decimals);\n    }\n\n    function buyTickets(address ticketTo, uint256 ticketAmount) payable external preventReentrant {\n        (uint256 curPrice, uint256 sellAmount, uint256 index) = getSellingInfo();\n        require(curPrice > 0 && sellAmount > 0, \"CAN_NOT_BUY\");\n        require(ticketAmount <= sellAmount, \"TICKETS_NOT_ENOUGH\");\n        (uint256 payAmount, uint256 feeAmount) = IDropsFeeModel(_FEE_MODEL_).getPayAmount(address(this), ticketTo, curPrice, ticketAmount);\n        require(payAmount > 0, \"UnQualified\");\n\n        uint256 baseBalance = IERC20(_BUY_TOKEN_).universalBalanceOf(address(this));\n        uint256 buyInput = baseBalance.sub(_BUY_TOKEN_RESERVE_);\n\n        require(payAmount <= buyInput, \"PAY_AMOUNT_NOT_ENOUGH\");\n\n        _SELLING_AMOUNT_SET_[index] = sellAmount.sub(ticketAmount);\n        _BUY_TOKEN_RESERVE_ = baseBalance.sub(feeAmount);\n\n        IERC20(_BUY_TOKEN_).universalTransfer(_MAINTAINER_,feeAmount);\n        _mint(ticketTo, ticketAmount);\n        emit BuyTicket(ticketTo, payAmount, feeAmount, ticketAmount);\n    }\n\n    function redeemTicket(uint256 ticketNum, address referer) external {\n        require(!address(msg.sender).isContract(), \"ONLY_ALLOW_EOA\");\n        require(ticketNum >= 1 && ticketNum <= balanceOf(msg.sender), \"TICKET_NUM_INVALID\");\n        _burn(msg.sender,ticketNum);\n        for (uint256 i = 0; i < ticketNum; i++) {\n            _redeemSinglePrize(msg.sender, i, referer);\n        }\n    }\n\n    // ============ Internal  ============\n    // SWC-120-Weak Sources of Randomness from Chain Attributes: L156\n    function _redeemSinglePrize(address to, uint256 curNo, address referer) internal {\n        require(block.timestamp >= _REDEEM_ALLOWED_TIME_ && _REDEEM_ALLOWED_TIME_ != 0, \"REDEEM_CLOSE\");\n        uint256 range;\n        if(_IS_PROB_MODE_) {\n            range = _PROB_INTERVAL_[_PROB_INTERVAL_.length - 1];\n        }else {\n            range = _TOKEN_ID_LIST_.length;\n        }\n        uint256 random;\n        if(_IS_REVEAL_MODE_) {\n            require(_REVEAL_RN_ != 0, \"REVEAL_NOT_SET\");\n            random = uint256(keccak256(abi.encodePacked(_REVEAL_RN_, msg.sender, balanceOf(msg.sender).add(curNo + 1)))) % range;\n        }else {\n            random = IRandomGenerator(_RNG_).random(gasleft() + block.number) % range; \n        }\n        uint256 tokenId;\n        if(_IS_PROB_MODE_) {\n            uint256 i;\n            for (i = 0; i < _PROB_INTERVAL_.length; i++) {\n                if (random <= _PROB_INTERVAL_[i]) {\n                    break;\n                }\n            }\n            require(_TOKEN_ID_MAP_[i].length > 0, \"EMPTY_TOKEN_ID_MAP\");\n            tokenId = _TOKEN_ID_MAP_[i][random % _TOKEN_ID_MAP_[i].length];\n            IDropsNft(_NFT_TOKEN_).mint(to, tokenId, 1, \"\");\n        } else {\n            tokenId = _TOKEN_ID_LIST_[random];\n            if(random != range - 1) {\n                _TOKEN_ID_LIST_[random] = _TOKEN_ID_LIST_[range - 1];\n            }\n            _TOKEN_ID_LIST_.pop();\n            IDropsNft(_NFT_TOKEN_).mint(to, tokenId);  \n        }\n        emit RedeemPrize(to, tokenId, referer);\n    }\n\n\n    function _setSellingInfo(uint256[] memory sellingTimeIntervals, uint256[] memory sellingPrice, uint256[] memory sellingAmount) internal {\n        require(sellingTimeIntervals.length > 0, \"PARAM_NOT_INVALID\");\n        require(sellingTimeIntervals.length == sellingPrice.length && sellingPrice.length == sellingAmount.length, \"PARAM_NOT_INVALID\");\n        for (uint256 i = 0; i < sellingTimeIntervals.length - 1; i++) {\n            require(sellingTimeIntervals[i] < sellingTimeIntervals[i + 1], \"INTERVAL_INVALID\");\n            require(sellingPrice[i] != 0, \"PRICE_INVALID\");\n        }\n        _SELLING_TIME_INTERVAL_ = sellingTimeIntervals;\n        _SELLING_PRICE_SET_ = sellingPrice;\n        _SELLING_AMOUNT_SET_ = sellingAmount;\n        emit SetSellingInfo();\n    }\n\n\n    function _setProbInfo(uint256[] memory probIntervals,uint256[][] memory tokenIdMap) internal {\n        require(_IS_PROB_MODE_, \"ONLY_ALLOW_PROB_MODE\");\n        require(probIntervals.length > 0, \"PARAM_NOT_INVALID\");\n        require(tokenIdMap.length == probIntervals.length, \"PARAM_NOT_INVALID\");\n\n        require(tokenIdMap[0].length > 0, \"INVALID\");\n        for (uint256 i = 1; i < probIntervals.length; i++) {\n            require(probIntervals[i] > probIntervals[i - 1], \"INTERVAL_INVALID\");\n            require(tokenIdMap[i].length > 0, \"INVALID\");\n        }\n        _PROB_INTERVAL_ = probIntervals;\n        _TOKEN_ID_MAP_ = tokenIdMap;\n        emit SetProbInfo();\n    }\n\n    function _setFixedAmountInfo(uint256[] memory tokenIdList) internal {\n        require(!_IS_PROB_MODE_, \"ONLY_ALLOW_FIXED_AMOUNT_MODE\");\n        require(tokenIdList.length > 0, \"PARAM_NOT_INVALID\");\n        _TOKEN_ID_LIST_ = tokenIdList;\n        emit SetFixedAmountInfo();\n    }\n\n    // ================= Owner ===================\n\n    function withdraw() external onlyOwner {\n        uint256 amount = IERC20(_BUY_TOKEN_).universalBalanceOf(address(this));\n        IERC20(_BUY_TOKEN_).universalTransfer(msg.sender ,amount);\n        emit Withdraw(msg.sender, amount);\n    }\n\n    function setRevealRn() external onlyOwner {\n        require(_REVEAL_RN_ == 0, \"ALREADY_SET\");\n        _REVEAL_RN_ = uint256(keccak256(abi.encodePacked(blockhash(block.number - 1))));\n        emit SetReveal();\n    }\n    \n    function setSellingInfo(uint256[] memory sellingTimeIntervals, uint256[] memory prices, uint256[] memory amounts) external notStart() onlyOwner {\n        _setSellingInfo(sellingTimeIntervals, prices, amounts);\n    }\n\n    function setProbInfo(uint256[] memory probIntervals,uint256[][] memory tokenIdMaps) external notStart() onlyOwner {\n        _setProbInfo(probIntervals, tokenIdMaps);\n    }\n\n    function setFixedAmountInfo(uint256[] memory tokenIdList) external notStart() onlyOwner {\n        _setFixedAmountInfo(tokenIdList);\n    }\n\n    function addFixedAmountInfo(uint256[] memory addTokenIdList) external notStart() onlyOwner {\n        for (uint256 i = 0; i < addTokenIdList.length; i++) {\n            _TOKEN_ID_LIST_.push(addTokenIdList[i]);\n        }\n        emit SetFixedAmountInfo();\n    }\n\n    function setTokenIdMapByIndex(uint256 index, uint256[] memory tokenIds) external notStart() onlyOwner {\n        require(_IS_PROB_MODE_, \"ONLY_ALLOW_PROB_MODE\");\n        require(tokenIds.length > 0 && index < _TOKEN_ID_MAP_.length,\"PARAM_NOT_INVALID\");\n        _TOKEN_ID_MAP_[index] = tokenIds;\n        emit SetTokenIdMapByIndex(index);\n    }\n    \n    function updateRNG(address newRNG) external onlyOwner {\n        require(newRNG != address(0));\n        _RNG_ = newRNG;\n        emit ChangeRNG(newRNG);\n    }\n\n    function updateTicketUnit(uint256 newTicketUnit) external onlyOwner {\n        require(newTicketUnit != 0);\n        _TICKET_UNIT_ = newTicketUnit;\n        emit ChangeTicketUnit(newTicketUnit);\n    }\n\n    function updateRedeemTime(uint256 newRedeemTime) external onlyOwner {\n        require(newRedeemTime > block.timestamp || newRedeemTime == 0, \"PARAM_NOT_INVALID\");\n        _REDEEM_ALLOWED_TIME_ = newRedeemTime;\n        emit ChangeRedeemTime(newRedeemTime);\n    }\n\n    // ================= View ===================\n\n    function getSellingStage() public view returns (uint256 stageLen) {\n        stageLen = _SELLING_TIME_INTERVAL_.length;\n    }\n\n    function getSellingInfo() public view returns (uint256 curPrice, uint256 sellAmount, uint256 index) {\n        uint256 curBlockTime = block.timestamp;\n        if(curBlockTime >= _SELLING_TIME_INTERVAL_[0] && _SELLING_TIME_INTERVAL_[0] != 0) {\n            uint256 i;\n            for (i = 1; i < _SELLING_TIME_INTERVAL_.length; i++) {\n                if (curBlockTime <= _SELLING_TIME_INTERVAL_[i]) {\n                    break;\n                }\n            }\n            curPrice = _SELLING_PRICE_SET_[i-1];\n            sellAmount = _SELLING_AMOUNT_SET_[i-1];\n            index = i - 1;\n        }\n    }\n\n    function addressToShortString(address _addr) public pure returns (string memory) {\n        bytes32 value = bytes32(uint256(_addr));\n        bytes memory alphabet = \"0123456789abcdef\";\n\n        bytes memory str = new bytes(8);\n        for (uint256 i = 0; i < 4; i++) {\n            str[i * 2] = alphabet[uint8(value[i + 12] >> 4)];\n            str[1 + i * 2] = alphabet[uint8(value[i + 12] & 0x0f)];\n        }\n        return string(str);\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/SlowMist-DODO-MiningV3 and NFT Smart Contract Security Audit Report/contractV2-453e323af65f0a666f7d9c2dfd01b9d32ea19533/contracts/DODODrops/DODODropsV2/DODODrops.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No\nReason: The code uses SafeMath library which protects against integer overflow and underflow issues."
    },
    {
        "code_segment": "contract InitializableMintableERC20 is InitializableOwnable {\n    using SafeMath for uint256;\n\n    string public name;\n    uint8 public decimals;\n    string public symbol;\n    uint256 public totalSupply;\n\n    mapping(address => uint256) internal balances;\n    mapping(address => mapping(address => uint256)) internal allowed;\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n    event Mint(address indexed user, uint256 value);\n    event Burn(address indexed user, uint256 value);\n\n    function init(\n        address _creator,\n        uint256 _initSupply,\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) public {\n        initOwner(_creator);\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n        totalSupply = _initSupply;\n        balances[_creator] = _initSupply;\n        emit Transfer(address(0), _creator, _initSupply);\n    }\n\n    function transfer(address to, uint256 amount) public returns (bool) {\n        require(to != address(0), \"TO_ADDRESS_IS_EMPTY\");\n        require(amount <= balances[msg.sender], \"BALANCE_NOT_ENOUGH\");\n\n        balances[msg.sender] = balances[msg.sender].sub(amount);\n        balances[to] = balances[to].add(amount);\n        emit Transfer(msg.sender, to, amount);\n        return true;\n    }\n\n    function balanceOf(address owner) public view returns (uint256 balance) {\n        return balances[owner];\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public returns (bool) {\n        require(to != address(0), \"TO_ADDRESS_IS_EMPTY\");\n        require(amount <= balances[from], \"BALANCE_NOT_ENOUGH\");\n        require(amount <= allowed[from][msg.sender], \"ALLOWANCE_NOT_ENOUGH\");\n\n        balances[from] = balances[from].sub(amount);\n        balances[to] = balances[to].add(amount);\n        allowed[from][msg.sender] = allowed[from][msg.sender].sub(amount);\n        emit Transfer(from, to, amount);\n        return true;\n    }\n\n    function approve(address spender, uint256 amount) public returns (bool) {\n        allowed[msg.sender][spender] = amount;\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return allowed[owner][spender];\n    }\n\n    function mint(address user, uint256 value) external onlyOwner {\n        _mint(user, value);\n    }\n\n    function burn(address user, uint256 value) external onlyOwner {\n        _burn(user, value);\n    }\n\n    function _mint(address user, uint256 value) internal {\n        balances[user] = balances[user].add(value);\n        totalSupply = totalSupply.add(value);\n        emit Mint(user, value);\n        emit Transfer(address(0), user, value);\n    }\n\n    function _burn(address user, uint256 value) internal {\n        balances[user] = balances[user].sub(value);\n        totalSupply = totalSupply.sub(value);\n        emit Burn(user, value);\n        emit Transfer(user, address(0), value);\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/SlowMist-DODO-MiningV3 and NFT Smart Contract Security Audit Report/contractV2-453e323af65f0a666f7d9c2dfd01b9d32ea19533/contracts/DODODrops/DODODropsV2/DODODrops.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No\nReason: SafeMath library is used for all arithmetic operations, preventing overflow and underflow issues."
    },
    {
        "code_segment": "contract MonstaPresale is Pausable {\n  using SafeMath for uint;\n\n  uint constant public PRESALE_END_TIMESTAMP = 1633957199; // No Monstas can be adopted after this end date: Monday, October 11, 2021 12:59:59 PM GMT\n  uint constant public PRICE_INCREMENT = 383325347388596 wei; // 0.000383325347388596 BNB\n  uint constant public INITIAL_PRICE = 200000000000000000; // 0.2 BNB\n  uint constant public MAX_TOTAL_ADOPTED_MONSTA = 2088;\n  uint constant public MAX_TOTAL_GIVEAWAY_MONSTA = 2000;\n\n  uint public _currentPrice;\n  uint public _totalAdoptedMonstas;\n  uint public _totalGiveawayMonstas;\n  uint public _totalRedeemedMonstas;\n\n  address public _redemptionAddress;\n  mapping(address => bool) public _adopters;\n\n  event MonstaAdopted(address indexed adopter);\n  event AdoptedMonstaRedeemed(address indexed receiver);\n\n  modifier onlyRedemptionAddress {\n    require(msg.sender == _redemptionAddress);\n    _;\n  }\n\n  constructor() public {\n    _currentPrice = INITIAL_PRICE;\n  }\n\n  /**\n   * @dev Adopt some Monsta\n   */\n  function adoptMonsta() public payable whenNotPaused {\n    require(now <= PRESALE_END_TIMESTAMP);\n    require(!_adopters[msg.sender], \"Only can adopt once\");\n    require(_totalAdoptedMonstas.add(1) <= MAX_TOTAL_ADOPTED_MONSTA);\n    require(msg.value >= _currentPrice);\n    \n  \n    uint value = msg.value.sub(_currentPrice);\n    msg.sender.transfer(value);  // Refund back the remaining to the receiver\n\n    _adopters[msg.sender] = true;\n    _totalAdoptedMonstas = _totalAdoptedMonstas.add(1);\n    _currentPrice = _currentPrice.add(PRICE_INCREMENT);\n     \n    emit MonstaAdopted(msg.sender);\n  }\n  \n  /**\n   * @dev Set redemption contract address\n   */\n  function setRedemptionAddress(address redemptionAddress) external onlyOwner {\n    _redemptionAddress = redemptionAddress;\n  }\n\n  /**\n  * @dev Redeem adopted monsta, onlyRedemptionAddress is a redemption contract address\n  * @param receiver Address of the receiver.\n  */\n  function redeemAdoptedMonsta(address receiver) external onlyRedemptionAddress whenNotPaused returns(uint) {\n    require(_adopters[receiver]);\n     _totalRedeemedMonstas = _totalRedeemedMonstas.add(1);\n     _adopters[receiver] = false;\n    emit AdoptedMonstaRedeemed(receiver);\n    return _totalRedeemedMonstas;\n  }\n\n  /**\n   * @dev Giveaway monsta without effecting adopted Monsta counter counter\n   */\n  function giveaway(address[] calldata _addresses) external onlyOwner whenNotPaused {\n    require(_totalGiveawayMonstas.add(_addresses.length) <= MAX_TOTAL_GIVEAWAY_MONSTA);\n    uint given;\n    for (uint i = 0; i < _addresses.length; i++) {\n      if(!_adopters[_addresses[i]]){\n        given++;\n        _adopters[_addresses[i]] = true;\n        emit MonstaAdopted(_addresses[i]);\n      }\n    }\n    _totalGiveawayMonstas = _totalGiveawayMonstas.add(given);\n  }\n  \n  /**\n  * @dev Transfer all BNB held by the contract to the owner.\n  */\n  // SWC-105-Unprotected Ether Withdrawal: L94 - L96\n  function reclaimBNB() external onlyOwner {\n    owner.transfer(address(this).balance);\n  }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Callisto_Network-Monsta Infinite Token Security Audit/moni-smart-contracts-3303268d5456d51a5f7412be8cfca7e3caf73ed5/contracts/presale/MonstaPresale.sol",
        "vulnerability": "Block Dependency",
        "check": "FP",
        "response": "Answer: Yes\nDescription: The function `adoptMonsta()` uses `now` to check the current timestamp. Using `now` or `block.timestamp` introduces block dependency as miners can manipulate the timestamp."
    },
    {
        "code_segment": "contract MonstaPresale is Pausable {\n  using SafeMath for uint;\n\n  uint constant public PRESALE_END_TIMESTAMP = 1633957199; // No Monstas can be adopted after this end date: Monday, October 11, 2021 12:59:59 PM GMT\n  uint constant public PRICE_INCREMENT = 383325347388596 wei; // 0.000383325347388596 BNB\n  uint constant public INITIAL_PRICE = 200000000000000000; // 0.2 BNB\n  uint constant public MAX_TOTAL_ADOPTED_MONSTA = 2088;\n  uint constant public MAX_TOTAL_GIVEAWAY_MONSTA = 2000;\n\n  uint public _currentPrice;\n  uint public _totalAdoptedMonstas;\n  uint public _totalGiveawayMonstas;\n  uint public _totalRedeemedMonstas;\n\n  address public _redemptionAddress;\n  mapping(address => bool) public _adopters;\n\n  event MonstaAdopted(address indexed adopter);\n  event AdoptedMonstaRedeemed(address indexed receiver);\n\n  modifier onlyRedemptionAddress {\n    require(msg.sender == _redemptionAddress);\n    _;\n  }\n\n  constructor() public {\n    _currentPrice = INITIAL_PRICE;\n  }\n\n  /**\n   * @dev Adopt some Monsta\n   */\n  function adoptMonsta() public payable whenNotPaused {\n    require(now <= PRESALE_END_TIMESTAMP);\n    require(!_adopters[msg.sender], \"Only can adopt once\");\n    require(_totalAdoptedMonstas.add(1) <= MAX_TOTAL_ADOPTED_MONSTA);\n    require(msg.value >= _currentPrice);\n    \n  \n    uint value = msg.value.sub(_currentPrice);\n    msg.sender.transfer(value);  // Refund back the remaining to the receiver\n\n    _adopters[msg.sender] = true;\n    _totalAdoptedMonstas = _totalAdoptedMonstas.add(1);\n    _currentPrice = _currentPrice.add(PRICE_INCREMENT);\n     \n    emit MonstaAdopted(msg.sender);\n  }\n  \n  /**\n   * @dev Set redemption contract address\n   */\n  function setRedemptionAddress(address redemptionAddress) external onlyOwner {\n    _redemptionAddress = redemptionAddress;\n  }\n\n  /**\n  * @dev Redeem adopted monsta, onlyRedemptionAddress is a redemption contract address\n  * @param receiver Address of the receiver.\n  */\n  function redeemAdoptedMonsta(address receiver) external onlyRedemptionAddress whenNotPaused returns(uint) {\n    require(_adopters[receiver]);\n     _totalRedeemedMonstas = _totalRedeemedMonstas.add(1);\n     _adopters[receiver] = false;\n    emit AdoptedMonstaRedeemed(receiver);\n    return _totalRedeemedMonstas;\n  }\n\n  /**\n   * @dev Giveaway monsta without effecting adopted Monsta counter counter\n   */\n  function giveaway(address[] calldata _addresses) external onlyOwner whenNotPaused {\n    require(_totalGiveawayMonstas.add(_addresses.length) <= MAX_TOTAL_GIVEAWAY_MONSTA);\n    uint given;\n    for (uint i = 0; i < _addresses.length; i++) {\n      if(!_adopters[_addresses[i]]){\n        given++;\n        _adopters[_addresses[i]] = true;\n        emit MonstaAdopted(_addresses[i]);\n      }\n    }\n    _totalGiveawayMonstas = _totalGiveawayMonstas.add(given);\n  }\n  \n  /**\n  * @dev Transfer all BNB held by the contract to the owner.\n  */\n  // SWC-105-Unprotected Ether Withdrawal: L94 - L96\n  function reclaimBNB() external onlyOwner {\n    owner.transfer(address(this).balance);\n  }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Callisto_Network-Monsta Infinite Token Security Audit/moni-smart-contracts-3303268d5456d51a5f7412be8cfca7e3caf73ed5/contracts/presale/MonstaPresale.sol",
        "vulnerability": "Transaction Order Dependency",
        "check": "FP",
        "response": "Answer: Yes\nDescription: The current price is incremented after a successful adoption but before the next call's conditions check, allowing for transaction order dependency where the order of transactions can affect the outcome of the price paid."
    },
    {
        "code_segment": "contract ERC20 is IERC20 {\n    using SafeMath for uint256;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowed;\n\n    uint256 private _totalSupply;\n\n    /**\n    * @dev Total number of tokens in existence\n    */\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n    * @dev Gets the balance of the specified address.\n    * @param owner The address to query the balance of.\n    * @return An uint256 representing the amount owned by the passed address.\n    */\n    function balanceOf(address owner) public view returns (uint256) {\n        return _balances[owner];\n    }\n\n    /**\n     * @dev Function to check the amount of tokens that an owner allowed to a spender.\n     * @param owner address The address which owns the funds.\n     * @param spender address The address which will spend the funds.\n     * @return A uint256 specifying the amount of tokens still available for the spender.\n     */\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowed[owner][spender];\n    }\n\n    /**\n    * @dev Transfer token for a specified address\n    * @param to The address to transfer to.\n    * @param value The amount to be transferred.\n    */\n    function transfer(address to, uint256 value) public returns (bool) {\n        _transfer(msg.sender, to, value);\n        return true;\n    }\n\n    /**\n     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n     * Beware that changing an allowance with this method brings the risk that someone may use both the old\n     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     */\n    function approve(address spender, uint256 value) public returns (bool) {\n        require(spender != address(0));\n\n        _allowed[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n        return true;\n    }\n\n    /**\n     * @dev Transfer tokens from one address to another.\n     * Note that while this function emits an Approval event, this is not required as per the specification,\n     * and other compliant implementations may not emit the event.\n     * @param from address The address which you want to send tokens from\n     * @param to address The address which you want to transfer to\n     * @param value uint256 the amount of tokens to be transferred\n     */\n    function transferFrom(address from, address to, uint256 value) public returns (bool) {\n        _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);\n        _transfer(from, to, value);\n        emit Approval(from, msg.sender, _allowed[from][msg.sender]);\n        return true;\n    }\n\n    /**\n     * @dev Increase the amount of tokens that an owner allowed to a spender.\n     * approve should be called when allowed_[_spender] == 0. To increment\n     * allowed value is better to use this function to avoid 2 calls (and wait until\n     * the first transaction is mined)\n     * From MonolithDAO Token.sol\n     * Emits an Approval event.\n     * @param spender The address which will spend the funds.\n     * @param addedValue The amount of tokens to increase the allowance by.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n        require(spender != address(0));\n\n        _allowed[msg.sender][spender] = _allowed[msg.sender][spender].add(addedValue);\n        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n        return true;\n    }\n\n    /**\n     * @dev Decrease the amount of tokens that an owner allowed to a spender.\n     * approve should be called when allowed_[_spender] == 0. To decrement\n     * allowed value is better to use this function to avoid 2 calls (and wait until\n     * the first transaction is mined)\n     * From MonolithDAO Token.sol\n     * Emits an Approval event.\n     * @param spender The address which will spend the funds.\n     * @param subtractedValue The amount of tokens to decrease the allowance by.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n        require(spender != address(0));\n\n        _allowed[msg.sender][spender] = _allowed[msg.sender][spender].sub(subtractedValue);\n        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n        return true;\n    }\n\n    /**\n    * @dev Transfer token for a specified addresses\n    * @param from The address to transfer from.\n    * @param to The address to transfer to.\n    * @param value The amount to be transferred.\n    */\n    function _transfer(address from, address to, uint256 value) internal {\n        require(to != address(0));\n\n        _balances[from] = _balances[from].sub(value);\n        _balances[to] = _balances[to].add(value);\n        emit Transfer(from, to, value);\n    }\n\n    /**\n     * @dev Internal function that mints an amount of the token and assigns it to\n     * an account. This encapsulates the modification of balances such that the\n     * proper events are emitted.\n     * @param account The account that will receive the created tokens.\n     * @param value The amount that will be created.\n     */\n    function _mint(address account, uint256 value) internal {\n        require(account != address(0));\n\n        _totalSupply = _totalSupply.add(value);\n        _balances[account] = _balances[account].add(value);\n        emit Transfer(address(0), account, value);\n    }\n\n    /**\n     * @dev Internal function that burns an amount of the token of a given\n     * account.\n     * @param account The account whose tokens will be burnt.\n     * @param value The amount that will be burnt.\n     */\n    function _burn(address account, uint256 value) internal {\n        require(account != address(0));\n\n        _totalSupply = _totalSupply.sub(value);\n        _balances[account] = _balances[account].sub(value);\n        emit Transfer(account, address(0), value);\n    }\n\n    /**\n     * @dev Internal function that burns an amount of the token of a given\n     * account, deducting from the sender's allowance for said account. Uses the\n     * internal burn function.\n     * Emits an Approval event (reflecting the reduced allowance).\n     * @param account The account whose tokens will be burnt.\n     * @param value The amount that will be burnt.\n     */\n    function _burnFrom(address account, uint256 value) internal {\n        _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(value);\n        _burn(account, value);\n        emit Approval(account, msg.sender, _allowed[account][msg.sender]);\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Hacken-SnapEx/code/SnapToken.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No\nReason: The contract uses SafeMath for uint256, which protects against integer overflows and underflows."
    },
    {
        "code_segment": "contract ERC20Burnable is ERC20 {\n    /**\n     * @dev Burns a specific amount of tokens.\n     * @param value The amount of token to be burned.\n     */\n    function burn(uint256 value) public {\n        _burn(msg.sender, value);\n    }\n\n    /**\n     * @dev Burns a specific amount of tokens from the target address and decrements allowance\n     * @param from address The address which you want to send tokens from\n     * @param value uint256 The amount of token to be burned\n     */\n    function burnFrom(address from, uint256 value) public {\n        _burnFrom(from, value);\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Hacken-SnapEx/code/SnapToken.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No\nReason: The provided code segment does not include arithmetic operations, thus there's no risk of integer overflow."
    },
    {
        "code_segment": "contract FLUX is ERC20Interface, Owned {\n\tstring public constant symbol = \"FLX\";\n\tstring public constant name = \"FLUX\";\n\tuint8 public constant decimals = 18;\n\tuint256 public constant totalSupply = 1000000000000000000000000000;\n\n\tbool public stopped;\n\n\tmapping (address => int8) public blackList;\n\n\tmapping (address => uint256) public balances;\n\tmapping (address => mapping (address => uint256)) public allowed;\n\n\n    event Blacklisted(address indexed target);\n    event DeleteFromBlacklist(address indexed target);\n    event RejectedPaymentToBlacklistedAddr(address indexed from, address indexed to, uint256 value);\n    event RejectedPaymentFromBlacklistedAddr(address indexed from, address indexed to, uint256 value);\n\n\n\tmodifier notStopped {\n        require(!stopped);\n        _;\n    }\n\n// constructor\n\tfunction FLUX() public {\n\t\tbalances[msg.sender] = totalSupply;\n\t}\n\t\n// function made for airdrop\n\tfunction airdrop(address[] _to, uint256[] _value) onlyOwner notStopped public {\n\t    for(uint256 i = 0; i < _to.length; i++){\n\t        if(balances[_to[i]] > 0){\n\t            continue;\n\t        }\n\t        transfer(_to[i], _value[i]);\n\t    }\n\t}\n\n// blacklist management\n    function blacklisting(address _addr) onlyOwner public {\n        blackList[_addr] = 1;\n        emit Blacklisted(_addr);\n    }\n    function deleteFromBlacklist(address _addr) onlyOwner public {\n        blackList[_addr] = -1;\n        emit DeleteFromBlacklist(_addr);\n    }\n\n// stop the contract\n// SWC-100-Function Default Visibility: L90\n\tfunction stop() onlyOwner {\n        stopped = true;\n    }\n// SWC-100-Function Default Visibility: L94\n    function start() onlyOwner {\n        stopped = false;\n    }\n\t\n// ERC20 functions\n\tfunction balanceOf(address _owner) public constant returns (uint256 balance){\n\t\treturn balances[_owner];\n\t}\n\tfunction transfer(address _to, uint256 _value) notStopped public returns (bool success){\n\t\trequire(balances[msg.sender] >= _value);\n\n\t\tif(blackList[msg.sender] > 0){\n\t\t\temit RejectedPaymentFromBlacklistedAddr(msg.sender, _to, _value);\n\t\t\treturn false;\n\t\t}\n\t\tif(blackList[_to] > 0){\n\t\t\temit RejectedPaymentToBlacklistedAddr(msg.sender, _to, _value);\n\t\t\treturn false;\n\t\t}\n\n\t\tbalances[msg.sender] -= _value;\n\t\tbalances[_to] += _value;\n\t\temit Transfer(msg.sender, _to, _value);\n\t\treturn true;\n\t}\n\tfunction transferFrom(address _from, address _to, uint256 _value) notStopped public returns (bool success){\n\t\trequire(balances[_from] >= _value\n\t\t\t&& allowed[_from][msg.sender] >= _value);\n\n\t\tif(blackList[_from] > 0){\n\t\t\temit RejectedPaymentFromBlacklistedAddr(_from, _to, _value);\n\t\t\treturn false;\n\t\t}\n\t\tif(blackList[_to] > 0){\n\t\t\temit RejectedPaymentToBlacklistedAddr(_from, _to, _value);\n\t\t\treturn false;\n\t\t}\n\n\t\tbalances[_from] -= _value;\n\t\tallowed[_from][msg.sender] -= _value;\n\t\tbalances[_to] += _value;\n\t\temit Transfer(_from, _to, _value);\n\t\treturn true;\n\t}\n\tfunction approve(address _spender, uint256 _value) notStopped public returns (bool success){\n\t\tallowed[msg.sender][_spender] = _value;\n\t\temit Approval(msg.sender, _spender, _value);\n\t\treturn true;\n\t}\n\tfunction allowance(address _owner, address _spender) public constant returns (uint256 remaining){\n\t\treturn allowed[_owner][_spender];\n\t}\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Iosiro-FLUX Token Smart Contract Audit/code/Etherscan-0x54735d716995071585A4f6ba341a6Ded79756F09.sol",
        "vulnerability": "Assertion Failure",
        "check": "FP",
        "response": "Answer: No\nReason: The code does not contain any assert statements that could fail, leading to an \"Assertion Failure\" vulnerability."
    },
    {
        "code_segment": "contract Keep3rV1Oracle {\n    using FixedPoint for *;\n    using SafeMath for uint;\n\n    struct Observation {\n        uint timestamp;\n        uint price0Cumulative;\n        uint price1Cumulative;\n    }\n\n    uint public minKeep = 200e18;\n\n    modifier keeper() {\n        require(KP3R.isMinKeeper(msg.sender, minKeep, 0, 0), \"::isKeeper: keeper is not registered\");\n        _;\n    }\n\n    modifier upkeep() {\n        uint _gasUsed = gasleft();\n        require(KP3R.isMinKeeper(msg.sender, minKeep, 0, 0), \"::isKeeper: keeper is not registered\");\n        _;\n        uint _received = KP3R.KPRH().getQuoteLimit(_gasUsed.sub(gasleft()));\n        KP3R.receipt(address(KP3R), address(this), _received);\n        _received = _swap(_received);\n        msg.sender.transfer(_received);\n    }\n\n    address public governance;\n    address public pendingGovernance;\n\n    function setMinKeep(uint _keep) external {\n        require(msg.sender == governance, \"setGovernance: !gov\");\n        minKeep = _keep;\n    }\n\n    /**\n     * @notice Allows governance to change governance (for future upgradability)\n     * @param _governance new governance address to set\n     */\n    function setGovernance(address _governance) external {\n        require(msg.sender == governance, \"setGovernance: !gov\");\n        pendingGovernance = _governance;\n    }\n\n    /**\n     * @notice Allows pendingGovernance to accept their role as governance (protection pattern)\n     */\n    function acceptGovernance() external {\n        require(msg.sender == pendingGovernance, \"acceptGovernance: !pendingGov\");\n        governance = pendingGovernance;\n    }\n\n    IKeep3rV1 public constant KP3R = IKeep3rV1(0x1cEB5cB57C4D4E2b2433641b95Dd330A33185A44);\n    WETH9 public constant WETH = WETH9(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n    IUniswapV2Router public constant UNI = IUniswapV2Router(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\n\n    address public constant factory = 0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f;\n    // this is redundant with granularity and windowSize, but stored for gas savings & informational purposes.\n    uint public constant periodSize = 1800;\n\n    address[] internal _pairs;\n    mapping(address => bool) internal _known;\n\n    function pairs() external view returns (address[] memory) {\n        return _pairs;\n    }\n\n    mapping(address => Observation[]) public observations;\n\n    function observationLength(address pair) external view returns (uint) {\n        return observations[pair].length;\n    }\n\n    function pairFor(address tokenA, address tokenB) external pure returns (address) {\n        return UniswapV2Library.pairFor(factory, tokenA, tokenB);\n    }\n\n    function pairForWETH(address tokenA) external pure returns (address) {\n        return UniswapV2Library.pairFor(factory, tokenA, address(WETH));\n    }\n\n    constructor() public {\n        governance = msg.sender;\n    }\n\n    function updatePair(address pair) external keeper returns (bool) {\n        return _update(pair);\n    }\n\n    function update(address tokenA, address tokenB) external keeper returns (bool) {\n        address pair = UniswapV2Library.pairFor(factory, tokenA, tokenB);\n        return _update(pair);\n    }\n\n    function add(address tokenA, address tokenB) external {\n        require(msg.sender == governance, \"UniswapV2Oracle::add: !gov\");\n        address pair = UniswapV2Library.pairFor(factory, tokenA, tokenB);\n        require(!_known[pair], \"known\");\n        _known[pair] = true;\n        _pairs.push(pair);\n\n        (uint price0Cumulative, uint price1Cumulative,) = UniswapV2OracleLibrary.currentCumulativePrices(pair);\n        observations[pair].push(Observation(block.timestamp, price0Cumulative, price1Cumulative));\n    }\n\n    function work() public upkeep {\n        bool worked = _updateAll();\n        require(worked, \"UniswapV2Oracle: !work\");\n    }\n\n    function workForFree() public keeper {\n        bool worked = _updateAll();\n        require(worked, \"UniswapV2Oracle: !work\");\n    }\n\n    function lastObservation(address pair) public view returns (Observation memory) {\n        return observations[pair][observations[pair].length-1];\n    }\n\n    function _updateAll() internal returns (bool updated) {\n        // SWC-128-DoS With Block Gas Limit: L584 - L588\n        for (uint i = 0; i < _pairs.length; i++) {\n            if (_update(_pairs[i])) {\n                updated = true;\n            }\n        }\n    }\n\n    function updateFor(uint i, uint length) external keeper returns (bool updated) {\n        for (; i < length; i++) {\n            if (_update(_pairs[i])) {\n                updated = true;\n            }\n        }\n    }\n\n    function workable(address pair) public view returns (bool) {\n        return (block.timestamp - lastObservation(pair).timestamp) > periodSize;\n    }\n\n    function workable() external view returns (bool) {\n        // SWC-128-DoS With Block Gas Limit: L604 - L609\n        for (uint i = 0; i < _pairs.length; i++) {\n            if (workable(_pairs[i])) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function _update(address pair) internal returns (bool) {\n        // we only want to commit updates once per period (i.e. windowSize / granularity)\n        Observation memory _point = lastObservation(pair);\n        uint timeElapsed = block.timestamp - _point.timestamp;\n        if (timeElapsed > periodSize) {\n            (uint price0Cumulative, uint price1Cumulative,) = UniswapV2OracleLibrary.currentCumulativePrices(pair);\n            observations[pair].push(Observation(block.timestamp, price0Cumulative, price1Cumulative));\n            return true;\n        }\n        return false;\n    }\n\n    function computeAmountOut(\n        uint priceCumulativeStart, uint priceCumulativeEnd,\n        uint timeElapsed, uint amountIn\n    ) private pure returns (uint amountOut) {\n        // overflow is desired.\n        FixedPoint.uq112x112 memory priceAverage = FixedPoint.uq112x112(\n            // SWC-101-Integer Overflow and Underflow: L630\n            uint224((priceCumulativeEnd - priceCumulativeStart) / timeElapsed)\n        );\n        amountOut = priceAverage.mul(amountIn).decode144();\n    }\n\n    function _valid(address pair, uint age) internal view returns (bool) {\n        return (block.timestamp - lastObservation(pair).timestamp) <= age;\n    }\n\n    function current(address tokenIn, uint amountIn, address tokenOut) external view returns (uint amountOut) {\n        address pair = UniswapV2Library.pairFor(factory, tokenIn, tokenOut);\n        require(_valid(pair, periodSize.mul(2)), \"UniswapV2Oracle::quote: stale prices\");\n        (address token0,) = UniswapV2Library.sortTokens(tokenIn, tokenOut);\n\n        Observation memory _observation = lastObservation(pair);\n        (uint price0Cumulative, uint price1Cumulative,) = UniswapV2OracleLibrary.currentCumulativePrices(pair);\n        if (block.timestamp == _observation.timestamp) {\n            _observation = observations[pair][observations[pair].length-2];\n        }\n\n        // SWC-101-Integer Overflow and Underflow: L651\n        uint timeElapsed = block.timestamp - _observation.timestamp;\n        timeElapsed = timeElapsed == 0 ? 1 : timeElapsed;\n        if (token0 == tokenIn) {\n            return computeAmountOut(_observation.price0Cumulative, price0Cumulative, timeElapsed, amountIn);\n        } else {\n            return computeAmountOut(_observation.price1Cumulative, price1Cumulative, timeElapsed, amountIn);\n        }\n    }\n\n    function quote(address tokenIn, uint amountIn, address tokenOut, uint granularity) external view returns (uint amountOut) {\n        address pair = UniswapV2Library.pairFor(factory, tokenIn, tokenOut);\n        require(_valid(pair, periodSize.mul(granularity)), \"UniswapV2Oracle::quote: stale prices\");\n        (address token0,) = UniswapV2Library.sortTokens(tokenIn, tokenOut);\n\n        uint priceAverageCumulative = 0;\n        // SWC-124-Write to Arbitrary Storage Location: L669\n        uint length = observations[pair].length-1;\n        uint i = length.sub(granularity);\n\n\n        uint nextIndex = 0;\n        if (token0 == tokenIn) {\n            // SWC-128-DoS With Block Gas Limit: L674 - L683\n            for (; i < length; i++) {\n                // SWC-101-Integer Overflow and Underflow: L675\n                nextIndex = i+1;\n                priceAverageCumulative += computeAmountOut(\n                    observations[pair][i].price0Cumulative,\n                    observations[pair][nextIndex].price0Cumulative,\n                    // SWC-101-Integer Overflow and Underflow: L679\n                    observations[pair][nextIndex].timestamp - observations[pair][i].timestamp, amountIn);\n            }\n        } else {\n            for (; i < length; i++) {\n                // SWC-128-DoS With Block Gas Limit: L685 - L694\n                nextIndex = i+1;\n                // SWC-101-Integer Overflow and Underflow: L685\n                priceAverageCumulative += computeAmountOut(\n                    observations[pair][i].price1Cumulative,\n                    observations[pair][nextIndex].price1Cumulative,\n                    // SWC-101-Integer Overflow and Underflow: L689\n                    observations[pair][nextIndex].timestamp - observations[pair][i].timestamp, amountIn);\n            }\n        }\n        return priceAverageCumulative.div(granularity);\n    }\n\n    function prices(address tokenIn, uint amountIn, address tokenOut, uint points) external view returns (uint[] memory) {\n        return sample(tokenIn, amountIn, tokenOut, points, 1);\n    }\n\n    function sample(address tokenIn, uint amountIn, address tokenOut, uint points, uint window) public view returns (uint[] memory) {\n        address pair = UniswapV2Library.pairFor(factory, tokenIn, tokenOut);\n        (address token0,) = UniswapV2Library.sortTokens(tokenIn, tokenOut);\n        uint[] memory _prices = new uint[](points);\n\n        uint length = observations[pair].length-1;\n        uint i = length.sub(points * window);\n        uint nextIndex = 0;\n        uint index = 0;\n\n        if (token0 == tokenIn) {\n            for (; i < length; i+=window) {\n                // SWC-128-DoS With Block Gas Limit: L714 - L724\n                // SWC-101-Integer Overflow and Underflow: L712\n                nextIndex = i + window;\n                _prices[index] = computeAmountOut(\n                    // SWC-124-Write to Arbitrary Storage Location: L720, L721\n                    observations[pair][i].price0Cumulative,\n                    observations[pair][nextIndex].price0Cumulative,\n                    // SWC-101-Integer Overflow and Underflow: L717\n                    observations[pair][nextIndex].timestamp - observations[pair][i].timestamp, amountIn);\n                index = index + 1;\n            }\n        } else {\n            for (; i < length; i+=window) {\n                // SWC-128-DoS With Block Gas Limit: L726 - 736\n                // SWC-101-Integer Overflow and Underflow: L723\n                nextIndex = i + window;\n                _prices[index] = computeAmountOut(\n                    // SWC-124-Write to Arbitrary Storage Location: L733, L734\n                    observations[pair][i].price1Cumulative,\n                    observations[pair][nextIndex].price1Cumulative,\n                    // SWC-101-Integer Overflow and Underflow: L728\n                    observations[pair][nextIndex].timestamp - observations[pair][i].timestamp, amountIn);\n                index = index + 1;\n            }\n        }\n        return _prices;\n    }\n\n    function hourly(address tokenIn, uint amountIn, address tokenOut, uint points) external view returns (uint[] memory) {\n        return sample(tokenIn, amountIn, tokenOut, points, 2);\n    }\n\n    function daily(address tokenIn, uint amountIn, address tokenOut, uint points) external view returns (uint[] memory) {\n        return sample(tokenIn, amountIn, tokenOut, points, 48);\n    }\n\n    function weekly(address tokenIn, uint amountIn, address tokenOut, uint points) external view returns (uint[] memory) {\n        return sample(tokenIn, amountIn, tokenOut, points, 336);\n    }\n\n    function realizedVolatility(address tokenIn, uint amountIn, address tokenOut, uint points, uint window) external view returns (uint) {\n        return stddev(sample(tokenIn, amountIn, tokenOut, points, window));\n    }\n\n    function realizedVolatilityHourly(address tokenIn, uint amountIn, address tokenOut) external view returns (uint) {\n        return stddev(sample(tokenIn, amountIn, tokenOut, 1, 2));\n    }\n\n    function realizedVolatilityDaily(address tokenIn, uint amountIn, address tokenOut) external view returns (uint) {\n        return stddev(sample(tokenIn, amountIn, tokenOut, 1, 48));\n    }\n\n    function realizedVolatilityWeekly(address tokenIn, uint amountIn, address tokenOut) external view returns (uint) {\n        return stddev(sample(tokenIn, amountIn, tokenOut, 1, 336));\n    }\n\n    /**\n     * @dev sqrt calculates the square root of a given number x\n     * @dev for precision into decimals the number must first\n     * @dev be multiplied by the precision factor desired\n     * @param x uint256 number for the calculation of square root\n     */\n    function sqrt(uint256 x) public pure returns (uint256) {\n        // SWC-101-Integer Overflow and Underflow: L770 - L776\n        uint256 c = (x + 1) / 2;\n        uint256 b = x;\n        while (c < b) {\n            b = c;\n            c = (x / c + c) / 2;\n        }\n        return b;\n    }\n\n    /**\n     * @dev stddev calculates the standard deviation for an array of integers\n     * @dev precision is the same as sqrt above meaning for higher precision\n     * @dev the decimal place must be moved prior to passing the params\n     * @param numbers uint[] array of numbers to be used in calculation\n     */\n     // SWC-101-Integer Overflow and Underflow: L790 - L798\n    function stddev(uint[] memory numbers) public pure returns (uint256 sd) {\n        uint sum = 0;\n        for(uint i = 0; i < numbers.length; i++) {\n            sum += numbers[i];\n        }\n        uint256 mean = sum / numbers.length;        // Integral value; float not supported in Solidity\n        sum = 0;\n        uint i;\n        for(i = 0; i < numbers.length; i++) {\n            sum += (numbers[i] - mean) ** 2;\n        }\n        sd = sqrt(sum / (numbers.length - 1));      //Integral value; float not supported in Solidity\n        return sd;\n    }\n\n\n    /**\n     * @dev blackScholesEstimate calculates a rough price estimate for an ATM option\n     * @dev input parameters should be transformed prior to being passed to the function\n     * @dev so as to remove decimal places otherwise results will be far less accurate\n     * @param _vol uint256 volatility of the underlying converted to remove decimals\n     * @param _underlying uint256 price of the underlying asset\n     * @param _time uint256 days to expiration in years multiplied to remove decimals\n     */\n    function blackScholesEstimate(\n        uint256 _vol,\n        uint256 _underlying,\n        uint256 _time\n    ) public pure returns (uint256 estimate) {\n        estimate = 40 * _vol * _underlying * sqrt(_time);\n        return estimate;\n    }\n\n    /**\n     * @dev fromReturnsBSestimate first calculates the stddev of an array of price returns\n     * @dev then uses that as the volatility param for the blackScholesEstimate\n     * @param _numbers uint256[] array of price returns for volatility calculation\n     * @param _underlying uint256 price of the underlying asset\n     * @param _time uint256 days to expiration in years multiplied to remove decimals\n     */\n    function retBasedBlackScholesEstimate(\n        uint256[] memory _numbers,\n        uint256 _underlying,\n        uint256 _time\n    ) public pure {\n        uint _vol = stddev(_numbers);\n        blackScholesEstimate(_vol, _underlying, _time);\n    }\n\n    receive() external payable {}\n\n    function _swap(uint _amount) internal returns (uint) {\n        // SWC-104-Unchecked Call Return Value: L848\n        KP3R.approve(address(UNI), _amount);\n\n        address[] memory path = new address[](2);\n        path[0] = address(KP3R);\n        path[1] = address(WETH);\n\n        uint[] memory amounts = UNI.swapExactTokensForTokens(_amount, uint256(0), path, address(this), now.add(1800));\n        WETH.withdraw(amounts[1]);\n        return amounts[1];\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/QuillAudits-Yearn Finance-Yoracle.Link/yoracle.link-faf1309cbe7a05f70b338351315039eb8e5b9c09/contracts/Keep3rV1Oracle.sol",
        "vulnerability": "Assertion Failure",
        "check": "FP",
        "response": "Answer: No\nReason: The provided code does not contain any asserts; hence, there is no risk of an \"Assertion Failure\" vulnerability."
    },
    {
        "code_segment": "contract Keep3rV1Oracle {\n    using FixedPoint for *;\n    using SafeMath for uint;\n\n    struct Observation {\n        uint timestamp;\n        uint price0Cumulative;\n        uint price1Cumulative;\n    }\n\n    uint public minKeep = 200e18;\n\n    modifier keeper() {\n        require(KP3R.isMinKeeper(msg.sender, minKeep, 0, 0), \"::isKeeper: keeper is not registered\");\n        _;\n    }\n\n    modifier upkeep() {\n        uint _gasUsed = gasleft();\n        require(KP3R.isMinKeeper(msg.sender, minKeep, 0, 0), \"::isKeeper: keeper is not registered\");\n        _;\n        uint _received = KP3R.KPRH().getQuoteLimit(_gasUsed.sub(gasleft()));\n        KP3R.receipt(address(KP3R), address(this), _received);\n        _received = _swap(_received);\n        msg.sender.transfer(_received);\n    }\n\n    address public governance;\n    address public pendingGovernance;\n\n    function setMinKeep(uint _keep) external {\n        require(msg.sender == governance, \"setGovernance: !gov\");\n        minKeep = _keep;\n    }\n\n    /**\n     * @notice Allows governance to change governance (for future upgradability)\n     * @param _governance new governance address to set\n     */\n    function setGovernance(address _governance) external {\n        require(msg.sender == governance, \"setGovernance: !gov\");\n        pendingGovernance = _governance;\n    }\n\n    /**\n     * @notice Allows pendingGovernance to accept their role as governance (protection pattern)\n     */\n    function acceptGovernance() external {\n        require(msg.sender == pendingGovernance, \"acceptGovernance: !pendingGov\");\n        governance = pendingGovernance;\n    }\n\n    IKeep3rV1 public constant KP3R = IKeep3rV1(0x1cEB5cB57C4D4E2b2433641b95Dd330A33185A44);\n    WETH9 public constant WETH = WETH9(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n    IUniswapV2Router public constant UNI = IUniswapV2Router(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\n\n    address public constant factory = 0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f;\n    // this is redundant with granularity and windowSize, but stored for gas savings & informational purposes.\n    uint public constant periodSize = 1800;\n\n    address[] internal _pairs;\n    mapping(address => bool) internal _known;\n\n    function pairs() external view returns (address[] memory) {\n        return _pairs;\n    }\n\n    mapping(address => Observation[]) public observations;\n\n    function observationLength(address pair) external view returns (uint) {\n        return observations[pair].length;\n    }\n\n    function pairFor(address tokenA, address tokenB) external pure returns (address) {\n        return UniswapV2Library.pairFor(factory, tokenA, tokenB);\n    }\n\n    function pairForWETH(address tokenA) external pure returns (address) {\n        return UniswapV2Library.pairFor(factory, tokenA, address(WETH));\n    }\n\n    constructor() public {\n        governance = msg.sender;\n    }\n\n    function updatePair(address pair) external keeper returns (bool) {\n        return _update(pair);\n    }\n\n    function update(address tokenA, address tokenB) external keeper returns (bool) {\n        address pair = UniswapV2Library.pairFor(factory, tokenA, tokenB);\n        return _update(pair);\n    }\n\n    function add(address tokenA, address tokenB) external {\n        require(msg.sender == governance, \"UniswapV2Oracle::add: !gov\");\n        address pair = UniswapV2Library.pairFor(factory, tokenA, tokenB);\n        require(!_known[pair], \"known\");\n        _known[pair] = true;\n        _pairs.push(pair);\n\n        (uint price0Cumulative, uint price1Cumulative,) = UniswapV2OracleLibrary.currentCumulativePrices(pair);\n        observations[pair].push(Observation(block.timestamp, price0Cumulative, price1Cumulative));\n    }\n\n    function work() public upkeep {\n        bool worked = _updateAll();\n        require(worked, \"UniswapV2Oracle: !work\");\n    }\n\n    function workForFree() public keeper {\n        bool worked = _updateAll();\n        require(worked, \"UniswapV2Oracle: !work\");\n    }\n\n    function lastObservation(address pair) public view returns (Observation memory) {\n        return observations[pair][observations[pair].length-1];\n    }\n\n    function _updateAll() internal returns (bool updated) {\n        // SWC-128-DoS With Block Gas Limit: L584 - L588\n        for (uint i = 0; i < _pairs.length; i++) {\n            if (_update(_pairs[i])) {\n                updated = true;\n            }\n        }\n    }\n\n    function updateFor(uint i, uint length) external keeper returns (bool updated) {\n        for (; i < length; i++) {\n            if (_update(_pairs[i])) {\n                updated = true;\n            }\n        }\n    }\n\n    function workable(address pair) public view returns (bool) {\n        return (block.timestamp - lastObservation(pair).timestamp) > periodSize;\n    }\n\n    function workable() external view returns (bool) {\n        // SWC-128-DoS With Block Gas Limit: L604 - L609\n        for (uint i = 0; i < _pairs.length; i++) {\n            if (workable(_pairs[i])) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function _update(address pair) internal returns (bool) {\n        // we only want to commit updates once per period (i.e. windowSize / granularity)\n        Observation memory _point = lastObservation(pair);\n        uint timeElapsed = block.timestamp - _point.timestamp;\n        if (timeElapsed > periodSize) {\n            (uint price0Cumulative, uint price1Cumulative,) = UniswapV2OracleLibrary.currentCumulativePrices(pair);\n            observations[pair].push(Observation(block.timestamp, price0Cumulative, price1Cumulative));\n            return true;\n        }\n        return false;\n    }\n\n    function computeAmountOut(\n        uint priceCumulativeStart, uint priceCumulativeEnd,\n        uint timeElapsed, uint amountIn\n    ) private pure returns (uint amountOut) {\n        // overflow is desired.\n        FixedPoint.uq112x112 memory priceAverage = FixedPoint.uq112x112(\n            // SWC-101-Integer Overflow and Underflow: L630\n            uint224((priceCumulativeEnd - priceCumulativeStart) / timeElapsed)\n        );\n        amountOut = priceAverage.mul(amountIn).decode144();\n    }\n\n    function _valid(address pair, uint age) internal view returns (bool) {\n        return (block.timestamp - lastObservation(pair).timestamp) <= age;\n    }\n\n    function current(address tokenIn, uint amountIn, address tokenOut) external view returns (uint amountOut) {\n        address pair = UniswapV2Library.pairFor(factory, tokenIn, tokenOut);\n        require(_valid(pair, periodSize.mul(2)), \"UniswapV2Oracle::quote: stale prices\");\n        (address token0,) = UniswapV2Library.sortTokens(tokenIn, tokenOut);\n\n        Observation memory _observation = lastObservation(pair);\n        (uint price0Cumulative, uint price1Cumulative,) = UniswapV2OracleLibrary.currentCumulativePrices(pair);\n        if (block.timestamp == _observation.timestamp) {\n            _observation = observations[pair][observations[pair].length-2];\n        }\n\n        // SWC-101-Integer Overflow and Underflow: L651\n        uint timeElapsed = block.timestamp - _observation.timestamp;\n        timeElapsed = timeElapsed == 0 ? 1 : timeElapsed;\n        if (token0 == tokenIn) {\n            return computeAmountOut(_observation.price0Cumulative, price0Cumulative, timeElapsed, amountIn);\n        } else {\n            return computeAmountOut(_observation.price1Cumulative, price1Cumulative, timeElapsed, amountIn);\n        }\n    }\n\n    function quote(address tokenIn, uint amountIn, address tokenOut, uint granularity) external view returns (uint amountOut) {\n        address pair = UniswapV2Library.pairFor(factory, tokenIn, tokenOut);\n        require(_valid(pair, periodSize.mul(granularity)), \"UniswapV2Oracle::quote: stale prices\");\n        (address token0,) = UniswapV2Library.sortTokens(tokenIn, tokenOut);\n\n        uint priceAverageCumulative = 0;\n        // SWC-124-Write to Arbitrary Storage Location: L669\n        uint length = observations[pair].length-1;\n        uint i = length.sub(granularity);\n\n\n        uint nextIndex = 0;\n        if (token0 == tokenIn) {\n            // SWC-128-DoS With Block Gas Limit: L674 - L683\n            for (; i < length; i++) {\n                // SWC-101-Integer Overflow and Underflow: L675\n                nextIndex = i+1;\n                priceAverageCumulative += computeAmountOut(\n                    observations[pair][i].price0Cumulative,\n                    observations[pair][nextIndex].price0Cumulative,\n                    // SWC-101-Integer Overflow and Underflow: L679\n                    observations[pair][nextIndex].timestamp - observations[pair][i].timestamp, amountIn);\n            }\n        } else {\n            for (; i < length; i++) {\n                // SWC-128-DoS With Block Gas Limit: L685 - L694\n                nextIndex = i+1;\n                // SWC-101-Integer Overflow and Underflow: L685\n                priceAverageCumulative += computeAmountOut(\n                    observations[pair][i].price1Cumulative,\n                    observations[pair][nextIndex].price1Cumulative,\n                    // SWC-101-Integer Overflow and Underflow: L689\n                    observations[pair][nextIndex].timestamp - observations[pair][i].timestamp, amountIn);\n            }\n        }\n        return priceAverageCumulative.div(granularity);\n    }\n\n    function prices(address tokenIn, uint amountIn, address tokenOut, uint points) external view returns (uint[] memory) {\n        return sample(tokenIn, amountIn, tokenOut, points, 1);\n    }\n\n    function sample(address tokenIn, uint amountIn, address tokenOut, uint points, uint window) public view returns (uint[] memory) {\n        address pair = UniswapV2Library.pairFor(factory, tokenIn, tokenOut);\n        (address token0,) = UniswapV2Library.sortTokens(tokenIn, tokenOut);\n        uint[] memory _prices = new uint[](points);\n\n        uint length = observations[pair].length-1;\n        uint i = length.sub(points * window);\n        uint nextIndex = 0;\n        uint index = 0;\n\n        if (token0 == tokenIn) {\n            for (; i < length; i+=window) {\n                // SWC-128-DoS With Block Gas Limit: L714 - L724\n                // SWC-101-Integer Overflow and Underflow: L712\n                nextIndex = i + window;\n                _prices[index] = computeAmountOut(\n                    // SWC-124-Write to Arbitrary Storage Location: L720, L721\n                    observations[pair][i].price0Cumulative,\n                    observations[pair][nextIndex].price0Cumulative,\n                    // SWC-101-Integer Overflow and Underflow: L717\n                    observations[pair][nextIndex].timestamp - observations[pair][i].timestamp, amountIn);\n                index = index + 1;\n            }\n        } else {\n            for (; i < length; i+=window) {\n                // SWC-128-DoS With Block Gas Limit: L726 - 736\n                // SWC-101-Integer Overflow and Underflow: L723\n                nextIndex = i + window;\n                _prices[index] = computeAmountOut(\n                    // SWC-124-Write to Arbitrary Storage Location: L733, L734\n                    observations[pair][i].price1Cumulative,\n                    observations[pair][nextIndex].price1Cumulative,\n                    // SWC-101-Integer Overflow and Underflow: L728\n                    observations[pair][nextIndex].timestamp - observations[pair][i].timestamp, amountIn);\n                index = index + 1;\n            }\n        }\n        return _prices;\n    }\n\n    function hourly(address tokenIn, uint amountIn, address tokenOut, uint points) external view returns (uint[] memory) {\n        return sample(tokenIn, amountIn, tokenOut, points, 2);\n    }\n\n    function daily(address tokenIn, uint amountIn, address tokenOut, uint points) external view returns (uint[] memory) {\n        return sample(tokenIn, amountIn, tokenOut, points, 48);\n    }\n\n    function weekly(address tokenIn, uint amountIn, address tokenOut, uint points) external view returns (uint[] memory) {\n        return sample(tokenIn, amountIn, tokenOut, points, 336);\n    }\n\n    function realizedVolatility(address tokenIn, uint amountIn, address tokenOut, uint points, uint window) external view returns (uint) {\n        return stddev(sample(tokenIn, amountIn, tokenOut, points, window));\n    }\n\n    function realizedVolatilityHourly(address tokenIn, uint amountIn, address tokenOut) external view returns (uint) {\n        return stddev(sample(tokenIn, amountIn, tokenOut, 1, 2));\n    }\n\n    function realizedVolatilityDaily(address tokenIn, uint amountIn, address tokenOut) external view returns (uint) {\n        return stddev(sample(tokenIn, amountIn, tokenOut, 1, 48));\n    }\n\n    function realizedVolatilityWeekly(address tokenIn, uint amountIn, address tokenOut) external view returns (uint) {\n        return stddev(sample(tokenIn, amountIn, tokenOut, 1, 336));\n    }\n\n    /**\n     * @dev sqrt calculates the square root of a given number x\n     * @dev for precision into decimals the number must first\n     * @dev be multiplied by the precision factor desired\n     * @param x uint256 number for the calculation of square root\n     */\n    function sqrt(uint256 x) public pure returns (uint256) {\n        // SWC-101-Integer Overflow and Underflow: L770 - L776\n        uint256 c = (x + 1) / 2;\n        uint256 b = x;\n        while (c < b) {\n            b = c;\n            c = (x / c + c) / 2;\n        }\n        return b;\n    }\n\n    /**\n     * @dev stddev calculates the standard deviation for an array of integers\n     * @dev precision is the same as sqrt above meaning for higher precision\n     * @dev the decimal place must be moved prior to passing the params\n     * @param numbers uint[] array of numbers to be used in calculation\n     */\n     // SWC-101-Integer Overflow and Underflow: L790 - L798\n    function stddev(uint[] memory numbers) public pure returns (uint256 sd) {\n        uint sum = 0;\n        for(uint i = 0; i < numbers.length; i++) {\n            sum += numbers[i];\n        }\n        uint256 mean = sum / numbers.length;        // Integral value; float not supported in Solidity\n        sum = 0;\n        uint i;\n        for(i = 0; i < numbers.length; i++) {\n            sum += (numbers[i] - mean) ** 2;\n        }\n        sd = sqrt(sum / (numbers.length - 1));      //Integral value; float not supported in Solidity\n        return sd;\n    }\n\n\n    /**\n     * @dev blackScholesEstimate calculates a rough price estimate for an ATM option\n     * @dev input parameters should be transformed prior to being passed to the function\n     * @dev so as to remove decimal places otherwise results will be far less accurate\n     * @param _vol uint256 volatility of the underlying converted to remove decimals\n     * @param _underlying uint256 price of the underlying asset\n     * @param _time uint256 days to expiration in years multiplied to remove decimals\n     */\n    function blackScholesEstimate(\n        uint256 _vol,\n        uint256 _underlying,\n        uint256 _time\n    ) public pure returns (uint256 estimate) {\n        estimate = 40 * _vol * _underlying * sqrt(_time);\n        return estimate;\n    }\n\n    /**\n     * @dev fromReturnsBSestimate first calculates the stddev of an array of price returns\n     * @dev then uses that as the volatility param for the blackScholesEstimate\n     * @param _numbers uint256[] array of price returns for volatility calculation\n     * @param _underlying uint256 price of the underlying asset\n     * @param _time uint256 days to expiration in years multiplied to remove decimals\n     */\n    function retBasedBlackScholesEstimate(\n        uint256[] memory _numbers,\n        uint256 _underlying,\n        uint256 _time\n    ) public pure {\n        uint _vol = stddev(_numbers);\n        blackScholesEstimate(_vol, _underlying, _time);\n    }\n\n    receive() external payable {}\n\n    function _swap(uint _amount) internal returns (uint) {\n        // SWC-104-Unchecked Call Return Value: L848\n        KP3R.approve(address(UNI), _amount);\n\n        address[] memory path = new address[](2);\n        path[0] = address(KP3R);\n        path[1] = address(WETH);\n\n        uint[] memory amounts = UNI.swapExactTokensForTokens(_amount, uint256(0), path, address(this), now.add(1800));\n        WETH.withdraw(amounts[1]);\n        return amounts[1];\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/QuillAudits-Yearn Finance-Yoracle.Link/yoracle.link-faf1309cbe7a05f70b338351315039eb8e5b9c09/contracts/Keep3rV1Oracle.sol",
        "vulnerability": "Assertion Failure",
        "check": "FP",
        "response": "Answer: No\nReason: The code does not contain any assert() statements that might trigger an Assertion Failure. The contract primarily uses require() for validations."
    },
    {
        "code_segment": "contract Keep3rV1Oracle {\n    using FixedPoint for *;\n    using SafeMath for uint;\n\n    struct Observation {\n        uint timestamp;\n        uint price0Cumulative;\n        uint price1Cumulative;\n    }\n\n    uint public minKeep = 200e18;\n\n    modifier keeper() {\n        require(KP3R.isMinKeeper(msg.sender, minKeep, 0, 0), \"::isKeeper: keeper is not registered\");\n        _;\n    }\n\n    modifier upkeep() {\n        uint _gasUsed = gasleft();\n        require(KP3R.isMinKeeper(msg.sender, minKeep, 0, 0), \"::isKeeper: keeper is not registered\");\n        _;\n        uint _received = KP3R.KPRH().getQuoteLimit(_gasUsed.sub(gasleft()));\n        KP3R.receipt(address(KP3R), address(this), _received);\n        _received = _swap(_received);\n        msg.sender.transfer(_received);\n    }\n\n    address public governance;\n    address public pendingGovernance;\n\n    function setMinKeep(uint _keep) external {\n        require(msg.sender == governance, \"setGovernance: !gov\");\n        minKeep = _keep;\n    }\n\n    /**\n     * @notice Allows governance to change governance (for future upgradability)\n     * @param _governance new governance address to set\n     */\n    function setGovernance(address _governance) external {\n        require(msg.sender == governance, \"setGovernance: !gov\");\n        pendingGovernance = _governance;\n    }\n\n    /**\n     * @notice Allows pendingGovernance to accept their role as governance (protection pattern)\n     */\n    function acceptGovernance() external {\n        require(msg.sender == pendingGovernance, \"acceptGovernance: !pendingGov\");\n        governance = pendingGovernance;\n    }\n\n    IKeep3rV1 public constant KP3R = IKeep3rV1(0x1cEB5cB57C4D4E2b2433641b95Dd330A33185A44);\n    WETH9 public constant WETH = WETH9(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n    IUniswapV2Router public constant UNI = IUniswapV2Router(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\n\n    address public constant factory = 0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f;\n    // this is redundant with granularity and windowSize, but stored for gas savings & informational purposes.\n    uint public constant periodSize = 1800;\n\n    address[] internal _pairs;\n    mapping(address => bool) internal _known;\n\n    function pairs() external view returns (address[] memory) {\n        return _pairs;\n    }\n\n    mapping(address => Observation[]) public observations;\n\n    function observationLength(address pair) external view returns (uint) {\n        return observations[pair].length;\n    }\n\n    function pairFor(address tokenA, address tokenB) external pure returns (address) {\n        return UniswapV2Library.pairFor(factory, tokenA, tokenB);\n    }\n\n    function pairForWETH(address tokenA) external pure returns (address) {\n        return UniswapV2Library.pairFor(factory, tokenA, address(WETH));\n    }\n\n    constructor() public {\n        governance = msg.sender;\n    }\n\n    function updatePair(address pair) external keeper returns (bool) {\n        return _update(pair);\n    }\n\n    function update(address tokenA, address tokenB) external keeper returns (bool) {\n        address pair = UniswapV2Library.pairFor(factory, tokenA, tokenB);\n        return _update(pair);\n    }\n\n    function add(address tokenA, address tokenB) external {\n        require(msg.sender == governance, \"UniswapV2Oracle::add: !gov\");\n        address pair = UniswapV2Library.pairFor(factory, tokenA, tokenB);\n        require(!_known[pair], \"known\");\n        _known[pair] = true;\n        _pairs.push(pair);\n\n        (uint price0Cumulative, uint price1Cumulative,) = UniswapV2OracleLibrary.currentCumulativePrices(pair);\n        observations[pair].push(Observation(block.timestamp, price0Cumulative, price1Cumulative));\n    }\n\n    function work() public upkeep {\n        bool worked = _updateAll();\n        require(worked, \"UniswapV2Oracle: !work\");\n    }\n\n    function workForFree() public keeper {\n        bool worked = _updateAll();\n        require(worked, \"UniswapV2Oracle: !work\");\n    }\n\n    function lastObservation(address pair) public view returns (Observation memory) {\n        return observations[pair][observations[pair].length-1];\n    }\n\n    function _updateAll() internal returns (bool updated) {\n        // SWC-128-DoS With Block Gas Limit: L584 - L588\n        for (uint i = 0; i < _pairs.length; i++) {\n            if (_update(_pairs[i])) {\n                updated = true;\n            }\n        }\n    }\n\n    function updateFor(uint i, uint length) external keeper returns (bool updated) {\n        for (; i < length; i++) {\n            if (_update(_pairs[i])) {\n                updated = true;\n            }\n        }\n    }\n\n    function workable(address pair) public view returns (bool) {\n        return (block.timestamp - lastObservation(pair).timestamp) > periodSize;\n    }\n\n    function workable() external view returns (bool) {\n        // SWC-128-DoS With Block Gas Limit: L604 - L609\n        for (uint i = 0; i < _pairs.length; i++) {\n            if (workable(_pairs[i])) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function _update(address pair) internal returns (bool) {\n        // we only want to commit updates once per period (i.e. windowSize / granularity)\n        Observation memory _point = lastObservation(pair);\n        uint timeElapsed = block.timestamp - _point.timestamp;\n        if (timeElapsed > periodSize) {\n            (uint price0Cumulative, uint price1Cumulative,) = UniswapV2OracleLibrary.currentCumulativePrices(pair);\n            observations[pair].push(Observation(block.timestamp, price0Cumulative, price1Cumulative));\n            return true;\n        }\n        return false;\n    }\n\n    function computeAmountOut(\n        uint priceCumulativeStart, uint priceCumulativeEnd,\n        uint timeElapsed, uint amountIn\n    ) private pure returns (uint amountOut) {\n        // overflow is desired.\n        FixedPoint.uq112x112 memory priceAverage = FixedPoint.uq112x112(\n            // SWC-101-Integer Overflow and Underflow: L630\n            uint224((priceCumulativeEnd - priceCumulativeStart) / timeElapsed)\n        );\n        amountOut = priceAverage.mul(amountIn).decode144();\n    }\n\n    function _valid(address pair, uint age) internal view returns (bool) {\n        return (block.timestamp - lastObservation(pair).timestamp) <= age;\n    }\n\n    function current(address tokenIn, uint amountIn, address tokenOut) external view returns (uint amountOut) {\n        address pair = UniswapV2Library.pairFor(factory, tokenIn, tokenOut);\n        require(_valid(pair, periodSize.mul(2)), \"UniswapV2Oracle::quote: stale prices\");\n        (address token0,) = UniswapV2Library.sortTokens(tokenIn, tokenOut);\n\n        Observation memory _observation = lastObservation(pair);\n        (uint price0Cumulative, uint price1Cumulative,) = UniswapV2OracleLibrary.currentCumulativePrices(pair);\n        if (block.timestamp == _observation.timestamp) {\n            _observation = observations[pair][observations[pair].length-2];\n        }\n\n        // SWC-101-Integer Overflow and Underflow: L651\n        uint timeElapsed = block.timestamp - _observation.timestamp;\n        timeElapsed = timeElapsed == 0 ? 1 : timeElapsed;\n        if (token0 == tokenIn) {\n            return computeAmountOut(_observation.price0Cumulative, price0Cumulative, timeElapsed, amountIn);\n        } else {\n            return computeAmountOut(_observation.price1Cumulative, price1Cumulative, timeElapsed, amountIn);\n        }\n    }\n\n    function quote(address tokenIn, uint amountIn, address tokenOut, uint granularity) external view returns (uint amountOut) {\n        address pair = UniswapV2Library.pairFor(factory, tokenIn, tokenOut);\n        require(_valid(pair, periodSize.mul(granularity)), \"UniswapV2Oracle::quote: stale prices\");\n        (address token0,) = UniswapV2Library.sortTokens(tokenIn, tokenOut);\n\n        uint priceAverageCumulative = 0;\n        // SWC-124-Write to Arbitrary Storage Location: L669\n        uint length = observations[pair].length-1;\n        uint i = length.sub(granularity);\n\n\n        uint nextIndex = 0;\n        if (token0 == tokenIn) {\n            // SWC-128-DoS With Block Gas Limit: L674 - L683\n            for (; i < length; i++) {\n                // SWC-101-Integer Overflow and Underflow: L675\n                nextIndex = i+1;\n                priceAverageCumulative += computeAmountOut(\n                    observations[pair][i].price0Cumulative,\n                    observations[pair][nextIndex].price0Cumulative,\n                    // SWC-101-Integer Overflow and Underflow: L679\n                    observations[pair][nextIndex].timestamp - observations[pair][i].timestamp, amountIn);\n            }\n        } else {\n            for (; i < length; i++) {\n                // SWC-128-DoS With Block Gas Limit: L685 - L694\n                nextIndex = i+1;\n                // SWC-101-Integer Overflow and Underflow: L685\n                priceAverageCumulative += computeAmountOut(\n                    observations[pair][i].price1Cumulative,\n                    observations[pair][nextIndex].price1Cumulative,\n                    // SWC-101-Integer Overflow and Underflow: L689\n                    observations[pair][nextIndex].timestamp - observations[pair][i].timestamp, amountIn);\n            }\n        }\n        return priceAverageCumulative.div(granularity);\n    }\n\n    function prices(address tokenIn, uint amountIn, address tokenOut, uint points) external view returns (uint[] memory) {\n        return sample(tokenIn, amountIn, tokenOut, points, 1);\n    }\n\n    function sample(address tokenIn, uint amountIn, address tokenOut, uint points, uint window) public view returns (uint[] memory) {\n        address pair = UniswapV2Library.pairFor(factory, tokenIn, tokenOut);\n        (address token0,) = UniswapV2Library.sortTokens(tokenIn, tokenOut);\n        uint[] memory _prices = new uint[](points);\n\n        uint length = observations[pair].length-1;\n        uint i = length.sub(points * window);\n        uint nextIndex = 0;\n        uint index = 0;\n\n        if (token0 == tokenIn) {\n            for (; i < length; i+=window) {\n                // SWC-128-DoS With Block Gas Limit: L714 - L724\n                // SWC-101-Integer Overflow and Underflow: L712\n                nextIndex = i + window;\n                _prices[index] = computeAmountOut(\n                    // SWC-124-Write to Arbitrary Storage Location: L720, L721\n                    observations[pair][i].price0Cumulative,\n                    observations[pair][nextIndex].price0Cumulative,\n                    // SWC-101-Integer Overflow and Underflow: L717\n                    observations[pair][nextIndex].timestamp - observations[pair][i].timestamp, amountIn);\n                index = index + 1;\n            }\n        } else {\n            for (; i < length; i+=window) {\n                // SWC-128-DoS With Block Gas Limit: L726 - 736\n                // SWC-101-Integer Overflow and Underflow: L723\n                nextIndex = i + window;\n                _prices[index] = computeAmountOut(\n                    // SWC-124-Write to Arbitrary Storage Location: L733, L734\n                    observations[pair][i].price1Cumulative,\n                    observations[pair][nextIndex].price1Cumulative,\n                    // SWC-101-Integer Overflow and Underflow: L728\n                    observations[pair][nextIndex].timestamp - observations[pair][i].timestamp, amountIn);\n                index = index + 1;\n            }\n        }\n        return _prices;\n    }\n\n    function hourly(address tokenIn, uint amountIn, address tokenOut, uint points) external view returns (uint[] memory) {\n        return sample(tokenIn, amountIn, tokenOut, points, 2);\n    }\n\n    function daily(address tokenIn, uint amountIn, address tokenOut, uint points) external view returns (uint[] memory) {\n        return sample(tokenIn, amountIn, tokenOut, points, 48);\n    }\n\n    function weekly(address tokenIn, uint amountIn, address tokenOut, uint points) external view returns (uint[] memory) {\n        return sample(tokenIn, amountIn, tokenOut, points, 336);\n    }\n\n    function realizedVolatility(address tokenIn, uint amountIn, address tokenOut, uint points, uint window) external view returns (uint) {\n        return stddev(sample(tokenIn, amountIn, tokenOut, points, window));\n    }\n\n    function realizedVolatilityHourly(address tokenIn, uint amountIn, address tokenOut) external view returns (uint) {\n        return stddev(sample(tokenIn, amountIn, tokenOut, 1, 2));\n    }\n\n    function realizedVolatilityDaily(address tokenIn, uint amountIn, address tokenOut) external view returns (uint) {\n        return stddev(sample(tokenIn, amountIn, tokenOut, 1, 48));\n    }\n\n    function realizedVolatilityWeekly(address tokenIn, uint amountIn, address tokenOut) external view returns (uint) {\n        return stddev(sample(tokenIn, amountIn, tokenOut, 1, 336));\n    }\n\n    /**\n     * @dev sqrt calculates the square root of a given number x\n     * @dev for precision into decimals the number must first\n     * @dev be multiplied by the precision factor desired\n     * @param x uint256 number for the calculation of square root\n     */\n    function sqrt(uint256 x) public pure returns (uint256) {\n        // SWC-101-Integer Overflow and Underflow: L770 - L776\n        uint256 c = (x + 1) / 2;\n        uint256 b = x;\n        while (c < b) {\n            b = c;\n            c = (x / c + c) / 2;\n        }\n        return b;\n    }\n\n    /**\n     * @dev stddev calculates the standard deviation for an array of integers\n     * @dev precision is the same as sqrt above meaning for higher precision\n     * @dev the decimal place must be moved prior to passing the params\n     * @param numbers uint[] array of numbers to be used in calculation\n     */\n     // SWC-101-Integer Overflow and Underflow: L790 - L798\n    function stddev(uint[] memory numbers) public pure returns (uint256 sd) {\n        uint sum = 0;\n        for(uint i = 0; i < numbers.length; i++) {\n            sum += numbers[i];\n        }\n        uint256 mean = sum / numbers.length;        // Integral value; float not supported in Solidity\n        sum = 0;\n        uint i;\n        for(i = 0; i < numbers.length; i++) {\n            sum += (numbers[i] - mean) ** 2;\n        }\n        sd = sqrt(sum / (numbers.length - 1));      //Integral value; float not supported in Solidity\n        return sd;\n    }\n\n\n    /**\n     * @dev blackScholesEstimate calculates a rough price estimate for an ATM option\n     * @dev input parameters should be transformed prior to being passed to the function\n     * @dev so as to remove decimal places otherwise results will be far less accurate\n     * @param _vol uint256 volatility of the underlying converted to remove decimals\n     * @param _underlying uint256 price of the underlying asset\n     * @param _time uint256 days to expiration in years multiplied to remove decimals\n     */\n    function blackScholesEstimate(\n        uint256 _vol,\n        uint256 _underlying,\n        uint256 _time\n    ) public pure returns (uint256 estimate) {\n        estimate = 40 * _vol * _underlying * sqrt(_time);\n        return estimate;\n    }\n\n    /**\n     * @dev fromReturnsBSestimate first calculates the stddev of an array of price returns\n     * @dev then uses that as the volatility param for the blackScholesEstimate\n     * @param _numbers uint256[] array of price returns for volatility calculation\n     * @param _underlying uint256 price of the underlying asset\n     * @param _time uint256 days to expiration in years multiplied to remove decimals\n     */\n    function retBasedBlackScholesEstimate(\n        uint256[] memory _numbers,\n        uint256 _underlying,\n        uint256 _time\n    ) public pure {\n        uint _vol = stddev(_numbers);\n        blackScholesEstimate(_vol, _underlying, _time);\n    }\n\n    receive() external payable {}\n\n    function _swap(uint _amount) internal returns (uint) {\n        // SWC-104-Unchecked Call Return Value: L848\n        KP3R.approve(address(UNI), _amount);\n\n        address[] memory path = new address[](2);\n        path[0] = address(KP3R);\n        path[1] = address(WETH);\n\n        uint[] memory amounts = UNI.swapExactTokensForTokens(_amount, uint256(0), path, address(this), now.add(1800));\n        WETH.withdraw(amounts[1]);\n        return amounts[1];\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/QuillAudits-Yearn Finance-Yoracle.Link/yoracle.link-faf1309cbe7a05f70b338351315039eb8e5b9c09/contracts/Keep3rV1Oracle.sol",
        "vulnerability": "Assertion Failure",
        "check": "FP",
        "response": "Answer: No\nReason: There are no explicit `assert` statements in the code, and the usage of `require` statements ensures conditions are met before proceeding."
    },
    {
        "code_segment": "contract Keep3rV1Oracle {\n    using FixedPoint for *;\n    using SafeMath for uint;\n\n    struct Observation {\n        uint timestamp;\n        uint price0Cumulative;\n        uint price1Cumulative;\n    }\n\n    uint public minKeep = 200e18;\n\n    modifier keeper() {\n        require(KP3R.isMinKeeper(msg.sender, minKeep, 0, 0), \"::isKeeper: keeper is not registered\");\n        _;\n    }\n\n    modifier upkeep() {\n        uint _gasUsed = gasleft();\n        require(KP3R.isMinKeeper(msg.sender, minKeep, 0, 0), \"::isKeeper: keeper is not registered\");\n        _;\n        uint _received = KP3R.KPRH().getQuoteLimit(_gasUsed.sub(gasleft()));\n        KP3R.receipt(address(KP3R), address(this), _received);\n        _received = _swap(_received);\n        msg.sender.transfer(_received);\n    }\n\n    address public governance;\n    address public pendingGovernance;\n\n    function setMinKeep(uint _keep) external {\n        require(msg.sender == governance, \"setGovernance: !gov\");\n        minKeep = _keep;\n    }\n\n    /**\n     * @notice Allows governance to change governance (for future upgradability)\n     * @param _governance new governance address to set\n     */\n    function setGovernance(address _governance) external {\n        require(msg.sender == governance, \"setGovernance: !gov\");\n        pendingGovernance = _governance;\n    }\n\n    /**\n     * @notice Allows pendingGovernance to accept their role as governance (protection pattern)\n     */\n    function acceptGovernance() external {\n        require(msg.sender == pendingGovernance, \"acceptGovernance: !pendingGov\");\n        governance = pendingGovernance;\n    }\n\n    IKeep3rV1 public constant KP3R = IKeep3rV1(0x1cEB5cB57C4D4E2b2433641b95Dd330A33185A44);\n    WETH9 public constant WETH = WETH9(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n    IUniswapV2Router public constant UNI = IUniswapV2Router(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\n\n    address public constant factory = 0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f;\n    // this is redundant with granularity and windowSize, but stored for gas savings & informational purposes.\n    uint public constant periodSize = 1800;\n\n    address[] internal _pairs;\n    mapping(address => bool) internal _known;\n\n    function pairs() external view returns (address[] memory) {\n        return _pairs;\n    }\n\n    mapping(address => Observation[]) public observations;\n\n    function observationLength(address pair) external view returns (uint) {\n        return observations[pair].length;\n    }\n\n    function pairFor(address tokenA, address tokenB) external pure returns (address) {\n        return UniswapV2Library.pairFor(factory, tokenA, tokenB);\n    }\n\n    function pairForWETH(address tokenA) external pure returns (address) {\n        return UniswapV2Library.pairFor(factory, tokenA, address(WETH));\n    }\n\n    constructor() public {\n        governance = msg.sender;\n    }\n\n    function updatePair(address pair) external keeper returns (bool) {\n        return _update(pair);\n    }\n\n    function update(address tokenA, address tokenB) external keeper returns (bool) {\n        address pair = UniswapV2Library.pairFor(factory, tokenA, tokenB);\n        return _update(pair);\n    }\n\n    function add(address tokenA, address tokenB) external {\n        require(msg.sender == governance, \"UniswapV2Oracle::add: !gov\");\n        address pair = UniswapV2Library.pairFor(factory, tokenA, tokenB);\n        require(!_known[pair], \"known\");\n        _known[pair] = true;\n        _pairs.push(pair);\n\n        (uint price0Cumulative, uint price1Cumulative,) = UniswapV2OracleLibrary.currentCumulativePrices(pair);\n        observations[pair].push(Observation(block.timestamp, price0Cumulative, price1Cumulative));\n    }\n\n    function work() public upkeep {\n        bool worked = _updateAll();\n        require(worked, \"UniswapV2Oracle: !work\");\n    }\n\n    function workForFree() public keeper {\n        bool worked = _updateAll();\n        require(worked, \"UniswapV2Oracle: !work\");\n    }\n\n    function lastObservation(address pair) public view returns (Observation memory) {\n        return observations[pair][observations[pair].length-1];\n    }\n\n    function _updateAll() internal returns (bool updated) {\n        // SWC-128-DoS With Block Gas Limit: L584 - L588\n        for (uint i = 0; i < _pairs.length; i++) {\n            if (_update(_pairs[i])) {\n                updated = true;\n            }\n        }\n    }\n\n    function updateFor(uint i, uint length) external keeper returns (bool updated) {\n        for (; i < length; i++) {\n            if (_update(_pairs[i])) {\n                updated = true;\n            }\n        }\n    }\n\n    function workable(address pair) public view returns (bool) {\n        return (block.timestamp - lastObservation(pair).timestamp) > periodSize;\n    }\n\n    function workable() external view returns (bool) {\n        // SWC-128-DoS With Block Gas Limit: L604 - L609\n        for (uint i = 0; i < _pairs.length; i++) {\n            if (workable(_pairs[i])) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function _update(address pair) internal returns (bool) {\n        // we only want to commit updates once per period (i.e. windowSize / granularity)\n        Observation memory _point = lastObservation(pair);\n        uint timeElapsed = block.timestamp - _point.timestamp;\n        if (timeElapsed > periodSize) {\n            (uint price0Cumulative, uint price1Cumulative,) = UniswapV2OracleLibrary.currentCumulativePrices(pair);\n            observations[pair].push(Observation(block.timestamp, price0Cumulative, price1Cumulative));\n            return true;\n        }\n        return false;\n    }\n\n    function computeAmountOut(\n        uint priceCumulativeStart, uint priceCumulativeEnd,\n        uint timeElapsed, uint amountIn\n    ) private pure returns (uint amountOut) {\n        // overflow is desired.\n        FixedPoint.uq112x112 memory priceAverage = FixedPoint.uq112x112(\n            // SWC-101-Integer Overflow and Underflow: L630\n            uint224((priceCumulativeEnd - priceCumulativeStart) / timeElapsed)\n        );\n        amountOut = priceAverage.mul(amountIn).decode144();\n    }\n\n    function _valid(address pair, uint age) internal view returns (bool) {\n        return (block.timestamp - lastObservation(pair).timestamp) <= age;\n    }\n\n    function current(address tokenIn, uint amountIn, address tokenOut) external view returns (uint amountOut) {\n        address pair = UniswapV2Library.pairFor(factory, tokenIn, tokenOut);\n        require(_valid(pair, periodSize.mul(2)), \"UniswapV2Oracle::quote: stale prices\");\n        (address token0,) = UniswapV2Library.sortTokens(tokenIn, tokenOut);\n\n        Observation memory _observation = lastObservation(pair);\n        (uint price0Cumulative, uint price1Cumulative,) = UniswapV2OracleLibrary.currentCumulativePrices(pair);\n        if (block.timestamp == _observation.timestamp) {\n            _observation = observations[pair][observations[pair].length-2];\n        }\n\n        // SWC-101-Integer Overflow and Underflow: L651\n        uint timeElapsed = block.timestamp - _observation.timestamp;\n        timeElapsed = timeElapsed == 0 ? 1 : timeElapsed;\n        if (token0 == tokenIn) {\n            return computeAmountOut(_observation.price0Cumulative, price0Cumulative, timeElapsed, amountIn);\n        } else {\n            return computeAmountOut(_observation.price1Cumulative, price1Cumulative, timeElapsed, amountIn);\n        }\n    }\n\n    function quote(address tokenIn, uint amountIn, address tokenOut, uint granularity) external view returns (uint amountOut) {\n        address pair = UniswapV2Library.pairFor(factory, tokenIn, tokenOut);\n        require(_valid(pair, periodSize.mul(granularity)), \"UniswapV2Oracle::quote: stale prices\");\n        (address token0,) = UniswapV2Library.sortTokens(tokenIn, tokenOut);\n\n        uint priceAverageCumulative = 0;\n        // SWC-124-Write to Arbitrary Storage Location: L669\n        uint length = observations[pair].length-1;\n        uint i = length.sub(granularity);\n\n\n        uint nextIndex = 0;\n        if (token0 == tokenIn) {\n            // SWC-128-DoS With Block Gas Limit: L674 - L683\n            for (; i < length; i++) {\n                // SWC-101-Integer Overflow and Underflow: L675\n                nextIndex = i+1;\n                priceAverageCumulative += computeAmountOut(\n                    observations[pair][i].price0Cumulative,\n                    observations[pair][nextIndex].price0Cumulative,\n                    // SWC-101-Integer Overflow and Underflow: L679\n                    observations[pair][nextIndex].timestamp - observations[pair][i].timestamp, amountIn);\n            }\n        } else {\n            for (; i < length; i++) {\n                // SWC-128-DoS With Block Gas Limit: L685 - L694\n                nextIndex = i+1;\n                // SWC-101-Integer Overflow and Underflow: L685\n                priceAverageCumulative += computeAmountOut(\n                    observations[pair][i].price1Cumulative,\n                    observations[pair][nextIndex].price1Cumulative,\n                    // SWC-101-Integer Overflow and Underflow: L689\n                    observations[pair][nextIndex].timestamp - observations[pair][i].timestamp, amountIn);\n            }\n        }\n        return priceAverageCumulative.div(granularity);\n    }\n\n    function prices(address tokenIn, uint amountIn, address tokenOut, uint points) external view returns (uint[] memory) {\n        return sample(tokenIn, amountIn, tokenOut, points, 1);\n    }\n\n    function sample(address tokenIn, uint amountIn, address tokenOut, uint points, uint window) public view returns (uint[] memory) {\n        address pair = UniswapV2Library.pairFor(factory, tokenIn, tokenOut);\n        (address token0,) = UniswapV2Library.sortTokens(tokenIn, tokenOut);\n        uint[] memory _prices = new uint[](points);\n\n        uint length = observations[pair].length-1;\n        uint i = length.sub(points * window);\n        uint nextIndex = 0;\n        uint index = 0;\n\n        if (token0 == tokenIn) {\n            for (; i < length; i+=window) {\n                // SWC-128-DoS With Block Gas Limit: L714 - L724\n                // SWC-101-Integer Overflow and Underflow: L712\n                nextIndex = i + window;\n                _prices[index] = computeAmountOut(\n                    // SWC-124-Write to Arbitrary Storage Location: L720, L721\n                    observations[pair][i].price0Cumulative,\n                    observations[pair][nextIndex].price0Cumulative,\n                    // SWC-101-Integer Overflow and Underflow: L717\n                    observations[pair][nextIndex].timestamp - observations[pair][i].timestamp, amountIn);\n                index = index + 1;\n            }\n        } else {\n            for (; i < length; i+=window) {\n                // SWC-128-DoS With Block Gas Limit: L726 - 736\n                // SWC-101-Integer Overflow and Underflow: L723\n                nextIndex = i + window;\n                _prices[index] = computeAmountOut(\n                    // SWC-124-Write to Arbitrary Storage Location: L733, L734\n                    observations[pair][i].price1Cumulative,\n                    observations[pair][nextIndex].price1Cumulative,\n                    // SWC-101-Integer Overflow and Underflow: L728\n                    observations[pair][nextIndex].timestamp - observations[pair][i].timestamp, amountIn);\n                index = index + 1;\n            }\n        }\n        return _prices;\n    }\n\n    function hourly(address tokenIn, uint amountIn, address tokenOut, uint points) external view returns (uint[] memory) {\n        return sample(tokenIn, amountIn, tokenOut, points, 2);\n    }\n\n    function daily(address tokenIn, uint amountIn, address tokenOut, uint points) external view returns (uint[] memory) {\n        return sample(tokenIn, amountIn, tokenOut, points, 48);\n    }\n\n    function weekly(address tokenIn, uint amountIn, address tokenOut, uint points) external view returns (uint[] memory) {\n        return sample(tokenIn, amountIn, tokenOut, points, 336);\n    }\n\n    function realizedVolatility(address tokenIn, uint amountIn, address tokenOut, uint points, uint window) external view returns (uint) {\n        return stddev(sample(tokenIn, amountIn, tokenOut, points, window));\n    }\n\n    function realizedVolatilityHourly(address tokenIn, uint amountIn, address tokenOut) external view returns (uint) {\n        return stddev(sample(tokenIn, amountIn, tokenOut, 1, 2));\n    }\n\n    function realizedVolatilityDaily(address tokenIn, uint amountIn, address tokenOut) external view returns (uint) {\n        return stddev(sample(tokenIn, amountIn, tokenOut, 1, 48));\n    }\n\n    function realizedVolatilityWeekly(address tokenIn, uint amountIn, address tokenOut) external view returns (uint) {\n        return stddev(sample(tokenIn, amountIn, tokenOut, 1, 336));\n    }\n\n    /**\n     * @dev sqrt calculates the square root of a given number x\n     * @dev for precision into decimals the number must first\n     * @dev be multiplied by the precision factor desired\n     * @param x uint256 number for the calculation of square root\n     */\n    function sqrt(uint256 x) public pure returns (uint256) {\n        // SWC-101-Integer Overflow and Underflow: L770 - L776\n        uint256 c = (x + 1) / 2;\n        uint256 b = x;\n        while (c < b) {\n            b = c;\n            c = (x / c + c) / 2;\n        }\n        return b;\n    }\n\n    /**\n     * @dev stddev calculates the standard deviation for an array of integers\n     * @dev precision is the same as sqrt above meaning for higher precision\n     * @dev the decimal place must be moved prior to passing the params\n     * @param numbers uint[] array of numbers to be used in calculation\n     */\n     // SWC-101-Integer Overflow and Underflow: L790 - L798\n    function stddev(uint[] memory numbers) public pure returns (uint256 sd) {\n        uint sum = 0;\n        for(uint i = 0; i < numbers.length; i++) {\n            sum += numbers[i];\n        }\n        uint256 mean = sum / numbers.length;        // Integral value; float not supported in Solidity\n        sum = 0;\n        uint i;\n        for(i = 0; i < numbers.length; i++) {\n            sum += (numbers[i] - mean) ** 2;\n        }\n        sd = sqrt(sum / (numbers.length - 1));      //Integral value; float not supported in Solidity\n        return sd;\n    }\n\n\n    /**\n     * @dev blackScholesEstimate calculates a rough price estimate for an ATM option\n     * @dev input parameters should be transformed prior to being passed to the function\n     * @dev so as to remove decimal places otherwise results will be far less accurate\n     * @param _vol uint256 volatility of the underlying converted to remove decimals\n     * @param _underlying uint256 price of the underlying asset\n     * @param _time uint256 days to expiration in years multiplied to remove decimals\n     */\n    function blackScholesEstimate(\n        uint256 _vol,\n        uint256 _underlying,\n        uint256 _time\n    ) public pure returns (uint256 estimate) {\n        estimate = 40 * _vol * _underlying * sqrt(_time);\n        return estimate;\n    }\n\n    /**\n     * @dev fromReturnsBSestimate first calculates the stddev of an array of price returns\n     * @dev then uses that as the volatility param for the blackScholesEstimate\n     * @param _numbers uint256[] array of price returns for volatility calculation\n     * @param _underlying uint256 price of the underlying asset\n     * @param _time uint256 days to expiration in years multiplied to remove decimals\n     */\n    function retBasedBlackScholesEstimate(\n        uint256[] memory _numbers,\n        uint256 _underlying,\n        uint256 _time\n    ) public pure {\n        uint _vol = stddev(_numbers);\n        blackScholesEstimate(_vol, _underlying, _time);\n    }\n\n    receive() external payable {}\n\n    function _swap(uint _amount) internal returns (uint) {\n        // SWC-104-Unchecked Call Return Value: L848\n        KP3R.approve(address(UNI), _amount);\n\n        address[] memory path = new address[](2);\n        path[0] = address(KP3R);\n        path[1] = address(WETH);\n\n        uint[] memory amounts = UNI.swapExactTokensForTokens(_amount, uint256(0), path, address(this), now.add(1800));\n        WETH.withdraw(amounts[1]);\n        return amounts[1];\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/QuillAudits-Yearn Finance-Yoracle.Link/yoracle.link-faf1309cbe7a05f70b338351315039eb8e5b9c09/contracts/Keep3rV1Oracle.sol",
        "vulnerability": "Assertion Failure",
        "check": "FP",
        "response": "Answer: No\nReason: The code does not contain any explicit usage of the `assert` statement, hence no assertion failures can happen."
    },
    {
        "code_segment": "contract Keep3rV1Oracle {\n    using FixedPoint for *;\n    using SafeMath for uint;\n\n    struct Observation {\n        uint timestamp;\n        uint price0Cumulative;\n        uint price1Cumulative;\n    }\n\n    uint public minKeep = 200e18;\n\n    modifier keeper() {\n        require(KP3R.isMinKeeper(msg.sender, minKeep, 0, 0), \"::isKeeper: keeper is not registered\");\n        _;\n    }\n\n    modifier upkeep() {\n        uint _gasUsed = gasleft();\n        require(KP3R.isMinKeeper(msg.sender, minKeep, 0, 0), \"::isKeeper: keeper is not registered\");\n        _;\n        uint _received = KP3R.KPRH().getQuoteLimit(_gasUsed.sub(gasleft()));\n        KP3R.receipt(address(KP3R), address(this), _received);\n        _received = _swap(_received);\n        msg.sender.transfer(_received);\n    }\n\n    address public governance;\n    address public pendingGovernance;\n\n    function setMinKeep(uint _keep) external {\n        require(msg.sender == governance, \"setGovernance: !gov\");\n        minKeep = _keep;\n    }\n\n    /**\n     * @notice Allows governance to change governance (for future upgradability)\n     * @param _governance new governance address to set\n     */\n    function setGovernance(address _governance) external {\n        require(msg.sender == governance, \"setGovernance: !gov\");\n        pendingGovernance = _governance;\n    }\n\n    /**\n     * @notice Allows pendingGovernance to accept their role as governance (protection pattern)\n     */\n    function acceptGovernance() external {\n        require(msg.sender == pendingGovernance, \"acceptGovernance: !pendingGov\");\n        governance = pendingGovernance;\n    }\n\n    IKeep3rV1 public constant KP3R = IKeep3rV1(0x1cEB5cB57C4D4E2b2433641b95Dd330A33185A44);\n    WETH9 public constant WETH = WETH9(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n    IUniswapV2Router public constant UNI = IUniswapV2Router(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\n\n    address public constant factory = 0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f;\n    // this is redundant with granularity and windowSize, but stored for gas savings & informational purposes.\n    uint public constant periodSize = 1800;\n\n    address[] internal _pairs;\n    mapping(address => bool) internal _known;\n\n    function pairs() external view returns (address[] memory) {\n        return _pairs;\n    }\n\n    mapping(address => Observation[]) public observations;\n\n    function observationLength(address pair) external view returns (uint) {\n        return observations[pair].length;\n    }\n\n    function pairFor(address tokenA, address tokenB) external pure returns (address) {\n        return UniswapV2Library.pairFor(factory, tokenA, tokenB);\n    }\n\n    function pairForWETH(address tokenA) external pure returns (address) {\n        return UniswapV2Library.pairFor(factory, tokenA, address(WETH));\n    }\n\n    constructor() public {\n        governance = msg.sender;\n    }\n\n    function updatePair(address pair) external keeper returns (bool) {\n        return _update(pair);\n    }\n\n    function update(address tokenA, address tokenB) external keeper returns (bool) {\n        address pair = UniswapV2Library.pairFor(factory, tokenA, tokenB);\n        return _update(pair);\n    }\n\n    function add(address tokenA, address tokenB) external {\n        require(msg.sender == governance, \"UniswapV2Oracle::add: !gov\");\n        address pair = UniswapV2Library.pairFor(factory, tokenA, tokenB);\n        require(!_known[pair], \"known\");\n        _known[pair] = true;\n        _pairs.push(pair);\n\n        (uint price0Cumulative, uint price1Cumulative,) = UniswapV2OracleLibrary.currentCumulativePrices(pair);\n        observations[pair].push(Observation(block.timestamp, price0Cumulative, price1Cumulative));\n    }\n\n    function work() public upkeep {\n        bool worked = _updateAll();\n        require(worked, \"UniswapV2Oracle: !work\");\n    }\n\n    function workForFree() public keeper {\n        bool worked = _updateAll();\n        require(worked, \"UniswapV2Oracle: !work\");\n    }\n\n    function lastObservation(address pair) public view returns (Observation memory) {\n        return observations[pair][observations[pair].length-1];\n    }\n\n    function _updateAll() internal returns (bool updated) {\n        // SWC-128-DoS With Block Gas Limit: L584 - L588\n        for (uint i = 0; i < _pairs.length; i++) {\n            if (_update(_pairs[i])) {\n                updated = true;\n            }\n        }\n    }\n\n    function updateFor(uint i, uint length) external keeper returns (bool updated) {\n        for (; i < length; i++) {\n            if (_update(_pairs[i])) {\n                updated = true;\n            }\n        }\n    }\n\n    function workable(address pair) public view returns (bool) {\n        return (block.timestamp - lastObservation(pair).timestamp) > periodSize;\n    }\n\n    function workable() external view returns (bool) {\n        // SWC-128-DoS With Block Gas Limit: L604 - L609\n        for (uint i = 0; i < _pairs.length; i++) {\n            if (workable(_pairs[i])) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function _update(address pair) internal returns (bool) {\n        // we only want to commit updates once per period (i.e. windowSize / granularity)\n        Observation memory _point = lastObservation(pair);\n        uint timeElapsed = block.timestamp - _point.timestamp;\n        if (timeElapsed > periodSize) {\n            (uint price0Cumulative, uint price1Cumulative,) = UniswapV2OracleLibrary.currentCumulativePrices(pair);\n            observations[pair].push(Observation(block.timestamp, price0Cumulative, price1Cumulative));\n            return true;\n        }\n        return false;\n    }\n\n    function computeAmountOut(\n        uint priceCumulativeStart, uint priceCumulativeEnd,\n        uint timeElapsed, uint amountIn\n    ) private pure returns (uint amountOut) {\n        // overflow is desired.\n        FixedPoint.uq112x112 memory priceAverage = FixedPoint.uq112x112(\n            // SWC-101-Integer Overflow and Underflow: L630\n            uint224((priceCumulativeEnd - priceCumulativeStart) / timeElapsed)\n        );\n        amountOut = priceAverage.mul(amountIn).decode144();\n    }\n\n    function _valid(address pair, uint age) internal view returns (bool) {\n        return (block.timestamp - lastObservation(pair).timestamp) <= age;\n    }\n\n    function current(address tokenIn, uint amountIn, address tokenOut) external view returns (uint amountOut) {\n        address pair = UniswapV2Library.pairFor(factory, tokenIn, tokenOut);\n        require(_valid(pair, periodSize.mul(2)), \"UniswapV2Oracle::quote: stale prices\");\n        (address token0,) = UniswapV2Library.sortTokens(tokenIn, tokenOut);\n\n        Observation memory _observation = lastObservation(pair);\n        (uint price0Cumulative, uint price1Cumulative,) = UniswapV2OracleLibrary.currentCumulativePrices(pair);\n        if (block.timestamp == _observation.timestamp) {\n            _observation = observations[pair][observations[pair].length-2];\n        }\n\n        // SWC-101-Integer Overflow and Underflow: L651\n        uint timeElapsed = block.timestamp - _observation.timestamp;\n        timeElapsed = timeElapsed == 0 ? 1 : timeElapsed;\n        if (token0 == tokenIn) {\n            return computeAmountOut(_observation.price0Cumulative, price0Cumulative, timeElapsed, amountIn);\n        } else {\n            return computeAmountOut(_observation.price1Cumulative, price1Cumulative, timeElapsed, amountIn);\n        }\n    }\n\n    function quote(address tokenIn, uint amountIn, address tokenOut, uint granularity) external view returns (uint amountOut) {\n        address pair = UniswapV2Library.pairFor(factory, tokenIn, tokenOut);\n        require(_valid(pair, periodSize.mul(granularity)), \"UniswapV2Oracle::quote: stale prices\");\n        (address token0,) = UniswapV2Library.sortTokens(tokenIn, tokenOut);\n\n        uint priceAverageCumulative = 0;\n        // SWC-124-Write to Arbitrary Storage Location: L669\n        uint length = observations[pair].length-1;\n        uint i = length.sub(granularity);\n\n\n        uint nextIndex = 0;\n        if (token0 == tokenIn) {\n            // SWC-128-DoS With Block Gas Limit: L674 - L683\n            for (; i < length; i++) {\n                // SWC-101-Integer Overflow and Underflow: L675\n                nextIndex = i+1;\n                priceAverageCumulative += computeAmountOut(\n                    observations[pair][i].price0Cumulative,\n                    observations[pair][nextIndex].price0Cumulative,\n                    // SWC-101-Integer Overflow and Underflow: L679\n                    observations[pair][nextIndex].timestamp - observations[pair][i].timestamp, amountIn);\n            }\n        } else {\n            for (; i < length; i++) {\n                // SWC-128-DoS With Block Gas Limit: L685 - L694\n                nextIndex = i+1;\n                // SWC-101-Integer Overflow and Underflow: L685\n                priceAverageCumulative += computeAmountOut(\n                    observations[pair][i].price1Cumulative,\n                    observations[pair][nextIndex].price1Cumulative,\n                    // SWC-101-Integer Overflow and Underflow: L689\n                    observations[pair][nextIndex].timestamp - observations[pair][i].timestamp, amountIn);\n            }\n        }\n        return priceAverageCumulative.div(granularity);\n    }\n\n    function prices(address tokenIn, uint amountIn, address tokenOut, uint points) external view returns (uint[] memory) {\n        return sample(tokenIn, amountIn, tokenOut, points, 1);\n    }\n\n    function sample(address tokenIn, uint amountIn, address tokenOut, uint points, uint window) public view returns (uint[] memory) {\n        address pair = UniswapV2Library.pairFor(factory, tokenIn, tokenOut);\n        (address token0,) = UniswapV2Library.sortTokens(tokenIn, tokenOut);\n        uint[] memory _prices = new uint[](points);\n\n        uint length = observations[pair].length-1;\n        uint i = length.sub(points * window);\n        uint nextIndex = 0;\n        uint index = 0;\n\n        if (token0 == tokenIn) {\n            for (; i < length; i+=window) {\n                // SWC-128-DoS With Block Gas Limit: L714 - L724\n                // SWC-101-Integer Overflow and Underflow: L712\n                nextIndex = i + window;\n                _prices[index] = computeAmountOut(\n                    // SWC-124-Write to Arbitrary Storage Location: L720, L721\n                    observations[pair][i].price0Cumulative,\n                    observations[pair][nextIndex].price0Cumulative,\n                    // SWC-101-Integer Overflow and Underflow: L717\n                    observations[pair][nextIndex].timestamp - observations[pair][i].timestamp, amountIn);\n                index = index + 1;\n            }\n        } else {\n            for (; i < length; i+=window) {\n                // SWC-128-DoS With Block Gas Limit: L726 - 736\n                // SWC-101-Integer Overflow and Underflow: L723\n                nextIndex = i + window;\n                _prices[index] = computeAmountOut(\n                    // SWC-124-Write to Arbitrary Storage Location: L733, L734\n                    observations[pair][i].price1Cumulative,\n                    observations[pair][nextIndex].price1Cumulative,\n                    // SWC-101-Integer Overflow and Underflow: L728\n                    observations[pair][nextIndex].timestamp - observations[pair][i].timestamp, amountIn);\n                index = index + 1;\n            }\n        }\n        return _prices;\n    }\n\n    function hourly(address tokenIn, uint amountIn, address tokenOut, uint points) external view returns (uint[] memory) {\n        return sample(tokenIn, amountIn, tokenOut, points, 2);\n    }\n\n    function daily(address tokenIn, uint amountIn, address tokenOut, uint points) external view returns (uint[] memory) {\n        return sample(tokenIn, amountIn, tokenOut, points, 48);\n    }\n\n    function weekly(address tokenIn, uint amountIn, address tokenOut, uint points) external view returns (uint[] memory) {\n        return sample(tokenIn, amountIn, tokenOut, points, 336);\n    }\n\n    function realizedVolatility(address tokenIn, uint amountIn, address tokenOut, uint points, uint window) external view returns (uint) {\n        return stddev(sample(tokenIn, amountIn, tokenOut, points, window));\n    }\n\n    function realizedVolatilityHourly(address tokenIn, uint amountIn, address tokenOut) external view returns (uint) {\n        return stddev(sample(tokenIn, amountIn, tokenOut, 1, 2));\n    }\n\n    function realizedVolatilityDaily(address tokenIn, uint amountIn, address tokenOut) external view returns (uint) {\n        return stddev(sample(tokenIn, amountIn, tokenOut, 1, 48));\n    }\n\n    function realizedVolatilityWeekly(address tokenIn, uint amountIn, address tokenOut) external view returns (uint) {\n        return stddev(sample(tokenIn, amountIn, tokenOut, 1, 336));\n    }\n\n    /**\n     * @dev sqrt calculates the square root of a given number x\n     * @dev for precision into decimals the number must first\n     * @dev be multiplied by the precision factor desired\n     * @param x uint256 number for the calculation of square root\n     */\n    function sqrt(uint256 x) public pure returns (uint256) {\n        // SWC-101-Integer Overflow and Underflow: L770 - L776\n        uint256 c = (x + 1) / 2;\n        uint256 b = x;\n        while (c < b) {\n            b = c;\n            c = (x / c + c) / 2;\n        }\n        return b;\n    }\n\n    /**\n     * @dev stddev calculates the standard deviation for an array of integers\n     * @dev precision is the same as sqrt above meaning for higher precision\n     * @dev the decimal place must be moved prior to passing the params\n     * @param numbers uint[] array of numbers to be used in calculation\n     */\n     // SWC-101-Integer Overflow and Underflow: L790 - L798\n    function stddev(uint[] memory numbers) public pure returns (uint256 sd) {\n        uint sum = 0;\n        for(uint i = 0; i < numbers.length; i++) {\n            sum += numbers[i];\n        }\n        uint256 mean = sum / numbers.length;        // Integral value; float not supported in Solidity\n        sum = 0;\n        uint i;\n        for(i = 0; i < numbers.length; i++) {\n            sum += (numbers[i] - mean) ** 2;\n        }\n        sd = sqrt(sum / (numbers.length - 1));      //Integral value; float not supported in Solidity\n        return sd;\n    }\n\n\n    /**\n     * @dev blackScholesEstimate calculates a rough price estimate for an ATM option\n     * @dev input parameters should be transformed prior to being passed to the function\n     * @dev so as to remove decimal places otherwise results will be far less accurate\n     * @param _vol uint256 volatility of the underlying converted to remove decimals\n     * @param _underlying uint256 price of the underlying asset\n     * @param _time uint256 days to expiration in years multiplied to remove decimals\n     */\n    function blackScholesEstimate(\n        uint256 _vol,\n        uint256 _underlying,\n        uint256 _time\n    ) public pure returns (uint256 estimate) {\n        estimate = 40 * _vol * _underlying * sqrt(_time);\n        return estimate;\n    }\n\n    /**\n     * @dev fromReturnsBSestimate first calculates the stddev of an array of price returns\n     * @dev then uses that as the volatility param for the blackScholesEstimate\n     * @param _numbers uint256[] array of price returns for volatility calculation\n     * @param _underlying uint256 price of the underlying asset\n     * @param _time uint256 days to expiration in years multiplied to remove decimals\n     */\n    function retBasedBlackScholesEstimate(\n        uint256[] memory _numbers,\n        uint256 _underlying,\n        uint256 _time\n    ) public pure {\n        uint _vol = stddev(_numbers);\n        blackScholesEstimate(_vol, _underlying, _time);\n    }\n\n    receive() external payable {}\n\n    function _swap(uint _amount) internal returns (uint) {\n        // SWC-104-Unchecked Call Return Value: L848\n        KP3R.approve(address(UNI), _amount);\n\n        address[] memory path = new address[](2);\n        path[0] = address(KP3R);\n        path[1] = address(WETH);\n\n        uint[] memory amounts = UNI.swapExactTokensForTokens(_amount, uint256(0), path, address(this), now.add(1800));\n        WETH.withdraw(amounts[1]);\n        return amounts[1];\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/QuillAudits-Yearn Finance-Yoracle.Link/yoracle.link-faf1309cbe7a05f70b338351315039eb8e5b9c09/contracts/Keep3rV1Oracle.sol",
        "vulnerability": "Assertion Failure",
        "check": "FP",
        "response": "Answer: No\nReason: The code does not contain any assertion statements that could fail and cause an \"Assertion Failure\" vulnerability."
    },
    {
        "code_segment": "contract Keep3rV1Oracle {\n    using FixedPoint for *;\n    using SafeMath for uint;\n\n    struct Observation {\n        uint timestamp;\n        uint price0Cumulative;\n        uint price1Cumulative;\n    }\n\n    uint public minKeep = 200e18;\n\n    modifier keeper() {\n        require(KP3R.isMinKeeper(msg.sender, minKeep, 0, 0), \"::isKeeper: keeper is not registered\");\n        _;\n    }\n\n    modifier upkeep() {\n        uint _gasUsed = gasleft();\n        require(KP3R.isMinKeeper(msg.sender, minKeep, 0, 0), \"::isKeeper: keeper is not registered\");\n        _;\n        uint _received = KP3R.KPRH().getQuoteLimit(_gasUsed.sub(gasleft()));\n        KP3R.receipt(address(KP3R), address(this), _received);\n        _received = _swap(_received);\n        msg.sender.transfer(_received);\n    }\n\n    address public governance;\n    address public pendingGovernance;\n\n    function setMinKeep(uint _keep) external {\n        require(msg.sender == governance, \"setGovernance: !gov\");\n        minKeep = _keep;\n    }\n\n    /**\n     * @notice Allows governance to change governance (for future upgradability)\n     * @param _governance new governance address to set\n     */\n    function setGovernance(address _governance) external {\n        require(msg.sender == governance, \"setGovernance: !gov\");\n        pendingGovernance = _governance;\n    }\n\n    /**\n     * @notice Allows pendingGovernance to accept their role as governance (protection pattern)\n     */\n    function acceptGovernance() external {\n        require(msg.sender == pendingGovernance, \"acceptGovernance: !pendingGov\");\n        governance = pendingGovernance;\n    }\n\n    IKeep3rV1 public constant KP3R = IKeep3rV1(0x1cEB5cB57C4D4E2b2433641b95Dd330A33185A44);\n    WETH9 public constant WETH = WETH9(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n    IUniswapV2Router public constant UNI = IUniswapV2Router(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\n\n    address public constant factory = 0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f;\n    // this is redundant with granularity and windowSize, but stored for gas savings & informational purposes.\n    uint public constant periodSize = 1800;\n\n    address[] internal _pairs;\n    mapping(address => bool) internal _known;\n\n    function pairs() external view returns (address[] memory) {\n        return _pairs;\n    }\n\n    mapping(address => Observation[]) public observations;\n\n    function observationLength(address pair) external view returns (uint) {\n        return observations[pair].length;\n    }\n\n    function pairFor(address tokenA, address tokenB) external pure returns (address) {\n        return UniswapV2Library.pairFor(factory, tokenA, tokenB);\n    }\n\n    function pairForWETH(address tokenA) external pure returns (address) {\n        return UniswapV2Library.pairFor(factory, tokenA, address(WETH));\n    }\n\n    constructor() public {\n        governance = msg.sender;\n    }\n\n    function updatePair(address pair) external keeper returns (bool) {\n        return _update(pair);\n    }\n\n    function update(address tokenA, address tokenB) external keeper returns (bool) {\n        address pair = UniswapV2Library.pairFor(factory, tokenA, tokenB);\n        return _update(pair);\n    }\n\n    function add(address tokenA, address tokenB) external {\n        require(msg.sender == governance, \"UniswapV2Oracle::add: !gov\");\n        address pair = UniswapV2Library.pairFor(factory, tokenA, tokenB);\n        require(!_known[pair], \"known\");\n        _known[pair] = true;\n        _pairs.push(pair);\n\n        (uint price0Cumulative, uint price1Cumulative,) = UniswapV2OracleLibrary.currentCumulativePrices(pair);\n        observations[pair].push(Observation(block.timestamp, price0Cumulative, price1Cumulative));\n    }\n\n    function work() public upkeep {\n        bool worked = _updateAll();\n        require(worked, \"UniswapV2Oracle: !work\");\n    }\n\n    function workForFree() public keeper {\n        bool worked = _updateAll();\n        require(worked, \"UniswapV2Oracle: !work\");\n    }\n\n    function lastObservation(address pair) public view returns (Observation memory) {\n        return observations[pair][observations[pair].length-1];\n    }\n\n    function _updateAll() internal returns (bool updated) {\n        // SWC-128-DoS With Block Gas Limit: L584 - L588\n        for (uint i = 0; i < _pairs.length; i++) {\n            if (_update(_pairs[i])) {\n                updated = true;\n            }\n        }\n    }\n\n    function updateFor(uint i, uint length) external keeper returns (bool updated) {\n        for (; i < length; i++) {\n            if (_update(_pairs[i])) {\n                updated = true;\n            }\n        }\n    }\n\n    function workable(address pair) public view returns (bool) {\n        return (block.timestamp - lastObservation(pair).timestamp) > periodSize;\n    }\n\n    function workable() external view returns (bool) {\n        // SWC-128-DoS With Block Gas Limit: L604 - L609\n        for (uint i = 0; i < _pairs.length; i++) {\n            if (workable(_pairs[i])) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function _update(address pair) internal returns (bool) {\n        // we only want to commit updates once per period (i.e. windowSize / granularity)\n        Observation memory _point = lastObservation(pair);\n        uint timeElapsed = block.timestamp - _point.timestamp;\n        if (timeElapsed > periodSize) {\n            (uint price0Cumulative, uint price1Cumulative,) = UniswapV2OracleLibrary.currentCumulativePrices(pair);\n            observations[pair].push(Observation(block.timestamp, price0Cumulative, price1Cumulative));\n            return true;\n        }\n        return false;\n    }\n\n    function computeAmountOut(\n        uint priceCumulativeStart, uint priceCumulativeEnd,\n        uint timeElapsed, uint amountIn\n    ) private pure returns (uint amountOut) {\n        // overflow is desired.\n        FixedPoint.uq112x112 memory priceAverage = FixedPoint.uq112x112(\n            // SWC-101-Integer Overflow and Underflow: L630\n            uint224((priceCumulativeEnd - priceCumulativeStart) / timeElapsed)\n        );\n        amountOut = priceAverage.mul(amountIn).decode144();\n    }\n\n    function _valid(address pair, uint age) internal view returns (bool) {\n        return (block.timestamp - lastObservation(pair).timestamp) <= age;\n    }\n\n    function current(address tokenIn, uint amountIn, address tokenOut) external view returns (uint amountOut) {\n        address pair = UniswapV2Library.pairFor(factory, tokenIn, tokenOut);\n        require(_valid(pair, periodSize.mul(2)), \"UniswapV2Oracle::quote: stale prices\");\n        (address token0,) = UniswapV2Library.sortTokens(tokenIn, tokenOut);\n\n        Observation memory _observation = lastObservation(pair);\n        (uint price0Cumulative, uint price1Cumulative,) = UniswapV2OracleLibrary.currentCumulativePrices(pair);\n        if (block.timestamp == _observation.timestamp) {\n            _observation = observations[pair][observations[pair].length-2];\n        }\n\n        // SWC-101-Integer Overflow and Underflow: L651\n        uint timeElapsed = block.timestamp - _observation.timestamp;\n        timeElapsed = timeElapsed == 0 ? 1 : timeElapsed;\n        if (token0 == tokenIn) {\n            return computeAmountOut(_observation.price0Cumulative, price0Cumulative, timeElapsed, amountIn);\n        } else {\n            return computeAmountOut(_observation.price1Cumulative, price1Cumulative, timeElapsed, amountIn);\n        }\n    }\n\n    function quote(address tokenIn, uint amountIn, address tokenOut, uint granularity) external view returns (uint amountOut) {\n        address pair = UniswapV2Library.pairFor(factory, tokenIn, tokenOut);\n        require(_valid(pair, periodSize.mul(granularity)), \"UniswapV2Oracle::quote: stale prices\");\n        (address token0,) = UniswapV2Library.sortTokens(tokenIn, tokenOut);\n\n        uint priceAverageCumulative = 0;\n        // SWC-124-Write to Arbitrary Storage Location: L669\n        uint length = observations[pair].length-1;\n        uint i = length.sub(granularity);\n\n\n        uint nextIndex = 0;\n        if (token0 == tokenIn) {\n            // SWC-128-DoS With Block Gas Limit: L674 - L683\n            for (; i < length; i++) {\n                // SWC-101-Integer Overflow and Underflow: L675\n                nextIndex = i+1;\n                priceAverageCumulative += computeAmountOut(\n                    observations[pair][i].price0Cumulative,\n                    observations[pair][nextIndex].price0Cumulative,\n                    // SWC-101-Integer Overflow and Underflow: L679\n                    observations[pair][nextIndex].timestamp - observations[pair][i].timestamp, amountIn);\n            }\n        } else {\n            for (; i < length; i++) {\n                // SWC-128-DoS With Block Gas Limit: L685 - L694\n                nextIndex = i+1;\n                // SWC-101-Integer Overflow and Underflow: L685\n                priceAverageCumulative += computeAmountOut(\n                    observations[pair][i].price1Cumulative,\n                    observations[pair][nextIndex].price1Cumulative,\n                    // SWC-101-Integer Overflow and Underflow: L689\n                    observations[pair][nextIndex].timestamp - observations[pair][i].timestamp, amountIn);\n            }\n        }\n        return priceAverageCumulative.div(granularity);\n    }\n\n    function prices(address tokenIn, uint amountIn, address tokenOut, uint points) external view returns (uint[] memory) {\n        return sample(tokenIn, amountIn, tokenOut, points, 1);\n    }\n\n    function sample(address tokenIn, uint amountIn, address tokenOut, uint points, uint window) public view returns (uint[] memory) {\n        address pair = UniswapV2Library.pairFor(factory, tokenIn, tokenOut);\n        (address token0,) = UniswapV2Library.sortTokens(tokenIn, tokenOut);\n        uint[] memory _prices = new uint[](points);\n\n        uint length = observations[pair].length-1;\n        uint i = length.sub(points * window);\n        uint nextIndex = 0;\n        uint index = 0;\n\n        if (token0 == tokenIn) {\n            for (; i < length; i+=window) {\n                // SWC-128-DoS With Block Gas Limit: L714 - L724\n                // SWC-101-Integer Overflow and Underflow: L712\n                nextIndex = i + window;\n                _prices[index] = computeAmountOut(\n                    // SWC-124-Write to Arbitrary Storage Location: L720, L721\n                    observations[pair][i].price0Cumulative,\n                    observations[pair][nextIndex].price0Cumulative,\n                    // SWC-101-Integer Overflow and Underflow: L717\n                    observations[pair][nextIndex].timestamp - observations[pair][i].timestamp, amountIn);\n                index = index + 1;\n            }\n        } else {\n            for (; i < length; i+=window) {\n                // SWC-128-DoS With Block Gas Limit: L726 - 736\n                // SWC-101-Integer Overflow and Underflow: L723\n                nextIndex = i + window;\n                _prices[index] = computeAmountOut(\n                    // SWC-124-Write to Arbitrary Storage Location: L733, L734\n                    observations[pair][i].price1Cumulative,\n                    observations[pair][nextIndex].price1Cumulative,\n                    // SWC-101-Integer Overflow and Underflow: L728\n                    observations[pair][nextIndex].timestamp - observations[pair][i].timestamp, amountIn);\n                index = index + 1;\n            }\n        }\n        return _prices;\n    }\n\n    function hourly(address tokenIn, uint amountIn, address tokenOut, uint points) external view returns (uint[] memory) {\n        return sample(tokenIn, amountIn, tokenOut, points, 2);\n    }\n\n    function daily(address tokenIn, uint amountIn, address tokenOut, uint points) external view returns (uint[] memory) {\n        return sample(tokenIn, amountIn, tokenOut, points, 48);\n    }\n\n    function weekly(address tokenIn, uint amountIn, address tokenOut, uint points) external view returns (uint[] memory) {\n        return sample(tokenIn, amountIn, tokenOut, points, 336);\n    }\n\n    function realizedVolatility(address tokenIn, uint amountIn, address tokenOut, uint points, uint window) external view returns (uint) {\n        return stddev(sample(tokenIn, amountIn, tokenOut, points, window));\n    }\n\n    function realizedVolatilityHourly(address tokenIn, uint amountIn, address tokenOut) external view returns (uint) {\n        return stddev(sample(tokenIn, amountIn, tokenOut, 1, 2));\n    }\n\n    function realizedVolatilityDaily(address tokenIn, uint amountIn, address tokenOut) external view returns (uint) {\n        return stddev(sample(tokenIn, amountIn, tokenOut, 1, 48));\n    }\n\n    function realizedVolatilityWeekly(address tokenIn, uint amountIn, address tokenOut) external view returns (uint) {\n        return stddev(sample(tokenIn, amountIn, tokenOut, 1, 336));\n    }\n\n    /**\n     * @dev sqrt calculates the square root of a given number x\n     * @dev for precision into decimals the number must first\n     * @dev be multiplied by the precision factor desired\n     * @param x uint256 number for the calculation of square root\n     */\n    function sqrt(uint256 x) public pure returns (uint256) {\n        // SWC-101-Integer Overflow and Underflow: L770 - L776\n        uint256 c = (x + 1) / 2;\n        uint256 b = x;\n        while (c < b) {\n            b = c;\n            c = (x / c + c) / 2;\n        }\n        return b;\n    }\n\n    /**\n     * @dev stddev calculates the standard deviation for an array of integers\n     * @dev precision is the same as sqrt above meaning for higher precision\n     * @dev the decimal place must be moved prior to passing the params\n     * @param numbers uint[] array of numbers to be used in calculation\n     */\n     // SWC-101-Integer Overflow and Underflow: L790 - L798\n    function stddev(uint[] memory numbers) public pure returns (uint256 sd) {\n        uint sum = 0;\n        for(uint i = 0; i < numbers.length; i++) {\n            sum += numbers[i];\n        }\n        uint256 mean = sum / numbers.length;        // Integral value; float not supported in Solidity\n        sum = 0;\n        uint i;\n        for(i = 0; i < numbers.length; i++) {\n            sum += (numbers[i] - mean) ** 2;\n        }\n        sd = sqrt(sum / (numbers.length - 1));      //Integral value; float not supported in Solidity\n        return sd;\n    }\n\n\n    /**\n     * @dev blackScholesEstimate calculates a rough price estimate for an ATM option\n     * @dev input parameters should be transformed prior to being passed to the function\n     * @dev so as to remove decimal places otherwise results will be far less accurate\n     * @param _vol uint256 volatility of the underlying converted to remove decimals\n     * @param _underlying uint256 price of the underlying asset\n     * @param _time uint256 days to expiration in years multiplied to remove decimals\n     */\n    function blackScholesEstimate(\n        uint256 _vol,\n        uint256 _underlying,\n        uint256 _time\n    ) public pure returns (uint256 estimate) {\n        estimate = 40 * _vol * _underlying * sqrt(_time);\n        return estimate;\n    }\n\n    /**\n     * @dev fromReturnsBSestimate first calculates the stddev of an array of price returns\n     * @dev then uses that as the volatility param for the blackScholesEstimate\n     * @param _numbers uint256[] array of price returns for volatility calculation\n     * @param _underlying uint256 price of the underlying asset\n     * @param _time uint256 days to expiration in years multiplied to remove decimals\n     */\n    function retBasedBlackScholesEstimate(\n        uint256[] memory _numbers,\n        uint256 _underlying,\n        uint256 _time\n    ) public pure {\n        uint _vol = stddev(_numbers);\n        blackScholesEstimate(_vol, _underlying, _time);\n    }\n\n    receive() external payable {}\n\n    function _swap(uint _amount) internal returns (uint) {\n        // SWC-104-Unchecked Call Return Value: L848\n        KP3R.approve(address(UNI), _amount);\n\n        address[] memory path = new address[](2);\n        path[0] = address(KP3R);\n        path[1] = address(WETH);\n\n        uint[] memory amounts = UNI.swapExactTokensForTokens(_amount, uint256(0), path, address(this), now.add(1800));\n        WETH.withdraw(amounts[1]);\n        return amounts[1];\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/QuillAudits-Yearn Finance-Yoracle.Link/yoracle.link-faf1309cbe7a05f70b338351315039eb8e5b9c09/contracts/Keep3rV1Oracle.sol",
        "vulnerability": "Assertion Failure",
        "check": "FP",
        "response": "Answer: No\nReason: The contract does not contain assert statements that could fail. The checks use `require`, which reverts the transaction if a condition is not met, but does not cause an assertion failure."
    },
    {
        "code_segment": "contract Keep3rV1Oracle {\n    using FixedPoint for *;\n    using SafeMath for uint;\n\n    struct Observation {\n        uint timestamp;\n        uint price0Cumulative;\n        uint price1Cumulative;\n    }\n\n    uint public minKeep = 200e18;\n\n    modifier keeper() {\n        require(KP3R.isMinKeeper(msg.sender, minKeep, 0, 0), \"::isKeeper: keeper is not registered\");\n        _;\n    }\n\n    modifier upkeep() {\n        uint _gasUsed = gasleft();\n        require(KP3R.isMinKeeper(msg.sender, minKeep, 0, 0), \"::isKeeper: keeper is not registered\");\n        _;\n        uint _received = KP3R.KPRH().getQuoteLimit(_gasUsed.sub(gasleft()));\n        KP3R.receipt(address(KP3R), address(this), _received);\n        _received = _swap(_received);\n        msg.sender.transfer(_received);\n    }\n\n    address public governance;\n    address public pendingGovernance;\n\n    function setMinKeep(uint _keep) external {\n        require(msg.sender == governance, \"setGovernance: !gov\");\n        minKeep = _keep;\n    }\n\n    /**\n     * @notice Allows governance to change governance (for future upgradability)\n     * @param _governance new governance address to set\n     */\n    function setGovernance(address _governance) external {\n        require(msg.sender == governance, \"setGovernance: !gov\");\n        pendingGovernance = _governance;\n    }\n\n    /**\n     * @notice Allows pendingGovernance to accept their role as governance (protection pattern)\n     */\n    function acceptGovernance() external {\n        require(msg.sender == pendingGovernance, \"acceptGovernance: !pendingGov\");\n        governance = pendingGovernance;\n    }\n\n    IKeep3rV1 public constant KP3R = IKeep3rV1(0x1cEB5cB57C4D4E2b2433641b95Dd330A33185A44);\n    WETH9 public constant WETH = WETH9(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n    IUniswapV2Router public constant UNI = IUniswapV2Router(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\n\n    address public constant factory = 0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f;\n    // this is redundant with granularity and windowSize, but stored for gas savings & informational purposes.\n    uint public constant periodSize = 1800;\n\n    address[] internal _pairs;\n    mapping(address => bool) internal _known;\n\n    function pairs() external view returns (address[] memory) {\n        return _pairs;\n    }\n\n    mapping(address => Observation[]) public observations;\n\n    function observationLength(address pair) external view returns (uint) {\n        return observations[pair].length;\n    }\n\n    function pairFor(address tokenA, address tokenB) external pure returns (address) {\n        return UniswapV2Library.pairFor(factory, tokenA, tokenB);\n    }\n\n    function pairForWETH(address tokenA) external pure returns (address) {\n        return UniswapV2Library.pairFor(factory, tokenA, address(WETH));\n    }\n\n    constructor() public {\n        governance = msg.sender;\n    }\n\n    function updatePair(address pair) external keeper returns (bool) {\n        return _update(pair);\n    }\n\n    function update(address tokenA, address tokenB) external keeper returns (bool) {\n        address pair = UniswapV2Library.pairFor(factory, tokenA, tokenB);\n        return _update(pair);\n    }\n\n    function add(address tokenA, address tokenB) external {\n        require(msg.sender == governance, \"UniswapV2Oracle::add: !gov\");\n        address pair = UniswapV2Library.pairFor(factory, tokenA, tokenB);\n        require(!_known[pair], \"known\");\n        _known[pair] = true;\n        _pairs.push(pair);\n\n        (uint price0Cumulative, uint price1Cumulative,) = UniswapV2OracleLibrary.currentCumulativePrices(pair);\n        observations[pair].push(Observation(block.timestamp, price0Cumulative, price1Cumulative));\n    }\n\n    function work() public upkeep {\n        bool worked = _updateAll();\n        require(worked, \"UniswapV2Oracle: !work\");\n    }\n\n    function workForFree() public keeper {\n        bool worked = _updateAll();\n        require(worked, \"UniswapV2Oracle: !work\");\n    }\n\n    function lastObservation(address pair) public view returns (Observation memory) {\n        return observations[pair][observations[pair].length-1];\n    }\n\n    function _updateAll() internal returns (bool updated) {\n        // SWC-128-DoS With Block Gas Limit: L584 - L588\n        for (uint i = 0; i < _pairs.length; i++) {\n            if (_update(_pairs[i])) {\n                updated = true;\n            }\n        }\n    }\n\n    function updateFor(uint i, uint length) external keeper returns (bool updated) {\n        for (; i < length; i++) {\n            if (_update(_pairs[i])) {\n                updated = true;\n            }\n        }\n    }\n\n    function workable(address pair) public view returns (bool) {\n        return (block.timestamp - lastObservation(pair).timestamp) > periodSize;\n    }\n\n    function workable() external view returns (bool) {\n        // SWC-128-DoS With Block Gas Limit: L604 - L609\n        for (uint i = 0; i < _pairs.length; i++) {\n            if (workable(_pairs[i])) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function _update(address pair) internal returns (bool) {\n        // we only want to commit updates once per period (i.e. windowSize / granularity)\n        Observation memory _point = lastObservation(pair);\n        uint timeElapsed = block.timestamp - _point.timestamp;\n        if (timeElapsed > periodSize) {\n            (uint price0Cumulative, uint price1Cumulative,) = UniswapV2OracleLibrary.currentCumulativePrices(pair);\n            observations[pair].push(Observation(block.timestamp, price0Cumulative, price1Cumulative));\n            return true;\n        }\n        return false;\n    }\n\n    function computeAmountOut(\n        uint priceCumulativeStart, uint priceCumulativeEnd,\n        uint timeElapsed, uint amountIn\n    ) private pure returns (uint amountOut) {\n        // overflow is desired.\n        FixedPoint.uq112x112 memory priceAverage = FixedPoint.uq112x112(\n            // SWC-101-Integer Overflow and Underflow: L630\n            uint224((priceCumulativeEnd - priceCumulativeStart) / timeElapsed)\n        );\n        amountOut = priceAverage.mul(amountIn).decode144();\n    }\n\n    function _valid(address pair, uint age) internal view returns (bool) {\n        return (block.timestamp - lastObservation(pair).timestamp) <= age;\n    }\n\n    function current(address tokenIn, uint amountIn, address tokenOut) external view returns (uint amountOut) {\n        address pair = UniswapV2Library.pairFor(factory, tokenIn, tokenOut);\n        require(_valid(pair, periodSize.mul(2)), \"UniswapV2Oracle::quote: stale prices\");\n        (address token0,) = UniswapV2Library.sortTokens(tokenIn, tokenOut);\n\n        Observation memory _observation = lastObservation(pair);\n        (uint price0Cumulative, uint price1Cumulative,) = UniswapV2OracleLibrary.currentCumulativePrices(pair);\n        if (block.timestamp == _observation.timestamp) {\n            _observation = observations[pair][observations[pair].length-2];\n        }\n\n        // SWC-101-Integer Overflow and Underflow: L651\n        uint timeElapsed = block.timestamp - _observation.timestamp;\n        timeElapsed = timeElapsed == 0 ? 1 : timeElapsed;\n        if (token0 == tokenIn) {\n            return computeAmountOut(_observation.price0Cumulative, price0Cumulative, timeElapsed, amountIn);\n        } else {\n            return computeAmountOut(_observation.price1Cumulative, price1Cumulative, timeElapsed, amountIn);\n        }\n    }\n\n    function quote(address tokenIn, uint amountIn, address tokenOut, uint granularity) external view returns (uint amountOut) {\n        address pair = UniswapV2Library.pairFor(factory, tokenIn, tokenOut);\n        require(_valid(pair, periodSize.mul(granularity)), \"UniswapV2Oracle::quote: stale prices\");\n        (address token0,) = UniswapV2Library.sortTokens(tokenIn, tokenOut);\n\n        uint priceAverageCumulative = 0;\n        // SWC-124-Write to Arbitrary Storage Location: L669\n        uint length = observations[pair].length-1;\n        uint i = length.sub(granularity);\n\n\n        uint nextIndex = 0;\n        if (token0 == tokenIn) {\n            // SWC-128-DoS With Block Gas Limit: L674 - L683\n            for (; i < length; i++) {\n                // SWC-101-Integer Overflow and Underflow: L675\n                nextIndex = i+1;\n                priceAverageCumulative += computeAmountOut(\n                    observations[pair][i].price0Cumulative,\n                    observations[pair][nextIndex].price0Cumulative,\n                    // SWC-101-Integer Overflow and Underflow: L679\n                    observations[pair][nextIndex].timestamp - observations[pair][i].timestamp, amountIn);\n            }\n        } else {\n            for (; i < length; i++) {\n                // SWC-128-DoS With Block Gas Limit: L685 - L694\n                nextIndex = i+1;\n                // SWC-101-Integer Overflow and Underflow: L685\n                priceAverageCumulative += computeAmountOut(\n                    observations[pair][i].price1Cumulative,\n                    observations[pair][nextIndex].price1Cumulative,\n                    // SWC-101-Integer Overflow and Underflow: L689\n                    observations[pair][nextIndex].timestamp - observations[pair][i].timestamp, amountIn);\n            }\n        }\n        return priceAverageCumulative.div(granularity);\n    }\n\n    function prices(address tokenIn, uint amountIn, address tokenOut, uint points) external view returns (uint[] memory) {\n        return sample(tokenIn, amountIn, tokenOut, points, 1);\n    }\n\n    function sample(address tokenIn, uint amountIn, address tokenOut, uint points, uint window) public view returns (uint[] memory) {\n        address pair = UniswapV2Library.pairFor(factory, tokenIn, tokenOut);\n        (address token0,) = UniswapV2Library.sortTokens(tokenIn, tokenOut);\n        uint[] memory _prices = new uint[](points);\n\n        uint length = observations[pair].length-1;\n        uint i = length.sub(points * window);\n        uint nextIndex = 0;\n        uint index = 0;\n\n        if (token0 == tokenIn) {\n            for (; i < length; i+=window) {\n                // SWC-128-DoS With Block Gas Limit: L714 - L724\n                // SWC-101-Integer Overflow and Underflow: L712\n                nextIndex = i + window;\n                _prices[index] = computeAmountOut(\n                    // SWC-124-Write to Arbitrary Storage Location: L720, L721\n                    observations[pair][i].price0Cumulative,\n                    observations[pair][nextIndex].price0Cumulative,\n                    // SWC-101-Integer Overflow and Underflow: L717\n                    observations[pair][nextIndex].timestamp - observations[pair][i].timestamp, amountIn);\n                index = index + 1;\n            }\n        } else {\n            for (; i < length; i+=window) {\n                // SWC-128-DoS With Block Gas Limit: L726 - 736\n                // SWC-101-Integer Overflow and Underflow: L723\n                nextIndex = i + window;\n                _prices[index] = computeAmountOut(\n                    // SWC-124-Write to Arbitrary Storage Location: L733, L734\n                    observations[pair][i].price1Cumulative,\n                    observations[pair][nextIndex].price1Cumulative,\n                    // SWC-101-Integer Overflow and Underflow: L728\n                    observations[pair][nextIndex].timestamp - observations[pair][i].timestamp, amountIn);\n                index = index + 1;\n            }\n        }\n        return _prices;\n    }\n\n    function hourly(address tokenIn, uint amountIn, address tokenOut, uint points) external view returns (uint[] memory) {\n        return sample(tokenIn, amountIn, tokenOut, points, 2);\n    }\n\n    function daily(address tokenIn, uint amountIn, address tokenOut, uint points) external view returns (uint[] memory) {\n        return sample(tokenIn, amountIn, tokenOut, points, 48);\n    }\n\n    function weekly(address tokenIn, uint amountIn, address tokenOut, uint points) external view returns (uint[] memory) {\n        return sample(tokenIn, amountIn, tokenOut, points, 336);\n    }\n\n    function realizedVolatility(address tokenIn, uint amountIn, address tokenOut, uint points, uint window) external view returns (uint) {\n        return stddev(sample(tokenIn, amountIn, tokenOut, points, window));\n    }\n\n    function realizedVolatilityHourly(address tokenIn, uint amountIn, address tokenOut) external view returns (uint) {\n        return stddev(sample(tokenIn, amountIn, tokenOut, 1, 2));\n    }\n\n    function realizedVolatilityDaily(address tokenIn, uint amountIn, address tokenOut) external view returns (uint) {\n        return stddev(sample(tokenIn, amountIn, tokenOut, 1, 48));\n    }\n\n    function realizedVolatilityWeekly(address tokenIn, uint amountIn, address tokenOut) external view returns (uint) {\n        return stddev(sample(tokenIn, amountIn, tokenOut, 1, 336));\n    }\n\n    /**\n     * @dev sqrt calculates the square root of a given number x\n     * @dev for precision into decimals the number must first\n     * @dev be multiplied by the precision factor desired\n     * @param x uint256 number for the calculation of square root\n     */\n    function sqrt(uint256 x) public pure returns (uint256) {\n        // SWC-101-Integer Overflow and Underflow: L770 - L776\n        uint256 c = (x + 1) / 2;\n        uint256 b = x;\n        while (c < b) {\n            b = c;\n            c = (x / c + c) / 2;\n        }\n        return b;\n    }\n\n    /**\n     * @dev stddev calculates the standard deviation for an array of integers\n     * @dev precision is the same as sqrt above meaning for higher precision\n     * @dev the decimal place must be moved prior to passing the params\n     * @param numbers uint[] array of numbers to be used in calculation\n     */\n     // SWC-101-Integer Overflow and Underflow: L790 - L798\n    function stddev(uint[] memory numbers) public pure returns (uint256 sd) {\n        uint sum = 0;\n        for(uint i = 0; i < numbers.length; i++) {\n            sum += numbers[i];\n        }\n        uint256 mean = sum / numbers.length;        // Integral value; float not supported in Solidity\n        sum = 0;\n        uint i;\n        for(i = 0; i < numbers.length; i++) {\n            sum += (numbers[i] - mean) ** 2;\n        }\n        sd = sqrt(sum / (numbers.length - 1));      //Integral value; float not supported in Solidity\n        return sd;\n    }\n\n\n    /**\n     * @dev blackScholesEstimate calculates a rough price estimate for an ATM option\n     * @dev input parameters should be transformed prior to being passed to the function\n     * @dev so as to remove decimal places otherwise results will be far less accurate\n     * @param _vol uint256 volatility of the underlying converted to remove decimals\n     * @param _underlying uint256 price of the underlying asset\n     * @param _time uint256 days to expiration in years multiplied to remove decimals\n     */\n    function blackScholesEstimate(\n        uint256 _vol,\n        uint256 _underlying,\n        uint256 _time\n    ) public pure returns (uint256 estimate) {\n        estimate = 40 * _vol * _underlying * sqrt(_time);\n        return estimate;\n    }\n\n    /**\n     * @dev fromReturnsBSestimate first calculates the stddev of an array of price returns\n     * @dev then uses that as the volatility param for the blackScholesEstimate\n     * @param _numbers uint256[] array of price returns for volatility calculation\n     * @param _underlying uint256 price of the underlying asset\n     * @param _time uint256 days to expiration in years multiplied to remove decimals\n     */\n    function retBasedBlackScholesEstimate(\n        uint256[] memory _numbers,\n        uint256 _underlying,\n        uint256 _time\n    ) public pure {\n        uint _vol = stddev(_numbers);\n        blackScholesEstimate(_vol, _underlying, _time);\n    }\n\n    receive() external payable {}\n\n    function _swap(uint _amount) internal returns (uint) {\n        // SWC-104-Unchecked Call Return Value: L848\n        KP3R.approve(address(UNI), _amount);\n\n        address[] memory path = new address[](2);\n        path[0] = address(KP3R);\n        path[1] = address(WETH);\n\n        uint[] memory amounts = UNI.swapExactTokensForTokens(_amount, uint256(0), path, address(this), now.add(1800));\n        WETH.withdraw(amounts[1]);\n        return amounts[1];\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/QuillAudits-Yearn Finance-Yoracle.Link/yoracle.link-faf1309cbe7a05f70b338351315039eb8e5b9c09/contracts/Keep3rV1Oracle.sol",
        "vulnerability": "Assertion Failure",
        "check": "FP",
        "response": "Answer: No\nReason: There are no assertions in the code; thus, no assertion failures can occur."
    },
    {
        "code_segment": "contract StandardMintableToken is owned { \n    /* Public variables of the token */\n    string public standard = 'Token 0.1';\n    string public name;                     // the token name \n    string public symbol;                   // the ticker symbol\n    uint8 public decimals;                  // amount of decimal places in the token\n    uint256 public totalSupply;             // total tokens\n    \n    /* This creates an array with all balances */\n    mapping (address => uint256) public balanceOf;\n    mapping (address => mapping (address => uint256)) public allowance;\n    \n    /* This creates an array with all frozen accounts */\n    mapping (address => bool) public frozenAccount;\n\n    /* This generates a public event on the blockchain that will notify clients */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    \n    /* This generates a public event on the blockchain that will notify clients */\n    event FrozenFunds(address target, bool frozen);\n    \n    /* This generates a public event on the blockchain that will notify clients */\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n    /* Initializes contract with initial supply tokens to the creator of the contract */\n    function StandardMintableToken(\n        string tokenName,               // the token name\n        uint8 decimalUnits,             // amount of decimal places in the token\n        string tokenSymbol,             // the token symbol\n        uint256 initialSupply            // the initial distro amount\n        ) {\n\n        balanceOf[msg.sender] = initialSupply;                   // Give the creator all initial tokens\n        totalSupply = initialSupply;                             // Update total supply\n        name = tokenName;                                        // Set the name for display purposes\n        symbol = tokenSymbol;                                    // Set the symbol for display purposes\n        decimals = decimalUnits;                                 // Amount of decimals for display purposes\n    }\n\n    /* Send tokens */\n    function transfer(address _to, uint256 _value) returns (bool success){\n        if (_value == 0) return false; \t\t\t\t             // Don't waste gas on zero-value transaction\n        if (balanceOf[msg.sender] < _value) return false;    // Check if the sender has enough\n        if (balanceOf[_to] + _value < balanceOf[_to]) throw; // Check for overflows\n        if (frozenAccount[msg.sender]) throw;                // Check if sender frozen\n        if (frozenAccount[_to]) throw;                       // Check if recipient frozen                 \n        balanceOf[msg.sender] -= _value;                     // Subtract from the sender\n        balanceOf[_to] += _value;                            // Add the same to the recipient\n        Transfer(msg.sender, _to, _value);                   // Notify anyone listening that this transfer took place\n        return true;\n    }\n\n    /* Allow another contract to spend some tokens on your behalf */\n    function approve(address _spender, uint256 _value)\n        returns (bool success) {\n        allowance[msg.sender][_spender] = _value;            // Update allowance first\n        Approval(msg.sender, _spender, _value);              // Notify of new Approval\n        return true;\n    }\n\n    /* Approve and then communicate the approved contract in a single tx */\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData)\n        returns (bool success) {\n        tokenRecipient spender = tokenRecipient(_spender);\n        if (approve(_spender, _value)) {\n            spender.receiveApproval(msg.sender, _value, this, _extraData);\n            return true;\n        }\n    }        \n\n    /* A contract attempts to get the coins */\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n        if (frozenAccount[_from]) throw;                        // Check if sender frozen       \n        if (frozenAccount[_to]) throw;                          // Check if recipient frozen                 \n        if (balanceOf[_from] < _value) return false;          \t// Check if the sender has enough\n        if (balanceOf[_to] + _value < balanceOf[_to]) throw;    // Check for overflows\n        if (_value > allowance[_from][msg.sender]) throw;       // Check allowance\n        balanceOf[_from] -= _value;                             // Subtract from the sender\n        balanceOf[_to] += _value;                               // Add the same to the recipient\n        allowance[_from][msg.sender] -= _value;                 // Update sender's allowance \n        Transfer(_from, _to, _value);                           // Perform the transfer\n        return true;\n    }\n    \n    /* A function to freeze or un-freeze accounts, to and from */\n    \n    function freezeAccount(address target, bool freeze ) onlyOwner {    \n        frozenAccount[target] = freeze;                       // set the array object to the value of bool freeze\n        FrozenFunds(target, freeze);                          // notify event\n    }\n    \n\n    /* A function to burn tokens and remove from supply */\n    \n    function burn(uint256 _value) returns (bool success) {\n        if (frozenAccount[msg.sender]) throw;                 // Check if sender frozen       \n        if (_value == 0) return false; \t\t\t\t          // Don't waste gas on zero-value transaction\n        if (balanceOf[msg.sender] < _value) return false;     // Check if the sender has enough\n        balanceOf[msg.sender] -= _value;                      // Subtract from the sender\n        totalSupply -= _value;                                // Updates totalSupply\n        Transfer(msg.sender,0, _value);\t                      // Burn _value tokens\n        return true;\n    }\n\n    function burnFrom(address _from, uint256 _value) onlyOwner returns (bool success) {\n        if (frozenAccount[msg.sender]) throw;                // Check if sender frozen       \n        if (frozenAccount[_from]) throw;                     // Check if recipient frozen \n        if (_value == 0) return false; \t\t\t             // Don't waste gas on zero-value transaction\n        if (balanceOf[_from] < _value) return false;         // Check if the sender has enough\n        if (_value > allowance[_from][msg.sender]) throw;    // Check allowance\n        balanceOf[_from] -= _value;                          // Subtract from the sender\n        totalSupply -= _value;                               // Updates totalSupply\n        allowance[_from][msg.sender] -= _value;\t\t\t\t // Updates allowance\n        Transfer(_from, 0, _value);                          // Burn tokens by Transfer to incinerator\n        return true;\n    }\n    \n    /* A function to add more tokens to the total supply, accessible only to owner*/\n    // SWC-101-Integer Overflow and Underflow\n    function mintToken(address target, uint256 mintedAmount) onlyOwner {\n        if (balanceOf[target] + mintedAmount < balanceOf[target]) throw; // Check for overflows\n        balanceOf[target] += mintedAmount;\n        totalSupply += mintedAmount;\n        Transfer(0, target, mintedAmount);\n\n    }\n    \n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Blockchain Labs NZ-Earth/Back-to-Earth-audit-master/contracts/GTKT_GoldTickets.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: Yes\nDescription: The contract does not use SafeMath library to handle arithmetic operations, which makes it susceptible to integer overflow vulnerabilities when increasing balances or totalSupply."
    },
    {
        "code_segment": "contract StandardMintableToken is owned { \n    /* Public variables of the token */\n    string public standard = 'Token 0.1';\n    string public name;                     // the token name \n    string public symbol;                   // the ticker symbol\n    uint8 public decimals;                  // amount of decimal places in the token\n    uint256 public totalSupply;             // total tokens\n    \n    /* This creates an array with all balances */\n    mapping (address => uint256) public balanceOf;\n    mapping (address => mapping (address => uint256)) public allowance;\n    \n    /* This creates an array with all frozen accounts */\n    mapping (address => bool) public frozenAccount;\n\n    /* This generates a public event on the blockchain that will notify clients */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    \n    /* This generates a public event on the blockchain that will notify clients */\n    event FrozenFunds(address target, bool frozen);\n    \n    /* This generates a public event on the blockchain that will notify clients */\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n    /* Initializes contract with initial supply tokens to the creator of the contract */\n    function StandardMintableToken(\n        string tokenName,               // the token name\n        uint8 decimalUnits,             // amount of decimal places in the token\n        string tokenSymbol,             // the token symbol\n        uint256 initialSupply            // the initial distro amount\n        ) {\n\n        balanceOf[msg.sender] = initialSupply;                   // Give the creator all initial tokens\n        totalSupply = initialSupply;                             // Update total supply\n        name = tokenName;                                        // Set the name for display purposes\n        symbol = tokenSymbol;                                    // Set the symbol for display purposes\n        decimals = decimalUnits;                                 // Amount of decimals for display purposes\n    }\n\n    /* Send tokens */\n    function transfer(address _to, uint256 _value) returns (bool success){\n        if (_value == 0) return false; \t\t\t\t             // Don't waste gas on zero-value transaction\n        if (balanceOf[msg.sender] < _value) return false;    // Check if the sender has enough\n        if (balanceOf[_to] + _value < balanceOf[_to]) throw; // Check for overflows\n        if (frozenAccount[msg.sender]) throw;                // Check if sender frozen\n        if (frozenAccount[_to]) throw;                       // Check if recipient frozen                 \n        balanceOf[msg.sender] -= _value;                     // Subtract from the sender\n        balanceOf[_to] += _value;                            // Add the same to the recipient\n        Transfer(msg.sender, _to, _value);                   // Notify anyone listening that this transfer took place\n        return true;\n    }\n\n    /* Allow another contract to spend some tokens on your behalf */\n    function approve(address _spender, uint256 _value)\n        returns (bool success) {\n        allowance[msg.sender][_spender] = _value;            // Update allowance first\n        Approval(msg.sender, _spender, _value);              // Notify of new Approval\n        return true;\n    }\n\n    /* Approve and then communicate the approved contract in a single tx */\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData)\n        returns (bool success) {\n        tokenRecipient spender = tokenRecipient(_spender);\n        if (approve(_spender, _value)) {\n            spender.receiveApproval(msg.sender, _value, this, _extraData);\n            return true;\n        }\n    }        \n\n    /* A contract attempts to get the coins */\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n        if (frozenAccount[_from]) throw;                        // Check if sender frozen       \n        if (frozenAccount[_to]) throw;                          // Check if recipient frozen                 \n        if (balanceOf[_from] < _value) return false;          \t// Check if the sender has enough\n        if (balanceOf[_to] + _value < balanceOf[_to]) throw;    // Check for overflows\n        if (_value > allowance[_from][msg.sender]) throw;       // Check allowance\n        balanceOf[_from] -= _value;                             // Subtract from the sender\n        balanceOf[_to] += _value;                               // Add the same to the recipient\n        allowance[_from][msg.sender] -= _value;                 // Update sender's allowance \n        Transfer(_from, _to, _value);                           // Perform the transfer\n        return true;\n    }\n    \n    /* A function to freeze or un-freeze accounts, to and from */\n    \n    function freezeAccount(address target, bool freeze ) onlyOwner {    \n        frozenAccount[target] = freeze;                       // set the array object to the value of bool freeze\n        FrozenFunds(target, freeze);                          // notify event\n    }\n    \n\n    /* A function to burn tokens and remove from supply */\n    \n    function burn(uint256 _value) returns (bool success) {\n        if (frozenAccount[msg.sender]) throw;                 // Check if sender frozen       \n        if (_value == 0) return false; \t\t\t\t          // Don't waste gas on zero-value transaction\n        if (balanceOf[msg.sender] < _value) return false;     // Check if the sender has enough\n        balanceOf[msg.sender] -= _value;                      // Subtract from the sender\n        totalSupply -= _value;                                // Updates totalSupply\n        Transfer(msg.sender,0, _value);\t                      // Burn _value tokens\n        return true;\n    }\n\n    function burnFrom(address _from, uint256 _value) onlyOwner returns (bool success) {\n        if (frozenAccount[msg.sender]) throw;                // Check if sender frozen       \n        if (frozenAccount[_from]) throw;                     // Check if recipient frozen \n        if (_value == 0) return false; \t\t\t             // Don't waste gas on zero-value transaction\n        if (balanceOf[_from] < _value) return false;         // Check if the sender has enough\n        if (_value > allowance[_from][msg.sender]) throw;    // Check allowance\n        balanceOf[_from] -= _value;                          // Subtract from the sender\n        totalSupply -= _value;                               // Updates totalSupply\n        allowance[_from][msg.sender] -= _value;\t\t\t\t // Updates allowance\n        Transfer(_from, 0, _value);                          // Burn tokens by Transfer to incinerator\n        return true;\n    }\n    \n    /* A function to add more tokens to the total supply, accessible only to owner*/\n    // SWC-101-Integer Overflow and Underflow\n    function mintToken(address target, uint256 mintedAmount) onlyOwner {\n        if (balanceOf[target] + mintedAmount < balanceOf[target]) throw; // Check for overflows\n        balanceOf[target] += mintedAmount;\n        totalSupply += mintedAmount;\n        Transfer(0, target, mintedAmount);\n\n    }\n    \n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Blockchain Labs NZ-Earth/Back-to-Earth-audit-master/contracts/GTKT_GoldTickets.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: Yes\nDescription: The code contains potential integer overflow vulnerabilities, particularly in the `mintToken` function where the addition of mintedAmount to balanceOf[target] is checked, but not the addition to totalSupply."
    },
    {
        "code_segment": "contract StandardMintableToken is owned { \n    /* Public variables of the token */\n    string public standard = 'Token 0.1';\n    string public name;                     // the token name \n    string public symbol;                   // the ticker symbol\n    uint8 public decimals;                  // amount of decimal places in the token\n    uint256 public totalSupply;             // total tokens\n    \n    /* This creates an array with all balances */\n    mapping (address => uint256) public balanceOf;\n    mapping (address => mapping (address => uint256)) public allowance;\n    \n    /* This creates an array with all frozen accounts */\n    mapping (address => bool) public frozenAccount;\n\n    /* This generates a public event on the blockchain that will notify clients */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    \n    /* This generates a public event on the blockchain that will notify clients */\n    event FrozenFunds(address target, bool frozen);\n    \n    /* This generates a public event on the blockchain that will notify clients */\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n    /* Initializes contract with initial supply tokens to the creator of the contract */\n    function StandardMintableToken(\n        string tokenName,               // the token name\n        uint8 decimalUnits,             // amount of decimal places in the token\n        string tokenSymbol,             // the token symbol\n        uint256 initialSupply            // the initial distro amount\n        ) {\n\n        balanceOf[msg.sender] = initialSupply;                   // Give the creator all initial tokens\n        totalSupply = initialSupply;                             // Update total supply\n        name = tokenName;                                        // Set the name for display purposes\n        symbol = tokenSymbol;                                    // Set the symbol for display purposes\n        decimals = decimalUnits;                                 // Amount of decimals for display purposes\n    }\n\n    /* Send tokens */\n    function transfer(address _to, uint256 _value) returns (bool success){\n        if (_value == 0) return false; \t\t\t\t             // Don't waste gas on zero-value transaction\n        if (balanceOf[msg.sender] < _value) return false;    // Check if the sender has enough\n        if (balanceOf[_to] + _value < balanceOf[_to]) throw; // Check for overflows\n        if (frozenAccount[msg.sender]) throw;                // Check if sender frozen\n        if (frozenAccount[_to]) throw;                       // Check if recipient frozen                 \n        balanceOf[msg.sender] -= _value;                     // Subtract from the sender\n        balanceOf[_to] += _value;                            // Add the same to the recipient\n        Transfer(msg.sender, _to, _value);                   // Notify anyone listening that this transfer took place\n        return true;\n    }\n\n    /* Allow another contract to spend some tokens on your behalf */\n    function approve(address _spender, uint256 _value)\n        returns (bool success) {\n        allowance[msg.sender][_spender] = _value;            // Update allowance first\n        Approval(msg.sender, _spender, _value);              // Notify of new Approval\n        return true;\n    }\n\n    /* Approve and then communicate the approved contract in a single tx */\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData)\n        returns (bool success) {\n        tokenRecipient spender = tokenRecipient(_spender);\n        if (approve(_spender, _value)) {\n            spender.receiveApproval(msg.sender, _value, this, _extraData);\n            return true;\n        }\n    }        \n\n    /* A contract attempts to get the coins */\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n        if (frozenAccount[_from]) throw;                        // Check if sender frozen       \n        if (frozenAccount[_to]) throw;                          // Check if recipient frozen                 \n        if (balanceOf[_from] < _value) return false;          \t// Check if the sender has enough\n        if (balanceOf[_to] + _value < balanceOf[_to]) throw;    // Check for overflows\n        if (_value > allowance[_from][msg.sender]) throw;       // Check allowance\n        balanceOf[_from] -= _value;                             // Subtract from the sender\n        balanceOf[_to] += _value;                               // Add the same to the recipient\n        allowance[_from][msg.sender] -= _value;                 // Update sender's allowance \n        Transfer(_from, _to, _value);                           // Perform the transfer\n        return true;\n    }\n    \n    /* A function to freeze or un-freeze accounts, to and from */\n    \n    function freezeAccount(address target, bool freeze ) onlyOwner {    \n        frozenAccount[target] = freeze;                       // set the array object to the value of bool freeze\n        FrozenFunds(target, freeze);                          // notify event\n    }\n    \n\n    /* A function to burn tokens and remove from supply */\n    \n    function burn(uint256 _value) returns (bool success) {\n        if (frozenAccount[msg.sender]) throw;                 // Check if sender frozen       \n        if (_value == 0) return false; \t\t\t\t          // Don't waste gas on zero-value transaction\n        if (balanceOf[msg.sender] < _value) return false;     // Check if the sender has enough\n        balanceOf[msg.sender] -= _value;                      // Subtract from the sender\n        totalSupply -= _value;                                // Updates totalSupply\n        Transfer(msg.sender,0, _value);\t                      // Burn _value tokens\n        return true;\n    }\n\n    function burnFrom(address _from, uint256 _value) onlyOwner returns (bool success) {\n        if (frozenAccount[msg.sender]) throw;                // Check if sender frozen       \n        if (frozenAccount[_from]) throw;                     // Check if recipient frozen \n        if (_value == 0) return false; \t\t\t             // Don't waste gas on zero-value transaction\n        if (balanceOf[_from] < _value) return false;         // Check if the sender has enough\n        if (_value > allowance[_from][msg.sender]) throw;    // Check allowance\n        balanceOf[_from] -= _value;                          // Subtract from the sender\n        totalSupply -= _value;                               // Updates totalSupply\n        allowance[_from][msg.sender] -= _value;\t\t\t\t // Updates allowance\n        Transfer(_from, 0, _value);                          // Burn tokens by Transfer to incinerator\n        return true;\n    }\n    \n    /* A function to add more tokens to the total supply, accessible only to owner*/\n    // SWC-101-Integer Overflow and Underflow\n    function mintToken(address target, uint256 mintedAmount) onlyOwner {\n        if (balanceOf[target] + mintedAmount < balanceOf[target]) throw; // Check for overflows\n        balanceOf[target] += mintedAmount;\n        totalSupply += mintedAmount;\n        Transfer(0, target, mintedAmount);\n\n    }\n    \n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Blockchain Labs NZ-Earth/Back-to-Earth-audit-master/contracts/GTKT_GoldTickets.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: Yes\nDescription: The code relies on the following pattern to check for overflows `if (balanceOf[_to] + _value < balanceOf[_to]) throw;` which was deprecated in Solidity versions. The mintToken function could potentially lead to an overflow if an incredibly high minted amount is added to the total supply. It would be better to use Solidity's SafeMath library to handle these operations securely."
    },
    {
        "code_segment": "contract StandardMintableToken is owned { \n    /* Public variables of the token */\n    string public standard = 'Token 0.1';\n    string public name;                     // the token name \n    string public symbol;                   // the ticker symbol\n    uint8 public decimals;                  // amount of decimal places in the token\n    uint256 public totalSupply;             // total tokens\n    \n    /* This creates an array with all balances */\n    mapping (address => uint256) public balanceOf;\n    mapping (address => mapping (address => uint256)) public allowance;\n    \n    /* This creates an array with all frozen accounts */\n    mapping (address => bool) public frozenAccount;\n\n    /* This generates a public event on the blockchain that will notify clients */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    \n    /* This generates a public event on the blockchain that will notify clients */\n    event FrozenFunds(address target, bool frozen);\n    \n    /* This generates a public event on the blockchain that will notify clients */\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n    /* Initializes contract with initial supply tokens to the creator of the contract */\n    function StandardMintableToken(\n        string tokenName,               // the token name\n        uint8 decimalUnits,             // amount of decimal places in the token\n        string tokenSymbol,             // the token symbol\n        uint256 initialSupply            // the initial distro amount\n        ) {\n\n        balanceOf[msg.sender] = initialSupply;                   // Give the creator all initial tokens\n        totalSupply = initialSupply;                             // Update total supply\n        name = tokenName;                                        // Set the name for display purposes\n        symbol = tokenSymbol;                                    // Set the symbol for display purposes\n        decimals = decimalUnits;                                 // Amount of decimals for display purposes\n    }\n\n    /* Send tokens */\n    function transfer(address _to, uint256 _value) returns (bool success){\n        if (_value == 0) return false; \t\t\t\t             // Don't waste gas on zero-value transaction\n        if (balanceOf[msg.sender] < _value) return false;    // Check if the sender has enough\n        if (balanceOf[_to] + _value < balanceOf[_to]) throw; // Check for overflows\n        if (frozenAccount[msg.sender]) throw;                // Check if sender frozen\n        if (frozenAccount[_to]) throw;                       // Check if recipient frozen                 \n        balanceOf[msg.sender] -= _value;                     // Subtract from the sender\n        balanceOf[_to] += _value;                            // Add the same to the recipient\n        Transfer(msg.sender, _to, _value);                   // Notify anyone listening that this transfer took place\n        return true;\n    }\n\n    /* Allow another contract to spend some tokens on your behalf */\n    function approve(address _spender, uint256 _value)\n        returns (bool success) {\n        allowance[msg.sender][_spender] = _value;            // Update allowance first\n        Approval(msg.sender, _spender, _value);              // Notify of new Approval\n        return true;\n    }\n\n    /* Approve and then communicate the approved contract in a single tx */\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData)\n        returns (bool success) {\n        tokenRecipient spender = tokenRecipient(_spender);\n        if (approve(_spender, _value)) {\n            spender.receiveApproval(msg.sender, _value, this, _extraData);\n            return true;\n        }\n    }        \n\n    /* A contract attempts to get the coins */\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n        if (frozenAccount[_from]) throw;                        // Check if sender frozen       \n        if (frozenAccount[_to]) throw;                          // Check if recipient frozen                 \n        if (balanceOf[_from] < _value) return false;          \t// Check if the sender has enough\n        if (balanceOf[_to] + _value < balanceOf[_to]) throw;    // Check for overflows\n        if (_value > allowance[_from][msg.sender]) throw;       // Check allowance\n        balanceOf[_from] -= _value;                             // Subtract from the sender\n        balanceOf[_to] += _value;                               // Add the same to the recipient\n        allowance[_from][msg.sender] -= _value;                 // Update sender's allowance \n        Transfer(_from, _to, _value);                           // Perform the transfer\n        return true;\n    }\n    \n    /* A function to freeze or un-freeze accounts, to and from */\n    \n    function freezeAccount(address target, bool freeze ) onlyOwner {    \n        frozenAccount[target] = freeze;                       // set the array object to the value of bool freeze\n        FrozenFunds(target, freeze);                          // notify event\n    }\n    \n\n    /* A function to burn tokens and remove from supply */\n    \n    function burn(uint256 _value) returns (bool success) {\n        if (frozenAccount[msg.sender]) throw;                 // Check if sender frozen       \n        if (_value == 0) return false; \t\t\t\t          // Don't waste gas on zero-value transaction\n        if (balanceOf[msg.sender] < _value) return false;     // Check if the sender has enough\n        balanceOf[msg.sender] -= _value;                      // Subtract from the sender\n        totalSupply -= _value;                                // Updates totalSupply\n        Transfer(msg.sender,0, _value);\t                      // Burn _value tokens\n        return true;\n    }\n\n    function burnFrom(address _from, uint256 _value) onlyOwner returns (bool success) {\n        if (frozenAccount[msg.sender]) throw;                // Check if sender frozen       \n        if (frozenAccount[_from]) throw;                     // Check if recipient frozen \n        if (_value == 0) return false; \t\t\t             // Don't waste gas on zero-value transaction\n        if (balanceOf[_from] < _value) return false;         // Check if the sender has enough\n        if (_value > allowance[_from][msg.sender]) throw;    // Check allowance\n        balanceOf[_from] -= _value;                          // Subtract from the sender\n        totalSupply -= _value;                               // Updates totalSupply\n        allowance[_from][msg.sender] -= _value;\t\t\t\t // Updates allowance\n        Transfer(_from, 0, _value);                          // Burn tokens by Transfer to incinerator\n        return true;\n    }\n    \n    /* A function to add more tokens to the total supply, accessible only to owner*/\n    // SWC-101-Integer Overflow and Underflow\n    function mintToken(address target, uint256 mintedAmount) onlyOwner {\n        if (balanceOf[target] + mintedAmount < balanceOf[target]) throw; // Check for overflows\n        balanceOf[target] += mintedAmount;\n        totalSupply += mintedAmount;\n        Transfer(0, target, mintedAmount);\n\n    }\n    \n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Blockchain Labs NZ-Earth/Back-to-Earth-audit-master/contracts/GTKT_GoldTickets.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: Yes\nDescription: The transferFrom function does not adequately check for integer overflows in the allowance update operation (allowance[_from][msg.sender] -= _value)."
    },
    {
        "code_segment": "contract StandardMintableToken is owned { \n    /* Public variables of the token */\n    string public standard = 'Token 0.1';\n    string public name;                     // the token name \n    string public symbol;                   // the ticker symbol\n    uint8 public decimals;                  // amount of decimal places in the token\n    uint256 public totalSupply;             // total tokens\n    \n    /* This creates an array with all balances */\n    mapping (address => uint256) public balanceOf;\n    mapping (address => mapping (address => uint256)) public allowance;\n    \n    /* This creates an array with all frozen accounts */\n    mapping (address => bool) public frozenAccount;\n\n    /* This generates a public event on the blockchain that will notify clients */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    \n    /* This generates a public event on the blockchain that will notify clients */\n    event FrozenFunds(address target, bool frozen);\n    \n    /* This generates a public event on the blockchain that will notify clients */\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n    /* Initializes contract with initial supply tokens to the creator of the contract */\n    function StandardMintableToken(\n        string tokenName,               // the token name\n        uint8 decimalUnits,             // amount of decimal places in the token\n        string tokenSymbol,             // the token symbol\n        uint256 initialSupply            // the initial distro amount\n        ) {\n\n        balanceOf[msg.sender] = initialSupply;                   // Give the creator all initial tokens\n        totalSupply = initialSupply;                             // Update total supply\n        name = tokenName;                                        // Set the name for display purposes\n        symbol = tokenSymbol;                                    // Set the symbol for display purposes\n        decimals = decimalUnits;                                 // Amount of decimals for display purposes\n    }\n\n    /* Send tokens */\n    function transfer(address _to, uint256 _value) returns (bool success){\n        if (_value == 0) return false; \t\t\t\t             // Don't waste gas on zero-value transaction\n        if (balanceOf[msg.sender] < _value) return false;    // Check if the sender has enough\n        if (balanceOf[_to] + _value < balanceOf[_to]) throw; // Check for overflows\n        if (frozenAccount[msg.sender]) throw;                // Check if sender frozen\n        if (frozenAccount[_to]) throw;                       // Check if recipient frozen                 \n        balanceOf[msg.sender] -= _value;                     // Subtract from the sender\n        balanceOf[_to] += _value;                            // Add the same to the recipient\n        Transfer(msg.sender, _to, _value);                   // Notify anyone listening that this transfer took place\n        return true;\n    }\n\n    /* Allow another contract to spend some tokens on your behalf */\n    function approve(address _spender, uint256 _value)\n        returns (bool success) {\n        allowance[msg.sender][_spender] = _value;            // Update allowance first\n        Approval(msg.sender, _spender, _value);              // Notify of new Approval\n        return true;\n    }\n\n    /* Approve and then communicate the approved contract in a single tx */\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData)\n        returns (bool success) {\n        tokenRecipient spender = tokenRecipient(_spender);\n        if (approve(_spender, _value)) {\n            spender.receiveApproval(msg.sender, _value, this, _extraData);\n            return true;\n        }\n    }        \n\n    /* A contract attempts to get the coins */\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n        if (frozenAccount[_from]) throw;                        // Check if sender frozen       \n        if (frozenAccount[_to]) throw;                          // Check if recipient frozen                 \n        if (balanceOf[_from] < _value) return false;          \t// Check if the sender has enough\n        if (balanceOf[_to] + _value < balanceOf[_to]) throw;    // Check for overflows\n        if (_value > allowance[_from][msg.sender]) throw;       // Check allowance\n        balanceOf[_from] -= _value;                             // Subtract from the sender\n        balanceOf[_to] += _value;                               // Add the same to the recipient\n        allowance[_from][msg.sender] -= _value;                 // Update sender's allowance \n        Transfer(_from, _to, _value);                           // Perform the transfer\n        return true;\n    }\n    \n    /* A function to freeze or un-freeze accounts, to and from */\n    \n    function freezeAccount(address target, bool freeze ) onlyOwner {    \n        frozenAccount[target] = freeze;                       // set the array object to the value of bool freeze\n        FrozenFunds(target, freeze);                          // notify event\n    }\n    \n\n    /* A function to burn tokens and remove from supply */\n    \n    function burn(uint256 _value) returns (bool success) {\n        if (frozenAccount[msg.sender]) throw;                 // Check if sender frozen       \n        if (_value == 0) return false; \t\t\t\t          // Don't waste gas on zero-value transaction\n        if (balanceOf[msg.sender] < _value) return false;     // Check if the sender has enough\n        balanceOf[msg.sender] -= _value;                      // Subtract from the sender\n        totalSupply -= _value;                                // Updates totalSupply\n        Transfer(msg.sender,0, _value);\t                      // Burn _value tokens\n        return true;\n    }\n\n    function burnFrom(address _from, uint256 _value) onlyOwner returns (bool success) {\n        if (frozenAccount[msg.sender]) throw;                // Check if sender frozen       \n        if (frozenAccount[_from]) throw;                     // Check if recipient frozen \n        if (_value == 0) return false; \t\t\t             // Don't waste gas on zero-value transaction\n        if (balanceOf[_from] < _value) return false;         // Check if the sender has enough\n        if (_value > allowance[_from][msg.sender]) throw;    // Check allowance\n        balanceOf[_from] -= _value;                          // Subtract from the sender\n        totalSupply -= _value;                               // Updates totalSupply\n        allowance[_from][msg.sender] -= _value;\t\t\t\t // Updates allowance\n        Transfer(_from, 0, _value);                          // Burn tokens by Transfer to incinerator\n        return true;\n    }\n    \n    /* A function to add more tokens to the total supply, accessible only to owner*/\n    // SWC-101-Integer Overflow and Underflow\n    function mintToken(address target, uint256 mintedAmount) onlyOwner {\n        if (balanceOf[target] + mintedAmount < balanceOf[target]) throw; // Check for overflows\n        balanceOf[target] += mintedAmount;\n        totalSupply += mintedAmount;\n        Transfer(0, target, mintedAmount);\n\n    }\n    \n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Blockchain Labs NZ-Earth/Back-to-Earth-audit-master/contracts/GTKT_GoldTickets.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: Yes\nDescription: The presence of an arithmetic check using if statements to handle overflows does not prevent all forms of integer overflow, especially without the use of later Solidity versions that include built-in overflow protection. This makes the contract vulnerable to arithmetic overflows in earlier Solidity versions."
    },
    {
        "code_segment": "contract CHAINSQUARE is ERC20Interface, Owned {\n\tstring public constant symbol = \"CHS\";\n\tstring public constant name = \"CHAINSQUARE\";\n\tuint8 public constant decimals = 18;\n\tuint256 public constant totalSupply = 100000000000000000000000000;\n\n\tbool public stopped;\n\n\tmapping (address => int8) public blackList;\n\n\tmapping (address => uint256) public balances;\n\tmapping (address => mapping (address => uint256)) public allowed;\n\n\n    event Blacklisted(address indexed target);\n    event DeleteFromBlacklist(address indexed target);\n    event RejectedPaymentToBlacklistedAddr(address indexed from, address indexed to, uint256 value);\n    event RejectedPaymentFromBlacklistedAddr(address indexed from, address indexed to, uint256 value);\n\n\n\tmodifier notStopped {\n        require(!stopped);\n        _;\n    }\n\n// constructor\n\tfunction CHAINSQUARE() public {\n\t\tbalances[msg.sender] = totalSupply;\n\t}\n\t\n// function made for airdrop\n\tfunction airdrop(address[] _to, uint256[] _value) onlyOwner notStopped public {\n\t    for(uint256 i = 0; i < _to.length; i++){\n\t        if(balances[_to[i]] > 0){\n\t            continue;\n\t        }\n\t        transfer(_to[i], _value[i]);\n\t    }\n\t}\n\n// blacklist management\n    function blacklisting(address _addr) onlyOwner public {\n        blackList[_addr] = 1;\n        emit Blacklisted(_addr);\n    }\n    function deleteFromBlacklist(address _addr) onlyOwner public {\n        blackList[_addr] = -1;\n        emit DeleteFromBlacklist(_addr);\n    }\n\n// stop the contract\n// SWC-100-Function Default Visibility: L90\n\tfunction stop() onlyOwner {\n        stopped = true;\n    }\n// SWC-100-Function Default Visibility: L94\n    function start() onlyOwner {\n        stopped = false;\n    }\n\t\n// ERC20 functions\n\tfunction balanceOf(address _owner) public constant returns (uint256 balance){\n\t\treturn balances[_owner];\n\t}\n\tfunction transfer(address _to, uint256 _value) notStopped public returns (bool success){\n\t\trequire(balances[msg.sender] >= _value);\n\n\t\tif(blackList[msg.sender] > 0){\n\t\t\temit RejectedPaymentFromBlacklistedAddr(msg.sender, _to, _value);\n\t\t\treturn false;\n\t\t}\n\t\tif(blackList[_to] > 0){\n\t\t\temit RejectedPaymentToBlacklistedAddr(msg.sender, _to, _value);\n\t\t\treturn false;\n\t\t}\n\n\t\tbalances[msg.sender] -= _value;\n\t\tbalances[_to] += _value;\n\t\temit Transfer(msg.sender, _to, _value);\n\t\treturn true;\n\t}\n\tfunction transferFrom(address _from, address _to, uint256 _value) notStopped public returns (bool success){\n\t\trequire(balances[_from] >= _value\n\t\t\t&& allowed[_from][msg.sender] >= _value);\n\n\t\tif(blackList[_from] > 0){\n\t\t\temit RejectedPaymentFromBlacklistedAddr(_from, _to, _value);\n\t\t\treturn false;\n\t\t}\n\t\tif(blackList[_to] > 0){\n\t\t\temit RejectedPaymentToBlacklistedAddr(_from, _to, _value);\n\t\t\treturn false;\n\t\t}\n\n\t\tbalances[_from] -= _value;\n\t\tallowed[_from][msg.sender] -= _value;\n\t\tbalances[_to] += _value;\n\t\temit Transfer(_from, _to, _value);\n\t\treturn true;\n\t}\n\tfunction approve(address _spender, uint256 _value) notStopped public returns (bool success){\n\t\tallowed[msg.sender][_spender] = _value;\n\t\temit Approval(msg.sender, _spender, _value);\n\t\treturn true;\n\t}\n\tfunction allowance(address _owner, address _spender) public constant returns (uint256 remaining){\n\t\treturn allowed[_owner][_spender];\n\t}\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Iosiro-CHAINSQUARE Smart Contract Audit/code/Etherscan-0xb41380174d0B06181513A5677b60200b93b5Efb4.sol",
        "vulnerability": "Assertion Failure",
        "check": "FP",
        "response": "Answer: No  \nReason: No assertions are used in the code, thus no assertion failure vulnerability exists."
    },
    {
        "code_segment": "contract AddressWhitelist is Ownable, Lockable {\n    enum Status { None, In, Out }\n    mapping(address => Status) public whitelist;\n\n    address[] public whitelistIndices;\n\n    event AddedToWhitelist(address indexed addedAddress);\n    event RemovedFromWhitelist(address indexed removedAddress);\n\n    /**\n     * @notice Adds an address to the whitelist.\n     * @param newElement the new address to add.\n     */\n    function addToWhitelist(address newElement) external nonReentrant() onlyOwner {\n        // Ignore if address is already included\n        if (whitelist[newElement] == Status.In) {\n            return;\n        }\n\n        // Only append new addresses to the array, never a duplicate\n        if (whitelist[newElement] == Status.None) {\n            whitelistIndices.push(newElement);\n        }\n\n        whitelist[newElement] = Status.In;\n\n        emit AddedToWhitelist(newElement);\n    }\n\n    /**\n     * @notice Removes an address from the whitelist.\n     * @param elementToRemove the existing address to remove.\n     */\n    function removeFromWhitelist(address elementToRemove) external nonReentrant() onlyOwner {\n        if (whitelist[elementToRemove] != Status.Out) {\n            whitelist[elementToRemove] = Status.Out;\n            emit RemovedFromWhitelist(elementToRemove);\n        }\n    }\n\n    /**\n     * @notice Checks whether an address is on the whitelist.\n     * @param elementToCheck the address to check.\n     * @return True if `elementToCheck` is on the whitelist, or False.\n     */\n    function isOnWhitelist(address elementToCheck) external view nonReentrantView() returns (bool) {\n        return whitelist[elementToCheck] == Status.In;\n    }\n\n    /**\n     * @notice Gets all addresses that are currently included in the whitelist.\n     * @dev Note: This method skips over, but still iterates through addresses. It is possible for this call to run out\n     * of gas if a large number of addresses have been removed. To reduce the likelihood of this unlikely scenario, we\n     * can modify the implementation so that when addresses are removed, the last addresses in the array is moved to\n     * the empty index.\n     * @return activeWhitelist the list of addresses on the whitelist.\n     */\n    function getWhitelist() external view nonReentrantView() returns (address[] memory activeWhitelist) {\n        // Determine size of whitelist first\n        uint256 activeCount = 0;\n        for (uint256 i = 0; i < whitelistIndices.length; i++) {\n            if (whitelist[whitelistIndices[i]] == Status.In) {\n                activeCount++;\n            }\n        }\n\n        // Populate whitelist\n        activeWhitelist = new address[](activeCount);\n        activeCount = 0;\n        for (uint256 i = 0; i < whitelistIndices.length; i++) {\n            address addr = whitelistIndices[i];\n            if (whitelist[addr] == Status.In) {\n                activeWhitelist[activeCount] = addr;\n                activeCount++;\n            }\n        }\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/openzeppelin-UMA/protocol-1631ef7ad29aaeba756ef3b9a01c667e1343df85/packages/core/contracts/oracle/implementation/OptimisticOracle.sol",
        "vulnerability": "Assertion Failure",
        "check": "FP",
        "response": "Answer: No\nReason: There are no assert statements in the code that could potentially fail."
    },
    {
        "code_segment": "contract AddressWhitelist is Ownable, Lockable {\n    enum Status { None, In, Out }\n    mapping(address => Status) public whitelist;\n\n    address[] public whitelistIndices;\n\n    event AddedToWhitelist(address indexed addedAddress);\n    event RemovedFromWhitelist(address indexed removedAddress);\n\n    /**\n     * @notice Adds an address to the whitelist.\n     * @param newElement the new address to add.\n     */\n    function addToWhitelist(address newElement) external nonReentrant() onlyOwner {\n        // Ignore if address is already included\n        if (whitelist[newElement] == Status.In) {\n            return;\n        }\n\n        // Only append new addresses to the array, never a duplicate\n        if (whitelist[newElement] == Status.None) {\n            whitelistIndices.push(newElement);\n        }\n\n        whitelist[newElement] = Status.In;\n\n        emit AddedToWhitelist(newElement);\n    }\n\n    /**\n     * @notice Removes an address from the whitelist.\n     * @param elementToRemove the existing address to remove.\n     */\n    function removeFromWhitelist(address elementToRemove) external nonReentrant() onlyOwner {\n        if (whitelist[elementToRemove] != Status.Out) {\n            whitelist[elementToRemove] = Status.Out;\n            emit RemovedFromWhitelist(elementToRemove);\n        }\n    }\n\n    /**\n     * @notice Checks whether an address is on the whitelist.\n     * @param elementToCheck the address to check.\n     * @return True if `elementToCheck` is on the whitelist, or False.\n     */\n    function isOnWhitelist(address elementToCheck) external view nonReentrantView() returns (bool) {\n        return whitelist[elementToCheck] == Status.In;\n    }\n\n    /**\n     * @notice Gets all addresses that are currently included in the whitelist.\n     * @dev Note: This method skips over, but still iterates through addresses. It is possible for this call to run out\n     * of gas if a large number of addresses have been removed. To reduce the likelihood of this unlikely scenario, we\n     * can modify the implementation so that when addresses are removed, the last addresses in the array is moved to\n     * the empty index.\n     * @return activeWhitelist the list of addresses on the whitelist.\n     */\n    function getWhitelist() external view nonReentrantView() returns (address[] memory activeWhitelist) {\n        // Determine size of whitelist first\n        uint256 activeCount = 0;\n        for (uint256 i = 0; i < whitelistIndices.length; i++) {\n            if (whitelist[whitelistIndices[i]] == Status.In) {\n                activeCount++;\n            }\n        }\n\n        // Populate whitelist\n        activeWhitelist = new address[](activeCount);\n        activeCount = 0;\n        for (uint256 i = 0; i < whitelistIndices.length; i++) {\n            address addr = whitelistIndices[i];\n            if (whitelist[addr] == Status.In) {\n                activeWhitelist[activeCount] = addr;\n                activeCount++;\n            }\n        }\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/openzeppelin-UMA/protocol-1631ef7ad29aaeba756ef3b9a01c667e1343df85/packages/core/contracts/financial-templates/perpetual-multiparty/PerpetualLiquidatable.sol",
        "vulnerability": "Assertion Failure",
        "check": "FP",
        "response": "Answer: No\nReason: The code does not contain any assertions (`assert` statements) that could potentially fail."
    },
    {
        "code_segment": "contract AddressWhitelist is Ownable, Lockable {\n    enum Status { None, In, Out }\n    mapping(address => Status) public whitelist;\n\n    address[] public whitelistIndices;\n\n    event AddedToWhitelist(address indexed addedAddress);\n    event RemovedFromWhitelist(address indexed removedAddress);\n\n    /**\n     * @notice Adds an address to the whitelist.\n     * @param newElement the new address to add.\n     */\n    function addToWhitelist(address newElement) external nonReentrant() onlyOwner {\n        // Ignore if address is already included\n        if (whitelist[newElement] == Status.In) {\n            return;\n        }\n\n        // Only append new addresses to the array, never a duplicate\n        if (whitelist[newElement] == Status.None) {\n            whitelistIndices.push(newElement);\n        }\n\n        whitelist[newElement] = Status.In;\n\n        emit AddedToWhitelist(newElement);\n    }\n\n    /**\n     * @notice Removes an address from the whitelist.\n     * @param elementToRemove the existing address to remove.\n     */\n    function removeFromWhitelist(address elementToRemove) external nonReentrant() onlyOwner {\n        if (whitelist[elementToRemove] != Status.Out) {\n            whitelist[elementToRemove] = Status.Out;\n            emit RemovedFromWhitelist(elementToRemove);\n        }\n    }\n\n    /**\n     * @notice Checks whether an address is on the whitelist.\n     * @param elementToCheck the address to check.\n     * @return True if `elementToCheck` is on the whitelist, or False.\n     */\n    function isOnWhitelist(address elementToCheck) external view nonReentrantView() returns (bool) {\n        return whitelist[elementToCheck] == Status.In;\n    }\n\n    /**\n     * @notice Gets all addresses that are currently included in the whitelist.\n     * @dev Note: This method skips over, but still iterates through addresses. It is possible for this call to run out\n     * of gas if a large number of addresses have been removed. To reduce the likelihood of this unlikely scenario, we\n     * can modify the implementation so that when addresses are removed, the last addresses in the array is moved to\n     * the empty index.\n     * @return activeWhitelist the list of addresses on the whitelist.\n     */\n    function getWhitelist() external view nonReentrantView() returns (address[] memory activeWhitelist) {\n        // Determine size of whitelist first\n        uint256 activeCount = 0;\n        for (uint256 i = 0; i < whitelistIndices.length; i++) {\n            if (whitelist[whitelistIndices[i]] == Status.In) {\n                activeCount++;\n            }\n        }\n\n        // Populate whitelist\n        activeWhitelist = new address[](activeCount);\n        activeCount = 0;\n        for (uint256 i = 0; i < whitelistIndices.length; i++) {\n            address addr = whitelistIndices[i];\n            if (whitelist[addr] == Status.In) {\n                activeWhitelist[activeCount] = addr;\n                activeCount++;\n            }\n        }\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/openzeppelin-UMA/protocol-1631ef7ad29aaeba756ef3b9a01c667e1343df85/packages/core/contracts/financial-templates/perpetual-multiparty/PerpetualCreator.sol",
        "vulnerability": "Assertion Failure",
        "check": "FP",
        "response": "Answer: No\nReason: The provided code does not contain any assertions, so there cannot be an assertion failure vulnerability."
    },
    {
        "code_segment": "contract AddressWhitelist is Ownable, Lockable {\n    enum Status { None, In, Out }\n    mapping(address => Status) public whitelist;\n\n    address[] public whitelistIndices;\n\n    event AddedToWhitelist(address indexed addedAddress);\n    event RemovedFromWhitelist(address indexed removedAddress);\n\n    /**\n     * @notice Adds an address to the whitelist.\n     * @param newElement the new address to add.\n     */\n    function addToWhitelist(address newElement) external nonReentrant() onlyOwner {\n        // Ignore if address is already included\n        if (whitelist[newElement] == Status.In) {\n            return;\n        }\n\n        // Only append new addresses to the array, never a duplicate\n        if (whitelist[newElement] == Status.None) {\n            whitelistIndices.push(newElement);\n        }\n\n        whitelist[newElement] = Status.In;\n\n        emit AddedToWhitelist(newElement);\n    }\n\n    /**\n     * @notice Removes an address from the whitelist.\n     * @param elementToRemove the existing address to remove.\n     */\n    function removeFromWhitelist(address elementToRemove) external nonReentrant() onlyOwner {\n        if (whitelist[elementToRemove] != Status.Out) {\n            whitelist[elementToRemove] = Status.Out;\n            emit RemovedFromWhitelist(elementToRemove);\n        }\n    }\n\n    /**\n     * @notice Checks whether an address is on the whitelist.\n     * @param elementToCheck the address to check.\n     * @return True if `elementToCheck` is on the whitelist, or False.\n     */\n    function isOnWhitelist(address elementToCheck) external view nonReentrantView() returns (bool) {\n        return whitelist[elementToCheck] == Status.In;\n    }\n\n    /**\n     * @notice Gets all addresses that are currently included in the whitelist.\n     * @dev Note: This method skips over, but still iterates through addresses. It is possible for this call to run out\n     * of gas if a large number of addresses have been removed. To reduce the likelihood of this unlikely scenario, we\n     * can modify the implementation so that when addresses are removed, the last addresses in the array is moved to\n     * the empty index.\n     * @return activeWhitelist the list of addresses on the whitelist.\n     */\n    function getWhitelist() external view nonReentrantView() returns (address[] memory activeWhitelist) {\n        // Determine size of whitelist first\n        uint256 activeCount = 0;\n        for (uint256 i = 0; i < whitelistIndices.length; i++) {\n            if (whitelist[whitelistIndices[i]] == Status.In) {\n                activeCount++;\n            }\n        }\n\n        // Populate whitelist\n        activeWhitelist = new address[](activeCount);\n        activeCount = 0;\n        for (uint256 i = 0; i < whitelistIndices.length; i++) {\n            address addr = whitelistIndices[i];\n            if (whitelist[addr] == Status.In) {\n                activeWhitelist[activeCount] = addr;\n                activeCount++;\n            }\n        }\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/openzeppelin-UMA/protocol-1631ef7ad29aaeba756ef3b9a01c667e1343df85/packages/core/contracts/financial-templates/perpetual-multiparty/PerpetualPositionManager.sol",
        "vulnerability": "Assertion Failure",
        "check": "FP",
        "response": "Answer: No\nReason: There are no assertions being used in this smart contract code that could fail."
    },
    {
        "code_segment": "contract FinToken is StandardToken {\n\taddress public owner;\n\t\n\tstring public constant name = \"FIN Token\"; \n\tstring public constant symbol = \"FIN\";\n\tuint8 public constant decimals = 18;\n\n\t// SWC-101-Integer Overflow and Underflow: L226\n\tuint256 public constant INITIAL_SUPPLY = 2623304 * (10 ** uint256(decimals));\n\t\n\tmapping (address => bool) internal verificatorAddresses;\n\tmapping (address => bool) internal verifiedAddresses;\n\t\n\tevent AddVerificator(address indexed verificator);\n\tevent RemoveVerificator(address indexed verificator);\n\t\n\tevent AddVerified(address indexed verificatorAddress, address indexed verified);\n\tevent RemoveVerified(address indexed verificatorAddress, address indexed verified);\n\t\n\tevent Mint(address indexed to, uint256 amount);\n\t\n\tmodifier onlyOwner() {\n\t\trequire(msg.sender == owner);\n\t\t_;\n\t}\n\t\n\tmodifier onlyVerificator() {\n\t\trequire(isVerificator(msg.sender));\n\t\t_;\n\t}\n\t\n\tmodifier onlyVerified(address _from, address _to) {\n\t\trequire(isVerified(_from));\n\t\trequire(isVerified(_to));\n\t\t_;\n\t}\n\n\tfunction FinToken() public {\n\t\towner = msg.sender;\n\t\ttotalSupply_ = INITIAL_SUPPLY;\n\t\tbalances[msg.sender] = INITIAL_SUPPLY;\n\t\temit Transfer(0x0, msg.sender, INITIAL_SUPPLY);\n\t}\n\t\n\tfunction addVerificatorAddress(address addr) public onlyOwner {\n\t\tverificatorAddresses[addr] = true;\n\t\temit AddVerificator(addr);\n\t}\n\t\n\tfunction removeVerificatorAddress(address addr) public onlyOwner {\n\t\tdelete verificatorAddresses[addr];\n\t\temit RemoveVerificator(addr);\n\t}\n\t\n\tfunction isVerificator(address addr) public constant returns (bool) {\n\t\treturn verificatorAddresses[addr];\n\t}\n\t\t\n\tfunction addVerifiedAddress(address addr) public onlyVerificator {\n\t\tverifiedAddresses[addr] = true;\n\t\temit AddVerified(msg.sender, addr);\n\t}\n\t\n\tfunction removeVerifiedAddress(address addr) public onlyVerificator {\n\t\tdelete verifiedAddresses[addr];\n\t\temit RemoveVerified(msg.sender, addr);\n\t}\n\t\n\tfunction isVerified(address addr) public constant returns (bool) {\n\t\treturn verifiedAddresses[addr];\n\t}\n\t\n\tfunction transfer(address _to, uint256 _value) public onlyVerified(msg.sender, _to) returns (bool) {\n\t\tsuper.transfer(_to, _value);\n\t}\n\t\n\tfunction transferFrom(address _from, address _to, uint256 _value) public onlyVerified(_from, _to) returns (bool) {\n\t    super.transferFrom(_from, _to, _value);\n\t}\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Chainsulting-NOM/FinToken/FinToken.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No\nReason: The use of a constant and well-defined multiplication for the INITIAL_SUPPLY calculation prevents integer overflow in this context."
    },
    {
        "code_segment": "contract FinToken is StandardToken {\n\taddress public owner;\n\t\n\tstring public constant name = \"FIN Token\"; \n\tstring public constant symbol = \"FIN\";\n\tuint8 public constant decimals = 18;\n\n\t// SWC-101-Integer Overflow and Underflow: L226\n\tuint256 public constant INITIAL_SUPPLY = 2623304 * (10 ** uint256(decimals));\n\t\n\tmapping (address => bool) internal verificatorAddresses;\n\tmapping (address => bool) internal verifiedAddresses;\n\t\n\tevent AddVerificator(address indexed verificator);\n\tevent RemoveVerificator(address indexed verificator);\n\t\n\tevent AddVerified(address indexed verificatorAddress, address indexed verified);\n\tevent RemoveVerified(address indexed verificatorAddress, address indexed verified);\n\t\n\tevent Mint(address indexed to, uint256 amount);\n\t\n\tmodifier onlyOwner() {\n\t\trequire(msg.sender == owner);\n\t\t_;\n\t}\n\t\n\tmodifier onlyVerificator() {\n\t\trequire(isVerificator(msg.sender));\n\t\t_;\n\t}\n\t\n\tmodifier onlyVerified(address _from, address _to) {\n\t\trequire(isVerified(_from));\n\t\trequire(isVerified(_to));\n\t\t_;\n\t}\n\n\tfunction FinToken() public {\n\t\towner = msg.sender;\n\t\ttotalSupply_ = INITIAL_SUPPLY;\n\t\tbalances[msg.sender] = INITIAL_SUPPLY;\n\t\temit Transfer(0x0, msg.sender, INITIAL_SUPPLY);\n\t}\n\t\n\tfunction addVerificatorAddress(address addr) public onlyOwner {\n\t\tverificatorAddresses[addr] = true;\n\t\temit AddVerificator(addr);\n\t}\n\t\n\tfunction removeVerificatorAddress(address addr) public onlyOwner {\n\t\tdelete verificatorAddresses[addr];\n\t\temit RemoveVerificator(addr);\n\t}\n\t\n\tfunction isVerificator(address addr) public constant returns (bool) {\n\t\treturn verificatorAddresses[addr];\n\t}\n\t\t\n\tfunction addVerifiedAddress(address addr) public onlyVerificator {\n\t\tverifiedAddresses[addr] = true;\n\t\temit AddVerified(msg.sender, addr);\n\t}\n\t\n\tfunction removeVerifiedAddress(address addr) public onlyVerificator {\n\t\tdelete verifiedAddresses[addr];\n\t\temit RemoveVerified(msg.sender, addr);\n\t}\n\t\n\tfunction isVerified(address addr) public constant returns (bool) {\n\t\treturn verifiedAddresses[addr];\n\t}\n\t\n\tfunction transfer(address _to, uint256 _value) public onlyVerified(msg.sender, _to) returns (bool) {\n\t\tsuper.transfer(_to, _value);\n\t}\n\t\n\tfunction transferFrom(address _from, address _to, uint256 _value) public onlyVerified(_from, _to) returns (bool) {\n\t    super.transferFrom(_from, _to, _value);\n\t}\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Chainsulting-NOM/FinToken/FinToken.sol",
        "vulnerability": "Assertion Failure",
        "check": "FP",
        "response": "Answer: No\nReason: The provided smart contract code does not contain any `assert` statements, and all conditions use `require`, which returns the remaining gas when conditions fail instead of throwing an assertion failure."
    },
    {
        "code_segment": "contract StandardToken is ERC20, BasicToken {\n\n\tmapping (address => mapping (address => uint256)) internal allowed;\n\n\n\t/**\n\t * @dev Transfer tokens from one address to another\n\t * @param _from address The address which you want to send tokens from\n\t * @param _to address The address which you want to transfer to\n\t * @param _value uint256 the amount of tokens to be transferred\n\t */\n\tfunction transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n\t\trequire(_to != address(0));\n\t\trequire(_value <= balances[_from]);\n\t\trequire(_value <= allowed[_from][msg.sender]);\n\n\t\tbalances[_from] = balances[_from].sub(_value);\n\t\tbalances[_to] = balances[_to].add(_value);\n\t\tallowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n\t\temit Transfer(_from, _to, _value);\n\t\treturn true;\n\t}\n\n\t/**\n\t * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n\t *\n\t * Beware that changing an allowance with this method brings the risk that someone may use both the old\n\t * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n\t * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n\t * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n\t * @param _spender The address which will spend the funds.\n\t * @param _value The amount of tokens to be spent.\n\t */\n\tfunction approve(address _spender, uint256 _value) public returns (bool) {\n\t\tallowed[msg.sender][_spender] = _value;\n\t\temit Approval(msg.sender, _spender, _value);\n\t\treturn true;\n\t}\n\n\t/**\n\t * @dev Function to check the amount of tokens that an owner allowed to a spender.\n\t * @param _owner address The address which owns the funds.\n\t * @param _spender address The address which will spend the funds.\n\t * @return A uint256 specifying the amount of tokens still available for the spender.\n\t */\n\tfunction allowance(address _owner, address _spender) public view returns (uint256) {\n\t\treturn allowed[_owner][_spender];\n\t}\n\n\t/**\n\t * @dev Increase the amount of tokens that an owner allowed to a spender.\n\t *\n\t * approve should be called when allowed[_spender] == 0. To increment\n\t * allowed value is better to use this function to avoid 2 calls (and wait until\n\t * the first transaction is mined)\n\t * From MonolithDAO Token.sol\n\t * @param _spender The address which will spend the funds.\n\t * @param _addedValue The amount of tokens to increase the allowance by.\n\t */\n\tfunction increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n\t\tallowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n\t\temit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n\t\treturn true;\n\t}\n\n\t/**\n\t * @dev Decrease the amount of tokens that an owner allowed to a spender.\n\t *\n\t * approve should be called when allowed[_spender] == 0. To decrement\n\t * allowed value is better to use this function to avoid 2 calls (and wait until\n\t * the first transaction is mined)\n\t * From MonolithDAO Token.sol\n\t * @param _spender The address which will spend the funds.\n\t * @param _subtractedValue The amount of tokens to decrease the allowance by.\n\t */\n\tfunction decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n\t\tuint oldValue = allowed[msg.sender][_spender];\n\t\tif (_subtractedValue > oldValue) {\n\t\t\tallowed[msg.sender][_spender] = 0;\n\t\t} else {\n\t\t\tallowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n\t\t}\n\t\temit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n\t\treturn true;\n\t}\n\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Chainsulting-NOM/FinToken/FinToken.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No\nReason: The provided code uses SafeMath library functions (`sub` and `add`) which protect against integer overflow and underflow vulnerabilities. Therefore, there is no risk of integer overflow in this smart contract."
    },
    {
        "code_segment": "contract StandardToken is ERC20, BasicToken {\n\n\tmapping (address => mapping (address => uint256)) internal allowed;\n\n\n\t/**\n\t * @dev Transfer tokens from one address to another\n\t * @param _from address The address which you want to send tokens from\n\t * @param _to address The address which you want to transfer to\n\t * @param _value uint256 the amount of tokens to be transferred\n\t */\n\tfunction transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n\t\trequire(_to != address(0));\n\t\trequire(_value <= balances[_from]);\n\t\trequire(_value <= allowed[_from][msg.sender]);\n\n\t\tbalances[_from] = balances[_from].sub(_value);\n\t\tbalances[_to] = balances[_to].add(_value);\n\t\tallowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n\t\temit Transfer(_from, _to, _value);\n\t\treturn true;\n\t}\n\n\t/**\n\t * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n\t *\n\t * Beware that changing an allowance with this method brings the risk that someone may use both the old\n\t * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n\t * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n\t * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n\t * @param _spender The address which will spend the funds.\n\t * @param _value The amount of tokens to be spent.\n\t */\n\tfunction approve(address _spender, uint256 _value) public returns (bool) {\n\t\tallowed[msg.sender][_spender] = _value;\n\t\temit Approval(msg.sender, _spender, _value);\n\t\treturn true;\n\t}\n\n\t/**\n\t * @dev Function to check the amount of tokens that an owner allowed to a spender.\n\t * @param _owner address The address which owns the funds.\n\t * @param _spender address The address which will spend the funds.\n\t * @return A uint256 specifying the amount of tokens still available for the spender.\n\t */\n\tfunction allowance(address _owner, address _spender) public view returns (uint256) {\n\t\treturn allowed[_owner][_spender];\n\t}\n\n\t/**\n\t * @dev Increase the amount of tokens that an owner allowed to a spender.\n\t *\n\t * approve should be called when allowed[_spender] == 0. To increment\n\t * allowed value is better to use this function to avoid 2 calls (and wait until\n\t * the first transaction is mined)\n\t * From MonolithDAO Token.sol\n\t * @param _spender The address which will spend the funds.\n\t * @param _addedValue The amount of tokens to increase the allowance by.\n\t */\n\tfunction increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n\t\tallowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n\t\temit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n\t\treturn true;\n\t}\n\n\t/**\n\t * @dev Decrease the amount of tokens that an owner allowed to a spender.\n\t *\n\t * approve should be called when allowed[_spender] == 0. To decrement\n\t * allowed value is better to use this function to avoid 2 calls (and wait until\n\t * the first transaction is mined)\n\t * From MonolithDAO Token.sol\n\t * @param _spender The address which will spend the funds.\n\t * @param _subtractedValue The amount of tokens to decrease the allowance by.\n\t */\n\tfunction decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n\t\tuint oldValue = allowed[msg.sender][_spender];\n\t\tif (_subtractedValue > oldValue) {\n\t\t\tallowed[msg.sender][_spender] = 0;\n\t\t} else {\n\t\t\tallowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n\t\t}\n\t\temit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n\t\treturn true;\n\t}\n\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Chainsulting-NOM/FinToken/FinToken.sol",
        "vulnerability": "Assertion Failure",
        "check": "FP",
        "response": "Answer: No\nReason: There are no assertions in the code; therefore, an assertion failure cannot occur. The code relies on require statements for checks."
    },
    {
        "code_segment": "contract TokenERC20 {\n    // Public variables of the token\n    string public name;\n    string public symbol;\n    uint8 public decimals = 18;\n    // 18 decimals is the strongly suggested default, avoid changing it\n    uint256 public totalSupply;\n\n    mapping (address => bool) public blacklist;\n    address admin;\n\n    // This creates an array with all balances\n    mapping (address => uint256) public balanceOf;\n    mapping (address => mapping (address => uint256)) public allowance;\n\n    // This generates a public event on the blockchain that will notify clients\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    // This notifies clients about the amount burnt\n    event Burn(address indexed from, uint256 value);\n\n    /**\n     * Constructor function\n     *\n     * Initializes contract with initial supply tokens to the creator of the contract\n     */\n    function TokenERC20(\n        uint256 initialSupply,\n        string tokenName,\n        string tokenSymbol\n    ) public {\n        totalSupply = initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount\n        balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens\n        name = tokenName;                                   // Set the name for display purposes\n        symbol = tokenSymbol;                               // Set the symbol for display purposes\n        admin = msg.sender;\n    }\n\n    /**\n     * Internal transfer, only can be called by this contract\n     */\n    function _transfer(address _from, address _to, uint _value) internal {\n        // Prevent transfer to 0x0 address. Use burn() instead\n        require(_to != 0x0);\n        // Check if the sender has enough\n        require(balanceOf[_from] >= _value);\n        // Check for overflows\n        require(balanceOf[_to] + _value > balanceOf[_to]);\n        // Save this for an assertion in the future\n        uint previousBalances = balanceOf[_from] + balanceOf[_to];\n        // Subtract from the sender\n        balanceOf[_from] -= _value;\n        // Add the same to the recipient\n        balanceOf[_to] += _value;\n        Transfer(_from, _to, _value);\n        // Asserts are used to use static analysis to find bugs in your code. They should never fail\n        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);\n    }\n\n    /**\n     * Transfer tokens\n     *\n     * Send `_value` tokens to `_to` from your account\n     *\n     * @param _to The address of the recipient\n     * @param _value the amount to send\n     */\n// SWC-104-Unchecked Call Return Value: L76\n    function transfer(address _to, uint256 _value) public {\n        require(!blacklist[msg.sender]);\n        _transfer(msg.sender, _to, _value);\n    }\n\n    /**\n     * Ban address\n     * \n     * @param addr ban addr\n     */\n    function ban(address addr) public {\n        require(msg.sender == admin);\n        blacklist[addr] = true;\n    }\n\n    /**\n     * Enable address\n     * \n     *  @param addr enable addr\n     */\n    function enable(address addr) public {\n        require(msg.sender == admin);\n        blacklist[addr] = false;\n    }\n\n    /**\n     * Transfer tokens from other address\n     *\n     * Send `_value` tokens to `_to` on behalf of `_from`\n     *\n     * @param _from The address of the sender\n     * @param _to The address of the recipient\n     * @param _value the amount to send\n     */\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n        require(!blacklist[msg.sender]);\n        require(_value <= allowance[_from][msg.sender]);     // Check allowance\n        allowance[_from][msg.sender] -= _value;\n        _transfer(_from, _to, _value);\n        return true;\n    }\n\n    /**\n     * Set allowance for other address\n     *\n     * Allows `_spender` to spend no more than `_value` tokens on your behalf\n     *\n     * @param _spender The address authorized to spend\n     * @param _value the max amount they can spend\n     */\n    function approve(address _spender, uint256 _value) public\n    returns (bool success) {\n        require(!blacklist[msg.sender]);\n        allowance[msg.sender][_spender] = _value;\n        return true;\n    }\n\n    /**\n     * Set allowance for other address and notify\n     *\n     * Allows `_spender` to spend no more than `_value` tokens on your behalf, and then ping the contract about it\n     *\n     * @param _spender The address authorized to spend\n     * @param _value the max amount they can spend\n     * @param _extraData some extra information to send to the approved contract\n     */\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData)\n    public\n    returns (bool success) {\n        require(!blacklist[msg.sender]);\n        tokenRecipient spender = tokenRecipient(_spender);\n        if (approve(_spender, _value)) {\n            spender.receiveApproval(msg.sender, _value, this, _extraData);\n            return true;\n        }\n    }\n\n    /**\n     * Destroy tokens\n     *\n     * Remove `_value` tokens from the system irreversibly\n     *\n     * @param _value the amount of money to burn\n     */\n    function burn(uint256 _value) public returns (bool success) {\n        require(!blacklist[msg.sender]);\n        require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough\n        balanceOf[msg.sender] -= _value;            // Subtract from the sender\n        totalSupply -= _value;                      // Updates totalSupply\n        Burn(msg.sender, _value);\n        return true;\n    }\n\n    /**\n     * Destroy tokens from other account\n     *\n     * Remove `_value` tokens from the system irreversibly on behalf of `_from`.\n     *\n     * @param _from the address of the sender\n     * @param _value the amount of money to burn\n     */\n    function burnFrom(address _from, uint256 _value) public returns (bool success) {\n        require(!blacklist[msg.sender]);\n        require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough\n        require(_value <= allowance[_from][msg.sender]);    // Check allowance\n        balanceOf[_from] -= _value;                         // Subtract from the targeted balance\n        allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance\n        totalSupply -= _value;                              // Update totalSupply\n        Burn(_from, _value);\n        return true;\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Callisto_Network-MaxiMine Token (MXM) Security Audit/code/code.sol",
        "vulnerability": "Reentrancy",
        "check": "FP",
        "response": "Answer: No\nReason: The code does not have any external calls to other contracts or untrusted addresses within functions that modify state variables, which is required for a reentrancy vulnerability."
    },
    {
        "code_segment": "contract ArkaniaProtocol is ERC20 {\n    constructor() ERC20(\"Arkania Protocol\", \"ANIA\") {\n        _mint(msg.sender, 100000000 * 10 ** decimals());\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Hacken-Arkania Protocol/Code-4fe28aed2e2549ba649ed2edb6a11ef7d2ac73fd/Ania.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No\nReason: The code uses a fixed supply for minting tokens, and does not involve user input that could cause an overflow."
    },
    {
        "code_segment": "contract WadzPayToken is Context, IERC20, IERC20Metadata, Ownable {\n    using SafeMath for uint256;\n    \n    mapping(address => uint256) private _balances;\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n    string private _name;\n    string private _symbol;\n\n\n    mapping(address => bool) public blackList;\n    mapping(address => uint256) private lastTxTimestamp;\n    bool private antibotPaused = true;\n\n    struct WhitelistRound {\n        uint256 duration;\n        uint256 amountMax;\n        mapping(address => bool) addresses;\n        mapping(address => uint256) purchased;\n    }\n\n    WhitelistRound[] public _tgeWhitelistRounds;\n\n    uint256 public _tgeTimestamp;\n    address public _tgePairAddress;\n\n    uint256 private maxTxPercent = 1000;\n    uint256 private transferDelay = 0;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The defaut value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor() {\n        _name = \"WadzPay Token\";\n        _symbol = \"WTK\";\n        _mint(msg.sender, 250000000 * (10**uint256(decimals())));\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account)\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount)\n        public\n        virtual\n        override\n        returns (bool)\n    {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender)\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount)\n        public\n        virtual\n        override\n        returns (bool)\n    {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        require(\n            currentAllowance >= amount,\n            \"ERC20: transfer amount exceeds allowance\"\n        );\n        _approve(sender, _msgSender(), currentAllowance - amount);\n\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue)\n        public\n        virtual\n        returns (bool)\n    {\n        _approve(\n            _msgSender(),\n            spender,\n            _allowances[_msgSender()][spender] + addedValue\n        );\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue)\n        public\n        virtual\n        returns (bool)\n    {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(\n            currentAllowance >= subtractedValue,\n            \"ERC20: decreased allowance below zero\"\n        );\n        _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n\n        return true;\n    }\n\n    function mint(address account, uint256 amount) public onlyOwner {\n        _mint(account, amount * (10**uint256(decimals())));\n    }\n\n    function destroy(address account, uint256 amount) public onlyOwner {\n        _burn(account, amount * (10**uint256(decimals())));\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n        if (!antibotPaused) {\n            if (sender != owner() && recipient != owner()) {\n                require(\n                    amount <= (totalSupply() * maxTxPercent) / 1000,\n                    \"Overflow max transfer amount\"\n                );\n            }\n            require(!blackList[sender], \"Blacklisted seller\");\n            _applyTGEWhitelist(sender, recipient, amount);\n            lastTxTimestamp[recipient] = block.timestamp;\n        }\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(\n            senderBalance >= amount,\n            \"ERC20: transfer amount exceeds balance\"\n        );\n        _balances[sender] = senderBalance - amount;\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        _balances[account] = accountBalance - amount;\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    \n    \n\n    \n    function addBlacklist(address _bot) external onlyOwner {\n        blackList[_bot] = true;\n        emit AddedBlackList(_bot);\n    }\n\n    \n    function removeBlacklist(address _addr) external onlyOwner {\n        blackList[_addr] = false;\n        emit RemovedBlackList(_addr);\n    }\n\n    \n    function destroyBlackFunds(address _blackListedUser) external onlyOwner {\n        require(blackList[_blackListedUser], \"This user is not a member of blacklist\");\n        uint dirtyFunds = balanceOf(_blackListedUser);\n        _balances[_blackListedUser] = 0;\n        _totalSupply -= dirtyFunds;\n        emit DestroyedBlackFunds(_blackListedUser, dirtyFunds);\n    }\n\n    event DestroyedBlackFunds(address _blackListedUser, uint _balance);\n\n    event AddedBlackList(address _user);\n\n    event RemovedBlackList(address _user);\n\n\n    /*\n     * createTGEWhitelist - Call this after initial Token Generation Event (TGE)\n     *\n     * pairAddress - address generated from createPair() event on DEX\n     * durations - array of durations (seconds) for each whitelist rounds\n     * amountsMax - array of max amounts (TOKEN decimals) for each whitelist round\n     *\n     */\n\n    function createTGEWhitelist(address pairAddress, uint256[] calldata durations, uint256[] calldata amountsMax) external onlyOwner {\n        require(durations.length == amountsMax.length, \"Invalid whitelist(s)\");\n\n        _tgePairAddress = pairAddress;\n\n        if(durations.length > 0) {\n\n            delete _tgeWhitelistRounds;\n\n            for (uint256 i = 0; i < durations.length; i++) {\n                WhitelistRound storage wlRound = _tgeWhitelistRounds[i];\n                wlRound.duration = durations[i];\n                wlRound.amountMax = amountsMax[i];\n            }\n\n        }\n    }\n\n    /*\n     * modifyTGEWhitelistAddresses - Define what addresses are included/excluded from a whitelist round\n     *\n     * index - 0-based index of round to modify whitelist\n     * duration - period in seconds from TGE event or previous whitelist round\n     * amountMax - max amount (TOKEN decimals) for each whitelist round\n     *\n     */\n\n    function modifyTGEWhitelist(uint256 index, uint256 duration, uint256 amountMax, address[] calldata addresses, bool enabled) external onlyOwner {\n        require(index < _tgeWhitelistRounds.length, \"Invalid index\");\n        require(amountMax > 0, \"Invalid amountMax\");\n\n        if(duration != _tgeWhitelistRounds[index].duration)\n            _tgeWhitelistRounds[index].duration = duration;\n\n        if(amountMax != _tgeWhitelistRounds[index].amountMax)\n            _tgeWhitelistRounds[index].amountMax = amountMax;\n\n        for (uint256 i = 0; i < addresses.length; i++) {\n            _tgeWhitelistRounds[index].addresses[addresses[i]] = enabled;\n        }\n    }\n\n    /*\n     *  getTGEWhitelistRound\n     *\n     *  returns:\n     *\n     *  1. whitelist round number ( 0 = no active round now )\n     *  2. duration, in seconds, current whitelist round is active for\n     *  3. timestamp current whitelist round closes at\n     *  4. maximum amount a whitelister can purchase in this round\n     *  5. is caller whitelisted\n     *  6. how much caller has purchased in current whitelist round\n     *\n     */\n\n    function getTGEWhitelistRound() public view returns (uint256, uint256, uint256, uint256, bool, uint256) {\n\n        if(_tgeTimestamp > 0) {\n\n            uint256 wlCloseTimestampLast = _tgeTimestamp;\n\n            for (uint256 i = 0; i < _tgeWhitelistRounds.length; i++) {\n\n                WhitelistRound storage wlRound = _tgeWhitelistRounds[i];\n\n                wlCloseTimestampLast = wlCloseTimestampLast.add(wlRound.duration);\n                if(block.timestamp <= wlCloseTimestampLast)\n                    return (i.add(1), wlRound.duration, wlCloseTimestampLast, wlRound.amountMax, wlRound.addresses[_msgSender()], wlRound.purchased[_msgSender()]);\n            }\n\n        }\n\n        return (0, 0, 0, 0, false, 0);\n    }\n\n    /*\n     * _applyTGEWhitelist - internal function to be called initially before any transfers\n     *\n     */\n\n    function _applyTGEWhitelist(address sender, address recipient, uint256 amount) internal {\n\n        if(_tgePairAddress == address(0) || _tgeWhitelistRounds.length == 0)\n            return;\n\n        if(_tgeTimestamp == 0 && sender != _tgePairAddress && recipient == _tgePairAddress && amount > 0)\n            _tgeTimestamp = block.timestamp;\n\n        if(sender == _tgePairAddress && recipient != _tgePairAddress) {\n            //buying\n\n            (uint256 wlRoundNumber,,,,,) = getTGEWhitelistRound();\n\n            if(wlRoundNumber > 0) {\n\n                WhitelistRound storage wlRound = _tgeWhitelistRounds[wlRoundNumber.sub(1)];\n\n                require(wlRound.addresses[recipient], \"TGE - Buyer is not whitelisted\");\n\n                uint256 amountRemaining = 0;\n\n                if(wlRound.purchased[recipient] < wlRound.amountMax)\n                    amountRemaining = wlRound.amountMax.sub(wlRound.purchased[recipient]);\n\n                require(amount <= amountRemaining, \"TGE - Amount exceeds whitelist maximum\");\n                wlRound.purchased[recipient] = wlRound.purchased[recipient].add(amount);\n\n            }\n\n        }\n\n    }\n\n\n    \n    function setMaxTxPercent(uint256 _maxTxPercent) external onlyOwner {\n        maxTxPercent = _maxTxPercent;\n    }\n\n    \n    function setTransferDelay(uint256 _transferDelay) external onlyOwner {\n        transferDelay = _transferDelay;\n    }\n\n    \n    function setAntibotPaused(bool _antibotPaused) external onlyOwner {\n        antibotPaused = _antibotPaused;\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/ImmuneBytes-WadzPay-Audit Report/code/WadzPayToken.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No\nReason: The code uses the SafeMath library for arithmetic operations, which prevents integer overflow."
    }
]