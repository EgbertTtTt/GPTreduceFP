[
    {
        "code_segment": "library BasicMathLib {\n  \n  \n  \n  \n  \n  \n  function times(uint256 a, uint256 b) public pure returns (bool err,uint256 res) {\n    assembly{\n      res := mul(a,b)\n      switch or(iszero(b), eq(div(res,b), a))\n      case 0 {\n        err := 1\n        res := 0\n      }\n    }\n  }\n\n  \n  \n  \n  \n  \n  \n  function dividedBy(uint256 a, uint256 b) public pure returns (bool err,uint256 i) {\n    uint256 res;\n    assembly{\n      switch iszero(b)\n      case 0 {\n        res := div(a,b)\n        let loc := mload(0x40)\n        mstore(add(loc,0x20),res)\n        i := mload(add(loc,0x20))\n      }\n      default {\n        err := 1\n        i := 0\n      }\n    }\n  }\n\n  \n  \n  \n  \n  \n  \n  function plus(uint256 a, uint256 b) public pure returns (bool err, uint256 res) {\n    assembly{\n      res := add(a,b)\n      switch and(eq(sub(res,b), a), or(gt(res,b),eq(res,b)))\n      case 0 {\n        err := 1\n        res := 0\n      }\n    }\n  }\n\n  \n  \n  \n  \n  \n  \n  function minus(uint256 a, uint256 b) public pure returns (bool err,uint256 res) {\n    assembly{\n      res := sub(a,b)\n      switch eq(and(eq(add(res,b), a), or(lt(res,a), eq(res,a))), 1)\n      case 0 {\n        err := 1\n        res := 0\n      }\n    }\n  }\n}",
        "function": "plus(uint256,uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/consensys-Modular_Interactive_Crowdsale/ethereum-libraries-73abc22623e0841b8ea67a5089002f4867102672/BasicMathLib/BasicMathLib.sol",
        "vulnerability": "Integer Arithmetic Bugs (SWC 101)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "library BasicMathLib {\n  \n  \n  \n  \n  \n  \n  function times(uint256 a, uint256 b) public pure returns (bool err,uint256 res) {\n    assembly{\n      res := mul(a,b)\n      switch or(iszero(b), eq(div(res,b), a))\n      case 0 {\n        err := 1\n        res := 0\n      }\n    }\n  }\n\n  \n  \n  \n  \n  \n  \n  function dividedBy(uint256 a, uint256 b) public pure returns (bool err,uint256 i) {\n    uint256 res;\n    assembly{\n      switch iszero(b)\n      case 0 {\n        res := div(a,b)\n        let loc := mload(0x40)\n        mstore(add(loc,0x20),res)\n        i := mload(add(loc,0x20))\n      }\n      default {\n        err := 1\n        i := 0\n      }\n    }\n  }\n\n  \n  \n  \n  \n  \n  \n  function plus(uint256 a, uint256 b) public pure returns (bool err, uint256 res) {\n    assembly{\n      res := add(a,b)\n      switch and(eq(sub(res,b), a), or(gt(res,b),eq(res,b)))\n      case 0 {\n        err := 1\n        res := 0\n      }\n    }\n  }\n\n  \n  \n  \n  \n  \n  \n  function minus(uint256 a, uint256 b) public pure returns (bool err,uint256 res) {\n    assembly{\n      res := sub(a,b)\n      switch eq(and(eq(add(res,b), a), or(lt(res,a), eq(res,a))), 1)\n      case 0 {\n        err := 1\n        res := 0\n      }\n    }\n  }\n}",
        "function": "plus(uint256,uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/consensys-Modular_Interactive_Crowdsale/ethereum-libraries-73abc22623e0841b8ea67a5089002f4867102672/BasicMathLib/BasicMathLib.sol",
        "vulnerability": "Integer Arithmetic Bugs (SWC 101)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "library BasicMathLib {\n  \n  \n  \n  \n  \n  \n  function times(uint256 a, uint256 b) public pure returns (bool err,uint256 res) {\n    assembly{\n      res := mul(a,b)\n      switch or(iszero(b), eq(div(res,b), a))\n      case 0 {\n        err := 1\n        res := 0\n      }\n    }\n  }\n\n  \n  \n  \n  \n  \n  \n  function dividedBy(uint256 a, uint256 b) public pure returns (bool err,uint256 i) {\n    uint256 res;\n    assembly{\n      switch iszero(b)\n      case 0 {\n        res := div(a,b)\n        let loc := mload(0x40)\n        mstore(add(loc,0x20),res)\n        i := mload(add(loc,0x20))\n      }\n      default {\n        err := 1\n        i := 0\n      }\n    }\n  }\n\n  \n  \n  \n  \n  \n  \n  function plus(uint256 a, uint256 b) public pure returns (bool err, uint256 res) {\n    assembly{\n      res := add(a,b)\n      switch and(eq(sub(res,b), a), or(gt(res,b),eq(res,b)))\n      case 0 {\n        err := 1\n        res := 0\n      }\n    }\n  }\n\n  \n  \n  \n  \n  \n  \n  function minus(uint256 a, uint256 b) public pure returns (bool err,uint256 res) {\n    assembly{\n      res := sub(a,b)\n      switch eq(and(eq(add(res,b), a), or(lt(res,a), eq(res,a))), 1)\n      case 0 {\n        err := 1\n        res := 0\n      }\n    }\n  }\n}",
        "function": "minus(uint256,uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/consensys-Modular_Interactive_Crowdsale/ethereum-libraries-73abc22623e0841b8ea67a5089002f4867102672/BasicMathLib/BasicMathLib.sol",
        "vulnerability": "Integer Arithmetic Bugs (SWC 101)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "library BasicMathLib {\n  \n  \n  \n  \n  \n  \n  function times(uint256 a, uint256 b) public pure returns (bool err,uint256 res) {\n    assembly{\n      res := mul(a,b)\n      switch or(iszero(b), eq(div(res,b), a))\n      case 0 {\n        err := 1\n        res := 0\n      }\n    }\n  }\n\n  \n  \n  \n  \n  \n  \n  function dividedBy(uint256 a, uint256 b) public pure returns (bool err,uint256 i) {\n    uint256 res;\n    assembly{\n      switch iszero(b)\n      case 0 {\n        res := div(a,b)\n        let loc := mload(0x40)\n        mstore(add(loc,0x20),res)\n        i := mload(add(loc,0x20))\n      }\n      default {\n        err := 1\n        i := 0\n      }\n    }\n  }\n\n  \n  \n  \n  \n  \n  \n  function plus(uint256 a, uint256 b) public pure returns (bool err, uint256 res) {\n    assembly{\n      res := add(a,b)\n      switch and(eq(sub(res,b), a), or(gt(res,b),eq(res,b)))\n      case 0 {\n        err := 1\n        res := 0\n      }\n    }\n  }\n\n  \n  \n  \n  \n  \n  \n  function minus(uint256 a, uint256 b) public pure returns (bool err,uint256 res) {\n    assembly{\n      res := sub(a,b)\n      switch eq(and(eq(add(res,b), a), or(lt(res,a), eq(res,a))), 1)\n      case 0 {\n        err := 1\n        res := 0\n      }\n    }\n  }\n}",
        "function": "minus(uint256,uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/consensys-Modular_Interactive_Crowdsale/ethereum-libraries-73abc22623e0841b8ea67a5089002f4867102672/BasicMathLib/BasicMathLib.sol",
        "vulnerability": "Integer Arithmetic Bugs (SWC 101)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "library Array256Lib {\n\n  \n  \n  \n  function sumElements(uint256[] storage self) public view returns(uint256 sum) {\n    assembly {\n      mstore(0x60,self_slot)\n\n      for { let i := 0 } lt(i, sload(self_slot)) { i := add(i, 1) } {\n        sum := add(sload(add(sha3(0x60,0x20),i)),sum)\n      }\n    }\n  }\n\n  \n  \n  \n  function getMax(uint256[] storage self) public view returns(uint256 maxValue) {\n    assembly {\n      mstore(0x60,self_slot)\n      maxValue := sload(sha3(0x60,0x20))\n\n      for { let i := 0 } lt(i, sload(self_slot)) { i := add(i, 1) } {\n        switch gt(sload(add(sha3(0x60,0x20),i)), maxValue)\n        case 1 {\n          maxValue := sload(add(sha3(0x60,0x20),i))\n        }\n      }\n    }\n  }\n\n  \n  \n  \n  function getMin(uint256[] storage self) public view returns(uint256 minValue) {\n    assembly {\n      mstore(0x60,self_slot)\n      minValue := sload(sha3(0x60,0x20))\n\n      for { let i := 0 } lt(i, sload(self_slot)) { i := add(i, 1) } {\n        switch gt(sload(add(sha3(0x60,0x20),i)), minValue)\n        case 0 {\n          minValue := sload(add(sha3(0x60,0x20),i))\n        }\n      }\n    }\n  }\n\n  \n  \n  \n  \n  \n  \n  function indexOf(uint256[] storage self, uint256 value, bool isSorted)\n           public\n           view\n           returns(bool found, uint256 index) {\n    assembly{\n      mstore(0x60,self_slot)\n      switch isSorted\n      case 1 {\n        let high := sub(sload(self_slot),1)\n        let mid := 0\n        let low := 0\n        for { } iszero(gt(low, high)) { } {\n          mid := div(add(low,high),2)\n\n          switch lt(sload(add(sha3(0x60,0x20),mid)),value)\n          case 1 {\n             low := add(mid,1)\n          }\n          case 0 {\n            switch gt(sload(add(sha3(0x60,0x20),mid)),value)\n            case 1 {\n              high := sub(mid,1)\n            }\n            case 0 {\n              found := 1\n              index := mid\n              low := add(high,1)\n            }\n          }\n        }\n      }\n      case 0 {\n        for { let low := 0 } lt(low, sload(self_slot)) { low := add(low, 1) } {\n          switch eq(sload(add(sha3(0x60,0x20),low)), value)\n          case 1 {\n            found := 1\n            index := low\n            low := sload(self_slot)\n          }\n        }\n      }\n    }\n  }\n\n  \n  \n  \n  function getParentI(uint256 index) private pure returns (uint256 pI) {\n    uint256 i = index - 1;\n    pI = i/2;\n  }\n\n  \n  \n  \n  function getLeftChildI(uint256 index) private pure returns (uint256 lcI) {\n    uint256 i = index * 2;\n    lcI = i + 1;\n  }\n\n  \n  \n  function heapSort(uint256[] storage self) public {\n    uint256 end = self.length - 1;\n    uint256 start = getParentI(end);\n    uint256 root = start;\n    uint256 lChild;\n    uint256 rChild;\n    uint256 swap;\n    uint256 temp;\n    while(start >= 0){\n      root = start;\n      lChild = getLeftChildI(start);\n      while(lChild <= end){\n        rChild = lChild + 1;\n        swap = root;\n        if(self[swap] < self[lChild])\n          swap = lChild;\n        if((rChild <= end) && (self[swap]<self[rChild]))\n          swap = rChild;\n        if(swap == root)\n          lChild = end+1;\n        else {\n          temp = self[swap];\n          self[swap] = self[root];\n          self[root] = temp;\n          root = swap;\n          lChild = getLeftChildI(root);\n        }\n      }\n      if(start == 0)\n        break;\n      else\n        start = start - 1;\n    }\n    while(end > 0){\n      temp = self[end];\n      self[end] = self[0];\n      self[0] = temp;\n      end = end - 1;\n      root = 0;\n      lChild = getLeftChildI(0);\n      while(lChild <= end){\n        rChild = lChild + 1;\n        swap = root;\n        if(self[swap] < self[lChild])\n          swap = lChild;\n        if((rChild <= end) && (self[swap]<self[rChild]))\n          swap = rChild;\n        if(swap == root)\n          lChild = end + 1;\n        else {\n          temp = self[swap];\n          self[swap] = self[root];\n          self[root] = temp;\n          root = swap;\n          lChild = getLeftChildI(root);\n        }\n      }\n    }\n  }\n\n  \n  \n  function uniq(uint256[] storage self) public returns (uint256 length) {\n    bool contains;\n    uint256 index;\n\n    for (uint256 i = 0; i < self.length; i++) {\n      (contains, index) = indexOf(self, self[i], false);\n\n      if (i > index) {\n        for (uint256 j = i; j < self.length - 1; j++){\n          self[j] = self[j + 1];\n        }\n\n        delete self[self.length - 1];\n        self.length--;\n        i--;\n      }\n    }\n\n    length = self.length;\n  }\n}",
        "function": "heapSort(uint256[] storage)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/consensys-Modular_Interactive_Crowdsale/ethereum-libraries-73abc22623e0841b8ea67a5089002f4867102672/ArrayUtilsLib/Array256Lib.sol",
        "vulnerability": "Exception State (SWC 110)",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract Migrations {\n  address public owner;\n  uint public last_completed_migration;\n\n  constructor() public {\n    owner = msg.sender;\n  }\n\n  modifier restricted() {\n    if (msg.sender == owner) _;\n  }\n\n  function setCompleted(uint completed) public restricted {\n    last_completed_migration = completed;\n  }\n\n  function upgrade(address new_address) public restricted {\n    Migrations upgraded = Migrations(new_address);\n    upgraded.setCompleted(last_completed_migration);\n  }\n}",
        "function": "upgrade(address)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/QuillAudits-Akropolis-Vesting/AkropolisToken-28a415392489a1a88073c3d0fd22b141f4d3170e/contracts/Migrations.sol",
        "vulnerability": "External Call To User-Supplied Address (SWC 107)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract Migrations {\n  address public owner;\n  uint public last_completed_migration;\n\n  constructor() public {\n    owner = msg.sender;\n  }\n\n  modifier restricted() {\n    if (msg.sender == owner) _;\n  }\n\n  function setCompleted(uint completed) public restricted {\n    last_completed_migration = completed;\n  }\n\n  function upgrade(address new_address) public restricted {\n    Migrations upgraded = Migrations(new_address);\n    upgraded.setCompleted(last_completed_migration);\n  }\n}",
        "function": "upgrade(address)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/QuillAudits-Akropolis-Vesting/akropolis-vesting-7f4f4543b08d3749b92839c85e1d77a33d917a37/contracts/Migrations.sol",
        "vulnerability": "External Call To User-Supplied Address (SWC 107)",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract TokenTranchePricing is Ownable {\n\n  using SafeMath for uint;\n\n  /**\n   * Define pricing schedule using tranches.\n   */\n  struct Tranche {\n      // Amount in tokens when this tranche becomes inactive\n      uint amount;\n      // Block interval [start, end)\n      // Starting block (included in the interval)\n      uint start;\n      // Ending block (excluded from the interval)\n      uint end;\n      // How many tokens per wei you will get while this tranche is active\n      uint price;\n  }\n  // We define offsets and size for the deserialization of ordered tuples in raw arrays\n  uint private constant amount_offset = 0;\n  uint private constant start_offset = 1;\n  uint private constant end_offset = 2;\n  uint private constant price_offset = 3;\n  uint private constant tranche_size = 4;\n\n  Tranche[] public tranches;\n  // SWC-101-Integer Overflow and Underflow: L45-69\n  \n  \n  function TokenTranchePricing(uint[] init_tranches) public {\n    // Need to have tuples, length check\n    require(init_tranches.length % tranche_size == 0);\n    // A tranche with amount zero can never be selected and is therefore useless.\n    // This check and the one inside the loop ensure no tranche can have an amount equal to zero.\n    require(init_tranches[amount_offset] > 0);\n\n    tranches.length = init_tranches.length / tranche_size;\n    for (uint i = 0; i < init_tranches.length / tranche_size; i++) {\n      // No invalid steps\n      uint amount = init_tranches[i * tranche_size + amount_offset];\n      uint start = init_tranches[i * tranche_size + start_offset];\n      uint end = init_tranches[i * tranche_size + end_offset];\n      require(block.number < start && start < end);\n      // Bail out when entering unnecessary tranches\n      // This is preferably checked before deploying contract into any blockchain.\n      require(i == 0 || (end >= tranches[i - 1].end && amount > tranches[i - 1].amount) ||\n              (end > tranches[i - 1].end && amount >= tranches[i - 1].amount));\n\n      tranches[i].amount = amount;\n      tranches[i].price = init_tranches[i * tranche_size + price_offset];\n      tranches[i].start = start;\n      tranches[i].end = end;\n    }\n  }\n\n  \n  \n  \n  function getCurrentTranche(uint tokensSold) private constant returns (Tranche) {\n    for (uint i = 0; i < tranches.length; i++) {\n      if (tranches[i].start <= block.number && block.number < tranches[i].end && tokensSold < tranches[i].amount) {\n        return tranches[i];\n      }\n    }\n    // No tranche is currently active\n    revert();\n  }\n\n  \n  \n  \n  function getCurrentPrice(uint tokensSold) public constant returns (uint result) {\n    return getCurrentTranche(tokensSold).price;\n  }\n\n}",
        "function": "constructor",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinfabrik-Worldbit Token Sale Smart Contract Audit/ico-445cc0c28894a85cb58f54631666deafdd35d859/contracts/TokenTranchePricing.sol",
        "vulnerability": "Exception State (SWC 110)",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "library Utils {\n    using SafeMath for uint256;\n//SWC-120-Weak Sources of Randomness from Chain Attributes:L693-707\n    function random(uint256 from, uint256 to, uint256 salty) private view returns (uint256) {\n        uint256 seed = uint256(\n            keccak256(\n                abi.encodePacked(\n                    block.timestamp + block.difficulty +\n                    ((uint256(keccak256(abi.encodePacked(block.coinbase)))) / (now)) +\n                    block.gaslimit +\n                    ((uint256(keccak256(abi.encodePacked(msg.sender)))) / (now)) +\n                    block.number +\n                    salty\n                )\n            )\n        );\n        return seed.mod(to - from) + from;\n    }\n\n    function isLotteryWon(uint256 salty, uint256 winningDoubleRewardPercentage) private view returns (bool) {\n        uint256 luckyNumber = random(0, 100, salty);\n        uint256 winPercentage = winningDoubleRewardPercentage;\n        return luckyNumber <= winPercentage;\n    }\n\n    function calculateBNBReward(\n        uint256 _tTotal,\n        uint256 currentBalance,\n        uint256 currentBNBPool,\n        uint256 winningDoubleRewardPercentage,\n        uint256 totalSupply,\n        address ofAddress\n    ) public view returns (uint256) {\n        uint256 bnbPool = currentBNBPool;\n\n        // calculate reward to send\n        bool isLotteryWonOnClaim = isLotteryWon(currentBalance, winningDoubleRewardPercentage);\n        uint256 multiplier = 100;\n\n        if (isLotteryWonOnClaim) {\n            multiplier = random(150, 200, currentBalance);\n        }\n\n        // now calculate reward\n        uint256 reward = bnbPool.mul(multiplier).mul(currentBalance).div(100).div(totalSupply);\n\n        return reward;\n    }\n\n    function calculateTopUpClaim(\n        uint256 currentRecipientBalance,\n        uint256 basedRewardCycleBlock,\n        uint256 threshHoldTopUpRate,\n        uint256 amount\n    ) public returns (uint256) {\n        if (currentRecipientBalance == 0) {\n            return block.timestamp + basedRewardCycleBlock;\n        }\n        else {\n            uint256 rate = amount.mul(100).div(currentRecipientBalance);\n\n            if (uint256(rate) >= threshHoldTopUpRate) {\n                uint256 incurCycleBlock = basedRewardCycleBlock.mul(uint256(rate)).div(100);\n\n                if (incurCycleBlock >= basedRewardCycleBlock) {\n                    incurCycleBlock = basedRewardCycleBlock;\n                }\n\n                return incurCycleBlock;\n            }\n\n            return 0;\n        }\n    }\n\n    function swapTokensForEth(\n        address routerAddress,\n        uint256 tokenAmount\n    ) public {\n        IPancakeRouter02 pancakeRouter = IPancakeRouter02(routerAddress);\n\n        // generate the pancake pair path of token -> weth\n        address[] memory path = new address[](2);\n        path[0] = address(this);\n        path[1] = pancakeRouter.WETH();\n\n        // make the swap\n        pancakeRouter.swapExactTokensForETHSupportingFeeOnTransferTokens(\n            tokenAmount,\n            0, // accept any amount of BNB\n            path,\n            address(this),\n            block.timestamp\n        );\n    }\n\n    function swapETHForTokens(\n        address routerAddress,\n        address recipient,\n        uint256 ethAmount\n    ) public {\n        IPancakeRouter02 pancakeRouter = IPancakeRouter02(routerAddress);\n\n        // generate the pancake pair path of token -> weth\n        address[] memory path = new address[](2);\n        path[0] = pancakeRouter.WETH();\n        path[1] = address(this);\n\n        // make the swap\n        pancakeRouter.swapExactETHForTokensSupportingFeeOnTransferTokens{value: ethAmount}(\n            0, // accept any amount of BNB\n            path,\n            address(recipient),\n            block.timestamp + 360\n        );\n    }\n\n    function addLiquidity(\n        address routerAddress,\n        address owner,\n        uint256 tokenAmount,\n        uint256 ethAmount\n    ) public {\n        IPancakeRouter02 pancakeRouter = IPancakeRouter02(routerAddress);\n\n        // add the liquidity\n        pancakeRouter.addLiquidityETH{value : ethAmount}(\n            address(this),\n            tokenAmount,\n            0, // slippage is unavoidable\n            0, // slippage is unavoidable\n            owner,\n            block.timestamp + 360\n        );\n    }\n}",
        "function": "calculateBNBReward(uint256,uint256,uint256,uint256,uint256,address)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/QuillAudits-GARFIELD Smart Contract/code/GARFIELD.sol",
        "vulnerability": "Dependence on predictable environment variable (SWC 116)",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "library Utils {\n    using SafeMath for uint256;\n//SWC-120-Weak Sources of Randomness from Chain Attributes:L693-707\n    function random(uint256 from, uint256 to, uint256 salty) private view returns (uint256) {\n        uint256 seed = uint256(\n            keccak256(\n                abi.encodePacked(\n                    block.timestamp + block.difficulty +\n                    ((uint256(keccak256(abi.encodePacked(block.coinbase)))) / (now)) +\n                    block.gaslimit +\n                    ((uint256(keccak256(abi.encodePacked(msg.sender)))) / (now)) +\n                    block.number +\n                    salty\n                )\n            )\n        );\n        return seed.mod(to - from) + from;\n    }\n\n    function isLotteryWon(uint256 salty, uint256 winningDoubleRewardPercentage) private view returns (bool) {\n        uint256 luckyNumber = random(0, 100, salty);\n        uint256 winPercentage = winningDoubleRewardPercentage;\n        return luckyNumber <= winPercentage;\n    }\n\n    function calculateBNBReward(\n        uint256 _tTotal,\n        uint256 currentBalance,\n        uint256 currentBNBPool,\n        uint256 winningDoubleRewardPercentage,\n        uint256 totalSupply,\n        address ofAddress\n    ) public view returns (uint256) {\n        uint256 bnbPool = currentBNBPool;\n\n        // calculate reward to send\n        bool isLotteryWonOnClaim = isLotteryWon(currentBalance, winningDoubleRewardPercentage);\n        uint256 multiplier = 100;\n\n        if (isLotteryWonOnClaim) {\n            multiplier = random(150, 200, currentBalance);\n        }\n\n        // now calculate reward\n        uint256 reward = bnbPool.mul(multiplier).mul(currentBalance).div(100).div(totalSupply);\n\n        return reward;\n    }\n\n    function calculateTopUpClaim(\n        uint256 currentRecipientBalance,\n        uint256 basedRewardCycleBlock,\n        uint256 threshHoldTopUpRate,\n        uint256 amount\n    ) public returns (uint256) {\n        if (currentRecipientBalance == 0) {\n            return block.timestamp + basedRewardCycleBlock;\n        }\n        else {\n            uint256 rate = amount.mul(100).div(currentRecipientBalance);\n\n            if (uint256(rate) >= threshHoldTopUpRate) {\n                uint256 incurCycleBlock = basedRewardCycleBlock.mul(uint256(rate)).div(100);\n\n                if (incurCycleBlock >= basedRewardCycleBlock) {\n                    incurCycleBlock = basedRewardCycleBlock;\n                }\n\n                return incurCycleBlock;\n            }\n\n            return 0;\n        }\n    }\n\n    function swapTokensForEth(\n        address routerAddress,\n        uint256 tokenAmount\n    ) public {\n        IPancakeRouter02 pancakeRouter = IPancakeRouter02(routerAddress);\n\n        // generate the pancake pair path of token -> weth\n        address[] memory path = new address[](2);\n        path[0] = address(this);\n        path[1] = pancakeRouter.WETH();\n\n        // make the swap\n        pancakeRouter.swapExactTokensForETHSupportingFeeOnTransferTokens(\n            tokenAmount,\n            0, // accept any amount of BNB\n            path,\n            address(this),\n            block.timestamp\n        );\n    }\n\n    function swapETHForTokens(\n        address routerAddress,\n        address recipient,\n        uint256 ethAmount\n    ) public {\n        IPancakeRouter02 pancakeRouter = IPancakeRouter02(routerAddress);\n\n        // generate the pancake pair path of token -> weth\n        address[] memory path = new address[](2);\n        path[0] = pancakeRouter.WETH();\n        path[1] = address(this);\n\n        // make the swap\n        pancakeRouter.swapExactETHForTokensSupportingFeeOnTransferTokens{value: ethAmount}(\n            0, // accept any amount of BNB\n            path,\n            address(recipient),\n            block.timestamp + 360\n        );\n    }\n\n    function addLiquidity(\n        address routerAddress,\n        address owner,\n        uint256 tokenAmount,\n        uint256 ethAmount\n    ) public {\n        IPancakeRouter02 pancakeRouter = IPancakeRouter02(routerAddress);\n\n        // add the liquidity\n        pancakeRouter.addLiquidityETH{value : ethAmount}(\n            address(this),\n            tokenAmount,\n            0, // slippage is unavoidable\n            0, // slippage is unavoidable\n            owner,\n            block.timestamp + 360\n        );\n    }\n}",
        "function": "calculateBNBReward(uint256,uint256,uint256,uint256,uint256,address)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/QuillAudits-GARFIELD Smart Contract/code/GARFIELD.sol",
        "vulnerability": "Exception State (SWC 110)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "library Utils {\n    using SafeMath for uint256;\n//SWC-120-Weak Sources of Randomness from Chain Attributes:L693-707\n    function random(uint256 from, uint256 to, uint256 salty) private view returns (uint256) {\n        uint256 seed = uint256(\n            keccak256(\n                abi.encodePacked(\n                    block.timestamp + block.difficulty +\n                    ((uint256(keccak256(abi.encodePacked(block.coinbase)))) / (now)) +\n                    block.gaslimit +\n                    ((uint256(keccak256(abi.encodePacked(msg.sender)))) / (now)) +\n                    block.number +\n                    salty\n                )\n            )\n        );\n        return seed.mod(to - from) + from;\n    }\n\n    function isLotteryWon(uint256 salty, uint256 winningDoubleRewardPercentage) private view returns (bool) {\n        uint256 luckyNumber = random(0, 100, salty);\n        uint256 winPercentage = winningDoubleRewardPercentage;\n        return luckyNumber <= winPercentage;\n    }\n\n    function calculateBNBReward(\n        uint256 _tTotal,\n        uint256 currentBalance,\n        uint256 currentBNBPool,\n        uint256 winningDoubleRewardPercentage,\n        uint256 totalSupply,\n        address ofAddress\n    ) public view returns (uint256) {\n        uint256 bnbPool = currentBNBPool;\n\n        // calculate reward to send\n        bool isLotteryWonOnClaim = isLotteryWon(currentBalance, winningDoubleRewardPercentage);\n        uint256 multiplier = 100;\n\n        if (isLotteryWonOnClaim) {\n            multiplier = random(150, 200, currentBalance);\n        }\n\n        // now calculate reward\n        uint256 reward = bnbPool.mul(multiplier).mul(currentBalance).div(100).div(totalSupply);\n\n        return reward;\n    }\n\n    function calculateTopUpClaim(\n        uint256 currentRecipientBalance,\n        uint256 basedRewardCycleBlock,\n        uint256 threshHoldTopUpRate,\n        uint256 amount\n    ) public returns (uint256) {\n        if (currentRecipientBalance == 0) {\n            return block.timestamp + basedRewardCycleBlock;\n        }\n        else {\n            uint256 rate = amount.mul(100).div(currentRecipientBalance);\n\n            if (uint256(rate) >= threshHoldTopUpRate) {\n                uint256 incurCycleBlock = basedRewardCycleBlock.mul(uint256(rate)).div(100);\n\n                if (incurCycleBlock >= basedRewardCycleBlock) {\n                    incurCycleBlock = basedRewardCycleBlock;\n                }\n\n                return incurCycleBlock;\n            }\n\n            return 0;\n        }\n    }\n\n    function swapTokensForEth(\n        address routerAddress,\n        uint256 tokenAmount\n    ) public {\n        IPancakeRouter02 pancakeRouter = IPancakeRouter02(routerAddress);\n\n        // generate the pancake pair path of token -> weth\n        address[] memory path = new address[](2);\n        path[0] = address(this);\n        path[1] = pancakeRouter.WETH();\n\n        // make the swap\n        pancakeRouter.swapExactTokensForETHSupportingFeeOnTransferTokens(\n            tokenAmount,\n            0, // accept any amount of BNB\n            path,\n            address(this),\n            block.timestamp\n        );\n    }\n\n    function swapETHForTokens(\n        address routerAddress,\n        address recipient,\n        uint256 ethAmount\n    ) public {\n        IPancakeRouter02 pancakeRouter = IPancakeRouter02(routerAddress);\n\n        // generate the pancake pair path of token -> weth\n        address[] memory path = new address[](2);\n        path[0] = pancakeRouter.WETH();\n        path[1] = address(this);\n\n        // make the swap\n        pancakeRouter.swapExactETHForTokensSupportingFeeOnTransferTokens{value: ethAmount}(\n            0, // accept any amount of BNB\n            path,\n            address(recipient),\n            block.timestamp + 360\n        );\n    }\n\n    function addLiquidity(\n        address routerAddress,\n        address owner,\n        uint256 tokenAmount,\n        uint256 ethAmount\n    ) public {\n        IPancakeRouter02 pancakeRouter = IPancakeRouter02(routerAddress);\n\n        // add the liquidity\n        pancakeRouter.addLiquidityETH{value : ethAmount}(\n            address(this),\n            tokenAmount,\n            0, // slippage is unavoidable\n            0, // slippage is unavoidable\n            owner,\n            block.timestamp + 360\n        );\n    }\n}",
        "function": "calculateBNBReward(uint256,uint256,uint256,uint256,uint256,address)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/QuillAudits-GARFIELD Smart Contract/code/GARFIELD.sol",
        "vulnerability": "Dependence on predictable environment variable (SWC 116)",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract Migrations {\n  address public owner;\n  uint public last_completed_migration;\n\n  constructor() public {\n    owner = msg.sender;\n  }\n\n  modifier restricted() {\n    if (msg.sender == owner) _;\n  }\n\n  function setCompleted(uint completed) public restricted {\n    last_completed_migration = completed;\n  }\n\n  function upgrade(address new_address) public restricted {\n    Migrations upgraded = Migrations(new_address);\n    upgraded.setCompleted(last_completed_migration);\n  }\n}",
        "function": "upgrade(address)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinfabrik-EasyPool Smart Contract Security Audit/EasyPool-master/contracts/Migrations.sol",
        "vulnerability": "External Call To User-Supplied Address (SWC 107)",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract Owned {\n  event OwnerAddition(address indexed owner);\n\n  event OwnerRemoval(address indexed owner);\n\n  // owner address to enable admin functions\n  mapping (address => bool) public isOwner;\n\n  address[] public owners;\n\n  address public operator;\n\n  modifier onlyOwner {\n\n    require(isOwner[msg.sender]);\n    _;\n  }\n\n  modifier onlyOperator {\n    require(msg.sender == operator);\n    _;\n  }\n\n  function setOperator(address _operator) external onlyOwner {\n    require(_operator != address(0));\n    operator = _operator;\n  }\n\n  function removeOwner(address _owner) public onlyOwner {\n    require(owners.length > 1);\n    isOwner[_owner] = false;\n    for (uint i = 0; i < owners.length - 1; i++) {\n      if (owners[i] == _owner) {\n        owners[i] = owners[SafeMath.sub(owners.length, 1)];\n        break;\n      }\n    }\n    owners.length = SafeMath.sub(owners.length, 1);\n    OwnerRemoval(_owner);\n  }\n\n  function addOwner(address _owner) external onlyOwner {\n    require(_owner != address(0));\n    if(isOwner[_owner]) return;\n    isOwner[_owner] = true;\n    owners.push(_owner);\n    OwnerAddition(_owner);\n  }\n\n  function setOwners(address[] _owners) internal {\n    for (uint i = 0; i < _owners.length; i++) {\n      require(_owners[i] != address(0));\n      isOwner[_owners[i]] = true;\n      OwnerAddition(_owners[i]);\n    }\n    owners = _owners;\n  }\n\n  function getOwners() public constant returns (address[])  {\n    return owners;\n  }\n\n}",
        "function": "owners(uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Blockchain Labs NZ-Leverj/staking-e8716e4a11881fad181b5330206d8b0c27a58510/contracts/Fee.sol",
        "vulnerability": "Exception State (SWC 110)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract MixinAssetProxyDispatcher is\n    Ownable,\n    MAssetProxyDispatcher {\n    // SWC-135-Code With No Effects: L32\n    using LibBytes for bytes;\n    \n    // Mapping from Asset Proxy Id's to their respective Asset Proxy\n    mapping (bytes4 => IAssetProxy) public assetProxies;\n\n    \n    \n    \n    function registerAssetProxy(address assetProxy)\n        external\n        onlyOwner\n    {\n        IAssetProxy assetProxyContract = IAssetProxy(assetProxy);\n\n        // Ensure that no asset proxy exists with current id.\n        bytes4 assetProxyId = assetProxyContract.getProxyId();\n        address currentAssetProxy = assetProxies[assetProxyId];\n        require(\n            currentAssetProxy == address(0),\n            \"ASSET_PROXY_ALREADY_EXISTS\"\n        );\n\n        // Add asset proxy and log registration.\n        assetProxies[assetProxyId] = assetProxyContract;\n        emit AssetProxyRegistered(\n            assetProxyId,\n            assetProxy\n        );\n    }\n\n    \n    \n    \n    function getAssetProxy(bytes4 assetProxyId)\n        external\n        view\n        returns (address)\n    {\n        return assetProxies[assetProxyId];\n    }\n\n    \n    \n    \n    \n    \n    function dispatchTransferFrom(\n        bytes memory assetData,\n        address from,\n        address to,\n        uint256 amount\n    )\n        internal\n    {\n        // Do nothing if no amount should be transferred.\n        if (amount > 0) {\n            // Ensure assetData length is valid\n            require(\n                assetData.length > 3,\n                \"LENGTH_GREATER_THAN_3_REQUIRED\"\n            );\n            \n            // Lookup assetProxy\n            bytes4 assetProxyId;\n            assembly {\n                assetProxyId := and(mload(\n                    add(assetData, 32)),\n                    0xFFFFFFFF00000000000000000000000000000000000000000000000000000000\n                )\n            }\n            address assetProxy = assetProxies[assetProxyId];\n\n            // Ensure that assetProxy exists\n            require(\n                assetProxy != address(0),\n                \"ASSET_PROXY_DOES_NOT_EXIST\"\n            );\n            \n            // We construct calldata for the `assetProxy.transferFrom` ABI.\n            // The layout of this calldata is in the table below.\n            // \n            // | Area     | Offset | Length  | Contents                                    |\n            // | -------- |--------|---------|-------------------------------------------- |\n            // | Header   | 0      | 4       | function selector                           |\n            // | Params   |        | 4 * 32  | function parameters:                        |\n            // |          | 4      |         |   1. offset to assetData (*)                |\n            // |          | 36     |         |   2. from                                   |\n            // |          | 68     |         |   3. to                                     |\n            // |          | 100    |         |   4. amount                                 |\n            // | Data     |        |         | assetData:                                  |\n            // |          | 132    | 32      | assetData Length                            |\n            // |          | 164    | **      | assetData Contents                          |\n\n            assembly {\n                \n                // `cdStart` is the start of the calldata for `assetProxy.transferFrom` (equal to free memory ptr).\n                let cdStart := mload(64)\n                // `dataAreaLength` is the total number of words needed to store `assetData`\n                //  As-per the ABI spec, this value is padded up to the nearest multiple of 32,\n                //  and includes 32-bytes for length.\n                let dataAreaLength := and(add(mload(assetData), 63), 0xFFFFFFFFFFFE0)\n                // `cdEnd` is the end of the calldata for `assetProxy.transferFrom`.\n                let cdEnd := add(cdStart, add(132, dataAreaLength))\n\n                \n                \n                // This area holds the 4-byte `transferFromSelector`.\n                // bytes4(keccak256(\"transferFrom(bytes,address,address,uint256)\")) = 0xa85e59e4\n                mstore(cdStart, 0xa85e59e400000000000000000000000000000000000000000000000000000000)\n                \n                \n                // Each parameter is padded to 32-bytes. The entire Params Area is 128 bytes.\n                // Notes:\n                //   1. The offset to `assetData` is the length of the Params Area (128 bytes).\n                //   2. A 20-byte mask is applied to addresses to zero-out the unused bytes.\n                mstore(add(cdStart, 4), 128)\n                mstore(add(cdStart, 36), and(from, 0xffffffffffffffffffffffffffffffffffffffff))\n                mstore(add(cdStart, 68), and(to, 0xffffffffffffffffffffffffffffffffffffffff))\n                mstore(add(cdStart, 100), amount)\n                \n                \n                // This area holds `assetData`.\n                let dataArea := add(cdStart, 132)\n                // solhint-disable-next-line no-empty-blocks\n                for {} lt(dataArea, cdEnd) {} {\n                    mstore(dataArea, mload(assetData))\n                    dataArea := add(dataArea, 32)\n                    assetData := add(assetData, 32)\n                }\n\n                \n                let success := call(\n                    gas,                    // forward all gas\n                    assetProxy,             // call address of asset proxy\n                    0,                      // don't send any ETH\n                    cdStart,                // pointer to start of input\n                    sub(cdEnd, cdStart),    // length of input  \n                    cdStart,                // write output over input\n                    512                     // reserve 512 bytes for output\n                )\n                if iszero(success) {\n                    revert(cdStart, returndatasize())\n                }\n            }\n        }\n    }\n}",
        "function": "registerAssetProxy(address)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/consensys-0x_Protocol_v2/0x-monorepo-a05b14e4d9659be1cc495ee33fd8962ce773f87f/packages/contracts/src/2.0.0/protocol/Exchange/MixinAssetProxyDispatcher.sol",
        "vulnerability": "External Call To User-Supplied Address (SWC 107)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract MixinAssetProxyDispatcher is\n    Ownable,\n    MAssetProxyDispatcher {\n    // SWC-135-Code With No Effects: L32\n    using LibBytes for bytes;\n    \n    // Mapping from Asset Proxy Id's to their respective Asset Proxy\n    mapping (bytes4 => IAssetProxy) public assetProxies;\n\n    \n    \n    \n    function registerAssetProxy(address assetProxy)\n        external\n        onlyOwner\n    {\n        IAssetProxy assetProxyContract = IAssetProxy(assetProxy);\n\n        // Ensure that no asset proxy exists with current id.\n        bytes4 assetProxyId = assetProxyContract.getProxyId();\n        address currentAssetProxy = assetProxies[assetProxyId];\n        require(\n            currentAssetProxy == address(0),\n            \"ASSET_PROXY_ALREADY_EXISTS\"\n        );\n\n        // Add asset proxy and log registration.\n        assetProxies[assetProxyId] = assetProxyContract;\n        emit AssetProxyRegistered(\n            assetProxyId,\n            assetProxy\n        );\n    }\n\n    \n    \n    \n    function getAssetProxy(bytes4 assetProxyId)\n        external\n        view\n        returns (address)\n    {\n        return assetProxies[assetProxyId];\n    }\n\n    \n    \n    \n    \n    \n    function dispatchTransferFrom(\n        bytes memory assetData,\n        address from,\n        address to,\n        uint256 amount\n    )\n        internal\n    {\n        // Do nothing if no amount should be transferred.\n        if (amount > 0) {\n            // Ensure assetData length is valid\n            require(\n                assetData.length > 3,\n                \"LENGTH_GREATER_THAN_3_REQUIRED\"\n            );\n            \n            // Lookup assetProxy\n            bytes4 assetProxyId;\n            assembly {\n                assetProxyId := and(mload(\n                    add(assetData, 32)),\n                    0xFFFFFFFF00000000000000000000000000000000000000000000000000000000\n                )\n            }\n            address assetProxy = assetProxies[assetProxyId];\n\n            // Ensure that assetProxy exists\n            require(\n                assetProxy != address(0),\n                \"ASSET_PROXY_DOES_NOT_EXIST\"\n            );\n            \n            // We construct calldata for the `assetProxy.transferFrom` ABI.\n            // The layout of this calldata is in the table below.\n            // \n            // | Area     | Offset | Length  | Contents                                    |\n            // | -------- |--------|---------|-------------------------------------------- |\n            // | Header   | 0      | 4       | function selector                           |\n            // | Params   |        | 4 * 32  | function parameters:                        |\n            // |          | 4      |         |   1. offset to assetData (*)                |\n            // |          | 36     |         |   2. from                                   |\n            // |          | 68     |         |   3. to                                     |\n            // |          | 100    |         |   4. amount                                 |\n            // | Data     |        |         | assetData:                                  |\n            // |          | 132    | 32      | assetData Length                            |\n            // |          | 164    | **      | assetData Contents                          |\n\n            assembly {\n                \n                // `cdStart` is the start of the calldata for `assetProxy.transferFrom` (equal to free memory ptr).\n                let cdStart := mload(64)\n                // `dataAreaLength` is the total number of words needed to store `assetData`\n                //  As-per the ABI spec, this value is padded up to the nearest multiple of 32,\n                //  and includes 32-bytes for length.\n                let dataAreaLength := and(add(mload(assetData), 63), 0xFFFFFFFFFFFE0)\n                // `cdEnd` is the end of the calldata for `assetProxy.transferFrom`.\n                let cdEnd := add(cdStart, add(132, dataAreaLength))\n\n                \n                \n                // This area holds the 4-byte `transferFromSelector`.\n                // bytes4(keccak256(\"transferFrom(bytes,address,address,uint256)\")) = 0xa85e59e4\n                mstore(cdStart, 0xa85e59e400000000000000000000000000000000000000000000000000000000)\n                \n                \n                // Each parameter is padded to 32-bytes. The entire Params Area is 128 bytes.\n                // Notes:\n                //   1. The offset to `assetData` is the length of the Params Area (128 bytes).\n                //   2. A 20-byte mask is applied to addresses to zero-out the unused bytes.\n                mstore(add(cdStart, 4), 128)\n                mstore(add(cdStart, 36), and(from, 0xffffffffffffffffffffffffffffffffffffffff))\n                mstore(add(cdStart, 68), and(to, 0xffffffffffffffffffffffffffffffffffffffff))\n                mstore(add(cdStart, 100), amount)\n                \n                \n                // This area holds `assetData`.\n                let dataArea := add(cdStart, 132)\n                // solhint-disable-next-line no-empty-blocks\n                for {} lt(dataArea, cdEnd) {} {\n                    mstore(dataArea, mload(assetData))\n                    dataArea := add(dataArea, 32)\n                    assetData := add(assetData, 32)\n                }\n\n                \n                let success := call(\n                    gas,                    // forward all gas\n                    assetProxy,             // call address of asset proxy\n                    0,                      // don't send any ETH\n                    cdStart,                // pointer to start of input\n                    sub(cdEnd, cdStart),    // length of input  \n                    cdStart,                // write output over input\n                    512                     // reserve 512 bytes for output\n                )\n                if iszero(success) {\n                    revert(cdStart, returndatasize())\n                }\n            }\n        }\n    }\n}",
        "function": "registerAssetProxy(address)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/consensys-0x_Protocol_v2/0x-monorepo-a05b14e4d9659be1cc495ee33fd8962ce773f87f/packages/contracts/src/2.0.0/protocol/Exchange/MixinAssetProxyDispatcher.sol",
        "vulnerability": "State access after external call (SWC 107)",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract MixinAssetProxyDispatcher is\n    Ownable,\n    MAssetProxyDispatcher {\n    // SWC-135-Code With No Effects: L32\n    using LibBytes for bytes;\n    \n    // Mapping from Asset Proxy Id's to their respective Asset Proxy\n    mapping (bytes4 => IAssetProxy) public assetProxies;\n\n    \n    \n    \n    function registerAssetProxy(address assetProxy)\n        external\n        onlyOwner\n    {\n        IAssetProxy assetProxyContract = IAssetProxy(assetProxy);\n\n        // Ensure that no asset proxy exists with current id.\n        bytes4 assetProxyId = assetProxyContract.getProxyId();\n        address currentAssetProxy = assetProxies[assetProxyId];\n        require(\n            currentAssetProxy == address(0),\n            \"ASSET_PROXY_ALREADY_EXISTS\"\n        );\n\n        // Add asset proxy and log registration.\n        assetProxies[assetProxyId] = assetProxyContract;\n        emit AssetProxyRegistered(\n            assetProxyId,\n            assetProxy\n        );\n    }\n\n    \n    \n    \n    function getAssetProxy(bytes4 assetProxyId)\n        external\n        view\n        returns (address)\n    {\n        return assetProxies[assetProxyId];\n    }\n\n    \n    \n    \n    \n    \n    function dispatchTransferFrom(\n        bytes memory assetData,\n        address from,\n        address to,\n        uint256 amount\n    )\n        internal\n    {\n        // Do nothing if no amount should be transferred.\n        if (amount > 0) {\n            // Ensure assetData length is valid\n            require(\n                assetData.length > 3,\n                \"LENGTH_GREATER_THAN_3_REQUIRED\"\n            );\n            \n            // Lookup assetProxy\n            bytes4 assetProxyId;\n            assembly {\n                assetProxyId := and(mload(\n                    add(assetData, 32)),\n                    0xFFFFFFFF00000000000000000000000000000000000000000000000000000000\n                )\n            }\n            address assetProxy = assetProxies[assetProxyId];\n\n            // Ensure that assetProxy exists\n            require(\n                assetProxy != address(0),\n                \"ASSET_PROXY_DOES_NOT_EXIST\"\n            );\n            \n            // We construct calldata for the `assetProxy.transferFrom` ABI.\n            // The layout of this calldata is in the table below.\n            // \n            // | Area     | Offset | Length  | Contents                                    |\n            // | -------- |--------|---------|-------------------------------------------- |\n            // | Header   | 0      | 4       | function selector                           |\n            // | Params   |        | 4 * 32  | function parameters:                        |\n            // |          | 4      |         |   1. offset to assetData (*)                |\n            // |          | 36     |         |   2. from                                   |\n            // |          | 68     |         |   3. to                                     |\n            // |          | 100    |         |   4. amount                                 |\n            // | Data     |        |         | assetData:                                  |\n            // |          | 132    | 32      | assetData Length                            |\n            // |          | 164    | **      | assetData Contents                          |\n\n            assembly {\n                \n                // `cdStart` is the start of the calldata for `assetProxy.transferFrom` (equal to free memory ptr).\n                let cdStart := mload(64)\n                // `dataAreaLength` is the total number of words needed to store `assetData`\n                //  As-per the ABI spec, this value is padded up to the nearest multiple of 32,\n                //  and includes 32-bytes for length.\n                let dataAreaLength := and(add(mload(assetData), 63), 0xFFFFFFFFFFFE0)\n                // `cdEnd` is the end of the calldata for `assetProxy.transferFrom`.\n                let cdEnd := add(cdStart, add(132, dataAreaLength))\n\n                \n                \n                // This area holds the 4-byte `transferFromSelector`.\n                // bytes4(keccak256(\"transferFrom(bytes,address,address,uint256)\")) = 0xa85e59e4\n                mstore(cdStart, 0xa85e59e400000000000000000000000000000000000000000000000000000000)\n                \n                \n                // Each parameter is padded to 32-bytes. The entire Params Area is 128 bytes.\n                // Notes:\n                //   1. The offset to `assetData` is the length of the Params Area (128 bytes).\n                //   2. A 20-byte mask is applied to addresses to zero-out the unused bytes.\n                mstore(add(cdStart, 4), 128)\n                mstore(add(cdStart, 36), and(from, 0xffffffffffffffffffffffffffffffffffffffff))\n                mstore(add(cdStart, 68), and(to, 0xffffffffffffffffffffffffffffffffffffffff))\n                mstore(add(cdStart, 100), amount)\n                \n                \n                // This area holds `assetData`.\n                let dataArea := add(cdStart, 132)\n                // solhint-disable-next-line no-empty-blocks\n                for {} lt(dataArea, cdEnd) {} {\n                    mstore(dataArea, mload(assetData))\n                    dataArea := add(dataArea, 32)\n                    assetData := add(assetData, 32)\n                }\n\n                \n                let success := call(\n                    gas,                    // forward all gas\n                    assetProxy,             // call address of asset proxy\n                    0,                      // don't send any ETH\n                    cdStart,                // pointer to start of input\n                    sub(cdEnd, cdStart),    // length of input  \n                    cdStart,                // write output over input\n                    512                     // reserve 512 bytes for output\n                )\n                if iszero(success) {\n                    revert(cdStart, returndatasize())\n                }\n            }\n        }\n    }\n}",
        "function": "registerAssetProxy(address)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/consensys-0x_Protocol_v2/0x-monorepo-a05b14e4d9659be1cc495ee33fd8962ce773f87f/packages/contracts/src/2.0.0/protocol/Exchange/MixinAssetProxyDispatcher.sol",
        "vulnerability": "State access after external call (SWC 107)",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract MixinAssetProxyDispatcher is\n    Ownable,\n    MAssetProxyDispatcher {\n    // SWC-135-Code With No Effects: L32\n    using LibBytes for bytes;\n    \n    // Mapping from Asset Proxy Id's to their respective Asset Proxy\n    mapping (bytes4 => IAssetProxy) public assetProxies;\n\n    \n    \n    \n    function registerAssetProxy(address assetProxy)\n        external\n        onlyOwner\n    {\n        IAssetProxy assetProxyContract = IAssetProxy(assetProxy);\n\n        // Ensure that no asset proxy exists with current id.\n        bytes4 assetProxyId = assetProxyContract.getProxyId();\n        address currentAssetProxy = assetProxies[assetProxyId];\n        require(\n            currentAssetProxy == address(0),\n            \"ASSET_PROXY_ALREADY_EXISTS\"\n        );\n\n        // Add asset proxy and log registration.\n        assetProxies[assetProxyId] = assetProxyContract;\n        emit AssetProxyRegistered(\n            assetProxyId,\n            assetProxy\n        );\n    }\n\n    \n    \n    \n    function getAssetProxy(bytes4 assetProxyId)\n        external\n        view\n        returns (address)\n    {\n        return assetProxies[assetProxyId];\n    }\n\n    \n    \n    \n    \n    \n    function dispatchTransferFrom(\n        bytes memory assetData,\n        address from,\n        address to,\n        uint256 amount\n    )\n        internal\n    {\n        // Do nothing if no amount should be transferred.\n        if (amount > 0) {\n            // Ensure assetData length is valid\n            require(\n                assetData.length > 3,\n                \"LENGTH_GREATER_THAN_3_REQUIRED\"\n            );\n            \n            // Lookup assetProxy\n            bytes4 assetProxyId;\n            assembly {\n                assetProxyId := and(mload(\n                    add(assetData, 32)),\n                    0xFFFFFFFF00000000000000000000000000000000000000000000000000000000\n                )\n            }\n            address assetProxy = assetProxies[assetProxyId];\n\n            // Ensure that assetProxy exists\n            require(\n                assetProxy != address(0),\n                \"ASSET_PROXY_DOES_NOT_EXIST\"\n            );\n            \n            // We construct calldata for the `assetProxy.transferFrom` ABI.\n            // The layout of this calldata is in the table below.\n            // \n            // | Area     | Offset | Length  | Contents                                    |\n            // | -------- |--------|---------|-------------------------------------------- |\n            // | Header   | 0      | 4       | function selector                           |\n            // | Params   |        | 4 * 32  | function parameters:                        |\n            // |          | 4      |         |   1. offset to assetData (*)                |\n            // |          | 36     |         |   2. from                                   |\n            // |          | 68     |         |   3. to                                     |\n            // |          | 100    |         |   4. amount                                 |\n            // | Data     |        |         | assetData:                                  |\n            // |          | 132    | 32      | assetData Length                            |\n            // |          | 164    | **      | assetData Contents                          |\n\n            assembly {\n                \n                // `cdStart` is the start of the calldata for `assetProxy.transferFrom` (equal to free memory ptr).\n                let cdStart := mload(64)\n                // `dataAreaLength` is the total number of words needed to store `assetData`\n                //  As-per the ABI spec, this value is padded up to the nearest multiple of 32,\n                //  and includes 32-bytes for length.\n                let dataAreaLength := and(add(mload(assetData), 63), 0xFFFFFFFFFFFE0)\n                // `cdEnd` is the end of the calldata for `assetProxy.transferFrom`.\n                let cdEnd := add(cdStart, add(132, dataAreaLength))\n\n                \n                \n                // This area holds the 4-byte `transferFromSelector`.\n                // bytes4(keccak256(\"transferFrom(bytes,address,address,uint256)\")) = 0xa85e59e4\n                mstore(cdStart, 0xa85e59e400000000000000000000000000000000000000000000000000000000)\n                \n                \n                // Each parameter is padded to 32-bytes. The entire Params Area is 128 bytes.\n                // Notes:\n                //   1. The offset to `assetData` is the length of the Params Area (128 bytes).\n                //   2. A 20-byte mask is applied to addresses to zero-out the unused bytes.\n                mstore(add(cdStart, 4), 128)\n                mstore(add(cdStart, 36), and(from, 0xffffffffffffffffffffffffffffffffffffffff))\n                mstore(add(cdStart, 68), and(to, 0xffffffffffffffffffffffffffffffffffffffff))\n                mstore(add(cdStart, 100), amount)\n                \n                \n                // This area holds `assetData`.\n                let dataArea := add(cdStart, 132)\n                // solhint-disable-next-line no-empty-blocks\n                for {} lt(dataArea, cdEnd) {} {\n                    mstore(dataArea, mload(assetData))\n                    dataArea := add(dataArea, 32)\n                    assetData := add(assetData, 32)\n                }\n\n                \n                let success := call(\n                    gas,                    // forward all gas\n                    assetProxy,             // call address of asset proxy\n                    0,                      // don't send any ETH\n                    cdStart,                // pointer to start of input\n                    sub(cdEnd, cdStart),    // length of input  \n                    cdStart,                // write output over input\n                    512                     // reserve 512 bytes for output\n                )\n                if iszero(success) {\n                    revert(cdStart, returndatasize())\n                }\n            }\n        }\n    }\n}",
        "function": "registerAssetProxy(address)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/consensys-0x_Protocol_v2/0x-monorepo-a05b14e4d9659be1cc495ee33fd8962ce773f87f/packages/contracts/src/2.0.0/protocol/Exchange/MixinAssetProxyDispatcher.sol",
        "vulnerability": "State access after external call (SWC 107)",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract SphrVestingStatic is Ownable {\n    \n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n    \n    struct VestingSchedule {\n        uint256 amount;\n        uint256 schedule;\n    }\n    \n    IERC20 private _token;\n    mapping (address => VestingSchedule[]) private _vestingSchedules;\n    mapping (address => uint256) private _releaseAmount;\n\n    \n    \n    constructor (IERC20 token) public {\n        _token = token;\n    }\n    \n    function tokenContract() public view virtual returns (address) {\n        return address(_token);\n    }\n    \n    function addVestingSchedule(address benificiary, uint256 amount, uint256 schedule) public onlyOwner returns (bool) {\n        VestingSchedule memory vs = VestingSchedule(amount, schedule);\n        _vestingSchedules[benificiary].push(vs);\n        return true;\n    }\n    \n    function vestedAmount() public view virtual returns (uint256) {\n        VestingSchedule[] memory vestingSchedules_ = _vestingSchedules[msg.sender];\n        \n        uint256 vestedAmount_;\n        for(uint256 i=0; i<vestingSchedules_.length; i++) {\n            if (vestingSchedules_[i].schedule < block.timestamp) {\n                vestedAmount_ += vestingSchedules_[i].amount;\n            }\n            \n        }\n        // SWC-101-Integer Overflow and Underflow: L707\n        vestedAmount_ -= _releaseAmount[msg.sender];\n        return vestedAmount_;\n    }\n    \n    function claim() public returns (bool) {\n        VestingSchedule[] memory vestingSchedules_ = _vestingSchedules[msg.sender];\n        \n        uint256 vestedAmount_;\n        for(uint256 i=0; i<vestingSchedules_.length; i++) {\n            if (vestingSchedules_[i].schedule < block.timestamp) {\n                vestedAmount_ += vestingSchedules_[i].amount;\n                delete vestingSchedules_[i];\n            }\n        }\n        vestedAmount_ -= _releaseAmount[msg.sender];\n        require(vestedAmount_ > 0, \"SphrVestingStatic: vested amount must be greater then 0\");\n        _token.safeTransfer(msg.sender, vestedAmount_);\n        _releaseAmount[msg.sender] += vestedAmount_;\n        return true;\n    }\n    \n    function getBlockTimestamp() public view virtual returns (uint256) {\n        return block.timestamp;\n    }\n}",
        "function": "vestedAmount()",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/PeckShield-Spherium/code/code.sol",
        "vulnerability": "Dependence on predictable environment variable (SWC 116)",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract SphrVestingStatic is Ownable {\n    \n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n    \n    struct VestingSchedule {\n        uint256 amount;\n        uint256 schedule;\n    }\n    \n    IERC20 private _token;\n    mapping (address => VestingSchedule[]) private _vestingSchedules;\n    mapping (address => uint256) private _releaseAmount;\n\n    \n    \n    constructor (IERC20 token) public {\n        _token = token;\n    }\n    \n    function tokenContract() public view virtual returns (address) {\n        return address(_token);\n    }\n    \n    function addVestingSchedule(address benificiary, uint256 amount, uint256 schedule) public onlyOwner returns (bool) {\n        VestingSchedule memory vs = VestingSchedule(amount, schedule);\n        _vestingSchedules[benificiary].push(vs);\n        return true;\n    }\n    \n    function vestedAmount() public view virtual returns (uint256) {\n        VestingSchedule[] memory vestingSchedules_ = _vestingSchedules[msg.sender];\n        \n        uint256 vestedAmount_;\n        for(uint256 i=0; i<vestingSchedules_.length; i++) {\n            if (vestingSchedules_[i].schedule < block.timestamp) {\n                vestedAmount_ += vestingSchedules_[i].amount;\n            }\n            \n        }\n        // SWC-101-Integer Overflow and Underflow: L707\n        vestedAmount_ -= _releaseAmount[msg.sender];\n        return vestedAmount_;\n    }\n    \n    function claim() public returns (bool) {\n        VestingSchedule[] memory vestingSchedules_ = _vestingSchedules[msg.sender];\n        \n        uint256 vestedAmount_;\n        for(uint256 i=0; i<vestingSchedules_.length; i++) {\n            if (vestingSchedules_[i].schedule < block.timestamp) {\n                vestedAmount_ += vestingSchedules_[i].amount;\n                delete vestingSchedules_[i];\n            }\n        }\n        vestedAmount_ -= _releaseAmount[msg.sender];\n        require(vestedAmount_ > 0, \"SphrVestingStatic: vested amount must be greater then 0\");\n        _token.safeTransfer(msg.sender, vestedAmount_);\n        _releaseAmount[msg.sender] += vestedAmount_;\n        return true;\n    }\n    \n    function getBlockTimestamp() public view virtual returns (uint256) {\n        return block.timestamp;\n    }\n}",
        "function": "claim()",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/PeckShield-Spherium/code/code.sol",
        "vulnerability": "Dependence on predictable environment variable (SWC 116)",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract Tier2FarmController {\n\n  using SafeMath\n    for uint256;\n\n\n  address payable public owner;\n  address payable public admin;\n  address public platformToken = 0x25550Cccbd68533Fa04bFD3e3AC4D09f9e00Fc50;\n  address public tokenStakingContract = 0x7d2768dE32b0b80b7a3454c06BdAc94A69DDc7A9;\n  address ETH_TOKEN_ADDRESS  = address(0x0);\n  mapping (string => address) public stakingContracts;\n  mapping (address => address) public tokenToFarmMapping;\n  mapping (string => address) public stakingContractsStakingToken;\n  mapping (address => mapping (address => uint256)) public depositBalances;\n  mapping (address => address) public tokenToAToken;\n    mapping (address => address) public aTokenToToken;\n  uint256 public commission  = 400; // Default is 4 percent\n\n\n  string public farmName = 'Aave';\n  mapping (address => uint256) public totalAmountStaked;\n\n   modifier onlyOwner {\n         require(\n             msg.sender == owner,\n             \"Only owner can call this function.\"\n         );\n         _;\n }\n\n  modifier onlyAdmin {\n         require(\n             msg.sender == admin,\n             \"Only admin can call this function.\"\n         );\n         _;\n }\n\n\n\n\n\n\n\n  constructor() public payable {\n        stakingContracts[\"DAI\"] =0x7d2768dE32b0b80b7a3454c06BdAc94A69DDc7A9 ;\n        stakingContracts[\"ALL\"] =0x7d2768dE32b0b80b7a3454c06BdAc94A69DDc7A9 ;\n        stakingContractsStakingToken [\"DAI\"] = 0x25550Cccbd68533Fa04bFD3e3AC4D09f9e00Fc50;\n        tokenToAToken[0x6B175474E89094C44Da98b954EedeAC495271d0F]= 0x25550Cccbd68533Fa04bFD3e3AC4D09f9e00Fc50;\n        aTokenToToken[0x25550Cccbd68533Fa04bFD3e3AC4D09f9e00Fc50]= 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n        tokenToFarmMapping[stakingContractsStakingToken [\"DAI\"]] =  stakingContracts[\"DAI\"];\n        owner= msg.sender;\n        admin = msg.sender;\n\n  }\n\n\n  fallback() external payable {\n\n\n  }\n\n\nfunction updateATokens(address tokenAddress, address aTokenAddress) public onlyAdmin returns (bool){\n    tokenToAToken[tokenAddress] = aTokenAddress;\n    aTokenToToken[aTokenAddress] = tokenAddress;\n    return true;\n}\n\n  function addOrEditStakingContract(string memory name, address stakingAddress, address stakingToken ) public onlyOwner returns (bool){\n\n    stakingContracts[name] = stakingAddress;\n    stakingContractsStakingToken[name] = stakingToken;\n    tokenToFarmMapping[stakingToken] = stakingAddress;\n\n    return true;\n\n  }\n\n  function updateCommission(uint amount) public onlyOwner returns(bool){\n      commission = amount;\n      return true;\n  }\n\n  function deposit(address tokenAddress, uint256 amount, address onBehalfOf) payable onlyOwner public returns (bool){\n\n\n\n\n        ERC20 thisToken = ERC20(tokenAddress);\n        require(thisToken.transferFrom(msg.sender, address(this), amount), \"Not enough tokens to transferFrom or no approval\");\n\n        depositBalances[onBehalfOf][tokenAddress] = depositBalances[onBehalfOf][tokenAddress].add(amount);\n\n        uint256 approvedAmount = thisToken.allowance(address(this), tokenToFarmMapping[tokenAddress]);\n        if(approvedAmount < amount  ){\n            thisToken.approve(tokenToFarmMapping[tokenAddress], amount.mul(10000000));\n        }\n        stake(amount, onBehalfOf, tokenAddress );\n\n        totalAmountStaked[tokenAddress] = totalAmountStaked[tokenAddress].add(amount);\n\n        emit Deposit(onBehalfOf, amount, tokenAddress);\n        return true;\n   }\n\n   function stake(uint256 amount, address onBehalfOf, address tokenAddress) internal returns(bool){\n\n      StakingInterface staker  = StakingInterface(tokenToFarmMapping[tokenAddress]);\n      staker.deposit(tokenAddress, amount, address(this), 0);\n      return true;\n\n   }\n\n   function unstake(uint256 amount, address onBehalfOf, address tokenAddress) internal returns(bool){\n      ERC20 aToken  = ERC20(tokenToAToken[tokenAddress]);\n      StakingInterface staker  =  StakingInterface(tokenToFarmMapping[tokenAddress]);\n      staker.withdraw(tokenAddress, aToken.balanceOf(address(this)), address(this));\n      return true;\n\n   }\n\n\n   function getStakedPoolBalanceByUser(address _owner, address tokenAddress) public view returns(uint256){\n        StakingInterface staker  = StakingInterface(tokenToFarmMapping[tokenAddress]);\n        ERC20 aToken  = ERC20(tokenToAToken[tokenAddress]);\n        uint256 numberTokens = aToken.balanceOf(address(this));\n\n        uint256 usersBalancePercentage = (depositBalances[_owner][tokenAddress].mul(1000000)).div(totalAmountStaked[tokenAddress]);\n        uint256 numberTokensPlusRewardsForUser= (numberTokens.mul(1000).mul(usersBalancePercentage)).div(1000000000);\n\n\n        return numberTokensPlusRewardsForUser;\n\n    }\n\n  //SWC-135-Code With No Effects: 205-253\n  function withdraw(address tokenAddress, uint256 amount, address payable onBehalfOf) onlyOwner payable public returns(bool){\n\n      ERC20 thisToken = ERC20(tokenAddress);\n      //uint256 numberTokensPreWithdrawal = getStakedBalance(address(this), tokenAddress);\n\n        if(tokenAddress == 0x0000000000000000000000000000000000000000){\n            require(depositBalances[msg.sender][tokenAddress] >= amount, \"You didnt deposit enough eth\");\n\n            totalAmountStaked[tokenAddress] = totalAmountStaked[tokenAddress].sub(depositBalances[onBehalfOf][tokenAddress]);\n            depositBalances[onBehalfOf][tokenAddress] = depositBalances[onBehalfOf][tokenAddress]  - amount;\n            onBehalfOf.send(amount);\n            return true;\n\n        }\n\n        require(depositBalances[onBehalfOf][tokenAddress] > 0, \"You dont have any tokens deposited\");\n\n        //uint256 numberTokensPostWithdrawal = thisToken.balanceOf(address(this));\n\n        //uint256 usersBalancePercentage = depositBalances[onBehalfOf][tokenAddress].div(totalAmountStaked[tokenAddress]);\n\n        uint256 numberTokensPlusRewardsForUser1 = getStakedPoolBalanceByUser(onBehalfOf, tokenAddress);\n        uint256 commissionForDAO1 = calculateCommission(numberTokensPlusRewardsForUser1);\n        uint256 numberTokensPlusRewardsForUserMinusCommission = numberTokensPlusRewardsForUser1-commissionForDAO1;\n\n        unstake(amount, onBehalfOf, tokenAddress);\n\n        //staking platforms only withdraw all for the most part, and for security sticking to this\n        totalAmountStaked[tokenAddress] = totalAmountStaked[tokenAddress].sub(depositBalances[onBehalfOf][tokenAddress]);\n\n        depositBalances[onBehalfOf][tokenAddress] = 0;\n        require(numberTokensPlusRewardsForUserMinusCommission >0, \"For some reason numberTokensPlusRewardsForUserMinusCommission is zero\");\n\n        require(thisToken.transfer(onBehalfOf, numberTokensPlusRewardsForUserMinusCommission), \"You dont have enough tokens inside this contract to withdraw from deposits\");\n        if(numberTokensPlusRewardsForUserMinusCommission >0){\n            thisToken.transfer(owner, commissionForDAO1);\n        }\n\n\n        uint256 remainingBalance = thisToken.balanceOf(address(this));\n        if(remainingBalance>0){\n            stake(remainingBalance, address(this), tokenAddress);\n        }\n\n\n        emit Withdrawal(onBehalfOf, amount, tokenAddress);\n        return true;\n\n   }\n\n\n   function calculateCommission(uint256 amount) view public returns(uint256){\n     uint256 commissionForDAO = (amount.mul(1000).mul(commission)).div(10000000);\n     return commissionForDAO;\n   }\n\n   function changeOwner(address payable newAdmin) onlyOwner public returns (bool){\n     owner = newAdmin;\n     return true;\n   }\n\n   function changeAdmin(address payable newOwner) onlyAdmin public returns (bool){\n     admin = newOwner;\n     return true;\n   }\n\n\n\n   function getStakedBalance(address _owner, address tokenAddress) public view returns(uint256){\n\n       ERC20 staker  = ERC20(tokenToAToken[tokenAddress]);\n       return staker.balanceOf(_owner);\n   }\n\n\n\n  function adminEmergencyWithdrawTokens(address token, uint amount, address payable destination) public onlyOwner returns(bool) {\n\n\n\n      if (address(token) == ETH_TOKEN_ADDRESS) {\n          destination.transfer(amount);\n      }\n      else {\n          ERC20 tokenToken = ERC20(token);\n          require(tokenToken.transfer(destination, amount));\n      }\n\n\n\n\n      return true;\n  }\n\n\n\n function kill() virtual public onlyOwner {\n\n         selfdestruct(owner);\n\n }\n\n\n    event Deposit(address indexed user, uint256 amount, address token);\n    event Withdrawal(address indexed user, uint256 amount, address token);\n\n\n\n\n}",
        "function": "adminEmergencyWithdrawTokens(address,uint256,address)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/PeckShield-Plexus/PlexusContracts-f7e8196a3881faee80369330f6844a7f38d65b65/contracts/tier2Aave.sol",
        "vulnerability": "External Call To User-Supplied Address (SWC 107)",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract Tier2FarmController {\n\n  using SafeMath\n    for uint256;\n\n\n  address payable public owner;\n  address payable public admin;\n  address public platformToken = 0x25550Cccbd68533Fa04bFD3e3AC4D09f9e00Fc50;\n  address public tokenStakingContract = 0x7d2768dE32b0b80b7a3454c06BdAc94A69DDc7A9;\n  address ETH_TOKEN_ADDRESS  = address(0x0);\n  mapping (string => address) public stakingContracts;\n  mapping (address => address) public tokenToFarmMapping;\n  mapping (string => address) public stakingContractsStakingToken;\n  mapping (address => mapping (address => uint256)) public depositBalances;\n  mapping (address => address) public tokenToAToken;\n    mapping (address => address) public aTokenToToken;\n  uint256 public commission  = 400; // Default is 4 percent\n\n\n  string public farmName = 'Aave';\n  mapping (address => uint256) public totalAmountStaked;\n\n   modifier onlyOwner {\n         require(\n             msg.sender == owner,\n             \"Only owner can call this function.\"\n         );\n         _;\n }\n\n  modifier onlyAdmin {\n         require(\n             msg.sender == admin,\n             \"Only admin can call this function.\"\n         );\n         _;\n }\n\n\n\n\n\n\n\n  constructor() public payable {\n        stakingContracts[\"DAI\"] =0x7d2768dE32b0b80b7a3454c06BdAc94A69DDc7A9 ;\n        stakingContracts[\"ALL\"] =0x7d2768dE32b0b80b7a3454c06BdAc94A69DDc7A9 ;\n        stakingContractsStakingToken [\"DAI\"] = 0x25550Cccbd68533Fa04bFD3e3AC4D09f9e00Fc50;\n        tokenToAToken[0x6B175474E89094C44Da98b954EedeAC495271d0F]= 0x25550Cccbd68533Fa04bFD3e3AC4D09f9e00Fc50;\n        aTokenToToken[0x25550Cccbd68533Fa04bFD3e3AC4D09f9e00Fc50]= 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n        tokenToFarmMapping[stakingContractsStakingToken [\"DAI\"]] =  stakingContracts[\"DAI\"];\n        owner= msg.sender;\n        admin = msg.sender;\n\n  }\n\n\n  fallback() external payable {\n\n\n  }\n\n\nfunction updateATokens(address tokenAddress, address aTokenAddress) public onlyAdmin returns (bool){\n    tokenToAToken[tokenAddress] = aTokenAddress;\n    aTokenToToken[aTokenAddress] = tokenAddress;\n    return true;\n}\n\n  function addOrEditStakingContract(string memory name, address stakingAddress, address stakingToken ) public onlyOwner returns (bool){\n\n    stakingContracts[name] = stakingAddress;\n    stakingContractsStakingToken[name] = stakingToken;\n    tokenToFarmMapping[stakingToken] = stakingAddress;\n\n    return true;\n\n  }\n\n  function updateCommission(uint amount) public onlyOwner returns(bool){\n      commission = amount;\n      return true;\n  }\n\n  function deposit(address tokenAddress, uint256 amount, address onBehalfOf) payable onlyOwner public returns (bool){\n\n\n\n\n        ERC20 thisToken = ERC20(tokenAddress);\n        require(thisToken.transferFrom(msg.sender, address(this), amount), \"Not enough tokens to transferFrom or no approval\");\n\n        depositBalances[onBehalfOf][tokenAddress] = depositBalances[onBehalfOf][tokenAddress].add(amount);\n\n        uint256 approvedAmount = thisToken.allowance(address(this), tokenToFarmMapping[tokenAddress]);\n        if(approvedAmount < amount  ){\n            thisToken.approve(tokenToFarmMapping[tokenAddress], amount.mul(10000000));\n        }\n        stake(amount, onBehalfOf, tokenAddress );\n\n        totalAmountStaked[tokenAddress] = totalAmountStaked[tokenAddress].add(amount);\n\n        emit Deposit(onBehalfOf, amount, tokenAddress);\n        return true;\n   }\n\n   function stake(uint256 amount, address onBehalfOf, address tokenAddress) internal returns(bool){\n\n      StakingInterface staker  = StakingInterface(tokenToFarmMapping[tokenAddress]);\n      staker.deposit(tokenAddress, amount, address(this), 0);\n      return true;\n\n   }\n\n   function unstake(uint256 amount, address onBehalfOf, address tokenAddress) internal returns(bool){\n      ERC20 aToken  = ERC20(tokenToAToken[tokenAddress]);\n      StakingInterface staker  =  StakingInterface(tokenToFarmMapping[tokenAddress]);\n      staker.withdraw(tokenAddress, aToken.balanceOf(address(this)), address(this));\n      return true;\n\n   }\n\n\n   function getStakedPoolBalanceByUser(address _owner, address tokenAddress) public view returns(uint256){\n        StakingInterface staker  = StakingInterface(tokenToFarmMapping[tokenAddress]);\n        ERC20 aToken  = ERC20(tokenToAToken[tokenAddress]);\n        uint256 numberTokens = aToken.balanceOf(address(this));\n\n        uint256 usersBalancePercentage = (depositBalances[_owner][tokenAddress].mul(1000000)).div(totalAmountStaked[tokenAddress]);\n        uint256 numberTokensPlusRewardsForUser= (numberTokens.mul(1000).mul(usersBalancePercentage)).div(1000000000);\n\n\n        return numberTokensPlusRewardsForUser;\n\n    }\n\n  //SWC-135-Code With No Effects: 205-253\n  function withdraw(address tokenAddress, uint256 amount, address payable onBehalfOf) onlyOwner payable public returns(bool){\n\n      ERC20 thisToken = ERC20(tokenAddress);\n      //uint256 numberTokensPreWithdrawal = getStakedBalance(address(this), tokenAddress);\n\n        if(tokenAddress == 0x0000000000000000000000000000000000000000){\n            require(depositBalances[msg.sender][tokenAddress] >= amount, \"You didnt deposit enough eth\");\n\n            totalAmountStaked[tokenAddress] = totalAmountStaked[tokenAddress].sub(depositBalances[onBehalfOf][tokenAddress]);\n            depositBalances[onBehalfOf][tokenAddress] = depositBalances[onBehalfOf][tokenAddress]  - amount;\n            onBehalfOf.send(amount);\n            return true;\n\n        }\n\n        require(depositBalances[onBehalfOf][tokenAddress] > 0, \"You dont have any tokens deposited\");\n\n        //uint256 numberTokensPostWithdrawal = thisToken.balanceOf(address(this));\n\n        //uint256 usersBalancePercentage = depositBalances[onBehalfOf][tokenAddress].div(totalAmountStaked[tokenAddress]);\n\n        uint256 numberTokensPlusRewardsForUser1 = getStakedPoolBalanceByUser(onBehalfOf, tokenAddress);\n        uint256 commissionForDAO1 = calculateCommission(numberTokensPlusRewardsForUser1);\n        uint256 numberTokensPlusRewardsForUserMinusCommission = numberTokensPlusRewardsForUser1-commissionForDAO1;\n\n        unstake(amount, onBehalfOf, tokenAddress);\n\n        //staking platforms only withdraw all for the most part, and for security sticking to this\n        totalAmountStaked[tokenAddress] = totalAmountStaked[tokenAddress].sub(depositBalances[onBehalfOf][tokenAddress]);\n\n        depositBalances[onBehalfOf][tokenAddress] = 0;\n        require(numberTokensPlusRewardsForUserMinusCommission >0, \"For some reason numberTokensPlusRewardsForUserMinusCommission is zero\");\n\n        require(thisToken.transfer(onBehalfOf, numberTokensPlusRewardsForUserMinusCommission), \"You dont have enough tokens inside this contract to withdraw from deposits\");\n        if(numberTokensPlusRewardsForUserMinusCommission >0){\n            thisToken.transfer(owner, commissionForDAO1);\n        }\n\n\n        uint256 remainingBalance = thisToken.balanceOf(address(this));\n        if(remainingBalance>0){\n            stake(remainingBalance, address(this), tokenAddress);\n        }\n\n\n        emit Withdrawal(onBehalfOf, amount, tokenAddress);\n        return true;\n\n   }\n\n\n   function calculateCommission(uint256 amount) view public returns(uint256){\n     uint256 commissionForDAO = (amount.mul(1000).mul(commission)).div(10000000);\n     return commissionForDAO;\n   }\n\n   function changeOwner(address payable newAdmin) onlyOwner public returns (bool){\n     owner = newAdmin;\n     return true;\n   }\n\n   function changeAdmin(address payable newOwner) onlyAdmin public returns (bool){\n     admin = newOwner;\n     return true;\n   }\n\n\n\n   function getStakedBalance(address _owner, address tokenAddress) public view returns(uint256){\n\n       ERC20 staker  = ERC20(tokenToAToken[tokenAddress]);\n       return staker.balanceOf(_owner);\n   }\n\n\n\n  function adminEmergencyWithdrawTokens(address token, uint amount, address payable destination) public onlyOwner returns(bool) {\n\n\n\n      if (address(token) == ETH_TOKEN_ADDRESS) {\n          destination.transfer(amount);\n      }\n      else {\n          ERC20 tokenToken = ERC20(token);\n          require(tokenToken.transfer(destination, amount));\n      }\n\n\n\n\n      return true;\n  }\n\n\n\n function kill() virtual public onlyOwner {\n\n         selfdestruct(owner);\n\n }\n\n\n    event Deposit(address indexed user, uint256 amount, address token);\n    event Withdrawal(address indexed user, uint256 amount, address token);\n\n\n\n\n}",
        "function": "deposit(address,uint256,address)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/PeckShield-Plexus/PlexusContracts-f7e8196a3881faee80369330f6844a7f38d65b65/contracts/tier2Aave.sol",
        "vulnerability": "External Call To User-Supplied Address (SWC 107)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract Tier2FarmController {\n\n  using SafeMath\n    for uint256;\n\n\n  address payable public owner;\n  address payable public admin;\n  address public platformToken = 0x25550Cccbd68533Fa04bFD3e3AC4D09f9e00Fc50;\n  address public tokenStakingContract = 0x7d2768dE32b0b80b7a3454c06BdAc94A69DDc7A9;\n  address ETH_TOKEN_ADDRESS  = address(0x0);\n  mapping (string => address) public stakingContracts;\n  mapping (address => address) public tokenToFarmMapping;\n  mapping (string => address) public stakingContractsStakingToken;\n  mapping (address => mapping (address => uint256)) public depositBalances;\n  mapping (address => address) public tokenToAToken;\n    mapping (address => address) public aTokenToToken;\n  uint256 public commission  = 400; // Default is 4 percent\n\n\n  string public farmName = 'Aave';\n  mapping (address => uint256) public totalAmountStaked;\n\n   modifier onlyOwner {\n         require(\n             msg.sender == owner,\n             \"Only owner can call this function.\"\n         );\n         _;\n }\n\n  modifier onlyAdmin {\n         require(\n             msg.sender == admin,\n             \"Only admin can call this function.\"\n         );\n         _;\n }\n\n\n\n\n\n\n\n  constructor() public payable {\n        stakingContracts[\"DAI\"] =0x7d2768dE32b0b80b7a3454c06BdAc94A69DDc7A9 ;\n        stakingContracts[\"ALL\"] =0x7d2768dE32b0b80b7a3454c06BdAc94A69DDc7A9 ;\n        stakingContractsStakingToken [\"DAI\"] = 0x25550Cccbd68533Fa04bFD3e3AC4D09f9e00Fc50;\n        tokenToAToken[0x6B175474E89094C44Da98b954EedeAC495271d0F]= 0x25550Cccbd68533Fa04bFD3e3AC4D09f9e00Fc50;\n        aTokenToToken[0x25550Cccbd68533Fa04bFD3e3AC4D09f9e00Fc50]= 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n        tokenToFarmMapping[stakingContractsStakingToken [\"DAI\"]] =  stakingContracts[\"DAI\"];\n        owner= msg.sender;\n        admin = msg.sender;\n\n  }\n\n\n  fallback() external payable {\n\n\n  }\n\n\nfunction updateATokens(address tokenAddress, address aTokenAddress) public onlyAdmin returns (bool){\n    tokenToAToken[tokenAddress] = aTokenAddress;\n    aTokenToToken[aTokenAddress] = tokenAddress;\n    return true;\n}\n\n  function addOrEditStakingContract(string memory name, address stakingAddress, address stakingToken ) public onlyOwner returns (bool){\n\n    stakingContracts[name] = stakingAddress;\n    stakingContractsStakingToken[name] = stakingToken;\n    tokenToFarmMapping[stakingToken] = stakingAddress;\n\n    return true;\n\n  }\n\n  function updateCommission(uint amount) public onlyOwner returns(bool){\n      commission = amount;\n      return true;\n  }\n\n  function deposit(address tokenAddress, uint256 amount, address onBehalfOf) payable onlyOwner public returns (bool){\n\n\n\n\n        ERC20 thisToken = ERC20(tokenAddress);\n        require(thisToken.transferFrom(msg.sender, address(this), amount), \"Not enough tokens to transferFrom or no approval\");\n\n        depositBalances[onBehalfOf][tokenAddress] = depositBalances[onBehalfOf][tokenAddress].add(amount);\n\n        uint256 approvedAmount = thisToken.allowance(address(this), tokenToFarmMapping[tokenAddress]);\n        if(approvedAmount < amount  ){\n            thisToken.approve(tokenToFarmMapping[tokenAddress], amount.mul(10000000));\n        }\n        stake(amount, onBehalfOf, tokenAddress );\n\n        totalAmountStaked[tokenAddress] = totalAmountStaked[tokenAddress].add(amount);\n\n        emit Deposit(onBehalfOf, amount, tokenAddress);\n        return true;\n   }\n\n   function stake(uint256 amount, address onBehalfOf, address tokenAddress) internal returns(bool){\n\n      StakingInterface staker  = StakingInterface(tokenToFarmMapping[tokenAddress]);\n      staker.deposit(tokenAddress, amount, address(this), 0);\n      return true;\n\n   }\n\n   function unstake(uint256 amount, address onBehalfOf, address tokenAddress) internal returns(bool){\n      ERC20 aToken  = ERC20(tokenToAToken[tokenAddress]);\n      StakingInterface staker  =  StakingInterface(tokenToFarmMapping[tokenAddress]);\n      staker.withdraw(tokenAddress, aToken.balanceOf(address(this)), address(this));\n      return true;\n\n   }\n\n\n   function getStakedPoolBalanceByUser(address _owner, address tokenAddress) public view returns(uint256){\n        StakingInterface staker  = StakingInterface(tokenToFarmMapping[tokenAddress]);\n        ERC20 aToken  = ERC20(tokenToAToken[tokenAddress]);\n        uint256 numberTokens = aToken.balanceOf(address(this));\n\n        uint256 usersBalancePercentage = (depositBalances[_owner][tokenAddress].mul(1000000)).div(totalAmountStaked[tokenAddress]);\n        uint256 numberTokensPlusRewardsForUser= (numberTokens.mul(1000).mul(usersBalancePercentage)).div(1000000000);\n\n\n        return numberTokensPlusRewardsForUser;\n\n    }\n\n  //SWC-135-Code With No Effects: 205-253\n  function withdraw(address tokenAddress, uint256 amount, address payable onBehalfOf) onlyOwner payable public returns(bool){\n\n      ERC20 thisToken = ERC20(tokenAddress);\n      //uint256 numberTokensPreWithdrawal = getStakedBalance(address(this), tokenAddress);\n\n        if(tokenAddress == 0x0000000000000000000000000000000000000000){\n            require(depositBalances[msg.sender][tokenAddress] >= amount, \"You didnt deposit enough eth\");\n\n            totalAmountStaked[tokenAddress] = totalAmountStaked[tokenAddress].sub(depositBalances[onBehalfOf][tokenAddress]);\n            depositBalances[onBehalfOf][tokenAddress] = depositBalances[onBehalfOf][tokenAddress]  - amount;\n            onBehalfOf.send(amount);\n            return true;\n\n        }\n\n        require(depositBalances[onBehalfOf][tokenAddress] > 0, \"You dont have any tokens deposited\");\n\n        //uint256 numberTokensPostWithdrawal = thisToken.balanceOf(address(this));\n\n        //uint256 usersBalancePercentage = depositBalances[onBehalfOf][tokenAddress].div(totalAmountStaked[tokenAddress]);\n\n        uint256 numberTokensPlusRewardsForUser1 = getStakedPoolBalanceByUser(onBehalfOf, tokenAddress);\n        uint256 commissionForDAO1 = calculateCommission(numberTokensPlusRewardsForUser1);\n        uint256 numberTokensPlusRewardsForUserMinusCommission = numberTokensPlusRewardsForUser1-commissionForDAO1;\n\n        unstake(amount, onBehalfOf, tokenAddress);\n\n        //staking platforms only withdraw all for the most part, and for security sticking to this\n        totalAmountStaked[tokenAddress] = totalAmountStaked[tokenAddress].sub(depositBalances[onBehalfOf][tokenAddress]);\n\n        depositBalances[onBehalfOf][tokenAddress] = 0;\n        require(numberTokensPlusRewardsForUserMinusCommission >0, \"For some reason numberTokensPlusRewardsForUserMinusCommission is zero\");\n\n        require(thisToken.transfer(onBehalfOf, numberTokensPlusRewardsForUserMinusCommission), \"You dont have enough tokens inside this contract to withdraw from deposits\");\n        if(numberTokensPlusRewardsForUserMinusCommission >0){\n            thisToken.transfer(owner, commissionForDAO1);\n        }\n\n\n        uint256 remainingBalance = thisToken.balanceOf(address(this));\n        if(remainingBalance>0){\n            stake(remainingBalance, address(this), tokenAddress);\n        }\n\n\n        emit Withdrawal(onBehalfOf, amount, tokenAddress);\n        return true;\n\n   }\n\n\n   function calculateCommission(uint256 amount) view public returns(uint256){\n     uint256 commissionForDAO = (amount.mul(1000).mul(commission)).div(10000000);\n     return commissionForDAO;\n   }\n\n   function changeOwner(address payable newAdmin) onlyOwner public returns (bool){\n     owner = newAdmin;\n     return true;\n   }\n\n   function changeAdmin(address payable newOwner) onlyAdmin public returns (bool){\n     admin = newOwner;\n     return true;\n   }\n\n\n\n   function getStakedBalance(address _owner, address tokenAddress) public view returns(uint256){\n\n       ERC20 staker  = ERC20(tokenToAToken[tokenAddress]);\n       return staker.balanceOf(_owner);\n   }\n\n\n\n  function adminEmergencyWithdrawTokens(address token, uint amount, address payable destination) public onlyOwner returns(bool) {\n\n\n\n      if (address(token) == ETH_TOKEN_ADDRESS) {\n          destination.transfer(amount);\n      }\n      else {\n          ERC20 tokenToken = ERC20(token);\n          require(tokenToken.transfer(destination, amount));\n      }\n\n\n\n\n      return true;\n  }\n\n\n\n function kill() virtual public onlyOwner {\n\n         selfdestruct(owner);\n\n }\n\n\n    event Deposit(address indexed user, uint256 amount, address token);\n    event Withdrawal(address indexed user, uint256 amount, address token);\n\n\n\n\n}",
        "function": "deposit(address,uint256,address)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/PeckShield-Plexus/PlexusContracts-f7e8196a3881faee80369330f6844a7f38d65b65/contracts/tier2Aave.sol",
        "vulnerability": "State access after external call (SWC 107)",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract Tier2FarmController {\n\n  using SafeMath\n    for uint256;\n\n\n  address payable public owner;\n  address payable public admin;\n  address public platformToken = 0x25550Cccbd68533Fa04bFD3e3AC4D09f9e00Fc50;\n  address public tokenStakingContract = 0x7d2768dE32b0b80b7a3454c06BdAc94A69DDc7A9;\n  address ETH_TOKEN_ADDRESS  = address(0x0);\n  mapping (string => address) public stakingContracts;\n  mapping (address => address) public tokenToFarmMapping;\n  mapping (string => address) public stakingContractsStakingToken;\n  mapping (address => mapping (address => uint256)) public depositBalances;\n  mapping (address => address) public tokenToAToken;\n    mapping (address => address) public aTokenToToken;\n  uint256 public commission  = 400; // Default is 4 percent\n\n\n  string public farmName = 'Aave';\n  mapping (address => uint256) public totalAmountStaked;\n\n   modifier onlyOwner {\n         require(\n             msg.sender == owner,\n             \"Only owner can call this function.\"\n         );\n         _;\n }\n\n  modifier onlyAdmin {\n         require(\n             msg.sender == admin,\n             \"Only admin can call this function.\"\n         );\n         _;\n }\n\n\n\n\n\n\n\n  constructor() public payable {\n        stakingContracts[\"DAI\"] =0x7d2768dE32b0b80b7a3454c06BdAc94A69DDc7A9 ;\n        stakingContracts[\"ALL\"] =0x7d2768dE32b0b80b7a3454c06BdAc94A69DDc7A9 ;\n        stakingContractsStakingToken [\"DAI\"] = 0x25550Cccbd68533Fa04bFD3e3AC4D09f9e00Fc50;\n        tokenToAToken[0x6B175474E89094C44Da98b954EedeAC495271d0F]= 0x25550Cccbd68533Fa04bFD3e3AC4D09f9e00Fc50;\n        aTokenToToken[0x25550Cccbd68533Fa04bFD3e3AC4D09f9e00Fc50]= 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n        tokenToFarmMapping[stakingContractsStakingToken [\"DAI\"]] =  stakingContracts[\"DAI\"];\n        owner= msg.sender;\n        admin = msg.sender;\n\n  }\n\n\n  fallback() external payable {\n\n\n  }\n\n\nfunction updateATokens(address tokenAddress, address aTokenAddress) public onlyAdmin returns (bool){\n    tokenToAToken[tokenAddress] = aTokenAddress;\n    aTokenToToken[aTokenAddress] = tokenAddress;\n    return true;\n}\n\n  function addOrEditStakingContract(string memory name, address stakingAddress, address stakingToken ) public onlyOwner returns (bool){\n\n    stakingContracts[name] = stakingAddress;\n    stakingContractsStakingToken[name] = stakingToken;\n    tokenToFarmMapping[stakingToken] = stakingAddress;\n\n    return true;\n\n  }\n\n  function updateCommission(uint amount) public onlyOwner returns(bool){\n      commission = amount;\n      return true;\n  }\n\n  function deposit(address tokenAddress, uint256 amount, address onBehalfOf) payable onlyOwner public returns (bool){\n\n\n\n\n        ERC20 thisToken = ERC20(tokenAddress);\n        require(thisToken.transferFrom(msg.sender, address(this), amount), \"Not enough tokens to transferFrom or no approval\");\n\n        depositBalances[onBehalfOf][tokenAddress] = depositBalances[onBehalfOf][tokenAddress].add(amount);\n\n        uint256 approvedAmount = thisToken.allowance(address(this), tokenToFarmMapping[tokenAddress]);\n        if(approvedAmount < amount  ){\n            thisToken.approve(tokenToFarmMapping[tokenAddress], amount.mul(10000000));\n        }\n        stake(amount, onBehalfOf, tokenAddress );\n\n        totalAmountStaked[tokenAddress] = totalAmountStaked[tokenAddress].add(amount);\n\n        emit Deposit(onBehalfOf, amount, tokenAddress);\n        return true;\n   }\n\n   function stake(uint256 amount, address onBehalfOf, address tokenAddress) internal returns(bool){\n\n      StakingInterface staker  = StakingInterface(tokenToFarmMapping[tokenAddress]);\n      staker.deposit(tokenAddress, amount, address(this), 0);\n      return true;\n\n   }\n\n   function unstake(uint256 amount, address onBehalfOf, address tokenAddress) internal returns(bool){\n      ERC20 aToken  = ERC20(tokenToAToken[tokenAddress]);\n      StakingInterface staker  =  StakingInterface(tokenToFarmMapping[tokenAddress]);\n      staker.withdraw(tokenAddress, aToken.balanceOf(address(this)), address(this));\n      return true;\n\n   }\n\n\n   function getStakedPoolBalanceByUser(address _owner, address tokenAddress) public view returns(uint256){\n        StakingInterface staker  = StakingInterface(tokenToFarmMapping[tokenAddress]);\n        ERC20 aToken  = ERC20(tokenToAToken[tokenAddress]);\n        uint256 numberTokens = aToken.balanceOf(address(this));\n\n        uint256 usersBalancePercentage = (depositBalances[_owner][tokenAddress].mul(1000000)).div(totalAmountStaked[tokenAddress]);\n        uint256 numberTokensPlusRewardsForUser= (numberTokens.mul(1000).mul(usersBalancePercentage)).div(1000000000);\n\n\n        return numberTokensPlusRewardsForUser;\n\n    }\n\n  //SWC-135-Code With No Effects: 205-253\n  function withdraw(address tokenAddress, uint256 amount, address payable onBehalfOf) onlyOwner payable public returns(bool){\n\n      ERC20 thisToken = ERC20(tokenAddress);\n      //uint256 numberTokensPreWithdrawal = getStakedBalance(address(this), tokenAddress);\n\n        if(tokenAddress == 0x0000000000000000000000000000000000000000){\n            require(depositBalances[msg.sender][tokenAddress] >= amount, \"You didnt deposit enough eth\");\n\n            totalAmountStaked[tokenAddress] = totalAmountStaked[tokenAddress].sub(depositBalances[onBehalfOf][tokenAddress]);\n            depositBalances[onBehalfOf][tokenAddress] = depositBalances[onBehalfOf][tokenAddress]  - amount;\n            onBehalfOf.send(amount);\n            return true;\n\n        }\n\n        require(depositBalances[onBehalfOf][tokenAddress] > 0, \"You dont have any tokens deposited\");\n\n        //uint256 numberTokensPostWithdrawal = thisToken.balanceOf(address(this));\n\n        //uint256 usersBalancePercentage = depositBalances[onBehalfOf][tokenAddress].div(totalAmountStaked[tokenAddress]);\n\n        uint256 numberTokensPlusRewardsForUser1 = getStakedPoolBalanceByUser(onBehalfOf, tokenAddress);\n        uint256 commissionForDAO1 = calculateCommission(numberTokensPlusRewardsForUser1);\n        uint256 numberTokensPlusRewardsForUserMinusCommission = numberTokensPlusRewardsForUser1-commissionForDAO1;\n\n        unstake(amount, onBehalfOf, tokenAddress);\n\n        //staking platforms only withdraw all for the most part, and for security sticking to this\n        totalAmountStaked[tokenAddress] = totalAmountStaked[tokenAddress].sub(depositBalances[onBehalfOf][tokenAddress]);\n\n        depositBalances[onBehalfOf][tokenAddress] = 0;\n        require(numberTokensPlusRewardsForUserMinusCommission >0, \"For some reason numberTokensPlusRewardsForUserMinusCommission is zero\");\n\n        require(thisToken.transfer(onBehalfOf, numberTokensPlusRewardsForUserMinusCommission), \"You dont have enough tokens inside this contract to withdraw from deposits\");\n        if(numberTokensPlusRewardsForUserMinusCommission >0){\n            thisToken.transfer(owner, commissionForDAO1);\n        }\n\n\n        uint256 remainingBalance = thisToken.balanceOf(address(this));\n        if(remainingBalance>0){\n            stake(remainingBalance, address(this), tokenAddress);\n        }\n\n\n        emit Withdrawal(onBehalfOf, amount, tokenAddress);\n        return true;\n\n   }\n\n\n   function calculateCommission(uint256 amount) view public returns(uint256){\n     uint256 commissionForDAO = (amount.mul(1000).mul(commission)).div(10000000);\n     return commissionForDAO;\n   }\n\n   function changeOwner(address payable newAdmin) onlyOwner public returns (bool){\n     owner = newAdmin;\n     return true;\n   }\n\n   function changeAdmin(address payable newOwner) onlyAdmin public returns (bool){\n     admin = newOwner;\n     return true;\n   }\n\n\n\n   function getStakedBalance(address _owner, address tokenAddress) public view returns(uint256){\n\n       ERC20 staker  = ERC20(tokenToAToken[tokenAddress]);\n       return staker.balanceOf(_owner);\n   }\n\n\n\n  function adminEmergencyWithdrawTokens(address token, uint amount, address payable destination) public onlyOwner returns(bool) {\n\n\n\n      if (address(token) == ETH_TOKEN_ADDRESS) {\n          destination.transfer(amount);\n      }\n      else {\n          ERC20 tokenToken = ERC20(token);\n          require(tokenToken.transfer(destination, amount));\n      }\n\n\n\n\n      return true;\n  }\n\n\n\n function kill() virtual public onlyOwner {\n\n         selfdestruct(owner);\n\n }\n\n\n    event Deposit(address indexed user, uint256 amount, address token);\n    event Withdrawal(address indexed user, uint256 amount, address token);\n\n\n\n\n}",
        "function": "deposit(address,uint256,address)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/PeckShield-Plexus/PlexusContracts-f7e8196a3881faee80369330f6844a7f38d65b65/contracts/tier2Aave.sol",
        "vulnerability": "State access after external call (SWC 107)",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract Tier2FarmController {\n\n  using SafeMath\n    for uint256;\n\n\n  address payable public owner;\n  address payable public admin;\n  address public platformToken = 0x25550Cccbd68533Fa04bFD3e3AC4D09f9e00Fc50;\n  address public tokenStakingContract = 0x7d2768dE32b0b80b7a3454c06BdAc94A69DDc7A9;\n  address ETH_TOKEN_ADDRESS  = address(0x0);\n  mapping (string => address) public stakingContracts;\n  mapping (address => address) public tokenToFarmMapping;\n  mapping (string => address) public stakingContractsStakingToken;\n  mapping (address => mapping (address => uint256)) public depositBalances;\n  mapping (address => address) public tokenToAToken;\n    mapping (address => address) public aTokenToToken;\n  uint256 public commission  = 400; // Default is 4 percent\n\n\n  string public farmName = 'Aave';\n  mapping (address => uint256) public totalAmountStaked;\n\n   modifier onlyOwner {\n         require(\n             msg.sender == owner,\n             \"Only owner can call this function.\"\n         );\n         _;\n }\n\n  modifier onlyAdmin {\n         require(\n             msg.sender == admin,\n             \"Only admin can call this function.\"\n         );\n         _;\n }\n\n\n\n\n\n\n\n  constructor() public payable {\n        stakingContracts[\"DAI\"] =0x7d2768dE32b0b80b7a3454c06BdAc94A69DDc7A9 ;\n        stakingContracts[\"ALL\"] =0x7d2768dE32b0b80b7a3454c06BdAc94A69DDc7A9 ;\n        stakingContractsStakingToken [\"DAI\"] = 0x25550Cccbd68533Fa04bFD3e3AC4D09f9e00Fc50;\n        tokenToAToken[0x6B175474E89094C44Da98b954EedeAC495271d0F]= 0x25550Cccbd68533Fa04bFD3e3AC4D09f9e00Fc50;\n        aTokenToToken[0x25550Cccbd68533Fa04bFD3e3AC4D09f9e00Fc50]= 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n        tokenToFarmMapping[stakingContractsStakingToken [\"DAI\"]] =  stakingContracts[\"DAI\"];\n        owner= msg.sender;\n        admin = msg.sender;\n\n  }\n\n\n  fallback() external payable {\n\n\n  }\n\n\nfunction updateATokens(address tokenAddress, address aTokenAddress) public onlyAdmin returns (bool){\n    tokenToAToken[tokenAddress] = aTokenAddress;\n    aTokenToToken[aTokenAddress] = tokenAddress;\n    return true;\n}\n\n  function addOrEditStakingContract(string memory name, address stakingAddress, address stakingToken ) public onlyOwner returns (bool){\n\n    stakingContracts[name] = stakingAddress;\n    stakingContractsStakingToken[name] = stakingToken;\n    tokenToFarmMapping[stakingToken] = stakingAddress;\n\n    return true;\n\n  }\n\n  function updateCommission(uint amount) public onlyOwner returns(bool){\n      commission = amount;\n      return true;\n  }\n\n  function deposit(address tokenAddress, uint256 amount, address onBehalfOf) payable onlyOwner public returns (bool){\n\n\n\n\n        ERC20 thisToken = ERC20(tokenAddress);\n        require(thisToken.transferFrom(msg.sender, address(this), amount), \"Not enough tokens to transferFrom or no approval\");\n\n        depositBalances[onBehalfOf][tokenAddress] = depositBalances[onBehalfOf][tokenAddress].add(amount);\n\n        uint256 approvedAmount = thisToken.allowance(address(this), tokenToFarmMapping[tokenAddress]);\n        if(approvedAmount < amount  ){\n            thisToken.approve(tokenToFarmMapping[tokenAddress], amount.mul(10000000));\n        }\n        stake(amount, onBehalfOf, tokenAddress );\n\n        totalAmountStaked[tokenAddress] = totalAmountStaked[tokenAddress].add(amount);\n\n        emit Deposit(onBehalfOf, amount, tokenAddress);\n        return true;\n   }\n\n   function stake(uint256 amount, address onBehalfOf, address tokenAddress) internal returns(bool){\n\n      StakingInterface staker  = StakingInterface(tokenToFarmMapping[tokenAddress]);\n      staker.deposit(tokenAddress, amount, address(this), 0);\n      return true;\n\n   }\n\n   function unstake(uint256 amount, address onBehalfOf, address tokenAddress) internal returns(bool){\n      ERC20 aToken  = ERC20(tokenToAToken[tokenAddress]);\n      StakingInterface staker  =  StakingInterface(tokenToFarmMapping[tokenAddress]);\n      staker.withdraw(tokenAddress, aToken.balanceOf(address(this)), address(this));\n      return true;\n\n   }\n\n\n   function getStakedPoolBalanceByUser(address _owner, address tokenAddress) public view returns(uint256){\n        StakingInterface staker  = StakingInterface(tokenToFarmMapping[tokenAddress]);\n        ERC20 aToken  = ERC20(tokenToAToken[tokenAddress]);\n        uint256 numberTokens = aToken.balanceOf(address(this));\n\n        uint256 usersBalancePercentage = (depositBalances[_owner][tokenAddress].mul(1000000)).div(totalAmountStaked[tokenAddress]);\n        uint256 numberTokensPlusRewardsForUser= (numberTokens.mul(1000).mul(usersBalancePercentage)).div(1000000000);\n\n\n        return numberTokensPlusRewardsForUser;\n\n    }\n\n  //SWC-135-Code With No Effects: 205-253\n  function withdraw(address tokenAddress, uint256 amount, address payable onBehalfOf) onlyOwner payable public returns(bool){\n\n      ERC20 thisToken = ERC20(tokenAddress);\n      //uint256 numberTokensPreWithdrawal = getStakedBalance(address(this), tokenAddress);\n\n        if(tokenAddress == 0x0000000000000000000000000000000000000000){\n            require(depositBalances[msg.sender][tokenAddress] >= amount, \"You didnt deposit enough eth\");\n\n            totalAmountStaked[tokenAddress] = totalAmountStaked[tokenAddress].sub(depositBalances[onBehalfOf][tokenAddress]);\n            depositBalances[onBehalfOf][tokenAddress] = depositBalances[onBehalfOf][tokenAddress]  - amount;\n            onBehalfOf.send(amount);\n            return true;\n\n        }\n\n        require(depositBalances[onBehalfOf][tokenAddress] > 0, \"You dont have any tokens deposited\");\n\n        //uint256 numberTokensPostWithdrawal = thisToken.balanceOf(address(this));\n\n        //uint256 usersBalancePercentage = depositBalances[onBehalfOf][tokenAddress].div(totalAmountStaked[tokenAddress]);\n\n        uint256 numberTokensPlusRewardsForUser1 = getStakedPoolBalanceByUser(onBehalfOf, tokenAddress);\n        uint256 commissionForDAO1 = calculateCommission(numberTokensPlusRewardsForUser1);\n        uint256 numberTokensPlusRewardsForUserMinusCommission = numberTokensPlusRewardsForUser1-commissionForDAO1;\n\n        unstake(amount, onBehalfOf, tokenAddress);\n\n        //staking platforms only withdraw all for the most part, and for security sticking to this\n        totalAmountStaked[tokenAddress] = totalAmountStaked[tokenAddress].sub(depositBalances[onBehalfOf][tokenAddress]);\n\n        depositBalances[onBehalfOf][tokenAddress] = 0;\n        require(numberTokensPlusRewardsForUserMinusCommission >0, \"For some reason numberTokensPlusRewardsForUserMinusCommission is zero\");\n\n        require(thisToken.transfer(onBehalfOf, numberTokensPlusRewardsForUserMinusCommission), \"You dont have enough tokens inside this contract to withdraw from deposits\");\n        if(numberTokensPlusRewardsForUserMinusCommission >0){\n            thisToken.transfer(owner, commissionForDAO1);\n        }\n\n\n        uint256 remainingBalance = thisToken.balanceOf(address(this));\n        if(remainingBalance>0){\n            stake(remainingBalance, address(this), tokenAddress);\n        }\n\n\n        emit Withdrawal(onBehalfOf, amount, tokenAddress);\n        return true;\n\n   }\n\n\n   function calculateCommission(uint256 amount) view public returns(uint256){\n     uint256 commissionForDAO = (amount.mul(1000).mul(commission)).div(10000000);\n     return commissionForDAO;\n   }\n\n   function changeOwner(address payable newAdmin) onlyOwner public returns (bool){\n     owner = newAdmin;\n     return true;\n   }\n\n   function changeAdmin(address payable newOwner) onlyAdmin public returns (bool){\n     admin = newOwner;\n     return true;\n   }\n\n\n\n   function getStakedBalance(address _owner, address tokenAddress) public view returns(uint256){\n\n       ERC20 staker  = ERC20(tokenToAToken[tokenAddress]);\n       return staker.balanceOf(_owner);\n   }\n\n\n\n  function adminEmergencyWithdrawTokens(address token, uint amount, address payable destination) public onlyOwner returns(bool) {\n\n\n\n      if (address(token) == ETH_TOKEN_ADDRESS) {\n          destination.transfer(amount);\n      }\n      else {\n          ERC20 tokenToken = ERC20(token);\n          require(tokenToken.transfer(destination, amount));\n      }\n\n\n\n\n      return true;\n  }\n\n\n\n function kill() virtual public onlyOwner {\n\n         selfdestruct(owner);\n\n }\n\n\n    event Deposit(address indexed user, uint256 amount, address token);\n    event Withdrawal(address indexed user, uint256 amount, address token);\n\n\n\n\n}",
        "function": "deposit(address,uint256,address)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/PeckShield-Plexus/PlexusContracts-f7e8196a3881faee80369330f6844a7f38d65b65/contracts/tier2Aave.sol",
        "vulnerability": "State access after external call (SWC 107)",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract Tier2FarmController {\n\n  using SafeMath\n    for uint256;\n\n\n  address payable public owner;\n  address payable public admin;\n  address public platformToken = 0x25550Cccbd68533Fa04bFD3e3AC4D09f9e00Fc50;\n  address public tokenStakingContract = 0x7d2768dE32b0b80b7a3454c06BdAc94A69DDc7A9;\n  address ETH_TOKEN_ADDRESS  = address(0x0);\n  mapping (string => address) public stakingContracts;\n  mapping (address => address) public tokenToFarmMapping;\n  mapping (string => address) public stakingContractsStakingToken;\n  mapping (address => mapping (address => uint256)) public depositBalances;\n  mapping (address => address) public tokenToAToken;\n    mapping (address => address) public aTokenToToken;\n  uint256 public commission  = 400; // Default is 4 percent\n\n\n  string public farmName = 'Aave';\n  mapping (address => uint256) public totalAmountStaked;\n\n   modifier onlyOwner {\n         require(\n             msg.sender == owner,\n             \"Only owner can call this function.\"\n         );\n         _;\n }\n\n  modifier onlyAdmin {\n         require(\n             msg.sender == admin,\n             \"Only admin can call this function.\"\n         );\n         _;\n }\n\n\n\n\n\n\n\n  constructor() public payable {\n        stakingContracts[\"DAI\"] =0x7d2768dE32b0b80b7a3454c06BdAc94A69DDc7A9 ;\n        stakingContracts[\"ALL\"] =0x7d2768dE32b0b80b7a3454c06BdAc94A69DDc7A9 ;\n        stakingContractsStakingToken [\"DAI\"] = 0x25550Cccbd68533Fa04bFD3e3AC4D09f9e00Fc50;\n        tokenToAToken[0x6B175474E89094C44Da98b954EedeAC495271d0F]= 0x25550Cccbd68533Fa04bFD3e3AC4D09f9e00Fc50;\n        aTokenToToken[0x25550Cccbd68533Fa04bFD3e3AC4D09f9e00Fc50]= 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n        tokenToFarmMapping[stakingContractsStakingToken [\"DAI\"]] =  stakingContracts[\"DAI\"];\n        owner= msg.sender;\n        admin = msg.sender;\n\n  }\n\n\n  fallback() external payable {\n\n\n  }\n\n\nfunction updateATokens(address tokenAddress, address aTokenAddress) public onlyAdmin returns (bool){\n    tokenToAToken[tokenAddress] = aTokenAddress;\n    aTokenToToken[aTokenAddress] = tokenAddress;\n    return true;\n}\n\n  function addOrEditStakingContract(string memory name, address stakingAddress, address stakingToken ) public onlyOwner returns (bool){\n\n    stakingContracts[name] = stakingAddress;\n    stakingContractsStakingToken[name] = stakingToken;\n    tokenToFarmMapping[stakingToken] = stakingAddress;\n\n    return true;\n\n  }\n\n  function updateCommission(uint amount) public onlyOwner returns(bool){\n      commission = amount;\n      return true;\n  }\n\n  function deposit(address tokenAddress, uint256 amount, address onBehalfOf) payable onlyOwner public returns (bool){\n\n\n\n\n        ERC20 thisToken = ERC20(tokenAddress);\n        require(thisToken.transferFrom(msg.sender, address(this), amount), \"Not enough tokens to transferFrom or no approval\");\n\n        depositBalances[onBehalfOf][tokenAddress] = depositBalances[onBehalfOf][tokenAddress].add(amount);\n\n        uint256 approvedAmount = thisToken.allowance(address(this), tokenToFarmMapping[tokenAddress]);\n        if(approvedAmount < amount  ){\n            thisToken.approve(tokenToFarmMapping[tokenAddress], amount.mul(10000000));\n        }\n        stake(amount, onBehalfOf, tokenAddress );\n\n        totalAmountStaked[tokenAddress] = totalAmountStaked[tokenAddress].add(amount);\n\n        emit Deposit(onBehalfOf, amount, tokenAddress);\n        return true;\n   }\n\n   function stake(uint256 amount, address onBehalfOf, address tokenAddress) internal returns(bool){\n\n      StakingInterface staker  = StakingInterface(tokenToFarmMapping[tokenAddress]);\n      staker.deposit(tokenAddress, amount, address(this), 0);\n      return true;\n\n   }\n\n   function unstake(uint256 amount, address onBehalfOf, address tokenAddress) internal returns(bool){\n      ERC20 aToken  = ERC20(tokenToAToken[tokenAddress]);\n      StakingInterface staker  =  StakingInterface(tokenToFarmMapping[tokenAddress]);\n      staker.withdraw(tokenAddress, aToken.balanceOf(address(this)), address(this));\n      return true;\n\n   }\n\n\n   function getStakedPoolBalanceByUser(address _owner, address tokenAddress) public view returns(uint256){\n        StakingInterface staker  = StakingInterface(tokenToFarmMapping[tokenAddress]);\n        ERC20 aToken  = ERC20(tokenToAToken[tokenAddress]);\n        uint256 numberTokens = aToken.balanceOf(address(this));\n\n        uint256 usersBalancePercentage = (depositBalances[_owner][tokenAddress].mul(1000000)).div(totalAmountStaked[tokenAddress]);\n        uint256 numberTokensPlusRewardsForUser= (numberTokens.mul(1000).mul(usersBalancePercentage)).div(1000000000);\n\n\n        return numberTokensPlusRewardsForUser;\n\n    }\n\n  //SWC-135-Code With No Effects: 205-253\n  function withdraw(address tokenAddress, uint256 amount, address payable onBehalfOf) onlyOwner payable public returns(bool){\n\n      ERC20 thisToken = ERC20(tokenAddress);\n      //uint256 numberTokensPreWithdrawal = getStakedBalance(address(this), tokenAddress);\n\n        if(tokenAddress == 0x0000000000000000000000000000000000000000){\n            require(depositBalances[msg.sender][tokenAddress] >= amount, \"You didnt deposit enough eth\");\n\n            totalAmountStaked[tokenAddress] = totalAmountStaked[tokenAddress].sub(depositBalances[onBehalfOf][tokenAddress]);\n            depositBalances[onBehalfOf][tokenAddress] = depositBalances[onBehalfOf][tokenAddress]  - amount;\n            onBehalfOf.send(amount);\n            return true;\n\n        }\n\n        require(depositBalances[onBehalfOf][tokenAddress] > 0, \"You dont have any tokens deposited\");\n\n        //uint256 numberTokensPostWithdrawal = thisToken.balanceOf(address(this));\n\n        //uint256 usersBalancePercentage = depositBalances[onBehalfOf][tokenAddress].div(totalAmountStaked[tokenAddress]);\n\n        uint256 numberTokensPlusRewardsForUser1 = getStakedPoolBalanceByUser(onBehalfOf, tokenAddress);\n        uint256 commissionForDAO1 = calculateCommission(numberTokensPlusRewardsForUser1);\n        uint256 numberTokensPlusRewardsForUserMinusCommission = numberTokensPlusRewardsForUser1-commissionForDAO1;\n\n        unstake(amount, onBehalfOf, tokenAddress);\n\n        //staking platforms only withdraw all for the most part, and for security sticking to this\n        totalAmountStaked[tokenAddress] = totalAmountStaked[tokenAddress].sub(depositBalances[onBehalfOf][tokenAddress]);\n\n        depositBalances[onBehalfOf][tokenAddress] = 0;\n        require(numberTokensPlusRewardsForUserMinusCommission >0, \"For some reason numberTokensPlusRewardsForUserMinusCommission is zero\");\n\n        require(thisToken.transfer(onBehalfOf, numberTokensPlusRewardsForUserMinusCommission), \"You dont have enough tokens inside this contract to withdraw from deposits\");\n        if(numberTokensPlusRewardsForUserMinusCommission >0){\n            thisToken.transfer(owner, commissionForDAO1);\n        }\n\n\n        uint256 remainingBalance = thisToken.balanceOf(address(this));\n        if(remainingBalance>0){\n            stake(remainingBalance, address(this), tokenAddress);\n        }\n\n\n        emit Withdrawal(onBehalfOf, amount, tokenAddress);\n        return true;\n\n   }\n\n\n   function calculateCommission(uint256 amount) view public returns(uint256){\n     uint256 commissionForDAO = (amount.mul(1000).mul(commission)).div(10000000);\n     return commissionForDAO;\n   }\n\n   function changeOwner(address payable newAdmin) onlyOwner public returns (bool){\n     owner = newAdmin;\n     return true;\n   }\n\n   function changeAdmin(address payable newOwner) onlyAdmin public returns (bool){\n     admin = newOwner;\n     return true;\n   }\n\n\n\n   function getStakedBalance(address _owner, address tokenAddress) public view returns(uint256){\n\n       ERC20 staker  = ERC20(tokenToAToken[tokenAddress]);\n       return staker.balanceOf(_owner);\n   }\n\n\n\n  function adminEmergencyWithdrawTokens(address token, uint amount, address payable destination) public onlyOwner returns(bool) {\n\n\n\n      if (address(token) == ETH_TOKEN_ADDRESS) {\n          destination.transfer(amount);\n      }\n      else {\n          ERC20 tokenToken = ERC20(token);\n          require(tokenToken.transfer(destination, amount));\n      }\n\n\n\n\n      return true;\n  }\n\n\n\n function kill() virtual public onlyOwner {\n\n         selfdestruct(owner);\n\n }\n\n\n    event Deposit(address indexed user, uint256 amount, address token);\n    event Withdrawal(address indexed user, uint256 amount, address token);\n\n\n\n\n}",
        "function": "deposit(address,uint256,address)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/PeckShield-Plexus/PlexusContracts-f7e8196a3881faee80369330f6844a7f38d65b65/contracts/tier2Aave.sol",
        "vulnerability": "State access after external call (SWC 107)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract Tier2FarmController {\n\n  using SafeMath\n    for uint256;\n\n\n  address payable public owner;\n  address payable public admin;\n  address public platformToken = 0x25550Cccbd68533Fa04bFD3e3AC4D09f9e00Fc50;\n  address public tokenStakingContract = 0x7d2768dE32b0b80b7a3454c06BdAc94A69DDc7A9;\n  address ETH_TOKEN_ADDRESS  = address(0x0);\n  mapping (string => address) public stakingContracts;\n  mapping (address => address) public tokenToFarmMapping;\n  mapping (string => address) public stakingContractsStakingToken;\n  mapping (address => mapping (address => uint256)) public depositBalances;\n  mapping (address => address) public tokenToAToken;\n    mapping (address => address) public aTokenToToken;\n  uint256 public commission  = 400; // Default is 4 percent\n\n\n  string public farmName = 'Aave';\n  mapping (address => uint256) public totalAmountStaked;\n\n   modifier onlyOwner {\n         require(\n             msg.sender == owner,\n             \"Only owner can call this function.\"\n         );\n         _;\n }\n\n  modifier onlyAdmin {\n         require(\n             msg.sender == admin,\n             \"Only admin can call this function.\"\n         );\n         _;\n }\n\n\n\n\n\n\n\n  constructor() public payable {\n        stakingContracts[\"DAI\"] =0x7d2768dE32b0b80b7a3454c06BdAc94A69DDc7A9 ;\n        stakingContracts[\"ALL\"] =0x7d2768dE32b0b80b7a3454c06BdAc94A69DDc7A9 ;\n        stakingContractsStakingToken [\"DAI\"] = 0x25550Cccbd68533Fa04bFD3e3AC4D09f9e00Fc50;\n        tokenToAToken[0x6B175474E89094C44Da98b954EedeAC495271d0F]= 0x25550Cccbd68533Fa04bFD3e3AC4D09f9e00Fc50;\n        aTokenToToken[0x25550Cccbd68533Fa04bFD3e3AC4D09f9e00Fc50]= 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n        tokenToFarmMapping[stakingContractsStakingToken [\"DAI\"]] =  stakingContracts[\"DAI\"];\n        owner= msg.sender;\n        admin = msg.sender;\n\n  }\n\n\n  fallback() external payable {\n\n\n  }\n\n\nfunction updateATokens(address tokenAddress, address aTokenAddress) public onlyAdmin returns (bool){\n    tokenToAToken[tokenAddress] = aTokenAddress;\n    aTokenToToken[aTokenAddress] = tokenAddress;\n    return true;\n}\n\n  function addOrEditStakingContract(string memory name, address stakingAddress, address stakingToken ) public onlyOwner returns (bool){\n\n    stakingContracts[name] = stakingAddress;\n    stakingContractsStakingToken[name] = stakingToken;\n    tokenToFarmMapping[stakingToken] = stakingAddress;\n\n    return true;\n\n  }\n\n  function updateCommission(uint amount) public onlyOwner returns(bool){\n      commission = amount;\n      return true;\n  }\n\n  function deposit(address tokenAddress, uint256 amount, address onBehalfOf) payable onlyOwner public returns (bool){\n\n\n\n\n        ERC20 thisToken = ERC20(tokenAddress);\n        require(thisToken.transferFrom(msg.sender, address(this), amount), \"Not enough tokens to transferFrom or no approval\");\n\n        depositBalances[onBehalfOf][tokenAddress] = depositBalances[onBehalfOf][tokenAddress].add(amount);\n\n        uint256 approvedAmount = thisToken.allowance(address(this), tokenToFarmMapping[tokenAddress]);\n        if(approvedAmount < amount  ){\n            thisToken.approve(tokenToFarmMapping[tokenAddress], amount.mul(10000000));\n        }\n        stake(amount, onBehalfOf, tokenAddress );\n\n        totalAmountStaked[tokenAddress] = totalAmountStaked[tokenAddress].add(amount);\n\n        emit Deposit(onBehalfOf, amount, tokenAddress);\n        return true;\n   }\n\n   function stake(uint256 amount, address onBehalfOf, address tokenAddress) internal returns(bool){\n\n      StakingInterface staker  = StakingInterface(tokenToFarmMapping[tokenAddress]);\n      staker.deposit(tokenAddress, amount, address(this), 0);\n      return true;\n\n   }\n\n   function unstake(uint256 amount, address onBehalfOf, address tokenAddress) internal returns(bool){\n      ERC20 aToken  = ERC20(tokenToAToken[tokenAddress]);\n      StakingInterface staker  =  StakingInterface(tokenToFarmMapping[tokenAddress]);\n      staker.withdraw(tokenAddress, aToken.balanceOf(address(this)), address(this));\n      return true;\n\n   }\n\n\n   function getStakedPoolBalanceByUser(address _owner, address tokenAddress) public view returns(uint256){\n        StakingInterface staker  = StakingInterface(tokenToFarmMapping[tokenAddress]);\n        ERC20 aToken  = ERC20(tokenToAToken[tokenAddress]);\n        uint256 numberTokens = aToken.balanceOf(address(this));\n\n        uint256 usersBalancePercentage = (depositBalances[_owner][tokenAddress].mul(1000000)).div(totalAmountStaked[tokenAddress]);\n        uint256 numberTokensPlusRewardsForUser= (numberTokens.mul(1000).mul(usersBalancePercentage)).div(1000000000);\n\n\n        return numberTokensPlusRewardsForUser;\n\n    }\n\n  //SWC-135-Code With No Effects: 205-253\n  function withdraw(address tokenAddress, uint256 amount, address payable onBehalfOf) onlyOwner payable public returns(bool){\n\n      ERC20 thisToken = ERC20(tokenAddress);\n      //uint256 numberTokensPreWithdrawal = getStakedBalance(address(this), tokenAddress);\n\n        if(tokenAddress == 0x0000000000000000000000000000000000000000){\n            require(depositBalances[msg.sender][tokenAddress] >= amount, \"You didnt deposit enough eth\");\n\n            totalAmountStaked[tokenAddress] = totalAmountStaked[tokenAddress].sub(depositBalances[onBehalfOf][tokenAddress]);\n            depositBalances[onBehalfOf][tokenAddress] = depositBalances[onBehalfOf][tokenAddress]  - amount;\n            onBehalfOf.send(amount);\n            return true;\n\n        }\n\n        require(depositBalances[onBehalfOf][tokenAddress] > 0, \"You dont have any tokens deposited\");\n\n        //uint256 numberTokensPostWithdrawal = thisToken.balanceOf(address(this));\n\n        //uint256 usersBalancePercentage = depositBalances[onBehalfOf][tokenAddress].div(totalAmountStaked[tokenAddress]);\n\n        uint256 numberTokensPlusRewardsForUser1 = getStakedPoolBalanceByUser(onBehalfOf, tokenAddress);\n        uint256 commissionForDAO1 = calculateCommission(numberTokensPlusRewardsForUser1);\n        uint256 numberTokensPlusRewardsForUserMinusCommission = numberTokensPlusRewardsForUser1-commissionForDAO1;\n\n        unstake(amount, onBehalfOf, tokenAddress);\n\n        //staking platforms only withdraw all for the most part, and for security sticking to this\n        totalAmountStaked[tokenAddress] = totalAmountStaked[tokenAddress].sub(depositBalances[onBehalfOf][tokenAddress]);\n\n        depositBalances[onBehalfOf][tokenAddress] = 0;\n        require(numberTokensPlusRewardsForUserMinusCommission >0, \"For some reason numberTokensPlusRewardsForUserMinusCommission is zero\");\n\n        require(thisToken.transfer(onBehalfOf, numberTokensPlusRewardsForUserMinusCommission), \"You dont have enough tokens inside this contract to withdraw from deposits\");\n        if(numberTokensPlusRewardsForUserMinusCommission >0){\n            thisToken.transfer(owner, commissionForDAO1);\n        }\n\n\n        uint256 remainingBalance = thisToken.balanceOf(address(this));\n        if(remainingBalance>0){\n            stake(remainingBalance, address(this), tokenAddress);\n        }\n\n\n        emit Withdrawal(onBehalfOf, amount, tokenAddress);\n        return true;\n\n   }\n\n\n   function calculateCommission(uint256 amount) view public returns(uint256){\n     uint256 commissionForDAO = (amount.mul(1000).mul(commission)).div(10000000);\n     return commissionForDAO;\n   }\n\n   function changeOwner(address payable newAdmin) onlyOwner public returns (bool){\n     owner = newAdmin;\n     return true;\n   }\n\n   function changeAdmin(address payable newOwner) onlyAdmin public returns (bool){\n     admin = newOwner;\n     return true;\n   }\n\n\n\n   function getStakedBalance(address _owner, address tokenAddress) public view returns(uint256){\n\n       ERC20 staker  = ERC20(tokenToAToken[tokenAddress]);\n       return staker.balanceOf(_owner);\n   }\n\n\n\n  function adminEmergencyWithdrawTokens(address token, uint amount, address payable destination) public onlyOwner returns(bool) {\n\n\n\n      if (address(token) == ETH_TOKEN_ADDRESS) {\n          destination.transfer(amount);\n      }\n      else {\n          ERC20 tokenToken = ERC20(token);\n          require(tokenToken.transfer(destination, amount));\n      }\n\n\n\n\n      return true;\n  }\n\n\n\n function kill() virtual public onlyOwner {\n\n         selfdestruct(owner);\n\n }\n\n\n    event Deposit(address indexed user, uint256 amount, address token);\n    event Withdrawal(address indexed user, uint256 amount, address token);\n\n\n\n\n}",
        "function": "deposit(address,uint256,address)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/PeckShield-Plexus/PlexusContracts-f7e8196a3881faee80369330f6844a7f38d65b65/contracts/tier2Aave.sol",
        "vulnerability": "State access after external call (SWC 107)",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract Tier2FarmController {\n\n  using SafeMath\n    for uint256;\n\n\n  address payable public owner;\n  address payable public admin;\n  address public platformToken = 0x25550Cccbd68533Fa04bFD3e3AC4D09f9e00Fc50;\n  address public tokenStakingContract = 0x7d2768dE32b0b80b7a3454c06BdAc94A69DDc7A9;\n  address ETH_TOKEN_ADDRESS  = address(0x0);\n  mapping (string => address) public stakingContracts;\n  mapping (address => address) public tokenToFarmMapping;\n  mapping (string => address) public stakingContractsStakingToken;\n  mapping (address => mapping (address => uint256)) public depositBalances;\n  mapping (address => address) public tokenToAToken;\n    mapping (address => address) public aTokenToToken;\n  uint256 public commission  = 400; // Default is 4 percent\n\n\n  string public farmName = 'Aave';\n  mapping (address => uint256) public totalAmountStaked;\n\n   modifier onlyOwner {\n         require(\n             msg.sender == owner,\n             \"Only owner can call this function.\"\n         );\n         _;\n }\n\n  modifier onlyAdmin {\n         require(\n             msg.sender == admin,\n             \"Only admin can call this function.\"\n         );\n         _;\n }\n\n\n\n\n\n\n\n  constructor() public payable {\n        stakingContracts[\"DAI\"] =0x7d2768dE32b0b80b7a3454c06BdAc94A69DDc7A9 ;\n        stakingContracts[\"ALL\"] =0x7d2768dE32b0b80b7a3454c06BdAc94A69DDc7A9 ;\n        stakingContractsStakingToken [\"DAI\"] = 0x25550Cccbd68533Fa04bFD3e3AC4D09f9e00Fc50;\n        tokenToAToken[0x6B175474E89094C44Da98b954EedeAC495271d0F]= 0x25550Cccbd68533Fa04bFD3e3AC4D09f9e00Fc50;\n        aTokenToToken[0x25550Cccbd68533Fa04bFD3e3AC4D09f9e00Fc50]= 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n        tokenToFarmMapping[stakingContractsStakingToken [\"DAI\"]] =  stakingContracts[\"DAI\"];\n        owner= msg.sender;\n        admin = msg.sender;\n\n  }\n\n\n  fallback() external payable {\n\n\n  }\n\n\nfunction updateATokens(address tokenAddress, address aTokenAddress) public onlyAdmin returns (bool){\n    tokenToAToken[tokenAddress] = aTokenAddress;\n    aTokenToToken[aTokenAddress] = tokenAddress;\n    return true;\n}\n\n  function addOrEditStakingContract(string memory name, address stakingAddress, address stakingToken ) public onlyOwner returns (bool){\n\n    stakingContracts[name] = stakingAddress;\n    stakingContractsStakingToken[name] = stakingToken;\n    tokenToFarmMapping[stakingToken] = stakingAddress;\n\n    return true;\n\n  }\n\n  function updateCommission(uint amount) public onlyOwner returns(bool){\n      commission = amount;\n      return true;\n  }\n\n  function deposit(address tokenAddress, uint256 amount, address onBehalfOf) payable onlyOwner public returns (bool){\n\n\n\n\n        ERC20 thisToken = ERC20(tokenAddress);\n        require(thisToken.transferFrom(msg.sender, address(this), amount), \"Not enough tokens to transferFrom or no approval\");\n\n        depositBalances[onBehalfOf][tokenAddress] = depositBalances[onBehalfOf][tokenAddress].add(amount);\n\n        uint256 approvedAmount = thisToken.allowance(address(this), tokenToFarmMapping[tokenAddress]);\n        if(approvedAmount < amount  ){\n            thisToken.approve(tokenToFarmMapping[tokenAddress], amount.mul(10000000));\n        }\n        stake(amount, onBehalfOf, tokenAddress );\n\n        totalAmountStaked[tokenAddress] = totalAmountStaked[tokenAddress].add(amount);\n\n        emit Deposit(onBehalfOf, amount, tokenAddress);\n        return true;\n   }\n\n   function stake(uint256 amount, address onBehalfOf, address tokenAddress) internal returns(bool){\n\n      StakingInterface staker  = StakingInterface(tokenToFarmMapping[tokenAddress]);\n      staker.deposit(tokenAddress, amount, address(this), 0);\n      return true;\n\n   }\n\n   function unstake(uint256 amount, address onBehalfOf, address tokenAddress) internal returns(bool){\n      ERC20 aToken  = ERC20(tokenToAToken[tokenAddress]);\n      StakingInterface staker  =  StakingInterface(tokenToFarmMapping[tokenAddress]);\n      staker.withdraw(tokenAddress, aToken.balanceOf(address(this)), address(this));\n      return true;\n\n   }\n\n\n   function getStakedPoolBalanceByUser(address _owner, address tokenAddress) public view returns(uint256){\n        StakingInterface staker  = StakingInterface(tokenToFarmMapping[tokenAddress]);\n        ERC20 aToken  = ERC20(tokenToAToken[tokenAddress]);\n        uint256 numberTokens = aToken.balanceOf(address(this));\n\n        uint256 usersBalancePercentage = (depositBalances[_owner][tokenAddress].mul(1000000)).div(totalAmountStaked[tokenAddress]);\n        uint256 numberTokensPlusRewardsForUser= (numberTokens.mul(1000).mul(usersBalancePercentage)).div(1000000000);\n\n\n        return numberTokensPlusRewardsForUser;\n\n    }\n\n  //SWC-135-Code With No Effects: 205-253\n  function withdraw(address tokenAddress, uint256 amount, address payable onBehalfOf) onlyOwner payable public returns(bool){\n\n      ERC20 thisToken = ERC20(tokenAddress);\n      //uint256 numberTokensPreWithdrawal = getStakedBalance(address(this), tokenAddress);\n\n        if(tokenAddress == 0x0000000000000000000000000000000000000000){\n            require(depositBalances[msg.sender][tokenAddress] >= amount, \"You didnt deposit enough eth\");\n\n            totalAmountStaked[tokenAddress] = totalAmountStaked[tokenAddress].sub(depositBalances[onBehalfOf][tokenAddress]);\n            depositBalances[onBehalfOf][tokenAddress] = depositBalances[onBehalfOf][tokenAddress]  - amount;\n            onBehalfOf.send(amount);\n            return true;\n\n        }\n\n        require(depositBalances[onBehalfOf][tokenAddress] > 0, \"You dont have any tokens deposited\");\n\n        //uint256 numberTokensPostWithdrawal = thisToken.balanceOf(address(this));\n\n        //uint256 usersBalancePercentage = depositBalances[onBehalfOf][tokenAddress].div(totalAmountStaked[tokenAddress]);\n\n        uint256 numberTokensPlusRewardsForUser1 = getStakedPoolBalanceByUser(onBehalfOf, tokenAddress);\n        uint256 commissionForDAO1 = calculateCommission(numberTokensPlusRewardsForUser1);\n        uint256 numberTokensPlusRewardsForUserMinusCommission = numberTokensPlusRewardsForUser1-commissionForDAO1;\n\n        unstake(amount, onBehalfOf, tokenAddress);\n\n        //staking platforms only withdraw all for the most part, and for security sticking to this\n        totalAmountStaked[tokenAddress] = totalAmountStaked[tokenAddress].sub(depositBalances[onBehalfOf][tokenAddress]);\n\n        depositBalances[onBehalfOf][tokenAddress] = 0;\n        require(numberTokensPlusRewardsForUserMinusCommission >0, \"For some reason numberTokensPlusRewardsForUserMinusCommission is zero\");\n\n        require(thisToken.transfer(onBehalfOf, numberTokensPlusRewardsForUserMinusCommission), \"You dont have enough tokens inside this contract to withdraw from deposits\");\n        if(numberTokensPlusRewardsForUserMinusCommission >0){\n            thisToken.transfer(owner, commissionForDAO1);\n        }\n\n\n        uint256 remainingBalance = thisToken.balanceOf(address(this));\n        if(remainingBalance>0){\n            stake(remainingBalance, address(this), tokenAddress);\n        }\n\n\n        emit Withdrawal(onBehalfOf, amount, tokenAddress);\n        return true;\n\n   }\n\n\n   function calculateCommission(uint256 amount) view public returns(uint256){\n     uint256 commissionForDAO = (amount.mul(1000).mul(commission)).div(10000000);\n     return commissionForDAO;\n   }\n\n   function changeOwner(address payable newAdmin) onlyOwner public returns (bool){\n     owner = newAdmin;\n     return true;\n   }\n\n   function changeAdmin(address payable newOwner) onlyAdmin public returns (bool){\n     admin = newOwner;\n     return true;\n   }\n\n\n\n   function getStakedBalance(address _owner, address tokenAddress) public view returns(uint256){\n\n       ERC20 staker  = ERC20(tokenToAToken[tokenAddress]);\n       return staker.balanceOf(_owner);\n   }\n\n\n\n  function adminEmergencyWithdrawTokens(address token, uint amount, address payable destination) public onlyOwner returns(bool) {\n\n\n\n      if (address(token) == ETH_TOKEN_ADDRESS) {\n          destination.transfer(amount);\n      }\n      else {\n          ERC20 tokenToken = ERC20(token);\n          require(tokenToken.transfer(destination, amount));\n      }\n\n\n\n\n      return true;\n  }\n\n\n\n function kill() virtual public onlyOwner {\n\n         selfdestruct(owner);\n\n }\n\n\n    event Deposit(address indexed user, uint256 amount, address token);\n    event Withdrawal(address indexed user, uint256 amount, address token);\n\n\n\n\n}",
        "function": "deposit(address,uint256,address)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/PeckShield-Plexus/PlexusContracts-f7e8196a3881faee80369330f6844a7f38d65b65/contracts/tier2Aave.sol",
        "vulnerability": "State access after external call (SWC 107)",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract Tier2FarmController {\n\n  using SafeMath\n    for uint256;\n\n\n  address payable public owner;\n  address payable public admin;\n  address public platformToken = 0x25550Cccbd68533Fa04bFD3e3AC4D09f9e00Fc50;\n  address public tokenStakingContract = 0x7d2768dE32b0b80b7a3454c06BdAc94A69DDc7A9;\n  address ETH_TOKEN_ADDRESS  = address(0x0);\n  mapping (string => address) public stakingContracts;\n  mapping (address => address) public tokenToFarmMapping;\n  mapping (string => address) public stakingContractsStakingToken;\n  mapping (address => mapping (address => uint256)) public depositBalances;\n  mapping (address => address) public tokenToAToken;\n    mapping (address => address) public aTokenToToken;\n  uint256 public commission  = 400; // Default is 4 percent\n\n\n  string public farmName = 'Aave';\n  mapping (address => uint256) public totalAmountStaked;\n\n   modifier onlyOwner {\n         require(\n             msg.sender == owner,\n             \"Only owner can call this function.\"\n         );\n         _;\n }\n\n  modifier onlyAdmin {\n         require(\n             msg.sender == admin,\n             \"Only admin can call this function.\"\n         );\n         _;\n }\n\n\n\n\n\n\n\n  constructor() public payable {\n        stakingContracts[\"DAI\"] =0x7d2768dE32b0b80b7a3454c06BdAc94A69DDc7A9 ;\n        stakingContracts[\"ALL\"] =0x7d2768dE32b0b80b7a3454c06BdAc94A69DDc7A9 ;\n        stakingContractsStakingToken [\"DAI\"] = 0x25550Cccbd68533Fa04bFD3e3AC4D09f9e00Fc50;\n        tokenToAToken[0x6B175474E89094C44Da98b954EedeAC495271d0F]= 0x25550Cccbd68533Fa04bFD3e3AC4D09f9e00Fc50;\n        aTokenToToken[0x25550Cccbd68533Fa04bFD3e3AC4D09f9e00Fc50]= 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n        tokenToFarmMapping[stakingContractsStakingToken [\"DAI\"]] =  stakingContracts[\"DAI\"];\n        owner= msg.sender;\n        admin = msg.sender;\n\n  }\n\n\n  fallback() external payable {\n\n\n  }\n\n\nfunction updateATokens(address tokenAddress, address aTokenAddress) public onlyAdmin returns (bool){\n    tokenToAToken[tokenAddress] = aTokenAddress;\n    aTokenToToken[aTokenAddress] = tokenAddress;\n    return true;\n}\n\n  function addOrEditStakingContract(string memory name, address stakingAddress, address stakingToken ) public onlyOwner returns (bool){\n\n    stakingContracts[name] = stakingAddress;\n    stakingContractsStakingToken[name] = stakingToken;\n    tokenToFarmMapping[stakingToken] = stakingAddress;\n\n    return true;\n\n  }\n\n  function updateCommission(uint amount) public onlyOwner returns(bool){\n      commission = amount;\n      return true;\n  }\n\n  function deposit(address tokenAddress, uint256 amount, address onBehalfOf) payable onlyOwner public returns (bool){\n\n\n\n\n        ERC20 thisToken = ERC20(tokenAddress);\n        require(thisToken.transferFrom(msg.sender, address(this), amount), \"Not enough tokens to transferFrom or no approval\");\n\n        depositBalances[onBehalfOf][tokenAddress] = depositBalances[onBehalfOf][tokenAddress].add(amount);\n\n        uint256 approvedAmount = thisToken.allowance(address(this), tokenToFarmMapping[tokenAddress]);\n        if(approvedAmount < amount  ){\n            thisToken.approve(tokenToFarmMapping[tokenAddress], amount.mul(10000000));\n        }\n        stake(amount, onBehalfOf, tokenAddress );\n\n        totalAmountStaked[tokenAddress] = totalAmountStaked[tokenAddress].add(amount);\n\n        emit Deposit(onBehalfOf, amount, tokenAddress);\n        return true;\n   }\n\n   function stake(uint256 amount, address onBehalfOf, address tokenAddress) internal returns(bool){\n\n      StakingInterface staker  = StakingInterface(tokenToFarmMapping[tokenAddress]);\n      staker.deposit(tokenAddress, amount, address(this), 0);\n      return true;\n\n   }\n\n   function unstake(uint256 amount, address onBehalfOf, address tokenAddress) internal returns(bool){\n      ERC20 aToken  = ERC20(tokenToAToken[tokenAddress]);\n      StakingInterface staker  =  StakingInterface(tokenToFarmMapping[tokenAddress]);\n      staker.withdraw(tokenAddress, aToken.balanceOf(address(this)), address(this));\n      return true;\n\n   }\n\n\n   function getStakedPoolBalanceByUser(address _owner, address tokenAddress) public view returns(uint256){\n        StakingInterface staker  = StakingInterface(tokenToFarmMapping[tokenAddress]);\n        ERC20 aToken  = ERC20(tokenToAToken[tokenAddress]);\n        uint256 numberTokens = aToken.balanceOf(address(this));\n\n        uint256 usersBalancePercentage = (depositBalances[_owner][tokenAddress].mul(1000000)).div(totalAmountStaked[tokenAddress]);\n        uint256 numberTokensPlusRewardsForUser= (numberTokens.mul(1000).mul(usersBalancePercentage)).div(1000000000);\n\n\n        return numberTokensPlusRewardsForUser;\n\n    }\n\n  //SWC-135-Code With No Effects: 205-253\n  function withdraw(address tokenAddress, uint256 amount, address payable onBehalfOf) onlyOwner payable public returns(bool){\n\n      ERC20 thisToken = ERC20(tokenAddress);\n      //uint256 numberTokensPreWithdrawal = getStakedBalance(address(this), tokenAddress);\n\n        if(tokenAddress == 0x0000000000000000000000000000000000000000){\n            require(depositBalances[msg.sender][tokenAddress] >= amount, \"You didnt deposit enough eth\");\n\n            totalAmountStaked[tokenAddress] = totalAmountStaked[tokenAddress].sub(depositBalances[onBehalfOf][tokenAddress]);\n            depositBalances[onBehalfOf][tokenAddress] = depositBalances[onBehalfOf][tokenAddress]  - amount;\n            onBehalfOf.send(amount);\n            return true;\n\n        }\n\n        require(depositBalances[onBehalfOf][tokenAddress] > 0, \"You dont have any tokens deposited\");\n\n        //uint256 numberTokensPostWithdrawal = thisToken.balanceOf(address(this));\n\n        //uint256 usersBalancePercentage = depositBalances[onBehalfOf][tokenAddress].div(totalAmountStaked[tokenAddress]);\n\n        uint256 numberTokensPlusRewardsForUser1 = getStakedPoolBalanceByUser(onBehalfOf, tokenAddress);\n        uint256 commissionForDAO1 = calculateCommission(numberTokensPlusRewardsForUser1);\n        uint256 numberTokensPlusRewardsForUserMinusCommission = numberTokensPlusRewardsForUser1-commissionForDAO1;\n\n        unstake(amount, onBehalfOf, tokenAddress);\n\n        //staking platforms only withdraw all for the most part, and for security sticking to this\n        totalAmountStaked[tokenAddress] = totalAmountStaked[tokenAddress].sub(depositBalances[onBehalfOf][tokenAddress]);\n\n        depositBalances[onBehalfOf][tokenAddress] = 0;\n        require(numberTokensPlusRewardsForUserMinusCommission >0, \"For some reason numberTokensPlusRewardsForUserMinusCommission is zero\");\n\n        require(thisToken.transfer(onBehalfOf, numberTokensPlusRewardsForUserMinusCommission), \"You dont have enough tokens inside this contract to withdraw from deposits\");\n        if(numberTokensPlusRewardsForUserMinusCommission >0){\n            thisToken.transfer(owner, commissionForDAO1);\n        }\n\n\n        uint256 remainingBalance = thisToken.balanceOf(address(this));\n        if(remainingBalance>0){\n            stake(remainingBalance, address(this), tokenAddress);\n        }\n\n\n        emit Withdrawal(onBehalfOf, amount, tokenAddress);\n        return true;\n\n   }\n\n\n   function calculateCommission(uint256 amount) view public returns(uint256){\n     uint256 commissionForDAO = (amount.mul(1000).mul(commission)).div(10000000);\n     return commissionForDAO;\n   }\n\n   function changeOwner(address payable newAdmin) onlyOwner public returns (bool){\n     owner = newAdmin;\n     return true;\n   }\n\n   function changeAdmin(address payable newOwner) onlyAdmin public returns (bool){\n     admin = newOwner;\n     return true;\n   }\n\n\n\n   function getStakedBalance(address _owner, address tokenAddress) public view returns(uint256){\n\n       ERC20 staker  = ERC20(tokenToAToken[tokenAddress]);\n       return staker.balanceOf(_owner);\n   }\n\n\n\n  function adminEmergencyWithdrawTokens(address token, uint amount, address payable destination) public onlyOwner returns(bool) {\n\n\n\n      if (address(token) == ETH_TOKEN_ADDRESS) {\n          destination.transfer(amount);\n      }\n      else {\n          ERC20 tokenToken = ERC20(token);\n          require(tokenToken.transfer(destination, amount));\n      }\n\n\n\n\n      return true;\n  }\n\n\n\n function kill() virtual public onlyOwner {\n\n         selfdestruct(owner);\n\n }\n\n\n    event Deposit(address indexed user, uint256 amount, address token);\n    event Withdrawal(address indexed user, uint256 amount, address token);\n\n\n\n\n}",
        "function": "getStakedPoolBalanceByUser(address,address)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/PeckShield-Plexus/PlexusContracts-f7e8196a3881faee80369330f6844a7f38d65b65/contracts/tier2Aave.sol",
        "vulnerability": "Exception State (SWC 110)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract Tier2FarmController {\n\n  using SafeMath\n    for uint256;\n\n\n  address payable public owner;\n  address payable public admin;\n  address public platformToken = 0x25550Cccbd68533Fa04bFD3e3AC4D09f9e00Fc50;\n  address public tokenStakingContract = 0x7d2768dE32b0b80b7a3454c06BdAc94A69DDc7A9;\n  address ETH_TOKEN_ADDRESS  = address(0x0);\n  mapping (string => address) public stakingContracts;\n  mapping (address => address) public tokenToFarmMapping;\n  mapping (string => address) public stakingContractsStakingToken;\n  mapping (address => mapping (address => uint256)) public depositBalances;\n  mapping (address => address) public tokenToAToken;\n    mapping (address => address) public aTokenToToken;\n  uint256 public commission  = 400; // Default is 4 percent\n\n\n  string public farmName = 'Aave';\n  mapping (address => uint256) public totalAmountStaked;\n\n   modifier onlyOwner {\n         require(\n             msg.sender == owner,\n             \"Only owner can call this function.\"\n         );\n         _;\n }\n\n  modifier onlyAdmin {\n         require(\n             msg.sender == admin,\n             \"Only admin can call this function.\"\n         );\n         _;\n }\n\n\n\n\n\n\n\n  constructor() public payable {\n        stakingContracts[\"DAI\"] =0x7d2768dE32b0b80b7a3454c06BdAc94A69DDc7A9 ;\n        stakingContracts[\"ALL\"] =0x7d2768dE32b0b80b7a3454c06BdAc94A69DDc7A9 ;\n        stakingContractsStakingToken [\"DAI\"] = 0x25550Cccbd68533Fa04bFD3e3AC4D09f9e00Fc50;\n        tokenToAToken[0x6B175474E89094C44Da98b954EedeAC495271d0F]= 0x25550Cccbd68533Fa04bFD3e3AC4D09f9e00Fc50;\n        aTokenToToken[0x25550Cccbd68533Fa04bFD3e3AC4D09f9e00Fc50]= 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n        tokenToFarmMapping[stakingContractsStakingToken [\"DAI\"]] =  stakingContracts[\"DAI\"];\n        owner= msg.sender;\n        admin = msg.sender;\n\n  }\n\n\n  fallback() external payable {\n\n\n  }\n\n\nfunction updateATokens(address tokenAddress, address aTokenAddress) public onlyAdmin returns (bool){\n    tokenToAToken[tokenAddress] = aTokenAddress;\n    aTokenToToken[aTokenAddress] = tokenAddress;\n    return true;\n}\n\n  function addOrEditStakingContract(string memory name, address stakingAddress, address stakingToken ) public onlyOwner returns (bool){\n\n    stakingContracts[name] = stakingAddress;\n    stakingContractsStakingToken[name] = stakingToken;\n    tokenToFarmMapping[stakingToken] = stakingAddress;\n\n    return true;\n\n  }\n\n  function updateCommission(uint amount) public onlyOwner returns(bool){\n      commission = amount;\n      return true;\n  }\n\n  function deposit(address tokenAddress, uint256 amount, address onBehalfOf) payable onlyOwner public returns (bool){\n\n\n\n\n        ERC20 thisToken = ERC20(tokenAddress);\n        require(thisToken.transferFrom(msg.sender, address(this), amount), \"Not enough tokens to transferFrom or no approval\");\n\n        depositBalances[onBehalfOf][tokenAddress] = depositBalances[onBehalfOf][tokenAddress].add(amount);\n\n        uint256 approvedAmount = thisToken.allowance(address(this), tokenToFarmMapping[tokenAddress]);\n        if(approvedAmount < amount  ){\n            thisToken.approve(tokenToFarmMapping[tokenAddress], amount.mul(10000000));\n        }\n        stake(amount, onBehalfOf, tokenAddress );\n\n        totalAmountStaked[tokenAddress] = totalAmountStaked[tokenAddress].add(amount);\n\n        emit Deposit(onBehalfOf, amount, tokenAddress);\n        return true;\n   }\n\n   function stake(uint256 amount, address onBehalfOf, address tokenAddress) internal returns(bool){\n\n      StakingInterface staker  = StakingInterface(tokenToFarmMapping[tokenAddress]);\n      staker.deposit(tokenAddress, amount, address(this), 0);\n      return true;\n\n   }\n\n   function unstake(uint256 amount, address onBehalfOf, address tokenAddress) internal returns(bool){\n      ERC20 aToken  = ERC20(tokenToAToken[tokenAddress]);\n      StakingInterface staker  =  StakingInterface(tokenToFarmMapping[tokenAddress]);\n      staker.withdraw(tokenAddress, aToken.balanceOf(address(this)), address(this));\n      return true;\n\n   }\n\n\n   function getStakedPoolBalanceByUser(address _owner, address tokenAddress) public view returns(uint256){\n        StakingInterface staker  = StakingInterface(tokenToFarmMapping[tokenAddress]);\n        ERC20 aToken  = ERC20(tokenToAToken[tokenAddress]);\n        uint256 numberTokens = aToken.balanceOf(address(this));\n\n        uint256 usersBalancePercentage = (depositBalances[_owner][tokenAddress].mul(1000000)).div(totalAmountStaked[tokenAddress]);\n        uint256 numberTokensPlusRewardsForUser= (numberTokens.mul(1000).mul(usersBalancePercentage)).div(1000000000);\n\n\n        return numberTokensPlusRewardsForUser;\n\n    }\n\n  //SWC-135-Code With No Effects: 205-253\n  function withdraw(address tokenAddress, uint256 amount, address payable onBehalfOf) onlyOwner payable public returns(bool){\n\n      ERC20 thisToken = ERC20(tokenAddress);\n      //uint256 numberTokensPreWithdrawal = getStakedBalance(address(this), tokenAddress);\n\n        if(tokenAddress == 0x0000000000000000000000000000000000000000){\n            require(depositBalances[msg.sender][tokenAddress] >= amount, \"You didnt deposit enough eth\");\n\n            totalAmountStaked[tokenAddress] = totalAmountStaked[tokenAddress].sub(depositBalances[onBehalfOf][tokenAddress]);\n            depositBalances[onBehalfOf][tokenAddress] = depositBalances[onBehalfOf][tokenAddress]  - amount;\n            onBehalfOf.send(amount);\n            return true;\n\n        }\n\n        require(depositBalances[onBehalfOf][tokenAddress] > 0, \"You dont have any tokens deposited\");\n\n        //uint256 numberTokensPostWithdrawal = thisToken.balanceOf(address(this));\n\n        //uint256 usersBalancePercentage = depositBalances[onBehalfOf][tokenAddress].div(totalAmountStaked[tokenAddress]);\n\n        uint256 numberTokensPlusRewardsForUser1 = getStakedPoolBalanceByUser(onBehalfOf, tokenAddress);\n        uint256 commissionForDAO1 = calculateCommission(numberTokensPlusRewardsForUser1);\n        uint256 numberTokensPlusRewardsForUserMinusCommission = numberTokensPlusRewardsForUser1-commissionForDAO1;\n\n        unstake(amount, onBehalfOf, tokenAddress);\n\n        //staking platforms only withdraw all for the most part, and for security sticking to this\n        totalAmountStaked[tokenAddress] = totalAmountStaked[tokenAddress].sub(depositBalances[onBehalfOf][tokenAddress]);\n\n        depositBalances[onBehalfOf][tokenAddress] = 0;\n        require(numberTokensPlusRewardsForUserMinusCommission >0, \"For some reason numberTokensPlusRewardsForUserMinusCommission is zero\");\n\n        require(thisToken.transfer(onBehalfOf, numberTokensPlusRewardsForUserMinusCommission), \"You dont have enough tokens inside this contract to withdraw from deposits\");\n        if(numberTokensPlusRewardsForUserMinusCommission >0){\n            thisToken.transfer(owner, commissionForDAO1);\n        }\n\n\n        uint256 remainingBalance = thisToken.balanceOf(address(this));\n        if(remainingBalance>0){\n            stake(remainingBalance, address(this), tokenAddress);\n        }\n\n\n        emit Withdrawal(onBehalfOf, amount, tokenAddress);\n        return true;\n\n   }\n\n\n   function calculateCommission(uint256 amount) view public returns(uint256){\n     uint256 commissionForDAO = (amount.mul(1000).mul(commission)).div(10000000);\n     return commissionForDAO;\n   }\n\n   function changeOwner(address payable newAdmin) onlyOwner public returns (bool){\n     owner = newAdmin;\n     return true;\n   }\n\n   function changeAdmin(address payable newOwner) onlyAdmin public returns (bool){\n     admin = newOwner;\n     return true;\n   }\n\n\n\n   function getStakedBalance(address _owner, address tokenAddress) public view returns(uint256){\n\n       ERC20 staker  = ERC20(tokenToAToken[tokenAddress]);\n       return staker.balanceOf(_owner);\n   }\n\n\n\n  function adminEmergencyWithdrawTokens(address token, uint amount, address payable destination) public onlyOwner returns(bool) {\n\n\n\n      if (address(token) == ETH_TOKEN_ADDRESS) {\n          destination.transfer(amount);\n      }\n      else {\n          ERC20 tokenToken = ERC20(token);\n          require(tokenToken.transfer(destination, amount));\n      }\n\n\n\n\n      return true;\n  }\n\n\n\n function kill() virtual public onlyOwner {\n\n         selfdestruct(owner);\n\n }\n\n\n    event Deposit(address indexed user, uint256 amount, address token);\n    event Withdrawal(address indexed user, uint256 amount, address token);\n\n\n\n\n}",
        "function": "deposit(address,uint256,address)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/PeckShield-Plexus/PlexusContracts-f7e8196a3881faee80369330f6844a7f38d65b65/contracts/tier2Aave.sol",
        "vulnerability": "State access after external call (SWC 107)",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract Tier2FarmController {\n\n  using SafeMath\n    for uint256;\n\n\n  address payable public owner;\n  address payable public admin;\n  address public platformToken = 0x25550Cccbd68533Fa04bFD3e3AC4D09f9e00Fc50;\n  address public tokenStakingContract = 0x7d2768dE32b0b80b7a3454c06BdAc94A69DDc7A9;\n  address ETH_TOKEN_ADDRESS  = address(0x0);\n  mapping (string => address) public stakingContracts;\n  mapping (address => address) public tokenToFarmMapping;\n  mapping (string => address) public stakingContractsStakingToken;\n  mapping (address => mapping (address => uint256)) public depositBalances;\n  mapping (address => address) public tokenToAToken;\n    mapping (address => address) public aTokenToToken;\n  uint256 public commission  = 400; // Default is 4 percent\n\n\n  string public farmName = 'Aave';\n  mapping (address => uint256) public totalAmountStaked;\n\n   modifier onlyOwner {\n         require(\n             msg.sender == owner,\n             \"Only owner can call this function.\"\n         );\n         _;\n }\n\n  modifier onlyAdmin {\n         require(\n             msg.sender == admin,\n             \"Only admin can call this function.\"\n         );\n         _;\n }\n\n\n\n\n\n\n\n  constructor() public payable {\n        stakingContracts[\"DAI\"] =0x7d2768dE32b0b80b7a3454c06BdAc94A69DDc7A9 ;\n        stakingContracts[\"ALL\"] =0x7d2768dE32b0b80b7a3454c06BdAc94A69DDc7A9 ;\n        stakingContractsStakingToken [\"DAI\"] = 0x25550Cccbd68533Fa04bFD3e3AC4D09f9e00Fc50;\n        tokenToAToken[0x6B175474E89094C44Da98b954EedeAC495271d0F]= 0x25550Cccbd68533Fa04bFD3e3AC4D09f9e00Fc50;\n        aTokenToToken[0x25550Cccbd68533Fa04bFD3e3AC4D09f9e00Fc50]= 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n        tokenToFarmMapping[stakingContractsStakingToken [\"DAI\"]] =  stakingContracts[\"DAI\"];\n        owner= msg.sender;\n        admin = msg.sender;\n\n  }\n\n\n  fallback() external payable {\n\n\n  }\n\n\nfunction updateATokens(address tokenAddress, address aTokenAddress) public onlyAdmin returns (bool){\n    tokenToAToken[tokenAddress] = aTokenAddress;\n    aTokenToToken[aTokenAddress] = tokenAddress;\n    return true;\n}\n\n  function addOrEditStakingContract(string memory name, address stakingAddress, address stakingToken ) public onlyOwner returns (bool){\n\n    stakingContracts[name] = stakingAddress;\n    stakingContractsStakingToken[name] = stakingToken;\n    tokenToFarmMapping[stakingToken] = stakingAddress;\n\n    return true;\n\n  }\n\n  function updateCommission(uint amount) public onlyOwner returns(bool){\n      commission = amount;\n      return true;\n  }\n\n  function deposit(address tokenAddress, uint256 amount, address onBehalfOf) payable onlyOwner public returns (bool){\n\n\n\n\n        ERC20 thisToken = ERC20(tokenAddress);\n        require(thisToken.transferFrom(msg.sender, address(this), amount), \"Not enough tokens to transferFrom or no approval\");\n\n        depositBalances[onBehalfOf][tokenAddress] = depositBalances[onBehalfOf][tokenAddress].add(amount);\n\n        uint256 approvedAmount = thisToken.allowance(address(this), tokenToFarmMapping[tokenAddress]);\n        if(approvedAmount < amount  ){\n            thisToken.approve(tokenToFarmMapping[tokenAddress], amount.mul(10000000));\n        }\n        stake(amount, onBehalfOf, tokenAddress );\n\n        totalAmountStaked[tokenAddress] = totalAmountStaked[tokenAddress].add(amount);\n\n        emit Deposit(onBehalfOf, amount, tokenAddress);\n        return true;\n   }\n\n   function stake(uint256 amount, address onBehalfOf, address tokenAddress) internal returns(bool){\n\n      StakingInterface staker  = StakingInterface(tokenToFarmMapping[tokenAddress]);\n      staker.deposit(tokenAddress, amount, address(this), 0);\n      return true;\n\n   }\n\n   function unstake(uint256 amount, address onBehalfOf, address tokenAddress) internal returns(bool){\n      ERC20 aToken  = ERC20(tokenToAToken[tokenAddress]);\n      StakingInterface staker  =  StakingInterface(tokenToFarmMapping[tokenAddress]);\n      staker.withdraw(tokenAddress, aToken.balanceOf(address(this)), address(this));\n      return true;\n\n   }\n\n\n   function getStakedPoolBalanceByUser(address _owner, address tokenAddress) public view returns(uint256){\n        StakingInterface staker  = StakingInterface(tokenToFarmMapping[tokenAddress]);\n        ERC20 aToken  = ERC20(tokenToAToken[tokenAddress]);\n        uint256 numberTokens = aToken.balanceOf(address(this));\n\n        uint256 usersBalancePercentage = (depositBalances[_owner][tokenAddress].mul(1000000)).div(totalAmountStaked[tokenAddress]);\n        uint256 numberTokensPlusRewardsForUser= (numberTokens.mul(1000).mul(usersBalancePercentage)).div(1000000000);\n\n\n        return numberTokensPlusRewardsForUser;\n\n    }\n\n  //SWC-135-Code With No Effects: 205-253\n  function withdraw(address tokenAddress, uint256 amount, address payable onBehalfOf) onlyOwner payable public returns(bool){\n\n      ERC20 thisToken = ERC20(tokenAddress);\n      //uint256 numberTokensPreWithdrawal = getStakedBalance(address(this), tokenAddress);\n\n        if(tokenAddress == 0x0000000000000000000000000000000000000000){\n            require(depositBalances[msg.sender][tokenAddress] >= amount, \"You didnt deposit enough eth\");\n\n            totalAmountStaked[tokenAddress] = totalAmountStaked[tokenAddress].sub(depositBalances[onBehalfOf][tokenAddress]);\n            depositBalances[onBehalfOf][tokenAddress] = depositBalances[onBehalfOf][tokenAddress]  - amount;\n            onBehalfOf.send(amount);\n            return true;\n\n        }\n\n        require(depositBalances[onBehalfOf][tokenAddress] > 0, \"You dont have any tokens deposited\");\n\n        //uint256 numberTokensPostWithdrawal = thisToken.balanceOf(address(this));\n\n        //uint256 usersBalancePercentage = depositBalances[onBehalfOf][tokenAddress].div(totalAmountStaked[tokenAddress]);\n\n        uint256 numberTokensPlusRewardsForUser1 = getStakedPoolBalanceByUser(onBehalfOf, tokenAddress);\n        uint256 commissionForDAO1 = calculateCommission(numberTokensPlusRewardsForUser1);\n        uint256 numberTokensPlusRewardsForUserMinusCommission = numberTokensPlusRewardsForUser1-commissionForDAO1;\n\n        unstake(amount, onBehalfOf, tokenAddress);\n\n        //staking platforms only withdraw all for the most part, and for security sticking to this\n        totalAmountStaked[tokenAddress] = totalAmountStaked[tokenAddress].sub(depositBalances[onBehalfOf][tokenAddress]);\n\n        depositBalances[onBehalfOf][tokenAddress] = 0;\n        require(numberTokensPlusRewardsForUserMinusCommission >0, \"For some reason numberTokensPlusRewardsForUserMinusCommission is zero\");\n\n        require(thisToken.transfer(onBehalfOf, numberTokensPlusRewardsForUserMinusCommission), \"You dont have enough tokens inside this contract to withdraw from deposits\");\n        if(numberTokensPlusRewardsForUserMinusCommission >0){\n            thisToken.transfer(owner, commissionForDAO1);\n        }\n\n\n        uint256 remainingBalance = thisToken.balanceOf(address(this));\n        if(remainingBalance>0){\n            stake(remainingBalance, address(this), tokenAddress);\n        }\n\n\n        emit Withdrawal(onBehalfOf, amount, tokenAddress);\n        return true;\n\n   }\n\n\n   function calculateCommission(uint256 amount) view public returns(uint256){\n     uint256 commissionForDAO = (amount.mul(1000).mul(commission)).div(10000000);\n     return commissionForDAO;\n   }\n\n   function changeOwner(address payable newAdmin) onlyOwner public returns (bool){\n     owner = newAdmin;\n     return true;\n   }\n\n   function changeAdmin(address payable newOwner) onlyAdmin public returns (bool){\n     admin = newOwner;\n     return true;\n   }\n\n\n\n   function getStakedBalance(address _owner, address tokenAddress) public view returns(uint256){\n\n       ERC20 staker  = ERC20(tokenToAToken[tokenAddress]);\n       return staker.balanceOf(_owner);\n   }\n\n\n\n  function adminEmergencyWithdrawTokens(address token, uint amount, address payable destination) public onlyOwner returns(bool) {\n\n\n\n      if (address(token) == ETH_TOKEN_ADDRESS) {\n          destination.transfer(amount);\n      }\n      else {\n          ERC20 tokenToken = ERC20(token);\n          require(tokenToken.transfer(destination, amount));\n      }\n\n\n\n\n      return true;\n  }\n\n\n\n function kill() virtual public onlyOwner {\n\n         selfdestruct(owner);\n\n }\n\n\n    event Deposit(address indexed user, uint256 amount, address token);\n    event Withdrawal(address indexed user, uint256 amount, address token);\n\n\n\n\n}",
        "function": "deposit(address,uint256,address)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/PeckShield-Plexus/PlexusContracts-f7e8196a3881faee80369330f6844a7f38d65b65/contracts/tier2Aave.sol",
        "vulnerability": "State access after external call (SWC 107)",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract Tier2FarmController {\n\n  using SafeMath\n    for uint256;\n\n\n  address payable public owner;\n  address public platformToken = 0xa0246c9032bC3A600820415aE600c6388619A14D;\n  address public tokenStakingContract = 0x25550Cccbd68533Fa04bFD3e3AC4D09f9e00Fc50;\n  address ETH_TOKEN_ADDRESS  = address(0x0);\n  mapping (string => address) public stakingContracts;\n  mapping (address => address) public tokenToFarmMapping;\n  mapping (string => address) public stakingContractsStakingToken;\n  mapping (address => mapping (address => uint256)) public depositBalances;\n  uint256 public commission  = 400; // Default is 4 percent\n\n\n  string public farmName = 'Harvest.Finance';\n  mapping (address => uint256) public totalAmountStaked;\n\n  modifier onlyOwner {\n         require(\n             msg.sender == owner,\n             \"Only owner can call this function.\"\n         );\n         _;\n }\n\n\n\n\n\n  constructor() public payable {\n        stakingContracts[\"FARM\"] = 0x25550Cccbd68533Fa04bFD3e3AC4D09f9e00Fc50;\n        stakingContractsStakingToken [\"FARM\"] = 0xa0246c9032bC3A600820415aE600c6388619A14D;\n        tokenToFarmMapping[stakingContractsStakingToken [\"FARM\"]] =  stakingContracts[\"FARM\"];\n        owner= msg.sender;\n\n  }\n\n\n  fallback() external payable {\n\n\n  }\n\n\n\n  function addOrEditStakingContract(string memory name, address stakingAddress, address stakingToken ) public onlyOwner returns (bool){\n\n    stakingContracts[name] = stakingAddress;\n    stakingContractsStakingToken[name] = stakingToken;\n    tokenToFarmMapping[stakingToken] = stakingAddress;\n    return true;\n\n  }\n\n  function updateCommission(uint amount) public onlyOwner returns(bool){\n      commission = amount;\n      return true;\n  }\n\n  function deposit(address tokenAddress, uint256 amount, address onBehalfOf) payable onlyOwner public returns (bool){\n\n\n       if(tokenAddress == 0x0000000000000000000000000000000000000000){\n\n            depositBalances[onBehalfOf][tokenAddress] = depositBalances[onBehalfOf][tokenAddress]  + msg.value;\n\n             stake(amount, onBehalfOf, tokenAddress );\n             totalAmountStaked[tokenAddress] = totalAmountStaked[tokenAddress].add(amount);\n             emit Deposit(onBehalfOf, amount, tokenAddress);\n            return true;\n\n        }\n\n        ERC20 thisToken = ERC20(tokenAddress);\n        require(thisToken.transferFrom(msg.sender, address(this), amount), \"Not enough tokens to transferFrom or no approval\");\n\n        depositBalances[onBehalfOf][tokenAddress] = depositBalances[onBehalfOf][tokenAddress]  + amount;\n\n        uint256 approvedAmount = thisToken.allowance(address(this), tokenToFarmMapping[tokenAddress]);\n        if(approvedAmount < amount  ){\n            thisToken.approve(tokenToFarmMapping[tokenAddress], amount.mul(10000000));\n        }\n        stake(amount, onBehalfOf, tokenAddress );\n\n        totalAmountStaked[tokenAddress] = totalAmountStaked[tokenAddress].add(amount);\n\n        emit Deposit(onBehalfOf, amount, tokenAddress);\n        return true;\n   }\n\n   function stake(uint256 amount, address onBehalfOf, address tokenAddress) internal returns(bool){\n\n      StakingInterface staker  = StakingInterface(tokenToFarmMapping[tokenAddress]);\n      staker.stake(amount);\n      return true;\n\n   }\n\n   function unstake(uint256 amount, address onBehalfOf, address tokenAddress) internal returns(bool){\n      StakingInterface staker  =  StakingInterface(tokenToFarmMapping[tokenAddress]);\n      staker.exit();\n      return true;\n\n   }\n\n\n   function getStakedPoolBalanceByUser(address _owner, address tokenAddress) public view returns(uint256){\n        StakingInterface staker  = StakingInterface(tokenToFarmMapping[tokenAddress]);\n\n        uint256 numberTokens = staker.balanceOf(address(this));\n\n        uint256 usersBalancePercentage = (depositBalances[_owner][tokenAddress].mul(1000000)).div(totalAmountStaked[tokenAddress]);\n        uint256 numberTokensPlusRewardsForUser= (numberTokens.mul(1000).mul(usersBalancePercentage)).div(1000000000);\n\n\n        return numberTokensPlusRewardsForUser;\n\n    }\n\n\n  function withdraw(address tokenAddress, uint256 amount, address payable onBehalfOf) onlyOwner payable public returns(bool){\n\n      ERC20 thisToken = ERC20(tokenAddress);\n      //uint256 numberTokensPreWithdrawal = getStakedBalance(address(this), tokenAddress);\n\n        if(tokenAddress == 0x0000000000000000000000000000000000000000){\n            require(depositBalances[msg.sender][tokenAddress] >= amount, \"You didnt deposit enough eth\");\n\n            totalAmountStaked[tokenAddress] = totalAmountStaked[tokenAddress].sub(depositBalances[onBehalfOf][tokenAddress]);\n            depositBalances[onBehalfOf][tokenAddress] = depositBalances[onBehalfOf][tokenAddress]  - amount;\n            onBehalfOf.send(amount);\n            return true;\n\n        }\n\n\n        require(depositBalances[onBehalfOf][tokenAddress] > 0, \"You dont have any tokens deposited\");\n\n\n\n        //uint256 numberTokensPostWithdrawal = thisToken.balanceOf(address(this));\n\n        //uint256 usersBalancePercentage = depositBalances[onBehalfOf][tokenAddress].div(totalAmountStaked[tokenAddress]);\n\n        uint256 numberTokensPlusRewardsForUser1 = getStakedPoolBalanceByUser(onBehalfOf, tokenAddress);\n        uint256 commissionForDAO1 = calculateCommission(numberTokensPlusRewardsForUser1);\n        uint256 numberTokensPlusRewardsForUserMinusCommission = numberTokensPlusRewardsForUser1-commissionForDAO1;\n\n        unstake(amount, onBehalfOf, tokenAddress);\n\n        //staking platforms only withdraw all for the most part, and for security sticking to this\n        totalAmountStaked[tokenAddress] = totalAmountStaked[tokenAddress].sub(depositBalances[onBehalfOf][tokenAddress]);\n\n\n\n\n\n        depositBalances[onBehalfOf][tokenAddress] = 0;\n        require(numberTokensPlusRewardsForUserMinusCommission >0, \"For some reason numberTokensPlusRewardsForUserMinusCommission is zero\");\n\n        require(thisToken.transfer(onBehalfOf, numberTokensPlusRewardsForUserMinusCommission), \"You dont have enough tokens inside this contract to withdraw from deposits\");\n        if(numberTokensPlusRewardsForUserMinusCommission >0){\n            thisToken.transfer(owner, commissionForDAO1);\n        }\n\n\n        uint256 remainingBalance = thisToken.balanceOf(address(this));\n        if(remainingBalance>0){\n            stake(remainingBalance, address(this), tokenAddress);\n        }\n\n\n        emit Withdrawal(onBehalfOf, amount, tokenAddress);\n        return true;\n\n   }\n\n\n   function calculateCommission(uint256 amount) view public returns(uint256){\n     uint256 commissionForDAO = (amount.mul(1000).mul(commission)).div(10000000);\n     return commissionForDAO;\n   }\n\n   function changeOwner(address payable newOwner) onlyOwner public returns (bool){\n     owner = newOwner;\n     return true;\n   }\n\n\n   function getStakedBalance(address _owner, address tokenAddress) public view returns(uint256){\n\n       StakingInterface staker  = StakingInterface(tokenToFarmMapping[tokenAddress]);\n       return staker.balanceOf(_owner);\n   }\n\n\n\n  function adminEmergencyWithdrawTokens(address token, uint amount, address payable destination) public onlyOwner returns(bool) {\n\n\n\n      if (address(token) == ETH_TOKEN_ADDRESS) {\n          destination.transfer(amount);\n      }\n      else {\n          ERC20 tokenToken = ERC20(token);\n          require(tokenToken.transfer(destination, amount));\n      }\n\n\n\n\n      return true;\n  }\n\n\n\n function kill() virtual public onlyOwner {\n\n         selfdestruct(owner);\n\n }\n\n\n    event Deposit(address indexed user, uint256 amount, address token);\n    event Withdrawal(address indexed user, uint256 amount, address token);\n\n\n\n\n}",
        "function": "adminEmergencyWithdrawTokens(address,uint256,address)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/PeckShield-Plexus/PlexusContracts-f7e8196a3881faee80369330f6844a7f38d65b65/contracts/tier2Farm.sol",
        "vulnerability": "External Call To User-Supplied Address (SWC 107)",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract Tier2FarmController {\n\n  using SafeMath\n    for uint256;\n\n\n  address payable public owner;\n  address public platformToken = 0xa0246c9032bC3A600820415aE600c6388619A14D;\n  address public tokenStakingContract = 0x25550Cccbd68533Fa04bFD3e3AC4D09f9e00Fc50;\n  address ETH_TOKEN_ADDRESS  = address(0x0);\n  mapping (string => address) public stakingContracts;\n  mapping (address => address) public tokenToFarmMapping;\n  mapping (string => address) public stakingContractsStakingToken;\n  mapping (address => mapping (address => uint256)) public depositBalances;\n  uint256 public commission  = 400; // Default is 4 percent\n\n\n  string public farmName = 'Harvest.Finance';\n  mapping (address => uint256) public totalAmountStaked;\n\n  modifier onlyOwner {\n         require(\n             msg.sender == owner,\n             \"Only owner can call this function.\"\n         );\n         _;\n }\n\n\n\n\n\n  constructor() public payable {\n        stakingContracts[\"FARM\"] = 0x25550Cccbd68533Fa04bFD3e3AC4D09f9e00Fc50;\n        stakingContractsStakingToken [\"FARM\"] = 0xa0246c9032bC3A600820415aE600c6388619A14D;\n        tokenToFarmMapping[stakingContractsStakingToken [\"FARM\"]] =  stakingContracts[\"FARM\"];\n        owner= msg.sender;\n\n  }\n\n\n  fallback() external payable {\n\n\n  }\n\n\n\n  function addOrEditStakingContract(string memory name, address stakingAddress, address stakingToken ) public onlyOwner returns (bool){\n\n    stakingContracts[name] = stakingAddress;\n    stakingContractsStakingToken[name] = stakingToken;\n    tokenToFarmMapping[stakingToken] = stakingAddress;\n    return true;\n\n  }\n\n  function updateCommission(uint amount) public onlyOwner returns(bool){\n      commission = amount;\n      return true;\n  }\n\n  function deposit(address tokenAddress, uint256 amount, address onBehalfOf) payable onlyOwner public returns (bool){\n\n\n       if(tokenAddress == 0x0000000000000000000000000000000000000000){\n\n            depositBalances[onBehalfOf][tokenAddress] = depositBalances[onBehalfOf][tokenAddress]  + msg.value;\n\n             stake(amount, onBehalfOf, tokenAddress );\n             totalAmountStaked[tokenAddress] = totalAmountStaked[tokenAddress].add(amount);\n             emit Deposit(onBehalfOf, amount, tokenAddress);\n            return true;\n\n        }\n\n        ERC20 thisToken = ERC20(tokenAddress);\n        require(thisToken.transferFrom(msg.sender, address(this), amount), \"Not enough tokens to transferFrom or no approval\");\n\n        depositBalances[onBehalfOf][tokenAddress] = depositBalances[onBehalfOf][tokenAddress]  + amount;\n\n        uint256 approvedAmount = thisToken.allowance(address(this), tokenToFarmMapping[tokenAddress]);\n        if(approvedAmount < amount  ){\n            thisToken.approve(tokenToFarmMapping[tokenAddress], amount.mul(10000000));\n        }\n        stake(amount, onBehalfOf, tokenAddress );\n\n        totalAmountStaked[tokenAddress] = totalAmountStaked[tokenAddress].add(amount);\n\n        emit Deposit(onBehalfOf, amount, tokenAddress);\n        return true;\n   }\n\n   function stake(uint256 amount, address onBehalfOf, address tokenAddress) internal returns(bool){\n\n      StakingInterface staker  = StakingInterface(tokenToFarmMapping[tokenAddress]);\n      staker.stake(amount);\n      return true;\n\n   }\n\n   function unstake(uint256 amount, address onBehalfOf, address tokenAddress) internal returns(bool){\n      StakingInterface staker  =  StakingInterface(tokenToFarmMapping[tokenAddress]);\n      staker.exit();\n      return true;\n\n   }\n\n\n   function getStakedPoolBalanceByUser(address _owner, address tokenAddress) public view returns(uint256){\n        StakingInterface staker  = StakingInterface(tokenToFarmMapping[tokenAddress]);\n\n        uint256 numberTokens = staker.balanceOf(address(this));\n\n        uint256 usersBalancePercentage = (depositBalances[_owner][tokenAddress].mul(1000000)).div(totalAmountStaked[tokenAddress]);\n        uint256 numberTokensPlusRewardsForUser= (numberTokens.mul(1000).mul(usersBalancePercentage)).div(1000000000);\n\n\n        return numberTokensPlusRewardsForUser;\n\n    }\n\n\n  function withdraw(address tokenAddress, uint256 amount, address payable onBehalfOf) onlyOwner payable public returns(bool){\n\n      ERC20 thisToken = ERC20(tokenAddress);\n      //uint256 numberTokensPreWithdrawal = getStakedBalance(address(this), tokenAddress);\n\n        if(tokenAddress == 0x0000000000000000000000000000000000000000){\n            require(depositBalances[msg.sender][tokenAddress] >= amount, \"You didnt deposit enough eth\");\n\n            totalAmountStaked[tokenAddress] = totalAmountStaked[tokenAddress].sub(depositBalances[onBehalfOf][tokenAddress]);\n            depositBalances[onBehalfOf][tokenAddress] = depositBalances[onBehalfOf][tokenAddress]  - amount;\n            onBehalfOf.send(amount);\n            return true;\n\n        }\n\n\n        require(depositBalances[onBehalfOf][tokenAddress] > 0, \"You dont have any tokens deposited\");\n\n\n\n        //uint256 numberTokensPostWithdrawal = thisToken.balanceOf(address(this));\n\n        //uint256 usersBalancePercentage = depositBalances[onBehalfOf][tokenAddress].div(totalAmountStaked[tokenAddress]);\n\n        uint256 numberTokensPlusRewardsForUser1 = getStakedPoolBalanceByUser(onBehalfOf, tokenAddress);\n        uint256 commissionForDAO1 = calculateCommission(numberTokensPlusRewardsForUser1);\n        uint256 numberTokensPlusRewardsForUserMinusCommission = numberTokensPlusRewardsForUser1-commissionForDAO1;\n\n        unstake(amount, onBehalfOf, tokenAddress);\n\n        //staking platforms only withdraw all for the most part, and for security sticking to this\n        totalAmountStaked[tokenAddress] = totalAmountStaked[tokenAddress].sub(depositBalances[onBehalfOf][tokenAddress]);\n\n\n\n\n\n        depositBalances[onBehalfOf][tokenAddress] = 0;\n        require(numberTokensPlusRewardsForUserMinusCommission >0, \"For some reason numberTokensPlusRewardsForUserMinusCommission is zero\");\n\n        require(thisToken.transfer(onBehalfOf, numberTokensPlusRewardsForUserMinusCommission), \"You dont have enough tokens inside this contract to withdraw from deposits\");\n        if(numberTokensPlusRewardsForUserMinusCommission >0){\n            thisToken.transfer(owner, commissionForDAO1);\n        }\n\n\n        uint256 remainingBalance = thisToken.balanceOf(address(this));\n        if(remainingBalance>0){\n            stake(remainingBalance, address(this), tokenAddress);\n        }\n\n\n        emit Withdrawal(onBehalfOf, amount, tokenAddress);\n        return true;\n\n   }\n\n\n   function calculateCommission(uint256 amount) view public returns(uint256){\n     uint256 commissionForDAO = (amount.mul(1000).mul(commission)).div(10000000);\n     return commissionForDAO;\n   }\n\n   function changeOwner(address payable newOwner) onlyOwner public returns (bool){\n     owner = newOwner;\n     return true;\n   }\n\n\n   function getStakedBalance(address _owner, address tokenAddress) public view returns(uint256){\n\n       StakingInterface staker  = StakingInterface(tokenToFarmMapping[tokenAddress]);\n       return staker.balanceOf(_owner);\n   }\n\n\n\n  function adminEmergencyWithdrawTokens(address token, uint amount, address payable destination) public onlyOwner returns(bool) {\n\n\n\n      if (address(token) == ETH_TOKEN_ADDRESS) {\n          destination.transfer(amount);\n      }\n      else {\n          ERC20 tokenToken = ERC20(token);\n          require(tokenToken.transfer(destination, amount));\n      }\n\n\n\n\n      return true;\n  }\n\n\n\n function kill() virtual public onlyOwner {\n\n         selfdestruct(owner);\n\n }\n\n\n    event Deposit(address indexed user, uint256 amount, address token);\n    event Withdrawal(address indexed user, uint256 amount, address token);\n\n\n\n\n}",
        "function": "deposit(address,uint256,address)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/PeckShield-Plexus/PlexusContracts-f7e8196a3881faee80369330f6844a7f38d65b65/contracts/tier2Farm.sol",
        "vulnerability": "External Call To User-Supplied Address (SWC 107)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract Tier2FarmController {\n\n  using SafeMath\n    for uint256;\n\n\n  address payable public owner;\n  address public platformToken = 0xa0246c9032bC3A600820415aE600c6388619A14D;\n  address public tokenStakingContract = 0x25550Cccbd68533Fa04bFD3e3AC4D09f9e00Fc50;\n  address ETH_TOKEN_ADDRESS  = address(0x0);\n  mapping (string => address) public stakingContracts;\n  mapping (address => address) public tokenToFarmMapping;\n  mapping (string => address) public stakingContractsStakingToken;\n  mapping (address => mapping (address => uint256)) public depositBalances;\n  uint256 public commission  = 400; // Default is 4 percent\n\n\n  string public farmName = 'Harvest.Finance';\n  mapping (address => uint256) public totalAmountStaked;\n\n  modifier onlyOwner {\n         require(\n             msg.sender == owner,\n             \"Only owner can call this function.\"\n         );\n         _;\n }\n\n\n\n\n\n  constructor() public payable {\n        stakingContracts[\"FARM\"] = 0x25550Cccbd68533Fa04bFD3e3AC4D09f9e00Fc50;\n        stakingContractsStakingToken [\"FARM\"] = 0xa0246c9032bC3A600820415aE600c6388619A14D;\n        tokenToFarmMapping[stakingContractsStakingToken [\"FARM\"]] =  stakingContracts[\"FARM\"];\n        owner= msg.sender;\n\n  }\n\n\n  fallback() external payable {\n\n\n  }\n\n\n\n  function addOrEditStakingContract(string memory name, address stakingAddress, address stakingToken ) public onlyOwner returns (bool){\n\n    stakingContracts[name] = stakingAddress;\n    stakingContractsStakingToken[name] = stakingToken;\n    tokenToFarmMapping[stakingToken] = stakingAddress;\n    return true;\n\n  }\n\n  function updateCommission(uint amount) public onlyOwner returns(bool){\n      commission = amount;\n      return true;\n  }\n\n  function deposit(address tokenAddress, uint256 amount, address onBehalfOf) payable onlyOwner public returns (bool){\n\n\n       if(tokenAddress == 0x0000000000000000000000000000000000000000){\n\n            depositBalances[onBehalfOf][tokenAddress] = depositBalances[onBehalfOf][tokenAddress]  + msg.value;\n\n             stake(amount, onBehalfOf, tokenAddress );\n             totalAmountStaked[tokenAddress] = totalAmountStaked[tokenAddress].add(amount);\n             emit Deposit(onBehalfOf, amount, tokenAddress);\n            return true;\n\n        }\n\n        ERC20 thisToken = ERC20(tokenAddress);\n        require(thisToken.transferFrom(msg.sender, address(this), amount), \"Not enough tokens to transferFrom or no approval\");\n\n        depositBalances[onBehalfOf][tokenAddress] = depositBalances[onBehalfOf][tokenAddress]  + amount;\n\n        uint256 approvedAmount = thisToken.allowance(address(this), tokenToFarmMapping[tokenAddress]);\n        if(approvedAmount < amount  ){\n            thisToken.approve(tokenToFarmMapping[tokenAddress], amount.mul(10000000));\n        }\n        stake(amount, onBehalfOf, tokenAddress );\n\n        totalAmountStaked[tokenAddress] = totalAmountStaked[tokenAddress].add(amount);\n\n        emit Deposit(onBehalfOf, amount, tokenAddress);\n        return true;\n   }\n\n   function stake(uint256 amount, address onBehalfOf, address tokenAddress) internal returns(bool){\n\n      StakingInterface staker  = StakingInterface(tokenToFarmMapping[tokenAddress]);\n      staker.stake(amount);\n      return true;\n\n   }\n\n   function unstake(uint256 amount, address onBehalfOf, address tokenAddress) internal returns(bool){\n      StakingInterface staker  =  StakingInterface(tokenToFarmMapping[tokenAddress]);\n      staker.exit();\n      return true;\n\n   }\n\n\n   function getStakedPoolBalanceByUser(address _owner, address tokenAddress) public view returns(uint256){\n        StakingInterface staker  = StakingInterface(tokenToFarmMapping[tokenAddress]);\n\n        uint256 numberTokens = staker.balanceOf(address(this));\n\n        uint256 usersBalancePercentage = (depositBalances[_owner][tokenAddress].mul(1000000)).div(totalAmountStaked[tokenAddress]);\n        uint256 numberTokensPlusRewardsForUser= (numberTokens.mul(1000).mul(usersBalancePercentage)).div(1000000000);\n\n\n        return numberTokensPlusRewardsForUser;\n\n    }\n\n\n  function withdraw(address tokenAddress, uint256 amount, address payable onBehalfOf) onlyOwner payable public returns(bool){\n\n      ERC20 thisToken = ERC20(tokenAddress);\n      //uint256 numberTokensPreWithdrawal = getStakedBalance(address(this), tokenAddress);\n\n        if(tokenAddress == 0x0000000000000000000000000000000000000000){\n            require(depositBalances[msg.sender][tokenAddress] >= amount, \"You didnt deposit enough eth\");\n\n            totalAmountStaked[tokenAddress] = totalAmountStaked[tokenAddress].sub(depositBalances[onBehalfOf][tokenAddress]);\n            depositBalances[onBehalfOf][tokenAddress] = depositBalances[onBehalfOf][tokenAddress]  - amount;\n            onBehalfOf.send(amount);\n            return true;\n\n        }\n\n\n        require(depositBalances[onBehalfOf][tokenAddress] > 0, \"You dont have any tokens deposited\");\n\n\n\n        //uint256 numberTokensPostWithdrawal = thisToken.balanceOf(address(this));\n\n        //uint256 usersBalancePercentage = depositBalances[onBehalfOf][tokenAddress].div(totalAmountStaked[tokenAddress]);\n\n        uint256 numberTokensPlusRewardsForUser1 = getStakedPoolBalanceByUser(onBehalfOf, tokenAddress);\n        uint256 commissionForDAO1 = calculateCommission(numberTokensPlusRewardsForUser1);\n        uint256 numberTokensPlusRewardsForUserMinusCommission = numberTokensPlusRewardsForUser1-commissionForDAO1;\n\n        unstake(amount, onBehalfOf, tokenAddress);\n\n        //staking platforms only withdraw all for the most part, and for security sticking to this\n        totalAmountStaked[tokenAddress] = totalAmountStaked[tokenAddress].sub(depositBalances[onBehalfOf][tokenAddress]);\n\n\n\n\n\n        depositBalances[onBehalfOf][tokenAddress] = 0;\n        require(numberTokensPlusRewardsForUserMinusCommission >0, \"For some reason numberTokensPlusRewardsForUserMinusCommission is zero\");\n\n        require(thisToken.transfer(onBehalfOf, numberTokensPlusRewardsForUserMinusCommission), \"You dont have enough tokens inside this contract to withdraw from deposits\");\n        if(numberTokensPlusRewardsForUserMinusCommission >0){\n            thisToken.transfer(owner, commissionForDAO1);\n        }\n\n\n        uint256 remainingBalance = thisToken.balanceOf(address(this));\n        if(remainingBalance>0){\n            stake(remainingBalance, address(this), tokenAddress);\n        }\n\n\n        emit Withdrawal(onBehalfOf, amount, tokenAddress);\n        return true;\n\n   }\n\n\n   function calculateCommission(uint256 amount) view public returns(uint256){\n     uint256 commissionForDAO = (amount.mul(1000).mul(commission)).div(10000000);\n     return commissionForDAO;\n   }\n\n   function changeOwner(address payable newOwner) onlyOwner public returns (bool){\n     owner = newOwner;\n     return true;\n   }\n\n\n   function getStakedBalance(address _owner, address tokenAddress) public view returns(uint256){\n\n       StakingInterface staker  = StakingInterface(tokenToFarmMapping[tokenAddress]);\n       return staker.balanceOf(_owner);\n   }\n\n\n\n  function adminEmergencyWithdrawTokens(address token, uint amount, address payable destination) public onlyOwner returns(bool) {\n\n\n\n      if (address(token) == ETH_TOKEN_ADDRESS) {\n          destination.transfer(amount);\n      }\n      else {\n          ERC20 tokenToken = ERC20(token);\n          require(tokenToken.transfer(destination, amount));\n      }\n\n\n\n\n      return true;\n  }\n\n\n\n function kill() virtual public onlyOwner {\n\n         selfdestruct(owner);\n\n }\n\n\n    event Deposit(address indexed user, uint256 amount, address token);\n    event Withdrawal(address indexed user, uint256 amount, address token);\n\n\n\n\n}",
        "function": "deposit(address,uint256,address)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/PeckShield-Plexus/PlexusContracts-f7e8196a3881faee80369330f6844a7f38d65b65/contracts/tier2Farm.sol",
        "vulnerability": "State access after external call (SWC 107)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract Tier2FarmController {\n\n  using SafeMath\n    for uint256;\n\n\n  address payable public owner;\n  address public platformToken = 0xa0246c9032bC3A600820415aE600c6388619A14D;\n  address public tokenStakingContract = 0x25550Cccbd68533Fa04bFD3e3AC4D09f9e00Fc50;\n  address ETH_TOKEN_ADDRESS  = address(0x0);\n  mapping (string => address) public stakingContracts;\n  mapping (address => address) public tokenToFarmMapping;\n  mapping (string => address) public stakingContractsStakingToken;\n  mapping (address => mapping (address => uint256)) public depositBalances;\n  uint256 public commission  = 400; // Default is 4 percent\n\n\n  string public farmName = 'Harvest.Finance';\n  mapping (address => uint256) public totalAmountStaked;\n\n  modifier onlyOwner {\n         require(\n             msg.sender == owner,\n             \"Only owner can call this function.\"\n         );\n         _;\n }\n\n\n\n\n\n  constructor() public payable {\n        stakingContracts[\"FARM\"] = 0x25550Cccbd68533Fa04bFD3e3AC4D09f9e00Fc50;\n        stakingContractsStakingToken [\"FARM\"] = 0xa0246c9032bC3A600820415aE600c6388619A14D;\n        tokenToFarmMapping[stakingContractsStakingToken [\"FARM\"]] =  stakingContracts[\"FARM\"];\n        owner= msg.sender;\n\n  }\n\n\n  fallback() external payable {\n\n\n  }\n\n\n\n  function addOrEditStakingContract(string memory name, address stakingAddress, address stakingToken ) public onlyOwner returns (bool){\n\n    stakingContracts[name] = stakingAddress;\n    stakingContractsStakingToken[name] = stakingToken;\n    tokenToFarmMapping[stakingToken] = stakingAddress;\n    return true;\n\n  }\n\n  function updateCommission(uint amount) public onlyOwner returns(bool){\n      commission = amount;\n      return true;\n  }\n\n  function deposit(address tokenAddress, uint256 amount, address onBehalfOf) payable onlyOwner public returns (bool){\n\n\n       if(tokenAddress == 0x0000000000000000000000000000000000000000){\n\n            depositBalances[onBehalfOf][tokenAddress] = depositBalances[onBehalfOf][tokenAddress]  + msg.value;\n\n             stake(amount, onBehalfOf, tokenAddress );\n             totalAmountStaked[tokenAddress] = totalAmountStaked[tokenAddress].add(amount);\n             emit Deposit(onBehalfOf, amount, tokenAddress);\n            return true;\n\n        }\n\n        ERC20 thisToken = ERC20(tokenAddress);\n        require(thisToken.transferFrom(msg.sender, address(this), amount), \"Not enough tokens to transferFrom or no approval\");\n\n        depositBalances[onBehalfOf][tokenAddress] = depositBalances[onBehalfOf][tokenAddress]  + amount;\n\n        uint256 approvedAmount = thisToken.allowance(address(this), tokenToFarmMapping[tokenAddress]);\n        if(approvedAmount < amount  ){\n            thisToken.approve(tokenToFarmMapping[tokenAddress], amount.mul(10000000));\n        }\n        stake(amount, onBehalfOf, tokenAddress );\n\n        totalAmountStaked[tokenAddress] = totalAmountStaked[tokenAddress].add(amount);\n\n        emit Deposit(onBehalfOf, amount, tokenAddress);\n        return true;\n   }\n\n   function stake(uint256 amount, address onBehalfOf, address tokenAddress) internal returns(bool){\n\n      StakingInterface staker  = StakingInterface(tokenToFarmMapping[tokenAddress]);\n      staker.stake(amount);\n      return true;\n\n   }\n\n   function unstake(uint256 amount, address onBehalfOf, address tokenAddress) internal returns(bool){\n      StakingInterface staker  =  StakingInterface(tokenToFarmMapping[tokenAddress]);\n      staker.exit();\n      return true;\n\n   }\n\n\n   function getStakedPoolBalanceByUser(address _owner, address tokenAddress) public view returns(uint256){\n        StakingInterface staker  = StakingInterface(tokenToFarmMapping[tokenAddress]);\n\n        uint256 numberTokens = staker.balanceOf(address(this));\n\n        uint256 usersBalancePercentage = (depositBalances[_owner][tokenAddress].mul(1000000)).div(totalAmountStaked[tokenAddress]);\n        uint256 numberTokensPlusRewardsForUser= (numberTokens.mul(1000).mul(usersBalancePercentage)).div(1000000000);\n\n\n        return numberTokensPlusRewardsForUser;\n\n    }\n\n\n  function withdraw(address tokenAddress, uint256 amount, address payable onBehalfOf) onlyOwner payable public returns(bool){\n\n      ERC20 thisToken = ERC20(tokenAddress);\n      //uint256 numberTokensPreWithdrawal = getStakedBalance(address(this), tokenAddress);\n\n        if(tokenAddress == 0x0000000000000000000000000000000000000000){\n            require(depositBalances[msg.sender][tokenAddress] >= amount, \"You didnt deposit enough eth\");\n\n            totalAmountStaked[tokenAddress] = totalAmountStaked[tokenAddress].sub(depositBalances[onBehalfOf][tokenAddress]);\n            depositBalances[onBehalfOf][tokenAddress] = depositBalances[onBehalfOf][tokenAddress]  - amount;\n            onBehalfOf.send(amount);\n            return true;\n\n        }\n\n\n        require(depositBalances[onBehalfOf][tokenAddress] > 0, \"You dont have any tokens deposited\");\n\n\n\n        //uint256 numberTokensPostWithdrawal = thisToken.balanceOf(address(this));\n\n        //uint256 usersBalancePercentage = depositBalances[onBehalfOf][tokenAddress].div(totalAmountStaked[tokenAddress]);\n\n        uint256 numberTokensPlusRewardsForUser1 = getStakedPoolBalanceByUser(onBehalfOf, tokenAddress);\n        uint256 commissionForDAO1 = calculateCommission(numberTokensPlusRewardsForUser1);\n        uint256 numberTokensPlusRewardsForUserMinusCommission = numberTokensPlusRewardsForUser1-commissionForDAO1;\n\n        unstake(amount, onBehalfOf, tokenAddress);\n\n        //staking platforms only withdraw all for the most part, and for security sticking to this\n        totalAmountStaked[tokenAddress] = totalAmountStaked[tokenAddress].sub(depositBalances[onBehalfOf][tokenAddress]);\n\n\n\n\n\n        depositBalances[onBehalfOf][tokenAddress] = 0;\n        require(numberTokensPlusRewardsForUserMinusCommission >0, \"For some reason numberTokensPlusRewardsForUserMinusCommission is zero\");\n\n        require(thisToken.transfer(onBehalfOf, numberTokensPlusRewardsForUserMinusCommission), \"You dont have enough tokens inside this contract to withdraw from deposits\");\n        if(numberTokensPlusRewardsForUserMinusCommission >0){\n            thisToken.transfer(owner, commissionForDAO1);\n        }\n\n\n        uint256 remainingBalance = thisToken.balanceOf(address(this));\n        if(remainingBalance>0){\n            stake(remainingBalance, address(this), tokenAddress);\n        }\n\n\n        emit Withdrawal(onBehalfOf, amount, tokenAddress);\n        return true;\n\n   }\n\n\n   function calculateCommission(uint256 amount) view public returns(uint256){\n     uint256 commissionForDAO = (amount.mul(1000).mul(commission)).div(10000000);\n     return commissionForDAO;\n   }\n\n   function changeOwner(address payable newOwner) onlyOwner public returns (bool){\n     owner = newOwner;\n     return true;\n   }\n\n\n   function getStakedBalance(address _owner, address tokenAddress) public view returns(uint256){\n\n       StakingInterface staker  = StakingInterface(tokenToFarmMapping[tokenAddress]);\n       return staker.balanceOf(_owner);\n   }\n\n\n\n  function adminEmergencyWithdrawTokens(address token, uint amount, address payable destination) public onlyOwner returns(bool) {\n\n\n\n      if (address(token) == ETH_TOKEN_ADDRESS) {\n          destination.transfer(amount);\n      }\n      else {\n          ERC20 tokenToken = ERC20(token);\n          require(tokenToken.transfer(destination, amount));\n      }\n\n\n\n\n      return true;\n  }\n\n\n\n function kill() virtual public onlyOwner {\n\n         selfdestruct(owner);\n\n }\n\n\n    event Deposit(address indexed user, uint256 amount, address token);\n    event Withdrawal(address indexed user, uint256 amount, address token);\n\n\n\n\n}",
        "function": "deposit(address,uint256,address)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/PeckShield-Plexus/PlexusContracts-f7e8196a3881faee80369330f6844a7f38d65b65/contracts/tier2Farm.sol",
        "vulnerability": "State access after external call (SWC 107)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract Tier2FarmController {\n\n  using SafeMath\n    for uint256;\n\n\n  address payable public owner;\n  address public platformToken = 0xa0246c9032bC3A600820415aE600c6388619A14D;\n  address public tokenStakingContract = 0x25550Cccbd68533Fa04bFD3e3AC4D09f9e00Fc50;\n  address ETH_TOKEN_ADDRESS  = address(0x0);\n  mapping (string => address) public stakingContracts;\n  mapping (address => address) public tokenToFarmMapping;\n  mapping (string => address) public stakingContractsStakingToken;\n  mapping (address => mapping (address => uint256)) public depositBalances;\n  uint256 public commission  = 400; // Default is 4 percent\n\n\n  string public farmName = 'Harvest.Finance';\n  mapping (address => uint256) public totalAmountStaked;\n\n  modifier onlyOwner {\n         require(\n             msg.sender == owner,\n             \"Only owner can call this function.\"\n         );\n         _;\n }\n\n\n\n\n\n  constructor() public payable {\n        stakingContracts[\"FARM\"] = 0x25550Cccbd68533Fa04bFD3e3AC4D09f9e00Fc50;\n        stakingContractsStakingToken [\"FARM\"] = 0xa0246c9032bC3A600820415aE600c6388619A14D;\n        tokenToFarmMapping[stakingContractsStakingToken [\"FARM\"]] =  stakingContracts[\"FARM\"];\n        owner= msg.sender;\n\n  }\n\n\n  fallback() external payable {\n\n\n  }\n\n\n\n  function addOrEditStakingContract(string memory name, address stakingAddress, address stakingToken ) public onlyOwner returns (bool){\n\n    stakingContracts[name] = stakingAddress;\n    stakingContractsStakingToken[name] = stakingToken;\n    tokenToFarmMapping[stakingToken] = stakingAddress;\n    return true;\n\n  }\n\n  function updateCommission(uint amount) public onlyOwner returns(bool){\n      commission = amount;\n      return true;\n  }\n\n  function deposit(address tokenAddress, uint256 amount, address onBehalfOf) payable onlyOwner public returns (bool){\n\n\n       if(tokenAddress == 0x0000000000000000000000000000000000000000){\n\n            depositBalances[onBehalfOf][tokenAddress] = depositBalances[onBehalfOf][tokenAddress]  + msg.value;\n\n             stake(amount, onBehalfOf, tokenAddress );\n             totalAmountStaked[tokenAddress] = totalAmountStaked[tokenAddress].add(amount);\n             emit Deposit(onBehalfOf, amount, tokenAddress);\n            return true;\n\n        }\n\n        ERC20 thisToken = ERC20(tokenAddress);\n        require(thisToken.transferFrom(msg.sender, address(this), amount), \"Not enough tokens to transferFrom or no approval\");\n\n        depositBalances[onBehalfOf][tokenAddress] = depositBalances[onBehalfOf][tokenAddress]  + amount;\n\n        uint256 approvedAmount = thisToken.allowance(address(this), tokenToFarmMapping[tokenAddress]);\n        if(approvedAmount < amount  ){\n            thisToken.approve(tokenToFarmMapping[tokenAddress], amount.mul(10000000));\n        }\n        stake(amount, onBehalfOf, tokenAddress );\n\n        totalAmountStaked[tokenAddress] = totalAmountStaked[tokenAddress].add(amount);\n\n        emit Deposit(onBehalfOf, amount, tokenAddress);\n        return true;\n   }\n\n   function stake(uint256 amount, address onBehalfOf, address tokenAddress) internal returns(bool){\n\n      StakingInterface staker  = StakingInterface(tokenToFarmMapping[tokenAddress]);\n      staker.stake(amount);\n      return true;\n\n   }\n\n   function unstake(uint256 amount, address onBehalfOf, address tokenAddress) internal returns(bool){\n      StakingInterface staker  =  StakingInterface(tokenToFarmMapping[tokenAddress]);\n      staker.exit();\n      return true;\n\n   }\n\n\n   function getStakedPoolBalanceByUser(address _owner, address tokenAddress) public view returns(uint256){\n        StakingInterface staker  = StakingInterface(tokenToFarmMapping[tokenAddress]);\n\n        uint256 numberTokens = staker.balanceOf(address(this));\n\n        uint256 usersBalancePercentage = (depositBalances[_owner][tokenAddress].mul(1000000)).div(totalAmountStaked[tokenAddress]);\n        uint256 numberTokensPlusRewardsForUser= (numberTokens.mul(1000).mul(usersBalancePercentage)).div(1000000000);\n\n\n        return numberTokensPlusRewardsForUser;\n\n    }\n\n\n  function withdraw(address tokenAddress, uint256 amount, address payable onBehalfOf) onlyOwner payable public returns(bool){\n\n      ERC20 thisToken = ERC20(tokenAddress);\n      //uint256 numberTokensPreWithdrawal = getStakedBalance(address(this), tokenAddress);\n\n        if(tokenAddress == 0x0000000000000000000000000000000000000000){\n            require(depositBalances[msg.sender][tokenAddress] >= amount, \"You didnt deposit enough eth\");\n\n            totalAmountStaked[tokenAddress] = totalAmountStaked[tokenAddress].sub(depositBalances[onBehalfOf][tokenAddress]);\n            depositBalances[onBehalfOf][tokenAddress] = depositBalances[onBehalfOf][tokenAddress]  - amount;\n            onBehalfOf.send(amount);\n            return true;\n\n        }\n\n\n        require(depositBalances[onBehalfOf][tokenAddress] > 0, \"You dont have any tokens deposited\");\n\n\n\n        //uint256 numberTokensPostWithdrawal = thisToken.balanceOf(address(this));\n\n        //uint256 usersBalancePercentage = depositBalances[onBehalfOf][tokenAddress].div(totalAmountStaked[tokenAddress]);\n\n        uint256 numberTokensPlusRewardsForUser1 = getStakedPoolBalanceByUser(onBehalfOf, tokenAddress);\n        uint256 commissionForDAO1 = calculateCommission(numberTokensPlusRewardsForUser1);\n        uint256 numberTokensPlusRewardsForUserMinusCommission = numberTokensPlusRewardsForUser1-commissionForDAO1;\n\n        unstake(amount, onBehalfOf, tokenAddress);\n\n        //staking platforms only withdraw all for the most part, and for security sticking to this\n        totalAmountStaked[tokenAddress] = totalAmountStaked[tokenAddress].sub(depositBalances[onBehalfOf][tokenAddress]);\n\n\n\n\n\n        depositBalances[onBehalfOf][tokenAddress] = 0;\n        require(numberTokensPlusRewardsForUserMinusCommission >0, \"For some reason numberTokensPlusRewardsForUserMinusCommission is zero\");\n\n        require(thisToken.transfer(onBehalfOf, numberTokensPlusRewardsForUserMinusCommission), \"You dont have enough tokens inside this contract to withdraw from deposits\");\n        if(numberTokensPlusRewardsForUserMinusCommission >0){\n            thisToken.transfer(owner, commissionForDAO1);\n        }\n\n\n        uint256 remainingBalance = thisToken.balanceOf(address(this));\n        if(remainingBalance>0){\n            stake(remainingBalance, address(this), tokenAddress);\n        }\n\n\n        emit Withdrawal(onBehalfOf, amount, tokenAddress);\n        return true;\n\n   }\n\n\n   function calculateCommission(uint256 amount) view public returns(uint256){\n     uint256 commissionForDAO = (amount.mul(1000).mul(commission)).div(10000000);\n     return commissionForDAO;\n   }\n\n   function changeOwner(address payable newOwner) onlyOwner public returns (bool){\n     owner = newOwner;\n     return true;\n   }\n\n\n   function getStakedBalance(address _owner, address tokenAddress) public view returns(uint256){\n\n       StakingInterface staker  = StakingInterface(tokenToFarmMapping[tokenAddress]);\n       return staker.balanceOf(_owner);\n   }\n\n\n\n  function adminEmergencyWithdrawTokens(address token, uint amount, address payable destination) public onlyOwner returns(bool) {\n\n\n\n      if (address(token) == ETH_TOKEN_ADDRESS) {\n          destination.transfer(amount);\n      }\n      else {\n          ERC20 tokenToken = ERC20(token);\n          require(tokenToken.transfer(destination, amount));\n      }\n\n\n\n\n      return true;\n  }\n\n\n\n function kill() virtual public onlyOwner {\n\n         selfdestruct(owner);\n\n }\n\n\n    event Deposit(address indexed user, uint256 amount, address token);\n    event Withdrawal(address indexed user, uint256 amount, address token);\n\n\n\n\n}",
        "function": "deposit(address,uint256,address)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/PeckShield-Plexus/PlexusContracts-f7e8196a3881faee80369330f6844a7f38d65b65/contracts/tier2Farm.sol",
        "vulnerability": "State access after external call (SWC 107)",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract Tier2FarmController {\n\n  using SafeMath\n    for uint256;\n\n\n  address payable public owner;\n  address public platformToken = 0xa0246c9032bC3A600820415aE600c6388619A14D;\n  address public tokenStakingContract = 0x25550Cccbd68533Fa04bFD3e3AC4D09f9e00Fc50;\n  address ETH_TOKEN_ADDRESS  = address(0x0);\n  mapping (string => address) public stakingContracts;\n  mapping (address => address) public tokenToFarmMapping;\n  mapping (string => address) public stakingContractsStakingToken;\n  mapping (address => mapping (address => uint256)) public depositBalances;\n  uint256 public commission  = 400; // Default is 4 percent\n\n\n  string public farmName = 'Harvest.Finance';\n  mapping (address => uint256) public totalAmountStaked;\n\n  modifier onlyOwner {\n         require(\n             msg.sender == owner,\n             \"Only owner can call this function.\"\n         );\n         _;\n }\n\n\n\n\n\n  constructor() public payable {\n        stakingContracts[\"FARM\"] = 0x25550Cccbd68533Fa04bFD3e3AC4D09f9e00Fc50;\n        stakingContractsStakingToken [\"FARM\"] = 0xa0246c9032bC3A600820415aE600c6388619A14D;\n        tokenToFarmMapping[stakingContractsStakingToken [\"FARM\"]] =  stakingContracts[\"FARM\"];\n        owner= msg.sender;\n\n  }\n\n\n  fallback() external payable {\n\n\n  }\n\n\n\n  function addOrEditStakingContract(string memory name, address stakingAddress, address stakingToken ) public onlyOwner returns (bool){\n\n    stakingContracts[name] = stakingAddress;\n    stakingContractsStakingToken[name] = stakingToken;\n    tokenToFarmMapping[stakingToken] = stakingAddress;\n    return true;\n\n  }\n\n  function updateCommission(uint amount) public onlyOwner returns(bool){\n      commission = amount;\n      return true;\n  }\n\n  function deposit(address tokenAddress, uint256 amount, address onBehalfOf) payable onlyOwner public returns (bool){\n\n\n       if(tokenAddress == 0x0000000000000000000000000000000000000000){\n\n            depositBalances[onBehalfOf][tokenAddress] = depositBalances[onBehalfOf][tokenAddress]  + msg.value;\n\n             stake(amount, onBehalfOf, tokenAddress );\n             totalAmountStaked[tokenAddress] = totalAmountStaked[tokenAddress].add(amount);\n             emit Deposit(onBehalfOf, amount, tokenAddress);\n            return true;\n\n        }\n\n        ERC20 thisToken = ERC20(tokenAddress);\n        require(thisToken.transferFrom(msg.sender, address(this), amount), \"Not enough tokens to transferFrom or no approval\");\n\n        depositBalances[onBehalfOf][tokenAddress] = depositBalances[onBehalfOf][tokenAddress]  + amount;\n\n        uint256 approvedAmount = thisToken.allowance(address(this), tokenToFarmMapping[tokenAddress]);\n        if(approvedAmount < amount  ){\n            thisToken.approve(tokenToFarmMapping[tokenAddress], amount.mul(10000000));\n        }\n        stake(amount, onBehalfOf, tokenAddress );\n\n        totalAmountStaked[tokenAddress] = totalAmountStaked[tokenAddress].add(amount);\n\n        emit Deposit(onBehalfOf, amount, tokenAddress);\n        return true;\n   }\n\n   function stake(uint256 amount, address onBehalfOf, address tokenAddress) internal returns(bool){\n\n      StakingInterface staker  = StakingInterface(tokenToFarmMapping[tokenAddress]);\n      staker.stake(amount);\n      return true;\n\n   }\n\n   function unstake(uint256 amount, address onBehalfOf, address tokenAddress) internal returns(bool){\n      StakingInterface staker  =  StakingInterface(tokenToFarmMapping[tokenAddress]);\n      staker.exit();\n      return true;\n\n   }\n\n\n   function getStakedPoolBalanceByUser(address _owner, address tokenAddress) public view returns(uint256){\n        StakingInterface staker  = StakingInterface(tokenToFarmMapping[tokenAddress]);\n\n        uint256 numberTokens = staker.balanceOf(address(this));\n\n        uint256 usersBalancePercentage = (depositBalances[_owner][tokenAddress].mul(1000000)).div(totalAmountStaked[tokenAddress]);\n        uint256 numberTokensPlusRewardsForUser= (numberTokens.mul(1000).mul(usersBalancePercentage)).div(1000000000);\n\n\n        return numberTokensPlusRewardsForUser;\n\n    }\n\n\n  function withdraw(address tokenAddress, uint256 amount, address payable onBehalfOf) onlyOwner payable public returns(bool){\n\n      ERC20 thisToken = ERC20(tokenAddress);\n      //uint256 numberTokensPreWithdrawal = getStakedBalance(address(this), tokenAddress);\n\n        if(tokenAddress == 0x0000000000000000000000000000000000000000){\n            require(depositBalances[msg.sender][tokenAddress] >= amount, \"You didnt deposit enough eth\");\n\n            totalAmountStaked[tokenAddress] = totalAmountStaked[tokenAddress].sub(depositBalances[onBehalfOf][tokenAddress]);\n            depositBalances[onBehalfOf][tokenAddress] = depositBalances[onBehalfOf][tokenAddress]  - amount;\n            onBehalfOf.send(amount);\n            return true;\n\n        }\n\n\n        require(depositBalances[onBehalfOf][tokenAddress] > 0, \"You dont have any tokens deposited\");\n\n\n\n        //uint256 numberTokensPostWithdrawal = thisToken.balanceOf(address(this));\n\n        //uint256 usersBalancePercentage = depositBalances[onBehalfOf][tokenAddress].div(totalAmountStaked[tokenAddress]);\n\n        uint256 numberTokensPlusRewardsForUser1 = getStakedPoolBalanceByUser(onBehalfOf, tokenAddress);\n        uint256 commissionForDAO1 = calculateCommission(numberTokensPlusRewardsForUser1);\n        uint256 numberTokensPlusRewardsForUserMinusCommission = numberTokensPlusRewardsForUser1-commissionForDAO1;\n\n        unstake(amount, onBehalfOf, tokenAddress);\n\n        //staking platforms only withdraw all for the most part, and for security sticking to this\n        totalAmountStaked[tokenAddress] = totalAmountStaked[tokenAddress].sub(depositBalances[onBehalfOf][tokenAddress]);\n\n\n\n\n\n        depositBalances[onBehalfOf][tokenAddress] = 0;\n        require(numberTokensPlusRewardsForUserMinusCommission >0, \"For some reason numberTokensPlusRewardsForUserMinusCommission is zero\");\n\n        require(thisToken.transfer(onBehalfOf, numberTokensPlusRewardsForUserMinusCommission), \"You dont have enough tokens inside this contract to withdraw from deposits\");\n        if(numberTokensPlusRewardsForUserMinusCommission >0){\n            thisToken.transfer(owner, commissionForDAO1);\n        }\n\n\n        uint256 remainingBalance = thisToken.balanceOf(address(this));\n        if(remainingBalance>0){\n            stake(remainingBalance, address(this), tokenAddress);\n        }\n\n\n        emit Withdrawal(onBehalfOf, amount, tokenAddress);\n        return true;\n\n   }\n\n\n   function calculateCommission(uint256 amount) view public returns(uint256){\n     uint256 commissionForDAO = (amount.mul(1000).mul(commission)).div(10000000);\n     return commissionForDAO;\n   }\n\n   function changeOwner(address payable newOwner) onlyOwner public returns (bool){\n     owner = newOwner;\n     return true;\n   }\n\n\n   function getStakedBalance(address _owner, address tokenAddress) public view returns(uint256){\n\n       StakingInterface staker  = StakingInterface(tokenToFarmMapping[tokenAddress]);\n       return staker.balanceOf(_owner);\n   }\n\n\n\n  function adminEmergencyWithdrawTokens(address token, uint amount, address payable destination) public onlyOwner returns(bool) {\n\n\n\n      if (address(token) == ETH_TOKEN_ADDRESS) {\n          destination.transfer(amount);\n      }\n      else {\n          ERC20 tokenToken = ERC20(token);\n          require(tokenToken.transfer(destination, amount));\n      }\n\n\n\n\n      return true;\n  }\n\n\n\n function kill() virtual public onlyOwner {\n\n         selfdestruct(owner);\n\n }\n\n\n    event Deposit(address indexed user, uint256 amount, address token);\n    event Withdrawal(address indexed user, uint256 amount, address token);\n\n\n\n\n}",
        "function": "deposit(address,uint256,address)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/PeckShield-Plexus/PlexusContracts-f7e8196a3881faee80369330f6844a7f38d65b65/contracts/tier2Farm.sol",
        "vulnerability": "State access after external call (SWC 107)",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract Tier2FarmController {\n\n  using SafeMath\n    for uint256;\n\n\n  address payable public owner;\n  address public platformToken = 0xa0246c9032bC3A600820415aE600c6388619A14D;\n  address public tokenStakingContract = 0x25550Cccbd68533Fa04bFD3e3AC4D09f9e00Fc50;\n  address ETH_TOKEN_ADDRESS  = address(0x0);\n  mapping (string => address) public stakingContracts;\n  mapping (address => address) public tokenToFarmMapping;\n  mapping (string => address) public stakingContractsStakingToken;\n  mapping (address => mapping (address => uint256)) public depositBalances;\n  uint256 public commission  = 400; // Default is 4 percent\n\n\n  string public farmName = 'Harvest.Finance';\n  mapping (address => uint256) public totalAmountStaked;\n\n  modifier onlyOwner {\n         require(\n             msg.sender == owner,\n             \"Only owner can call this function.\"\n         );\n         _;\n }\n\n\n\n\n\n  constructor() public payable {\n        stakingContracts[\"FARM\"] = 0x25550Cccbd68533Fa04bFD3e3AC4D09f9e00Fc50;\n        stakingContractsStakingToken [\"FARM\"] = 0xa0246c9032bC3A600820415aE600c6388619A14D;\n        tokenToFarmMapping[stakingContractsStakingToken [\"FARM\"]] =  stakingContracts[\"FARM\"];\n        owner= msg.sender;\n\n  }\n\n\n  fallback() external payable {\n\n\n  }\n\n\n\n  function addOrEditStakingContract(string memory name, address stakingAddress, address stakingToken ) public onlyOwner returns (bool){\n\n    stakingContracts[name] = stakingAddress;\n    stakingContractsStakingToken[name] = stakingToken;\n    tokenToFarmMapping[stakingToken] = stakingAddress;\n    return true;\n\n  }\n\n  function updateCommission(uint amount) public onlyOwner returns(bool){\n      commission = amount;\n      return true;\n  }\n\n  function deposit(address tokenAddress, uint256 amount, address onBehalfOf) payable onlyOwner public returns (bool){\n\n\n       if(tokenAddress == 0x0000000000000000000000000000000000000000){\n\n            depositBalances[onBehalfOf][tokenAddress] = depositBalances[onBehalfOf][tokenAddress]  + msg.value;\n\n             stake(amount, onBehalfOf, tokenAddress );\n             totalAmountStaked[tokenAddress] = totalAmountStaked[tokenAddress].add(amount);\n             emit Deposit(onBehalfOf, amount, tokenAddress);\n            return true;\n\n        }\n\n        ERC20 thisToken = ERC20(tokenAddress);\n        require(thisToken.transferFrom(msg.sender, address(this), amount), \"Not enough tokens to transferFrom or no approval\");\n\n        depositBalances[onBehalfOf][tokenAddress] = depositBalances[onBehalfOf][tokenAddress]  + amount;\n\n        uint256 approvedAmount = thisToken.allowance(address(this), tokenToFarmMapping[tokenAddress]);\n        if(approvedAmount < amount  ){\n            thisToken.approve(tokenToFarmMapping[tokenAddress], amount.mul(10000000));\n        }\n        stake(amount, onBehalfOf, tokenAddress );\n\n        totalAmountStaked[tokenAddress] = totalAmountStaked[tokenAddress].add(amount);\n\n        emit Deposit(onBehalfOf, amount, tokenAddress);\n        return true;\n   }\n\n   function stake(uint256 amount, address onBehalfOf, address tokenAddress) internal returns(bool){\n\n      StakingInterface staker  = StakingInterface(tokenToFarmMapping[tokenAddress]);\n      staker.stake(amount);\n      return true;\n\n   }\n\n   function unstake(uint256 amount, address onBehalfOf, address tokenAddress) internal returns(bool){\n      StakingInterface staker  =  StakingInterface(tokenToFarmMapping[tokenAddress]);\n      staker.exit();\n      return true;\n\n   }\n\n\n   function getStakedPoolBalanceByUser(address _owner, address tokenAddress) public view returns(uint256){\n        StakingInterface staker  = StakingInterface(tokenToFarmMapping[tokenAddress]);\n\n        uint256 numberTokens = staker.balanceOf(address(this));\n\n        uint256 usersBalancePercentage = (depositBalances[_owner][tokenAddress].mul(1000000)).div(totalAmountStaked[tokenAddress]);\n        uint256 numberTokensPlusRewardsForUser= (numberTokens.mul(1000).mul(usersBalancePercentage)).div(1000000000);\n\n\n        return numberTokensPlusRewardsForUser;\n\n    }\n\n\n  function withdraw(address tokenAddress, uint256 amount, address payable onBehalfOf) onlyOwner payable public returns(bool){\n\n      ERC20 thisToken = ERC20(tokenAddress);\n      //uint256 numberTokensPreWithdrawal = getStakedBalance(address(this), tokenAddress);\n\n        if(tokenAddress == 0x0000000000000000000000000000000000000000){\n            require(depositBalances[msg.sender][tokenAddress] >= amount, \"You didnt deposit enough eth\");\n\n            totalAmountStaked[tokenAddress] = totalAmountStaked[tokenAddress].sub(depositBalances[onBehalfOf][tokenAddress]);\n            depositBalances[onBehalfOf][tokenAddress] = depositBalances[onBehalfOf][tokenAddress]  - amount;\n            onBehalfOf.send(amount);\n            return true;\n\n        }\n\n\n        require(depositBalances[onBehalfOf][tokenAddress] > 0, \"You dont have any tokens deposited\");\n\n\n\n        //uint256 numberTokensPostWithdrawal = thisToken.balanceOf(address(this));\n\n        //uint256 usersBalancePercentage = depositBalances[onBehalfOf][tokenAddress].div(totalAmountStaked[tokenAddress]);\n\n        uint256 numberTokensPlusRewardsForUser1 = getStakedPoolBalanceByUser(onBehalfOf, tokenAddress);\n        uint256 commissionForDAO1 = calculateCommission(numberTokensPlusRewardsForUser1);\n        uint256 numberTokensPlusRewardsForUserMinusCommission = numberTokensPlusRewardsForUser1-commissionForDAO1;\n\n        unstake(amount, onBehalfOf, tokenAddress);\n\n        //staking platforms only withdraw all for the most part, and for security sticking to this\n        totalAmountStaked[tokenAddress] = totalAmountStaked[tokenAddress].sub(depositBalances[onBehalfOf][tokenAddress]);\n\n\n\n\n\n        depositBalances[onBehalfOf][tokenAddress] = 0;\n        require(numberTokensPlusRewardsForUserMinusCommission >0, \"For some reason numberTokensPlusRewardsForUserMinusCommission is zero\");\n\n        require(thisToken.transfer(onBehalfOf, numberTokensPlusRewardsForUserMinusCommission), \"You dont have enough tokens inside this contract to withdraw from deposits\");\n        if(numberTokensPlusRewardsForUserMinusCommission >0){\n            thisToken.transfer(owner, commissionForDAO1);\n        }\n\n\n        uint256 remainingBalance = thisToken.balanceOf(address(this));\n        if(remainingBalance>0){\n            stake(remainingBalance, address(this), tokenAddress);\n        }\n\n\n        emit Withdrawal(onBehalfOf, amount, tokenAddress);\n        return true;\n\n   }\n\n\n   function calculateCommission(uint256 amount) view public returns(uint256){\n     uint256 commissionForDAO = (amount.mul(1000).mul(commission)).div(10000000);\n     return commissionForDAO;\n   }\n\n   function changeOwner(address payable newOwner) onlyOwner public returns (bool){\n     owner = newOwner;\n     return true;\n   }\n\n\n   function getStakedBalance(address _owner, address tokenAddress) public view returns(uint256){\n\n       StakingInterface staker  = StakingInterface(tokenToFarmMapping[tokenAddress]);\n       return staker.balanceOf(_owner);\n   }\n\n\n\n  function adminEmergencyWithdrawTokens(address token, uint amount, address payable destination) public onlyOwner returns(bool) {\n\n\n\n      if (address(token) == ETH_TOKEN_ADDRESS) {\n          destination.transfer(amount);\n      }\n      else {\n          ERC20 tokenToken = ERC20(token);\n          require(tokenToken.transfer(destination, amount));\n      }\n\n\n\n\n      return true;\n  }\n\n\n\n function kill() virtual public onlyOwner {\n\n         selfdestruct(owner);\n\n }\n\n\n    event Deposit(address indexed user, uint256 amount, address token);\n    event Withdrawal(address indexed user, uint256 amount, address token);\n\n\n\n\n}",
        "function": "deposit(address,uint256,address)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/PeckShield-Plexus/PlexusContracts-f7e8196a3881faee80369330f6844a7f38d65b65/contracts/tier2Farm.sol",
        "vulnerability": "State access after external call (SWC 107)",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract Tier2FarmController {\n\n  using SafeMath\n    for uint256;\n\n\n  address payable public owner;\n  address public platformToken = 0xa0246c9032bC3A600820415aE600c6388619A14D;\n  address public tokenStakingContract = 0x25550Cccbd68533Fa04bFD3e3AC4D09f9e00Fc50;\n  address ETH_TOKEN_ADDRESS  = address(0x0);\n  mapping (string => address) public stakingContracts;\n  mapping (address => address) public tokenToFarmMapping;\n  mapping (string => address) public stakingContractsStakingToken;\n  mapping (address => mapping (address => uint256)) public depositBalances;\n  uint256 public commission  = 400; // Default is 4 percent\n\n\n  string public farmName = 'Harvest.Finance';\n  mapping (address => uint256) public totalAmountStaked;\n\n  modifier onlyOwner {\n         require(\n             msg.sender == owner,\n             \"Only owner can call this function.\"\n         );\n         _;\n }\n\n\n\n\n\n  constructor() public payable {\n        stakingContracts[\"FARM\"] = 0x25550Cccbd68533Fa04bFD3e3AC4D09f9e00Fc50;\n        stakingContractsStakingToken [\"FARM\"] = 0xa0246c9032bC3A600820415aE600c6388619A14D;\n        tokenToFarmMapping[stakingContractsStakingToken [\"FARM\"]] =  stakingContracts[\"FARM\"];\n        owner= msg.sender;\n\n  }\n\n\n  fallback() external payable {\n\n\n  }\n\n\n\n  function addOrEditStakingContract(string memory name, address stakingAddress, address stakingToken ) public onlyOwner returns (bool){\n\n    stakingContracts[name] = stakingAddress;\n    stakingContractsStakingToken[name] = stakingToken;\n    tokenToFarmMapping[stakingToken] = stakingAddress;\n    return true;\n\n  }\n\n  function updateCommission(uint amount) public onlyOwner returns(bool){\n      commission = amount;\n      return true;\n  }\n\n  function deposit(address tokenAddress, uint256 amount, address onBehalfOf) payable onlyOwner public returns (bool){\n\n\n       if(tokenAddress == 0x0000000000000000000000000000000000000000){\n\n            depositBalances[onBehalfOf][tokenAddress] = depositBalances[onBehalfOf][tokenAddress]  + msg.value;\n\n             stake(amount, onBehalfOf, tokenAddress );\n             totalAmountStaked[tokenAddress] = totalAmountStaked[tokenAddress].add(amount);\n             emit Deposit(onBehalfOf, amount, tokenAddress);\n            return true;\n\n        }\n\n        ERC20 thisToken = ERC20(tokenAddress);\n        require(thisToken.transferFrom(msg.sender, address(this), amount), \"Not enough tokens to transferFrom or no approval\");\n\n        depositBalances[onBehalfOf][tokenAddress] = depositBalances[onBehalfOf][tokenAddress]  + amount;\n\n        uint256 approvedAmount = thisToken.allowance(address(this), tokenToFarmMapping[tokenAddress]);\n        if(approvedAmount < amount  ){\n            thisToken.approve(tokenToFarmMapping[tokenAddress], amount.mul(10000000));\n        }\n        stake(amount, onBehalfOf, tokenAddress );\n\n        totalAmountStaked[tokenAddress] = totalAmountStaked[tokenAddress].add(amount);\n\n        emit Deposit(onBehalfOf, amount, tokenAddress);\n        return true;\n   }\n\n   function stake(uint256 amount, address onBehalfOf, address tokenAddress) internal returns(bool){\n\n      StakingInterface staker  = StakingInterface(tokenToFarmMapping[tokenAddress]);\n      staker.stake(amount);\n      return true;\n\n   }\n\n   function unstake(uint256 amount, address onBehalfOf, address tokenAddress) internal returns(bool){\n      StakingInterface staker  =  StakingInterface(tokenToFarmMapping[tokenAddress]);\n      staker.exit();\n      return true;\n\n   }\n\n\n   function getStakedPoolBalanceByUser(address _owner, address tokenAddress) public view returns(uint256){\n        StakingInterface staker  = StakingInterface(tokenToFarmMapping[tokenAddress]);\n\n        uint256 numberTokens = staker.balanceOf(address(this));\n\n        uint256 usersBalancePercentage = (depositBalances[_owner][tokenAddress].mul(1000000)).div(totalAmountStaked[tokenAddress]);\n        uint256 numberTokensPlusRewardsForUser= (numberTokens.mul(1000).mul(usersBalancePercentage)).div(1000000000);\n\n\n        return numberTokensPlusRewardsForUser;\n\n    }\n\n\n  function withdraw(address tokenAddress, uint256 amount, address payable onBehalfOf) onlyOwner payable public returns(bool){\n\n      ERC20 thisToken = ERC20(tokenAddress);\n      //uint256 numberTokensPreWithdrawal = getStakedBalance(address(this), tokenAddress);\n\n        if(tokenAddress == 0x0000000000000000000000000000000000000000){\n            require(depositBalances[msg.sender][tokenAddress] >= amount, \"You didnt deposit enough eth\");\n\n            totalAmountStaked[tokenAddress] = totalAmountStaked[tokenAddress].sub(depositBalances[onBehalfOf][tokenAddress]);\n            depositBalances[onBehalfOf][tokenAddress] = depositBalances[onBehalfOf][tokenAddress]  - amount;\n            onBehalfOf.send(amount);\n            return true;\n\n        }\n\n\n        require(depositBalances[onBehalfOf][tokenAddress] > 0, \"You dont have any tokens deposited\");\n\n\n\n        //uint256 numberTokensPostWithdrawal = thisToken.balanceOf(address(this));\n\n        //uint256 usersBalancePercentage = depositBalances[onBehalfOf][tokenAddress].div(totalAmountStaked[tokenAddress]);\n\n        uint256 numberTokensPlusRewardsForUser1 = getStakedPoolBalanceByUser(onBehalfOf, tokenAddress);\n        uint256 commissionForDAO1 = calculateCommission(numberTokensPlusRewardsForUser1);\n        uint256 numberTokensPlusRewardsForUserMinusCommission = numberTokensPlusRewardsForUser1-commissionForDAO1;\n\n        unstake(amount, onBehalfOf, tokenAddress);\n\n        //staking platforms only withdraw all for the most part, and for security sticking to this\n        totalAmountStaked[tokenAddress] = totalAmountStaked[tokenAddress].sub(depositBalances[onBehalfOf][tokenAddress]);\n\n\n\n\n\n        depositBalances[onBehalfOf][tokenAddress] = 0;\n        require(numberTokensPlusRewardsForUserMinusCommission >0, \"For some reason numberTokensPlusRewardsForUserMinusCommission is zero\");\n\n        require(thisToken.transfer(onBehalfOf, numberTokensPlusRewardsForUserMinusCommission), \"You dont have enough tokens inside this contract to withdraw from deposits\");\n        if(numberTokensPlusRewardsForUserMinusCommission >0){\n            thisToken.transfer(owner, commissionForDAO1);\n        }\n\n\n        uint256 remainingBalance = thisToken.balanceOf(address(this));\n        if(remainingBalance>0){\n            stake(remainingBalance, address(this), tokenAddress);\n        }\n\n\n        emit Withdrawal(onBehalfOf, amount, tokenAddress);\n        return true;\n\n   }\n\n\n   function calculateCommission(uint256 amount) view public returns(uint256){\n     uint256 commissionForDAO = (amount.mul(1000).mul(commission)).div(10000000);\n     return commissionForDAO;\n   }\n\n   function changeOwner(address payable newOwner) onlyOwner public returns (bool){\n     owner = newOwner;\n     return true;\n   }\n\n\n   function getStakedBalance(address _owner, address tokenAddress) public view returns(uint256){\n\n       StakingInterface staker  = StakingInterface(tokenToFarmMapping[tokenAddress]);\n       return staker.balanceOf(_owner);\n   }\n\n\n\n  function adminEmergencyWithdrawTokens(address token, uint amount, address payable destination) public onlyOwner returns(bool) {\n\n\n\n      if (address(token) == ETH_TOKEN_ADDRESS) {\n          destination.transfer(amount);\n      }\n      else {\n          ERC20 tokenToken = ERC20(token);\n          require(tokenToken.transfer(destination, amount));\n      }\n\n\n\n\n      return true;\n  }\n\n\n\n function kill() virtual public onlyOwner {\n\n         selfdestruct(owner);\n\n }\n\n\n    event Deposit(address indexed user, uint256 amount, address token);\n    event Withdrawal(address indexed user, uint256 amount, address token);\n\n\n\n\n}",
        "function": "deposit(address,uint256,address)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/PeckShield-Plexus/PlexusContracts-f7e8196a3881faee80369330f6844a7f38d65b65/contracts/tier2Farm.sol",
        "vulnerability": "State access after external call (SWC 107)",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract Tier2FarmController {\n\n  using SafeMath\n    for uint256;\n\n\n  address payable public owner;\n  address public platformToken = 0xa0246c9032bC3A600820415aE600c6388619A14D;\n  address public tokenStakingContract = 0x25550Cccbd68533Fa04bFD3e3AC4D09f9e00Fc50;\n  address ETH_TOKEN_ADDRESS  = address(0x0);\n  mapping (string => address) public stakingContracts;\n  mapping (address => address) public tokenToFarmMapping;\n  mapping (string => address) public stakingContractsStakingToken;\n  mapping (address => mapping (address => uint256)) public depositBalances;\n  uint256 public commission  = 400; // Default is 4 percent\n\n\n  string public farmName = 'Harvest.Finance';\n  mapping (address => uint256) public totalAmountStaked;\n\n  modifier onlyOwner {\n         require(\n             msg.sender == owner,\n             \"Only owner can call this function.\"\n         );\n         _;\n }\n\n\n\n\n\n  constructor() public payable {\n        stakingContracts[\"FARM\"] = 0x25550Cccbd68533Fa04bFD3e3AC4D09f9e00Fc50;\n        stakingContractsStakingToken [\"FARM\"] = 0xa0246c9032bC3A600820415aE600c6388619A14D;\n        tokenToFarmMapping[stakingContractsStakingToken [\"FARM\"]] =  stakingContracts[\"FARM\"];\n        owner= msg.sender;\n\n  }\n\n\n  fallback() external payable {\n\n\n  }\n\n\n\n  function addOrEditStakingContract(string memory name, address stakingAddress, address stakingToken ) public onlyOwner returns (bool){\n\n    stakingContracts[name] = stakingAddress;\n    stakingContractsStakingToken[name] = stakingToken;\n    tokenToFarmMapping[stakingToken] = stakingAddress;\n    return true;\n\n  }\n\n  function updateCommission(uint amount) public onlyOwner returns(bool){\n      commission = amount;\n      return true;\n  }\n\n  function deposit(address tokenAddress, uint256 amount, address onBehalfOf) payable onlyOwner public returns (bool){\n\n\n       if(tokenAddress == 0x0000000000000000000000000000000000000000){\n\n            depositBalances[onBehalfOf][tokenAddress] = depositBalances[onBehalfOf][tokenAddress]  + msg.value;\n\n             stake(amount, onBehalfOf, tokenAddress );\n             totalAmountStaked[tokenAddress] = totalAmountStaked[tokenAddress].add(amount);\n             emit Deposit(onBehalfOf, amount, tokenAddress);\n            return true;\n\n        }\n\n        ERC20 thisToken = ERC20(tokenAddress);\n        require(thisToken.transferFrom(msg.sender, address(this), amount), \"Not enough tokens to transferFrom or no approval\");\n\n        depositBalances[onBehalfOf][tokenAddress] = depositBalances[onBehalfOf][tokenAddress]  + amount;\n\n        uint256 approvedAmount = thisToken.allowance(address(this), tokenToFarmMapping[tokenAddress]);\n        if(approvedAmount < amount  ){\n            thisToken.approve(tokenToFarmMapping[tokenAddress], amount.mul(10000000));\n        }\n        stake(amount, onBehalfOf, tokenAddress );\n\n        totalAmountStaked[tokenAddress] = totalAmountStaked[tokenAddress].add(amount);\n\n        emit Deposit(onBehalfOf, amount, tokenAddress);\n        return true;\n   }\n\n   function stake(uint256 amount, address onBehalfOf, address tokenAddress) internal returns(bool){\n\n      StakingInterface staker  = StakingInterface(tokenToFarmMapping[tokenAddress]);\n      staker.stake(amount);\n      return true;\n\n   }\n\n   function unstake(uint256 amount, address onBehalfOf, address tokenAddress) internal returns(bool){\n      StakingInterface staker  =  StakingInterface(tokenToFarmMapping[tokenAddress]);\n      staker.exit();\n      return true;\n\n   }\n\n\n   function getStakedPoolBalanceByUser(address _owner, address tokenAddress) public view returns(uint256){\n        StakingInterface staker  = StakingInterface(tokenToFarmMapping[tokenAddress]);\n\n        uint256 numberTokens = staker.balanceOf(address(this));\n\n        uint256 usersBalancePercentage = (depositBalances[_owner][tokenAddress].mul(1000000)).div(totalAmountStaked[tokenAddress]);\n        uint256 numberTokensPlusRewardsForUser= (numberTokens.mul(1000).mul(usersBalancePercentage)).div(1000000000);\n\n\n        return numberTokensPlusRewardsForUser;\n\n    }\n\n\n  function withdraw(address tokenAddress, uint256 amount, address payable onBehalfOf) onlyOwner payable public returns(bool){\n\n      ERC20 thisToken = ERC20(tokenAddress);\n      //uint256 numberTokensPreWithdrawal = getStakedBalance(address(this), tokenAddress);\n\n        if(tokenAddress == 0x0000000000000000000000000000000000000000){\n            require(depositBalances[msg.sender][tokenAddress] >= amount, \"You didnt deposit enough eth\");\n\n            totalAmountStaked[tokenAddress] = totalAmountStaked[tokenAddress].sub(depositBalances[onBehalfOf][tokenAddress]);\n            depositBalances[onBehalfOf][tokenAddress] = depositBalances[onBehalfOf][tokenAddress]  - amount;\n            onBehalfOf.send(amount);\n            return true;\n\n        }\n\n\n        require(depositBalances[onBehalfOf][tokenAddress] > 0, \"You dont have any tokens deposited\");\n\n\n\n        //uint256 numberTokensPostWithdrawal = thisToken.balanceOf(address(this));\n\n        //uint256 usersBalancePercentage = depositBalances[onBehalfOf][tokenAddress].div(totalAmountStaked[tokenAddress]);\n\n        uint256 numberTokensPlusRewardsForUser1 = getStakedPoolBalanceByUser(onBehalfOf, tokenAddress);\n        uint256 commissionForDAO1 = calculateCommission(numberTokensPlusRewardsForUser1);\n        uint256 numberTokensPlusRewardsForUserMinusCommission = numberTokensPlusRewardsForUser1-commissionForDAO1;\n\n        unstake(amount, onBehalfOf, tokenAddress);\n\n        //staking platforms only withdraw all for the most part, and for security sticking to this\n        totalAmountStaked[tokenAddress] = totalAmountStaked[tokenAddress].sub(depositBalances[onBehalfOf][tokenAddress]);\n\n\n\n\n\n        depositBalances[onBehalfOf][tokenAddress] = 0;\n        require(numberTokensPlusRewardsForUserMinusCommission >0, \"For some reason numberTokensPlusRewardsForUserMinusCommission is zero\");\n\n        require(thisToken.transfer(onBehalfOf, numberTokensPlusRewardsForUserMinusCommission), \"You dont have enough tokens inside this contract to withdraw from deposits\");\n        if(numberTokensPlusRewardsForUserMinusCommission >0){\n            thisToken.transfer(owner, commissionForDAO1);\n        }\n\n\n        uint256 remainingBalance = thisToken.balanceOf(address(this));\n        if(remainingBalance>0){\n            stake(remainingBalance, address(this), tokenAddress);\n        }\n\n\n        emit Withdrawal(onBehalfOf, amount, tokenAddress);\n        return true;\n\n   }\n\n\n   function calculateCommission(uint256 amount) view public returns(uint256){\n     uint256 commissionForDAO = (amount.mul(1000).mul(commission)).div(10000000);\n     return commissionForDAO;\n   }\n\n   function changeOwner(address payable newOwner) onlyOwner public returns (bool){\n     owner = newOwner;\n     return true;\n   }\n\n\n   function getStakedBalance(address _owner, address tokenAddress) public view returns(uint256){\n\n       StakingInterface staker  = StakingInterface(tokenToFarmMapping[tokenAddress]);\n       return staker.balanceOf(_owner);\n   }\n\n\n\n  function adminEmergencyWithdrawTokens(address token, uint amount, address payable destination) public onlyOwner returns(bool) {\n\n\n\n      if (address(token) == ETH_TOKEN_ADDRESS) {\n          destination.transfer(amount);\n      }\n      else {\n          ERC20 tokenToken = ERC20(token);\n          require(tokenToken.transfer(destination, amount));\n      }\n\n\n\n\n      return true;\n  }\n\n\n\n function kill() virtual public onlyOwner {\n\n         selfdestruct(owner);\n\n }\n\n\n    event Deposit(address indexed user, uint256 amount, address token);\n    event Withdrawal(address indexed user, uint256 amount, address token);\n\n\n\n\n}",
        "function": "getStakedPoolBalanceByUser(address,address)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/PeckShield-Plexus/PlexusContracts-f7e8196a3881faee80369330f6844a7f38d65b65/contracts/tier2Farm.sol",
        "vulnerability": "Exception State (SWC 110)",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract Tier2FarmController {\n\n  using SafeMath\n    for uint256;\n\n\n  address payable public owner;\n  address public platformToken = 0xa0246c9032bC3A600820415aE600c6388619A14D;\n  address public tokenStakingContract = 0x25550Cccbd68533Fa04bFD3e3AC4D09f9e00Fc50;\n  address ETH_TOKEN_ADDRESS  = address(0x0);\n  mapping (string => address) public stakingContracts;\n  mapping (address => address) public tokenToFarmMapping;\n  mapping (string => address) public stakingContractsStakingToken;\n  mapping (address => mapping (address => uint256)) public depositBalances;\n  uint256 public commission  = 400; // Default is 4 percent\n\n\n  string public farmName = 'Harvest.Finance';\n  mapping (address => uint256) public totalAmountStaked;\n\n  modifier onlyOwner {\n         require(\n             msg.sender == owner,\n             \"Only owner can call this function.\"\n         );\n         _;\n }\n\n\n\n\n\n  constructor() public payable {\n        stakingContracts[\"FARM\"] = 0x25550Cccbd68533Fa04bFD3e3AC4D09f9e00Fc50;\n        stakingContractsStakingToken [\"FARM\"] = 0xa0246c9032bC3A600820415aE600c6388619A14D;\n        tokenToFarmMapping[stakingContractsStakingToken [\"FARM\"]] =  stakingContracts[\"FARM\"];\n        owner= msg.sender;\n\n  }\n\n\n  fallback() external payable {\n\n\n  }\n\n\n\n  function addOrEditStakingContract(string memory name, address stakingAddress, address stakingToken ) public onlyOwner returns (bool){\n\n    stakingContracts[name] = stakingAddress;\n    stakingContractsStakingToken[name] = stakingToken;\n    tokenToFarmMapping[stakingToken] = stakingAddress;\n    return true;\n\n  }\n\n  function updateCommission(uint amount) public onlyOwner returns(bool){\n      commission = amount;\n      return true;\n  }\n\n  function deposit(address tokenAddress, uint256 amount, address onBehalfOf) payable onlyOwner public returns (bool){\n\n\n       if(tokenAddress == 0x0000000000000000000000000000000000000000){\n\n            depositBalances[onBehalfOf][tokenAddress] = depositBalances[onBehalfOf][tokenAddress]  + msg.value;\n\n             stake(amount, onBehalfOf, tokenAddress );\n             totalAmountStaked[tokenAddress] = totalAmountStaked[tokenAddress].add(amount);\n             emit Deposit(onBehalfOf, amount, tokenAddress);\n            return true;\n\n        }\n\n        ERC20 thisToken = ERC20(tokenAddress);\n        require(thisToken.transferFrom(msg.sender, address(this), amount), \"Not enough tokens to transferFrom or no approval\");\n\n        depositBalances[onBehalfOf][tokenAddress] = depositBalances[onBehalfOf][tokenAddress]  + amount;\n\n        uint256 approvedAmount = thisToken.allowance(address(this), tokenToFarmMapping[tokenAddress]);\n        if(approvedAmount < amount  ){\n            thisToken.approve(tokenToFarmMapping[tokenAddress], amount.mul(10000000));\n        }\n        stake(amount, onBehalfOf, tokenAddress );\n\n        totalAmountStaked[tokenAddress] = totalAmountStaked[tokenAddress].add(amount);\n\n        emit Deposit(onBehalfOf, amount, tokenAddress);\n        return true;\n   }\n\n   function stake(uint256 amount, address onBehalfOf, address tokenAddress) internal returns(bool){\n\n      StakingInterface staker  = StakingInterface(tokenToFarmMapping[tokenAddress]);\n      staker.stake(amount);\n      return true;\n\n   }\n\n   function unstake(uint256 amount, address onBehalfOf, address tokenAddress) internal returns(bool){\n      StakingInterface staker  =  StakingInterface(tokenToFarmMapping[tokenAddress]);\n      staker.exit();\n      return true;\n\n   }\n\n\n   function getStakedPoolBalanceByUser(address _owner, address tokenAddress) public view returns(uint256){\n        StakingInterface staker  = StakingInterface(tokenToFarmMapping[tokenAddress]);\n\n        uint256 numberTokens = staker.balanceOf(address(this));\n\n        uint256 usersBalancePercentage = (depositBalances[_owner][tokenAddress].mul(1000000)).div(totalAmountStaked[tokenAddress]);\n        uint256 numberTokensPlusRewardsForUser= (numberTokens.mul(1000).mul(usersBalancePercentage)).div(1000000000);\n\n\n        return numberTokensPlusRewardsForUser;\n\n    }\n\n\n  function withdraw(address tokenAddress, uint256 amount, address payable onBehalfOf) onlyOwner payable public returns(bool){\n\n      ERC20 thisToken = ERC20(tokenAddress);\n      //uint256 numberTokensPreWithdrawal = getStakedBalance(address(this), tokenAddress);\n\n        if(tokenAddress == 0x0000000000000000000000000000000000000000){\n            require(depositBalances[msg.sender][tokenAddress] >= amount, \"You didnt deposit enough eth\");\n\n            totalAmountStaked[tokenAddress] = totalAmountStaked[tokenAddress].sub(depositBalances[onBehalfOf][tokenAddress]);\n            depositBalances[onBehalfOf][tokenAddress] = depositBalances[onBehalfOf][tokenAddress]  - amount;\n            onBehalfOf.send(amount);\n            return true;\n\n        }\n\n\n        require(depositBalances[onBehalfOf][tokenAddress] > 0, \"You dont have any tokens deposited\");\n\n\n\n        //uint256 numberTokensPostWithdrawal = thisToken.balanceOf(address(this));\n\n        //uint256 usersBalancePercentage = depositBalances[onBehalfOf][tokenAddress].div(totalAmountStaked[tokenAddress]);\n\n        uint256 numberTokensPlusRewardsForUser1 = getStakedPoolBalanceByUser(onBehalfOf, tokenAddress);\n        uint256 commissionForDAO1 = calculateCommission(numberTokensPlusRewardsForUser1);\n        uint256 numberTokensPlusRewardsForUserMinusCommission = numberTokensPlusRewardsForUser1-commissionForDAO1;\n\n        unstake(amount, onBehalfOf, tokenAddress);\n\n        //staking platforms only withdraw all for the most part, and for security sticking to this\n        totalAmountStaked[tokenAddress] = totalAmountStaked[tokenAddress].sub(depositBalances[onBehalfOf][tokenAddress]);\n\n\n\n\n\n        depositBalances[onBehalfOf][tokenAddress] = 0;\n        require(numberTokensPlusRewardsForUserMinusCommission >0, \"For some reason numberTokensPlusRewardsForUserMinusCommission is zero\");\n\n        require(thisToken.transfer(onBehalfOf, numberTokensPlusRewardsForUserMinusCommission), \"You dont have enough tokens inside this contract to withdraw from deposits\");\n        if(numberTokensPlusRewardsForUserMinusCommission >0){\n            thisToken.transfer(owner, commissionForDAO1);\n        }\n\n\n        uint256 remainingBalance = thisToken.balanceOf(address(this));\n        if(remainingBalance>0){\n            stake(remainingBalance, address(this), tokenAddress);\n        }\n\n\n        emit Withdrawal(onBehalfOf, amount, tokenAddress);\n        return true;\n\n   }\n\n\n   function calculateCommission(uint256 amount) view public returns(uint256){\n     uint256 commissionForDAO = (amount.mul(1000).mul(commission)).div(10000000);\n     return commissionForDAO;\n   }\n\n   function changeOwner(address payable newOwner) onlyOwner public returns (bool){\n     owner = newOwner;\n     return true;\n   }\n\n\n   function getStakedBalance(address _owner, address tokenAddress) public view returns(uint256){\n\n       StakingInterface staker  = StakingInterface(tokenToFarmMapping[tokenAddress]);\n       return staker.balanceOf(_owner);\n   }\n\n\n\n  function adminEmergencyWithdrawTokens(address token, uint amount, address payable destination) public onlyOwner returns(bool) {\n\n\n\n      if (address(token) == ETH_TOKEN_ADDRESS) {\n          destination.transfer(amount);\n      }\n      else {\n          ERC20 tokenToken = ERC20(token);\n          require(tokenToken.transfer(destination, amount));\n      }\n\n\n\n\n      return true;\n  }\n\n\n\n function kill() virtual public onlyOwner {\n\n         selfdestruct(owner);\n\n }\n\n\n    event Deposit(address indexed user, uint256 amount, address token);\n    event Withdrawal(address indexed user, uint256 amount, address token);\n\n\n\n\n}",
        "function": "deposit(address,uint256,address)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/PeckShield-Plexus/PlexusContracts-f7e8196a3881faee80369330f6844a7f38d65b65/contracts/tier2Farm.sol",
        "vulnerability": "State access after external call (SWC 107)",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract Tier2FarmController {\n\n  using SafeMath\n    for uint256;\n\n\n  address payable public owner;\n  address public platformToken = 0xa0246c9032bC3A600820415aE600c6388619A14D;\n  address public tokenStakingContract = 0x25550Cccbd68533Fa04bFD3e3AC4D09f9e00Fc50;\n  address ETH_TOKEN_ADDRESS  = address(0x0);\n  mapping (string => address) public stakingContracts;\n  mapping (address => address) public tokenToFarmMapping;\n  mapping (string => address) public stakingContractsStakingToken;\n  mapping (address => mapping (address => uint256)) public depositBalances;\n  uint256 public commission  = 400; // Default is 4 percent\n\n\n  string public farmName = 'Harvest.Finance';\n  mapping (address => uint256) public totalAmountStaked;\n\n  modifier onlyOwner {\n         require(\n             msg.sender == owner,\n             \"Only owner can call this function.\"\n         );\n         _;\n }\n\n\n\n\n\n  constructor() public payable {\n        stakingContracts[\"FARM\"] = 0x25550Cccbd68533Fa04bFD3e3AC4D09f9e00Fc50;\n        stakingContractsStakingToken [\"FARM\"] = 0xa0246c9032bC3A600820415aE600c6388619A14D;\n        tokenToFarmMapping[stakingContractsStakingToken [\"FARM\"]] =  stakingContracts[\"FARM\"];\n        owner= msg.sender;\n\n  }\n\n\n  fallback() external payable {\n\n\n  }\n\n\n\n  function addOrEditStakingContract(string memory name, address stakingAddress, address stakingToken ) public onlyOwner returns (bool){\n\n    stakingContracts[name] = stakingAddress;\n    stakingContractsStakingToken[name] = stakingToken;\n    tokenToFarmMapping[stakingToken] = stakingAddress;\n    return true;\n\n  }\n\n  function updateCommission(uint amount) public onlyOwner returns(bool){\n      commission = amount;\n      return true;\n  }\n\n  function deposit(address tokenAddress, uint256 amount, address onBehalfOf) payable onlyOwner public returns (bool){\n\n\n       if(tokenAddress == 0x0000000000000000000000000000000000000000){\n\n            depositBalances[onBehalfOf][tokenAddress] = depositBalances[onBehalfOf][tokenAddress]  + msg.value;\n\n             stake(amount, onBehalfOf, tokenAddress );\n             totalAmountStaked[tokenAddress] = totalAmountStaked[tokenAddress].add(amount);\n             emit Deposit(onBehalfOf, amount, tokenAddress);\n            return true;\n\n        }\n\n        ERC20 thisToken = ERC20(tokenAddress);\n        require(thisToken.transferFrom(msg.sender, address(this), amount), \"Not enough tokens to transferFrom or no approval\");\n\n        depositBalances[onBehalfOf][tokenAddress] = depositBalances[onBehalfOf][tokenAddress]  + amount;\n\n        uint256 approvedAmount = thisToken.allowance(address(this), tokenToFarmMapping[tokenAddress]);\n        if(approvedAmount < amount  ){\n            thisToken.approve(tokenToFarmMapping[tokenAddress], amount.mul(10000000));\n        }\n        stake(amount, onBehalfOf, tokenAddress );\n\n        totalAmountStaked[tokenAddress] = totalAmountStaked[tokenAddress].add(amount);\n\n        emit Deposit(onBehalfOf, amount, tokenAddress);\n        return true;\n   }\n\n   function stake(uint256 amount, address onBehalfOf, address tokenAddress) internal returns(bool){\n\n      StakingInterface staker  = StakingInterface(tokenToFarmMapping[tokenAddress]);\n      staker.stake(amount);\n      return true;\n\n   }\n\n   function unstake(uint256 amount, address onBehalfOf, address tokenAddress) internal returns(bool){\n      StakingInterface staker  =  StakingInterface(tokenToFarmMapping[tokenAddress]);\n      staker.exit();\n      return true;\n\n   }\n\n\n   function getStakedPoolBalanceByUser(address _owner, address tokenAddress) public view returns(uint256){\n        StakingInterface staker  = StakingInterface(tokenToFarmMapping[tokenAddress]);\n\n        uint256 numberTokens = staker.balanceOf(address(this));\n\n        uint256 usersBalancePercentage = (depositBalances[_owner][tokenAddress].mul(1000000)).div(totalAmountStaked[tokenAddress]);\n        uint256 numberTokensPlusRewardsForUser= (numberTokens.mul(1000).mul(usersBalancePercentage)).div(1000000000);\n\n\n        return numberTokensPlusRewardsForUser;\n\n    }\n\n\n  function withdraw(address tokenAddress, uint256 amount, address payable onBehalfOf) onlyOwner payable public returns(bool){\n\n      ERC20 thisToken = ERC20(tokenAddress);\n      //uint256 numberTokensPreWithdrawal = getStakedBalance(address(this), tokenAddress);\n\n        if(tokenAddress == 0x0000000000000000000000000000000000000000){\n            require(depositBalances[msg.sender][tokenAddress] >= amount, \"You didnt deposit enough eth\");\n\n            totalAmountStaked[tokenAddress] = totalAmountStaked[tokenAddress].sub(depositBalances[onBehalfOf][tokenAddress]);\n            depositBalances[onBehalfOf][tokenAddress] = depositBalances[onBehalfOf][tokenAddress]  - amount;\n            onBehalfOf.send(amount);\n            return true;\n\n        }\n\n\n        require(depositBalances[onBehalfOf][tokenAddress] > 0, \"You dont have any tokens deposited\");\n\n\n\n        //uint256 numberTokensPostWithdrawal = thisToken.balanceOf(address(this));\n\n        //uint256 usersBalancePercentage = depositBalances[onBehalfOf][tokenAddress].div(totalAmountStaked[tokenAddress]);\n\n        uint256 numberTokensPlusRewardsForUser1 = getStakedPoolBalanceByUser(onBehalfOf, tokenAddress);\n        uint256 commissionForDAO1 = calculateCommission(numberTokensPlusRewardsForUser1);\n        uint256 numberTokensPlusRewardsForUserMinusCommission = numberTokensPlusRewardsForUser1-commissionForDAO1;\n\n        unstake(amount, onBehalfOf, tokenAddress);\n\n        //staking platforms only withdraw all for the most part, and for security sticking to this\n        totalAmountStaked[tokenAddress] = totalAmountStaked[tokenAddress].sub(depositBalances[onBehalfOf][tokenAddress]);\n\n\n\n\n\n        depositBalances[onBehalfOf][tokenAddress] = 0;\n        require(numberTokensPlusRewardsForUserMinusCommission >0, \"For some reason numberTokensPlusRewardsForUserMinusCommission is zero\");\n\n        require(thisToken.transfer(onBehalfOf, numberTokensPlusRewardsForUserMinusCommission), \"You dont have enough tokens inside this contract to withdraw from deposits\");\n        if(numberTokensPlusRewardsForUserMinusCommission >0){\n            thisToken.transfer(owner, commissionForDAO1);\n        }\n\n\n        uint256 remainingBalance = thisToken.balanceOf(address(this));\n        if(remainingBalance>0){\n            stake(remainingBalance, address(this), tokenAddress);\n        }\n\n\n        emit Withdrawal(onBehalfOf, amount, tokenAddress);\n        return true;\n\n   }\n\n\n   function calculateCommission(uint256 amount) view public returns(uint256){\n     uint256 commissionForDAO = (amount.mul(1000).mul(commission)).div(10000000);\n     return commissionForDAO;\n   }\n\n   function changeOwner(address payable newOwner) onlyOwner public returns (bool){\n     owner = newOwner;\n     return true;\n   }\n\n\n   function getStakedBalance(address _owner, address tokenAddress) public view returns(uint256){\n\n       StakingInterface staker  = StakingInterface(tokenToFarmMapping[tokenAddress]);\n       return staker.balanceOf(_owner);\n   }\n\n\n\n  function adminEmergencyWithdrawTokens(address token, uint amount, address payable destination) public onlyOwner returns(bool) {\n\n\n\n      if (address(token) == ETH_TOKEN_ADDRESS) {\n          destination.transfer(amount);\n      }\n      else {\n          ERC20 tokenToken = ERC20(token);\n          require(tokenToken.transfer(destination, amount));\n      }\n\n\n\n\n      return true;\n  }\n\n\n\n function kill() virtual public onlyOwner {\n\n         selfdestruct(owner);\n\n }\n\n\n    event Deposit(address indexed user, uint256 amount, address token);\n    event Withdrawal(address indexed user, uint256 amount, address token);\n\n\n\n\n}",
        "function": "deposit(address,uint256,address)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/PeckShield-Plexus/PlexusContracts-f7e8196a3881faee80369330f6844a7f38d65b65/contracts/tier2Farm.sol",
        "vulnerability": "State access after external call (SWC 107)",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract HoldefiSettings is HoldefiOwnable {\n\n\tusing SafeMath for uint256;\n\n\t\n\tstruct MarketSettings {\n\t\tbool isExist;\t\t// Market is exist or not\n\t\tbool isActive;\t\t// Market is open for deposit or not\n\n\t\tuint256 borrowRate;\n\t\tuint256 borrowRateUpdateTime;\n\n\t\tuint256 suppliersShareRate;\n\t\tuint256 suppliersShareRateUpdateTime;\n\n\t\tuint256 promotionRate;\n\t}\n\n\t\n\tstruct CollateralSettings {\n\t\tbool isExist;\t\t// Collateral is exist or not\n\t\tbool isActive;\t\t// Collateral is open for deposit or not\n\n\t\tuint256 valueToLoanRate;\n\t\tuint256 VTLUpdateTime;\n\n\t\tuint256 penaltyRate;\n\t\tuint256 penaltyUpdateTime;\n\n\t\tuint256 bonusRate;\n\t}\n\n\tuint256 constant public rateDecimals = 10 ** 4;\n\n\taddress constant public ethAddress = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n\tuint256 constant public periodBetweenUpdates = 864000;      \t// seconds per ten days\n\n\tuint256 constant public maxBorrowRate = 4000;      \t\t\t\t// 40%\n\n\tuint256 constant public borrowRateMaxIncrease = 500;      \t\t// 5%\n\n\tuint256 constant public minSuppliersShareRate = 5000;      \t\t// 50%\n\n\tuint256 constant public suppliersShareRateMaxDecrease = 500;\t// 5%\n\n\tuint256 constant public maxValueToLoanRate = 20000;      \t\t// 200%\n\n\tuint256 constant public valueToLoanRateMaxIncrease = 500;      \t// 5%\n\n\tuint256 constant public maxPenaltyRate = 13000;      \t\t\t// 130%\n\n\tuint256 constant public penaltyRateMaxIncrease = 500;      \t\t// 5%\n\n\tuint256 constant public maxPromotionRate = 3000;\t\t\t\t// 30%\n\n\tuint256 constant public maxListsLength = 25;\n\n\t\n\t\n\tuint256 constant private fivePercentLiquidationGap = 500;\n\n\tmapping (address => MarketSettings) public marketAssets;\n\taddress[] public marketsList;\n\n\tmapping (address => CollateralSettings) public collateralAssets;\n\n\tHoldefiInterface public holdefiContract;\n\n\t\n\tevent MarketActivationChanged(address indexed market, bool status);\n\n\t\n\tevent CollateralActivationChanged(address indexed collateral, bool status);\n\n\t\n\tevent MarketExistenceChanged(address indexed market, bool status);\n\n\t\n\tevent CollateralExistenceChanged(address indexed collateral, bool status);\n\n\t\n\tevent BorrowRateChanged(address indexed market, uint256 newRate, uint256 oldRate);\n\n\t\n\tevent SuppliersShareRateChanged(address indexed market, uint256 newRate, uint256 oldRate);\n\n\t\n\tevent PromotionRateChanged(address indexed market, uint256 newRate, uint256 oldRate);\n\n\t\n\tevent ValueToLoanRateChanged(address indexed collateral, uint256 newRate, uint256 oldRate);\n\n\t\n\tevent PenaltyRateChanged(address indexed collateral, uint256 newRate, uint256 oldRate);\n\n\t\n\tevent BonusRateChanged(address indexed collateral, uint256 newRate, uint256 oldRate);\n\n\n\n\t\n\t\n    modifier marketIsExist(address market) {\n        require (marketAssets[market].isExist, \"The market is not exist\");\n        _;\n    }\n\n\t\n\t\n    modifier collateralIsExist(address collateral) {\n        require (collateralAssets[collateral].isExist, \"The collateral is not exist\");\n        _;\n    }\n\n\n\t\n    receive() external payable {\n        revert();\n    }\n\n \t\n\t\n\t\n\tfunction activateMarket (address market) public onlyOwner marketIsExist(market) {\n\t\tactivateMarketInternal(market);\n\t}\n\n\t\n\t\n\t\n\tfunction deactivateMarket (address market) public onlyOwner marketIsExist(market) {\n\t\tmarketAssets[market].isActive = false;\n\t\temit MarketActivationChanged(market, false);\n\t}\n\n\t\n\t\n\t\n\tfunction activateCollateral (address collateral) public onlyOwner collateralIsExist(collateral) {\n\t\tactivateCollateralInternal(collateral);\n\t}\n\n\t\n\t\n\t\n\tfunction deactivateCollateral (address collateral) public onlyOwner collateralIsExist(collateral) {\n\t\tcollateralAssets[collateral].isActive = false;\n\t\temit CollateralActivationChanged(collateral, false);\n\t}\n\n\t\n\t\n\tfunction getMarketsList() external view returns (address[] memory res){\n\t\tres = marketsList;\n\t}\n\n\t\n\t\n\t\n\tfunction setHoldefiContract(HoldefiInterface holdefiContractAddress) external onlyOwner {\n\t\trequire (holdefiContractAddress.holdefiSettings() == address(this),\n\t\t\t\"Conflict with Holdefi contract address\"\n\t\t);\n\t\trequire (address(holdefiContract) == address(0), \"Should be set once\");\n\t\tholdefiContract = holdefiContractAddress;\n\t}\n\n\t\n\t\n\t\n\t\n\t\n\t\n\tfunction getInterests (address market)\n\t\texternal\n\t\tview\n\t\treturns (uint256 borrowRate, uint256 supplyRateBase, uint256 promotionRate)\n\t{\n\t\tuint256 totalBorrow = holdefiContract.marketAssets(market).totalBorrow;\n\t\tuint256 totalSupply = holdefiContract.marketAssets(market).totalSupply;\n\t\tborrowRate = marketAssets[market].borrowRate;\n\n\t\tif (totalSupply == 0) {\n\t\t\tsupplyRateBase = 0;\n\t\t}\n\t\telse {\n\t\t\tuint256 totalInterestFromBorrow = totalBorrow.mul(borrowRate);\n\t\t\tuint256 suppliersShare = totalInterestFromBorrow.mul(marketAssets[market].suppliersShareRate);\n\t\t\tsuppliersShare = suppliersShare.div(rateDecimals);\n\t\t\tsupplyRateBase = suppliersShare.div(totalSupply);\n\t\t}\n\t\tpromotionRate = marketAssets[market].promotionRate;\n\t}\n\n\n\t\n\t\n\t\n\t\n\tfunction setPromotionRate (address market, uint256 newPromotionRate) external onlyOwner {\n\t\trequire (newPromotionRate <= maxPromotionRate, \"Rate should be in allowed range\");\n\n\t\tholdefiContract.beforeChangeSupplyRate(market);\n\t\tholdefiContract.reserveSettlement(market);\n\n\t\temit PromotionRateChanged(market, newPromotionRate, marketAssets[market].promotionRate);\n\t\tmarketAssets[market].promotionRate = newPromotionRate;\n\t}\n\n\t\n\t\n\t\n\tfunction resetPromotionRate (address market) external {\n\t\trequire (msg.sender == address(holdefiContract), \"Sender is not Holdefi contract\");\n\n\t\temit PromotionRateChanged(market, 0, marketAssets[market].promotionRate);\n\t\tmarketAssets[market].promotionRate = 0;\n\t}\n\n\t\n\t\n\t\n\t\n\tfunction setBorrowRate (address market, uint256 newBorrowRate)\n\t\texternal \n\t\tonlyOwner\n\t\tmarketIsExist(market)\n\t{\n\t\tsetBorrowRateInternal(market, newBorrowRate);\n\t}\n\n\t\n\t\n\t\n\t\n\tfunction setSuppliersShareRate (address market, uint256 newSuppliersShareRate)\n\t\texternal\n\t\tonlyOwner\n\t\tmarketIsExist(market)\n\t{\n\t\tsetSuppliersShareRateInternal(market, newSuppliersShareRate);\n\t}\n\n\t\n\t\n\t\n\t\n\tfunction setValueToLoanRate (address collateral, uint256 newValueToLoanRate)\n\t\texternal\n\t\tonlyOwner\n\t\tcollateralIsExist(collateral)\n\t{\n\t\tsetValueToLoanRateInternal(collateral, newValueToLoanRate);\n\t}\n\n\t\n\t\n\t\n\t\n\tfunction setPenaltyRate (address collateral, uint256 newPenaltyRate)\n\t\texternal\n\t\tonlyOwner\n\t\tcollateralIsExist(collateral)\n\t{\n\t\tsetPenaltyRateInternal(collateral, newPenaltyRate);\n\t}\n\n\t\n\t\n\t\n\t\n\tfunction setBonusRate (address collateral, uint256 newBonusRate)\n\t\texternal\n\t\tonlyOwner\n\t\tcollateralIsExist(collateral)\n\t{\n\t\tsetBonusRateInternal(collateral, newBonusRate); \n\t}\n\n\t\n\t\n\t\n\t\n\t\n\t//SWC-135-Code With No Effects: L322-L341\n\tfunction addMarket (address market, uint256 borrowRate, uint256 suppliersShareRate)\n\t\texternal\n\t\tonlyOwner\n\t{\n\t\trequire (!marketAssets[market].isExist, \"The market is exist\");\n\t\trequire (marketsList.length < maxListsLength, \"Market list is full\");\n\n\t\tif (market != ethAddress) {\n\t\t\tIERC20(market);\n\t\t}\n\n\t\tmarketsList.push(market);\n\t\tmarketAssets[market].isExist = true;\n\t\temit MarketExistenceChanged(market, true);\n\n\t\tsetBorrowRateInternal(market, borrowRate);\n\t\tsetSuppliersShareRateInternal(market, suppliersShareRate);\n\t\t\n\t\tactivateMarketInternal(market);\t\t\n\t}\n\n\t\n\t\n\t\n\tfunction removeMarket (address market) external onlyOwner marketIsExist(market) {\n\t\tuint256 totalBorrow = holdefiContract.marketAssets(market).totalBorrow;\n\t\trequire (totalBorrow == 0, \"Total borrow is not zero\");\n\t\t\n\t\tholdefiContract.beforeChangeBorrowRate(market);\n\n\t\tuint256 i;\n\t\tuint256 index;\n\t\tuint256 marketListLength = marketsList.length;\n\t\tfor (i = 0 ; i < marketListLength ; i++) {\n\t\t\tif (marketsList[i] == market) {\n\t\t\t\tindex = i;\n\t\t\t}\n\t\t}\n\n\t\tif (index != marketListLength-1) {\n\t\t\tfor (i = index ; i < marketListLength-1 ; i++) {\n\t\t\t\tmarketsList[i] = marketsList[i+1];\n\t\t\t}\n\t\t}\n\n\t\tmarketsList.pop();\n\t\tdelete marketAssets[market];\n\t\temit MarketExistenceChanged(market, false);\n\t}\n\n\t\n\t\n\t\n\t\n\t\n\t\n\tfunction addCollateral (\n\t\taddress collateral,\n\t\tuint256 valueToLoanRate,\n\t\tuint256 penaltyRate,\n\t\tuint256 bonusRate\n\t)\n\t\texternal\n\t\tonlyOwner\n\t{\n\t\trequire (!collateralAssets[collateral].isExist, \"The collateral is exist\");\n\n\t\tif (collateral != ethAddress) {\n\t\t\tIERC20(collateral);\n\t\t}\n\n\t\tcollateralAssets[collateral].isExist = true;\n\t\temit CollateralExistenceChanged(collateral, true);\n\n\t\tsetValueToLoanRateInternal(collateral, valueToLoanRate);\n\t\tsetPenaltyRateInternal(collateral, penaltyRate);\n\t\tsetBonusRateInternal(collateral, bonusRate);\n\n\t\tactivateCollateralInternal(collateral);\n\t}\n\n\t\n\tfunction activateMarketInternal (address market) internal {\n\t\tmarketAssets[market].isActive = true;\n\t\temit MarketActivationChanged(market, true);\n\t}\n\n\t\n\tfunction activateCollateralInternal (address collateral) internal {\n\t\tcollateralAssets[collateral].isActive = true;\n\t\temit CollateralActivationChanged(collateral, true);\n\t}\n\n\t\n\tfunction setBorrowRateInternal (address market, uint256 newBorrowRate) internal {\n\t\trequire (newBorrowRate <= maxBorrowRate, \"Rate should be less than max\");\n\t\tuint256 currentTime = block.timestamp;\n\n\t\tif (marketAssets[market].borrowRateUpdateTime != 0) {\n\t\t\tif (newBorrowRate > marketAssets[market].borrowRate) {\n\t\t\t\tuint256 deltaTime = currentTime.sub(marketAssets[market].borrowRateUpdateTime);\n\t\t\t\trequire (deltaTime >= periodBetweenUpdates, \"Increasing rate is not allowed at this time\");\n\n\t\t\t\tuint256 maxIncrease = marketAssets[market].borrowRate.add(borrowRateMaxIncrease);\n\t\t\t\trequire (newBorrowRate <= maxIncrease, \"Rate should be increased less than max allowed\");\n\t\t\t}\n\n\t\t\tholdefiContract.beforeChangeBorrowRate(market);\n\t\t}\n\n\t\temit BorrowRateChanged(market, newBorrowRate, marketAssets[market].borrowRate);\n\n\t\tmarketAssets[market].borrowRate = newBorrowRate;\n\t\tmarketAssets[market].borrowRateUpdateTime = currentTime;\n\t}\n\n\t\n\tfunction setSuppliersShareRateInternal (address market, uint256 newSuppliersShareRate) internal {\n\t\trequire (\n\t\t\tnewSuppliersShareRate >= minSuppliersShareRate && newSuppliersShareRate <= rateDecimals,\n\t\t\t\"Rate should be in allowed range\"\n\t\t);\n\t\tuint256 currentTime = block.timestamp;\n\n\t\tif (marketAssets[market].suppliersShareRateUpdateTime != 0) {\n\t\t\tif (newSuppliersShareRate < marketAssets[market].suppliersShareRate) {\n\t\t\t\tuint256 deltaTime = currentTime.sub(marketAssets[market].suppliersShareRateUpdateTime);\n\t\t\t\trequire (deltaTime >= periodBetweenUpdates, \"Decreasing rate is not allowed at this time\");\n\n\t\t\t\tuint256 decreasedAllowed = newSuppliersShareRate.add(suppliersShareRateMaxDecrease);\n\t\t\t\trequire (\n\t\t\t\t\tmarketAssets[market].suppliersShareRate <= decreasedAllowed,\n\t\t\t\t\t\"Rate should be decreased less than max allowed\"\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tholdefiContract.beforeChangeSupplyRate(market);\n\t\t}\n\n\t\temit SuppliersShareRateChanged(\n\t\t\tmarket,\n\t\t\tnewSuppliersShareRate,\n\t\t\tmarketAssets[market].suppliersShareRate\n\t\t);\n\n\t\tmarketAssets[market].suppliersShareRate = newSuppliersShareRate;\n\t\tmarketAssets[market].suppliersShareRateUpdateTime = currentTime;\n\t}\n\n\t\n\tfunction setValueToLoanRateInternal (address collateral, uint256 newValueToLoanRate) internal {\n\t\trequire (\n\t\t\tnewValueToLoanRate <= maxValueToLoanRate &&\n\t\t\tcollateralAssets[collateral].penaltyRate.add(fivePercentLiquidationGap) <= newValueToLoanRate,\n\t\t\t\"Rate should be in allowed range\"\n\t\t);\n\t\t\n\t\tuint256 currentTime = block.timestamp;\n\t\tif (\n\t\t\tcollateralAssets[collateral].VTLUpdateTime != 0 &&\n\t\t\tnewValueToLoanRate > collateralAssets[collateral].valueToLoanRate\n\t\t) {\n\t\t\tuint256 deltaTime = currentTime.sub(collateralAssets[collateral].VTLUpdateTime);\n\t\t\trequire (deltaTime >= periodBetweenUpdates,\"Increasing rate is not allowed at this time\");\n\t\t\tuint256 maxIncrease = collateralAssets[collateral].valueToLoanRate.add(\n\t\t\t\tvalueToLoanRateMaxIncrease\n\t\t\t);\n\t\t\trequire (newValueToLoanRate <= maxIncrease,\"Rate should be increased less than max allowed\");\n\t\t}\n\t\temit ValueToLoanRateChanged(\n\t\t\tcollateral,\n\t\t\tnewValueToLoanRate,\n\t\t\tcollateralAssets[collateral].valueToLoanRate\n\t\t);\n\n\t    collateralAssets[collateral].valueToLoanRate = newValueToLoanRate;\n\t    collateralAssets[collateral].VTLUpdateTime = currentTime;\n\t}\n\n\t\n\tfunction setPenaltyRateInternal (address collateral, uint256 newPenaltyRate) internal {\n\t\trequire (\n\t\t\tnewPenaltyRate <= maxPenaltyRate &&\n\t\t\tnewPenaltyRate <= collateralAssets[collateral].valueToLoanRate.sub(fivePercentLiquidationGap) &&\n\t\t\tcollateralAssets[collateral].bonusRate <= newPenaltyRate,\n\t\t\t\"Rate should be in allowed range\"\n\t\t);\n\n\t\tuint256 currentTime = block.timestamp;\n\t\tif (\n\t\t\tcollateralAssets[collateral].penaltyUpdateTime != 0 &&\n\t\t\tnewPenaltyRate > collateralAssets[collateral].penaltyRate\n\t\t) {\n\t\t\tuint256 deltaTime = currentTime.sub(collateralAssets[collateral].penaltyUpdateTime);\n\t\t\trequire (deltaTime >= periodBetweenUpdates, \"Increasing rate is not allowed at this time\");\n\t\t\tuint256 maxIncrease = collateralAssets[collateral].penaltyRate.add(penaltyRateMaxIncrease);\n\t\t\trequire (newPenaltyRate <= maxIncrease, \"Rate should be increased less than max allowed\");\n\t\t}\n\n\t\temit PenaltyRateChanged(collateral, newPenaltyRate, collateralAssets[collateral].penaltyRate);\n\n\t    collateralAssets[collateral].penaltyRate  = newPenaltyRate;\n\t    collateralAssets[collateral].penaltyUpdateTime = currentTime;\n\t}\n\n\t\n\tfunction setBonusRateInternal (address collateral, uint256 newBonusRate) internal {\n\t\trequire (\n\t\t\tnewBonusRate <= collateralAssets[collateral].penaltyRate && newBonusRate >= rateDecimals,\n\t\t\t\"Rate should be in allowed range\"\n\t\t);\n\t\t\n\t\temit BonusRateChanged(collateral, newBonusRate, collateralAssets[collateral].bonusRate);\n\t    collateralAssets[collateral].bonusRate = newBonusRate;    \n\t}\n}",
        "function": "marketsList(uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/PeckShield-Holdefi/Holdefi-5a1e6e0d582120142e8a531f6806eba6665ef2f4/contracts/HoldefiSettings.sol",
        "vulnerability": "Exception State (SWC 110)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract StakingPool is Owned {\n    using SafeMath for uint256;\n    \n    Ierc20 public tswap;\n    Ierc20 public rewardToken;\n    uint256 poolDuration;\n    uint256 totalRewards;\n    uint256 rewardsWithdrawn;\n    uint256 poolStartTime;\n    uint256 poolEndTime;\n    uint256 totalStaked;\n    // Represents a single stake for a user. A user may have multiple.\n    struct Stake {\n        uint256 amount;\n        uint256 stakingTime;\n        uint256 lastWithdrawTime;\n    }\n    mapping (address => Stake[]) public userStaking;\n    \n    // Represents total staking of an user\n    struct UserTotals {\n        uint256 totalStaking;\n        uint256 totalStakingTIme;\n    }\n    mapping (address => UserTotals) public userTotalStaking;\n    \n    struct Ris3Rewards {\n        uint256 totalWithdrawn;\n        uint256 lastWithdrawTime;\n    }\n    mapping(address => Ris3Rewards) public userRewardInfo;\n    \n    event OwnerSetReward(uint256 amount);\n    event Staked(address userAddress, uint256 amount);\n    event StakingWithdrawal(address userAddress, uint256 amount);\n    event RewardWithdrawal(address userAddress, uint256 amount);\n    event PoolDurationChange(uint256 poolDuration);\n    \n    /**\n     * Constrctor function\n    */\n    constructor() public {\n        tswap = Ierc20(0xf823eA01D48F7Fb36b4b319f21dae404Ac86Bb8d);\n        rewardToken = Ierc20(0xdE55ea8232e0B1615d762eFCB17Cb2D7df164727);\n        poolDuration = 1 hours;\n    }\n    \n    //Set pool rewards\n    function ownerSetPoolRewards(uint256 _rewardAmount) external onlyOwner {\n        require(poolStartTime == 0, \"Pool rewards already set\");\n        require(_rewardAmount > 0, \"Cannot create pool with zero amount\");\n        \n        //set total rewards value\n        totalRewards = _rewardAmount;\n        \n        poolStartTime = now;\n        poolEndTime = now + poolDuration;\n        \n        //transfer tokens to contract\n        // SWC-104-Unchecked Call Return Value: L132\n        rewardToken.transferFrom(msg.sender, this, _rewardAmount);\n        emit OwnerSetReward(_rewardAmount);\n    }\n    \n    //Stake function for users to stake SWAP token\n    function stake(uint256 amount) external {\n        require(amount > 0, \"Cannot stake 0\");\n        require(now < poolEndTime, \"Staking pool is closed\"); //staking pool is closed for staking\n        \n        //add value in staking\n        userTotalStaking[msg.sender].totalStaking = userTotalStaking[msg.sender].totalStaking.add(amount);\n        \n        //add new stake\n        Stake memory newStake = Stake(amount, now, 0);\n        userStaking[msg.sender].push(newStake);\n        \n        //add to total staked\n        totalStaked = totalStaked.add(amount);\n        \n        tswap.transferFrom(msg.sender, this, amount);\n        emit Staked(msg.sender, amount);\n    }\n    \n    //compute rewards\n    function computeNewReward(uint256 _rewardAmount, uint256 _stakedAmount, uint256 _stakeTimeSec) private view returns (uint256 _reward) {\n        uint256 rewardPerSecond = totalRewards.mul(1 ether);\n        if (rewardPerSecond != 0 ) {\n            rewardPerSecond = rewardPerSecond.div(poolDuration);\n        }\n        \n        if (rewardPerSecond > 0) {\n            uint256 rewardPerSecForEachTokenStaked = rewardPerSecond.div(totalStaked);\n            uint256 userRewards = rewardPerSecForEachTokenStaked.mul(_stakedAmount).mul(_stakeTimeSec);\n                    userRewards = userRewards.div(1 ether);\n            \n            return _rewardAmount.add(userRewards);\n        } else {\n            return 0;\n        }\n    }\n    \n    //calculate your rewards\n    function calculateReward(address _userAddress) public view returns (uint256 _reward) {\n        // all user stakes\n        Stake[] storage accountStakes = userStaking[_userAddress];\n        \n        // Redeem from most recent stake and go backwards in time.\n        uint256 rewardAmount = 0;\n        uint256 i = accountStakes.length;\n        while (i > 0) {\n            Stake storage userStake = accountStakes[i - 1];\n            uint256 stakeTimeSec;\n            \n            //check if current time is more than pool ending time\n            if (now > poolEndTime) {\n                stakeTimeSec = poolEndTime.sub(userStake.stakingTime);\n                if(userStake.lastWithdrawTime != 0){\n                    stakeTimeSec = poolEndTime.sub(userStake.lastWithdrawTime);\n                }\n            } else {\n                stakeTimeSec = now.sub(userStake.stakingTime);\n                if(userStake.lastWithdrawTime != 0){\n                    stakeTimeSec = now.sub(userStake.lastWithdrawTime);\n                }\n            }\n            \n            // fully redeem a past stake\n            rewardAmount = computeNewReward(rewardAmount, userStake.amount, stakeTimeSec);\n            i--;\n        }\n        \n        return rewardAmount;\n    }\n    \n    //Withdraw staking and rewards\n    function withdrawStaking(uint256 amount) external {\n        require(amount > 0, \"Amount can not be zero\");\n        require(userTotalStaking[msg.sender].totalStaking >= amount, \"You are trying to withdaw more than your stake\");\n        \n        // 1. User Accounting\n        Stake[] storage accountStakes = userStaking[msg.sender];\n        \n        // Redeem from most recent stake and go backwards in time.\n        uint256 sharesLeftToBurn = amount;\n        uint256 rewardAmount = 0;\n        while (sharesLeftToBurn > 0) {\n            Stake storage lastStake = accountStakes[accountStakes.length - 1];\n            uint256 stakeTimeSec;\n            //check if current time is more than pool ending time\n            if (now > poolEndTime) {\n                stakeTimeSec = poolEndTime.sub(lastStake.stakingTime);\n                if(lastStake.lastWithdrawTime != 0){\n                    stakeTimeSec = poolEndTime.sub(lastStake.lastWithdrawTime);\n                }\n            } else {\n                stakeTimeSec = now.sub(lastStake.stakingTime);\n                if(lastStake.lastWithdrawTime != 0){\n                    stakeTimeSec = now.sub(lastStake.lastWithdrawTime);\n                }\n            }\n            \n            if (lastStake.amount <= sharesLeftToBurn) {\n                // fully redeem a past stake\n                rewardAmount = computeNewReward(rewardAmount, lastStake.amount, stakeTimeSec);\n                sharesLeftToBurn = sharesLeftToBurn.sub(lastStake.amount);\n                accountStakes.length--;\n            } else {\n                // partially redeem a past stake\n                rewardAmount = computeNewReward(rewardAmount, sharesLeftToBurn, stakeTimeSec);\n                lastStake.amount = lastStake.amount.sub(sharesLeftToBurn);\n                lastStake.lastWithdrawTime = now;\n                sharesLeftToBurn = 0;\n            }\n        }\n        \n        //substract value in staking\n        userTotalStaking[msg.sender].totalStaking = userTotalStaking[msg.sender].totalStaking.sub(amount);\n        \n        //substract from total staked\n        totalStaked = totalStaked.sub(amount);\n        \n        //update user rewards info\n        userRewardInfo[msg.sender].totalWithdrawn = userRewardInfo[msg.sender].totalWithdrawn.add(rewardAmount);\n        userRewardInfo[msg.sender].lastWithdrawTime = now;\n        \n        //update total rewards withdrawn\n        rewardsWithdrawn = rewardsWithdrawn.add(rewardAmount);\n        \n        //transfer rewards and tokens\n        // SWC-104-Unchecked Call Return Value: L262\n        rewardToken.transfer(msg.sender, rewardAmount);\n        tswap.transfer(msg.sender, amount);\n        \n        emit RewardWithdrawal(msg.sender, rewardAmount);\n        emit StakingWithdrawal(msg.sender, amount);\n    }\n    \n    //Withdraw rewards\n    function withdrawRewardsOnly() external {\n        uint256 _rwdAmount = calculateReward(msg.sender);\n        require(_rwdAmount > 0, \"You do not have enough rewards\");\n        \n        // 1. User Accounting\n        Stake[] storage accountStakes = userStaking[msg.sender];\n        \n        // Redeem from most recent stake and go backwards in time.\n        uint256 rewardAmount = 0;\n        uint256 i = accountStakes.length;\n        while (i > 0) {\n            Stake storage userStake = accountStakes[i - 1];\n            uint256 stakeTimeSec;\n            \n            //check if current time is more than pool ending time\n            if (now > poolEndTime) {\n                stakeTimeSec = poolEndTime.sub(userStake.stakingTime);\n                if(userStake.lastWithdrawTime != 0){\n                    stakeTimeSec = poolEndTime.sub(userStake.lastWithdrawTime);\n                }\n            } else {\n                stakeTimeSec = now.sub(userStake.stakingTime);\n                if(userStake.lastWithdrawTime != 0){\n                    stakeTimeSec = now.sub(userStake.lastWithdrawTime);\n                }\n            }\n            \n            // fully redeem a past stake\n            rewardAmount = computeNewReward(rewardAmount, userStake.amount, stakeTimeSec);\n            userStake.lastWithdrawTime = now;\n            i--;\n        }\n        \n        //update user rewards info\n        userRewardInfo[msg.sender].totalWithdrawn = userRewardInfo[msg.sender].totalWithdrawn.add(rewardAmount);\n        userRewardInfo[msg.sender].lastWithdrawTime = now;\n        \n        //update total rewards withdrawn\n        rewardsWithdrawn = rewardsWithdrawn.add(rewardAmount);\n        \n        //transfer rewards\n        rewardToken.transfer(msg.sender, rewardAmount);\n        emit RewardWithdrawal(msg.sender, rewardAmount);\n    }\n    \n    //get staking details by user address\n    function getStakingAmount(address _userAddress) external constant returns (uint256 _stakedAmount) {\n        return userTotalStaking[_userAddress].totalStaking;\n    }\n    \n    //get total rewards collected by user\n    function getTotalRewardCollectedByUser(address userAddress) view external returns (uint256 _totalRewardCollected) \n    {\n        return userRewardInfo[userAddress].totalWithdrawn;\n    }\n    \n    //get total SWAP token staked in the contract\n    function getTotalStaked() external constant returns ( uint256 _totalStaked) {\n        return totalStaked;\n    }\n    \n    //get total rewards in the contract\n    function getTotalRewards() external constant returns ( uint256 _totalRewards) {\n        return totalRewards;\n    }\n    \n    //get pool details\n    function getPoolDetails() external view returns (address _baseToken, address _pairedToken, uint256 _totalRewards, uint256 _rewardsWithdrawn, uint256 _poolStartTime, uint256 _poolEndTime) {\n        return (address(tswap),address(rewardToken),totalRewards,rewardsWithdrawn,poolStartTime,poolEndTime);\n    }\n    \n    //get duration of pools\n    function getPoolDuration() external constant returns (uint256 _poolDuration) {\n        return poolDuration;\n    }\n\n    //set duration of pools by owner in seconds\n    function setPoolDuration(uint256 _poolDuration) external onlyOwner {\n        poolDuration = _poolDuration;\n        poolEndTime = poolStartTime + _poolDuration;\n        emit PoolDurationChange(_poolDuration);\n    }\n    \n    //get SWAP token address\n    function getSwapAddress() external constant returns (address _swapAddress) {\n        return address(tswap);\n    }\n    \n    //set tswap address\n    function setTswapAddress(address _address) external onlyOwner {\n        tswap = Ierc20(_address);\n    }\n    \n    //set reward token address\n    function setRewardTokenAddress(address _address) external onlyOwner {\n        rewardToken = Ierc20(_address);\n    }\n    \n}",
        "function": "userStaking(address,uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Hacken-TrustSwap-V1/code/StakingPool.sol",
        "vulnerability": "Exception State (SWC 110)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract StakingPool is Owned {\n    using SafeMath for uint256;\n    \n    Ierc20 public tswap;\n    Ierc20 public rewardToken;\n    uint256 poolDuration;\n    uint256 totalRewards;\n    uint256 rewardsWithdrawn;\n    uint256 poolStartTime;\n    uint256 poolEndTime;\n    uint256 totalStaked;\n    // Represents a single stake for a user. A user may have multiple.\n    struct Stake {\n        uint256 amount;\n        uint256 stakingTime;\n        uint256 lastWithdrawTime;\n    }\n    mapping (address => Stake[]) public userStaking;\n    \n    // Represents total staking of an user\n    struct UserTotals {\n        uint256 totalStaking;\n        uint256 totalStakingTIme;\n    }\n    mapping (address => UserTotals) public userTotalStaking;\n    \n    struct Ris3Rewards {\n        uint256 totalWithdrawn;\n        uint256 lastWithdrawTime;\n    }\n    mapping(address => Ris3Rewards) public userRewardInfo;\n    \n    event OwnerSetReward(uint256 amount);\n    event Staked(address userAddress, uint256 amount);\n    event StakingWithdrawal(address userAddress, uint256 amount);\n    event RewardWithdrawal(address userAddress, uint256 amount);\n    event PoolDurationChange(uint256 poolDuration);\n    \n    /**\n     * Constrctor function\n    */\n    constructor() public {\n        tswap = Ierc20(0xf823eA01D48F7Fb36b4b319f21dae404Ac86Bb8d);\n        rewardToken = Ierc20(0xdE55ea8232e0B1615d762eFCB17Cb2D7df164727);\n        poolDuration = 1 hours;\n    }\n    \n    //Set pool rewards\n    function ownerSetPoolRewards(uint256 _rewardAmount) external onlyOwner {\n        require(poolStartTime == 0, \"Pool rewards already set\");\n        require(_rewardAmount > 0, \"Cannot create pool with zero amount\");\n        \n        //set total rewards value\n        totalRewards = _rewardAmount;\n        \n        poolStartTime = now;\n        poolEndTime = now + poolDuration;\n        \n        //transfer tokens to contract\n        // SWC-104-Unchecked Call Return Value: L132\n        rewardToken.transferFrom(msg.sender, this, _rewardAmount);\n        emit OwnerSetReward(_rewardAmount);\n    }\n    \n    //Stake function for users to stake SWAP token\n    function stake(uint256 amount) external {\n        require(amount > 0, \"Cannot stake 0\");\n        require(now < poolEndTime, \"Staking pool is closed\"); //staking pool is closed for staking\n        \n        //add value in staking\n        userTotalStaking[msg.sender].totalStaking = userTotalStaking[msg.sender].totalStaking.add(amount);\n        \n        //add new stake\n        Stake memory newStake = Stake(amount, now, 0);\n        userStaking[msg.sender].push(newStake);\n        \n        //add to total staked\n        totalStaked = totalStaked.add(amount);\n        \n        tswap.transferFrom(msg.sender, this, amount);\n        emit Staked(msg.sender, amount);\n    }\n    \n    //compute rewards\n    function computeNewReward(uint256 _rewardAmount, uint256 _stakedAmount, uint256 _stakeTimeSec) private view returns (uint256 _reward) {\n        uint256 rewardPerSecond = totalRewards.mul(1 ether);\n        if (rewardPerSecond != 0 ) {\n            rewardPerSecond = rewardPerSecond.div(poolDuration);\n        }\n        \n        if (rewardPerSecond > 0) {\n            uint256 rewardPerSecForEachTokenStaked = rewardPerSecond.div(totalStaked);\n            uint256 userRewards = rewardPerSecForEachTokenStaked.mul(_stakedAmount).mul(_stakeTimeSec);\n                    userRewards = userRewards.div(1 ether);\n            \n            return _rewardAmount.add(userRewards);\n        } else {\n            return 0;\n        }\n    }\n    \n    //calculate your rewards\n    function calculateReward(address _userAddress) public view returns (uint256 _reward) {\n        // all user stakes\n        Stake[] storage accountStakes = userStaking[_userAddress];\n        \n        // Redeem from most recent stake and go backwards in time.\n        uint256 rewardAmount = 0;\n        uint256 i = accountStakes.length;\n        while (i > 0) {\n            Stake storage userStake = accountStakes[i - 1];\n            uint256 stakeTimeSec;\n            \n            //check if current time is more than pool ending time\n            if (now > poolEndTime) {\n                stakeTimeSec = poolEndTime.sub(userStake.stakingTime);\n                if(userStake.lastWithdrawTime != 0){\n                    stakeTimeSec = poolEndTime.sub(userStake.lastWithdrawTime);\n                }\n            } else {\n                stakeTimeSec = now.sub(userStake.stakingTime);\n                if(userStake.lastWithdrawTime != 0){\n                    stakeTimeSec = now.sub(userStake.lastWithdrawTime);\n                }\n            }\n            \n            // fully redeem a past stake\n            rewardAmount = computeNewReward(rewardAmount, userStake.amount, stakeTimeSec);\n            i--;\n        }\n        \n        return rewardAmount;\n    }\n    \n    //Withdraw staking and rewards\n    function withdrawStaking(uint256 amount) external {\n        require(amount > 0, \"Amount can not be zero\");\n        require(userTotalStaking[msg.sender].totalStaking >= amount, \"You are trying to withdaw more than your stake\");\n        \n        // 1. User Accounting\n        Stake[] storage accountStakes = userStaking[msg.sender];\n        \n        // Redeem from most recent stake and go backwards in time.\n        uint256 sharesLeftToBurn = amount;\n        uint256 rewardAmount = 0;\n        while (sharesLeftToBurn > 0) {\n            Stake storage lastStake = accountStakes[accountStakes.length - 1];\n            uint256 stakeTimeSec;\n            //check if current time is more than pool ending time\n            if (now > poolEndTime) {\n                stakeTimeSec = poolEndTime.sub(lastStake.stakingTime);\n                if(lastStake.lastWithdrawTime != 0){\n                    stakeTimeSec = poolEndTime.sub(lastStake.lastWithdrawTime);\n                }\n            } else {\n                stakeTimeSec = now.sub(lastStake.stakingTime);\n                if(lastStake.lastWithdrawTime != 0){\n                    stakeTimeSec = now.sub(lastStake.lastWithdrawTime);\n                }\n            }\n            \n            if (lastStake.amount <= sharesLeftToBurn) {\n                // fully redeem a past stake\n                rewardAmount = computeNewReward(rewardAmount, lastStake.amount, stakeTimeSec);\n                sharesLeftToBurn = sharesLeftToBurn.sub(lastStake.amount);\n                accountStakes.length--;\n            } else {\n                // partially redeem a past stake\n                rewardAmount = computeNewReward(rewardAmount, sharesLeftToBurn, stakeTimeSec);\n                lastStake.amount = lastStake.amount.sub(sharesLeftToBurn);\n                lastStake.lastWithdrawTime = now;\n                sharesLeftToBurn = 0;\n            }\n        }\n        \n        //substract value in staking\n        userTotalStaking[msg.sender].totalStaking = userTotalStaking[msg.sender].totalStaking.sub(amount);\n        \n        //substract from total staked\n        totalStaked = totalStaked.sub(amount);\n        \n        //update user rewards info\n        userRewardInfo[msg.sender].totalWithdrawn = userRewardInfo[msg.sender].totalWithdrawn.add(rewardAmount);\n        userRewardInfo[msg.sender].lastWithdrawTime = now;\n        \n        //update total rewards withdrawn\n        rewardsWithdrawn = rewardsWithdrawn.add(rewardAmount);\n        \n        //transfer rewards and tokens\n        // SWC-104-Unchecked Call Return Value: L262\n        rewardToken.transfer(msg.sender, rewardAmount);\n        tswap.transfer(msg.sender, amount);\n        \n        emit RewardWithdrawal(msg.sender, rewardAmount);\n        emit StakingWithdrawal(msg.sender, amount);\n    }\n    \n    //Withdraw rewards\n    function withdrawRewardsOnly() external {\n        uint256 _rwdAmount = calculateReward(msg.sender);\n        require(_rwdAmount > 0, \"You do not have enough rewards\");\n        \n        // 1. User Accounting\n        Stake[] storage accountStakes = userStaking[msg.sender];\n        \n        // Redeem from most recent stake and go backwards in time.\n        uint256 rewardAmount = 0;\n        uint256 i = accountStakes.length;\n        while (i > 0) {\n            Stake storage userStake = accountStakes[i - 1];\n            uint256 stakeTimeSec;\n            \n            //check if current time is more than pool ending time\n            if (now > poolEndTime) {\n                stakeTimeSec = poolEndTime.sub(userStake.stakingTime);\n                if(userStake.lastWithdrawTime != 0){\n                    stakeTimeSec = poolEndTime.sub(userStake.lastWithdrawTime);\n                }\n            } else {\n                stakeTimeSec = now.sub(userStake.stakingTime);\n                if(userStake.lastWithdrawTime != 0){\n                    stakeTimeSec = now.sub(userStake.lastWithdrawTime);\n                }\n            }\n            \n            // fully redeem a past stake\n            rewardAmount = computeNewReward(rewardAmount, userStake.amount, stakeTimeSec);\n            userStake.lastWithdrawTime = now;\n            i--;\n        }\n        \n        //update user rewards info\n        userRewardInfo[msg.sender].totalWithdrawn = userRewardInfo[msg.sender].totalWithdrawn.add(rewardAmount);\n        userRewardInfo[msg.sender].lastWithdrawTime = now;\n        \n        //update total rewards withdrawn\n        rewardsWithdrawn = rewardsWithdrawn.add(rewardAmount);\n        \n        //transfer rewards\n        rewardToken.transfer(msg.sender, rewardAmount);\n        emit RewardWithdrawal(msg.sender, rewardAmount);\n    }\n    \n    //get staking details by user address\n    function getStakingAmount(address _userAddress) external constant returns (uint256 _stakedAmount) {\n        return userTotalStaking[_userAddress].totalStaking;\n    }\n    \n    //get total rewards collected by user\n    function getTotalRewardCollectedByUser(address userAddress) view external returns (uint256 _totalRewardCollected) \n    {\n        return userRewardInfo[userAddress].totalWithdrawn;\n    }\n    \n    //get total SWAP token staked in the contract\n    function getTotalStaked() external constant returns ( uint256 _totalStaked) {\n        return totalStaked;\n    }\n    \n    //get total rewards in the contract\n    function getTotalRewards() external constant returns ( uint256 _totalRewards) {\n        return totalRewards;\n    }\n    \n    //get pool details\n    function getPoolDetails() external view returns (address _baseToken, address _pairedToken, uint256 _totalRewards, uint256 _rewardsWithdrawn, uint256 _poolStartTime, uint256 _poolEndTime) {\n        return (address(tswap),address(rewardToken),totalRewards,rewardsWithdrawn,poolStartTime,poolEndTime);\n    }\n    \n    //get duration of pools\n    function getPoolDuration() external constant returns (uint256 _poolDuration) {\n        return poolDuration;\n    }\n\n    //set duration of pools by owner in seconds\n    function setPoolDuration(uint256 _poolDuration) external onlyOwner {\n        poolDuration = _poolDuration;\n        poolEndTime = poolStartTime + _poolDuration;\n        emit PoolDurationChange(_poolDuration);\n    }\n    \n    //get SWAP token address\n    function getSwapAddress() external constant returns (address _swapAddress) {\n        return address(tswap);\n    }\n    \n    //set tswap address\n    function setTswapAddress(address _address) external onlyOwner {\n        tswap = Ierc20(_address);\n    }\n    \n    //set reward token address\n    function setRewardTokenAddress(address _address) external onlyOwner {\n        rewardToken = Ierc20(_address);\n    }\n    \n}",
        "function": "stake(uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Hacken-TrustSwap-V1/code/StakingPool.sol",
        "vulnerability": "Dependence on predictable environment variable (SWC 116)",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract StakingPool is Owned {\n    using SafeMath for uint256;\n    \n    Ierc20 public tswap;\n    Ierc20 public rewardToken;\n    uint256 poolDuration;\n    uint256 totalRewards;\n    uint256 rewardsWithdrawn;\n    uint256 poolStartTime;\n    uint256 poolEndTime;\n    uint256 totalStaked;\n    // Represents a single stake for a user. A user may have multiple.\n    struct Stake {\n        uint256 amount;\n        uint256 stakingTime;\n        uint256 lastWithdrawTime;\n    }\n    mapping (address => Stake[]) public userStaking;\n    \n    // Represents total staking of an user\n    struct UserTotals {\n        uint256 totalStaking;\n        uint256 totalStakingTIme;\n    }\n    mapping (address => UserTotals) public userTotalStaking;\n    \n    struct Ris3Rewards {\n        uint256 totalWithdrawn;\n        uint256 lastWithdrawTime;\n    }\n    mapping(address => Ris3Rewards) public userRewardInfo;\n    \n    event OwnerSetReward(uint256 amount);\n    event Staked(address userAddress, uint256 amount);\n    event StakingWithdrawal(address userAddress, uint256 amount);\n    event RewardWithdrawal(address userAddress, uint256 amount);\n    event PoolDurationChange(uint256 poolDuration);\n    \n    /**\n     * Constrctor function\n    */\n    constructor() public {\n        tswap = Ierc20(0xf823eA01D48F7Fb36b4b319f21dae404Ac86Bb8d);\n        rewardToken = Ierc20(0xdE55ea8232e0B1615d762eFCB17Cb2D7df164727);\n        poolDuration = 1 hours;\n    }\n    \n    //Set pool rewards\n    function ownerSetPoolRewards(uint256 _rewardAmount) external onlyOwner {\n        require(poolStartTime == 0, \"Pool rewards already set\");\n        require(_rewardAmount > 0, \"Cannot create pool with zero amount\");\n        \n        //set total rewards value\n        totalRewards = _rewardAmount;\n        \n        poolStartTime = now;\n        poolEndTime = now + poolDuration;\n        \n        //transfer tokens to contract\n        // SWC-104-Unchecked Call Return Value: L132\n        rewardToken.transferFrom(msg.sender, this, _rewardAmount);\n        emit OwnerSetReward(_rewardAmount);\n    }\n    \n    //Stake function for users to stake SWAP token\n    function stake(uint256 amount) external {\n        require(amount > 0, \"Cannot stake 0\");\n        require(now < poolEndTime, \"Staking pool is closed\"); //staking pool is closed for staking\n        \n        //add value in staking\n        userTotalStaking[msg.sender].totalStaking = userTotalStaking[msg.sender].totalStaking.add(amount);\n        \n        //add new stake\n        Stake memory newStake = Stake(amount, now, 0);\n        userStaking[msg.sender].push(newStake);\n        \n        //add to total staked\n        totalStaked = totalStaked.add(amount);\n        \n        tswap.transferFrom(msg.sender, this, amount);\n        emit Staked(msg.sender, amount);\n    }\n    \n    //compute rewards\n    function computeNewReward(uint256 _rewardAmount, uint256 _stakedAmount, uint256 _stakeTimeSec) private view returns (uint256 _reward) {\n        uint256 rewardPerSecond = totalRewards.mul(1 ether);\n        if (rewardPerSecond != 0 ) {\n            rewardPerSecond = rewardPerSecond.div(poolDuration);\n        }\n        \n        if (rewardPerSecond > 0) {\n            uint256 rewardPerSecForEachTokenStaked = rewardPerSecond.div(totalStaked);\n            uint256 userRewards = rewardPerSecForEachTokenStaked.mul(_stakedAmount).mul(_stakeTimeSec);\n                    userRewards = userRewards.div(1 ether);\n            \n            return _rewardAmount.add(userRewards);\n        } else {\n            return 0;\n        }\n    }\n    \n    //calculate your rewards\n    function calculateReward(address _userAddress) public view returns (uint256 _reward) {\n        // all user stakes\n        Stake[] storage accountStakes = userStaking[_userAddress];\n        \n        // Redeem from most recent stake and go backwards in time.\n        uint256 rewardAmount = 0;\n        uint256 i = accountStakes.length;\n        while (i > 0) {\n            Stake storage userStake = accountStakes[i - 1];\n            uint256 stakeTimeSec;\n            \n            //check if current time is more than pool ending time\n            if (now > poolEndTime) {\n                stakeTimeSec = poolEndTime.sub(userStake.stakingTime);\n                if(userStake.lastWithdrawTime != 0){\n                    stakeTimeSec = poolEndTime.sub(userStake.lastWithdrawTime);\n                }\n            } else {\n                stakeTimeSec = now.sub(userStake.stakingTime);\n                if(userStake.lastWithdrawTime != 0){\n                    stakeTimeSec = now.sub(userStake.lastWithdrawTime);\n                }\n            }\n            \n            // fully redeem a past stake\n            rewardAmount = computeNewReward(rewardAmount, userStake.amount, stakeTimeSec);\n            i--;\n        }\n        \n        return rewardAmount;\n    }\n    \n    //Withdraw staking and rewards\n    function withdrawStaking(uint256 amount) external {\n        require(amount > 0, \"Amount can not be zero\");\n        require(userTotalStaking[msg.sender].totalStaking >= amount, \"You are trying to withdaw more than your stake\");\n        \n        // 1. User Accounting\n        Stake[] storage accountStakes = userStaking[msg.sender];\n        \n        // Redeem from most recent stake and go backwards in time.\n        uint256 sharesLeftToBurn = amount;\n        uint256 rewardAmount = 0;\n        while (sharesLeftToBurn > 0) {\n            Stake storage lastStake = accountStakes[accountStakes.length - 1];\n            uint256 stakeTimeSec;\n            //check if current time is more than pool ending time\n            if (now > poolEndTime) {\n                stakeTimeSec = poolEndTime.sub(lastStake.stakingTime);\n                if(lastStake.lastWithdrawTime != 0){\n                    stakeTimeSec = poolEndTime.sub(lastStake.lastWithdrawTime);\n                }\n            } else {\n                stakeTimeSec = now.sub(lastStake.stakingTime);\n                if(lastStake.lastWithdrawTime != 0){\n                    stakeTimeSec = now.sub(lastStake.lastWithdrawTime);\n                }\n            }\n            \n            if (lastStake.amount <= sharesLeftToBurn) {\n                // fully redeem a past stake\n                rewardAmount = computeNewReward(rewardAmount, lastStake.amount, stakeTimeSec);\n                sharesLeftToBurn = sharesLeftToBurn.sub(lastStake.amount);\n                accountStakes.length--;\n            } else {\n                // partially redeem a past stake\n                rewardAmount = computeNewReward(rewardAmount, sharesLeftToBurn, stakeTimeSec);\n                lastStake.amount = lastStake.amount.sub(sharesLeftToBurn);\n                lastStake.lastWithdrawTime = now;\n                sharesLeftToBurn = 0;\n            }\n        }\n        \n        //substract value in staking\n        userTotalStaking[msg.sender].totalStaking = userTotalStaking[msg.sender].totalStaking.sub(amount);\n        \n        //substract from total staked\n        totalStaked = totalStaked.sub(amount);\n        \n        //update user rewards info\n        userRewardInfo[msg.sender].totalWithdrawn = userRewardInfo[msg.sender].totalWithdrawn.add(rewardAmount);\n        userRewardInfo[msg.sender].lastWithdrawTime = now;\n        \n        //update total rewards withdrawn\n        rewardsWithdrawn = rewardsWithdrawn.add(rewardAmount);\n        \n        //transfer rewards and tokens\n        // SWC-104-Unchecked Call Return Value: L262\n        rewardToken.transfer(msg.sender, rewardAmount);\n        tswap.transfer(msg.sender, amount);\n        \n        emit RewardWithdrawal(msg.sender, rewardAmount);\n        emit StakingWithdrawal(msg.sender, amount);\n    }\n    \n    //Withdraw rewards\n    function withdrawRewardsOnly() external {\n        uint256 _rwdAmount = calculateReward(msg.sender);\n        require(_rwdAmount > 0, \"You do not have enough rewards\");\n        \n        // 1. User Accounting\n        Stake[] storage accountStakes = userStaking[msg.sender];\n        \n        // Redeem from most recent stake and go backwards in time.\n        uint256 rewardAmount = 0;\n        uint256 i = accountStakes.length;\n        while (i > 0) {\n            Stake storage userStake = accountStakes[i - 1];\n            uint256 stakeTimeSec;\n            \n            //check if current time is more than pool ending time\n            if (now > poolEndTime) {\n                stakeTimeSec = poolEndTime.sub(userStake.stakingTime);\n                if(userStake.lastWithdrawTime != 0){\n                    stakeTimeSec = poolEndTime.sub(userStake.lastWithdrawTime);\n                }\n            } else {\n                stakeTimeSec = now.sub(userStake.stakingTime);\n                if(userStake.lastWithdrawTime != 0){\n                    stakeTimeSec = now.sub(userStake.lastWithdrawTime);\n                }\n            }\n            \n            // fully redeem a past stake\n            rewardAmount = computeNewReward(rewardAmount, userStake.amount, stakeTimeSec);\n            userStake.lastWithdrawTime = now;\n            i--;\n        }\n        \n        //update user rewards info\n        userRewardInfo[msg.sender].totalWithdrawn = userRewardInfo[msg.sender].totalWithdrawn.add(rewardAmount);\n        userRewardInfo[msg.sender].lastWithdrawTime = now;\n        \n        //update total rewards withdrawn\n        rewardsWithdrawn = rewardsWithdrawn.add(rewardAmount);\n        \n        //transfer rewards\n        rewardToken.transfer(msg.sender, rewardAmount);\n        emit RewardWithdrawal(msg.sender, rewardAmount);\n    }\n    \n    //get staking details by user address\n    function getStakingAmount(address _userAddress) external constant returns (uint256 _stakedAmount) {\n        return userTotalStaking[_userAddress].totalStaking;\n    }\n    \n    //get total rewards collected by user\n    function getTotalRewardCollectedByUser(address userAddress) view external returns (uint256 _totalRewardCollected) \n    {\n        return userRewardInfo[userAddress].totalWithdrawn;\n    }\n    \n    //get total SWAP token staked in the contract\n    function getTotalStaked() external constant returns ( uint256 _totalStaked) {\n        return totalStaked;\n    }\n    \n    //get total rewards in the contract\n    function getTotalRewards() external constant returns ( uint256 _totalRewards) {\n        return totalRewards;\n    }\n    \n    //get pool details\n    function getPoolDetails() external view returns (address _baseToken, address _pairedToken, uint256 _totalRewards, uint256 _rewardsWithdrawn, uint256 _poolStartTime, uint256 _poolEndTime) {\n        return (address(tswap),address(rewardToken),totalRewards,rewardsWithdrawn,poolStartTime,poolEndTime);\n    }\n    \n    //get duration of pools\n    function getPoolDuration() external constant returns (uint256 _poolDuration) {\n        return poolDuration;\n    }\n\n    //set duration of pools by owner in seconds\n    function setPoolDuration(uint256 _poolDuration) external onlyOwner {\n        poolDuration = _poolDuration;\n        poolEndTime = poolStartTime + _poolDuration;\n        emit PoolDurationChange(_poolDuration);\n    }\n    \n    //get SWAP token address\n    function getSwapAddress() external constant returns (address _swapAddress) {\n        return address(tswap);\n    }\n    \n    //set tswap address\n    function setTswapAddress(address _address) external onlyOwner {\n        tswap = Ierc20(_address);\n    }\n    \n    //set reward token address\n    function setRewardTokenAddress(address _address) external onlyOwner {\n        rewardToken = Ierc20(_address);\n    }\n    \n}",
        "function": "ownerSetPoolRewards(uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Hacken-TrustSwap-V1/code/StakingPool.sol",
        "vulnerability": "Integer Arithmetic Bugs (SWC 101)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract StakingPool is Owned {\n    using SafeMath for uint256;\n    \n    Ierc20 public tswap;\n    Ierc20 public rewardToken;\n    uint256 poolDuration;\n    uint256 totalRewards;\n    uint256 rewardsWithdrawn;\n    uint256 poolStartTime;\n    uint256 poolEndTime;\n    uint256 totalStaked;\n    // Represents a single stake for a user. A user may have multiple.\n    struct Stake {\n        uint256 amount;\n        uint256 stakingTime;\n        uint256 lastWithdrawTime;\n    }\n    mapping (address => Stake[]) public userStaking;\n    \n    // Represents total staking of an user\n    struct UserTotals {\n        uint256 totalStaking;\n        uint256 totalStakingTIme;\n    }\n    mapping (address => UserTotals) public userTotalStaking;\n    \n    struct Ris3Rewards {\n        uint256 totalWithdrawn;\n        uint256 lastWithdrawTime;\n    }\n    mapping(address => Ris3Rewards) public userRewardInfo;\n    \n    event OwnerSetReward(uint256 amount);\n    event Staked(address userAddress, uint256 amount);\n    event StakingWithdrawal(address userAddress, uint256 amount);\n    event RewardWithdrawal(address userAddress, uint256 amount);\n    event PoolDurationChange(uint256 poolDuration);\n    \n    /**\n     * Constrctor function\n    */\n    constructor() public {\n        tswap = Ierc20(0xf823eA01D48F7Fb36b4b319f21dae404Ac86Bb8d);\n        rewardToken = Ierc20(0xdE55ea8232e0B1615d762eFCB17Cb2D7df164727);\n        poolDuration = 1 hours;\n    }\n    \n    //Set pool rewards\n    function ownerSetPoolRewards(uint256 _rewardAmount) external onlyOwner {\n        require(poolStartTime == 0, \"Pool rewards already set\");\n        require(_rewardAmount > 0, \"Cannot create pool with zero amount\");\n        \n        //set total rewards value\n        totalRewards = _rewardAmount;\n        \n        poolStartTime = now;\n        poolEndTime = now + poolDuration;\n        \n        //transfer tokens to contract\n        // SWC-104-Unchecked Call Return Value: L132\n        rewardToken.transferFrom(msg.sender, this, _rewardAmount);\n        emit OwnerSetReward(_rewardAmount);\n    }\n    \n    //Stake function for users to stake SWAP token\n    function stake(uint256 amount) external {\n        require(amount > 0, \"Cannot stake 0\");\n        require(now < poolEndTime, \"Staking pool is closed\"); //staking pool is closed for staking\n        \n        //add value in staking\n        userTotalStaking[msg.sender].totalStaking = userTotalStaking[msg.sender].totalStaking.add(amount);\n        \n        //add new stake\n        Stake memory newStake = Stake(amount, now, 0);\n        userStaking[msg.sender].push(newStake);\n        \n        //add to total staked\n        totalStaked = totalStaked.add(amount);\n        \n        tswap.transferFrom(msg.sender, this, amount);\n        emit Staked(msg.sender, amount);\n    }\n    \n    //compute rewards\n    function computeNewReward(uint256 _rewardAmount, uint256 _stakedAmount, uint256 _stakeTimeSec) private view returns (uint256 _reward) {\n        uint256 rewardPerSecond = totalRewards.mul(1 ether);\n        if (rewardPerSecond != 0 ) {\n            rewardPerSecond = rewardPerSecond.div(poolDuration);\n        }\n        \n        if (rewardPerSecond > 0) {\n            uint256 rewardPerSecForEachTokenStaked = rewardPerSecond.div(totalStaked);\n            uint256 userRewards = rewardPerSecForEachTokenStaked.mul(_stakedAmount).mul(_stakeTimeSec);\n                    userRewards = userRewards.div(1 ether);\n            \n            return _rewardAmount.add(userRewards);\n        } else {\n            return 0;\n        }\n    }\n    \n    //calculate your rewards\n    function calculateReward(address _userAddress) public view returns (uint256 _reward) {\n        // all user stakes\n        Stake[] storage accountStakes = userStaking[_userAddress];\n        \n        // Redeem from most recent stake and go backwards in time.\n        uint256 rewardAmount = 0;\n        uint256 i = accountStakes.length;\n        while (i > 0) {\n            Stake storage userStake = accountStakes[i - 1];\n            uint256 stakeTimeSec;\n            \n            //check if current time is more than pool ending time\n            if (now > poolEndTime) {\n                stakeTimeSec = poolEndTime.sub(userStake.stakingTime);\n                if(userStake.lastWithdrawTime != 0){\n                    stakeTimeSec = poolEndTime.sub(userStake.lastWithdrawTime);\n                }\n            } else {\n                stakeTimeSec = now.sub(userStake.stakingTime);\n                if(userStake.lastWithdrawTime != 0){\n                    stakeTimeSec = now.sub(userStake.lastWithdrawTime);\n                }\n            }\n            \n            // fully redeem a past stake\n            rewardAmount = computeNewReward(rewardAmount, userStake.amount, stakeTimeSec);\n            i--;\n        }\n        \n        return rewardAmount;\n    }\n    \n    //Withdraw staking and rewards\n    function withdrawStaking(uint256 amount) external {\n        require(amount > 0, \"Amount can not be zero\");\n        require(userTotalStaking[msg.sender].totalStaking >= amount, \"You are trying to withdaw more than your stake\");\n        \n        // 1. User Accounting\n        Stake[] storage accountStakes = userStaking[msg.sender];\n        \n        // Redeem from most recent stake and go backwards in time.\n        uint256 sharesLeftToBurn = amount;\n        uint256 rewardAmount = 0;\n        while (sharesLeftToBurn > 0) {\n            Stake storage lastStake = accountStakes[accountStakes.length - 1];\n            uint256 stakeTimeSec;\n            //check if current time is more than pool ending time\n            if (now > poolEndTime) {\n                stakeTimeSec = poolEndTime.sub(lastStake.stakingTime);\n                if(lastStake.lastWithdrawTime != 0){\n                    stakeTimeSec = poolEndTime.sub(lastStake.lastWithdrawTime);\n                }\n            } else {\n                stakeTimeSec = now.sub(lastStake.stakingTime);\n                if(lastStake.lastWithdrawTime != 0){\n                    stakeTimeSec = now.sub(lastStake.lastWithdrawTime);\n                }\n            }\n            \n            if (lastStake.amount <= sharesLeftToBurn) {\n                // fully redeem a past stake\n                rewardAmount = computeNewReward(rewardAmount, lastStake.amount, stakeTimeSec);\n                sharesLeftToBurn = sharesLeftToBurn.sub(lastStake.amount);\n                accountStakes.length--;\n            } else {\n                // partially redeem a past stake\n                rewardAmount = computeNewReward(rewardAmount, sharesLeftToBurn, stakeTimeSec);\n                lastStake.amount = lastStake.amount.sub(sharesLeftToBurn);\n                lastStake.lastWithdrawTime = now;\n                sharesLeftToBurn = 0;\n            }\n        }\n        \n        //substract value in staking\n        userTotalStaking[msg.sender].totalStaking = userTotalStaking[msg.sender].totalStaking.sub(amount);\n        \n        //substract from total staked\n        totalStaked = totalStaked.sub(amount);\n        \n        //update user rewards info\n        userRewardInfo[msg.sender].totalWithdrawn = userRewardInfo[msg.sender].totalWithdrawn.add(rewardAmount);\n        userRewardInfo[msg.sender].lastWithdrawTime = now;\n        \n        //update total rewards withdrawn\n        rewardsWithdrawn = rewardsWithdrawn.add(rewardAmount);\n        \n        //transfer rewards and tokens\n        // SWC-104-Unchecked Call Return Value: L262\n        rewardToken.transfer(msg.sender, rewardAmount);\n        tswap.transfer(msg.sender, amount);\n        \n        emit RewardWithdrawal(msg.sender, rewardAmount);\n        emit StakingWithdrawal(msg.sender, amount);\n    }\n    \n    //Withdraw rewards\n    function withdrawRewardsOnly() external {\n        uint256 _rwdAmount = calculateReward(msg.sender);\n        require(_rwdAmount > 0, \"You do not have enough rewards\");\n        \n        // 1. User Accounting\n        Stake[] storage accountStakes = userStaking[msg.sender];\n        \n        // Redeem from most recent stake and go backwards in time.\n        uint256 rewardAmount = 0;\n        uint256 i = accountStakes.length;\n        while (i > 0) {\n            Stake storage userStake = accountStakes[i - 1];\n            uint256 stakeTimeSec;\n            \n            //check if current time is more than pool ending time\n            if (now > poolEndTime) {\n                stakeTimeSec = poolEndTime.sub(userStake.stakingTime);\n                if(userStake.lastWithdrawTime != 0){\n                    stakeTimeSec = poolEndTime.sub(userStake.lastWithdrawTime);\n                }\n            } else {\n                stakeTimeSec = now.sub(userStake.stakingTime);\n                if(userStake.lastWithdrawTime != 0){\n                    stakeTimeSec = now.sub(userStake.lastWithdrawTime);\n                }\n            }\n            \n            // fully redeem a past stake\n            rewardAmount = computeNewReward(rewardAmount, userStake.amount, stakeTimeSec);\n            userStake.lastWithdrawTime = now;\n            i--;\n        }\n        \n        //update user rewards info\n        userRewardInfo[msg.sender].totalWithdrawn = userRewardInfo[msg.sender].totalWithdrawn.add(rewardAmount);\n        userRewardInfo[msg.sender].lastWithdrawTime = now;\n        \n        //update total rewards withdrawn\n        rewardsWithdrawn = rewardsWithdrawn.add(rewardAmount);\n        \n        //transfer rewards\n        rewardToken.transfer(msg.sender, rewardAmount);\n        emit RewardWithdrawal(msg.sender, rewardAmount);\n    }\n    \n    //get staking details by user address\n    function getStakingAmount(address _userAddress) external constant returns (uint256 _stakedAmount) {\n        return userTotalStaking[_userAddress].totalStaking;\n    }\n    \n    //get total rewards collected by user\n    function getTotalRewardCollectedByUser(address userAddress) view external returns (uint256 _totalRewardCollected) \n    {\n        return userRewardInfo[userAddress].totalWithdrawn;\n    }\n    \n    //get total SWAP token staked in the contract\n    function getTotalStaked() external constant returns ( uint256 _totalStaked) {\n        return totalStaked;\n    }\n    \n    //get total rewards in the contract\n    function getTotalRewards() external constant returns ( uint256 _totalRewards) {\n        return totalRewards;\n    }\n    \n    //get pool details\n    function getPoolDetails() external view returns (address _baseToken, address _pairedToken, uint256 _totalRewards, uint256 _rewardsWithdrawn, uint256 _poolStartTime, uint256 _poolEndTime) {\n        return (address(tswap),address(rewardToken),totalRewards,rewardsWithdrawn,poolStartTime,poolEndTime);\n    }\n    \n    //get duration of pools\n    function getPoolDuration() external constant returns (uint256 _poolDuration) {\n        return poolDuration;\n    }\n\n    //set duration of pools by owner in seconds\n    function setPoolDuration(uint256 _poolDuration) external onlyOwner {\n        poolDuration = _poolDuration;\n        poolEndTime = poolStartTime + _poolDuration;\n        emit PoolDurationChange(_poolDuration);\n    }\n    \n    //get SWAP token address\n    function getSwapAddress() external constant returns (address _swapAddress) {\n        return address(tswap);\n    }\n    \n    //set tswap address\n    function setTswapAddress(address _address) external onlyOwner {\n        tswap = Ierc20(_address);\n    }\n    \n    //set reward token address\n    function setRewardTokenAddress(address _address) external onlyOwner {\n        rewardToken = Ierc20(_address);\n    }\n    \n}",
        "function": "ownerSetPoolRewards(uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Hacken-TrustSwap-V1/code/StakingPool.sol",
        "vulnerability": "External Call To User-Supplied Address (SWC 107)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract BaseFilterV1 is InitializableOwnable, ReentrancyGuard {\n    using SafeMath for uint256;\n\n    //=================== Storage ===================\n    address public _NFT_COLLECTION_;\n    uint256 public _NFT_ID_START_;\n    uint256 public _NFT_ID_END_ = uint256(-1);\n\n    //tokenId => isRegistered\n    mapping(uint256 => bool) public _SPREAD_IDS_REGISTRY_;\n\n    //tokenId => amount\n    mapping(uint256 => uint256) public _NFT_RESERVE_;\n\n    uint256[] public _NFT_IDS_;\n    uint256 public _TOTAL_NFT_AMOUNT_;\n    uint256 public _MAX_NFT_AMOUNT_;\n    uint256 public _MIN_NFT_AMOUNT_;\n\n    // GS -> Geometric sequence\n    // CR -> Common Ratio\n\n    //For Deposit NFT INto Pool\n    uint256 public _GS_START_IN_;\n    uint256 public _CR_IN_;\n    bool public _NFT_IN_TOGGLE_ = false;\n\n    //For NFT Random OUT from Pool\n    uint256 public _GS_START_RANDOM_OUT_;\n    uint256 public _CR_RANDOM_OUT_;\n    bool public _NFT_RANDOM_OUT_TOGGLE_ = false;\n\n    //For NFT Target OUT from Pool\n    uint256 public _GS_START_TARGET_OUT_;\n    uint256 public _CR_TARGET_OUT_;\n    bool public _NFT_TARGET_OUT_TOGGLE_ = false;\n\n    modifier onlySuperOwner() {\n        require(msg.sender == IFilterAdmin(_OWNER_)._OWNER_(), \"ONLY_SUPER_OWNER\");\n        _;\n    }\n\n    //==================== Query Prop ==================\n\n    function isNFTValid(address nftCollectionAddress, uint256 nftId) external view returns (bool) {\n        if (nftCollectionAddress == _NFT_COLLECTION_) {\n            return isNFTIDValid(nftId);\n        } else {\n            return false;\n        }\n    }\n\n    function isNFTIDValid(uint256 nftId) public view returns (bool) {\n        return (nftId >= _NFT_ID_START_ && nftId <= _NFT_ID_END_) || _SPREAD_IDS_REGISTRY_[nftId];\n    }\n\n    function getAvaliableNFTInAmount() public view returns (uint256) {\n        if (_MAX_NFT_AMOUNT_ <= _TOTAL_NFT_AMOUNT_) {\n            return 0;\n        } else {\n            return _MAX_NFT_AMOUNT_ - _TOTAL_NFT_AMOUNT_;\n        }\n    }\n\n    function getAvaliableNFTOutAmount() public view returns (uint256) {\n        if (_TOTAL_NFT_AMOUNT_ <= _MIN_NFT_AMOUNT_) {\n            return 0;\n        } else {\n            return _TOTAL_NFT_AMOUNT_ - _MIN_NFT_AMOUNT_;\n        }\n    }\n\n    function getNFTIndexById(uint256 tokenId) public view returns (uint256) {\n        uint256 i = 0;\n        for (; i < _NFT_IDS_.length; i++) {\n            if (_NFT_IDS_[i] == tokenId) break;\n        }\n        require(i < _NFT_IDS_.length, \"TOKEN_ID_NOT_EXSIT\");\n        return i;\n    }\n\n    //==================== Query Price ==================\n\n    function queryNFTIn(uint256 NFTInAmount)\n        public\n        view\n        returns (\n            uint256 rawReceive, \n            uint256 received\n        )\n    {\n        require(NFTInAmount <= getAvaliableNFTInAmount(), \"EXCEDD_IN_AMOUNT\");\n        rawReceive = _geometricCalc(\n            _GS_START_IN_,\n            _CR_IN_,\n            _TOTAL_NFT_AMOUNT_,\n            _TOTAL_NFT_AMOUNT_ + NFTInAmount\n        );\n        (,, received) = IFilterAdmin(_OWNER_).queryMintFee(rawReceive);\n    }\n\n    function queryNFTTargetOut(uint256 NFTOutAmount)\n        public\n        view\n        returns (\n            uint256 rawPay, \n            uint256 pay\n        )\n    {\n        require(NFTOutAmount <= getAvaliableNFTOutAmount(), \"EXCEED_OUT_AMOUNT\");\n        rawPay = _geometricCalc(\n            _GS_START_TARGET_OUT_,\n            _CR_TARGET_OUT_,\n            _TOTAL_NFT_AMOUNT_ - NFTOutAmount,\n            _TOTAL_NFT_AMOUNT_\n        );\n        (,, pay) = IFilterAdmin(_OWNER_).queryBurnFee(rawPay);\n    }\n\n    function queryNFTRandomOut(uint256 NFTOutAmount)\n        public\n        view\n        returns (\n            uint256 rawPay, \n            uint256 pay\n        )\n    {\n        require(NFTOutAmount <= getAvaliableNFTOutAmount(), \"EXCEED_OUT_AMOUNT\");\n        rawPay = _geometricCalc(\n            _GS_START_RANDOM_OUT_,\n            _CR_RANDOM_OUT_,\n            _TOTAL_NFT_AMOUNT_ - NFTOutAmount,\n            _TOTAL_NFT_AMOUNT_\n        );\n        (,, pay) = IFilterAdmin(_OWNER_).queryBurnFee(rawPay);\n    }\n\n    // ============ Math =============\n\n    function _geometricCalc(\n        uint256 a1,\n        uint256 q,\n        uint256 start,\n        uint256 end\n    ) internal view returns (uint256) {\n        if (q == DecimalMath.ONE) {\n            return end.sub(start).mul(a1);\n        }\n        //Sn=a1*(q^n-1)/(q-1)\n        //Sn-Sm = a1*(q^n-q^m)/(q-1)\n\n        //q^n\n        uint256 qn = DecimalMath.powFloor(q, end);\n        //q^m\n        uint256 qm = DecimalMath.powFloor(q, start);\n        return a1.mul(qn.sub(qm)).div(q.sub(DecimalMath.ONE));\n    }\n    // SWC-120-Weak Sources of Randomness from Chain Attributes: L175\n    function _getRandomNum() public view returns (uint256 randomNum) {\n        randomNum = uint256(\n            keccak256(abi.encodePacked(tx.origin, blockhash(block.number - 1), gasleft()))\n        );\n    }\n\n    // ================= Ownable ================\n\n    function changeNFTInPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) external onlySuperOwner {\n        _changeNFTInPrice(newGsStart, newCr, toggleFlag);\n    }\n\n    function _changeNFTInPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) internal {\n        require(newCr > DecimalMath.ONE, \"CR_INVALID\");\n        _GS_START_IN_ = newGsStart;\n        _CR_IN_ = newCr;\n        _NFT_IN_TOGGLE_ = true;\n    }\n\n    function changeNFTRandomInPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) external onlySuperOwner {\n        _changeNFTRandomInPrice(newGsStart, newCr, toggleFlag);\n    }\n\n    function _changeNFTRandomInPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) internal {\n        require(newCr > DecimalMath.ONE, \"CR_INVALID\");\n        _GS_START_RANDOM_OUT_ = newGsStart;\n        _CR_RANDOM_OUT_ = newCr;\n        _NFT_RANDOM_OUT_TOGGLE_ = true;\n    }\n\n    function changeNFTTargetOutPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) external onlySuperOwner {\n        _changeNFTTargetOutPrice(newGsStart, newCr, toggleFlag);\n    }\n\n    function _changeNFTTargetOutPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) internal {\n        require(newCr > DecimalMath.ONE, \"CR_INVALID\");\n        _GS_START_TARGET_OUT_ = newGsStart;\n        _CR_TARGET_OUT_ = newCr;\n        _NFT_TARGET_OUT_TOGGLE_ = true;\n    }\n\n    function changeNFTAmountRange(uint256 maxNFTAmount, uint256 minNFTAmount)\n        external\n        onlySuperOwner\n    {\n        _changeNFTAmountRange(maxNFTAmount, minNFTAmount);\n    }\n\n    function _changeNFTAmountRange(uint256 maxNFTAmount, uint256 minNFTAmount) internal {\n        require(maxNFTAmount >= minNFTAmount, \"AMOUNT_INVALID\");\n        _MAX_NFT_AMOUNT_ = maxNFTAmount;\n        _MIN_NFT_AMOUNT_ = minNFTAmount;\n    }\n\n    function changeTokenIdRange(uint256 nftIdStart, uint256 nftIdEnd) external onlySuperOwner {\n        _changeTokenIdRange(nftIdStart, nftIdEnd);\n    }\n\n    function _changeTokenIdRange(uint256 nftIdStart, uint256 nftIdEnd) internal {\n        require(nftIdStart <= nftIdEnd, \"TOKEN_RANGE_INVALID\");\n\n        _NFT_ID_START_ = nftIdStart;\n        _NFT_ID_END_ = nftIdEnd;\n    }\n\n    function changeTokenIdMap(uint256[] memory tokenIds, bool[] memory isRegistered)\n        external\n        onlySuperOwner\n    {\n        _changeTokenIdMap(tokenIds, isRegistered);\n    }\n\n    function _changeTokenIdMap(uint256[] memory tokenIds, bool[] memory isRegistered) internal {\n        require(tokenIds.length == isRegistered.length, \"PARAM_NOT_MATCH\");\n\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            _SPREAD_IDS_REGISTRY_[tokenIds[i]] = isRegistered[i];\n        }\n    }\n}",
        "function": "changeTokenIdRange(uint256,uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/SlowMist-DODO-NFTPool Smart Contract Security Audit Report/contractV2-e16ceb038ed6bf070ea75d9359c7ad54e6f3e226/contracts/NFTPool/impl/BaseFilterV1.sol",
        "vulnerability": "External Call To User-Supplied Address (SWC 107)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract BaseFilterV1 is InitializableOwnable, ReentrancyGuard {\n    using SafeMath for uint256;\n\n    //=================== Storage ===================\n    address public _NFT_COLLECTION_;\n    uint256 public _NFT_ID_START_;\n    uint256 public _NFT_ID_END_ = uint256(-1);\n\n    //tokenId => isRegistered\n    mapping(uint256 => bool) public _SPREAD_IDS_REGISTRY_;\n\n    //tokenId => amount\n    mapping(uint256 => uint256) public _NFT_RESERVE_;\n\n    uint256[] public _NFT_IDS_;\n    uint256 public _TOTAL_NFT_AMOUNT_;\n    uint256 public _MAX_NFT_AMOUNT_;\n    uint256 public _MIN_NFT_AMOUNT_;\n\n    // GS -> Geometric sequence\n    // CR -> Common Ratio\n\n    //For Deposit NFT INto Pool\n    uint256 public _GS_START_IN_;\n    uint256 public _CR_IN_;\n    bool public _NFT_IN_TOGGLE_ = false;\n\n    //For NFT Random OUT from Pool\n    uint256 public _GS_START_RANDOM_OUT_;\n    uint256 public _CR_RANDOM_OUT_;\n    bool public _NFT_RANDOM_OUT_TOGGLE_ = false;\n\n    //For NFT Target OUT from Pool\n    uint256 public _GS_START_TARGET_OUT_;\n    uint256 public _CR_TARGET_OUT_;\n    bool public _NFT_TARGET_OUT_TOGGLE_ = false;\n\n    modifier onlySuperOwner() {\n        require(msg.sender == IFilterAdmin(_OWNER_)._OWNER_(), \"ONLY_SUPER_OWNER\");\n        _;\n    }\n\n    //==================== Query Prop ==================\n\n    function isNFTValid(address nftCollectionAddress, uint256 nftId) external view returns (bool) {\n        if (nftCollectionAddress == _NFT_COLLECTION_) {\n            return isNFTIDValid(nftId);\n        } else {\n            return false;\n        }\n    }\n\n    function isNFTIDValid(uint256 nftId) public view returns (bool) {\n        return (nftId >= _NFT_ID_START_ && nftId <= _NFT_ID_END_) || _SPREAD_IDS_REGISTRY_[nftId];\n    }\n\n    function getAvaliableNFTInAmount() public view returns (uint256) {\n        if (_MAX_NFT_AMOUNT_ <= _TOTAL_NFT_AMOUNT_) {\n            return 0;\n        } else {\n            return _MAX_NFT_AMOUNT_ - _TOTAL_NFT_AMOUNT_;\n        }\n    }\n\n    function getAvaliableNFTOutAmount() public view returns (uint256) {\n        if (_TOTAL_NFT_AMOUNT_ <= _MIN_NFT_AMOUNT_) {\n            return 0;\n        } else {\n            return _TOTAL_NFT_AMOUNT_ - _MIN_NFT_AMOUNT_;\n        }\n    }\n\n    function getNFTIndexById(uint256 tokenId) public view returns (uint256) {\n        uint256 i = 0;\n        for (; i < _NFT_IDS_.length; i++) {\n            if (_NFT_IDS_[i] == tokenId) break;\n        }\n        require(i < _NFT_IDS_.length, \"TOKEN_ID_NOT_EXSIT\");\n        return i;\n    }\n\n    //==================== Query Price ==================\n\n    function queryNFTIn(uint256 NFTInAmount)\n        public\n        view\n        returns (\n            uint256 rawReceive, \n            uint256 received\n        )\n    {\n        require(NFTInAmount <= getAvaliableNFTInAmount(), \"EXCEDD_IN_AMOUNT\");\n        rawReceive = _geometricCalc(\n            _GS_START_IN_,\n            _CR_IN_,\n            _TOTAL_NFT_AMOUNT_,\n            _TOTAL_NFT_AMOUNT_ + NFTInAmount\n        );\n        (,, received) = IFilterAdmin(_OWNER_).queryMintFee(rawReceive);\n    }\n\n    function queryNFTTargetOut(uint256 NFTOutAmount)\n        public\n        view\n        returns (\n            uint256 rawPay, \n            uint256 pay\n        )\n    {\n        require(NFTOutAmount <= getAvaliableNFTOutAmount(), \"EXCEED_OUT_AMOUNT\");\n        rawPay = _geometricCalc(\n            _GS_START_TARGET_OUT_,\n            _CR_TARGET_OUT_,\n            _TOTAL_NFT_AMOUNT_ - NFTOutAmount,\n            _TOTAL_NFT_AMOUNT_\n        );\n        (,, pay) = IFilterAdmin(_OWNER_).queryBurnFee(rawPay);\n    }\n\n    function queryNFTRandomOut(uint256 NFTOutAmount)\n        public\n        view\n        returns (\n            uint256 rawPay, \n            uint256 pay\n        )\n    {\n        require(NFTOutAmount <= getAvaliableNFTOutAmount(), \"EXCEED_OUT_AMOUNT\");\n        rawPay = _geometricCalc(\n            _GS_START_RANDOM_OUT_,\n            _CR_RANDOM_OUT_,\n            _TOTAL_NFT_AMOUNT_ - NFTOutAmount,\n            _TOTAL_NFT_AMOUNT_\n        );\n        (,, pay) = IFilterAdmin(_OWNER_).queryBurnFee(rawPay);\n    }\n\n    // ============ Math =============\n\n    function _geometricCalc(\n        uint256 a1,\n        uint256 q,\n        uint256 start,\n        uint256 end\n    ) internal view returns (uint256) {\n        if (q == DecimalMath.ONE) {\n            return end.sub(start).mul(a1);\n        }\n        //Sn=a1*(q^n-1)/(q-1)\n        //Sn-Sm = a1*(q^n-q^m)/(q-1)\n\n        //q^n\n        uint256 qn = DecimalMath.powFloor(q, end);\n        //q^m\n        uint256 qm = DecimalMath.powFloor(q, start);\n        return a1.mul(qn.sub(qm)).div(q.sub(DecimalMath.ONE));\n    }\n    // SWC-120-Weak Sources of Randomness from Chain Attributes: L175\n    function _getRandomNum() public view returns (uint256 randomNum) {\n        randomNum = uint256(\n            keccak256(abi.encodePacked(tx.origin, blockhash(block.number - 1), gasleft()))\n        );\n    }\n\n    // ================= Ownable ================\n\n    function changeNFTInPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) external onlySuperOwner {\n        _changeNFTInPrice(newGsStart, newCr, toggleFlag);\n    }\n\n    function _changeNFTInPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) internal {\n        require(newCr > DecimalMath.ONE, \"CR_INVALID\");\n        _GS_START_IN_ = newGsStart;\n        _CR_IN_ = newCr;\n        _NFT_IN_TOGGLE_ = true;\n    }\n\n    function changeNFTRandomInPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) external onlySuperOwner {\n        _changeNFTRandomInPrice(newGsStart, newCr, toggleFlag);\n    }\n\n    function _changeNFTRandomInPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) internal {\n        require(newCr > DecimalMath.ONE, \"CR_INVALID\");\n        _GS_START_RANDOM_OUT_ = newGsStart;\n        _CR_RANDOM_OUT_ = newCr;\n        _NFT_RANDOM_OUT_TOGGLE_ = true;\n    }\n\n    function changeNFTTargetOutPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) external onlySuperOwner {\n        _changeNFTTargetOutPrice(newGsStart, newCr, toggleFlag);\n    }\n\n    function _changeNFTTargetOutPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) internal {\n        require(newCr > DecimalMath.ONE, \"CR_INVALID\");\n        _GS_START_TARGET_OUT_ = newGsStart;\n        _CR_TARGET_OUT_ = newCr;\n        _NFT_TARGET_OUT_TOGGLE_ = true;\n    }\n\n    function changeNFTAmountRange(uint256 maxNFTAmount, uint256 minNFTAmount)\n        external\n        onlySuperOwner\n    {\n        _changeNFTAmountRange(maxNFTAmount, minNFTAmount);\n    }\n\n    function _changeNFTAmountRange(uint256 maxNFTAmount, uint256 minNFTAmount) internal {\n        require(maxNFTAmount >= minNFTAmount, \"AMOUNT_INVALID\");\n        _MAX_NFT_AMOUNT_ = maxNFTAmount;\n        _MIN_NFT_AMOUNT_ = minNFTAmount;\n    }\n\n    function changeTokenIdRange(uint256 nftIdStart, uint256 nftIdEnd) external onlySuperOwner {\n        _changeTokenIdRange(nftIdStart, nftIdEnd);\n    }\n\n    function _changeTokenIdRange(uint256 nftIdStart, uint256 nftIdEnd) internal {\n        require(nftIdStart <= nftIdEnd, \"TOKEN_RANGE_INVALID\");\n\n        _NFT_ID_START_ = nftIdStart;\n        _NFT_ID_END_ = nftIdEnd;\n    }\n\n    function changeTokenIdMap(uint256[] memory tokenIds, bool[] memory isRegistered)\n        external\n        onlySuperOwner\n    {\n        _changeTokenIdMap(tokenIds, isRegistered);\n    }\n\n    function _changeTokenIdMap(uint256[] memory tokenIds, bool[] memory isRegistered) internal {\n        require(tokenIds.length == isRegistered.length, \"PARAM_NOT_MATCH\");\n\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            _SPREAD_IDS_REGISTRY_[tokenIds[i]] = isRegistered[i];\n        }\n    }\n}",
        "function": "changeTokenIdRange(uint256,uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/SlowMist-DODO-NFTPool Smart Contract Security Audit Report/contractV2-e16ceb038ed6bf070ea75d9359c7ad54e6f3e226/contracts/NFTPool/impl/BaseFilterV1.sol",
        "vulnerability": "Dependence on tx.origin (SWC 115)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract BaseFilterV1 is InitializableOwnable, ReentrancyGuard {\n    using SafeMath for uint256;\n\n    //=================== Storage ===================\n    address public _NFT_COLLECTION_;\n    uint256 public _NFT_ID_START_;\n    uint256 public _NFT_ID_END_ = uint256(-1);\n\n    //tokenId => isRegistered\n    mapping(uint256 => bool) public _SPREAD_IDS_REGISTRY_;\n\n    //tokenId => amount\n    mapping(uint256 => uint256) public _NFT_RESERVE_;\n\n    uint256[] public _NFT_IDS_;\n    uint256 public _TOTAL_NFT_AMOUNT_;\n    uint256 public _MAX_NFT_AMOUNT_;\n    uint256 public _MIN_NFT_AMOUNT_;\n\n    // GS -> Geometric sequence\n    // CR -> Common Ratio\n\n    //For Deposit NFT INto Pool\n    uint256 public _GS_START_IN_;\n    uint256 public _CR_IN_;\n    bool public _NFT_IN_TOGGLE_ = false;\n\n    //For NFT Random OUT from Pool\n    uint256 public _GS_START_RANDOM_OUT_;\n    uint256 public _CR_RANDOM_OUT_;\n    bool public _NFT_RANDOM_OUT_TOGGLE_ = false;\n\n    //For NFT Target OUT from Pool\n    uint256 public _GS_START_TARGET_OUT_;\n    uint256 public _CR_TARGET_OUT_;\n    bool public _NFT_TARGET_OUT_TOGGLE_ = false;\n\n    modifier onlySuperOwner() {\n        require(msg.sender == IFilterAdmin(_OWNER_)._OWNER_(), \"ONLY_SUPER_OWNER\");\n        _;\n    }\n\n    //==================== Query Prop ==================\n\n    function isNFTValid(address nftCollectionAddress, uint256 nftId) external view returns (bool) {\n        if (nftCollectionAddress == _NFT_COLLECTION_) {\n            return isNFTIDValid(nftId);\n        } else {\n            return false;\n        }\n    }\n\n    function isNFTIDValid(uint256 nftId) public view returns (bool) {\n        return (nftId >= _NFT_ID_START_ && nftId <= _NFT_ID_END_) || _SPREAD_IDS_REGISTRY_[nftId];\n    }\n\n    function getAvaliableNFTInAmount() public view returns (uint256) {\n        if (_MAX_NFT_AMOUNT_ <= _TOTAL_NFT_AMOUNT_) {\n            return 0;\n        } else {\n            return _MAX_NFT_AMOUNT_ - _TOTAL_NFT_AMOUNT_;\n        }\n    }\n\n    function getAvaliableNFTOutAmount() public view returns (uint256) {\n        if (_TOTAL_NFT_AMOUNT_ <= _MIN_NFT_AMOUNT_) {\n            return 0;\n        } else {\n            return _TOTAL_NFT_AMOUNT_ - _MIN_NFT_AMOUNT_;\n        }\n    }\n\n    function getNFTIndexById(uint256 tokenId) public view returns (uint256) {\n        uint256 i = 0;\n        for (; i < _NFT_IDS_.length; i++) {\n            if (_NFT_IDS_[i] == tokenId) break;\n        }\n        require(i < _NFT_IDS_.length, \"TOKEN_ID_NOT_EXSIT\");\n        return i;\n    }\n\n    //==================== Query Price ==================\n\n    function queryNFTIn(uint256 NFTInAmount)\n        public\n        view\n        returns (\n            uint256 rawReceive, \n            uint256 received\n        )\n    {\n        require(NFTInAmount <= getAvaliableNFTInAmount(), \"EXCEDD_IN_AMOUNT\");\n        rawReceive = _geometricCalc(\n            _GS_START_IN_,\n            _CR_IN_,\n            _TOTAL_NFT_AMOUNT_,\n            _TOTAL_NFT_AMOUNT_ + NFTInAmount\n        );\n        (,, received) = IFilterAdmin(_OWNER_).queryMintFee(rawReceive);\n    }\n\n    function queryNFTTargetOut(uint256 NFTOutAmount)\n        public\n        view\n        returns (\n            uint256 rawPay, \n            uint256 pay\n        )\n    {\n        require(NFTOutAmount <= getAvaliableNFTOutAmount(), \"EXCEED_OUT_AMOUNT\");\n        rawPay = _geometricCalc(\n            _GS_START_TARGET_OUT_,\n            _CR_TARGET_OUT_,\n            _TOTAL_NFT_AMOUNT_ - NFTOutAmount,\n            _TOTAL_NFT_AMOUNT_\n        );\n        (,, pay) = IFilterAdmin(_OWNER_).queryBurnFee(rawPay);\n    }\n\n    function queryNFTRandomOut(uint256 NFTOutAmount)\n        public\n        view\n        returns (\n            uint256 rawPay, \n            uint256 pay\n        )\n    {\n        require(NFTOutAmount <= getAvaliableNFTOutAmount(), \"EXCEED_OUT_AMOUNT\");\n        rawPay = _geometricCalc(\n            _GS_START_RANDOM_OUT_,\n            _CR_RANDOM_OUT_,\n            _TOTAL_NFT_AMOUNT_ - NFTOutAmount,\n            _TOTAL_NFT_AMOUNT_\n        );\n        (,, pay) = IFilterAdmin(_OWNER_).queryBurnFee(rawPay);\n    }\n\n    // ============ Math =============\n\n    function _geometricCalc(\n        uint256 a1,\n        uint256 q,\n        uint256 start,\n        uint256 end\n    ) internal view returns (uint256) {\n        if (q == DecimalMath.ONE) {\n            return end.sub(start).mul(a1);\n        }\n        //Sn=a1*(q^n-1)/(q-1)\n        //Sn-Sm = a1*(q^n-q^m)/(q-1)\n\n        //q^n\n        uint256 qn = DecimalMath.powFloor(q, end);\n        //q^m\n        uint256 qm = DecimalMath.powFloor(q, start);\n        return a1.mul(qn.sub(qm)).div(q.sub(DecimalMath.ONE));\n    }\n    // SWC-120-Weak Sources of Randomness from Chain Attributes: L175\n    function _getRandomNum() public view returns (uint256 randomNum) {\n        randomNum = uint256(\n            keccak256(abi.encodePacked(tx.origin, blockhash(block.number - 1), gasleft()))\n        );\n    }\n\n    // ================= Ownable ================\n\n    function changeNFTInPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) external onlySuperOwner {\n        _changeNFTInPrice(newGsStart, newCr, toggleFlag);\n    }\n\n    function _changeNFTInPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) internal {\n        require(newCr > DecimalMath.ONE, \"CR_INVALID\");\n        _GS_START_IN_ = newGsStart;\n        _CR_IN_ = newCr;\n        _NFT_IN_TOGGLE_ = true;\n    }\n\n    function changeNFTRandomInPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) external onlySuperOwner {\n        _changeNFTRandomInPrice(newGsStart, newCr, toggleFlag);\n    }\n\n    function _changeNFTRandomInPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) internal {\n        require(newCr > DecimalMath.ONE, \"CR_INVALID\");\n        _GS_START_RANDOM_OUT_ = newGsStart;\n        _CR_RANDOM_OUT_ = newCr;\n        _NFT_RANDOM_OUT_TOGGLE_ = true;\n    }\n\n    function changeNFTTargetOutPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) external onlySuperOwner {\n        _changeNFTTargetOutPrice(newGsStart, newCr, toggleFlag);\n    }\n\n    function _changeNFTTargetOutPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) internal {\n        require(newCr > DecimalMath.ONE, \"CR_INVALID\");\n        _GS_START_TARGET_OUT_ = newGsStart;\n        _CR_TARGET_OUT_ = newCr;\n        _NFT_TARGET_OUT_TOGGLE_ = true;\n    }\n\n    function changeNFTAmountRange(uint256 maxNFTAmount, uint256 minNFTAmount)\n        external\n        onlySuperOwner\n    {\n        _changeNFTAmountRange(maxNFTAmount, minNFTAmount);\n    }\n\n    function _changeNFTAmountRange(uint256 maxNFTAmount, uint256 minNFTAmount) internal {\n        require(maxNFTAmount >= minNFTAmount, \"AMOUNT_INVALID\");\n        _MAX_NFT_AMOUNT_ = maxNFTAmount;\n        _MIN_NFT_AMOUNT_ = minNFTAmount;\n    }\n\n    function changeTokenIdRange(uint256 nftIdStart, uint256 nftIdEnd) external onlySuperOwner {\n        _changeTokenIdRange(nftIdStart, nftIdEnd);\n    }\n\n    function _changeTokenIdRange(uint256 nftIdStart, uint256 nftIdEnd) internal {\n        require(nftIdStart <= nftIdEnd, \"TOKEN_RANGE_INVALID\");\n\n        _NFT_ID_START_ = nftIdStart;\n        _NFT_ID_END_ = nftIdEnd;\n    }\n\n    function changeTokenIdMap(uint256[] memory tokenIds, bool[] memory isRegistered)\n        external\n        onlySuperOwner\n    {\n        _changeTokenIdMap(tokenIds, isRegistered);\n    }\n\n    function _changeTokenIdMap(uint256[] memory tokenIds, bool[] memory isRegistered) internal {\n        require(tokenIds.length == isRegistered.length, \"PARAM_NOT_MATCH\");\n\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            _SPREAD_IDS_REGISTRY_[tokenIds[i]] = isRegistered[i];\n        }\n    }\n}",
        "function": "claimOwnership()",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/SlowMist-DODO-NFTPool Smart Contract Security Audit Report/contractV2-e16ceb038ed6bf070ea75d9359c7ad54e6f3e226/contracts/NFTPool/impl/BaseFilterV1.sol",
        "vulnerability": "Dependence on tx.origin (SWC 115)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract BaseFilterV1 is InitializableOwnable, ReentrancyGuard {\n    using SafeMath for uint256;\n\n    //=================== Storage ===================\n    address public _NFT_COLLECTION_;\n    uint256 public _NFT_ID_START_;\n    uint256 public _NFT_ID_END_ = uint256(-1);\n\n    //tokenId => isRegistered\n    mapping(uint256 => bool) public _SPREAD_IDS_REGISTRY_;\n\n    //tokenId => amount\n    mapping(uint256 => uint256) public _NFT_RESERVE_;\n\n    uint256[] public _NFT_IDS_;\n    uint256 public _TOTAL_NFT_AMOUNT_;\n    uint256 public _MAX_NFT_AMOUNT_;\n    uint256 public _MIN_NFT_AMOUNT_;\n\n    // GS -> Geometric sequence\n    // CR -> Common Ratio\n\n    //For Deposit NFT INto Pool\n    uint256 public _GS_START_IN_;\n    uint256 public _CR_IN_;\n    bool public _NFT_IN_TOGGLE_ = false;\n\n    //For NFT Random OUT from Pool\n    uint256 public _GS_START_RANDOM_OUT_;\n    uint256 public _CR_RANDOM_OUT_;\n    bool public _NFT_RANDOM_OUT_TOGGLE_ = false;\n\n    //For NFT Target OUT from Pool\n    uint256 public _GS_START_TARGET_OUT_;\n    uint256 public _CR_TARGET_OUT_;\n    bool public _NFT_TARGET_OUT_TOGGLE_ = false;\n\n    modifier onlySuperOwner() {\n        require(msg.sender == IFilterAdmin(_OWNER_)._OWNER_(), \"ONLY_SUPER_OWNER\");\n        _;\n    }\n\n    //==================== Query Prop ==================\n\n    function isNFTValid(address nftCollectionAddress, uint256 nftId) external view returns (bool) {\n        if (nftCollectionAddress == _NFT_COLLECTION_) {\n            return isNFTIDValid(nftId);\n        } else {\n            return false;\n        }\n    }\n\n    function isNFTIDValid(uint256 nftId) public view returns (bool) {\n        return (nftId >= _NFT_ID_START_ && nftId <= _NFT_ID_END_) || _SPREAD_IDS_REGISTRY_[nftId];\n    }\n\n    function getAvaliableNFTInAmount() public view returns (uint256) {\n        if (_MAX_NFT_AMOUNT_ <= _TOTAL_NFT_AMOUNT_) {\n            return 0;\n        } else {\n            return _MAX_NFT_AMOUNT_ - _TOTAL_NFT_AMOUNT_;\n        }\n    }\n\n    function getAvaliableNFTOutAmount() public view returns (uint256) {\n        if (_TOTAL_NFT_AMOUNT_ <= _MIN_NFT_AMOUNT_) {\n            return 0;\n        } else {\n            return _TOTAL_NFT_AMOUNT_ - _MIN_NFT_AMOUNT_;\n        }\n    }\n\n    function getNFTIndexById(uint256 tokenId) public view returns (uint256) {\n        uint256 i = 0;\n        for (; i < _NFT_IDS_.length; i++) {\n            if (_NFT_IDS_[i] == tokenId) break;\n        }\n        require(i < _NFT_IDS_.length, \"TOKEN_ID_NOT_EXSIT\");\n        return i;\n    }\n\n    //==================== Query Price ==================\n\n    function queryNFTIn(uint256 NFTInAmount)\n        public\n        view\n        returns (\n            uint256 rawReceive, \n            uint256 received\n        )\n    {\n        require(NFTInAmount <= getAvaliableNFTInAmount(), \"EXCEDD_IN_AMOUNT\");\n        rawReceive = _geometricCalc(\n            _GS_START_IN_,\n            _CR_IN_,\n            _TOTAL_NFT_AMOUNT_,\n            _TOTAL_NFT_AMOUNT_ + NFTInAmount\n        );\n        (,, received) = IFilterAdmin(_OWNER_).queryMintFee(rawReceive);\n    }\n\n    function queryNFTTargetOut(uint256 NFTOutAmount)\n        public\n        view\n        returns (\n            uint256 rawPay, \n            uint256 pay\n        )\n    {\n        require(NFTOutAmount <= getAvaliableNFTOutAmount(), \"EXCEED_OUT_AMOUNT\");\n        rawPay = _geometricCalc(\n            _GS_START_TARGET_OUT_,\n            _CR_TARGET_OUT_,\n            _TOTAL_NFT_AMOUNT_ - NFTOutAmount,\n            _TOTAL_NFT_AMOUNT_\n        );\n        (,, pay) = IFilterAdmin(_OWNER_).queryBurnFee(rawPay);\n    }\n\n    function queryNFTRandomOut(uint256 NFTOutAmount)\n        public\n        view\n        returns (\n            uint256 rawPay, \n            uint256 pay\n        )\n    {\n        require(NFTOutAmount <= getAvaliableNFTOutAmount(), \"EXCEED_OUT_AMOUNT\");\n        rawPay = _geometricCalc(\n            _GS_START_RANDOM_OUT_,\n            _CR_RANDOM_OUT_,\n            _TOTAL_NFT_AMOUNT_ - NFTOutAmount,\n            _TOTAL_NFT_AMOUNT_\n        );\n        (,, pay) = IFilterAdmin(_OWNER_).queryBurnFee(rawPay);\n    }\n\n    // ============ Math =============\n\n    function _geometricCalc(\n        uint256 a1,\n        uint256 q,\n        uint256 start,\n        uint256 end\n    ) internal view returns (uint256) {\n        if (q == DecimalMath.ONE) {\n            return end.sub(start).mul(a1);\n        }\n        //Sn=a1*(q^n-1)/(q-1)\n        //Sn-Sm = a1*(q^n-q^m)/(q-1)\n\n        //q^n\n        uint256 qn = DecimalMath.powFloor(q, end);\n        //q^m\n        uint256 qm = DecimalMath.powFloor(q, start);\n        return a1.mul(qn.sub(qm)).div(q.sub(DecimalMath.ONE));\n    }\n    // SWC-120-Weak Sources of Randomness from Chain Attributes: L175\n    function _getRandomNum() public view returns (uint256 randomNum) {\n        randomNum = uint256(\n            keccak256(abi.encodePacked(tx.origin, blockhash(block.number - 1), gasleft()))\n        );\n    }\n\n    // ================= Ownable ================\n\n    function changeNFTInPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) external onlySuperOwner {\n        _changeNFTInPrice(newGsStart, newCr, toggleFlag);\n    }\n\n    function _changeNFTInPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) internal {\n        require(newCr > DecimalMath.ONE, \"CR_INVALID\");\n        _GS_START_IN_ = newGsStart;\n        _CR_IN_ = newCr;\n        _NFT_IN_TOGGLE_ = true;\n    }\n\n    function changeNFTRandomInPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) external onlySuperOwner {\n        _changeNFTRandomInPrice(newGsStart, newCr, toggleFlag);\n    }\n\n    function _changeNFTRandomInPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) internal {\n        require(newCr > DecimalMath.ONE, \"CR_INVALID\");\n        _GS_START_RANDOM_OUT_ = newGsStart;\n        _CR_RANDOM_OUT_ = newCr;\n        _NFT_RANDOM_OUT_TOGGLE_ = true;\n    }\n\n    function changeNFTTargetOutPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) external onlySuperOwner {\n        _changeNFTTargetOutPrice(newGsStart, newCr, toggleFlag);\n    }\n\n    function _changeNFTTargetOutPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) internal {\n        require(newCr > DecimalMath.ONE, \"CR_INVALID\");\n        _GS_START_TARGET_OUT_ = newGsStart;\n        _CR_TARGET_OUT_ = newCr;\n        _NFT_TARGET_OUT_TOGGLE_ = true;\n    }\n\n    function changeNFTAmountRange(uint256 maxNFTAmount, uint256 minNFTAmount)\n        external\n        onlySuperOwner\n    {\n        _changeNFTAmountRange(maxNFTAmount, minNFTAmount);\n    }\n\n    function _changeNFTAmountRange(uint256 maxNFTAmount, uint256 minNFTAmount) internal {\n        require(maxNFTAmount >= minNFTAmount, \"AMOUNT_INVALID\");\n        _MAX_NFT_AMOUNT_ = maxNFTAmount;\n        _MIN_NFT_AMOUNT_ = minNFTAmount;\n    }\n\n    function changeTokenIdRange(uint256 nftIdStart, uint256 nftIdEnd) external onlySuperOwner {\n        _changeTokenIdRange(nftIdStart, nftIdEnd);\n    }\n\n    function _changeTokenIdRange(uint256 nftIdStart, uint256 nftIdEnd) internal {\n        require(nftIdStart <= nftIdEnd, \"TOKEN_RANGE_INVALID\");\n\n        _NFT_ID_START_ = nftIdStart;\n        _NFT_ID_END_ = nftIdEnd;\n    }\n\n    function changeTokenIdMap(uint256[] memory tokenIds, bool[] memory isRegistered)\n        external\n        onlySuperOwner\n    {\n        _changeTokenIdMap(tokenIds, isRegistered);\n    }\n\n    function _changeTokenIdMap(uint256[] memory tokenIds, bool[] memory isRegistered) internal {\n        require(tokenIds.length == isRegistered.length, \"PARAM_NOT_MATCH\");\n\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            _SPREAD_IDS_REGISTRY_[tokenIds[i]] = isRegistered[i];\n        }\n    }\n}",
        "function": "changeNFTRandomInPrice(uint256,uint256,bool)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/SlowMist-DODO-NFTPool Smart Contract Security Audit Report/contractV2-e16ceb038ed6bf070ea75d9359c7ad54e6f3e226/contracts/NFTPool/impl/BaseFilterV1.sol",
        "vulnerability": "External Call To User-Supplied Address (SWC 107)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract BaseFilterV1 is InitializableOwnable, ReentrancyGuard {\n    using SafeMath for uint256;\n\n    //=================== Storage ===================\n    address public _NFT_COLLECTION_;\n    uint256 public _NFT_ID_START_;\n    uint256 public _NFT_ID_END_ = uint256(-1);\n\n    //tokenId => isRegistered\n    mapping(uint256 => bool) public _SPREAD_IDS_REGISTRY_;\n\n    //tokenId => amount\n    mapping(uint256 => uint256) public _NFT_RESERVE_;\n\n    uint256[] public _NFT_IDS_;\n    uint256 public _TOTAL_NFT_AMOUNT_;\n    uint256 public _MAX_NFT_AMOUNT_;\n    uint256 public _MIN_NFT_AMOUNT_;\n\n    // GS -> Geometric sequence\n    // CR -> Common Ratio\n\n    //For Deposit NFT INto Pool\n    uint256 public _GS_START_IN_;\n    uint256 public _CR_IN_;\n    bool public _NFT_IN_TOGGLE_ = false;\n\n    //For NFT Random OUT from Pool\n    uint256 public _GS_START_RANDOM_OUT_;\n    uint256 public _CR_RANDOM_OUT_;\n    bool public _NFT_RANDOM_OUT_TOGGLE_ = false;\n\n    //For NFT Target OUT from Pool\n    uint256 public _GS_START_TARGET_OUT_;\n    uint256 public _CR_TARGET_OUT_;\n    bool public _NFT_TARGET_OUT_TOGGLE_ = false;\n\n    modifier onlySuperOwner() {\n        require(msg.sender == IFilterAdmin(_OWNER_)._OWNER_(), \"ONLY_SUPER_OWNER\");\n        _;\n    }\n\n    //==================== Query Prop ==================\n\n    function isNFTValid(address nftCollectionAddress, uint256 nftId) external view returns (bool) {\n        if (nftCollectionAddress == _NFT_COLLECTION_) {\n            return isNFTIDValid(nftId);\n        } else {\n            return false;\n        }\n    }\n\n    function isNFTIDValid(uint256 nftId) public view returns (bool) {\n        return (nftId >= _NFT_ID_START_ && nftId <= _NFT_ID_END_) || _SPREAD_IDS_REGISTRY_[nftId];\n    }\n\n    function getAvaliableNFTInAmount() public view returns (uint256) {\n        if (_MAX_NFT_AMOUNT_ <= _TOTAL_NFT_AMOUNT_) {\n            return 0;\n        } else {\n            return _MAX_NFT_AMOUNT_ - _TOTAL_NFT_AMOUNT_;\n        }\n    }\n\n    function getAvaliableNFTOutAmount() public view returns (uint256) {\n        if (_TOTAL_NFT_AMOUNT_ <= _MIN_NFT_AMOUNT_) {\n            return 0;\n        } else {\n            return _TOTAL_NFT_AMOUNT_ - _MIN_NFT_AMOUNT_;\n        }\n    }\n\n    function getNFTIndexById(uint256 tokenId) public view returns (uint256) {\n        uint256 i = 0;\n        for (; i < _NFT_IDS_.length; i++) {\n            if (_NFT_IDS_[i] == tokenId) break;\n        }\n        require(i < _NFT_IDS_.length, \"TOKEN_ID_NOT_EXSIT\");\n        return i;\n    }\n\n    //==================== Query Price ==================\n\n    function queryNFTIn(uint256 NFTInAmount)\n        public\n        view\n        returns (\n            uint256 rawReceive, \n            uint256 received\n        )\n    {\n        require(NFTInAmount <= getAvaliableNFTInAmount(), \"EXCEDD_IN_AMOUNT\");\n        rawReceive = _geometricCalc(\n            _GS_START_IN_,\n            _CR_IN_,\n            _TOTAL_NFT_AMOUNT_,\n            _TOTAL_NFT_AMOUNT_ + NFTInAmount\n        );\n        (,, received) = IFilterAdmin(_OWNER_).queryMintFee(rawReceive);\n    }\n\n    function queryNFTTargetOut(uint256 NFTOutAmount)\n        public\n        view\n        returns (\n            uint256 rawPay, \n            uint256 pay\n        )\n    {\n        require(NFTOutAmount <= getAvaliableNFTOutAmount(), \"EXCEED_OUT_AMOUNT\");\n        rawPay = _geometricCalc(\n            _GS_START_TARGET_OUT_,\n            _CR_TARGET_OUT_,\n            _TOTAL_NFT_AMOUNT_ - NFTOutAmount,\n            _TOTAL_NFT_AMOUNT_\n        );\n        (,, pay) = IFilterAdmin(_OWNER_).queryBurnFee(rawPay);\n    }\n\n    function queryNFTRandomOut(uint256 NFTOutAmount)\n        public\n        view\n        returns (\n            uint256 rawPay, \n            uint256 pay\n        )\n    {\n        require(NFTOutAmount <= getAvaliableNFTOutAmount(), \"EXCEED_OUT_AMOUNT\");\n        rawPay = _geometricCalc(\n            _GS_START_RANDOM_OUT_,\n            _CR_RANDOM_OUT_,\n            _TOTAL_NFT_AMOUNT_ - NFTOutAmount,\n            _TOTAL_NFT_AMOUNT_\n        );\n        (,, pay) = IFilterAdmin(_OWNER_).queryBurnFee(rawPay);\n    }\n\n    // ============ Math =============\n\n    function _geometricCalc(\n        uint256 a1,\n        uint256 q,\n        uint256 start,\n        uint256 end\n    ) internal view returns (uint256) {\n        if (q == DecimalMath.ONE) {\n            return end.sub(start).mul(a1);\n        }\n        //Sn=a1*(q^n-1)/(q-1)\n        //Sn-Sm = a1*(q^n-q^m)/(q-1)\n\n        //q^n\n        uint256 qn = DecimalMath.powFloor(q, end);\n        //q^m\n        uint256 qm = DecimalMath.powFloor(q, start);\n        return a1.mul(qn.sub(qm)).div(q.sub(DecimalMath.ONE));\n    }\n    // SWC-120-Weak Sources of Randomness from Chain Attributes: L175\n    function _getRandomNum() public view returns (uint256 randomNum) {\n        randomNum = uint256(\n            keccak256(abi.encodePacked(tx.origin, blockhash(block.number - 1), gasleft()))\n        );\n    }\n\n    // ================= Ownable ================\n\n    function changeNFTInPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) external onlySuperOwner {\n        _changeNFTInPrice(newGsStart, newCr, toggleFlag);\n    }\n\n    function _changeNFTInPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) internal {\n        require(newCr > DecimalMath.ONE, \"CR_INVALID\");\n        _GS_START_IN_ = newGsStart;\n        _CR_IN_ = newCr;\n        _NFT_IN_TOGGLE_ = true;\n    }\n\n    function changeNFTRandomInPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) external onlySuperOwner {\n        _changeNFTRandomInPrice(newGsStart, newCr, toggleFlag);\n    }\n\n    function _changeNFTRandomInPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) internal {\n        require(newCr > DecimalMath.ONE, \"CR_INVALID\");\n        _GS_START_RANDOM_OUT_ = newGsStart;\n        _CR_RANDOM_OUT_ = newCr;\n        _NFT_RANDOM_OUT_TOGGLE_ = true;\n    }\n\n    function changeNFTTargetOutPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) external onlySuperOwner {\n        _changeNFTTargetOutPrice(newGsStart, newCr, toggleFlag);\n    }\n\n    function _changeNFTTargetOutPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) internal {\n        require(newCr > DecimalMath.ONE, \"CR_INVALID\");\n        _GS_START_TARGET_OUT_ = newGsStart;\n        _CR_TARGET_OUT_ = newCr;\n        _NFT_TARGET_OUT_TOGGLE_ = true;\n    }\n\n    function changeNFTAmountRange(uint256 maxNFTAmount, uint256 minNFTAmount)\n        external\n        onlySuperOwner\n    {\n        _changeNFTAmountRange(maxNFTAmount, minNFTAmount);\n    }\n\n    function _changeNFTAmountRange(uint256 maxNFTAmount, uint256 minNFTAmount) internal {\n        require(maxNFTAmount >= minNFTAmount, \"AMOUNT_INVALID\");\n        _MAX_NFT_AMOUNT_ = maxNFTAmount;\n        _MIN_NFT_AMOUNT_ = minNFTAmount;\n    }\n\n    function changeTokenIdRange(uint256 nftIdStart, uint256 nftIdEnd) external onlySuperOwner {\n        _changeTokenIdRange(nftIdStart, nftIdEnd);\n    }\n\n    function _changeTokenIdRange(uint256 nftIdStart, uint256 nftIdEnd) internal {\n        require(nftIdStart <= nftIdEnd, \"TOKEN_RANGE_INVALID\");\n\n        _NFT_ID_START_ = nftIdStart;\n        _NFT_ID_END_ = nftIdEnd;\n    }\n\n    function changeTokenIdMap(uint256[] memory tokenIds, bool[] memory isRegistered)\n        external\n        onlySuperOwner\n    {\n        _changeTokenIdMap(tokenIds, isRegistered);\n    }\n\n    function _changeTokenIdMap(uint256[] memory tokenIds, bool[] memory isRegistered) internal {\n        require(tokenIds.length == isRegistered.length, \"PARAM_NOT_MATCH\");\n\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            _SPREAD_IDS_REGISTRY_[tokenIds[i]] = isRegistered[i];\n        }\n    }\n}",
        "function": "changeNFTRandomInPrice(uint256,uint256,bool)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/SlowMist-DODO-NFTPool Smart Contract Security Audit Report/contractV2-e16ceb038ed6bf070ea75d9359c7ad54e6f3e226/contracts/NFTPool/impl/BaseFilterV1.sol",
        "vulnerability": "Dependence on tx.origin (SWC 115)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract BaseFilterV1 is InitializableOwnable, ReentrancyGuard {\n    using SafeMath for uint256;\n\n    //=================== Storage ===================\n    address public _NFT_COLLECTION_;\n    uint256 public _NFT_ID_START_;\n    uint256 public _NFT_ID_END_ = uint256(-1);\n\n    //tokenId => isRegistered\n    mapping(uint256 => bool) public _SPREAD_IDS_REGISTRY_;\n\n    //tokenId => amount\n    mapping(uint256 => uint256) public _NFT_RESERVE_;\n\n    uint256[] public _NFT_IDS_;\n    uint256 public _TOTAL_NFT_AMOUNT_;\n    uint256 public _MAX_NFT_AMOUNT_;\n    uint256 public _MIN_NFT_AMOUNT_;\n\n    // GS -> Geometric sequence\n    // CR -> Common Ratio\n\n    //For Deposit NFT INto Pool\n    uint256 public _GS_START_IN_;\n    uint256 public _CR_IN_;\n    bool public _NFT_IN_TOGGLE_ = false;\n\n    //For NFT Random OUT from Pool\n    uint256 public _GS_START_RANDOM_OUT_;\n    uint256 public _CR_RANDOM_OUT_;\n    bool public _NFT_RANDOM_OUT_TOGGLE_ = false;\n\n    //For NFT Target OUT from Pool\n    uint256 public _GS_START_TARGET_OUT_;\n    uint256 public _CR_TARGET_OUT_;\n    bool public _NFT_TARGET_OUT_TOGGLE_ = false;\n\n    modifier onlySuperOwner() {\n        require(msg.sender == IFilterAdmin(_OWNER_)._OWNER_(), \"ONLY_SUPER_OWNER\");\n        _;\n    }\n\n    //==================== Query Prop ==================\n\n    function isNFTValid(address nftCollectionAddress, uint256 nftId) external view returns (bool) {\n        if (nftCollectionAddress == _NFT_COLLECTION_) {\n            return isNFTIDValid(nftId);\n        } else {\n            return false;\n        }\n    }\n\n    function isNFTIDValid(uint256 nftId) public view returns (bool) {\n        return (nftId >= _NFT_ID_START_ && nftId <= _NFT_ID_END_) || _SPREAD_IDS_REGISTRY_[nftId];\n    }\n\n    function getAvaliableNFTInAmount() public view returns (uint256) {\n        if (_MAX_NFT_AMOUNT_ <= _TOTAL_NFT_AMOUNT_) {\n            return 0;\n        } else {\n            return _MAX_NFT_AMOUNT_ - _TOTAL_NFT_AMOUNT_;\n        }\n    }\n\n    function getAvaliableNFTOutAmount() public view returns (uint256) {\n        if (_TOTAL_NFT_AMOUNT_ <= _MIN_NFT_AMOUNT_) {\n            return 0;\n        } else {\n            return _TOTAL_NFT_AMOUNT_ - _MIN_NFT_AMOUNT_;\n        }\n    }\n\n    function getNFTIndexById(uint256 tokenId) public view returns (uint256) {\n        uint256 i = 0;\n        for (; i < _NFT_IDS_.length; i++) {\n            if (_NFT_IDS_[i] == tokenId) break;\n        }\n        require(i < _NFT_IDS_.length, \"TOKEN_ID_NOT_EXSIT\");\n        return i;\n    }\n\n    //==================== Query Price ==================\n\n    function queryNFTIn(uint256 NFTInAmount)\n        public\n        view\n        returns (\n            uint256 rawReceive, \n            uint256 received\n        )\n    {\n        require(NFTInAmount <= getAvaliableNFTInAmount(), \"EXCEDD_IN_AMOUNT\");\n        rawReceive = _geometricCalc(\n            _GS_START_IN_,\n            _CR_IN_,\n            _TOTAL_NFT_AMOUNT_,\n            _TOTAL_NFT_AMOUNT_ + NFTInAmount\n        );\n        (,, received) = IFilterAdmin(_OWNER_).queryMintFee(rawReceive);\n    }\n\n    function queryNFTTargetOut(uint256 NFTOutAmount)\n        public\n        view\n        returns (\n            uint256 rawPay, \n            uint256 pay\n        )\n    {\n        require(NFTOutAmount <= getAvaliableNFTOutAmount(), \"EXCEED_OUT_AMOUNT\");\n        rawPay = _geometricCalc(\n            _GS_START_TARGET_OUT_,\n            _CR_TARGET_OUT_,\n            _TOTAL_NFT_AMOUNT_ - NFTOutAmount,\n            _TOTAL_NFT_AMOUNT_\n        );\n        (,, pay) = IFilterAdmin(_OWNER_).queryBurnFee(rawPay);\n    }\n\n    function queryNFTRandomOut(uint256 NFTOutAmount)\n        public\n        view\n        returns (\n            uint256 rawPay, \n            uint256 pay\n        )\n    {\n        require(NFTOutAmount <= getAvaliableNFTOutAmount(), \"EXCEED_OUT_AMOUNT\");\n        rawPay = _geometricCalc(\n            _GS_START_RANDOM_OUT_,\n            _CR_RANDOM_OUT_,\n            _TOTAL_NFT_AMOUNT_ - NFTOutAmount,\n            _TOTAL_NFT_AMOUNT_\n        );\n        (,, pay) = IFilterAdmin(_OWNER_).queryBurnFee(rawPay);\n    }\n\n    // ============ Math =============\n\n    function _geometricCalc(\n        uint256 a1,\n        uint256 q,\n        uint256 start,\n        uint256 end\n    ) internal view returns (uint256) {\n        if (q == DecimalMath.ONE) {\n            return end.sub(start).mul(a1);\n        }\n        //Sn=a1*(q^n-1)/(q-1)\n        //Sn-Sm = a1*(q^n-q^m)/(q-1)\n\n        //q^n\n        uint256 qn = DecimalMath.powFloor(q, end);\n        //q^m\n        uint256 qm = DecimalMath.powFloor(q, start);\n        return a1.mul(qn.sub(qm)).div(q.sub(DecimalMath.ONE));\n    }\n    // SWC-120-Weak Sources of Randomness from Chain Attributes: L175\n    function _getRandomNum() public view returns (uint256 randomNum) {\n        randomNum = uint256(\n            keccak256(abi.encodePacked(tx.origin, blockhash(block.number - 1), gasleft()))\n        );\n    }\n\n    // ================= Ownable ================\n\n    function changeNFTInPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) external onlySuperOwner {\n        _changeNFTInPrice(newGsStart, newCr, toggleFlag);\n    }\n\n    function _changeNFTInPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) internal {\n        require(newCr > DecimalMath.ONE, \"CR_INVALID\");\n        _GS_START_IN_ = newGsStart;\n        _CR_IN_ = newCr;\n        _NFT_IN_TOGGLE_ = true;\n    }\n\n    function changeNFTRandomInPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) external onlySuperOwner {\n        _changeNFTRandomInPrice(newGsStart, newCr, toggleFlag);\n    }\n\n    function _changeNFTRandomInPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) internal {\n        require(newCr > DecimalMath.ONE, \"CR_INVALID\");\n        _GS_START_RANDOM_OUT_ = newGsStart;\n        _CR_RANDOM_OUT_ = newCr;\n        _NFT_RANDOM_OUT_TOGGLE_ = true;\n    }\n\n    function changeNFTTargetOutPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) external onlySuperOwner {\n        _changeNFTTargetOutPrice(newGsStart, newCr, toggleFlag);\n    }\n\n    function _changeNFTTargetOutPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) internal {\n        require(newCr > DecimalMath.ONE, \"CR_INVALID\");\n        _GS_START_TARGET_OUT_ = newGsStart;\n        _CR_TARGET_OUT_ = newCr;\n        _NFT_TARGET_OUT_TOGGLE_ = true;\n    }\n\n    function changeNFTAmountRange(uint256 maxNFTAmount, uint256 minNFTAmount)\n        external\n        onlySuperOwner\n    {\n        _changeNFTAmountRange(maxNFTAmount, minNFTAmount);\n    }\n\n    function _changeNFTAmountRange(uint256 maxNFTAmount, uint256 minNFTAmount) internal {\n        require(maxNFTAmount >= minNFTAmount, \"AMOUNT_INVALID\");\n        _MAX_NFT_AMOUNT_ = maxNFTAmount;\n        _MIN_NFT_AMOUNT_ = minNFTAmount;\n    }\n\n    function changeTokenIdRange(uint256 nftIdStart, uint256 nftIdEnd) external onlySuperOwner {\n        _changeTokenIdRange(nftIdStart, nftIdEnd);\n    }\n\n    function _changeTokenIdRange(uint256 nftIdStart, uint256 nftIdEnd) internal {\n        require(nftIdStart <= nftIdEnd, \"TOKEN_RANGE_INVALID\");\n\n        _NFT_ID_START_ = nftIdStart;\n        _NFT_ID_END_ = nftIdEnd;\n    }\n\n    function changeTokenIdMap(uint256[] memory tokenIds, bool[] memory isRegistered)\n        external\n        onlySuperOwner\n    {\n        _changeTokenIdMap(tokenIds, isRegistered);\n    }\n\n    function _changeTokenIdMap(uint256[] memory tokenIds, bool[] memory isRegistered) internal {\n        require(tokenIds.length == isRegistered.length, \"PARAM_NOT_MATCH\");\n\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            _SPREAD_IDS_REGISTRY_[tokenIds[i]] = isRegistered[i];\n        }\n    }\n}",
        "function": "changeNFTAmountRange(uint256,uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/SlowMist-DODO-NFTPool Smart Contract Security Audit Report/contractV2-e16ceb038ed6bf070ea75d9359c7ad54e6f3e226/contracts/NFTPool/impl/BaseFilterV1.sol",
        "vulnerability": "External Call To User-Supplied Address (SWC 107)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract BaseFilterV1 is InitializableOwnable, ReentrancyGuard {\n    using SafeMath for uint256;\n\n    //=================== Storage ===================\n    address public _NFT_COLLECTION_;\n    uint256 public _NFT_ID_START_;\n    uint256 public _NFT_ID_END_ = uint256(-1);\n\n    //tokenId => isRegistered\n    mapping(uint256 => bool) public _SPREAD_IDS_REGISTRY_;\n\n    //tokenId => amount\n    mapping(uint256 => uint256) public _NFT_RESERVE_;\n\n    uint256[] public _NFT_IDS_;\n    uint256 public _TOTAL_NFT_AMOUNT_;\n    uint256 public _MAX_NFT_AMOUNT_;\n    uint256 public _MIN_NFT_AMOUNT_;\n\n    // GS -> Geometric sequence\n    // CR -> Common Ratio\n\n    //For Deposit NFT INto Pool\n    uint256 public _GS_START_IN_;\n    uint256 public _CR_IN_;\n    bool public _NFT_IN_TOGGLE_ = false;\n\n    //For NFT Random OUT from Pool\n    uint256 public _GS_START_RANDOM_OUT_;\n    uint256 public _CR_RANDOM_OUT_;\n    bool public _NFT_RANDOM_OUT_TOGGLE_ = false;\n\n    //For NFT Target OUT from Pool\n    uint256 public _GS_START_TARGET_OUT_;\n    uint256 public _CR_TARGET_OUT_;\n    bool public _NFT_TARGET_OUT_TOGGLE_ = false;\n\n    modifier onlySuperOwner() {\n        require(msg.sender == IFilterAdmin(_OWNER_)._OWNER_(), \"ONLY_SUPER_OWNER\");\n        _;\n    }\n\n    //==================== Query Prop ==================\n\n    function isNFTValid(address nftCollectionAddress, uint256 nftId) external view returns (bool) {\n        if (nftCollectionAddress == _NFT_COLLECTION_) {\n            return isNFTIDValid(nftId);\n        } else {\n            return false;\n        }\n    }\n\n    function isNFTIDValid(uint256 nftId) public view returns (bool) {\n        return (nftId >= _NFT_ID_START_ && nftId <= _NFT_ID_END_) || _SPREAD_IDS_REGISTRY_[nftId];\n    }\n\n    function getAvaliableNFTInAmount() public view returns (uint256) {\n        if (_MAX_NFT_AMOUNT_ <= _TOTAL_NFT_AMOUNT_) {\n            return 0;\n        } else {\n            return _MAX_NFT_AMOUNT_ - _TOTAL_NFT_AMOUNT_;\n        }\n    }\n\n    function getAvaliableNFTOutAmount() public view returns (uint256) {\n        if (_TOTAL_NFT_AMOUNT_ <= _MIN_NFT_AMOUNT_) {\n            return 0;\n        } else {\n            return _TOTAL_NFT_AMOUNT_ - _MIN_NFT_AMOUNT_;\n        }\n    }\n\n    function getNFTIndexById(uint256 tokenId) public view returns (uint256) {\n        uint256 i = 0;\n        for (; i < _NFT_IDS_.length; i++) {\n            if (_NFT_IDS_[i] == tokenId) break;\n        }\n        require(i < _NFT_IDS_.length, \"TOKEN_ID_NOT_EXSIT\");\n        return i;\n    }\n\n    //==================== Query Price ==================\n\n    function queryNFTIn(uint256 NFTInAmount)\n        public\n        view\n        returns (\n            uint256 rawReceive, \n            uint256 received\n        )\n    {\n        require(NFTInAmount <= getAvaliableNFTInAmount(), \"EXCEDD_IN_AMOUNT\");\n        rawReceive = _geometricCalc(\n            _GS_START_IN_,\n            _CR_IN_,\n            _TOTAL_NFT_AMOUNT_,\n            _TOTAL_NFT_AMOUNT_ + NFTInAmount\n        );\n        (,, received) = IFilterAdmin(_OWNER_).queryMintFee(rawReceive);\n    }\n\n    function queryNFTTargetOut(uint256 NFTOutAmount)\n        public\n        view\n        returns (\n            uint256 rawPay, \n            uint256 pay\n        )\n    {\n        require(NFTOutAmount <= getAvaliableNFTOutAmount(), \"EXCEED_OUT_AMOUNT\");\n        rawPay = _geometricCalc(\n            _GS_START_TARGET_OUT_,\n            _CR_TARGET_OUT_,\n            _TOTAL_NFT_AMOUNT_ - NFTOutAmount,\n            _TOTAL_NFT_AMOUNT_\n        );\n        (,, pay) = IFilterAdmin(_OWNER_).queryBurnFee(rawPay);\n    }\n\n    function queryNFTRandomOut(uint256 NFTOutAmount)\n        public\n        view\n        returns (\n            uint256 rawPay, \n            uint256 pay\n        )\n    {\n        require(NFTOutAmount <= getAvaliableNFTOutAmount(), \"EXCEED_OUT_AMOUNT\");\n        rawPay = _geometricCalc(\n            _GS_START_RANDOM_OUT_,\n            _CR_RANDOM_OUT_,\n            _TOTAL_NFT_AMOUNT_ - NFTOutAmount,\n            _TOTAL_NFT_AMOUNT_\n        );\n        (,, pay) = IFilterAdmin(_OWNER_).queryBurnFee(rawPay);\n    }\n\n    // ============ Math =============\n\n    function _geometricCalc(\n        uint256 a1,\n        uint256 q,\n        uint256 start,\n        uint256 end\n    ) internal view returns (uint256) {\n        if (q == DecimalMath.ONE) {\n            return end.sub(start).mul(a1);\n        }\n        //Sn=a1*(q^n-1)/(q-1)\n        //Sn-Sm = a1*(q^n-q^m)/(q-1)\n\n        //q^n\n        uint256 qn = DecimalMath.powFloor(q, end);\n        //q^m\n        uint256 qm = DecimalMath.powFloor(q, start);\n        return a1.mul(qn.sub(qm)).div(q.sub(DecimalMath.ONE));\n    }\n    // SWC-120-Weak Sources of Randomness from Chain Attributes: L175\n    function _getRandomNum() public view returns (uint256 randomNum) {\n        randomNum = uint256(\n            keccak256(abi.encodePacked(tx.origin, blockhash(block.number - 1), gasleft()))\n        );\n    }\n\n    // ================= Ownable ================\n\n    function changeNFTInPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) external onlySuperOwner {\n        _changeNFTInPrice(newGsStart, newCr, toggleFlag);\n    }\n\n    function _changeNFTInPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) internal {\n        require(newCr > DecimalMath.ONE, \"CR_INVALID\");\n        _GS_START_IN_ = newGsStart;\n        _CR_IN_ = newCr;\n        _NFT_IN_TOGGLE_ = true;\n    }\n\n    function changeNFTRandomInPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) external onlySuperOwner {\n        _changeNFTRandomInPrice(newGsStart, newCr, toggleFlag);\n    }\n\n    function _changeNFTRandomInPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) internal {\n        require(newCr > DecimalMath.ONE, \"CR_INVALID\");\n        _GS_START_RANDOM_OUT_ = newGsStart;\n        _CR_RANDOM_OUT_ = newCr;\n        _NFT_RANDOM_OUT_TOGGLE_ = true;\n    }\n\n    function changeNFTTargetOutPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) external onlySuperOwner {\n        _changeNFTTargetOutPrice(newGsStart, newCr, toggleFlag);\n    }\n\n    function _changeNFTTargetOutPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) internal {\n        require(newCr > DecimalMath.ONE, \"CR_INVALID\");\n        _GS_START_TARGET_OUT_ = newGsStart;\n        _CR_TARGET_OUT_ = newCr;\n        _NFT_TARGET_OUT_TOGGLE_ = true;\n    }\n\n    function changeNFTAmountRange(uint256 maxNFTAmount, uint256 minNFTAmount)\n        external\n        onlySuperOwner\n    {\n        _changeNFTAmountRange(maxNFTAmount, minNFTAmount);\n    }\n\n    function _changeNFTAmountRange(uint256 maxNFTAmount, uint256 minNFTAmount) internal {\n        require(maxNFTAmount >= minNFTAmount, \"AMOUNT_INVALID\");\n        _MAX_NFT_AMOUNT_ = maxNFTAmount;\n        _MIN_NFT_AMOUNT_ = minNFTAmount;\n    }\n\n    function changeTokenIdRange(uint256 nftIdStart, uint256 nftIdEnd) external onlySuperOwner {\n        _changeTokenIdRange(nftIdStart, nftIdEnd);\n    }\n\n    function _changeTokenIdRange(uint256 nftIdStart, uint256 nftIdEnd) internal {\n        require(nftIdStart <= nftIdEnd, \"TOKEN_RANGE_INVALID\");\n\n        _NFT_ID_START_ = nftIdStart;\n        _NFT_ID_END_ = nftIdEnd;\n    }\n\n    function changeTokenIdMap(uint256[] memory tokenIds, bool[] memory isRegistered)\n        external\n        onlySuperOwner\n    {\n        _changeTokenIdMap(tokenIds, isRegistered);\n    }\n\n    function _changeTokenIdMap(uint256[] memory tokenIds, bool[] memory isRegistered) internal {\n        require(tokenIds.length == isRegistered.length, \"PARAM_NOT_MATCH\");\n\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            _SPREAD_IDS_REGISTRY_[tokenIds[i]] = isRegistered[i];\n        }\n    }\n}",
        "function": "changeNFTAmountRange(uint256,uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/SlowMist-DODO-NFTPool Smart Contract Security Audit Report/contractV2-e16ceb038ed6bf070ea75d9359c7ad54e6f3e226/contracts/NFTPool/impl/BaseFilterV1.sol",
        "vulnerability": "Dependence on tx.origin (SWC 115)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract BaseFilterV1 is InitializableOwnable, ReentrancyGuard {\n    using SafeMath for uint256;\n\n    //=================== Storage ===================\n    address public _NFT_COLLECTION_;\n    uint256 public _NFT_ID_START_;\n    uint256 public _NFT_ID_END_ = uint256(-1);\n\n    //tokenId => isRegistered\n    mapping(uint256 => bool) public _SPREAD_IDS_REGISTRY_;\n\n    //tokenId => amount\n    mapping(uint256 => uint256) public _NFT_RESERVE_;\n\n    uint256[] public _NFT_IDS_;\n    uint256 public _TOTAL_NFT_AMOUNT_;\n    uint256 public _MAX_NFT_AMOUNT_;\n    uint256 public _MIN_NFT_AMOUNT_;\n\n    // GS -> Geometric sequence\n    // CR -> Common Ratio\n\n    //For Deposit NFT INto Pool\n    uint256 public _GS_START_IN_;\n    uint256 public _CR_IN_;\n    bool public _NFT_IN_TOGGLE_ = false;\n\n    //For NFT Random OUT from Pool\n    uint256 public _GS_START_RANDOM_OUT_;\n    uint256 public _CR_RANDOM_OUT_;\n    bool public _NFT_RANDOM_OUT_TOGGLE_ = false;\n\n    //For NFT Target OUT from Pool\n    uint256 public _GS_START_TARGET_OUT_;\n    uint256 public _CR_TARGET_OUT_;\n    bool public _NFT_TARGET_OUT_TOGGLE_ = false;\n\n    modifier onlySuperOwner() {\n        require(msg.sender == IFilterAdmin(_OWNER_)._OWNER_(), \"ONLY_SUPER_OWNER\");\n        _;\n    }\n\n    //==================== Query Prop ==================\n\n    function isNFTValid(address nftCollectionAddress, uint256 nftId) external view returns (bool) {\n        if (nftCollectionAddress == _NFT_COLLECTION_) {\n            return isNFTIDValid(nftId);\n        } else {\n            return false;\n        }\n    }\n\n    function isNFTIDValid(uint256 nftId) public view returns (bool) {\n        return (nftId >= _NFT_ID_START_ && nftId <= _NFT_ID_END_) || _SPREAD_IDS_REGISTRY_[nftId];\n    }\n\n    function getAvaliableNFTInAmount() public view returns (uint256) {\n        if (_MAX_NFT_AMOUNT_ <= _TOTAL_NFT_AMOUNT_) {\n            return 0;\n        } else {\n            return _MAX_NFT_AMOUNT_ - _TOTAL_NFT_AMOUNT_;\n        }\n    }\n\n    function getAvaliableNFTOutAmount() public view returns (uint256) {\n        if (_TOTAL_NFT_AMOUNT_ <= _MIN_NFT_AMOUNT_) {\n            return 0;\n        } else {\n            return _TOTAL_NFT_AMOUNT_ - _MIN_NFT_AMOUNT_;\n        }\n    }\n\n    function getNFTIndexById(uint256 tokenId) public view returns (uint256) {\n        uint256 i = 0;\n        for (; i < _NFT_IDS_.length; i++) {\n            if (_NFT_IDS_[i] == tokenId) break;\n        }\n        require(i < _NFT_IDS_.length, \"TOKEN_ID_NOT_EXSIT\");\n        return i;\n    }\n\n    //==================== Query Price ==================\n\n    function queryNFTIn(uint256 NFTInAmount)\n        public\n        view\n        returns (\n            uint256 rawReceive, \n            uint256 received\n        )\n    {\n        require(NFTInAmount <= getAvaliableNFTInAmount(), \"EXCEDD_IN_AMOUNT\");\n        rawReceive = _geometricCalc(\n            _GS_START_IN_,\n            _CR_IN_,\n            _TOTAL_NFT_AMOUNT_,\n            _TOTAL_NFT_AMOUNT_ + NFTInAmount\n        );\n        (,, received) = IFilterAdmin(_OWNER_).queryMintFee(rawReceive);\n    }\n\n    function queryNFTTargetOut(uint256 NFTOutAmount)\n        public\n        view\n        returns (\n            uint256 rawPay, \n            uint256 pay\n        )\n    {\n        require(NFTOutAmount <= getAvaliableNFTOutAmount(), \"EXCEED_OUT_AMOUNT\");\n        rawPay = _geometricCalc(\n            _GS_START_TARGET_OUT_,\n            _CR_TARGET_OUT_,\n            _TOTAL_NFT_AMOUNT_ - NFTOutAmount,\n            _TOTAL_NFT_AMOUNT_\n        );\n        (,, pay) = IFilterAdmin(_OWNER_).queryBurnFee(rawPay);\n    }\n\n    function queryNFTRandomOut(uint256 NFTOutAmount)\n        public\n        view\n        returns (\n            uint256 rawPay, \n            uint256 pay\n        )\n    {\n        require(NFTOutAmount <= getAvaliableNFTOutAmount(), \"EXCEED_OUT_AMOUNT\");\n        rawPay = _geometricCalc(\n            _GS_START_RANDOM_OUT_,\n            _CR_RANDOM_OUT_,\n            _TOTAL_NFT_AMOUNT_ - NFTOutAmount,\n            _TOTAL_NFT_AMOUNT_\n        );\n        (,, pay) = IFilterAdmin(_OWNER_).queryBurnFee(rawPay);\n    }\n\n    // ============ Math =============\n\n    function _geometricCalc(\n        uint256 a1,\n        uint256 q,\n        uint256 start,\n        uint256 end\n    ) internal view returns (uint256) {\n        if (q == DecimalMath.ONE) {\n            return end.sub(start).mul(a1);\n        }\n        //Sn=a1*(q^n-1)/(q-1)\n        //Sn-Sm = a1*(q^n-q^m)/(q-1)\n\n        //q^n\n        uint256 qn = DecimalMath.powFloor(q, end);\n        //q^m\n        uint256 qm = DecimalMath.powFloor(q, start);\n        return a1.mul(qn.sub(qm)).div(q.sub(DecimalMath.ONE));\n    }\n    // SWC-120-Weak Sources of Randomness from Chain Attributes: L175\n    function _getRandomNum() public view returns (uint256 randomNum) {\n        randomNum = uint256(\n            keccak256(abi.encodePacked(tx.origin, blockhash(block.number - 1), gasleft()))\n        );\n    }\n\n    // ================= Ownable ================\n\n    function changeNFTInPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) external onlySuperOwner {\n        _changeNFTInPrice(newGsStart, newCr, toggleFlag);\n    }\n\n    function _changeNFTInPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) internal {\n        require(newCr > DecimalMath.ONE, \"CR_INVALID\");\n        _GS_START_IN_ = newGsStart;\n        _CR_IN_ = newCr;\n        _NFT_IN_TOGGLE_ = true;\n    }\n\n    function changeNFTRandomInPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) external onlySuperOwner {\n        _changeNFTRandomInPrice(newGsStart, newCr, toggleFlag);\n    }\n\n    function _changeNFTRandomInPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) internal {\n        require(newCr > DecimalMath.ONE, \"CR_INVALID\");\n        _GS_START_RANDOM_OUT_ = newGsStart;\n        _CR_RANDOM_OUT_ = newCr;\n        _NFT_RANDOM_OUT_TOGGLE_ = true;\n    }\n\n    function changeNFTTargetOutPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) external onlySuperOwner {\n        _changeNFTTargetOutPrice(newGsStart, newCr, toggleFlag);\n    }\n\n    function _changeNFTTargetOutPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) internal {\n        require(newCr > DecimalMath.ONE, \"CR_INVALID\");\n        _GS_START_TARGET_OUT_ = newGsStart;\n        _CR_TARGET_OUT_ = newCr;\n        _NFT_TARGET_OUT_TOGGLE_ = true;\n    }\n\n    function changeNFTAmountRange(uint256 maxNFTAmount, uint256 minNFTAmount)\n        external\n        onlySuperOwner\n    {\n        _changeNFTAmountRange(maxNFTAmount, minNFTAmount);\n    }\n\n    function _changeNFTAmountRange(uint256 maxNFTAmount, uint256 minNFTAmount) internal {\n        require(maxNFTAmount >= minNFTAmount, \"AMOUNT_INVALID\");\n        _MAX_NFT_AMOUNT_ = maxNFTAmount;\n        _MIN_NFT_AMOUNT_ = minNFTAmount;\n    }\n\n    function changeTokenIdRange(uint256 nftIdStart, uint256 nftIdEnd) external onlySuperOwner {\n        _changeTokenIdRange(nftIdStart, nftIdEnd);\n    }\n\n    function _changeTokenIdRange(uint256 nftIdStart, uint256 nftIdEnd) internal {\n        require(nftIdStart <= nftIdEnd, \"TOKEN_RANGE_INVALID\");\n\n        _NFT_ID_START_ = nftIdStart;\n        _NFT_ID_END_ = nftIdEnd;\n    }\n\n    function changeTokenIdMap(uint256[] memory tokenIds, bool[] memory isRegistered)\n        external\n        onlySuperOwner\n    {\n        _changeTokenIdMap(tokenIds, isRegistered);\n    }\n\n    function _changeTokenIdMap(uint256[] memory tokenIds, bool[] memory isRegistered) internal {\n        require(tokenIds.length == isRegistered.length, \"PARAM_NOT_MATCH\");\n\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            _SPREAD_IDS_REGISTRY_[tokenIds[i]] = isRegistered[i];\n        }\n    }\n}",
        "function": "_NFT_IDS_(uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/SlowMist-DODO-NFTPool Smart Contract Security Audit Report/contractV2-e16ceb038ed6bf070ea75d9359c7ad54e6f3e226/contracts/NFTPool/impl/BaseFilterV1.sol",
        "vulnerability": "Exception State (SWC 110)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract BaseFilterV1 is InitializableOwnable, ReentrancyGuard {\n    using SafeMath for uint256;\n\n    //=================== Storage ===================\n    address public _NFT_COLLECTION_;\n    uint256 public _NFT_ID_START_;\n    uint256 public _NFT_ID_END_ = uint256(-1);\n\n    //tokenId => isRegistered\n    mapping(uint256 => bool) public _SPREAD_IDS_REGISTRY_;\n\n    //tokenId => amount\n    mapping(uint256 => uint256) public _NFT_RESERVE_;\n\n    uint256[] public _NFT_IDS_;\n    uint256 public _TOTAL_NFT_AMOUNT_;\n    uint256 public _MAX_NFT_AMOUNT_;\n    uint256 public _MIN_NFT_AMOUNT_;\n\n    // GS -> Geometric sequence\n    // CR -> Common Ratio\n\n    //For Deposit NFT INto Pool\n    uint256 public _GS_START_IN_;\n    uint256 public _CR_IN_;\n    bool public _NFT_IN_TOGGLE_ = false;\n\n    //For NFT Random OUT from Pool\n    uint256 public _GS_START_RANDOM_OUT_;\n    uint256 public _CR_RANDOM_OUT_;\n    bool public _NFT_RANDOM_OUT_TOGGLE_ = false;\n\n    //For NFT Target OUT from Pool\n    uint256 public _GS_START_TARGET_OUT_;\n    uint256 public _CR_TARGET_OUT_;\n    bool public _NFT_TARGET_OUT_TOGGLE_ = false;\n\n    modifier onlySuperOwner() {\n        require(msg.sender == IFilterAdmin(_OWNER_)._OWNER_(), \"ONLY_SUPER_OWNER\");\n        _;\n    }\n\n    //==================== Query Prop ==================\n\n    function isNFTValid(address nftCollectionAddress, uint256 nftId) external view returns (bool) {\n        if (nftCollectionAddress == _NFT_COLLECTION_) {\n            return isNFTIDValid(nftId);\n        } else {\n            return false;\n        }\n    }\n\n    function isNFTIDValid(uint256 nftId) public view returns (bool) {\n        return (nftId >= _NFT_ID_START_ && nftId <= _NFT_ID_END_) || _SPREAD_IDS_REGISTRY_[nftId];\n    }\n\n    function getAvaliableNFTInAmount() public view returns (uint256) {\n        if (_MAX_NFT_AMOUNT_ <= _TOTAL_NFT_AMOUNT_) {\n            return 0;\n        } else {\n            return _MAX_NFT_AMOUNT_ - _TOTAL_NFT_AMOUNT_;\n        }\n    }\n\n    function getAvaliableNFTOutAmount() public view returns (uint256) {\n        if (_TOTAL_NFT_AMOUNT_ <= _MIN_NFT_AMOUNT_) {\n            return 0;\n        } else {\n            return _TOTAL_NFT_AMOUNT_ - _MIN_NFT_AMOUNT_;\n        }\n    }\n\n    function getNFTIndexById(uint256 tokenId) public view returns (uint256) {\n        uint256 i = 0;\n        for (; i < _NFT_IDS_.length; i++) {\n            if (_NFT_IDS_[i] == tokenId) break;\n        }\n        require(i < _NFT_IDS_.length, \"TOKEN_ID_NOT_EXSIT\");\n        return i;\n    }\n\n    //==================== Query Price ==================\n\n    function queryNFTIn(uint256 NFTInAmount)\n        public\n        view\n        returns (\n            uint256 rawReceive, \n            uint256 received\n        )\n    {\n        require(NFTInAmount <= getAvaliableNFTInAmount(), \"EXCEDD_IN_AMOUNT\");\n        rawReceive = _geometricCalc(\n            _GS_START_IN_,\n            _CR_IN_,\n            _TOTAL_NFT_AMOUNT_,\n            _TOTAL_NFT_AMOUNT_ + NFTInAmount\n        );\n        (,, received) = IFilterAdmin(_OWNER_).queryMintFee(rawReceive);\n    }\n\n    function queryNFTTargetOut(uint256 NFTOutAmount)\n        public\n        view\n        returns (\n            uint256 rawPay, \n            uint256 pay\n        )\n    {\n        require(NFTOutAmount <= getAvaliableNFTOutAmount(), \"EXCEED_OUT_AMOUNT\");\n        rawPay = _geometricCalc(\n            _GS_START_TARGET_OUT_,\n            _CR_TARGET_OUT_,\n            _TOTAL_NFT_AMOUNT_ - NFTOutAmount,\n            _TOTAL_NFT_AMOUNT_\n        );\n        (,, pay) = IFilterAdmin(_OWNER_).queryBurnFee(rawPay);\n    }\n\n    function queryNFTRandomOut(uint256 NFTOutAmount)\n        public\n        view\n        returns (\n            uint256 rawPay, \n            uint256 pay\n        )\n    {\n        require(NFTOutAmount <= getAvaliableNFTOutAmount(), \"EXCEED_OUT_AMOUNT\");\n        rawPay = _geometricCalc(\n            _GS_START_RANDOM_OUT_,\n            _CR_RANDOM_OUT_,\n            _TOTAL_NFT_AMOUNT_ - NFTOutAmount,\n            _TOTAL_NFT_AMOUNT_\n        );\n        (,, pay) = IFilterAdmin(_OWNER_).queryBurnFee(rawPay);\n    }\n\n    // ============ Math =============\n\n    function _geometricCalc(\n        uint256 a1,\n        uint256 q,\n        uint256 start,\n        uint256 end\n    ) internal view returns (uint256) {\n        if (q == DecimalMath.ONE) {\n            return end.sub(start).mul(a1);\n        }\n        //Sn=a1*(q^n-1)/(q-1)\n        //Sn-Sm = a1*(q^n-q^m)/(q-1)\n\n        //q^n\n        uint256 qn = DecimalMath.powFloor(q, end);\n        //q^m\n        uint256 qm = DecimalMath.powFloor(q, start);\n        return a1.mul(qn.sub(qm)).div(q.sub(DecimalMath.ONE));\n    }\n    // SWC-120-Weak Sources of Randomness from Chain Attributes: L175\n    function _getRandomNum() public view returns (uint256 randomNum) {\n        randomNum = uint256(\n            keccak256(abi.encodePacked(tx.origin, blockhash(block.number - 1), gasleft()))\n        );\n    }\n\n    // ================= Ownable ================\n\n    function changeNFTInPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) external onlySuperOwner {\n        _changeNFTInPrice(newGsStart, newCr, toggleFlag);\n    }\n\n    function _changeNFTInPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) internal {\n        require(newCr > DecimalMath.ONE, \"CR_INVALID\");\n        _GS_START_IN_ = newGsStart;\n        _CR_IN_ = newCr;\n        _NFT_IN_TOGGLE_ = true;\n    }\n\n    function changeNFTRandomInPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) external onlySuperOwner {\n        _changeNFTRandomInPrice(newGsStart, newCr, toggleFlag);\n    }\n\n    function _changeNFTRandomInPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) internal {\n        require(newCr > DecimalMath.ONE, \"CR_INVALID\");\n        _GS_START_RANDOM_OUT_ = newGsStart;\n        _CR_RANDOM_OUT_ = newCr;\n        _NFT_RANDOM_OUT_TOGGLE_ = true;\n    }\n\n    function changeNFTTargetOutPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) external onlySuperOwner {\n        _changeNFTTargetOutPrice(newGsStart, newCr, toggleFlag);\n    }\n\n    function _changeNFTTargetOutPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) internal {\n        require(newCr > DecimalMath.ONE, \"CR_INVALID\");\n        _GS_START_TARGET_OUT_ = newGsStart;\n        _CR_TARGET_OUT_ = newCr;\n        _NFT_TARGET_OUT_TOGGLE_ = true;\n    }\n\n    function changeNFTAmountRange(uint256 maxNFTAmount, uint256 minNFTAmount)\n        external\n        onlySuperOwner\n    {\n        _changeNFTAmountRange(maxNFTAmount, minNFTAmount);\n    }\n\n    function _changeNFTAmountRange(uint256 maxNFTAmount, uint256 minNFTAmount) internal {\n        require(maxNFTAmount >= minNFTAmount, \"AMOUNT_INVALID\");\n        _MAX_NFT_AMOUNT_ = maxNFTAmount;\n        _MIN_NFT_AMOUNT_ = minNFTAmount;\n    }\n\n    function changeTokenIdRange(uint256 nftIdStart, uint256 nftIdEnd) external onlySuperOwner {\n        _changeTokenIdRange(nftIdStart, nftIdEnd);\n    }\n\n    function _changeTokenIdRange(uint256 nftIdStart, uint256 nftIdEnd) internal {\n        require(nftIdStart <= nftIdEnd, \"TOKEN_RANGE_INVALID\");\n\n        _NFT_ID_START_ = nftIdStart;\n        _NFT_ID_END_ = nftIdEnd;\n    }\n\n    function changeTokenIdMap(uint256[] memory tokenIds, bool[] memory isRegistered)\n        external\n        onlySuperOwner\n    {\n        _changeTokenIdMap(tokenIds, isRegistered);\n    }\n\n    function _changeTokenIdMap(uint256[] memory tokenIds, bool[] memory isRegistered) internal {\n        require(tokenIds.length == isRegistered.length, \"PARAM_NOT_MATCH\");\n\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            _SPREAD_IDS_REGISTRY_[tokenIds[i]] = isRegistered[i];\n        }\n    }\n}",
        "function": "changeNFTInPrice(uint256,uint256,bool)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/SlowMist-DODO-NFTPool Smart Contract Security Audit Report/contractV2-e16ceb038ed6bf070ea75d9359c7ad54e6f3e226/contracts/NFTPool/impl/BaseFilterV1.sol",
        "vulnerability": "External Call To User-Supplied Address (SWC 107)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract BaseFilterV1 is InitializableOwnable, ReentrancyGuard {\n    using SafeMath for uint256;\n\n    //=================== Storage ===================\n    address public _NFT_COLLECTION_;\n    uint256 public _NFT_ID_START_;\n    uint256 public _NFT_ID_END_ = uint256(-1);\n\n    //tokenId => isRegistered\n    mapping(uint256 => bool) public _SPREAD_IDS_REGISTRY_;\n\n    //tokenId => amount\n    mapping(uint256 => uint256) public _NFT_RESERVE_;\n\n    uint256[] public _NFT_IDS_;\n    uint256 public _TOTAL_NFT_AMOUNT_;\n    uint256 public _MAX_NFT_AMOUNT_;\n    uint256 public _MIN_NFT_AMOUNT_;\n\n    // GS -> Geometric sequence\n    // CR -> Common Ratio\n\n    //For Deposit NFT INto Pool\n    uint256 public _GS_START_IN_;\n    uint256 public _CR_IN_;\n    bool public _NFT_IN_TOGGLE_ = false;\n\n    //For NFT Random OUT from Pool\n    uint256 public _GS_START_RANDOM_OUT_;\n    uint256 public _CR_RANDOM_OUT_;\n    bool public _NFT_RANDOM_OUT_TOGGLE_ = false;\n\n    //For NFT Target OUT from Pool\n    uint256 public _GS_START_TARGET_OUT_;\n    uint256 public _CR_TARGET_OUT_;\n    bool public _NFT_TARGET_OUT_TOGGLE_ = false;\n\n    modifier onlySuperOwner() {\n        require(msg.sender == IFilterAdmin(_OWNER_)._OWNER_(), \"ONLY_SUPER_OWNER\");\n        _;\n    }\n\n    //==================== Query Prop ==================\n\n    function isNFTValid(address nftCollectionAddress, uint256 nftId) external view returns (bool) {\n        if (nftCollectionAddress == _NFT_COLLECTION_) {\n            return isNFTIDValid(nftId);\n        } else {\n            return false;\n        }\n    }\n\n    function isNFTIDValid(uint256 nftId) public view returns (bool) {\n        return (nftId >= _NFT_ID_START_ && nftId <= _NFT_ID_END_) || _SPREAD_IDS_REGISTRY_[nftId];\n    }\n\n    function getAvaliableNFTInAmount() public view returns (uint256) {\n        if (_MAX_NFT_AMOUNT_ <= _TOTAL_NFT_AMOUNT_) {\n            return 0;\n        } else {\n            return _MAX_NFT_AMOUNT_ - _TOTAL_NFT_AMOUNT_;\n        }\n    }\n\n    function getAvaliableNFTOutAmount() public view returns (uint256) {\n        if (_TOTAL_NFT_AMOUNT_ <= _MIN_NFT_AMOUNT_) {\n            return 0;\n        } else {\n            return _TOTAL_NFT_AMOUNT_ - _MIN_NFT_AMOUNT_;\n        }\n    }\n\n    function getNFTIndexById(uint256 tokenId) public view returns (uint256) {\n        uint256 i = 0;\n        for (; i < _NFT_IDS_.length; i++) {\n            if (_NFT_IDS_[i] == tokenId) break;\n        }\n        require(i < _NFT_IDS_.length, \"TOKEN_ID_NOT_EXSIT\");\n        return i;\n    }\n\n    //==================== Query Price ==================\n\n    function queryNFTIn(uint256 NFTInAmount)\n        public\n        view\n        returns (\n            uint256 rawReceive, \n            uint256 received\n        )\n    {\n        require(NFTInAmount <= getAvaliableNFTInAmount(), \"EXCEDD_IN_AMOUNT\");\n        rawReceive = _geometricCalc(\n            _GS_START_IN_,\n            _CR_IN_,\n            _TOTAL_NFT_AMOUNT_,\n            _TOTAL_NFT_AMOUNT_ + NFTInAmount\n        );\n        (,, received) = IFilterAdmin(_OWNER_).queryMintFee(rawReceive);\n    }\n\n    function queryNFTTargetOut(uint256 NFTOutAmount)\n        public\n        view\n        returns (\n            uint256 rawPay, \n            uint256 pay\n        )\n    {\n        require(NFTOutAmount <= getAvaliableNFTOutAmount(), \"EXCEED_OUT_AMOUNT\");\n        rawPay = _geometricCalc(\n            _GS_START_TARGET_OUT_,\n            _CR_TARGET_OUT_,\n            _TOTAL_NFT_AMOUNT_ - NFTOutAmount,\n            _TOTAL_NFT_AMOUNT_\n        );\n        (,, pay) = IFilterAdmin(_OWNER_).queryBurnFee(rawPay);\n    }\n\n    function queryNFTRandomOut(uint256 NFTOutAmount)\n        public\n        view\n        returns (\n            uint256 rawPay, \n            uint256 pay\n        )\n    {\n        require(NFTOutAmount <= getAvaliableNFTOutAmount(), \"EXCEED_OUT_AMOUNT\");\n        rawPay = _geometricCalc(\n            _GS_START_RANDOM_OUT_,\n            _CR_RANDOM_OUT_,\n            _TOTAL_NFT_AMOUNT_ - NFTOutAmount,\n            _TOTAL_NFT_AMOUNT_\n        );\n        (,, pay) = IFilterAdmin(_OWNER_).queryBurnFee(rawPay);\n    }\n\n    // ============ Math =============\n\n    function _geometricCalc(\n        uint256 a1,\n        uint256 q,\n        uint256 start,\n        uint256 end\n    ) internal view returns (uint256) {\n        if (q == DecimalMath.ONE) {\n            return end.sub(start).mul(a1);\n        }\n        //Sn=a1*(q^n-1)/(q-1)\n        //Sn-Sm = a1*(q^n-q^m)/(q-1)\n\n        //q^n\n        uint256 qn = DecimalMath.powFloor(q, end);\n        //q^m\n        uint256 qm = DecimalMath.powFloor(q, start);\n        return a1.mul(qn.sub(qm)).div(q.sub(DecimalMath.ONE));\n    }\n    // SWC-120-Weak Sources of Randomness from Chain Attributes: L175\n    function _getRandomNum() public view returns (uint256 randomNum) {\n        randomNum = uint256(\n            keccak256(abi.encodePacked(tx.origin, blockhash(block.number - 1), gasleft()))\n        );\n    }\n\n    // ================= Ownable ================\n\n    function changeNFTInPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) external onlySuperOwner {\n        _changeNFTInPrice(newGsStart, newCr, toggleFlag);\n    }\n\n    function _changeNFTInPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) internal {\n        require(newCr > DecimalMath.ONE, \"CR_INVALID\");\n        _GS_START_IN_ = newGsStart;\n        _CR_IN_ = newCr;\n        _NFT_IN_TOGGLE_ = true;\n    }\n\n    function changeNFTRandomInPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) external onlySuperOwner {\n        _changeNFTRandomInPrice(newGsStart, newCr, toggleFlag);\n    }\n\n    function _changeNFTRandomInPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) internal {\n        require(newCr > DecimalMath.ONE, \"CR_INVALID\");\n        _GS_START_RANDOM_OUT_ = newGsStart;\n        _CR_RANDOM_OUT_ = newCr;\n        _NFT_RANDOM_OUT_TOGGLE_ = true;\n    }\n\n    function changeNFTTargetOutPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) external onlySuperOwner {\n        _changeNFTTargetOutPrice(newGsStart, newCr, toggleFlag);\n    }\n\n    function _changeNFTTargetOutPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) internal {\n        require(newCr > DecimalMath.ONE, \"CR_INVALID\");\n        _GS_START_TARGET_OUT_ = newGsStart;\n        _CR_TARGET_OUT_ = newCr;\n        _NFT_TARGET_OUT_TOGGLE_ = true;\n    }\n\n    function changeNFTAmountRange(uint256 maxNFTAmount, uint256 minNFTAmount)\n        external\n        onlySuperOwner\n    {\n        _changeNFTAmountRange(maxNFTAmount, minNFTAmount);\n    }\n\n    function _changeNFTAmountRange(uint256 maxNFTAmount, uint256 minNFTAmount) internal {\n        require(maxNFTAmount >= minNFTAmount, \"AMOUNT_INVALID\");\n        _MAX_NFT_AMOUNT_ = maxNFTAmount;\n        _MIN_NFT_AMOUNT_ = minNFTAmount;\n    }\n\n    function changeTokenIdRange(uint256 nftIdStart, uint256 nftIdEnd) external onlySuperOwner {\n        _changeTokenIdRange(nftIdStart, nftIdEnd);\n    }\n\n    function _changeTokenIdRange(uint256 nftIdStart, uint256 nftIdEnd) internal {\n        require(nftIdStart <= nftIdEnd, \"TOKEN_RANGE_INVALID\");\n\n        _NFT_ID_START_ = nftIdStart;\n        _NFT_ID_END_ = nftIdEnd;\n    }\n\n    function changeTokenIdMap(uint256[] memory tokenIds, bool[] memory isRegistered)\n        external\n        onlySuperOwner\n    {\n        _changeTokenIdMap(tokenIds, isRegistered);\n    }\n\n    function _changeTokenIdMap(uint256[] memory tokenIds, bool[] memory isRegistered) internal {\n        require(tokenIds.length == isRegistered.length, \"PARAM_NOT_MATCH\");\n\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            _SPREAD_IDS_REGISTRY_[tokenIds[i]] = isRegistered[i];\n        }\n    }\n}",
        "function": "changeNFTInPrice(uint256,uint256,bool)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/SlowMist-DODO-NFTPool Smart Contract Security Audit Report/contractV2-e16ceb038ed6bf070ea75d9359c7ad54e6f3e226/contracts/NFTPool/impl/BaseFilterV1.sol",
        "vulnerability": "Dependence on tx.origin (SWC 115)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract BaseFilterV1 is InitializableOwnable, ReentrancyGuard {\n    using SafeMath for uint256;\n\n    //=================== Storage ===================\n    address public _NFT_COLLECTION_;\n    uint256 public _NFT_ID_START_;\n    uint256 public _NFT_ID_END_ = uint256(-1);\n\n    //tokenId => isRegistered\n    mapping(uint256 => bool) public _SPREAD_IDS_REGISTRY_;\n\n    //tokenId => amount\n    mapping(uint256 => uint256) public _NFT_RESERVE_;\n\n    uint256[] public _NFT_IDS_;\n    uint256 public _TOTAL_NFT_AMOUNT_;\n    uint256 public _MAX_NFT_AMOUNT_;\n    uint256 public _MIN_NFT_AMOUNT_;\n\n    // GS -> Geometric sequence\n    // CR -> Common Ratio\n\n    //For Deposit NFT INto Pool\n    uint256 public _GS_START_IN_;\n    uint256 public _CR_IN_;\n    bool public _NFT_IN_TOGGLE_ = false;\n\n    //For NFT Random OUT from Pool\n    uint256 public _GS_START_RANDOM_OUT_;\n    uint256 public _CR_RANDOM_OUT_;\n    bool public _NFT_RANDOM_OUT_TOGGLE_ = false;\n\n    //For NFT Target OUT from Pool\n    uint256 public _GS_START_TARGET_OUT_;\n    uint256 public _CR_TARGET_OUT_;\n    bool public _NFT_TARGET_OUT_TOGGLE_ = false;\n\n    modifier onlySuperOwner() {\n        require(msg.sender == IFilterAdmin(_OWNER_)._OWNER_(), \"ONLY_SUPER_OWNER\");\n        _;\n    }\n\n    //==================== Query Prop ==================\n\n    function isNFTValid(address nftCollectionAddress, uint256 nftId) external view returns (bool) {\n        if (nftCollectionAddress == _NFT_COLLECTION_) {\n            return isNFTIDValid(nftId);\n        } else {\n            return false;\n        }\n    }\n\n    function isNFTIDValid(uint256 nftId) public view returns (bool) {\n        return (nftId >= _NFT_ID_START_ && nftId <= _NFT_ID_END_) || _SPREAD_IDS_REGISTRY_[nftId];\n    }\n\n    function getAvaliableNFTInAmount() public view returns (uint256) {\n        if (_MAX_NFT_AMOUNT_ <= _TOTAL_NFT_AMOUNT_) {\n            return 0;\n        } else {\n            return _MAX_NFT_AMOUNT_ - _TOTAL_NFT_AMOUNT_;\n        }\n    }\n\n    function getAvaliableNFTOutAmount() public view returns (uint256) {\n        if (_TOTAL_NFT_AMOUNT_ <= _MIN_NFT_AMOUNT_) {\n            return 0;\n        } else {\n            return _TOTAL_NFT_AMOUNT_ - _MIN_NFT_AMOUNT_;\n        }\n    }\n\n    function getNFTIndexById(uint256 tokenId) public view returns (uint256) {\n        uint256 i = 0;\n        for (; i < _NFT_IDS_.length; i++) {\n            if (_NFT_IDS_[i] == tokenId) break;\n        }\n        require(i < _NFT_IDS_.length, \"TOKEN_ID_NOT_EXSIT\");\n        return i;\n    }\n\n    //==================== Query Price ==================\n\n    function queryNFTIn(uint256 NFTInAmount)\n        public\n        view\n        returns (\n            uint256 rawReceive, \n            uint256 received\n        )\n    {\n        require(NFTInAmount <= getAvaliableNFTInAmount(), \"EXCEDD_IN_AMOUNT\");\n        rawReceive = _geometricCalc(\n            _GS_START_IN_,\n            _CR_IN_,\n            _TOTAL_NFT_AMOUNT_,\n            _TOTAL_NFT_AMOUNT_ + NFTInAmount\n        );\n        (,, received) = IFilterAdmin(_OWNER_).queryMintFee(rawReceive);\n    }\n\n    function queryNFTTargetOut(uint256 NFTOutAmount)\n        public\n        view\n        returns (\n            uint256 rawPay, \n            uint256 pay\n        )\n    {\n        require(NFTOutAmount <= getAvaliableNFTOutAmount(), \"EXCEED_OUT_AMOUNT\");\n        rawPay = _geometricCalc(\n            _GS_START_TARGET_OUT_,\n            _CR_TARGET_OUT_,\n            _TOTAL_NFT_AMOUNT_ - NFTOutAmount,\n            _TOTAL_NFT_AMOUNT_\n        );\n        (,, pay) = IFilterAdmin(_OWNER_).queryBurnFee(rawPay);\n    }\n\n    function queryNFTRandomOut(uint256 NFTOutAmount)\n        public\n        view\n        returns (\n            uint256 rawPay, \n            uint256 pay\n        )\n    {\n        require(NFTOutAmount <= getAvaliableNFTOutAmount(), \"EXCEED_OUT_AMOUNT\");\n        rawPay = _geometricCalc(\n            _GS_START_RANDOM_OUT_,\n            _CR_RANDOM_OUT_,\n            _TOTAL_NFT_AMOUNT_ - NFTOutAmount,\n            _TOTAL_NFT_AMOUNT_\n        );\n        (,, pay) = IFilterAdmin(_OWNER_).queryBurnFee(rawPay);\n    }\n\n    // ============ Math =============\n\n    function _geometricCalc(\n        uint256 a1,\n        uint256 q,\n        uint256 start,\n        uint256 end\n    ) internal view returns (uint256) {\n        if (q == DecimalMath.ONE) {\n            return end.sub(start).mul(a1);\n        }\n        //Sn=a1*(q^n-1)/(q-1)\n        //Sn-Sm = a1*(q^n-q^m)/(q-1)\n\n        //q^n\n        uint256 qn = DecimalMath.powFloor(q, end);\n        //q^m\n        uint256 qm = DecimalMath.powFloor(q, start);\n        return a1.mul(qn.sub(qm)).div(q.sub(DecimalMath.ONE));\n    }\n    // SWC-120-Weak Sources of Randomness from Chain Attributes: L175\n    function _getRandomNum() public view returns (uint256 randomNum) {\n        randomNum = uint256(\n            keccak256(abi.encodePacked(tx.origin, blockhash(block.number - 1), gasleft()))\n        );\n    }\n\n    // ================= Ownable ================\n\n    function changeNFTInPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) external onlySuperOwner {\n        _changeNFTInPrice(newGsStart, newCr, toggleFlag);\n    }\n\n    function _changeNFTInPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) internal {\n        require(newCr > DecimalMath.ONE, \"CR_INVALID\");\n        _GS_START_IN_ = newGsStart;\n        _CR_IN_ = newCr;\n        _NFT_IN_TOGGLE_ = true;\n    }\n\n    function changeNFTRandomInPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) external onlySuperOwner {\n        _changeNFTRandomInPrice(newGsStart, newCr, toggleFlag);\n    }\n\n    function _changeNFTRandomInPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) internal {\n        require(newCr > DecimalMath.ONE, \"CR_INVALID\");\n        _GS_START_RANDOM_OUT_ = newGsStart;\n        _CR_RANDOM_OUT_ = newCr;\n        _NFT_RANDOM_OUT_TOGGLE_ = true;\n    }\n\n    function changeNFTTargetOutPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) external onlySuperOwner {\n        _changeNFTTargetOutPrice(newGsStart, newCr, toggleFlag);\n    }\n\n    function _changeNFTTargetOutPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) internal {\n        require(newCr > DecimalMath.ONE, \"CR_INVALID\");\n        _GS_START_TARGET_OUT_ = newGsStart;\n        _CR_TARGET_OUT_ = newCr;\n        _NFT_TARGET_OUT_TOGGLE_ = true;\n    }\n\n    function changeNFTAmountRange(uint256 maxNFTAmount, uint256 minNFTAmount)\n        external\n        onlySuperOwner\n    {\n        _changeNFTAmountRange(maxNFTAmount, minNFTAmount);\n    }\n\n    function _changeNFTAmountRange(uint256 maxNFTAmount, uint256 minNFTAmount) internal {\n        require(maxNFTAmount >= minNFTAmount, \"AMOUNT_INVALID\");\n        _MAX_NFT_AMOUNT_ = maxNFTAmount;\n        _MIN_NFT_AMOUNT_ = minNFTAmount;\n    }\n\n    function changeTokenIdRange(uint256 nftIdStart, uint256 nftIdEnd) external onlySuperOwner {\n        _changeTokenIdRange(nftIdStart, nftIdEnd);\n    }\n\n    function _changeTokenIdRange(uint256 nftIdStart, uint256 nftIdEnd) internal {\n        require(nftIdStart <= nftIdEnd, \"TOKEN_RANGE_INVALID\");\n\n        _NFT_ID_START_ = nftIdStart;\n        _NFT_ID_END_ = nftIdEnd;\n    }\n\n    function changeTokenIdMap(uint256[] memory tokenIds, bool[] memory isRegistered)\n        external\n        onlySuperOwner\n    {\n        _changeTokenIdMap(tokenIds, isRegistered);\n    }\n\n    function _changeTokenIdMap(uint256[] memory tokenIds, bool[] memory isRegistered) internal {\n        require(tokenIds.length == isRegistered.length, \"PARAM_NOT_MATCH\");\n\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            _SPREAD_IDS_REGISTRY_[tokenIds[i]] = isRegistered[i];\n        }\n    }\n}",
        "function": "changeNFTTargetOutPrice(uint256,uint256,bool)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/SlowMist-DODO-NFTPool Smart Contract Security Audit Report/contractV2-e16ceb038ed6bf070ea75d9359c7ad54e6f3e226/contracts/NFTPool/impl/BaseFilterV1.sol",
        "vulnerability": "External Call To User-Supplied Address (SWC 107)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract BaseFilterV1 is InitializableOwnable, ReentrancyGuard {\n    using SafeMath for uint256;\n\n    //=================== Storage ===================\n    address public _NFT_COLLECTION_;\n    uint256 public _NFT_ID_START_;\n    uint256 public _NFT_ID_END_ = uint256(-1);\n\n    //tokenId => isRegistered\n    mapping(uint256 => bool) public _SPREAD_IDS_REGISTRY_;\n\n    //tokenId => amount\n    mapping(uint256 => uint256) public _NFT_RESERVE_;\n\n    uint256[] public _NFT_IDS_;\n    uint256 public _TOTAL_NFT_AMOUNT_;\n    uint256 public _MAX_NFT_AMOUNT_;\n    uint256 public _MIN_NFT_AMOUNT_;\n\n    // GS -> Geometric sequence\n    // CR -> Common Ratio\n\n    //For Deposit NFT INto Pool\n    uint256 public _GS_START_IN_;\n    uint256 public _CR_IN_;\n    bool public _NFT_IN_TOGGLE_ = false;\n\n    //For NFT Random OUT from Pool\n    uint256 public _GS_START_RANDOM_OUT_;\n    uint256 public _CR_RANDOM_OUT_;\n    bool public _NFT_RANDOM_OUT_TOGGLE_ = false;\n\n    //For NFT Target OUT from Pool\n    uint256 public _GS_START_TARGET_OUT_;\n    uint256 public _CR_TARGET_OUT_;\n    bool public _NFT_TARGET_OUT_TOGGLE_ = false;\n\n    modifier onlySuperOwner() {\n        require(msg.sender == IFilterAdmin(_OWNER_)._OWNER_(), \"ONLY_SUPER_OWNER\");\n        _;\n    }\n\n    //==================== Query Prop ==================\n\n    function isNFTValid(address nftCollectionAddress, uint256 nftId) external view returns (bool) {\n        if (nftCollectionAddress == _NFT_COLLECTION_) {\n            return isNFTIDValid(nftId);\n        } else {\n            return false;\n        }\n    }\n\n    function isNFTIDValid(uint256 nftId) public view returns (bool) {\n        return (nftId >= _NFT_ID_START_ && nftId <= _NFT_ID_END_) || _SPREAD_IDS_REGISTRY_[nftId];\n    }\n\n    function getAvaliableNFTInAmount() public view returns (uint256) {\n        if (_MAX_NFT_AMOUNT_ <= _TOTAL_NFT_AMOUNT_) {\n            return 0;\n        } else {\n            return _MAX_NFT_AMOUNT_ - _TOTAL_NFT_AMOUNT_;\n        }\n    }\n\n    function getAvaliableNFTOutAmount() public view returns (uint256) {\n        if (_TOTAL_NFT_AMOUNT_ <= _MIN_NFT_AMOUNT_) {\n            return 0;\n        } else {\n            return _TOTAL_NFT_AMOUNT_ - _MIN_NFT_AMOUNT_;\n        }\n    }\n\n    function getNFTIndexById(uint256 tokenId) public view returns (uint256) {\n        uint256 i = 0;\n        for (; i < _NFT_IDS_.length; i++) {\n            if (_NFT_IDS_[i] == tokenId) break;\n        }\n        require(i < _NFT_IDS_.length, \"TOKEN_ID_NOT_EXSIT\");\n        return i;\n    }\n\n    //==================== Query Price ==================\n\n    function queryNFTIn(uint256 NFTInAmount)\n        public\n        view\n        returns (\n            uint256 rawReceive, \n            uint256 received\n        )\n    {\n        require(NFTInAmount <= getAvaliableNFTInAmount(), \"EXCEDD_IN_AMOUNT\");\n        rawReceive = _geometricCalc(\n            _GS_START_IN_,\n            _CR_IN_,\n            _TOTAL_NFT_AMOUNT_,\n            _TOTAL_NFT_AMOUNT_ + NFTInAmount\n        );\n        (,, received) = IFilterAdmin(_OWNER_).queryMintFee(rawReceive);\n    }\n\n    function queryNFTTargetOut(uint256 NFTOutAmount)\n        public\n        view\n        returns (\n            uint256 rawPay, \n            uint256 pay\n        )\n    {\n        require(NFTOutAmount <= getAvaliableNFTOutAmount(), \"EXCEED_OUT_AMOUNT\");\n        rawPay = _geometricCalc(\n            _GS_START_TARGET_OUT_,\n            _CR_TARGET_OUT_,\n            _TOTAL_NFT_AMOUNT_ - NFTOutAmount,\n            _TOTAL_NFT_AMOUNT_\n        );\n        (,, pay) = IFilterAdmin(_OWNER_).queryBurnFee(rawPay);\n    }\n\n    function queryNFTRandomOut(uint256 NFTOutAmount)\n        public\n        view\n        returns (\n            uint256 rawPay, \n            uint256 pay\n        )\n    {\n        require(NFTOutAmount <= getAvaliableNFTOutAmount(), \"EXCEED_OUT_AMOUNT\");\n        rawPay = _geometricCalc(\n            _GS_START_RANDOM_OUT_,\n            _CR_RANDOM_OUT_,\n            _TOTAL_NFT_AMOUNT_ - NFTOutAmount,\n            _TOTAL_NFT_AMOUNT_\n        );\n        (,, pay) = IFilterAdmin(_OWNER_).queryBurnFee(rawPay);\n    }\n\n    // ============ Math =============\n\n    function _geometricCalc(\n        uint256 a1,\n        uint256 q,\n        uint256 start,\n        uint256 end\n    ) internal view returns (uint256) {\n        if (q == DecimalMath.ONE) {\n            return end.sub(start).mul(a1);\n        }\n        //Sn=a1*(q^n-1)/(q-1)\n        //Sn-Sm = a1*(q^n-q^m)/(q-1)\n\n        //q^n\n        uint256 qn = DecimalMath.powFloor(q, end);\n        //q^m\n        uint256 qm = DecimalMath.powFloor(q, start);\n        return a1.mul(qn.sub(qm)).div(q.sub(DecimalMath.ONE));\n    }\n    // SWC-120-Weak Sources of Randomness from Chain Attributes: L175\n    function _getRandomNum() public view returns (uint256 randomNum) {\n        randomNum = uint256(\n            keccak256(abi.encodePacked(tx.origin, blockhash(block.number - 1), gasleft()))\n        );\n    }\n\n    // ================= Ownable ================\n\n    function changeNFTInPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) external onlySuperOwner {\n        _changeNFTInPrice(newGsStart, newCr, toggleFlag);\n    }\n\n    function _changeNFTInPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) internal {\n        require(newCr > DecimalMath.ONE, \"CR_INVALID\");\n        _GS_START_IN_ = newGsStart;\n        _CR_IN_ = newCr;\n        _NFT_IN_TOGGLE_ = true;\n    }\n\n    function changeNFTRandomInPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) external onlySuperOwner {\n        _changeNFTRandomInPrice(newGsStart, newCr, toggleFlag);\n    }\n\n    function _changeNFTRandomInPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) internal {\n        require(newCr > DecimalMath.ONE, \"CR_INVALID\");\n        _GS_START_RANDOM_OUT_ = newGsStart;\n        _CR_RANDOM_OUT_ = newCr;\n        _NFT_RANDOM_OUT_TOGGLE_ = true;\n    }\n\n    function changeNFTTargetOutPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) external onlySuperOwner {\n        _changeNFTTargetOutPrice(newGsStart, newCr, toggleFlag);\n    }\n\n    function _changeNFTTargetOutPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) internal {\n        require(newCr > DecimalMath.ONE, \"CR_INVALID\");\n        _GS_START_TARGET_OUT_ = newGsStart;\n        _CR_TARGET_OUT_ = newCr;\n        _NFT_TARGET_OUT_TOGGLE_ = true;\n    }\n\n    function changeNFTAmountRange(uint256 maxNFTAmount, uint256 minNFTAmount)\n        external\n        onlySuperOwner\n    {\n        _changeNFTAmountRange(maxNFTAmount, minNFTAmount);\n    }\n\n    function _changeNFTAmountRange(uint256 maxNFTAmount, uint256 minNFTAmount) internal {\n        require(maxNFTAmount >= minNFTAmount, \"AMOUNT_INVALID\");\n        _MAX_NFT_AMOUNT_ = maxNFTAmount;\n        _MIN_NFT_AMOUNT_ = minNFTAmount;\n    }\n\n    function changeTokenIdRange(uint256 nftIdStart, uint256 nftIdEnd) external onlySuperOwner {\n        _changeTokenIdRange(nftIdStart, nftIdEnd);\n    }\n\n    function _changeTokenIdRange(uint256 nftIdStart, uint256 nftIdEnd) internal {\n        require(nftIdStart <= nftIdEnd, \"TOKEN_RANGE_INVALID\");\n\n        _NFT_ID_START_ = nftIdStart;\n        _NFT_ID_END_ = nftIdEnd;\n    }\n\n    function changeTokenIdMap(uint256[] memory tokenIds, bool[] memory isRegistered)\n        external\n        onlySuperOwner\n    {\n        _changeTokenIdMap(tokenIds, isRegistered);\n    }\n\n    function _changeTokenIdMap(uint256[] memory tokenIds, bool[] memory isRegistered) internal {\n        require(tokenIds.length == isRegistered.length, \"PARAM_NOT_MATCH\");\n\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            _SPREAD_IDS_REGISTRY_[tokenIds[i]] = isRegistered[i];\n        }\n    }\n}",
        "function": "changeNFTTargetOutPrice(uint256,uint256,bool)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/SlowMist-DODO-NFTPool Smart Contract Security Audit Report/contractV2-e16ceb038ed6bf070ea75d9359c7ad54e6f3e226/contracts/NFTPool/impl/BaseFilterV1.sol",
        "vulnerability": "Dependence on tx.origin (SWC 115)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract BaseFilterV1 is InitializableOwnable, ReentrancyGuard {\n    using SafeMath for uint256;\n\n    //=================== Storage ===================\n    address public _NFT_COLLECTION_;\n    uint256 public _NFT_ID_START_;\n    uint256 public _NFT_ID_END_ = uint256(-1);\n\n    //tokenId => isRegistered\n    mapping(uint256 => bool) public _SPREAD_IDS_REGISTRY_;\n\n    //tokenId => amount\n    mapping(uint256 => uint256) public _NFT_RESERVE_;\n\n    uint256[] public _NFT_IDS_;\n    uint256 public _TOTAL_NFT_AMOUNT_;\n    uint256 public _MAX_NFT_AMOUNT_;\n    uint256 public _MIN_NFT_AMOUNT_;\n\n    // GS -> Geometric sequence\n    // CR -> Common Ratio\n\n    //For Deposit NFT INto Pool\n    uint256 public _GS_START_IN_;\n    uint256 public _CR_IN_;\n    bool public _NFT_IN_TOGGLE_ = false;\n\n    //For NFT Random OUT from Pool\n    uint256 public _GS_START_RANDOM_OUT_;\n    uint256 public _CR_RANDOM_OUT_;\n    bool public _NFT_RANDOM_OUT_TOGGLE_ = false;\n\n    //For NFT Target OUT from Pool\n    uint256 public _GS_START_TARGET_OUT_;\n    uint256 public _CR_TARGET_OUT_;\n    bool public _NFT_TARGET_OUT_TOGGLE_ = false;\n\n    modifier onlySuperOwner() {\n        require(msg.sender == IFilterAdmin(_OWNER_)._OWNER_(), \"ONLY_SUPER_OWNER\");\n        _;\n    }\n\n    //==================== Query Prop ==================\n\n    function isNFTValid(address nftCollectionAddress, uint256 nftId) external view returns (bool) {\n        if (nftCollectionAddress == _NFT_COLLECTION_) {\n            return isNFTIDValid(nftId);\n        } else {\n            return false;\n        }\n    }\n\n    function isNFTIDValid(uint256 nftId) public view returns (bool) {\n        return (nftId >= _NFT_ID_START_ && nftId <= _NFT_ID_END_) || _SPREAD_IDS_REGISTRY_[nftId];\n    }\n\n    function getAvaliableNFTInAmount() public view returns (uint256) {\n        if (_MAX_NFT_AMOUNT_ <= _TOTAL_NFT_AMOUNT_) {\n            return 0;\n        } else {\n            return _MAX_NFT_AMOUNT_ - _TOTAL_NFT_AMOUNT_;\n        }\n    }\n\n    function getAvaliableNFTOutAmount() public view returns (uint256) {\n        if (_TOTAL_NFT_AMOUNT_ <= _MIN_NFT_AMOUNT_) {\n            return 0;\n        } else {\n            return _TOTAL_NFT_AMOUNT_ - _MIN_NFT_AMOUNT_;\n        }\n    }\n\n    function getNFTIndexById(uint256 tokenId) public view returns (uint256) {\n        uint256 i = 0;\n        for (; i < _NFT_IDS_.length; i++) {\n            if (_NFT_IDS_[i] == tokenId) break;\n        }\n        require(i < _NFT_IDS_.length, \"TOKEN_ID_NOT_EXSIT\");\n        return i;\n    }\n\n    //==================== Query Price ==================\n\n    function queryNFTIn(uint256 NFTInAmount)\n        public\n        view\n        returns (\n            uint256 rawReceive, \n            uint256 received\n        )\n    {\n        require(NFTInAmount <= getAvaliableNFTInAmount(), \"EXCEDD_IN_AMOUNT\");\n        rawReceive = _geometricCalc(\n            _GS_START_IN_,\n            _CR_IN_,\n            _TOTAL_NFT_AMOUNT_,\n            _TOTAL_NFT_AMOUNT_ + NFTInAmount\n        );\n        (,, received) = IFilterAdmin(_OWNER_).queryMintFee(rawReceive);\n    }\n\n    function queryNFTTargetOut(uint256 NFTOutAmount)\n        public\n        view\n        returns (\n            uint256 rawPay, \n            uint256 pay\n        )\n    {\n        require(NFTOutAmount <= getAvaliableNFTOutAmount(), \"EXCEED_OUT_AMOUNT\");\n        rawPay = _geometricCalc(\n            _GS_START_TARGET_OUT_,\n            _CR_TARGET_OUT_,\n            _TOTAL_NFT_AMOUNT_ - NFTOutAmount,\n            _TOTAL_NFT_AMOUNT_\n        );\n        (,, pay) = IFilterAdmin(_OWNER_).queryBurnFee(rawPay);\n    }\n\n    function queryNFTRandomOut(uint256 NFTOutAmount)\n        public\n        view\n        returns (\n            uint256 rawPay, \n            uint256 pay\n        )\n    {\n        require(NFTOutAmount <= getAvaliableNFTOutAmount(), \"EXCEED_OUT_AMOUNT\");\n        rawPay = _geometricCalc(\n            _GS_START_RANDOM_OUT_,\n            _CR_RANDOM_OUT_,\n            _TOTAL_NFT_AMOUNT_ - NFTOutAmount,\n            _TOTAL_NFT_AMOUNT_\n        );\n        (,, pay) = IFilterAdmin(_OWNER_).queryBurnFee(rawPay);\n    }\n\n    // ============ Math =============\n\n    function _geometricCalc(\n        uint256 a1,\n        uint256 q,\n        uint256 start,\n        uint256 end\n    ) internal view returns (uint256) {\n        if (q == DecimalMath.ONE) {\n            return end.sub(start).mul(a1);\n        }\n        //Sn=a1*(q^n-1)/(q-1)\n        //Sn-Sm = a1*(q^n-q^m)/(q-1)\n\n        //q^n\n        uint256 qn = DecimalMath.powFloor(q, end);\n        //q^m\n        uint256 qm = DecimalMath.powFloor(q, start);\n        return a1.mul(qn.sub(qm)).div(q.sub(DecimalMath.ONE));\n    }\n    // SWC-120-Weak Sources of Randomness from Chain Attributes: L175\n    function _getRandomNum() public view returns (uint256 randomNum) {\n        randomNum = uint256(\n            keccak256(abi.encodePacked(tx.origin, blockhash(block.number - 1), gasleft()))\n        );\n    }\n\n    // ================= Ownable ================\n\n    function changeNFTInPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) external onlySuperOwner {\n        _changeNFTInPrice(newGsStart, newCr, toggleFlag);\n    }\n\n    function _changeNFTInPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) internal {\n        require(newCr > DecimalMath.ONE, \"CR_INVALID\");\n        _GS_START_IN_ = newGsStart;\n        _CR_IN_ = newCr;\n        _NFT_IN_TOGGLE_ = true;\n    }\n\n    function changeNFTRandomInPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) external onlySuperOwner {\n        _changeNFTRandomInPrice(newGsStart, newCr, toggleFlag);\n    }\n\n    function _changeNFTRandomInPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) internal {\n        require(newCr > DecimalMath.ONE, \"CR_INVALID\");\n        _GS_START_RANDOM_OUT_ = newGsStart;\n        _CR_RANDOM_OUT_ = newCr;\n        _NFT_RANDOM_OUT_TOGGLE_ = true;\n    }\n\n    function changeNFTTargetOutPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) external onlySuperOwner {\n        _changeNFTTargetOutPrice(newGsStart, newCr, toggleFlag);\n    }\n\n    function _changeNFTTargetOutPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) internal {\n        require(newCr > DecimalMath.ONE, \"CR_INVALID\");\n        _GS_START_TARGET_OUT_ = newGsStart;\n        _CR_TARGET_OUT_ = newCr;\n        _NFT_TARGET_OUT_TOGGLE_ = true;\n    }\n\n    function changeNFTAmountRange(uint256 maxNFTAmount, uint256 minNFTAmount)\n        external\n        onlySuperOwner\n    {\n        _changeNFTAmountRange(maxNFTAmount, minNFTAmount);\n    }\n\n    function _changeNFTAmountRange(uint256 maxNFTAmount, uint256 minNFTAmount) internal {\n        require(maxNFTAmount >= minNFTAmount, \"AMOUNT_INVALID\");\n        _MAX_NFT_AMOUNT_ = maxNFTAmount;\n        _MIN_NFT_AMOUNT_ = minNFTAmount;\n    }\n\n    function changeTokenIdRange(uint256 nftIdStart, uint256 nftIdEnd) external onlySuperOwner {\n        _changeTokenIdRange(nftIdStart, nftIdEnd);\n    }\n\n    function _changeTokenIdRange(uint256 nftIdStart, uint256 nftIdEnd) internal {\n        require(nftIdStart <= nftIdEnd, \"TOKEN_RANGE_INVALID\");\n\n        _NFT_ID_START_ = nftIdStart;\n        _NFT_ID_END_ = nftIdEnd;\n    }\n\n    function changeTokenIdMap(uint256[] memory tokenIds, bool[] memory isRegistered)\n        external\n        onlySuperOwner\n    {\n        _changeTokenIdMap(tokenIds, isRegistered);\n    }\n\n    function _changeTokenIdMap(uint256[] memory tokenIds, bool[] memory isRegistered) internal {\n        require(tokenIds.length == isRegistered.length, \"PARAM_NOT_MATCH\");\n\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            _SPREAD_IDS_REGISTRY_[tokenIds[i]] = isRegistered[i];\n        }\n    }\n}",
        "function": "transferOwnership(address)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/SlowMist-DODO-NFTPool Smart Contract Security Audit Report/contractV2-e16ceb038ed6bf070ea75d9359c7ad54e6f3e226/contracts/NFTPool/impl/BaseFilterV1.sol",
        "vulnerability": "Dependence on tx.origin (SWC 115)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract BaseFilterV1 is InitializableOwnable, ReentrancyGuard {\n    using SafeMath for uint256;\n\n    //=================== Storage ===================\n    address public _NFT_COLLECTION_;\n    uint256 public _NFT_ID_START_;\n    uint256 public _NFT_ID_END_ = uint256(-1);\n\n    //tokenId => isRegistered\n    mapping(uint256 => bool) public _SPREAD_IDS_REGISTRY_;\n\n    //tokenId => amount\n    mapping(uint256 => uint256) public _NFT_RESERVE_;\n\n    uint256[] public _NFT_IDS_;\n    uint256 public _TOTAL_NFT_AMOUNT_;\n    uint256 public _MAX_NFT_AMOUNT_;\n    uint256 public _MIN_NFT_AMOUNT_;\n\n    // GS -> Geometric sequence\n    // CR -> Common Ratio\n\n    //For Deposit NFT INto Pool\n    uint256 public _GS_START_IN_;\n    uint256 public _CR_IN_;\n    bool public _NFT_IN_TOGGLE_ = false;\n\n    //For NFT Random OUT from Pool\n    uint256 public _GS_START_RANDOM_OUT_;\n    uint256 public _CR_RANDOM_OUT_;\n    bool public _NFT_RANDOM_OUT_TOGGLE_ = false;\n\n    //For NFT Target OUT from Pool\n    uint256 public _GS_START_TARGET_OUT_;\n    uint256 public _CR_TARGET_OUT_;\n    bool public _NFT_TARGET_OUT_TOGGLE_ = false;\n\n    modifier onlySuperOwner() {\n        require(msg.sender == IFilterAdmin(_OWNER_)._OWNER_(), \"ONLY_SUPER_OWNER\");\n        _;\n    }\n\n    //==================== Query Prop ==================\n\n    function isNFTValid(address nftCollectionAddress, uint256 nftId) external view returns (bool) {\n        if (nftCollectionAddress == _NFT_COLLECTION_) {\n            return isNFTIDValid(nftId);\n        } else {\n            return false;\n        }\n    }\n\n    function isNFTIDValid(uint256 nftId) public view returns (bool) {\n        return (nftId >= _NFT_ID_START_ && nftId <= _NFT_ID_END_) || _SPREAD_IDS_REGISTRY_[nftId];\n    }\n\n    function getAvaliableNFTInAmount() public view returns (uint256) {\n        if (_MAX_NFT_AMOUNT_ <= _TOTAL_NFT_AMOUNT_) {\n            return 0;\n        } else {\n            return _MAX_NFT_AMOUNT_ - _TOTAL_NFT_AMOUNT_;\n        }\n    }\n\n    function getAvaliableNFTOutAmount() public view returns (uint256) {\n        if (_TOTAL_NFT_AMOUNT_ <= _MIN_NFT_AMOUNT_) {\n            return 0;\n        } else {\n            return _TOTAL_NFT_AMOUNT_ - _MIN_NFT_AMOUNT_;\n        }\n    }\n\n    function getNFTIndexById(uint256 tokenId) public view returns (uint256) {\n        uint256 i = 0;\n        for (; i < _NFT_IDS_.length; i++) {\n            if (_NFT_IDS_[i] == tokenId) break;\n        }\n        require(i < _NFT_IDS_.length, \"TOKEN_ID_NOT_EXSIT\");\n        return i;\n    }\n\n    //==================== Query Price ==================\n\n    function queryNFTIn(uint256 NFTInAmount)\n        public\n        view\n        returns (\n            uint256 rawReceive, \n            uint256 received\n        )\n    {\n        require(NFTInAmount <= getAvaliableNFTInAmount(), \"EXCEDD_IN_AMOUNT\");\n        rawReceive = _geometricCalc(\n            _GS_START_IN_,\n            _CR_IN_,\n            _TOTAL_NFT_AMOUNT_,\n            _TOTAL_NFT_AMOUNT_ + NFTInAmount\n        );\n        (,, received) = IFilterAdmin(_OWNER_).queryMintFee(rawReceive);\n    }\n\n    function queryNFTTargetOut(uint256 NFTOutAmount)\n        public\n        view\n        returns (\n            uint256 rawPay, \n            uint256 pay\n        )\n    {\n        require(NFTOutAmount <= getAvaliableNFTOutAmount(), \"EXCEED_OUT_AMOUNT\");\n        rawPay = _geometricCalc(\n            _GS_START_TARGET_OUT_,\n            _CR_TARGET_OUT_,\n            _TOTAL_NFT_AMOUNT_ - NFTOutAmount,\n            _TOTAL_NFT_AMOUNT_\n        );\n        (,, pay) = IFilterAdmin(_OWNER_).queryBurnFee(rawPay);\n    }\n\n    function queryNFTRandomOut(uint256 NFTOutAmount)\n        public\n        view\n        returns (\n            uint256 rawPay, \n            uint256 pay\n        )\n    {\n        require(NFTOutAmount <= getAvaliableNFTOutAmount(), \"EXCEED_OUT_AMOUNT\");\n        rawPay = _geometricCalc(\n            _GS_START_RANDOM_OUT_,\n            _CR_RANDOM_OUT_,\n            _TOTAL_NFT_AMOUNT_ - NFTOutAmount,\n            _TOTAL_NFT_AMOUNT_\n        );\n        (,, pay) = IFilterAdmin(_OWNER_).queryBurnFee(rawPay);\n    }\n\n    // ============ Math =============\n\n    function _geometricCalc(\n        uint256 a1,\n        uint256 q,\n        uint256 start,\n        uint256 end\n    ) internal view returns (uint256) {\n        if (q == DecimalMath.ONE) {\n            return end.sub(start).mul(a1);\n        }\n        //Sn=a1*(q^n-1)/(q-1)\n        //Sn-Sm = a1*(q^n-q^m)/(q-1)\n\n        //q^n\n        uint256 qn = DecimalMath.powFloor(q, end);\n        //q^m\n        uint256 qm = DecimalMath.powFloor(q, start);\n        return a1.mul(qn.sub(qm)).div(q.sub(DecimalMath.ONE));\n    }\n    // SWC-120-Weak Sources of Randomness from Chain Attributes: L175\n    function _getRandomNum() public view returns (uint256 randomNum) {\n        randomNum = uint256(\n            keccak256(abi.encodePacked(tx.origin, blockhash(block.number - 1), gasleft()))\n        );\n    }\n\n    // ================= Ownable ================\n\n    function changeNFTInPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) external onlySuperOwner {\n        _changeNFTInPrice(newGsStart, newCr, toggleFlag);\n    }\n\n    function _changeNFTInPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) internal {\n        require(newCr > DecimalMath.ONE, \"CR_INVALID\");\n        _GS_START_IN_ = newGsStart;\n        _CR_IN_ = newCr;\n        _NFT_IN_TOGGLE_ = true;\n    }\n\n    function changeNFTRandomInPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) external onlySuperOwner {\n        _changeNFTRandomInPrice(newGsStart, newCr, toggleFlag);\n    }\n\n    function _changeNFTRandomInPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) internal {\n        require(newCr > DecimalMath.ONE, \"CR_INVALID\");\n        _GS_START_RANDOM_OUT_ = newGsStart;\n        _CR_RANDOM_OUT_ = newCr;\n        _NFT_RANDOM_OUT_TOGGLE_ = true;\n    }\n\n    function changeNFTTargetOutPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) external onlySuperOwner {\n        _changeNFTTargetOutPrice(newGsStart, newCr, toggleFlag);\n    }\n\n    function _changeNFTTargetOutPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) internal {\n        require(newCr > DecimalMath.ONE, \"CR_INVALID\");\n        _GS_START_TARGET_OUT_ = newGsStart;\n        _CR_TARGET_OUT_ = newCr;\n        _NFT_TARGET_OUT_TOGGLE_ = true;\n    }\n\n    function changeNFTAmountRange(uint256 maxNFTAmount, uint256 minNFTAmount)\n        external\n        onlySuperOwner\n    {\n        _changeNFTAmountRange(maxNFTAmount, minNFTAmount);\n    }\n\n    function _changeNFTAmountRange(uint256 maxNFTAmount, uint256 minNFTAmount) internal {\n        require(maxNFTAmount >= minNFTAmount, \"AMOUNT_INVALID\");\n        _MAX_NFT_AMOUNT_ = maxNFTAmount;\n        _MIN_NFT_AMOUNT_ = minNFTAmount;\n    }\n\n    function changeTokenIdRange(uint256 nftIdStart, uint256 nftIdEnd) external onlySuperOwner {\n        _changeTokenIdRange(nftIdStart, nftIdEnd);\n    }\n\n    function _changeTokenIdRange(uint256 nftIdStart, uint256 nftIdEnd) internal {\n        require(nftIdStart <= nftIdEnd, \"TOKEN_RANGE_INVALID\");\n\n        _NFT_ID_START_ = nftIdStart;\n        _NFT_ID_END_ = nftIdEnd;\n    }\n\n    function changeTokenIdMap(uint256[] memory tokenIds, bool[] memory isRegistered)\n        external\n        onlySuperOwner\n    {\n        _changeTokenIdMap(tokenIds, isRegistered);\n    }\n\n    function _changeTokenIdMap(uint256[] memory tokenIds, bool[] memory isRegistered) internal {\n        require(tokenIds.length == isRegistered.length, \"PARAM_NOT_MATCH\");\n\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            _SPREAD_IDS_REGISTRY_[tokenIds[i]] = isRegistered[i];\n        }\n    }\n}",
        "function": "changeTokenIdRange(uint256,uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/SlowMist-DODO-NFTPool Smart Contract Security Audit Report/contractV2-e16ceb038ed6bf070ea75d9359c7ad54e6f3e226/contracts/NFTPool/impl/BaseFilterV1.sol",
        "vulnerability": "State access after external call (SWC 107)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract BaseFilterV1 is InitializableOwnable, ReentrancyGuard {\n    using SafeMath for uint256;\n\n    //=================== Storage ===================\n    address public _NFT_COLLECTION_;\n    uint256 public _NFT_ID_START_;\n    uint256 public _NFT_ID_END_ = uint256(-1);\n\n    //tokenId => isRegistered\n    mapping(uint256 => bool) public _SPREAD_IDS_REGISTRY_;\n\n    //tokenId => amount\n    mapping(uint256 => uint256) public _NFT_RESERVE_;\n\n    uint256[] public _NFT_IDS_;\n    uint256 public _TOTAL_NFT_AMOUNT_;\n    uint256 public _MAX_NFT_AMOUNT_;\n    uint256 public _MIN_NFT_AMOUNT_;\n\n    // GS -> Geometric sequence\n    // CR -> Common Ratio\n\n    //For Deposit NFT INto Pool\n    uint256 public _GS_START_IN_;\n    uint256 public _CR_IN_;\n    bool public _NFT_IN_TOGGLE_ = false;\n\n    //For NFT Random OUT from Pool\n    uint256 public _GS_START_RANDOM_OUT_;\n    uint256 public _CR_RANDOM_OUT_;\n    bool public _NFT_RANDOM_OUT_TOGGLE_ = false;\n\n    //For NFT Target OUT from Pool\n    uint256 public _GS_START_TARGET_OUT_;\n    uint256 public _CR_TARGET_OUT_;\n    bool public _NFT_TARGET_OUT_TOGGLE_ = false;\n\n    modifier onlySuperOwner() {\n        require(msg.sender == IFilterAdmin(_OWNER_)._OWNER_(), \"ONLY_SUPER_OWNER\");\n        _;\n    }\n\n    //==================== Query Prop ==================\n\n    function isNFTValid(address nftCollectionAddress, uint256 nftId) external view returns (bool) {\n        if (nftCollectionAddress == _NFT_COLLECTION_) {\n            return isNFTIDValid(nftId);\n        } else {\n            return false;\n        }\n    }\n\n    function isNFTIDValid(uint256 nftId) public view returns (bool) {\n        return (nftId >= _NFT_ID_START_ && nftId <= _NFT_ID_END_) || _SPREAD_IDS_REGISTRY_[nftId];\n    }\n\n    function getAvaliableNFTInAmount() public view returns (uint256) {\n        if (_MAX_NFT_AMOUNT_ <= _TOTAL_NFT_AMOUNT_) {\n            return 0;\n        } else {\n            return _MAX_NFT_AMOUNT_ - _TOTAL_NFT_AMOUNT_;\n        }\n    }\n\n    function getAvaliableNFTOutAmount() public view returns (uint256) {\n        if (_TOTAL_NFT_AMOUNT_ <= _MIN_NFT_AMOUNT_) {\n            return 0;\n        } else {\n            return _TOTAL_NFT_AMOUNT_ - _MIN_NFT_AMOUNT_;\n        }\n    }\n\n    function getNFTIndexById(uint256 tokenId) public view returns (uint256) {\n        uint256 i = 0;\n        for (; i < _NFT_IDS_.length; i++) {\n            if (_NFT_IDS_[i] == tokenId) break;\n        }\n        require(i < _NFT_IDS_.length, \"TOKEN_ID_NOT_EXSIT\");\n        return i;\n    }\n\n    //==================== Query Price ==================\n\n    function queryNFTIn(uint256 NFTInAmount)\n        public\n        view\n        returns (\n            uint256 rawReceive, \n            uint256 received\n        )\n    {\n        require(NFTInAmount <= getAvaliableNFTInAmount(), \"EXCEDD_IN_AMOUNT\");\n        rawReceive = _geometricCalc(\n            _GS_START_IN_,\n            _CR_IN_,\n            _TOTAL_NFT_AMOUNT_,\n            _TOTAL_NFT_AMOUNT_ + NFTInAmount\n        );\n        (,, received) = IFilterAdmin(_OWNER_).queryMintFee(rawReceive);\n    }\n\n    function queryNFTTargetOut(uint256 NFTOutAmount)\n        public\n        view\n        returns (\n            uint256 rawPay, \n            uint256 pay\n        )\n    {\n        require(NFTOutAmount <= getAvaliableNFTOutAmount(), \"EXCEED_OUT_AMOUNT\");\n        rawPay = _geometricCalc(\n            _GS_START_TARGET_OUT_,\n            _CR_TARGET_OUT_,\n            _TOTAL_NFT_AMOUNT_ - NFTOutAmount,\n            _TOTAL_NFT_AMOUNT_\n        );\n        (,, pay) = IFilterAdmin(_OWNER_).queryBurnFee(rawPay);\n    }\n\n    function queryNFTRandomOut(uint256 NFTOutAmount)\n        public\n        view\n        returns (\n            uint256 rawPay, \n            uint256 pay\n        )\n    {\n        require(NFTOutAmount <= getAvaliableNFTOutAmount(), \"EXCEED_OUT_AMOUNT\");\n        rawPay = _geometricCalc(\n            _GS_START_RANDOM_OUT_,\n            _CR_RANDOM_OUT_,\n            _TOTAL_NFT_AMOUNT_ - NFTOutAmount,\n            _TOTAL_NFT_AMOUNT_\n        );\n        (,, pay) = IFilterAdmin(_OWNER_).queryBurnFee(rawPay);\n    }\n\n    // ============ Math =============\n\n    function _geometricCalc(\n        uint256 a1,\n        uint256 q,\n        uint256 start,\n        uint256 end\n    ) internal view returns (uint256) {\n        if (q == DecimalMath.ONE) {\n            return end.sub(start).mul(a1);\n        }\n        //Sn=a1*(q^n-1)/(q-1)\n        //Sn-Sm = a1*(q^n-q^m)/(q-1)\n\n        //q^n\n        uint256 qn = DecimalMath.powFloor(q, end);\n        //q^m\n        uint256 qm = DecimalMath.powFloor(q, start);\n        return a1.mul(qn.sub(qm)).div(q.sub(DecimalMath.ONE));\n    }\n    // SWC-120-Weak Sources of Randomness from Chain Attributes: L175\n    function _getRandomNum() public view returns (uint256 randomNum) {\n        randomNum = uint256(\n            keccak256(abi.encodePacked(tx.origin, blockhash(block.number - 1), gasleft()))\n        );\n    }\n\n    // ================= Ownable ================\n\n    function changeNFTInPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) external onlySuperOwner {\n        _changeNFTInPrice(newGsStart, newCr, toggleFlag);\n    }\n\n    function _changeNFTInPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) internal {\n        require(newCr > DecimalMath.ONE, \"CR_INVALID\");\n        _GS_START_IN_ = newGsStart;\n        _CR_IN_ = newCr;\n        _NFT_IN_TOGGLE_ = true;\n    }\n\n    function changeNFTRandomInPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) external onlySuperOwner {\n        _changeNFTRandomInPrice(newGsStart, newCr, toggleFlag);\n    }\n\n    function _changeNFTRandomInPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) internal {\n        require(newCr > DecimalMath.ONE, \"CR_INVALID\");\n        _GS_START_RANDOM_OUT_ = newGsStart;\n        _CR_RANDOM_OUT_ = newCr;\n        _NFT_RANDOM_OUT_TOGGLE_ = true;\n    }\n\n    function changeNFTTargetOutPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) external onlySuperOwner {\n        _changeNFTTargetOutPrice(newGsStart, newCr, toggleFlag);\n    }\n\n    function _changeNFTTargetOutPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) internal {\n        require(newCr > DecimalMath.ONE, \"CR_INVALID\");\n        _GS_START_TARGET_OUT_ = newGsStart;\n        _CR_TARGET_OUT_ = newCr;\n        _NFT_TARGET_OUT_TOGGLE_ = true;\n    }\n\n    function changeNFTAmountRange(uint256 maxNFTAmount, uint256 minNFTAmount)\n        external\n        onlySuperOwner\n    {\n        _changeNFTAmountRange(maxNFTAmount, minNFTAmount);\n    }\n\n    function _changeNFTAmountRange(uint256 maxNFTAmount, uint256 minNFTAmount) internal {\n        require(maxNFTAmount >= minNFTAmount, \"AMOUNT_INVALID\");\n        _MAX_NFT_AMOUNT_ = maxNFTAmount;\n        _MIN_NFT_AMOUNT_ = minNFTAmount;\n    }\n\n    function changeTokenIdRange(uint256 nftIdStart, uint256 nftIdEnd) external onlySuperOwner {\n        _changeTokenIdRange(nftIdStart, nftIdEnd);\n    }\n\n    function _changeTokenIdRange(uint256 nftIdStart, uint256 nftIdEnd) internal {\n        require(nftIdStart <= nftIdEnd, \"TOKEN_RANGE_INVALID\");\n\n        _NFT_ID_START_ = nftIdStart;\n        _NFT_ID_END_ = nftIdEnd;\n    }\n\n    function changeTokenIdMap(uint256[] memory tokenIds, bool[] memory isRegistered)\n        external\n        onlySuperOwner\n    {\n        _changeTokenIdMap(tokenIds, isRegistered);\n    }\n\n    function _changeTokenIdMap(uint256[] memory tokenIds, bool[] memory isRegistered) internal {\n        require(tokenIds.length == isRegistered.length, \"PARAM_NOT_MATCH\");\n\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            _SPREAD_IDS_REGISTRY_[tokenIds[i]] = isRegistered[i];\n        }\n    }\n}",
        "function": "changeTokenIdRange(uint256,uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/SlowMist-DODO-NFTPool Smart Contract Security Audit Report/contractV2-e16ceb038ed6bf070ea75d9359c7ad54e6f3e226/contracts/NFTPool/impl/BaseFilterV1.sol",
        "vulnerability": "State access after external call (SWC 107)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract BaseFilterV1 is InitializableOwnable, ReentrancyGuard {\n    using SafeMath for uint256;\n\n    //=================== Storage ===================\n    address public _NFT_COLLECTION_;\n    uint256 public _NFT_ID_START_;\n    uint256 public _NFT_ID_END_ = uint256(-1);\n\n    //tokenId => isRegistered\n    mapping(uint256 => bool) public _SPREAD_IDS_REGISTRY_;\n\n    //tokenId => amount\n    mapping(uint256 => uint256) public _NFT_RESERVE_;\n\n    uint256[] public _NFT_IDS_;\n    uint256 public _TOTAL_NFT_AMOUNT_;\n    uint256 public _MAX_NFT_AMOUNT_;\n    uint256 public _MIN_NFT_AMOUNT_;\n\n    // GS -> Geometric sequence\n    // CR -> Common Ratio\n\n    //For Deposit NFT INto Pool\n    uint256 public _GS_START_IN_;\n    uint256 public _CR_IN_;\n    bool public _NFT_IN_TOGGLE_ = false;\n\n    //For NFT Random OUT from Pool\n    uint256 public _GS_START_RANDOM_OUT_;\n    uint256 public _CR_RANDOM_OUT_;\n    bool public _NFT_RANDOM_OUT_TOGGLE_ = false;\n\n    //For NFT Target OUT from Pool\n    uint256 public _GS_START_TARGET_OUT_;\n    uint256 public _CR_TARGET_OUT_;\n    bool public _NFT_TARGET_OUT_TOGGLE_ = false;\n\n    modifier onlySuperOwner() {\n        require(msg.sender == IFilterAdmin(_OWNER_)._OWNER_(), \"ONLY_SUPER_OWNER\");\n        _;\n    }\n\n    //==================== Query Prop ==================\n\n    function isNFTValid(address nftCollectionAddress, uint256 nftId) external view returns (bool) {\n        if (nftCollectionAddress == _NFT_COLLECTION_) {\n            return isNFTIDValid(nftId);\n        } else {\n            return false;\n        }\n    }\n\n    function isNFTIDValid(uint256 nftId) public view returns (bool) {\n        return (nftId >= _NFT_ID_START_ && nftId <= _NFT_ID_END_) || _SPREAD_IDS_REGISTRY_[nftId];\n    }\n\n    function getAvaliableNFTInAmount() public view returns (uint256) {\n        if (_MAX_NFT_AMOUNT_ <= _TOTAL_NFT_AMOUNT_) {\n            return 0;\n        } else {\n            return _MAX_NFT_AMOUNT_ - _TOTAL_NFT_AMOUNT_;\n        }\n    }\n\n    function getAvaliableNFTOutAmount() public view returns (uint256) {\n        if (_TOTAL_NFT_AMOUNT_ <= _MIN_NFT_AMOUNT_) {\n            return 0;\n        } else {\n            return _TOTAL_NFT_AMOUNT_ - _MIN_NFT_AMOUNT_;\n        }\n    }\n\n    function getNFTIndexById(uint256 tokenId) public view returns (uint256) {\n        uint256 i = 0;\n        for (; i < _NFT_IDS_.length; i++) {\n            if (_NFT_IDS_[i] == tokenId) break;\n        }\n        require(i < _NFT_IDS_.length, \"TOKEN_ID_NOT_EXSIT\");\n        return i;\n    }\n\n    //==================== Query Price ==================\n\n    function queryNFTIn(uint256 NFTInAmount)\n        public\n        view\n        returns (\n            uint256 rawReceive, \n            uint256 received\n        )\n    {\n        require(NFTInAmount <= getAvaliableNFTInAmount(), \"EXCEDD_IN_AMOUNT\");\n        rawReceive = _geometricCalc(\n            _GS_START_IN_,\n            _CR_IN_,\n            _TOTAL_NFT_AMOUNT_,\n            _TOTAL_NFT_AMOUNT_ + NFTInAmount\n        );\n        (,, received) = IFilterAdmin(_OWNER_).queryMintFee(rawReceive);\n    }\n\n    function queryNFTTargetOut(uint256 NFTOutAmount)\n        public\n        view\n        returns (\n            uint256 rawPay, \n            uint256 pay\n        )\n    {\n        require(NFTOutAmount <= getAvaliableNFTOutAmount(), \"EXCEED_OUT_AMOUNT\");\n        rawPay = _geometricCalc(\n            _GS_START_TARGET_OUT_,\n            _CR_TARGET_OUT_,\n            _TOTAL_NFT_AMOUNT_ - NFTOutAmount,\n            _TOTAL_NFT_AMOUNT_\n        );\n        (,, pay) = IFilterAdmin(_OWNER_).queryBurnFee(rawPay);\n    }\n\n    function queryNFTRandomOut(uint256 NFTOutAmount)\n        public\n        view\n        returns (\n            uint256 rawPay, \n            uint256 pay\n        )\n    {\n        require(NFTOutAmount <= getAvaliableNFTOutAmount(), \"EXCEED_OUT_AMOUNT\");\n        rawPay = _geometricCalc(\n            _GS_START_RANDOM_OUT_,\n            _CR_RANDOM_OUT_,\n            _TOTAL_NFT_AMOUNT_ - NFTOutAmount,\n            _TOTAL_NFT_AMOUNT_\n        );\n        (,, pay) = IFilterAdmin(_OWNER_).queryBurnFee(rawPay);\n    }\n\n    // ============ Math =============\n\n    function _geometricCalc(\n        uint256 a1,\n        uint256 q,\n        uint256 start,\n        uint256 end\n    ) internal view returns (uint256) {\n        if (q == DecimalMath.ONE) {\n            return end.sub(start).mul(a1);\n        }\n        //Sn=a1*(q^n-1)/(q-1)\n        //Sn-Sm = a1*(q^n-q^m)/(q-1)\n\n        //q^n\n        uint256 qn = DecimalMath.powFloor(q, end);\n        //q^m\n        uint256 qm = DecimalMath.powFloor(q, start);\n        return a1.mul(qn.sub(qm)).div(q.sub(DecimalMath.ONE));\n    }\n    // SWC-120-Weak Sources of Randomness from Chain Attributes: L175\n    function _getRandomNum() public view returns (uint256 randomNum) {\n        randomNum = uint256(\n            keccak256(abi.encodePacked(tx.origin, blockhash(block.number - 1), gasleft()))\n        );\n    }\n\n    // ================= Ownable ================\n\n    function changeNFTInPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) external onlySuperOwner {\n        _changeNFTInPrice(newGsStart, newCr, toggleFlag);\n    }\n\n    function _changeNFTInPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) internal {\n        require(newCr > DecimalMath.ONE, \"CR_INVALID\");\n        _GS_START_IN_ = newGsStart;\n        _CR_IN_ = newCr;\n        _NFT_IN_TOGGLE_ = true;\n    }\n\n    function changeNFTRandomInPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) external onlySuperOwner {\n        _changeNFTRandomInPrice(newGsStart, newCr, toggleFlag);\n    }\n\n    function _changeNFTRandomInPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) internal {\n        require(newCr > DecimalMath.ONE, \"CR_INVALID\");\n        _GS_START_RANDOM_OUT_ = newGsStart;\n        _CR_RANDOM_OUT_ = newCr;\n        _NFT_RANDOM_OUT_TOGGLE_ = true;\n    }\n\n    function changeNFTTargetOutPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) external onlySuperOwner {\n        _changeNFTTargetOutPrice(newGsStart, newCr, toggleFlag);\n    }\n\n    function _changeNFTTargetOutPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) internal {\n        require(newCr > DecimalMath.ONE, \"CR_INVALID\");\n        _GS_START_TARGET_OUT_ = newGsStart;\n        _CR_TARGET_OUT_ = newCr;\n        _NFT_TARGET_OUT_TOGGLE_ = true;\n    }\n\n    function changeNFTAmountRange(uint256 maxNFTAmount, uint256 minNFTAmount)\n        external\n        onlySuperOwner\n    {\n        _changeNFTAmountRange(maxNFTAmount, minNFTAmount);\n    }\n\n    function _changeNFTAmountRange(uint256 maxNFTAmount, uint256 minNFTAmount) internal {\n        require(maxNFTAmount >= minNFTAmount, \"AMOUNT_INVALID\");\n        _MAX_NFT_AMOUNT_ = maxNFTAmount;\n        _MIN_NFT_AMOUNT_ = minNFTAmount;\n    }\n\n    function changeTokenIdRange(uint256 nftIdStart, uint256 nftIdEnd) external onlySuperOwner {\n        _changeTokenIdRange(nftIdStart, nftIdEnd);\n    }\n\n    function _changeTokenIdRange(uint256 nftIdStart, uint256 nftIdEnd) internal {\n        require(nftIdStart <= nftIdEnd, \"TOKEN_RANGE_INVALID\");\n\n        _NFT_ID_START_ = nftIdStart;\n        _NFT_ID_END_ = nftIdEnd;\n    }\n\n    function changeTokenIdMap(uint256[] memory tokenIds, bool[] memory isRegistered)\n        external\n        onlySuperOwner\n    {\n        _changeTokenIdMap(tokenIds, isRegistered);\n    }\n\n    function _changeTokenIdMap(uint256[] memory tokenIds, bool[] memory isRegistered) internal {\n        require(tokenIds.length == isRegistered.length, \"PARAM_NOT_MATCH\");\n\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            _SPREAD_IDS_REGISTRY_[tokenIds[i]] = isRegistered[i];\n        }\n    }\n}",
        "function": "changeNFTRandomInPrice(uint256,uint256,bool)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/SlowMist-DODO-NFTPool Smart Contract Security Audit Report/contractV2-e16ceb038ed6bf070ea75d9359c7ad54e6f3e226/contracts/NFTPool/impl/BaseFilterV1.sol",
        "vulnerability": "State access after external call (SWC 107)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract BaseFilterV1 is InitializableOwnable, ReentrancyGuard {\n    using SafeMath for uint256;\n\n    //=================== Storage ===================\n    address public _NFT_COLLECTION_;\n    uint256 public _NFT_ID_START_;\n    uint256 public _NFT_ID_END_ = uint256(-1);\n\n    //tokenId => isRegistered\n    mapping(uint256 => bool) public _SPREAD_IDS_REGISTRY_;\n\n    //tokenId => amount\n    mapping(uint256 => uint256) public _NFT_RESERVE_;\n\n    uint256[] public _NFT_IDS_;\n    uint256 public _TOTAL_NFT_AMOUNT_;\n    uint256 public _MAX_NFT_AMOUNT_;\n    uint256 public _MIN_NFT_AMOUNT_;\n\n    // GS -> Geometric sequence\n    // CR -> Common Ratio\n\n    //For Deposit NFT INto Pool\n    uint256 public _GS_START_IN_;\n    uint256 public _CR_IN_;\n    bool public _NFT_IN_TOGGLE_ = false;\n\n    //For NFT Random OUT from Pool\n    uint256 public _GS_START_RANDOM_OUT_;\n    uint256 public _CR_RANDOM_OUT_;\n    bool public _NFT_RANDOM_OUT_TOGGLE_ = false;\n\n    //For NFT Target OUT from Pool\n    uint256 public _GS_START_TARGET_OUT_;\n    uint256 public _CR_TARGET_OUT_;\n    bool public _NFT_TARGET_OUT_TOGGLE_ = false;\n\n    modifier onlySuperOwner() {\n        require(msg.sender == IFilterAdmin(_OWNER_)._OWNER_(), \"ONLY_SUPER_OWNER\");\n        _;\n    }\n\n    //==================== Query Prop ==================\n\n    function isNFTValid(address nftCollectionAddress, uint256 nftId) external view returns (bool) {\n        if (nftCollectionAddress == _NFT_COLLECTION_) {\n            return isNFTIDValid(nftId);\n        } else {\n            return false;\n        }\n    }\n\n    function isNFTIDValid(uint256 nftId) public view returns (bool) {\n        return (nftId >= _NFT_ID_START_ && nftId <= _NFT_ID_END_) || _SPREAD_IDS_REGISTRY_[nftId];\n    }\n\n    function getAvaliableNFTInAmount() public view returns (uint256) {\n        if (_MAX_NFT_AMOUNT_ <= _TOTAL_NFT_AMOUNT_) {\n            return 0;\n        } else {\n            return _MAX_NFT_AMOUNT_ - _TOTAL_NFT_AMOUNT_;\n        }\n    }\n\n    function getAvaliableNFTOutAmount() public view returns (uint256) {\n        if (_TOTAL_NFT_AMOUNT_ <= _MIN_NFT_AMOUNT_) {\n            return 0;\n        } else {\n            return _TOTAL_NFT_AMOUNT_ - _MIN_NFT_AMOUNT_;\n        }\n    }\n\n    function getNFTIndexById(uint256 tokenId) public view returns (uint256) {\n        uint256 i = 0;\n        for (; i < _NFT_IDS_.length; i++) {\n            if (_NFT_IDS_[i] == tokenId) break;\n        }\n        require(i < _NFT_IDS_.length, \"TOKEN_ID_NOT_EXSIT\");\n        return i;\n    }\n\n    //==================== Query Price ==================\n\n    function queryNFTIn(uint256 NFTInAmount)\n        public\n        view\n        returns (\n            uint256 rawReceive, \n            uint256 received\n        )\n    {\n        require(NFTInAmount <= getAvaliableNFTInAmount(), \"EXCEDD_IN_AMOUNT\");\n        rawReceive = _geometricCalc(\n            _GS_START_IN_,\n            _CR_IN_,\n            _TOTAL_NFT_AMOUNT_,\n            _TOTAL_NFT_AMOUNT_ + NFTInAmount\n        );\n        (,, received) = IFilterAdmin(_OWNER_).queryMintFee(rawReceive);\n    }\n\n    function queryNFTTargetOut(uint256 NFTOutAmount)\n        public\n        view\n        returns (\n            uint256 rawPay, \n            uint256 pay\n        )\n    {\n        require(NFTOutAmount <= getAvaliableNFTOutAmount(), \"EXCEED_OUT_AMOUNT\");\n        rawPay = _geometricCalc(\n            _GS_START_TARGET_OUT_,\n            _CR_TARGET_OUT_,\n            _TOTAL_NFT_AMOUNT_ - NFTOutAmount,\n            _TOTAL_NFT_AMOUNT_\n        );\n        (,, pay) = IFilterAdmin(_OWNER_).queryBurnFee(rawPay);\n    }\n\n    function queryNFTRandomOut(uint256 NFTOutAmount)\n        public\n        view\n        returns (\n            uint256 rawPay, \n            uint256 pay\n        )\n    {\n        require(NFTOutAmount <= getAvaliableNFTOutAmount(), \"EXCEED_OUT_AMOUNT\");\n        rawPay = _geometricCalc(\n            _GS_START_RANDOM_OUT_,\n            _CR_RANDOM_OUT_,\n            _TOTAL_NFT_AMOUNT_ - NFTOutAmount,\n            _TOTAL_NFT_AMOUNT_\n        );\n        (,, pay) = IFilterAdmin(_OWNER_).queryBurnFee(rawPay);\n    }\n\n    // ============ Math =============\n\n    function _geometricCalc(\n        uint256 a1,\n        uint256 q,\n        uint256 start,\n        uint256 end\n    ) internal view returns (uint256) {\n        if (q == DecimalMath.ONE) {\n            return end.sub(start).mul(a1);\n        }\n        //Sn=a1*(q^n-1)/(q-1)\n        //Sn-Sm = a1*(q^n-q^m)/(q-1)\n\n        //q^n\n        uint256 qn = DecimalMath.powFloor(q, end);\n        //q^m\n        uint256 qm = DecimalMath.powFloor(q, start);\n        return a1.mul(qn.sub(qm)).div(q.sub(DecimalMath.ONE));\n    }\n    // SWC-120-Weak Sources of Randomness from Chain Attributes: L175\n    function _getRandomNum() public view returns (uint256 randomNum) {\n        randomNum = uint256(\n            keccak256(abi.encodePacked(tx.origin, blockhash(block.number - 1), gasleft()))\n        );\n    }\n\n    // ================= Ownable ================\n\n    function changeNFTInPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) external onlySuperOwner {\n        _changeNFTInPrice(newGsStart, newCr, toggleFlag);\n    }\n\n    function _changeNFTInPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) internal {\n        require(newCr > DecimalMath.ONE, \"CR_INVALID\");\n        _GS_START_IN_ = newGsStart;\n        _CR_IN_ = newCr;\n        _NFT_IN_TOGGLE_ = true;\n    }\n\n    function changeNFTRandomInPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) external onlySuperOwner {\n        _changeNFTRandomInPrice(newGsStart, newCr, toggleFlag);\n    }\n\n    function _changeNFTRandomInPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) internal {\n        require(newCr > DecimalMath.ONE, \"CR_INVALID\");\n        _GS_START_RANDOM_OUT_ = newGsStart;\n        _CR_RANDOM_OUT_ = newCr;\n        _NFT_RANDOM_OUT_TOGGLE_ = true;\n    }\n\n    function changeNFTTargetOutPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) external onlySuperOwner {\n        _changeNFTTargetOutPrice(newGsStart, newCr, toggleFlag);\n    }\n\n    function _changeNFTTargetOutPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) internal {\n        require(newCr > DecimalMath.ONE, \"CR_INVALID\");\n        _GS_START_TARGET_OUT_ = newGsStart;\n        _CR_TARGET_OUT_ = newCr;\n        _NFT_TARGET_OUT_TOGGLE_ = true;\n    }\n\n    function changeNFTAmountRange(uint256 maxNFTAmount, uint256 minNFTAmount)\n        external\n        onlySuperOwner\n    {\n        _changeNFTAmountRange(maxNFTAmount, minNFTAmount);\n    }\n\n    function _changeNFTAmountRange(uint256 maxNFTAmount, uint256 minNFTAmount) internal {\n        require(maxNFTAmount >= minNFTAmount, \"AMOUNT_INVALID\");\n        _MAX_NFT_AMOUNT_ = maxNFTAmount;\n        _MIN_NFT_AMOUNT_ = minNFTAmount;\n    }\n\n    function changeTokenIdRange(uint256 nftIdStart, uint256 nftIdEnd) external onlySuperOwner {\n        _changeTokenIdRange(nftIdStart, nftIdEnd);\n    }\n\n    function _changeTokenIdRange(uint256 nftIdStart, uint256 nftIdEnd) internal {\n        require(nftIdStart <= nftIdEnd, \"TOKEN_RANGE_INVALID\");\n\n        _NFT_ID_START_ = nftIdStart;\n        _NFT_ID_END_ = nftIdEnd;\n    }\n\n    function changeTokenIdMap(uint256[] memory tokenIds, bool[] memory isRegistered)\n        external\n        onlySuperOwner\n    {\n        _changeTokenIdMap(tokenIds, isRegistered);\n    }\n\n    function _changeTokenIdMap(uint256[] memory tokenIds, bool[] memory isRegistered) internal {\n        require(tokenIds.length == isRegistered.length, \"PARAM_NOT_MATCH\");\n\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            _SPREAD_IDS_REGISTRY_[tokenIds[i]] = isRegistered[i];\n        }\n    }\n}",
        "function": "changeNFTRandomInPrice(uint256,uint256,bool)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/SlowMist-DODO-NFTPool Smart Contract Security Audit Report/contractV2-e16ceb038ed6bf070ea75d9359c7ad54e6f3e226/contracts/NFTPool/impl/BaseFilterV1.sol",
        "vulnerability": "State access after external call (SWC 107)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract BaseFilterV1 is InitializableOwnable, ReentrancyGuard {\n    using SafeMath for uint256;\n\n    //=================== Storage ===================\n    address public _NFT_COLLECTION_;\n    uint256 public _NFT_ID_START_;\n    uint256 public _NFT_ID_END_ = uint256(-1);\n\n    //tokenId => isRegistered\n    mapping(uint256 => bool) public _SPREAD_IDS_REGISTRY_;\n\n    //tokenId => amount\n    mapping(uint256 => uint256) public _NFT_RESERVE_;\n\n    uint256[] public _NFT_IDS_;\n    uint256 public _TOTAL_NFT_AMOUNT_;\n    uint256 public _MAX_NFT_AMOUNT_;\n    uint256 public _MIN_NFT_AMOUNT_;\n\n    // GS -> Geometric sequence\n    // CR -> Common Ratio\n\n    //For Deposit NFT INto Pool\n    uint256 public _GS_START_IN_;\n    uint256 public _CR_IN_;\n    bool public _NFT_IN_TOGGLE_ = false;\n\n    //For NFT Random OUT from Pool\n    uint256 public _GS_START_RANDOM_OUT_;\n    uint256 public _CR_RANDOM_OUT_;\n    bool public _NFT_RANDOM_OUT_TOGGLE_ = false;\n\n    //For NFT Target OUT from Pool\n    uint256 public _GS_START_TARGET_OUT_;\n    uint256 public _CR_TARGET_OUT_;\n    bool public _NFT_TARGET_OUT_TOGGLE_ = false;\n\n    modifier onlySuperOwner() {\n        require(msg.sender == IFilterAdmin(_OWNER_)._OWNER_(), \"ONLY_SUPER_OWNER\");\n        _;\n    }\n\n    //==================== Query Prop ==================\n\n    function isNFTValid(address nftCollectionAddress, uint256 nftId) external view returns (bool) {\n        if (nftCollectionAddress == _NFT_COLLECTION_) {\n            return isNFTIDValid(nftId);\n        } else {\n            return false;\n        }\n    }\n\n    function isNFTIDValid(uint256 nftId) public view returns (bool) {\n        return (nftId >= _NFT_ID_START_ && nftId <= _NFT_ID_END_) || _SPREAD_IDS_REGISTRY_[nftId];\n    }\n\n    function getAvaliableNFTInAmount() public view returns (uint256) {\n        if (_MAX_NFT_AMOUNT_ <= _TOTAL_NFT_AMOUNT_) {\n            return 0;\n        } else {\n            return _MAX_NFT_AMOUNT_ - _TOTAL_NFT_AMOUNT_;\n        }\n    }\n\n    function getAvaliableNFTOutAmount() public view returns (uint256) {\n        if (_TOTAL_NFT_AMOUNT_ <= _MIN_NFT_AMOUNT_) {\n            return 0;\n        } else {\n            return _TOTAL_NFT_AMOUNT_ - _MIN_NFT_AMOUNT_;\n        }\n    }\n\n    function getNFTIndexById(uint256 tokenId) public view returns (uint256) {\n        uint256 i = 0;\n        for (; i < _NFT_IDS_.length; i++) {\n            if (_NFT_IDS_[i] == tokenId) break;\n        }\n        require(i < _NFT_IDS_.length, \"TOKEN_ID_NOT_EXSIT\");\n        return i;\n    }\n\n    //==================== Query Price ==================\n\n    function queryNFTIn(uint256 NFTInAmount)\n        public\n        view\n        returns (\n            uint256 rawReceive, \n            uint256 received\n        )\n    {\n        require(NFTInAmount <= getAvaliableNFTInAmount(), \"EXCEDD_IN_AMOUNT\");\n        rawReceive = _geometricCalc(\n            _GS_START_IN_,\n            _CR_IN_,\n            _TOTAL_NFT_AMOUNT_,\n            _TOTAL_NFT_AMOUNT_ + NFTInAmount\n        );\n        (,, received) = IFilterAdmin(_OWNER_).queryMintFee(rawReceive);\n    }\n\n    function queryNFTTargetOut(uint256 NFTOutAmount)\n        public\n        view\n        returns (\n            uint256 rawPay, \n            uint256 pay\n        )\n    {\n        require(NFTOutAmount <= getAvaliableNFTOutAmount(), \"EXCEED_OUT_AMOUNT\");\n        rawPay = _geometricCalc(\n            _GS_START_TARGET_OUT_,\n            _CR_TARGET_OUT_,\n            _TOTAL_NFT_AMOUNT_ - NFTOutAmount,\n            _TOTAL_NFT_AMOUNT_\n        );\n        (,, pay) = IFilterAdmin(_OWNER_).queryBurnFee(rawPay);\n    }\n\n    function queryNFTRandomOut(uint256 NFTOutAmount)\n        public\n        view\n        returns (\n            uint256 rawPay, \n            uint256 pay\n        )\n    {\n        require(NFTOutAmount <= getAvaliableNFTOutAmount(), \"EXCEED_OUT_AMOUNT\");\n        rawPay = _geometricCalc(\n            _GS_START_RANDOM_OUT_,\n            _CR_RANDOM_OUT_,\n            _TOTAL_NFT_AMOUNT_ - NFTOutAmount,\n            _TOTAL_NFT_AMOUNT_\n        );\n        (,, pay) = IFilterAdmin(_OWNER_).queryBurnFee(rawPay);\n    }\n\n    // ============ Math =============\n\n    function _geometricCalc(\n        uint256 a1,\n        uint256 q,\n        uint256 start,\n        uint256 end\n    ) internal view returns (uint256) {\n        if (q == DecimalMath.ONE) {\n            return end.sub(start).mul(a1);\n        }\n        //Sn=a1*(q^n-1)/(q-1)\n        //Sn-Sm = a1*(q^n-q^m)/(q-1)\n\n        //q^n\n        uint256 qn = DecimalMath.powFloor(q, end);\n        //q^m\n        uint256 qm = DecimalMath.powFloor(q, start);\n        return a1.mul(qn.sub(qm)).div(q.sub(DecimalMath.ONE));\n    }\n    // SWC-120-Weak Sources of Randomness from Chain Attributes: L175\n    function _getRandomNum() public view returns (uint256 randomNum) {\n        randomNum = uint256(\n            keccak256(abi.encodePacked(tx.origin, blockhash(block.number - 1), gasleft()))\n        );\n    }\n\n    // ================= Ownable ================\n\n    function changeNFTInPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) external onlySuperOwner {\n        _changeNFTInPrice(newGsStart, newCr, toggleFlag);\n    }\n\n    function _changeNFTInPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) internal {\n        require(newCr > DecimalMath.ONE, \"CR_INVALID\");\n        _GS_START_IN_ = newGsStart;\n        _CR_IN_ = newCr;\n        _NFT_IN_TOGGLE_ = true;\n    }\n\n    function changeNFTRandomInPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) external onlySuperOwner {\n        _changeNFTRandomInPrice(newGsStart, newCr, toggleFlag);\n    }\n\n    function _changeNFTRandomInPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) internal {\n        require(newCr > DecimalMath.ONE, \"CR_INVALID\");\n        _GS_START_RANDOM_OUT_ = newGsStart;\n        _CR_RANDOM_OUT_ = newCr;\n        _NFT_RANDOM_OUT_TOGGLE_ = true;\n    }\n\n    function changeNFTTargetOutPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) external onlySuperOwner {\n        _changeNFTTargetOutPrice(newGsStart, newCr, toggleFlag);\n    }\n\n    function _changeNFTTargetOutPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) internal {\n        require(newCr > DecimalMath.ONE, \"CR_INVALID\");\n        _GS_START_TARGET_OUT_ = newGsStart;\n        _CR_TARGET_OUT_ = newCr;\n        _NFT_TARGET_OUT_TOGGLE_ = true;\n    }\n\n    function changeNFTAmountRange(uint256 maxNFTAmount, uint256 minNFTAmount)\n        external\n        onlySuperOwner\n    {\n        _changeNFTAmountRange(maxNFTAmount, minNFTAmount);\n    }\n\n    function _changeNFTAmountRange(uint256 maxNFTAmount, uint256 minNFTAmount) internal {\n        require(maxNFTAmount >= minNFTAmount, \"AMOUNT_INVALID\");\n        _MAX_NFT_AMOUNT_ = maxNFTAmount;\n        _MIN_NFT_AMOUNT_ = minNFTAmount;\n    }\n\n    function changeTokenIdRange(uint256 nftIdStart, uint256 nftIdEnd) external onlySuperOwner {\n        _changeTokenIdRange(nftIdStart, nftIdEnd);\n    }\n\n    function _changeTokenIdRange(uint256 nftIdStart, uint256 nftIdEnd) internal {\n        require(nftIdStart <= nftIdEnd, \"TOKEN_RANGE_INVALID\");\n\n        _NFT_ID_START_ = nftIdStart;\n        _NFT_ID_END_ = nftIdEnd;\n    }\n\n    function changeTokenIdMap(uint256[] memory tokenIds, bool[] memory isRegistered)\n        external\n        onlySuperOwner\n    {\n        _changeTokenIdMap(tokenIds, isRegistered);\n    }\n\n    function _changeTokenIdMap(uint256[] memory tokenIds, bool[] memory isRegistered) internal {\n        require(tokenIds.length == isRegistered.length, \"PARAM_NOT_MATCH\");\n\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            _SPREAD_IDS_REGISTRY_[tokenIds[i]] = isRegistered[i];\n        }\n    }\n}",
        "function": "changeNFTRandomInPrice(uint256,uint256,bool)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/SlowMist-DODO-NFTPool Smart Contract Security Audit Report/contractV2-e16ceb038ed6bf070ea75d9359c7ad54e6f3e226/contracts/NFTPool/impl/BaseFilterV1.sol",
        "vulnerability": "State access after external call (SWC 107)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract BaseFilterV1 is InitializableOwnable, ReentrancyGuard {\n    using SafeMath for uint256;\n\n    //=================== Storage ===================\n    address public _NFT_COLLECTION_;\n    uint256 public _NFT_ID_START_;\n    uint256 public _NFT_ID_END_ = uint256(-1);\n\n    //tokenId => isRegistered\n    mapping(uint256 => bool) public _SPREAD_IDS_REGISTRY_;\n\n    //tokenId => amount\n    mapping(uint256 => uint256) public _NFT_RESERVE_;\n\n    uint256[] public _NFT_IDS_;\n    uint256 public _TOTAL_NFT_AMOUNT_;\n    uint256 public _MAX_NFT_AMOUNT_;\n    uint256 public _MIN_NFT_AMOUNT_;\n\n    // GS -> Geometric sequence\n    // CR -> Common Ratio\n\n    //For Deposit NFT INto Pool\n    uint256 public _GS_START_IN_;\n    uint256 public _CR_IN_;\n    bool public _NFT_IN_TOGGLE_ = false;\n\n    //For NFT Random OUT from Pool\n    uint256 public _GS_START_RANDOM_OUT_;\n    uint256 public _CR_RANDOM_OUT_;\n    bool public _NFT_RANDOM_OUT_TOGGLE_ = false;\n\n    //For NFT Target OUT from Pool\n    uint256 public _GS_START_TARGET_OUT_;\n    uint256 public _CR_TARGET_OUT_;\n    bool public _NFT_TARGET_OUT_TOGGLE_ = false;\n\n    modifier onlySuperOwner() {\n        require(msg.sender == IFilterAdmin(_OWNER_)._OWNER_(), \"ONLY_SUPER_OWNER\");\n        _;\n    }\n\n    //==================== Query Prop ==================\n\n    function isNFTValid(address nftCollectionAddress, uint256 nftId) external view returns (bool) {\n        if (nftCollectionAddress == _NFT_COLLECTION_) {\n            return isNFTIDValid(nftId);\n        } else {\n            return false;\n        }\n    }\n\n    function isNFTIDValid(uint256 nftId) public view returns (bool) {\n        return (nftId >= _NFT_ID_START_ && nftId <= _NFT_ID_END_) || _SPREAD_IDS_REGISTRY_[nftId];\n    }\n\n    function getAvaliableNFTInAmount() public view returns (uint256) {\n        if (_MAX_NFT_AMOUNT_ <= _TOTAL_NFT_AMOUNT_) {\n            return 0;\n        } else {\n            return _MAX_NFT_AMOUNT_ - _TOTAL_NFT_AMOUNT_;\n        }\n    }\n\n    function getAvaliableNFTOutAmount() public view returns (uint256) {\n        if (_TOTAL_NFT_AMOUNT_ <= _MIN_NFT_AMOUNT_) {\n            return 0;\n        } else {\n            return _TOTAL_NFT_AMOUNT_ - _MIN_NFT_AMOUNT_;\n        }\n    }\n\n    function getNFTIndexById(uint256 tokenId) public view returns (uint256) {\n        uint256 i = 0;\n        for (; i < _NFT_IDS_.length; i++) {\n            if (_NFT_IDS_[i] == tokenId) break;\n        }\n        require(i < _NFT_IDS_.length, \"TOKEN_ID_NOT_EXSIT\");\n        return i;\n    }\n\n    //==================== Query Price ==================\n\n    function queryNFTIn(uint256 NFTInAmount)\n        public\n        view\n        returns (\n            uint256 rawReceive, \n            uint256 received\n        )\n    {\n        require(NFTInAmount <= getAvaliableNFTInAmount(), \"EXCEDD_IN_AMOUNT\");\n        rawReceive = _geometricCalc(\n            _GS_START_IN_,\n            _CR_IN_,\n            _TOTAL_NFT_AMOUNT_,\n            _TOTAL_NFT_AMOUNT_ + NFTInAmount\n        );\n        (,, received) = IFilterAdmin(_OWNER_).queryMintFee(rawReceive);\n    }\n\n    function queryNFTTargetOut(uint256 NFTOutAmount)\n        public\n        view\n        returns (\n            uint256 rawPay, \n            uint256 pay\n        )\n    {\n        require(NFTOutAmount <= getAvaliableNFTOutAmount(), \"EXCEED_OUT_AMOUNT\");\n        rawPay = _geometricCalc(\n            _GS_START_TARGET_OUT_,\n            _CR_TARGET_OUT_,\n            _TOTAL_NFT_AMOUNT_ - NFTOutAmount,\n            _TOTAL_NFT_AMOUNT_\n        );\n        (,, pay) = IFilterAdmin(_OWNER_).queryBurnFee(rawPay);\n    }\n\n    function queryNFTRandomOut(uint256 NFTOutAmount)\n        public\n        view\n        returns (\n            uint256 rawPay, \n            uint256 pay\n        )\n    {\n        require(NFTOutAmount <= getAvaliableNFTOutAmount(), \"EXCEED_OUT_AMOUNT\");\n        rawPay = _geometricCalc(\n            _GS_START_RANDOM_OUT_,\n            _CR_RANDOM_OUT_,\n            _TOTAL_NFT_AMOUNT_ - NFTOutAmount,\n            _TOTAL_NFT_AMOUNT_\n        );\n        (,, pay) = IFilterAdmin(_OWNER_).queryBurnFee(rawPay);\n    }\n\n    // ============ Math =============\n\n    function _geometricCalc(\n        uint256 a1,\n        uint256 q,\n        uint256 start,\n        uint256 end\n    ) internal view returns (uint256) {\n        if (q == DecimalMath.ONE) {\n            return end.sub(start).mul(a1);\n        }\n        //Sn=a1*(q^n-1)/(q-1)\n        //Sn-Sm = a1*(q^n-q^m)/(q-1)\n\n        //q^n\n        uint256 qn = DecimalMath.powFloor(q, end);\n        //q^m\n        uint256 qm = DecimalMath.powFloor(q, start);\n        return a1.mul(qn.sub(qm)).div(q.sub(DecimalMath.ONE));\n    }\n    // SWC-120-Weak Sources of Randomness from Chain Attributes: L175\n    function _getRandomNum() public view returns (uint256 randomNum) {\n        randomNum = uint256(\n            keccak256(abi.encodePacked(tx.origin, blockhash(block.number - 1), gasleft()))\n        );\n    }\n\n    // ================= Ownable ================\n\n    function changeNFTInPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) external onlySuperOwner {\n        _changeNFTInPrice(newGsStart, newCr, toggleFlag);\n    }\n\n    function _changeNFTInPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) internal {\n        require(newCr > DecimalMath.ONE, \"CR_INVALID\");\n        _GS_START_IN_ = newGsStart;\n        _CR_IN_ = newCr;\n        _NFT_IN_TOGGLE_ = true;\n    }\n\n    function changeNFTRandomInPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) external onlySuperOwner {\n        _changeNFTRandomInPrice(newGsStart, newCr, toggleFlag);\n    }\n\n    function _changeNFTRandomInPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) internal {\n        require(newCr > DecimalMath.ONE, \"CR_INVALID\");\n        _GS_START_RANDOM_OUT_ = newGsStart;\n        _CR_RANDOM_OUT_ = newCr;\n        _NFT_RANDOM_OUT_TOGGLE_ = true;\n    }\n\n    function changeNFTTargetOutPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) external onlySuperOwner {\n        _changeNFTTargetOutPrice(newGsStart, newCr, toggleFlag);\n    }\n\n    function _changeNFTTargetOutPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) internal {\n        require(newCr > DecimalMath.ONE, \"CR_INVALID\");\n        _GS_START_TARGET_OUT_ = newGsStart;\n        _CR_TARGET_OUT_ = newCr;\n        _NFT_TARGET_OUT_TOGGLE_ = true;\n    }\n\n    function changeNFTAmountRange(uint256 maxNFTAmount, uint256 minNFTAmount)\n        external\n        onlySuperOwner\n    {\n        _changeNFTAmountRange(maxNFTAmount, minNFTAmount);\n    }\n\n    function _changeNFTAmountRange(uint256 maxNFTAmount, uint256 minNFTAmount) internal {\n        require(maxNFTAmount >= minNFTAmount, \"AMOUNT_INVALID\");\n        _MAX_NFT_AMOUNT_ = maxNFTAmount;\n        _MIN_NFT_AMOUNT_ = minNFTAmount;\n    }\n\n    function changeTokenIdRange(uint256 nftIdStart, uint256 nftIdEnd) external onlySuperOwner {\n        _changeTokenIdRange(nftIdStart, nftIdEnd);\n    }\n\n    function _changeTokenIdRange(uint256 nftIdStart, uint256 nftIdEnd) internal {\n        require(nftIdStart <= nftIdEnd, \"TOKEN_RANGE_INVALID\");\n\n        _NFT_ID_START_ = nftIdStart;\n        _NFT_ID_END_ = nftIdEnd;\n    }\n\n    function changeTokenIdMap(uint256[] memory tokenIds, bool[] memory isRegistered)\n        external\n        onlySuperOwner\n    {\n        _changeTokenIdMap(tokenIds, isRegistered);\n    }\n\n    function _changeTokenIdMap(uint256[] memory tokenIds, bool[] memory isRegistered) internal {\n        require(tokenIds.length == isRegistered.length, \"PARAM_NOT_MATCH\");\n\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            _SPREAD_IDS_REGISTRY_[tokenIds[i]] = isRegistered[i];\n        }\n    }\n}",
        "function": "changeNFTRandomInPrice(uint256,uint256,bool)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/SlowMist-DODO-NFTPool Smart Contract Security Audit Report/contractV2-e16ceb038ed6bf070ea75d9359c7ad54e6f3e226/contracts/NFTPool/impl/BaseFilterV1.sol",
        "vulnerability": "State access after external call (SWC 107)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract BaseFilterV1 is InitializableOwnable, ReentrancyGuard {\n    using SafeMath for uint256;\n\n    //=================== Storage ===================\n    address public _NFT_COLLECTION_;\n    uint256 public _NFT_ID_START_;\n    uint256 public _NFT_ID_END_ = uint256(-1);\n\n    //tokenId => isRegistered\n    mapping(uint256 => bool) public _SPREAD_IDS_REGISTRY_;\n\n    //tokenId => amount\n    mapping(uint256 => uint256) public _NFT_RESERVE_;\n\n    uint256[] public _NFT_IDS_;\n    uint256 public _TOTAL_NFT_AMOUNT_;\n    uint256 public _MAX_NFT_AMOUNT_;\n    uint256 public _MIN_NFT_AMOUNT_;\n\n    // GS -> Geometric sequence\n    // CR -> Common Ratio\n\n    //For Deposit NFT INto Pool\n    uint256 public _GS_START_IN_;\n    uint256 public _CR_IN_;\n    bool public _NFT_IN_TOGGLE_ = false;\n\n    //For NFT Random OUT from Pool\n    uint256 public _GS_START_RANDOM_OUT_;\n    uint256 public _CR_RANDOM_OUT_;\n    bool public _NFT_RANDOM_OUT_TOGGLE_ = false;\n\n    //For NFT Target OUT from Pool\n    uint256 public _GS_START_TARGET_OUT_;\n    uint256 public _CR_TARGET_OUT_;\n    bool public _NFT_TARGET_OUT_TOGGLE_ = false;\n\n    modifier onlySuperOwner() {\n        require(msg.sender == IFilterAdmin(_OWNER_)._OWNER_(), \"ONLY_SUPER_OWNER\");\n        _;\n    }\n\n    //==================== Query Prop ==================\n\n    function isNFTValid(address nftCollectionAddress, uint256 nftId) external view returns (bool) {\n        if (nftCollectionAddress == _NFT_COLLECTION_) {\n            return isNFTIDValid(nftId);\n        } else {\n            return false;\n        }\n    }\n\n    function isNFTIDValid(uint256 nftId) public view returns (bool) {\n        return (nftId >= _NFT_ID_START_ && nftId <= _NFT_ID_END_) || _SPREAD_IDS_REGISTRY_[nftId];\n    }\n\n    function getAvaliableNFTInAmount() public view returns (uint256) {\n        if (_MAX_NFT_AMOUNT_ <= _TOTAL_NFT_AMOUNT_) {\n            return 0;\n        } else {\n            return _MAX_NFT_AMOUNT_ - _TOTAL_NFT_AMOUNT_;\n        }\n    }\n\n    function getAvaliableNFTOutAmount() public view returns (uint256) {\n        if (_TOTAL_NFT_AMOUNT_ <= _MIN_NFT_AMOUNT_) {\n            return 0;\n        } else {\n            return _TOTAL_NFT_AMOUNT_ - _MIN_NFT_AMOUNT_;\n        }\n    }\n\n    function getNFTIndexById(uint256 tokenId) public view returns (uint256) {\n        uint256 i = 0;\n        for (; i < _NFT_IDS_.length; i++) {\n            if (_NFT_IDS_[i] == tokenId) break;\n        }\n        require(i < _NFT_IDS_.length, \"TOKEN_ID_NOT_EXSIT\");\n        return i;\n    }\n\n    //==================== Query Price ==================\n\n    function queryNFTIn(uint256 NFTInAmount)\n        public\n        view\n        returns (\n            uint256 rawReceive, \n            uint256 received\n        )\n    {\n        require(NFTInAmount <= getAvaliableNFTInAmount(), \"EXCEDD_IN_AMOUNT\");\n        rawReceive = _geometricCalc(\n            _GS_START_IN_,\n            _CR_IN_,\n            _TOTAL_NFT_AMOUNT_,\n            _TOTAL_NFT_AMOUNT_ + NFTInAmount\n        );\n        (,, received) = IFilterAdmin(_OWNER_).queryMintFee(rawReceive);\n    }\n\n    function queryNFTTargetOut(uint256 NFTOutAmount)\n        public\n        view\n        returns (\n            uint256 rawPay, \n            uint256 pay\n        )\n    {\n        require(NFTOutAmount <= getAvaliableNFTOutAmount(), \"EXCEED_OUT_AMOUNT\");\n        rawPay = _geometricCalc(\n            _GS_START_TARGET_OUT_,\n            _CR_TARGET_OUT_,\n            _TOTAL_NFT_AMOUNT_ - NFTOutAmount,\n            _TOTAL_NFT_AMOUNT_\n        );\n        (,, pay) = IFilterAdmin(_OWNER_).queryBurnFee(rawPay);\n    }\n\n    function queryNFTRandomOut(uint256 NFTOutAmount)\n        public\n        view\n        returns (\n            uint256 rawPay, \n            uint256 pay\n        )\n    {\n        require(NFTOutAmount <= getAvaliableNFTOutAmount(), \"EXCEED_OUT_AMOUNT\");\n        rawPay = _geometricCalc(\n            _GS_START_RANDOM_OUT_,\n            _CR_RANDOM_OUT_,\n            _TOTAL_NFT_AMOUNT_ - NFTOutAmount,\n            _TOTAL_NFT_AMOUNT_\n        );\n        (,, pay) = IFilterAdmin(_OWNER_).queryBurnFee(rawPay);\n    }\n\n    // ============ Math =============\n\n    function _geometricCalc(\n        uint256 a1,\n        uint256 q,\n        uint256 start,\n        uint256 end\n    ) internal view returns (uint256) {\n        if (q == DecimalMath.ONE) {\n            return end.sub(start).mul(a1);\n        }\n        //Sn=a1*(q^n-1)/(q-1)\n        //Sn-Sm = a1*(q^n-q^m)/(q-1)\n\n        //q^n\n        uint256 qn = DecimalMath.powFloor(q, end);\n        //q^m\n        uint256 qm = DecimalMath.powFloor(q, start);\n        return a1.mul(qn.sub(qm)).div(q.sub(DecimalMath.ONE));\n    }\n    // SWC-120-Weak Sources of Randomness from Chain Attributes: L175\n    function _getRandomNum() public view returns (uint256 randomNum) {\n        randomNum = uint256(\n            keccak256(abi.encodePacked(tx.origin, blockhash(block.number - 1), gasleft()))\n        );\n    }\n\n    // ================= Ownable ================\n\n    function changeNFTInPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) external onlySuperOwner {\n        _changeNFTInPrice(newGsStart, newCr, toggleFlag);\n    }\n\n    function _changeNFTInPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) internal {\n        require(newCr > DecimalMath.ONE, \"CR_INVALID\");\n        _GS_START_IN_ = newGsStart;\n        _CR_IN_ = newCr;\n        _NFT_IN_TOGGLE_ = true;\n    }\n\n    function changeNFTRandomInPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) external onlySuperOwner {\n        _changeNFTRandomInPrice(newGsStart, newCr, toggleFlag);\n    }\n\n    function _changeNFTRandomInPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) internal {\n        require(newCr > DecimalMath.ONE, \"CR_INVALID\");\n        _GS_START_RANDOM_OUT_ = newGsStart;\n        _CR_RANDOM_OUT_ = newCr;\n        _NFT_RANDOM_OUT_TOGGLE_ = true;\n    }\n\n    function changeNFTTargetOutPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) external onlySuperOwner {\n        _changeNFTTargetOutPrice(newGsStart, newCr, toggleFlag);\n    }\n\n    function _changeNFTTargetOutPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) internal {\n        require(newCr > DecimalMath.ONE, \"CR_INVALID\");\n        _GS_START_TARGET_OUT_ = newGsStart;\n        _CR_TARGET_OUT_ = newCr;\n        _NFT_TARGET_OUT_TOGGLE_ = true;\n    }\n\n    function changeNFTAmountRange(uint256 maxNFTAmount, uint256 minNFTAmount)\n        external\n        onlySuperOwner\n    {\n        _changeNFTAmountRange(maxNFTAmount, minNFTAmount);\n    }\n\n    function _changeNFTAmountRange(uint256 maxNFTAmount, uint256 minNFTAmount) internal {\n        require(maxNFTAmount >= minNFTAmount, \"AMOUNT_INVALID\");\n        _MAX_NFT_AMOUNT_ = maxNFTAmount;\n        _MIN_NFT_AMOUNT_ = minNFTAmount;\n    }\n\n    function changeTokenIdRange(uint256 nftIdStart, uint256 nftIdEnd) external onlySuperOwner {\n        _changeTokenIdRange(nftIdStart, nftIdEnd);\n    }\n\n    function _changeTokenIdRange(uint256 nftIdStart, uint256 nftIdEnd) internal {\n        require(nftIdStart <= nftIdEnd, \"TOKEN_RANGE_INVALID\");\n\n        _NFT_ID_START_ = nftIdStart;\n        _NFT_ID_END_ = nftIdEnd;\n    }\n\n    function changeTokenIdMap(uint256[] memory tokenIds, bool[] memory isRegistered)\n        external\n        onlySuperOwner\n    {\n        _changeTokenIdMap(tokenIds, isRegistered);\n    }\n\n    function _changeTokenIdMap(uint256[] memory tokenIds, bool[] memory isRegistered) internal {\n        require(tokenIds.length == isRegistered.length, \"PARAM_NOT_MATCH\");\n\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            _SPREAD_IDS_REGISTRY_[tokenIds[i]] = isRegistered[i];\n        }\n    }\n}",
        "function": "changeNFTAmountRange(uint256,uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/SlowMist-DODO-NFTPool Smart Contract Security Audit Report/contractV2-e16ceb038ed6bf070ea75d9359c7ad54e6f3e226/contracts/NFTPool/impl/BaseFilterV1.sol",
        "vulnerability": "State access after external call (SWC 107)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract BaseFilterV1 is InitializableOwnable, ReentrancyGuard {\n    using SafeMath for uint256;\n\n    //=================== Storage ===================\n    address public _NFT_COLLECTION_;\n    uint256 public _NFT_ID_START_;\n    uint256 public _NFT_ID_END_ = uint256(-1);\n\n    //tokenId => isRegistered\n    mapping(uint256 => bool) public _SPREAD_IDS_REGISTRY_;\n\n    //tokenId => amount\n    mapping(uint256 => uint256) public _NFT_RESERVE_;\n\n    uint256[] public _NFT_IDS_;\n    uint256 public _TOTAL_NFT_AMOUNT_;\n    uint256 public _MAX_NFT_AMOUNT_;\n    uint256 public _MIN_NFT_AMOUNT_;\n\n    // GS -> Geometric sequence\n    // CR -> Common Ratio\n\n    //For Deposit NFT INto Pool\n    uint256 public _GS_START_IN_;\n    uint256 public _CR_IN_;\n    bool public _NFT_IN_TOGGLE_ = false;\n\n    //For NFT Random OUT from Pool\n    uint256 public _GS_START_RANDOM_OUT_;\n    uint256 public _CR_RANDOM_OUT_;\n    bool public _NFT_RANDOM_OUT_TOGGLE_ = false;\n\n    //For NFT Target OUT from Pool\n    uint256 public _GS_START_TARGET_OUT_;\n    uint256 public _CR_TARGET_OUT_;\n    bool public _NFT_TARGET_OUT_TOGGLE_ = false;\n\n    modifier onlySuperOwner() {\n        require(msg.sender == IFilterAdmin(_OWNER_)._OWNER_(), \"ONLY_SUPER_OWNER\");\n        _;\n    }\n\n    //==================== Query Prop ==================\n\n    function isNFTValid(address nftCollectionAddress, uint256 nftId) external view returns (bool) {\n        if (nftCollectionAddress == _NFT_COLLECTION_) {\n            return isNFTIDValid(nftId);\n        } else {\n            return false;\n        }\n    }\n\n    function isNFTIDValid(uint256 nftId) public view returns (bool) {\n        return (nftId >= _NFT_ID_START_ && nftId <= _NFT_ID_END_) || _SPREAD_IDS_REGISTRY_[nftId];\n    }\n\n    function getAvaliableNFTInAmount() public view returns (uint256) {\n        if (_MAX_NFT_AMOUNT_ <= _TOTAL_NFT_AMOUNT_) {\n            return 0;\n        } else {\n            return _MAX_NFT_AMOUNT_ - _TOTAL_NFT_AMOUNT_;\n        }\n    }\n\n    function getAvaliableNFTOutAmount() public view returns (uint256) {\n        if (_TOTAL_NFT_AMOUNT_ <= _MIN_NFT_AMOUNT_) {\n            return 0;\n        } else {\n            return _TOTAL_NFT_AMOUNT_ - _MIN_NFT_AMOUNT_;\n        }\n    }\n\n    function getNFTIndexById(uint256 tokenId) public view returns (uint256) {\n        uint256 i = 0;\n        for (; i < _NFT_IDS_.length; i++) {\n            if (_NFT_IDS_[i] == tokenId) break;\n        }\n        require(i < _NFT_IDS_.length, \"TOKEN_ID_NOT_EXSIT\");\n        return i;\n    }\n\n    //==================== Query Price ==================\n\n    function queryNFTIn(uint256 NFTInAmount)\n        public\n        view\n        returns (\n            uint256 rawReceive, \n            uint256 received\n        )\n    {\n        require(NFTInAmount <= getAvaliableNFTInAmount(), \"EXCEDD_IN_AMOUNT\");\n        rawReceive = _geometricCalc(\n            _GS_START_IN_,\n            _CR_IN_,\n            _TOTAL_NFT_AMOUNT_,\n            _TOTAL_NFT_AMOUNT_ + NFTInAmount\n        );\n        (,, received) = IFilterAdmin(_OWNER_).queryMintFee(rawReceive);\n    }\n\n    function queryNFTTargetOut(uint256 NFTOutAmount)\n        public\n        view\n        returns (\n            uint256 rawPay, \n            uint256 pay\n        )\n    {\n        require(NFTOutAmount <= getAvaliableNFTOutAmount(), \"EXCEED_OUT_AMOUNT\");\n        rawPay = _geometricCalc(\n            _GS_START_TARGET_OUT_,\n            _CR_TARGET_OUT_,\n            _TOTAL_NFT_AMOUNT_ - NFTOutAmount,\n            _TOTAL_NFT_AMOUNT_\n        );\n        (,, pay) = IFilterAdmin(_OWNER_).queryBurnFee(rawPay);\n    }\n\n    function queryNFTRandomOut(uint256 NFTOutAmount)\n        public\n        view\n        returns (\n            uint256 rawPay, \n            uint256 pay\n        )\n    {\n        require(NFTOutAmount <= getAvaliableNFTOutAmount(), \"EXCEED_OUT_AMOUNT\");\n        rawPay = _geometricCalc(\n            _GS_START_RANDOM_OUT_,\n            _CR_RANDOM_OUT_,\n            _TOTAL_NFT_AMOUNT_ - NFTOutAmount,\n            _TOTAL_NFT_AMOUNT_\n        );\n        (,, pay) = IFilterAdmin(_OWNER_).queryBurnFee(rawPay);\n    }\n\n    // ============ Math =============\n\n    function _geometricCalc(\n        uint256 a1,\n        uint256 q,\n        uint256 start,\n        uint256 end\n    ) internal view returns (uint256) {\n        if (q == DecimalMath.ONE) {\n            return end.sub(start).mul(a1);\n        }\n        //Sn=a1*(q^n-1)/(q-1)\n        //Sn-Sm = a1*(q^n-q^m)/(q-1)\n\n        //q^n\n        uint256 qn = DecimalMath.powFloor(q, end);\n        //q^m\n        uint256 qm = DecimalMath.powFloor(q, start);\n        return a1.mul(qn.sub(qm)).div(q.sub(DecimalMath.ONE));\n    }\n    // SWC-120-Weak Sources of Randomness from Chain Attributes: L175\n    function _getRandomNum() public view returns (uint256 randomNum) {\n        randomNum = uint256(\n            keccak256(abi.encodePacked(tx.origin, blockhash(block.number - 1), gasleft()))\n        );\n    }\n\n    // ================= Ownable ================\n\n    function changeNFTInPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) external onlySuperOwner {\n        _changeNFTInPrice(newGsStart, newCr, toggleFlag);\n    }\n\n    function _changeNFTInPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) internal {\n        require(newCr > DecimalMath.ONE, \"CR_INVALID\");\n        _GS_START_IN_ = newGsStart;\n        _CR_IN_ = newCr;\n        _NFT_IN_TOGGLE_ = true;\n    }\n\n    function changeNFTRandomInPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) external onlySuperOwner {\n        _changeNFTRandomInPrice(newGsStart, newCr, toggleFlag);\n    }\n\n    function _changeNFTRandomInPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) internal {\n        require(newCr > DecimalMath.ONE, \"CR_INVALID\");\n        _GS_START_RANDOM_OUT_ = newGsStart;\n        _CR_RANDOM_OUT_ = newCr;\n        _NFT_RANDOM_OUT_TOGGLE_ = true;\n    }\n\n    function changeNFTTargetOutPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) external onlySuperOwner {\n        _changeNFTTargetOutPrice(newGsStart, newCr, toggleFlag);\n    }\n\n    function _changeNFTTargetOutPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) internal {\n        require(newCr > DecimalMath.ONE, \"CR_INVALID\");\n        _GS_START_TARGET_OUT_ = newGsStart;\n        _CR_TARGET_OUT_ = newCr;\n        _NFT_TARGET_OUT_TOGGLE_ = true;\n    }\n\n    function changeNFTAmountRange(uint256 maxNFTAmount, uint256 minNFTAmount)\n        external\n        onlySuperOwner\n    {\n        _changeNFTAmountRange(maxNFTAmount, minNFTAmount);\n    }\n\n    function _changeNFTAmountRange(uint256 maxNFTAmount, uint256 minNFTAmount) internal {\n        require(maxNFTAmount >= minNFTAmount, \"AMOUNT_INVALID\");\n        _MAX_NFT_AMOUNT_ = maxNFTAmount;\n        _MIN_NFT_AMOUNT_ = minNFTAmount;\n    }\n\n    function changeTokenIdRange(uint256 nftIdStart, uint256 nftIdEnd) external onlySuperOwner {\n        _changeTokenIdRange(nftIdStart, nftIdEnd);\n    }\n\n    function _changeTokenIdRange(uint256 nftIdStart, uint256 nftIdEnd) internal {\n        require(nftIdStart <= nftIdEnd, \"TOKEN_RANGE_INVALID\");\n\n        _NFT_ID_START_ = nftIdStart;\n        _NFT_ID_END_ = nftIdEnd;\n    }\n\n    function changeTokenIdMap(uint256[] memory tokenIds, bool[] memory isRegistered)\n        external\n        onlySuperOwner\n    {\n        _changeTokenIdMap(tokenIds, isRegistered);\n    }\n\n    function _changeTokenIdMap(uint256[] memory tokenIds, bool[] memory isRegistered) internal {\n        require(tokenIds.length == isRegistered.length, \"PARAM_NOT_MATCH\");\n\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            _SPREAD_IDS_REGISTRY_[tokenIds[i]] = isRegistered[i];\n        }\n    }\n}",
        "function": "changeNFTAmountRange(uint256,uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/SlowMist-DODO-NFTPool Smart Contract Security Audit Report/contractV2-e16ceb038ed6bf070ea75d9359c7ad54e6f3e226/contracts/NFTPool/impl/BaseFilterV1.sol",
        "vulnerability": "State access after external call (SWC 107)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract BaseFilterV1 is InitializableOwnable, ReentrancyGuard {\n    using SafeMath for uint256;\n\n    //=================== Storage ===================\n    address public _NFT_COLLECTION_;\n    uint256 public _NFT_ID_START_;\n    uint256 public _NFT_ID_END_ = uint256(-1);\n\n    //tokenId => isRegistered\n    mapping(uint256 => bool) public _SPREAD_IDS_REGISTRY_;\n\n    //tokenId => amount\n    mapping(uint256 => uint256) public _NFT_RESERVE_;\n\n    uint256[] public _NFT_IDS_;\n    uint256 public _TOTAL_NFT_AMOUNT_;\n    uint256 public _MAX_NFT_AMOUNT_;\n    uint256 public _MIN_NFT_AMOUNT_;\n\n    // GS -> Geometric sequence\n    // CR -> Common Ratio\n\n    //For Deposit NFT INto Pool\n    uint256 public _GS_START_IN_;\n    uint256 public _CR_IN_;\n    bool public _NFT_IN_TOGGLE_ = false;\n\n    //For NFT Random OUT from Pool\n    uint256 public _GS_START_RANDOM_OUT_;\n    uint256 public _CR_RANDOM_OUT_;\n    bool public _NFT_RANDOM_OUT_TOGGLE_ = false;\n\n    //For NFT Target OUT from Pool\n    uint256 public _GS_START_TARGET_OUT_;\n    uint256 public _CR_TARGET_OUT_;\n    bool public _NFT_TARGET_OUT_TOGGLE_ = false;\n\n    modifier onlySuperOwner() {\n        require(msg.sender == IFilterAdmin(_OWNER_)._OWNER_(), \"ONLY_SUPER_OWNER\");\n        _;\n    }\n\n    //==================== Query Prop ==================\n\n    function isNFTValid(address nftCollectionAddress, uint256 nftId) external view returns (bool) {\n        if (nftCollectionAddress == _NFT_COLLECTION_) {\n            return isNFTIDValid(nftId);\n        } else {\n            return false;\n        }\n    }\n\n    function isNFTIDValid(uint256 nftId) public view returns (bool) {\n        return (nftId >= _NFT_ID_START_ && nftId <= _NFT_ID_END_) || _SPREAD_IDS_REGISTRY_[nftId];\n    }\n\n    function getAvaliableNFTInAmount() public view returns (uint256) {\n        if (_MAX_NFT_AMOUNT_ <= _TOTAL_NFT_AMOUNT_) {\n            return 0;\n        } else {\n            return _MAX_NFT_AMOUNT_ - _TOTAL_NFT_AMOUNT_;\n        }\n    }\n\n    function getAvaliableNFTOutAmount() public view returns (uint256) {\n        if (_TOTAL_NFT_AMOUNT_ <= _MIN_NFT_AMOUNT_) {\n            return 0;\n        } else {\n            return _TOTAL_NFT_AMOUNT_ - _MIN_NFT_AMOUNT_;\n        }\n    }\n\n    function getNFTIndexById(uint256 tokenId) public view returns (uint256) {\n        uint256 i = 0;\n        for (; i < _NFT_IDS_.length; i++) {\n            if (_NFT_IDS_[i] == tokenId) break;\n        }\n        require(i < _NFT_IDS_.length, \"TOKEN_ID_NOT_EXSIT\");\n        return i;\n    }\n\n    //==================== Query Price ==================\n\n    function queryNFTIn(uint256 NFTInAmount)\n        public\n        view\n        returns (\n            uint256 rawReceive, \n            uint256 received\n        )\n    {\n        require(NFTInAmount <= getAvaliableNFTInAmount(), \"EXCEDD_IN_AMOUNT\");\n        rawReceive = _geometricCalc(\n            _GS_START_IN_,\n            _CR_IN_,\n            _TOTAL_NFT_AMOUNT_,\n            _TOTAL_NFT_AMOUNT_ + NFTInAmount\n        );\n        (,, received) = IFilterAdmin(_OWNER_).queryMintFee(rawReceive);\n    }\n\n    function queryNFTTargetOut(uint256 NFTOutAmount)\n        public\n        view\n        returns (\n            uint256 rawPay, \n            uint256 pay\n        )\n    {\n        require(NFTOutAmount <= getAvaliableNFTOutAmount(), \"EXCEED_OUT_AMOUNT\");\n        rawPay = _geometricCalc(\n            _GS_START_TARGET_OUT_,\n            _CR_TARGET_OUT_,\n            _TOTAL_NFT_AMOUNT_ - NFTOutAmount,\n            _TOTAL_NFT_AMOUNT_\n        );\n        (,, pay) = IFilterAdmin(_OWNER_).queryBurnFee(rawPay);\n    }\n\n    function queryNFTRandomOut(uint256 NFTOutAmount)\n        public\n        view\n        returns (\n            uint256 rawPay, \n            uint256 pay\n        )\n    {\n        require(NFTOutAmount <= getAvaliableNFTOutAmount(), \"EXCEED_OUT_AMOUNT\");\n        rawPay = _geometricCalc(\n            _GS_START_RANDOM_OUT_,\n            _CR_RANDOM_OUT_,\n            _TOTAL_NFT_AMOUNT_ - NFTOutAmount,\n            _TOTAL_NFT_AMOUNT_\n        );\n        (,, pay) = IFilterAdmin(_OWNER_).queryBurnFee(rawPay);\n    }\n\n    // ============ Math =============\n\n    function _geometricCalc(\n        uint256 a1,\n        uint256 q,\n        uint256 start,\n        uint256 end\n    ) internal view returns (uint256) {\n        if (q == DecimalMath.ONE) {\n            return end.sub(start).mul(a1);\n        }\n        //Sn=a1*(q^n-1)/(q-1)\n        //Sn-Sm = a1*(q^n-q^m)/(q-1)\n\n        //q^n\n        uint256 qn = DecimalMath.powFloor(q, end);\n        //q^m\n        uint256 qm = DecimalMath.powFloor(q, start);\n        return a1.mul(qn.sub(qm)).div(q.sub(DecimalMath.ONE));\n    }\n    // SWC-120-Weak Sources of Randomness from Chain Attributes: L175\n    function _getRandomNum() public view returns (uint256 randomNum) {\n        randomNum = uint256(\n            keccak256(abi.encodePacked(tx.origin, blockhash(block.number - 1), gasleft()))\n        );\n    }\n\n    // ================= Ownable ================\n\n    function changeNFTInPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) external onlySuperOwner {\n        _changeNFTInPrice(newGsStart, newCr, toggleFlag);\n    }\n\n    function _changeNFTInPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) internal {\n        require(newCr > DecimalMath.ONE, \"CR_INVALID\");\n        _GS_START_IN_ = newGsStart;\n        _CR_IN_ = newCr;\n        _NFT_IN_TOGGLE_ = true;\n    }\n\n    function changeNFTRandomInPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) external onlySuperOwner {\n        _changeNFTRandomInPrice(newGsStart, newCr, toggleFlag);\n    }\n\n    function _changeNFTRandomInPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) internal {\n        require(newCr > DecimalMath.ONE, \"CR_INVALID\");\n        _GS_START_RANDOM_OUT_ = newGsStart;\n        _CR_RANDOM_OUT_ = newCr;\n        _NFT_RANDOM_OUT_TOGGLE_ = true;\n    }\n\n    function changeNFTTargetOutPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) external onlySuperOwner {\n        _changeNFTTargetOutPrice(newGsStart, newCr, toggleFlag);\n    }\n\n    function _changeNFTTargetOutPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) internal {\n        require(newCr > DecimalMath.ONE, \"CR_INVALID\");\n        _GS_START_TARGET_OUT_ = newGsStart;\n        _CR_TARGET_OUT_ = newCr;\n        _NFT_TARGET_OUT_TOGGLE_ = true;\n    }\n\n    function changeNFTAmountRange(uint256 maxNFTAmount, uint256 minNFTAmount)\n        external\n        onlySuperOwner\n    {\n        _changeNFTAmountRange(maxNFTAmount, minNFTAmount);\n    }\n\n    function _changeNFTAmountRange(uint256 maxNFTAmount, uint256 minNFTAmount) internal {\n        require(maxNFTAmount >= minNFTAmount, \"AMOUNT_INVALID\");\n        _MAX_NFT_AMOUNT_ = maxNFTAmount;\n        _MIN_NFT_AMOUNT_ = minNFTAmount;\n    }\n\n    function changeTokenIdRange(uint256 nftIdStart, uint256 nftIdEnd) external onlySuperOwner {\n        _changeTokenIdRange(nftIdStart, nftIdEnd);\n    }\n\n    function _changeTokenIdRange(uint256 nftIdStart, uint256 nftIdEnd) internal {\n        require(nftIdStart <= nftIdEnd, \"TOKEN_RANGE_INVALID\");\n\n        _NFT_ID_START_ = nftIdStart;\n        _NFT_ID_END_ = nftIdEnd;\n    }\n\n    function changeTokenIdMap(uint256[] memory tokenIds, bool[] memory isRegistered)\n        external\n        onlySuperOwner\n    {\n        _changeTokenIdMap(tokenIds, isRegistered);\n    }\n\n    function _changeTokenIdMap(uint256[] memory tokenIds, bool[] memory isRegistered) internal {\n        require(tokenIds.length == isRegistered.length, \"PARAM_NOT_MATCH\");\n\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            _SPREAD_IDS_REGISTRY_[tokenIds[i]] = isRegistered[i];\n        }\n    }\n}",
        "function": "changeNFTInPrice(uint256,uint256,bool)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/SlowMist-DODO-NFTPool Smart Contract Security Audit Report/contractV2-e16ceb038ed6bf070ea75d9359c7ad54e6f3e226/contracts/NFTPool/impl/BaseFilterV1.sol",
        "vulnerability": "State access after external call (SWC 107)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract BaseFilterV1 is InitializableOwnable, ReentrancyGuard {\n    using SafeMath for uint256;\n\n    //=================== Storage ===================\n    address public _NFT_COLLECTION_;\n    uint256 public _NFT_ID_START_;\n    uint256 public _NFT_ID_END_ = uint256(-1);\n\n    //tokenId => isRegistered\n    mapping(uint256 => bool) public _SPREAD_IDS_REGISTRY_;\n\n    //tokenId => amount\n    mapping(uint256 => uint256) public _NFT_RESERVE_;\n\n    uint256[] public _NFT_IDS_;\n    uint256 public _TOTAL_NFT_AMOUNT_;\n    uint256 public _MAX_NFT_AMOUNT_;\n    uint256 public _MIN_NFT_AMOUNT_;\n\n    // GS -> Geometric sequence\n    // CR -> Common Ratio\n\n    //For Deposit NFT INto Pool\n    uint256 public _GS_START_IN_;\n    uint256 public _CR_IN_;\n    bool public _NFT_IN_TOGGLE_ = false;\n\n    //For NFT Random OUT from Pool\n    uint256 public _GS_START_RANDOM_OUT_;\n    uint256 public _CR_RANDOM_OUT_;\n    bool public _NFT_RANDOM_OUT_TOGGLE_ = false;\n\n    //For NFT Target OUT from Pool\n    uint256 public _GS_START_TARGET_OUT_;\n    uint256 public _CR_TARGET_OUT_;\n    bool public _NFT_TARGET_OUT_TOGGLE_ = false;\n\n    modifier onlySuperOwner() {\n        require(msg.sender == IFilterAdmin(_OWNER_)._OWNER_(), \"ONLY_SUPER_OWNER\");\n        _;\n    }\n\n    //==================== Query Prop ==================\n\n    function isNFTValid(address nftCollectionAddress, uint256 nftId) external view returns (bool) {\n        if (nftCollectionAddress == _NFT_COLLECTION_) {\n            return isNFTIDValid(nftId);\n        } else {\n            return false;\n        }\n    }\n\n    function isNFTIDValid(uint256 nftId) public view returns (bool) {\n        return (nftId >= _NFT_ID_START_ && nftId <= _NFT_ID_END_) || _SPREAD_IDS_REGISTRY_[nftId];\n    }\n\n    function getAvaliableNFTInAmount() public view returns (uint256) {\n        if (_MAX_NFT_AMOUNT_ <= _TOTAL_NFT_AMOUNT_) {\n            return 0;\n        } else {\n            return _MAX_NFT_AMOUNT_ - _TOTAL_NFT_AMOUNT_;\n        }\n    }\n\n    function getAvaliableNFTOutAmount() public view returns (uint256) {\n        if (_TOTAL_NFT_AMOUNT_ <= _MIN_NFT_AMOUNT_) {\n            return 0;\n        } else {\n            return _TOTAL_NFT_AMOUNT_ - _MIN_NFT_AMOUNT_;\n        }\n    }\n\n    function getNFTIndexById(uint256 tokenId) public view returns (uint256) {\n        uint256 i = 0;\n        for (; i < _NFT_IDS_.length; i++) {\n            if (_NFT_IDS_[i] == tokenId) break;\n        }\n        require(i < _NFT_IDS_.length, \"TOKEN_ID_NOT_EXSIT\");\n        return i;\n    }\n\n    //==================== Query Price ==================\n\n    function queryNFTIn(uint256 NFTInAmount)\n        public\n        view\n        returns (\n            uint256 rawReceive, \n            uint256 received\n        )\n    {\n        require(NFTInAmount <= getAvaliableNFTInAmount(), \"EXCEDD_IN_AMOUNT\");\n        rawReceive = _geometricCalc(\n            _GS_START_IN_,\n            _CR_IN_,\n            _TOTAL_NFT_AMOUNT_,\n            _TOTAL_NFT_AMOUNT_ + NFTInAmount\n        );\n        (,, received) = IFilterAdmin(_OWNER_).queryMintFee(rawReceive);\n    }\n\n    function queryNFTTargetOut(uint256 NFTOutAmount)\n        public\n        view\n        returns (\n            uint256 rawPay, \n            uint256 pay\n        )\n    {\n        require(NFTOutAmount <= getAvaliableNFTOutAmount(), \"EXCEED_OUT_AMOUNT\");\n        rawPay = _geometricCalc(\n            _GS_START_TARGET_OUT_,\n            _CR_TARGET_OUT_,\n            _TOTAL_NFT_AMOUNT_ - NFTOutAmount,\n            _TOTAL_NFT_AMOUNT_\n        );\n        (,, pay) = IFilterAdmin(_OWNER_).queryBurnFee(rawPay);\n    }\n\n    function queryNFTRandomOut(uint256 NFTOutAmount)\n        public\n        view\n        returns (\n            uint256 rawPay, \n            uint256 pay\n        )\n    {\n        require(NFTOutAmount <= getAvaliableNFTOutAmount(), \"EXCEED_OUT_AMOUNT\");\n        rawPay = _geometricCalc(\n            _GS_START_RANDOM_OUT_,\n            _CR_RANDOM_OUT_,\n            _TOTAL_NFT_AMOUNT_ - NFTOutAmount,\n            _TOTAL_NFT_AMOUNT_\n        );\n        (,, pay) = IFilterAdmin(_OWNER_).queryBurnFee(rawPay);\n    }\n\n    // ============ Math =============\n\n    function _geometricCalc(\n        uint256 a1,\n        uint256 q,\n        uint256 start,\n        uint256 end\n    ) internal view returns (uint256) {\n        if (q == DecimalMath.ONE) {\n            return end.sub(start).mul(a1);\n        }\n        //Sn=a1*(q^n-1)/(q-1)\n        //Sn-Sm = a1*(q^n-q^m)/(q-1)\n\n        //q^n\n        uint256 qn = DecimalMath.powFloor(q, end);\n        //q^m\n        uint256 qm = DecimalMath.powFloor(q, start);\n        return a1.mul(qn.sub(qm)).div(q.sub(DecimalMath.ONE));\n    }\n    // SWC-120-Weak Sources of Randomness from Chain Attributes: L175\n    function _getRandomNum() public view returns (uint256 randomNum) {\n        randomNum = uint256(\n            keccak256(abi.encodePacked(tx.origin, blockhash(block.number - 1), gasleft()))\n        );\n    }\n\n    // ================= Ownable ================\n\n    function changeNFTInPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) external onlySuperOwner {\n        _changeNFTInPrice(newGsStart, newCr, toggleFlag);\n    }\n\n    function _changeNFTInPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) internal {\n        require(newCr > DecimalMath.ONE, \"CR_INVALID\");\n        _GS_START_IN_ = newGsStart;\n        _CR_IN_ = newCr;\n        _NFT_IN_TOGGLE_ = true;\n    }\n\n    function changeNFTRandomInPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) external onlySuperOwner {\n        _changeNFTRandomInPrice(newGsStart, newCr, toggleFlag);\n    }\n\n    function _changeNFTRandomInPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) internal {\n        require(newCr > DecimalMath.ONE, \"CR_INVALID\");\n        _GS_START_RANDOM_OUT_ = newGsStart;\n        _CR_RANDOM_OUT_ = newCr;\n        _NFT_RANDOM_OUT_TOGGLE_ = true;\n    }\n\n    function changeNFTTargetOutPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) external onlySuperOwner {\n        _changeNFTTargetOutPrice(newGsStart, newCr, toggleFlag);\n    }\n\n    function _changeNFTTargetOutPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) internal {\n        require(newCr > DecimalMath.ONE, \"CR_INVALID\");\n        _GS_START_TARGET_OUT_ = newGsStart;\n        _CR_TARGET_OUT_ = newCr;\n        _NFT_TARGET_OUT_TOGGLE_ = true;\n    }\n\n    function changeNFTAmountRange(uint256 maxNFTAmount, uint256 minNFTAmount)\n        external\n        onlySuperOwner\n    {\n        _changeNFTAmountRange(maxNFTAmount, minNFTAmount);\n    }\n\n    function _changeNFTAmountRange(uint256 maxNFTAmount, uint256 minNFTAmount) internal {\n        require(maxNFTAmount >= minNFTAmount, \"AMOUNT_INVALID\");\n        _MAX_NFT_AMOUNT_ = maxNFTAmount;\n        _MIN_NFT_AMOUNT_ = minNFTAmount;\n    }\n\n    function changeTokenIdRange(uint256 nftIdStart, uint256 nftIdEnd) external onlySuperOwner {\n        _changeTokenIdRange(nftIdStart, nftIdEnd);\n    }\n\n    function _changeTokenIdRange(uint256 nftIdStart, uint256 nftIdEnd) internal {\n        require(nftIdStart <= nftIdEnd, \"TOKEN_RANGE_INVALID\");\n\n        _NFT_ID_START_ = nftIdStart;\n        _NFT_ID_END_ = nftIdEnd;\n    }\n\n    function changeTokenIdMap(uint256[] memory tokenIds, bool[] memory isRegistered)\n        external\n        onlySuperOwner\n    {\n        _changeTokenIdMap(tokenIds, isRegistered);\n    }\n\n    function _changeTokenIdMap(uint256[] memory tokenIds, bool[] memory isRegistered) internal {\n        require(tokenIds.length == isRegistered.length, \"PARAM_NOT_MATCH\");\n\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            _SPREAD_IDS_REGISTRY_[tokenIds[i]] = isRegistered[i];\n        }\n    }\n}",
        "function": "changeNFTInPrice(uint256,uint256,bool)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/SlowMist-DODO-NFTPool Smart Contract Security Audit Report/contractV2-e16ceb038ed6bf070ea75d9359c7ad54e6f3e226/contracts/NFTPool/impl/BaseFilterV1.sol",
        "vulnerability": "State access after external call (SWC 107)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract BaseFilterV1 is InitializableOwnable, ReentrancyGuard {\n    using SafeMath for uint256;\n\n    //=================== Storage ===================\n    address public _NFT_COLLECTION_;\n    uint256 public _NFT_ID_START_;\n    uint256 public _NFT_ID_END_ = uint256(-1);\n\n    //tokenId => isRegistered\n    mapping(uint256 => bool) public _SPREAD_IDS_REGISTRY_;\n\n    //tokenId => amount\n    mapping(uint256 => uint256) public _NFT_RESERVE_;\n\n    uint256[] public _NFT_IDS_;\n    uint256 public _TOTAL_NFT_AMOUNT_;\n    uint256 public _MAX_NFT_AMOUNT_;\n    uint256 public _MIN_NFT_AMOUNT_;\n\n    // GS -> Geometric sequence\n    // CR -> Common Ratio\n\n    //For Deposit NFT INto Pool\n    uint256 public _GS_START_IN_;\n    uint256 public _CR_IN_;\n    bool public _NFT_IN_TOGGLE_ = false;\n\n    //For NFT Random OUT from Pool\n    uint256 public _GS_START_RANDOM_OUT_;\n    uint256 public _CR_RANDOM_OUT_;\n    bool public _NFT_RANDOM_OUT_TOGGLE_ = false;\n\n    //For NFT Target OUT from Pool\n    uint256 public _GS_START_TARGET_OUT_;\n    uint256 public _CR_TARGET_OUT_;\n    bool public _NFT_TARGET_OUT_TOGGLE_ = false;\n\n    modifier onlySuperOwner() {\n        require(msg.sender == IFilterAdmin(_OWNER_)._OWNER_(), \"ONLY_SUPER_OWNER\");\n        _;\n    }\n\n    //==================== Query Prop ==================\n\n    function isNFTValid(address nftCollectionAddress, uint256 nftId) external view returns (bool) {\n        if (nftCollectionAddress == _NFT_COLLECTION_) {\n            return isNFTIDValid(nftId);\n        } else {\n            return false;\n        }\n    }\n\n    function isNFTIDValid(uint256 nftId) public view returns (bool) {\n        return (nftId >= _NFT_ID_START_ && nftId <= _NFT_ID_END_) || _SPREAD_IDS_REGISTRY_[nftId];\n    }\n\n    function getAvaliableNFTInAmount() public view returns (uint256) {\n        if (_MAX_NFT_AMOUNT_ <= _TOTAL_NFT_AMOUNT_) {\n            return 0;\n        } else {\n            return _MAX_NFT_AMOUNT_ - _TOTAL_NFT_AMOUNT_;\n        }\n    }\n\n    function getAvaliableNFTOutAmount() public view returns (uint256) {\n        if (_TOTAL_NFT_AMOUNT_ <= _MIN_NFT_AMOUNT_) {\n            return 0;\n        } else {\n            return _TOTAL_NFT_AMOUNT_ - _MIN_NFT_AMOUNT_;\n        }\n    }\n\n    function getNFTIndexById(uint256 tokenId) public view returns (uint256) {\n        uint256 i = 0;\n        for (; i < _NFT_IDS_.length; i++) {\n            if (_NFT_IDS_[i] == tokenId) break;\n        }\n        require(i < _NFT_IDS_.length, \"TOKEN_ID_NOT_EXSIT\");\n        return i;\n    }\n\n    //==================== Query Price ==================\n\n    function queryNFTIn(uint256 NFTInAmount)\n        public\n        view\n        returns (\n            uint256 rawReceive, \n            uint256 received\n        )\n    {\n        require(NFTInAmount <= getAvaliableNFTInAmount(), \"EXCEDD_IN_AMOUNT\");\n        rawReceive = _geometricCalc(\n            _GS_START_IN_,\n            _CR_IN_,\n            _TOTAL_NFT_AMOUNT_,\n            _TOTAL_NFT_AMOUNT_ + NFTInAmount\n        );\n        (,, received) = IFilterAdmin(_OWNER_).queryMintFee(rawReceive);\n    }\n\n    function queryNFTTargetOut(uint256 NFTOutAmount)\n        public\n        view\n        returns (\n            uint256 rawPay, \n            uint256 pay\n        )\n    {\n        require(NFTOutAmount <= getAvaliableNFTOutAmount(), \"EXCEED_OUT_AMOUNT\");\n        rawPay = _geometricCalc(\n            _GS_START_TARGET_OUT_,\n            _CR_TARGET_OUT_,\n            _TOTAL_NFT_AMOUNT_ - NFTOutAmount,\n            _TOTAL_NFT_AMOUNT_\n        );\n        (,, pay) = IFilterAdmin(_OWNER_).queryBurnFee(rawPay);\n    }\n\n    function queryNFTRandomOut(uint256 NFTOutAmount)\n        public\n        view\n        returns (\n            uint256 rawPay, \n            uint256 pay\n        )\n    {\n        require(NFTOutAmount <= getAvaliableNFTOutAmount(), \"EXCEED_OUT_AMOUNT\");\n        rawPay = _geometricCalc(\n            _GS_START_RANDOM_OUT_,\n            _CR_RANDOM_OUT_,\n            _TOTAL_NFT_AMOUNT_ - NFTOutAmount,\n            _TOTAL_NFT_AMOUNT_\n        );\n        (,, pay) = IFilterAdmin(_OWNER_).queryBurnFee(rawPay);\n    }\n\n    // ============ Math =============\n\n    function _geometricCalc(\n        uint256 a1,\n        uint256 q,\n        uint256 start,\n        uint256 end\n    ) internal view returns (uint256) {\n        if (q == DecimalMath.ONE) {\n            return end.sub(start).mul(a1);\n        }\n        //Sn=a1*(q^n-1)/(q-1)\n        //Sn-Sm = a1*(q^n-q^m)/(q-1)\n\n        //q^n\n        uint256 qn = DecimalMath.powFloor(q, end);\n        //q^m\n        uint256 qm = DecimalMath.powFloor(q, start);\n        return a1.mul(qn.sub(qm)).div(q.sub(DecimalMath.ONE));\n    }\n    // SWC-120-Weak Sources of Randomness from Chain Attributes: L175\n    function _getRandomNum() public view returns (uint256 randomNum) {\n        randomNum = uint256(\n            keccak256(abi.encodePacked(tx.origin, blockhash(block.number - 1), gasleft()))\n        );\n    }\n\n    // ================= Ownable ================\n\n    function changeNFTInPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) external onlySuperOwner {\n        _changeNFTInPrice(newGsStart, newCr, toggleFlag);\n    }\n\n    function _changeNFTInPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) internal {\n        require(newCr > DecimalMath.ONE, \"CR_INVALID\");\n        _GS_START_IN_ = newGsStart;\n        _CR_IN_ = newCr;\n        _NFT_IN_TOGGLE_ = true;\n    }\n\n    function changeNFTRandomInPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) external onlySuperOwner {\n        _changeNFTRandomInPrice(newGsStart, newCr, toggleFlag);\n    }\n\n    function _changeNFTRandomInPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) internal {\n        require(newCr > DecimalMath.ONE, \"CR_INVALID\");\n        _GS_START_RANDOM_OUT_ = newGsStart;\n        _CR_RANDOM_OUT_ = newCr;\n        _NFT_RANDOM_OUT_TOGGLE_ = true;\n    }\n\n    function changeNFTTargetOutPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) external onlySuperOwner {\n        _changeNFTTargetOutPrice(newGsStart, newCr, toggleFlag);\n    }\n\n    function _changeNFTTargetOutPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) internal {\n        require(newCr > DecimalMath.ONE, \"CR_INVALID\");\n        _GS_START_TARGET_OUT_ = newGsStart;\n        _CR_TARGET_OUT_ = newCr;\n        _NFT_TARGET_OUT_TOGGLE_ = true;\n    }\n\n    function changeNFTAmountRange(uint256 maxNFTAmount, uint256 minNFTAmount)\n        external\n        onlySuperOwner\n    {\n        _changeNFTAmountRange(maxNFTAmount, minNFTAmount);\n    }\n\n    function _changeNFTAmountRange(uint256 maxNFTAmount, uint256 minNFTAmount) internal {\n        require(maxNFTAmount >= minNFTAmount, \"AMOUNT_INVALID\");\n        _MAX_NFT_AMOUNT_ = maxNFTAmount;\n        _MIN_NFT_AMOUNT_ = minNFTAmount;\n    }\n\n    function changeTokenIdRange(uint256 nftIdStart, uint256 nftIdEnd) external onlySuperOwner {\n        _changeTokenIdRange(nftIdStart, nftIdEnd);\n    }\n\n    function _changeTokenIdRange(uint256 nftIdStart, uint256 nftIdEnd) internal {\n        require(nftIdStart <= nftIdEnd, \"TOKEN_RANGE_INVALID\");\n\n        _NFT_ID_START_ = nftIdStart;\n        _NFT_ID_END_ = nftIdEnd;\n    }\n\n    function changeTokenIdMap(uint256[] memory tokenIds, bool[] memory isRegistered)\n        external\n        onlySuperOwner\n    {\n        _changeTokenIdMap(tokenIds, isRegistered);\n    }\n\n    function _changeTokenIdMap(uint256[] memory tokenIds, bool[] memory isRegistered) internal {\n        require(tokenIds.length == isRegistered.length, \"PARAM_NOT_MATCH\");\n\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            _SPREAD_IDS_REGISTRY_[tokenIds[i]] = isRegistered[i];\n        }\n    }\n}",
        "function": "changeNFTInPrice(uint256,uint256,bool)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/SlowMist-DODO-NFTPool Smart Contract Security Audit Report/contractV2-e16ceb038ed6bf070ea75d9359c7ad54e6f3e226/contracts/NFTPool/impl/BaseFilterV1.sol",
        "vulnerability": "State access after external call (SWC 107)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract BaseFilterV1 is InitializableOwnable, ReentrancyGuard {\n    using SafeMath for uint256;\n\n    //=================== Storage ===================\n    address public _NFT_COLLECTION_;\n    uint256 public _NFT_ID_START_;\n    uint256 public _NFT_ID_END_ = uint256(-1);\n\n    //tokenId => isRegistered\n    mapping(uint256 => bool) public _SPREAD_IDS_REGISTRY_;\n\n    //tokenId => amount\n    mapping(uint256 => uint256) public _NFT_RESERVE_;\n\n    uint256[] public _NFT_IDS_;\n    uint256 public _TOTAL_NFT_AMOUNT_;\n    uint256 public _MAX_NFT_AMOUNT_;\n    uint256 public _MIN_NFT_AMOUNT_;\n\n    // GS -> Geometric sequence\n    // CR -> Common Ratio\n\n    //For Deposit NFT INto Pool\n    uint256 public _GS_START_IN_;\n    uint256 public _CR_IN_;\n    bool public _NFT_IN_TOGGLE_ = false;\n\n    //For NFT Random OUT from Pool\n    uint256 public _GS_START_RANDOM_OUT_;\n    uint256 public _CR_RANDOM_OUT_;\n    bool public _NFT_RANDOM_OUT_TOGGLE_ = false;\n\n    //For NFT Target OUT from Pool\n    uint256 public _GS_START_TARGET_OUT_;\n    uint256 public _CR_TARGET_OUT_;\n    bool public _NFT_TARGET_OUT_TOGGLE_ = false;\n\n    modifier onlySuperOwner() {\n        require(msg.sender == IFilterAdmin(_OWNER_)._OWNER_(), \"ONLY_SUPER_OWNER\");\n        _;\n    }\n\n    //==================== Query Prop ==================\n\n    function isNFTValid(address nftCollectionAddress, uint256 nftId) external view returns (bool) {\n        if (nftCollectionAddress == _NFT_COLLECTION_) {\n            return isNFTIDValid(nftId);\n        } else {\n            return false;\n        }\n    }\n\n    function isNFTIDValid(uint256 nftId) public view returns (bool) {\n        return (nftId >= _NFT_ID_START_ && nftId <= _NFT_ID_END_) || _SPREAD_IDS_REGISTRY_[nftId];\n    }\n\n    function getAvaliableNFTInAmount() public view returns (uint256) {\n        if (_MAX_NFT_AMOUNT_ <= _TOTAL_NFT_AMOUNT_) {\n            return 0;\n        } else {\n            return _MAX_NFT_AMOUNT_ - _TOTAL_NFT_AMOUNT_;\n        }\n    }\n\n    function getAvaliableNFTOutAmount() public view returns (uint256) {\n        if (_TOTAL_NFT_AMOUNT_ <= _MIN_NFT_AMOUNT_) {\n            return 0;\n        } else {\n            return _TOTAL_NFT_AMOUNT_ - _MIN_NFT_AMOUNT_;\n        }\n    }\n\n    function getNFTIndexById(uint256 tokenId) public view returns (uint256) {\n        uint256 i = 0;\n        for (; i < _NFT_IDS_.length; i++) {\n            if (_NFT_IDS_[i] == tokenId) break;\n        }\n        require(i < _NFT_IDS_.length, \"TOKEN_ID_NOT_EXSIT\");\n        return i;\n    }\n\n    //==================== Query Price ==================\n\n    function queryNFTIn(uint256 NFTInAmount)\n        public\n        view\n        returns (\n            uint256 rawReceive, \n            uint256 received\n        )\n    {\n        require(NFTInAmount <= getAvaliableNFTInAmount(), \"EXCEDD_IN_AMOUNT\");\n        rawReceive = _geometricCalc(\n            _GS_START_IN_,\n            _CR_IN_,\n            _TOTAL_NFT_AMOUNT_,\n            _TOTAL_NFT_AMOUNT_ + NFTInAmount\n        );\n        (,, received) = IFilterAdmin(_OWNER_).queryMintFee(rawReceive);\n    }\n\n    function queryNFTTargetOut(uint256 NFTOutAmount)\n        public\n        view\n        returns (\n            uint256 rawPay, \n            uint256 pay\n        )\n    {\n        require(NFTOutAmount <= getAvaliableNFTOutAmount(), \"EXCEED_OUT_AMOUNT\");\n        rawPay = _geometricCalc(\n            _GS_START_TARGET_OUT_,\n            _CR_TARGET_OUT_,\n            _TOTAL_NFT_AMOUNT_ - NFTOutAmount,\n            _TOTAL_NFT_AMOUNT_\n        );\n        (,, pay) = IFilterAdmin(_OWNER_).queryBurnFee(rawPay);\n    }\n\n    function queryNFTRandomOut(uint256 NFTOutAmount)\n        public\n        view\n        returns (\n            uint256 rawPay, \n            uint256 pay\n        )\n    {\n        require(NFTOutAmount <= getAvaliableNFTOutAmount(), \"EXCEED_OUT_AMOUNT\");\n        rawPay = _geometricCalc(\n            _GS_START_RANDOM_OUT_,\n            _CR_RANDOM_OUT_,\n            _TOTAL_NFT_AMOUNT_ - NFTOutAmount,\n            _TOTAL_NFT_AMOUNT_\n        );\n        (,, pay) = IFilterAdmin(_OWNER_).queryBurnFee(rawPay);\n    }\n\n    // ============ Math =============\n\n    function _geometricCalc(\n        uint256 a1,\n        uint256 q,\n        uint256 start,\n        uint256 end\n    ) internal view returns (uint256) {\n        if (q == DecimalMath.ONE) {\n            return end.sub(start).mul(a1);\n        }\n        //Sn=a1*(q^n-1)/(q-1)\n        //Sn-Sm = a1*(q^n-q^m)/(q-1)\n\n        //q^n\n        uint256 qn = DecimalMath.powFloor(q, end);\n        //q^m\n        uint256 qm = DecimalMath.powFloor(q, start);\n        return a1.mul(qn.sub(qm)).div(q.sub(DecimalMath.ONE));\n    }\n    // SWC-120-Weak Sources of Randomness from Chain Attributes: L175\n    function _getRandomNum() public view returns (uint256 randomNum) {\n        randomNum = uint256(\n            keccak256(abi.encodePacked(tx.origin, blockhash(block.number - 1), gasleft()))\n        );\n    }\n\n    // ================= Ownable ================\n\n    function changeNFTInPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) external onlySuperOwner {\n        _changeNFTInPrice(newGsStart, newCr, toggleFlag);\n    }\n\n    function _changeNFTInPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) internal {\n        require(newCr > DecimalMath.ONE, \"CR_INVALID\");\n        _GS_START_IN_ = newGsStart;\n        _CR_IN_ = newCr;\n        _NFT_IN_TOGGLE_ = true;\n    }\n\n    function changeNFTRandomInPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) external onlySuperOwner {\n        _changeNFTRandomInPrice(newGsStart, newCr, toggleFlag);\n    }\n\n    function _changeNFTRandomInPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) internal {\n        require(newCr > DecimalMath.ONE, \"CR_INVALID\");\n        _GS_START_RANDOM_OUT_ = newGsStart;\n        _CR_RANDOM_OUT_ = newCr;\n        _NFT_RANDOM_OUT_TOGGLE_ = true;\n    }\n\n    function changeNFTTargetOutPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) external onlySuperOwner {\n        _changeNFTTargetOutPrice(newGsStart, newCr, toggleFlag);\n    }\n\n    function _changeNFTTargetOutPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) internal {\n        require(newCr > DecimalMath.ONE, \"CR_INVALID\");\n        _GS_START_TARGET_OUT_ = newGsStart;\n        _CR_TARGET_OUT_ = newCr;\n        _NFT_TARGET_OUT_TOGGLE_ = true;\n    }\n\n    function changeNFTAmountRange(uint256 maxNFTAmount, uint256 minNFTAmount)\n        external\n        onlySuperOwner\n    {\n        _changeNFTAmountRange(maxNFTAmount, minNFTAmount);\n    }\n\n    function _changeNFTAmountRange(uint256 maxNFTAmount, uint256 minNFTAmount) internal {\n        require(maxNFTAmount >= minNFTAmount, \"AMOUNT_INVALID\");\n        _MAX_NFT_AMOUNT_ = maxNFTAmount;\n        _MIN_NFT_AMOUNT_ = minNFTAmount;\n    }\n\n    function changeTokenIdRange(uint256 nftIdStart, uint256 nftIdEnd) external onlySuperOwner {\n        _changeTokenIdRange(nftIdStart, nftIdEnd);\n    }\n\n    function _changeTokenIdRange(uint256 nftIdStart, uint256 nftIdEnd) internal {\n        require(nftIdStart <= nftIdEnd, \"TOKEN_RANGE_INVALID\");\n\n        _NFT_ID_START_ = nftIdStart;\n        _NFT_ID_END_ = nftIdEnd;\n    }\n\n    function changeTokenIdMap(uint256[] memory tokenIds, bool[] memory isRegistered)\n        external\n        onlySuperOwner\n    {\n        _changeTokenIdMap(tokenIds, isRegistered);\n    }\n\n    function _changeTokenIdMap(uint256[] memory tokenIds, bool[] memory isRegistered) internal {\n        require(tokenIds.length == isRegistered.length, \"PARAM_NOT_MATCH\");\n\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            _SPREAD_IDS_REGISTRY_[tokenIds[i]] = isRegistered[i];\n        }\n    }\n}",
        "function": "changeNFTInPrice(uint256,uint256,bool)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/SlowMist-DODO-NFTPool Smart Contract Security Audit Report/contractV2-e16ceb038ed6bf070ea75d9359c7ad54e6f3e226/contracts/NFTPool/impl/BaseFilterV1.sol",
        "vulnerability": "State access after external call (SWC 107)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract BaseFilterV1 is InitializableOwnable, ReentrancyGuard {\n    using SafeMath for uint256;\n\n    //=================== Storage ===================\n    address public _NFT_COLLECTION_;\n    uint256 public _NFT_ID_START_;\n    uint256 public _NFT_ID_END_ = uint256(-1);\n\n    //tokenId => isRegistered\n    mapping(uint256 => bool) public _SPREAD_IDS_REGISTRY_;\n\n    //tokenId => amount\n    mapping(uint256 => uint256) public _NFT_RESERVE_;\n\n    uint256[] public _NFT_IDS_;\n    uint256 public _TOTAL_NFT_AMOUNT_;\n    uint256 public _MAX_NFT_AMOUNT_;\n    uint256 public _MIN_NFT_AMOUNT_;\n\n    // GS -> Geometric sequence\n    // CR -> Common Ratio\n\n    //For Deposit NFT INto Pool\n    uint256 public _GS_START_IN_;\n    uint256 public _CR_IN_;\n    bool public _NFT_IN_TOGGLE_ = false;\n\n    //For NFT Random OUT from Pool\n    uint256 public _GS_START_RANDOM_OUT_;\n    uint256 public _CR_RANDOM_OUT_;\n    bool public _NFT_RANDOM_OUT_TOGGLE_ = false;\n\n    //For NFT Target OUT from Pool\n    uint256 public _GS_START_TARGET_OUT_;\n    uint256 public _CR_TARGET_OUT_;\n    bool public _NFT_TARGET_OUT_TOGGLE_ = false;\n\n    modifier onlySuperOwner() {\n        require(msg.sender == IFilterAdmin(_OWNER_)._OWNER_(), \"ONLY_SUPER_OWNER\");\n        _;\n    }\n\n    //==================== Query Prop ==================\n\n    function isNFTValid(address nftCollectionAddress, uint256 nftId) external view returns (bool) {\n        if (nftCollectionAddress == _NFT_COLLECTION_) {\n            return isNFTIDValid(nftId);\n        } else {\n            return false;\n        }\n    }\n\n    function isNFTIDValid(uint256 nftId) public view returns (bool) {\n        return (nftId >= _NFT_ID_START_ && nftId <= _NFT_ID_END_) || _SPREAD_IDS_REGISTRY_[nftId];\n    }\n\n    function getAvaliableNFTInAmount() public view returns (uint256) {\n        if (_MAX_NFT_AMOUNT_ <= _TOTAL_NFT_AMOUNT_) {\n            return 0;\n        } else {\n            return _MAX_NFT_AMOUNT_ - _TOTAL_NFT_AMOUNT_;\n        }\n    }\n\n    function getAvaliableNFTOutAmount() public view returns (uint256) {\n        if (_TOTAL_NFT_AMOUNT_ <= _MIN_NFT_AMOUNT_) {\n            return 0;\n        } else {\n            return _TOTAL_NFT_AMOUNT_ - _MIN_NFT_AMOUNT_;\n        }\n    }\n\n    function getNFTIndexById(uint256 tokenId) public view returns (uint256) {\n        uint256 i = 0;\n        for (; i < _NFT_IDS_.length; i++) {\n            if (_NFT_IDS_[i] == tokenId) break;\n        }\n        require(i < _NFT_IDS_.length, \"TOKEN_ID_NOT_EXSIT\");\n        return i;\n    }\n\n    //==================== Query Price ==================\n\n    function queryNFTIn(uint256 NFTInAmount)\n        public\n        view\n        returns (\n            uint256 rawReceive, \n            uint256 received\n        )\n    {\n        require(NFTInAmount <= getAvaliableNFTInAmount(), \"EXCEDD_IN_AMOUNT\");\n        rawReceive = _geometricCalc(\n            _GS_START_IN_,\n            _CR_IN_,\n            _TOTAL_NFT_AMOUNT_,\n            _TOTAL_NFT_AMOUNT_ + NFTInAmount\n        );\n        (,, received) = IFilterAdmin(_OWNER_).queryMintFee(rawReceive);\n    }\n\n    function queryNFTTargetOut(uint256 NFTOutAmount)\n        public\n        view\n        returns (\n            uint256 rawPay, \n            uint256 pay\n        )\n    {\n        require(NFTOutAmount <= getAvaliableNFTOutAmount(), \"EXCEED_OUT_AMOUNT\");\n        rawPay = _geometricCalc(\n            _GS_START_TARGET_OUT_,\n            _CR_TARGET_OUT_,\n            _TOTAL_NFT_AMOUNT_ - NFTOutAmount,\n            _TOTAL_NFT_AMOUNT_\n        );\n        (,, pay) = IFilterAdmin(_OWNER_).queryBurnFee(rawPay);\n    }\n\n    function queryNFTRandomOut(uint256 NFTOutAmount)\n        public\n        view\n        returns (\n            uint256 rawPay, \n            uint256 pay\n        )\n    {\n        require(NFTOutAmount <= getAvaliableNFTOutAmount(), \"EXCEED_OUT_AMOUNT\");\n        rawPay = _geometricCalc(\n            _GS_START_RANDOM_OUT_,\n            _CR_RANDOM_OUT_,\n            _TOTAL_NFT_AMOUNT_ - NFTOutAmount,\n            _TOTAL_NFT_AMOUNT_\n        );\n        (,, pay) = IFilterAdmin(_OWNER_).queryBurnFee(rawPay);\n    }\n\n    // ============ Math =============\n\n    function _geometricCalc(\n        uint256 a1,\n        uint256 q,\n        uint256 start,\n        uint256 end\n    ) internal view returns (uint256) {\n        if (q == DecimalMath.ONE) {\n            return end.sub(start).mul(a1);\n        }\n        //Sn=a1*(q^n-1)/(q-1)\n        //Sn-Sm = a1*(q^n-q^m)/(q-1)\n\n        //q^n\n        uint256 qn = DecimalMath.powFloor(q, end);\n        //q^m\n        uint256 qm = DecimalMath.powFloor(q, start);\n        return a1.mul(qn.sub(qm)).div(q.sub(DecimalMath.ONE));\n    }\n    // SWC-120-Weak Sources of Randomness from Chain Attributes: L175\n    function _getRandomNum() public view returns (uint256 randomNum) {\n        randomNum = uint256(\n            keccak256(abi.encodePacked(tx.origin, blockhash(block.number - 1), gasleft()))\n        );\n    }\n\n    // ================= Ownable ================\n\n    function changeNFTInPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) external onlySuperOwner {\n        _changeNFTInPrice(newGsStart, newCr, toggleFlag);\n    }\n\n    function _changeNFTInPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) internal {\n        require(newCr > DecimalMath.ONE, \"CR_INVALID\");\n        _GS_START_IN_ = newGsStart;\n        _CR_IN_ = newCr;\n        _NFT_IN_TOGGLE_ = true;\n    }\n\n    function changeNFTRandomInPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) external onlySuperOwner {\n        _changeNFTRandomInPrice(newGsStart, newCr, toggleFlag);\n    }\n\n    function _changeNFTRandomInPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) internal {\n        require(newCr > DecimalMath.ONE, \"CR_INVALID\");\n        _GS_START_RANDOM_OUT_ = newGsStart;\n        _CR_RANDOM_OUT_ = newCr;\n        _NFT_RANDOM_OUT_TOGGLE_ = true;\n    }\n\n    function changeNFTTargetOutPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) external onlySuperOwner {\n        _changeNFTTargetOutPrice(newGsStart, newCr, toggleFlag);\n    }\n\n    function _changeNFTTargetOutPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) internal {\n        require(newCr > DecimalMath.ONE, \"CR_INVALID\");\n        _GS_START_TARGET_OUT_ = newGsStart;\n        _CR_TARGET_OUT_ = newCr;\n        _NFT_TARGET_OUT_TOGGLE_ = true;\n    }\n\n    function changeNFTAmountRange(uint256 maxNFTAmount, uint256 minNFTAmount)\n        external\n        onlySuperOwner\n    {\n        _changeNFTAmountRange(maxNFTAmount, minNFTAmount);\n    }\n\n    function _changeNFTAmountRange(uint256 maxNFTAmount, uint256 minNFTAmount) internal {\n        require(maxNFTAmount >= minNFTAmount, \"AMOUNT_INVALID\");\n        _MAX_NFT_AMOUNT_ = maxNFTAmount;\n        _MIN_NFT_AMOUNT_ = minNFTAmount;\n    }\n\n    function changeTokenIdRange(uint256 nftIdStart, uint256 nftIdEnd) external onlySuperOwner {\n        _changeTokenIdRange(nftIdStart, nftIdEnd);\n    }\n\n    function _changeTokenIdRange(uint256 nftIdStart, uint256 nftIdEnd) internal {\n        require(nftIdStart <= nftIdEnd, \"TOKEN_RANGE_INVALID\");\n\n        _NFT_ID_START_ = nftIdStart;\n        _NFT_ID_END_ = nftIdEnd;\n    }\n\n    function changeTokenIdMap(uint256[] memory tokenIds, bool[] memory isRegistered)\n        external\n        onlySuperOwner\n    {\n        _changeTokenIdMap(tokenIds, isRegistered);\n    }\n\n    function _changeTokenIdMap(uint256[] memory tokenIds, bool[] memory isRegistered) internal {\n        require(tokenIds.length == isRegistered.length, \"PARAM_NOT_MATCH\");\n\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            _SPREAD_IDS_REGISTRY_[tokenIds[i]] = isRegistered[i];\n        }\n    }\n}",
        "function": "changeNFTTargetOutPrice(uint256,uint256,bool)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/SlowMist-DODO-NFTPool Smart Contract Security Audit Report/contractV2-e16ceb038ed6bf070ea75d9359c7ad54e6f3e226/contracts/NFTPool/impl/BaseFilterV1.sol",
        "vulnerability": "State access after external call (SWC 107)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract BaseFilterV1 is InitializableOwnable, ReentrancyGuard {\n    using SafeMath for uint256;\n\n    //=================== Storage ===================\n    address public _NFT_COLLECTION_;\n    uint256 public _NFT_ID_START_;\n    uint256 public _NFT_ID_END_ = uint256(-1);\n\n    //tokenId => isRegistered\n    mapping(uint256 => bool) public _SPREAD_IDS_REGISTRY_;\n\n    //tokenId => amount\n    mapping(uint256 => uint256) public _NFT_RESERVE_;\n\n    uint256[] public _NFT_IDS_;\n    uint256 public _TOTAL_NFT_AMOUNT_;\n    uint256 public _MAX_NFT_AMOUNT_;\n    uint256 public _MIN_NFT_AMOUNT_;\n\n    // GS -> Geometric sequence\n    // CR -> Common Ratio\n\n    //For Deposit NFT INto Pool\n    uint256 public _GS_START_IN_;\n    uint256 public _CR_IN_;\n    bool public _NFT_IN_TOGGLE_ = false;\n\n    //For NFT Random OUT from Pool\n    uint256 public _GS_START_RANDOM_OUT_;\n    uint256 public _CR_RANDOM_OUT_;\n    bool public _NFT_RANDOM_OUT_TOGGLE_ = false;\n\n    //For NFT Target OUT from Pool\n    uint256 public _GS_START_TARGET_OUT_;\n    uint256 public _CR_TARGET_OUT_;\n    bool public _NFT_TARGET_OUT_TOGGLE_ = false;\n\n    modifier onlySuperOwner() {\n        require(msg.sender == IFilterAdmin(_OWNER_)._OWNER_(), \"ONLY_SUPER_OWNER\");\n        _;\n    }\n\n    //==================== Query Prop ==================\n\n    function isNFTValid(address nftCollectionAddress, uint256 nftId) external view returns (bool) {\n        if (nftCollectionAddress == _NFT_COLLECTION_) {\n            return isNFTIDValid(nftId);\n        } else {\n            return false;\n        }\n    }\n\n    function isNFTIDValid(uint256 nftId) public view returns (bool) {\n        return (nftId >= _NFT_ID_START_ && nftId <= _NFT_ID_END_) || _SPREAD_IDS_REGISTRY_[nftId];\n    }\n\n    function getAvaliableNFTInAmount() public view returns (uint256) {\n        if (_MAX_NFT_AMOUNT_ <= _TOTAL_NFT_AMOUNT_) {\n            return 0;\n        } else {\n            return _MAX_NFT_AMOUNT_ - _TOTAL_NFT_AMOUNT_;\n        }\n    }\n\n    function getAvaliableNFTOutAmount() public view returns (uint256) {\n        if (_TOTAL_NFT_AMOUNT_ <= _MIN_NFT_AMOUNT_) {\n            return 0;\n        } else {\n            return _TOTAL_NFT_AMOUNT_ - _MIN_NFT_AMOUNT_;\n        }\n    }\n\n    function getNFTIndexById(uint256 tokenId) public view returns (uint256) {\n        uint256 i = 0;\n        for (; i < _NFT_IDS_.length; i++) {\n            if (_NFT_IDS_[i] == tokenId) break;\n        }\n        require(i < _NFT_IDS_.length, \"TOKEN_ID_NOT_EXSIT\");\n        return i;\n    }\n\n    //==================== Query Price ==================\n\n    function queryNFTIn(uint256 NFTInAmount)\n        public\n        view\n        returns (\n            uint256 rawReceive, \n            uint256 received\n        )\n    {\n        require(NFTInAmount <= getAvaliableNFTInAmount(), \"EXCEDD_IN_AMOUNT\");\n        rawReceive = _geometricCalc(\n            _GS_START_IN_,\n            _CR_IN_,\n            _TOTAL_NFT_AMOUNT_,\n            _TOTAL_NFT_AMOUNT_ + NFTInAmount\n        );\n        (,, received) = IFilterAdmin(_OWNER_).queryMintFee(rawReceive);\n    }\n\n    function queryNFTTargetOut(uint256 NFTOutAmount)\n        public\n        view\n        returns (\n            uint256 rawPay, \n            uint256 pay\n        )\n    {\n        require(NFTOutAmount <= getAvaliableNFTOutAmount(), \"EXCEED_OUT_AMOUNT\");\n        rawPay = _geometricCalc(\n            _GS_START_TARGET_OUT_,\n            _CR_TARGET_OUT_,\n            _TOTAL_NFT_AMOUNT_ - NFTOutAmount,\n            _TOTAL_NFT_AMOUNT_\n        );\n        (,, pay) = IFilterAdmin(_OWNER_).queryBurnFee(rawPay);\n    }\n\n    function queryNFTRandomOut(uint256 NFTOutAmount)\n        public\n        view\n        returns (\n            uint256 rawPay, \n            uint256 pay\n        )\n    {\n        require(NFTOutAmount <= getAvaliableNFTOutAmount(), \"EXCEED_OUT_AMOUNT\");\n        rawPay = _geometricCalc(\n            _GS_START_RANDOM_OUT_,\n            _CR_RANDOM_OUT_,\n            _TOTAL_NFT_AMOUNT_ - NFTOutAmount,\n            _TOTAL_NFT_AMOUNT_\n        );\n        (,, pay) = IFilterAdmin(_OWNER_).queryBurnFee(rawPay);\n    }\n\n    // ============ Math =============\n\n    function _geometricCalc(\n        uint256 a1,\n        uint256 q,\n        uint256 start,\n        uint256 end\n    ) internal view returns (uint256) {\n        if (q == DecimalMath.ONE) {\n            return end.sub(start).mul(a1);\n        }\n        //Sn=a1*(q^n-1)/(q-1)\n        //Sn-Sm = a1*(q^n-q^m)/(q-1)\n\n        //q^n\n        uint256 qn = DecimalMath.powFloor(q, end);\n        //q^m\n        uint256 qm = DecimalMath.powFloor(q, start);\n        return a1.mul(qn.sub(qm)).div(q.sub(DecimalMath.ONE));\n    }\n    // SWC-120-Weak Sources of Randomness from Chain Attributes: L175\n    function _getRandomNum() public view returns (uint256 randomNum) {\n        randomNum = uint256(\n            keccak256(abi.encodePacked(tx.origin, blockhash(block.number - 1), gasleft()))\n        );\n    }\n\n    // ================= Ownable ================\n\n    function changeNFTInPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) external onlySuperOwner {\n        _changeNFTInPrice(newGsStart, newCr, toggleFlag);\n    }\n\n    function _changeNFTInPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) internal {\n        require(newCr > DecimalMath.ONE, \"CR_INVALID\");\n        _GS_START_IN_ = newGsStart;\n        _CR_IN_ = newCr;\n        _NFT_IN_TOGGLE_ = true;\n    }\n\n    function changeNFTRandomInPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) external onlySuperOwner {\n        _changeNFTRandomInPrice(newGsStart, newCr, toggleFlag);\n    }\n\n    function _changeNFTRandomInPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) internal {\n        require(newCr > DecimalMath.ONE, \"CR_INVALID\");\n        _GS_START_RANDOM_OUT_ = newGsStart;\n        _CR_RANDOM_OUT_ = newCr;\n        _NFT_RANDOM_OUT_TOGGLE_ = true;\n    }\n\n    function changeNFTTargetOutPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) external onlySuperOwner {\n        _changeNFTTargetOutPrice(newGsStart, newCr, toggleFlag);\n    }\n\n    function _changeNFTTargetOutPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) internal {\n        require(newCr > DecimalMath.ONE, \"CR_INVALID\");\n        _GS_START_TARGET_OUT_ = newGsStart;\n        _CR_TARGET_OUT_ = newCr;\n        _NFT_TARGET_OUT_TOGGLE_ = true;\n    }\n\n    function changeNFTAmountRange(uint256 maxNFTAmount, uint256 minNFTAmount)\n        external\n        onlySuperOwner\n    {\n        _changeNFTAmountRange(maxNFTAmount, minNFTAmount);\n    }\n\n    function _changeNFTAmountRange(uint256 maxNFTAmount, uint256 minNFTAmount) internal {\n        require(maxNFTAmount >= minNFTAmount, \"AMOUNT_INVALID\");\n        _MAX_NFT_AMOUNT_ = maxNFTAmount;\n        _MIN_NFT_AMOUNT_ = minNFTAmount;\n    }\n\n    function changeTokenIdRange(uint256 nftIdStart, uint256 nftIdEnd) external onlySuperOwner {\n        _changeTokenIdRange(nftIdStart, nftIdEnd);\n    }\n\n    function _changeTokenIdRange(uint256 nftIdStart, uint256 nftIdEnd) internal {\n        require(nftIdStart <= nftIdEnd, \"TOKEN_RANGE_INVALID\");\n\n        _NFT_ID_START_ = nftIdStart;\n        _NFT_ID_END_ = nftIdEnd;\n    }\n\n    function changeTokenIdMap(uint256[] memory tokenIds, bool[] memory isRegistered)\n        external\n        onlySuperOwner\n    {\n        _changeTokenIdMap(tokenIds, isRegistered);\n    }\n\n    function _changeTokenIdMap(uint256[] memory tokenIds, bool[] memory isRegistered) internal {\n        require(tokenIds.length == isRegistered.length, \"PARAM_NOT_MATCH\");\n\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            _SPREAD_IDS_REGISTRY_[tokenIds[i]] = isRegistered[i];\n        }\n    }\n}",
        "function": "changeNFTTargetOutPrice(uint256,uint256,bool)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/SlowMist-DODO-NFTPool Smart Contract Security Audit Report/contractV2-e16ceb038ed6bf070ea75d9359c7ad54e6f3e226/contracts/NFTPool/impl/BaseFilterV1.sol",
        "vulnerability": "State access after external call (SWC 107)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract BaseFilterV1 is InitializableOwnable, ReentrancyGuard {\n    using SafeMath for uint256;\n\n    //=================== Storage ===================\n    address public _NFT_COLLECTION_;\n    uint256 public _NFT_ID_START_;\n    uint256 public _NFT_ID_END_ = uint256(-1);\n\n    //tokenId => isRegistered\n    mapping(uint256 => bool) public _SPREAD_IDS_REGISTRY_;\n\n    //tokenId => amount\n    mapping(uint256 => uint256) public _NFT_RESERVE_;\n\n    uint256[] public _NFT_IDS_;\n    uint256 public _TOTAL_NFT_AMOUNT_;\n    uint256 public _MAX_NFT_AMOUNT_;\n    uint256 public _MIN_NFT_AMOUNT_;\n\n    // GS -> Geometric sequence\n    // CR -> Common Ratio\n\n    //For Deposit NFT INto Pool\n    uint256 public _GS_START_IN_;\n    uint256 public _CR_IN_;\n    bool public _NFT_IN_TOGGLE_ = false;\n\n    //For NFT Random OUT from Pool\n    uint256 public _GS_START_RANDOM_OUT_;\n    uint256 public _CR_RANDOM_OUT_;\n    bool public _NFT_RANDOM_OUT_TOGGLE_ = false;\n\n    //For NFT Target OUT from Pool\n    uint256 public _GS_START_TARGET_OUT_;\n    uint256 public _CR_TARGET_OUT_;\n    bool public _NFT_TARGET_OUT_TOGGLE_ = false;\n\n    modifier onlySuperOwner() {\n        require(msg.sender == IFilterAdmin(_OWNER_)._OWNER_(), \"ONLY_SUPER_OWNER\");\n        _;\n    }\n\n    //==================== Query Prop ==================\n\n    function isNFTValid(address nftCollectionAddress, uint256 nftId) external view returns (bool) {\n        if (nftCollectionAddress == _NFT_COLLECTION_) {\n            return isNFTIDValid(nftId);\n        } else {\n            return false;\n        }\n    }\n\n    function isNFTIDValid(uint256 nftId) public view returns (bool) {\n        return (nftId >= _NFT_ID_START_ && nftId <= _NFT_ID_END_) || _SPREAD_IDS_REGISTRY_[nftId];\n    }\n\n    function getAvaliableNFTInAmount() public view returns (uint256) {\n        if (_MAX_NFT_AMOUNT_ <= _TOTAL_NFT_AMOUNT_) {\n            return 0;\n        } else {\n            return _MAX_NFT_AMOUNT_ - _TOTAL_NFT_AMOUNT_;\n        }\n    }\n\n    function getAvaliableNFTOutAmount() public view returns (uint256) {\n        if (_TOTAL_NFT_AMOUNT_ <= _MIN_NFT_AMOUNT_) {\n            return 0;\n        } else {\n            return _TOTAL_NFT_AMOUNT_ - _MIN_NFT_AMOUNT_;\n        }\n    }\n\n    function getNFTIndexById(uint256 tokenId) public view returns (uint256) {\n        uint256 i = 0;\n        for (; i < _NFT_IDS_.length; i++) {\n            if (_NFT_IDS_[i] == tokenId) break;\n        }\n        require(i < _NFT_IDS_.length, \"TOKEN_ID_NOT_EXSIT\");\n        return i;\n    }\n\n    //==================== Query Price ==================\n\n    function queryNFTIn(uint256 NFTInAmount)\n        public\n        view\n        returns (\n            uint256 rawReceive, \n            uint256 received\n        )\n    {\n        require(NFTInAmount <= getAvaliableNFTInAmount(), \"EXCEDD_IN_AMOUNT\");\n        rawReceive = _geometricCalc(\n            _GS_START_IN_,\n            _CR_IN_,\n            _TOTAL_NFT_AMOUNT_,\n            _TOTAL_NFT_AMOUNT_ + NFTInAmount\n        );\n        (,, received) = IFilterAdmin(_OWNER_).queryMintFee(rawReceive);\n    }\n\n    function queryNFTTargetOut(uint256 NFTOutAmount)\n        public\n        view\n        returns (\n            uint256 rawPay, \n            uint256 pay\n        )\n    {\n        require(NFTOutAmount <= getAvaliableNFTOutAmount(), \"EXCEED_OUT_AMOUNT\");\n        rawPay = _geometricCalc(\n            _GS_START_TARGET_OUT_,\n            _CR_TARGET_OUT_,\n            _TOTAL_NFT_AMOUNT_ - NFTOutAmount,\n            _TOTAL_NFT_AMOUNT_\n        );\n        (,, pay) = IFilterAdmin(_OWNER_).queryBurnFee(rawPay);\n    }\n\n    function queryNFTRandomOut(uint256 NFTOutAmount)\n        public\n        view\n        returns (\n            uint256 rawPay, \n            uint256 pay\n        )\n    {\n        require(NFTOutAmount <= getAvaliableNFTOutAmount(), \"EXCEED_OUT_AMOUNT\");\n        rawPay = _geometricCalc(\n            _GS_START_RANDOM_OUT_,\n            _CR_RANDOM_OUT_,\n            _TOTAL_NFT_AMOUNT_ - NFTOutAmount,\n            _TOTAL_NFT_AMOUNT_\n        );\n        (,, pay) = IFilterAdmin(_OWNER_).queryBurnFee(rawPay);\n    }\n\n    // ============ Math =============\n\n    function _geometricCalc(\n        uint256 a1,\n        uint256 q,\n        uint256 start,\n        uint256 end\n    ) internal view returns (uint256) {\n        if (q == DecimalMath.ONE) {\n            return end.sub(start).mul(a1);\n        }\n        //Sn=a1*(q^n-1)/(q-1)\n        //Sn-Sm = a1*(q^n-q^m)/(q-1)\n\n        //q^n\n        uint256 qn = DecimalMath.powFloor(q, end);\n        //q^m\n        uint256 qm = DecimalMath.powFloor(q, start);\n        return a1.mul(qn.sub(qm)).div(q.sub(DecimalMath.ONE));\n    }\n    // SWC-120-Weak Sources of Randomness from Chain Attributes: L175\n    function _getRandomNum() public view returns (uint256 randomNum) {\n        randomNum = uint256(\n            keccak256(abi.encodePacked(tx.origin, blockhash(block.number - 1), gasleft()))\n        );\n    }\n\n    // ================= Ownable ================\n\n    function changeNFTInPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) external onlySuperOwner {\n        _changeNFTInPrice(newGsStart, newCr, toggleFlag);\n    }\n\n    function _changeNFTInPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) internal {\n        require(newCr > DecimalMath.ONE, \"CR_INVALID\");\n        _GS_START_IN_ = newGsStart;\n        _CR_IN_ = newCr;\n        _NFT_IN_TOGGLE_ = true;\n    }\n\n    function changeNFTRandomInPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) external onlySuperOwner {\n        _changeNFTRandomInPrice(newGsStart, newCr, toggleFlag);\n    }\n\n    function _changeNFTRandomInPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) internal {\n        require(newCr > DecimalMath.ONE, \"CR_INVALID\");\n        _GS_START_RANDOM_OUT_ = newGsStart;\n        _CR_RANDOM_OUT_ = newCr;\n        _NFT_RANDOM_OUT_TOGGLE_ = true;\n    }\n\n    function changeNFTTargetOutPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) external onlySuperOwner {\n        _changeNFTTargetOutPrice(newGsStart, newCr, toggleFlag);\n    }\n\n    function _changeNFTTargetOutPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) internal {\n        require(newCr > DecimalMath.ONE, \"CR_INVALID\");\n        _GS_START_TARGET_OUT_ = newGsStart;\n        _CR_TARGET_OUT_ = newCr;\n        _NFT_TARGET_OUT_TOGGLE_ = true;\n    }\n\n    function changeNFTAmountRange(uint256 maxNFTAmount, uint256 minNFTAmount)\n        external\n        onlySuperOwner\n    {\n        _changeNFTAmountRange(maxNFTAmount, minNFTAmount);\n    }\n\n    function _changeNFTAmountRange(uint256 maxNFTAmount, uint256 minNFTAmount) internal {\n        require(maxNFTAmount >= minNFTAmount, \"AMOUNT_INVALID\");\n        _MAX_NFT_AMOUNT_ = maxNFTAmount;\n        _MIN_NFT_AMOUNT_ = minNFTAmount;\n    }\n\n    function changeTokenIdRange(uint256 nftIdStart, uint256 nftIdEnd) external onlySuperOwner {\n        _changeTokenIdRange(nftIdStart, nftIdEnd);\n    }\n\n    function _changeTokenIdRange(uint256 nftIdStart, uint256 nftIdEnd) internal {\n        require(nftIdStart <= nftIdEnd, \"TOKEN_RANGE_INVALID\");\n\n        _NFT_ID_START_ = nftIdStart;\n        _NFT_ID_END_ = nftIdEnd;\n    }\n\n    function changeTokenIdMap(uint256[] memory tokenIds, bool[] memory isRegistered)\n        external\n        onlySuperOwner\n    {\n        _changeTokenIdMap(tokenIds, isRegistered);\n    }\n\n    function _changeTokenIdMap(uint256[] memory tokenIds, bool[] memory isRegistered) internal {\n        require(tokenIds.length == isRegistered.length, \"PARAM_NOT_MATCH\");\n\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            _SPREAD_IDS_REGISTRY_[tokenIds[i]] = isRegistered[i];\n        }\n    }\n}",
        "function": "changeNFTTargetOutPrice(uint256,uint256,bool)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/SlowMist-DODO-NFTPool Smart Contract Security Audit Report/contractV2-e16ceb038ed6bf070ea75d9359c7ad54e6f3e226/contracts/NFTPool/impl/BaseFilterV1.sol",
        "vulnerability": "State access after external call (SWC 107)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract BaseFilterV1 is InitializableOwnable, ReentrancyGuard {\n    using SafeMath for uint256;\n\n    //=================== Storage ===================\n    address public _NFT_COLLECTION_;\n    uint256 public _NFT_ID_START_;\n    uint256 public _NFT_ID_END_ = uint256(-1);\n\n    //tokenId => isRegistered\n    mapping(uint256 => bool) public _SPREAD_IDS_REGISTRY_;\n\n    //tokenId => amount\n    mapping(uint256 => uint256) public _NFT_RESERVE_;\n\n    uint256[] public _NFT_IDS_;\n    uint256 public _TOTAL_NFT_AMOUNT_;\n    uint256 public _MAX_NFT_AMOUNT_;\n    uint256 public _MIN_NFT_AMOUNT_;\n\n    // GS -> Geometric sequence\n    // CR -> Common Ratio\n\n    //For Deposit NFT INto Pool\n    uint256 public _GS_START_IN_;\n    uint256 public _CR_IN_;\n    bool public _NFT_IN_TOGGLE_ = false;\n\n    //For NFT Random OUT from Pool\n    uint256 public _GS_START_RANDOM_OUT_;\n    uint256 public _CR_RANDOM_OUT_;\n    bool public _NFT_RANDOM_OUT_TOGGLE_ = false;\n\n    //For NFT Target OUT from Pool\n    uint256 public _GS_START_TARGET_OUT_;\n    uint256 public _CR_TARGET_OUT_;\n    bool public _NFT_TARGET_OUT_TOGGLE_ = false;\n\n    modifier onlySuperOwner() {\n        require(msg.sender == IFilterAdmin(_OWNER_)._OWNER_(), \"ONLY_SUPER_OWNER\");\n        _;\n    }\n\n    //==================== Query Prop ==================\n\n    function isNFTValid(address nftCollectionAddress, uint256 nftId) external view returns (bool) {\n        if (nftCollectionAddress == _NFT_COLLECTION_) {\n            return isNFTIDValid(nftId);\n        } else {\n            return false;\n        }\n    }\n\n    function isNFTIDValid(uint256 nftId) public view returns (bool) {\n        return (nftId >= _NFT_ID_START_ && nftId <= _NFT_ID_END_) || _SPREAD_IDS_REGISTRY_[nftId];\n    }\n\n    function getAvaliableNFTInAmount() public view returns (uint256) {\n        if (_MAX_NFT_AMOUNT_ <= _TOTAL_NFT_AMOUNT_) {\n            return 0;\n        } else {\n            return _MAX_NFT_AMOUNT_ - _TOTAL_NFT_AMOUNT_;\n        }\n    }\n\n    function getAvaliableNFTOutAmount() public view returns (uint256) {\n        if (_TOTAL_NFT_AMOUNT_ <= _MIN_NFT_AMOUNT_) {\n            return 0;\n        } else {\n            return _TOTAL_NFT_AMOUNT_ - _MIN_NFT_AMOUNT_;\n        }\n    }\n\n    function getNFTIndexById(uint256 tokenId) public view returns (uint256) {\n        uint256 i = 0;\n        for (; i < _NFT_IDS_.length; i++) {\n            if (_NFT_IDS_[i] == tokenId) break;\n        }\n        require(i < _NFT_IDS_.length, \"TOKEN_ID_NOT_EXSIT\");\n        return i;\n    }\n\n    //==================== Query Price ==================\n\n    function queryNFTIn(uint256 NFTInAmount)\n        public\n        view\n        returns (\n            uint256 rawReceive, \n            uint256 received\n        )\n    {\n        require(NFTInAmount <= getAvaliableNFTInAmount(), \"EXCEDD_IN_AMOUNT\");\n        rawReceive = _geometricCalc(\n            _GS_START_IN_,\n            _CR_IN_,\n            _TOTAL_NFT_AMOUNT_,\n            _TOTAL_NFT_AMOUNT_ + NFTInAmount\n        );\n        (,, received) = IFilterAdmin(_OWNER_).queryMintFee(rawReceive);\n    }\n\n    function queryNFTTargetOut(uint256 NFTOutAmount)\n        public\n        view\n        returns (\n            uint256 rawPay, \n            uint256 pay\n        )\n    {\n        require(NFTOutAmount <= getAvaliableNFTOutAmount(), \"EXCEED_OUT_AMOUNT\");\n        rawPay = _geometricCalc(\n            _GS_START_TARGET_OUT_,\n            _CR_TARGET_OUT_,\n            _TOTAL_NFT_AMOUNT_ - NFTOutAmount,\n            _TOTAL_NFT_AMOUNT_\n        );\n        (,, pay) = IFilterAdmin(_OWNER_).queryBurnFee(rawPay);\n    }\n\n    function queryNFTRandomOut(uint256 NFTOutAmount)\n        public\n        view\n        returns (\n            uint256 rawPay, \n            uint256 pay\n        )\n    {\n        require(NFTOutAmount <= getAvaliableNFTOutAmount(), \"EXCEED_OUT_AMOUNT\");\n        rawPay = _geometricCalc(\n            _GS_START_RANDOM_OUT_,\n            _CR_RANDOM_OUT_,\n            _TOTAL_NFT_AMOUNT_ - NFTOutAmount,\n            _TOTAL_NFT_AMOUNT_\n        );\n        (,, pay) = IFilterAdmin(_OWNER_).queryBurnFee(rawPay);\n    }\n\n    // ============ Math =============\n\n    function _geometricCalc(\n        uint256 a1,\n        uint256 q,\n        uint256 start,\n        uint256 end\n    ) internal view returns (uint256) {\n        if (q == DecimalMath.ONE) {\n            return end.sub(start).mul(a1);\n        }\n        //Sn=a1*(q^n-1)/(q-1)\n        //Sn-Sm = a1*(q^n-q^m)/(q-1)\n\n        //q^n\n        uint256 qn = DecimalMath.powFloor(q, end);\n        //q^m\n        uint256 qm = DecimalMath.powFloor(q, start);\n        return a1.mul(qn.sub(qm)).div(q.sub(DecimalMath.ONE));\n    }\n    // SWC-120-Weak Sources of Randomness from Chain Attributes: L175\n    function _getRandomNum() public view returns (uint256 randomNum) {\n        randomNum = uint256(\n            keccak256(abi.encodePacked(tx.origin, blockhash(block.number - 1), gasleft()))\n        );\n    }\n\n    // ================= Ownable ================\n\n    function changeNFTInPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) external onlySuperOwner {\n        _changeNFTInPrice(newGsStart, newCr, toggleFlag);\n    }\n\n    function _changeNFTInPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) internal {\n        require(newCr > DecimalMath.ONE, \"CR_INVALID\");\n        _GS_START_IN_ = newGsStart;\n        _CR_IN_ = newCr;\n        _NFT_IN_TOGGLE_ = true;\n    }\n\n    function changeNFTRandomInPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) external onlySuperOwner {\n        _changeNFTRandomInPrice(newGsStart, newCr, toggleFlag);\n    }\n\n    function _changeNFTRandomInPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) internal {\n        require(newCr > DecimalMath.ONE, \"CR_INVALID\");\n        _GS_START_RANDOM_OUT_ = newGsStart;\n        _CR_RANDOM_OUT_ = newCr;\n        _NFT_RANDOM_OUT_TOGGLE_ = true;\n    }\n\n    function changeNFTTargetOutPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) external onlySuperOwner {\n        _changeNFTTargetOutPrice(newGsStart, newCr, toggleFlag);\n    }\n\n    function _changeNFTTargetOutPrice(\n        uint256 newGsStart,\n        uint256 newCr,\n        bool toggleFlag\n    ) internal {\n        require(newCr > DecimalMath.ONE, \"CR_INVALID\");\n        _GS_START_TARGET_OUT_ = newGsStart;\n        _CR_TARGET_OUT_ = newCr;\n        _NFT_TARGET_OUT_TOGGLE_ = true;\n    }\n\n    function changeNFTAmountRange(uint256 maxNFTAmount, uint256 minNFTAmount)\n        external\n        onlySuperOwner\n    {\n        _changeNFTAmountRange(maxNFTAmount, minNFTAmount);\n    }\n\n    function _changeNFTAmountRange(uint256 maxNFTAmount, uint256 minNFTAmount) internal {\n        require(maxNFTAmount >= minNFTAmount, \"AMOUNT_INVALID\");\n        _MAX_NFT_AMOUNT_ = maxNFTAmount;\n        _MIN_NFT_AMOUNT_ = minNFTAmount;\n    }\n\n    function changeTokenIdRange(uint256 nftIdStart, uint256 nftIdEnd) external onlySuperOwner {\n        _changeTokenIdRange(nftIdStart, nftIdEnd);\n    }\n\n    function _changeTokenIdRange(uint256 nftIdStart, uint256 nftIdEnd) internal {\n        require(nftIdStart <= nftIdEnd, \"TOKEN_RANGE_INVALID\");\n\n        _NFT_ID_START_ = nftIdStart;\n        _NFT_ID_END_ = nftIdEnd;\n    }\n\n    function changeTokenIdMap(uint256[] memory tokenIds, bool[] memory isRegistered)\n        external\n        onlySuperOwner\n    {\n        _changeTokenIdMap(tokenIds, isRegistered);\n    }\n\n    function _changeTokenIdMap(uint256[] memory tokenIds, bool[] memory isRegistered) internal {\n        require(tokenIds.length == isRegistered.length, \"PARAM_NOT_MATCH\");\n\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            _SPREAD_IDS_REGISTRY_[tokenIds[i]] = isRegistered[i];\n        }\n    }\n}",
        "function": "changeNFTTargetOutPrice(uint256,uint256,bool)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/SlowMist-DODO-NFTPool Smart Contract Security Audit Report/contractV2-e16ceb038ed6bf070ea75d9359c7ad54e6f3e226/contracts/NFTPool/impl/BaseFilterV1.sol",
        "vulnerability": "State access after external call (SWC 107)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract BridgeValidators is IBridgeValidators, EternalStorage, Ownable {\n    using SafeMath for uint256;\n    event ValidatorAdded (address validator);\n    event ValidatorRemoved (address validator);\n    event RequiredSignaturesChanged (uint256 requiredSignatures);\n\n    function initialize(uint256 _requiredSignatures, address[] _initialValidators, address _owner)\n      public returns(bool)\n    {\n        require(!isInitialized());\n        require(_owner != address(0));\n        setOwner(_owner);\n        require(_requiredSignatures != 0);\n        require(_initialValidators.length >= _requiredSignatures);\n        for (uint256 i = 0; i < _initialValidators.length; i++) {\n            require(_initialValidators[i] != address(0));\n            assert(validators(_initialValidators[i]) != true);\n            setValidatorCount(validatorCount().add(1));\n            setValidator(_initialValidators[i], true);\n            emit ValidatorAdded(_initialValidators[i]);\n        }\n        //SWC-135-Code With No Effects: L31\n        require(validatorCount() >= _requiredSignatures);\n        uintStorage[keccak256(abi.encodePacked(\"requiredSignatures\"))] = _requiredSignatures;\n        setInitialize(true);\n        return isInitialized();\n    }\n\n    function addValidator(address _validator) external onlyOwner {\n        require(_validator != address(0));\n        require(!isValidator(_validator));\n        setValidatorCount(validatorCount().add(1));\n        setValidator(_validator, true);\n        emit ValidatorAdded(_validator);\n    }\n\n    function removeValidator(address _validator) external onlyOwner {\n        require(validatorCount() > requiredSignatures());\n        require(isValidator(_validator));\n        setValidator(_validator, false);\n        setValidatorCount(validatorCount().sub(1));\n        emit ValidatorRemoved(_validator);\n    }\n\n    function setRequiredSignatures(uint256 _requiredSignatures) external onlyOwner {\n        require(validatorCount() >= _requiredSignatures);\n        require(_requiredSignatures != 0);\n        uintStorage[keccak256(abi.encodePacked(\"requiredSignatures\"))] = _requiredSignatures;\n        emit RequiredSignaturesChanged(_requiredSignatures);\n    }\n\n    function requiredSignatures() public view returns(uint256) {\n        return uintStorage[keccak256(abi.encodePacked(\"requiredSignatures\"))];\n    }\n\n    function validatorCount() public view returns(uint256) {\n        return uintStorage[keccak256(abi.encodePacked(\"validatorCount\"))];\n    }\n\n    function validators(address _validator) public view returns(bool) {\n        return boolStorage[keccak256(abi.encodePacked(\"validators\", _validator))];\n    }\n\n    function isValidator(address _validator) public view returns(bool) {\n        return validators(_validator) == true;\n    }\n\n    function isInitialized() public view returns(bool) {\n        return boolStorage[keccak256(abi.encodePacked(\"isInitialized\"))];\n    }\n\n    function setValidatorCount(uint256 _validatorCount) private {\n        uintStorage[keccak256(abi.encodePacked(\"validatorCount\"))] = _validatorCount;\n    }\n\n    function setValidator(address _validator, bool _status) private {\n        boolStorage[keccak256(abi.encodePacked(\"validators\", _validator))] = _status;\n    }\n\n    function setInitialize(bool _status) private {\n        boolStorage[keccak256(abi.encodePacked(\"isInitialized\"))] = _status;\n    }\n}",
        "function": "initialize(uint256,address[],address)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/PepperSec-POA-Network-Bridge/tokenbridge-contracts-2bf70c7e9fd42968aec2dc352017618907834401/contracts/upgradeable_contracts/BridgeValidators.sol",
        "vulnerability": "Exception State (SWC 110)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract Vault {\n    using SafeMath for uint;\n    /**\n     * @dev Storage slot with the incognito proxy.\n     * This is the keccak-256 hash of \"eip1967.proxy.incognito.\" subtracted by 1\n     */\n    bytes32 private constant _INCOGNITO_SLOT = 0x62135fc083646fdb4e1a9d700e351b886a4a5a39da980650269edd1ade91ffd2;\n    address constant public ETH_TOKEN = 0x0000000000000000000000000000000000000000;\n    mapping(bytes32 => bool) public withdrawed;\n    mapping(bytes32 => bool) public sigDataUsed;\n    // address => token => amount\n    mapping(address => mapping(address => uint)) public withdrawRequests;\n    mapping(address => mapping(address => bool)) public migration;\n    mapping(address => uint) public totalDepositedToSCAmount;\n    Withdrawable public prevVault;\n    bool public notEntered = true;\n    bool public isInitialized = false;\n\n    struct BurnInstData {\n        uint8 meta; // type of the instruction\n        uint8 shard; // ID of the Incognito shard containing the instruction, must be 1\n        address token; // ETH address of the token contract (0x0 for ETH)\n        address payable to; // ETH address of the receiver of the token\n        uint amount; // burned amount (on Incognito)\n        bytes32 itx; // Incognito's burning tx\n    }\n\n    // error code\n    enum Errors {\n        EMPTY,\n        NO_REENTRANCE,\n        MAX_UINT_REACHED,\n        VALUE_OVER_FLOW,\n        INTERNAL_TX_ERROR,\n        ALREADY_USED,\n        INVALID_DATA,\n        TOKEN_NOT_ENOUGH,\n        WITHDRAW_REQUEST_TOKEN_NOT_ENOUGH,\n        INVALID_RETURN_DATA,\n        NOT_EQUAL,\n        NULL_VALUE,\n        ONLY_PREVAULT,\n        PREVAULT_NOT_PAUSED\n    }\n\n    event Deposit(address token, string incognitoAddress, uint amount);\n    event Withdraw(address token, address to, uint amount);\n    event UpdateTokenTotal(address[] assets, uint[] amounts);\n    event UpdateIncognitoProxy(address newIncognitoProxy);\n\n    /**\n     * modifier for contract version\n     */\n     modifier onlyPreVault(){\n        require(address(prevVault) != address(0x0) && msg.sender == address(prevVault), errorToString(Errors.ONLY_PREVAULT));\n        _;\n     }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, notEntered will be true\n        require(notEntered, errorToString(Errors.NO_REENTRANCE));\n\n        // Any calls to nonReentrant after this point will fail\n        notEntered = false;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        notEntered = true;\n    }\n\n    /**\n     * @dev Creates new Vault to hold assets for Incognito Chain\n     * @param _prevVault: previous version of the Vault to refer back if necessary\n     * After migrating all assets to a new Vault, we still need to refer\n     * back to previous Vault to make sure old withdrawals aren't being reused\n     */\n    function initialize(address _prevVault) external {\n        require(!isInitialized);\n        prevVault = Withdrawable(_prevVault);\n        isInitialized = true;\n        notEntered = true;\n    }\n\n    /**\n     * @dev Returns the current incognito proxy.\n     */\n    function _incognito() internal view returns (address icg) {\n        bytes32 slot = _INCOGNITO_SLOT;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            icg := sload(slot)\n        }\n    }\n\n    /**\n     * @dev Makes a ETH deposit to the vault to mint pETH over at Incognito Chain\n     * @notice This only works when the contract is not Paused\n     * @notice The maximum amount to deposit is capped since Incognito balance is stored as uint64\n     * @param incognitoAddress: Incognito Address to receive pETH\n     */\n    function deposit(string calldata incognitoAddress) external payable nonReentrant {\n        require(address(this).balance <= 10 ** 27, errorToString(Errors.MAX_UINT_REACHED));\n        emit Deposit(ETH_TOKEN, incognitoAddress, msg.value);\n    }\n\n    /**\n     * @dev Makes a ERC20 deposit to the vault to mint pERC20 over at Incognito Chain\n     * @notice This only works when the contract is not Paused\n     * @notice The maximum amount to deposit is capped since Incognito balance is stored as uint64\n     * @notice Before calling this function, enough ERC20 must be allowed to\n     * tranfer from msg.sender to this contract\n     * @param token: address of the ERC20 token\n     * @param amount: to deposit to the vault and mint on Incognito Chain\n     * @param incognitoAddress: Incognito Address to receive pERC20\n     */\n    function depositERC20(address token, uint amount, string calldata incognitoAddress) external payable nonReentrant {\n        IERC20 erc20Interface = IERC20(token);\n        uint8 decimals = getDecimals(address(token));\n        uint tokenBalance = erc20Interface.balanceOf(address(this));\n        uint beforeTransfer = tokenBalance;\n        uint emitAmount = amount;\n        if (decimals > 9) {\n            emitAmount = emitAmount / (10 ** (uint(decimals) - 9));\n            tokenBalance = tokenBalance / (10 ** (uint(decimals) - 9));\n        }\n        require(emitAmount <= 10 ** 18 && tokenBalance <= 10 ** 18 && emitAmount.safeAdd(tokenBalance) <= 10 ** 18, errorToString(Errors.VALUE_OVER_FLOW));\n        erc20Interface.transferFrom(msg.sender, address(this), amount);\n        require(checkSuccess(), errorToString(Errors.INTERNAL_TX_ERROR));\n        require(balanceOf(token).safeSub(beforeTransfer) == amount, errorToString(Errors.NOT_EQUAL));\n\n        emit Deposit(token, incognitoAddress, emitAmount);\n    }\n\n    /**\n     * @dev Checks if a burn proof has been used before\n     * @notice First, we check inside the storage of this contract itself. If the\n     * hash has been used before, we return the result. Otherwise, we query\n     * previous vault recursively until the first Vault (prevVault address is 0x0)\n     * @param hash: of the burn proof\n     * @return bool: whether the proof has been used or not\n     */\n    function isWithdrawed(bytes32 hash) public view returns(bool) {\n        if (withdrawed[hash]) {\n            return true;\n        } else if (address(prevVault) == address(0)) {\n            return false;\n        }\n        return prevVault.isWithdrawed(hash);\n    }\n\n    /**\n     * @dev Parses a burn instruction and returns the components\n     * @param inst: the full instruction, containing both metadata and body\n     */\n    function parseBurnInst(bytes memory inst) public pure returns (BurnInstData memory) {\n        BurnInstData memory data;\n        data.meta = uint8(inst[0]);\n        data.shard = uint8(inst[1]);\n        address token;\n        address payable to;\n        uint amount;\n        bytes32 itx;\n        assembly {\n            // skip first 0x20 bytes (stored length of inst)\n            token := mload(add(inst, 0x22)) // [3:34]\n            to := mload(add(inst, 0x42)) // [34:66]\n            amount := mload(add(inst, 0x62)) // [66:98]\n            itx := mload(add(inst, 0x82)) // [98:130]\n        }\n        data.token = token;\n        data.to = to;\n        data.amount = amount;\n        data.itx = itx;\n        return data;\n    }\n\n    /**\n     * @dev Verifies that a burn instruction is valid\n     * @notice All params except inst are the list of 2 elements corresponding to\n     * the proof on beacon and bridge\n     * @notice All params are the same as in `withdraw`\n     */\n    function verifyInst(\n        bytes memory inst,\n        uint heights,\n        bytes32[] memory instPaths,\n        bool[] memory instPathIsLefts,\n        bytes32 instRoots,\n        bytes32 blkData,\n        uint[] memory sigIdxs,\n        uint8[] memory sigVs,\n        bytes32[] memory sigRs,\n        bytes32[] memory sigSs\n    ) view internal {\n        // Each instruction can only by redeemed once\n        bytes32 beaconInstHash = keccak256(abi.encodePacked(inst, heights));\n\n        // Verify instruction on beacon\n        require(Incognito(_incognito()).instructionApproved(\n            true, // Only check instruction on beacon\n            beaconInstHash,\n            heights,\n            instPaths,\n            instPathIsLefts,\n            instRoots,\n            blkData,\n            sigIdxs,\n            sigVs,\n            sigRs,\n            sigSs\n        ), errorToString(Errors.INVALID_DATA));\n    }\n\n    /**\n     * @dev Withdraws pETH/pIERC20 by providing a burn proof over at Incognito Chain\n     * @notice This function takes a burn instruction on Incognito Chain, checks\n     * for its validity and returns the token back to ETH chain\n     * @notice This only works when the contract is not Paused\n     * @param inst: the decoded instruction as a list of bytes\n     * @param heights: the blocks containing the instruction\n     * @param instPaths: merkle path of the instruction\n     * @param instPathIsLefts: whether each node on the path is the left or right child\n     * @param instRoots: root of the merkle tree contains all instructions\n     * @param blkData: merkle has of the block body\n     * @param sigIdxs: indices of the validators who signed this block\n     * @param sigVs: part of the signatures of the validators\n     * @param sigRs: part of the signatures of the validators\n     * @param sigSs: part of the signatures of the validators\n     */\n    function withdraw(\n        bytes memory inst,\n        uint heights,\n        bytes32[] memory instPaths,\n        bool[] memory instPathIsLefts,\n        bytes32 instRoots,\n        bytes32 blkData,\n        uint[] memory sigIdxs,\n        uint8[] memory sigVs,\n        bytes32[] memory sigRs,\n        bytes32[] memory sigSs\n    ) public nonReentrant {\n        require(inst.length >= 130);\n        BurnInstData memory data = parseBurnInst(inst);\n        require(data.meta == 241 && data.shard == 1); // Check instruction type\n\n        // Not withdrawed\n        require(!isWithdrawed(data.itx), errorToString(Errors.ALREADY_USED));\n        withdrawed[data.itx] = true;\n\n        // Check if balance is enough\n        if (data.token == ETH_TOKEN) {\n            require(address(this).balance >= data.amount.safeAdd(totalDepositedToSCAmount[data.token]), errorToString(Errors.TOKEN_NOT_ENOUGH));\n        } else {\n            uint8 decimals = getDecimals(data.token);\n            if (decimals > 9) {\n                data.amount = data.amount * (10 ** (uint(decimals) - 9));\n            }\n            require(IERC20(data.token).balanceOf(address(this)) >= data.amount.safeAdd(totalDepositedToSCAmount[data.token]), errorToString(Errors.TOKEN_NOT_ENOUGH));\n        }\n\n        verifyInst(\n            inst,\n            heights,\n            instPaths,\n            instPathIsLefts,\n            instRoots,\n            blkData,\n            sigIdxs,\n            sigVs,\n            sigRs,\n            sigSs\n        );\n\n        // Send and notify\n        if (data.token == ETH_TOKEN) {\n          (bool success, ) =  data.to.call{value: data.amount}(\"\");\n          require(success, errorToString(Errors.INTERNAL_TX_ERROR));\n        } else {\n            IERC20(data.token).transfer(data.to, data.amount);\n            require(checkSuccess(), errorToString(Errors.INTERNAL_TX_ERROR));\n        }\n        emit Withdraw(data.token, data.to, data.amount);\n    }\n\n    /**\n     * @dev Burnt Proof is submited to store burnt amount of p-token/p-ETH and receiver's address\n     * Receiver then can call withdrawRequest to withdraw these token to he/she incognito address.\n     * @notice This function takes a burn instruction on Incognito Chain, checks\n     * for its validity and returns the token back to ETH chain\n     * @notice This only works when the contract is not Paused\n     * @param inst: the decoded instruction as a list of bytes\n     * @param heights: the blocks containing the instruction\n     * @param instPaths: merkle path of the instruction\n     * @param instPathIsLefts: whether each node on the path is the left or right child\n     * @param instRoots: root of the merkle tree contains all instructions\n     * @param blkData: merkle has of the block body\n     * @param sigIdxs: indices of the validators who signed this block\n     * @param sigVs: part of the signatures of the validators\n     * @param sigRs: part of the signatures of the validators\n     * @param sigSs: part of the signatures of the validators\n     */\n    function submitBurnProof(\n        bytes memory inst,\n        uint heights,\n        bytes32[] memory instPaths,\n        bool[] memory instPathIsLefts,\n        bytes32 instRoots,\n        bytes32 blkData,\n        uint[] memory sigIdxs,\n        uint8[] memory sigVs,\n        bytes32[] memory sigRs,\n        bytes32[] memory sigSs\n    ) public nonReentrant {\n        require(inst.length >= 130);\n        BurnInstData memory data = parseBurnInst(inst);\n        require(data.meta == 243 && data.shard == 1); // Check instruction type\n\n        // Not withdrawed\n        require(!isWithdrawed(data.itx), errorToString(Errors.ALREADY_USED));\n        withdrawed[data.itx] = true;\n\n        // Check if balance is enough\n        if (data.token == ETH_TOKEN) {\n            require(address(this).balance >= data.amount.safeAdd(totalDepositedToSCAmount[data.token]), errorToString(Errors.TOKEN_NOT_ENOUGH));\n        } else {\n            uint8 decimals = getDecimals(data.token);\n            if (decimals > 9) {\n                // SWC-101-Integer Overflow and Underflow: L409\n                data.amount = data.amount * (10 ** (uint(decimals) - 9));\n            }\n            require(IERC20(data.token).balanceOf(address(this)) >= data.amount.safeAdd(totalDepositedToSCAmount[data.token]), errorToString(Errors.TOKEN_NOT_ENOUGH));\n        }\n\n        verifyInst(\n            inst,\n            heights,\n            instPaths,\n            instPathIsLefts,\n            instRoots,\n            blkData,\n            sigIdxs,\n            sigVs,\n            sigRs,\n            sigSs\n        );\n\n        withdrawRequests[data.to][data.token] = withdrawRequests[data.to][data.token].safeAdd(data.amount);\n        totalDepositedToSCAmount[data.token] = totalDepositedToSCAmount[data.token].safeAdd(data.amount);\n    }\n\n    /**\n     * @dev generate address from signature data and hash.\n     */\n    function sigToAddress(bytes memory signData, bytes32 hash) public pure returns (address) {\n        bytes32 s;\n        bytes32 r;\n        uint8 v;\n        assembly {\n            r := mload(add(signData, 0x20))\n            s := mload(add(signData, 0x40))\n        }\n        v = uint8(signData[64]) + 27;\n        return ecrecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Checks if a sig data has been used before\n     * @notice First, we check inside the storage of this contract itself. If the\n     * hash has been used before, we return the result. Otherwise, we query\n     * previous vault recursively until the first Vault (prevVault address is 0x0)\n     * @param hash: of the sig data\n     * @return bool: whether the sig data has been used or not\n     */\n    function isSigDataUsed(bytes32 hash) public view returns(bool) {\n        if (sigDataUsed[hash]) {\n            return true;\n        } else if (address(prevVault) == address(0)) {\n            return false;\n        }\n        return prevVault.isSigDataUsed(hash);\n    }\n\n    /**\n     * @dev User requests withdraw token contains in withdrawRequests.\n     * Deposit event will be emitted to let incognito recognize and mint new p-tokens for the user.\n     * @param incognitoAddress: incognito's address that will receive minted p-tokens.\n     * @param token: ethereum's token address (eg., ETH, DAI, ...)\n     * @param amount: amount of the token in ethereum's denomination\n     * @param signData: signature of an unique data that is signed by an account which is generated from user's incognito privkey\n     * @param timestamp: unique data generated from client (timestamp for example)\n     */\n    function requestWithdraw(\n        string calldata incognitoAddress,\n        address token,\n        uint amount,\n        bytes calldata signData,\n        bytes calldata timestamp\n    ) external nonReentrant {\n        // verify owner signs data\n        address verifier = verifySignData(abi.encode(incognitoAddress, token, timestamp, amount), signData);\n\n        // migrate from preVault\n        migrateBalance(verifier, token);\n\n        require(withdrawRequests[verifier][token] >= amount, errorToString(Errors.WITHDRAW_REQUEST_TOKEN_NOT_ENOUGH));\n        withdrawRequests[verifier][token] = withdrawRequests[verifier][token].safeSub(amount);\n        totalDepositedToSCAmount[token] = totalDepositedToSCAmount[token].safeSub(amount);\n\n        // convert denomination from ethereum's to incognito's (pcoin)\n        uint emitAmount = amount;\n        if (token != ETH_TOKEN) {\n            uint8 decimals = getDecimals(token);\n            if (decimals > 9) {\n                emitAmount = amount / (10 ** (uint(decimals) - 9));\n            }\n        }\n\n        emit Deposit(token, incognitoAddress, emitAmount);\n    }\n\n    /**\n     * @dev execute is a general function that plays a role as proxy to interact to other smart contracts.\n     * @param token: ethereum's token address (eg., ETH, DAI, ...)\n     * @param amount: amount of the token in ethereum's denomination\n     * @param recipientToken: received token address.\n     * @param exchangeAddress: address of targeting smart contract that actually executes the desired logics like trade, invest, borrow and so on.\n     * @param callData: encoded with signature and params of function from targeting smart contract.\n     * @param timestamp: unique data generated from client (timestamp for example)\n     * @param signData: signature of an unique data that is signed by an account which is generated from user's incognito privkey\n     */\n    //  SWC-114-Transaction Order Dependence: L512 - L547\n    // SWC-105-Unprotected Ether Withdrawal: L513 - 548\n    function execute(\n        address token,\n        uint amount,\n        address recipientToken,\n        address exchangeAddress,\n        bytes calldata callData,\n        bytes calldata timestamp,\n        bytes calldata signData\n    ) external payable nonReentrant {\n        //verify ower signs data from input\n        address verifier = verifySignData(abi.encode(exchangeAddress, callData, timestamp, amount), signData);\n\n        // migrate from preVault\n        migrateBalance(verifier, token);\n        require(withdrawRequests[verifier][token] >= amount, errorToString(Errors.WITHDRAW_REQUEST_TOKEN_NOT_ENOUGH));\n\n        // update balance of verifier\n        totalDepositedToSCAmount[token] = totalDepositedToSCAmount[token].safeSub(amount);\n        withdrawRequests[verifier][token] = withdrawRequests[verifier][token].safeSub(amount);\n\n        // define number of eth spent for forwarder.\n        uint ethAmount = msg.value;\n        if (token == ETH_TOKEN) {\n            ethAmount = ethAmount.safeAdd(amount);\n        } else {\n            // transfer token to exchangeAddress.\n            require(IERC20(token).balanceOf(address(this)) >= amount, errorToString(Errors.TOKEN_NOT_ENOUGH));\n            IERC20(token).transfer(exchangeAddress, amount);\n            require(checkSuccess(), errorToString(Errors.INTERNAL_TX_ERROR));\n        }\n        uint returnedAmount = callExtFunc(recipientToken, ethAmount, callData, exchangeAddress);\n\n        // update withdrawRequests\n        withdrawRequests[verifier][recipientToken] = withdrawRequests[verifier][recipientToken].safeAdd(returnedAmount);\n        totalDepositedToSCAmount[recipientToken] = totalDepositedToSCAmount[recipientToken].safeAdd(returnedAmount);\n    }\n\n    /**\n     * @dev single trade\n     */\n    function callExtFunc(address recipientToken, uint ethAmount, bytes memory callData, address exchangeAddress) internal returns (uint) {\n         // get balance of recipient token before trade to compare after trade.\n        uint balanceBeforeTrade = balanceOf(recipientToken);\n        if (recipientToken == ETH_TOKEN) {\n            balanceBeforeTrade = balanceBeforeTrade.safeSub(msg.value);\n        }\n        require(address(this).balance >= ethAmount, errorToString(Errors.TOKEN_NOT_ENOUGH));\n        (bool success, bytes memory result) = exchangeAddress.call{value: ethAmount}(callData);\n        require(success);\n\n        (address returnedTokenAddress, uint returnedAmount) = abi.decode(result, (address, uint));\n        require(returnedTokenAddress == recipientToken && balanceOf(recipientToken).safeSub(balanceBeforeTrade) == returnedAmount, errorToString(Errors.INVALID_RETURN_DATA));\n\n        return returnedAmount;\n    }\n\n    /**\n     * @dev verify sign data\n     */\n     function verifySignData(bytes memory data, bytes memory signData) internal returns(address){\n        bytes32 hash = keccak256(data);\n        require(!isSigDataUsed(hash), errorToString(Errors.ALREADY_USED));\n        address verifier = sigToAddress(signData, hash);\n       // mark data hash of sig as used\n        sigDataUsed[hash] = true;\n\n        return verifier;\n     }\n\n    /**\n      * @dev migrate balance from previous vault\n      * Note: uncomment for next version\n      */\n    function migrateBalance(address owner, address token) internal {\n        if (address(prevVault) != address(0x0) && !migration[owner][token]) {\n            withdrawRequests[owner][token] = withdrawRequests[owner][token].safeAdd(prevVault.getDepositedBalance(token, owner));\n  \t        migration[owner][token] = true;\n  \t   }\n    }\n\n    /**\n     * @dev Get the amount of specific coin for specific wallet\n     */\n    function getDepositedBalance(\n        address token,\n        address owner\n    ) public view returns (uint) {\n        if (address(prevVault) != address(0x0) && !migration[owner][token]) {\n \t        return withdrawRequests[owner][token].safeAdd(prevVault.getDepositedBalance(token, owner));\n \t    }\n        return withdrawRequests[owner][token];\n    }\n\n    /**\n     * @dev Move total number of assets to newVault\n     * @notice This only works when the preVault is Paused\n     * @notice This can only be called by preVault\n     * @param assets: address of the ERC20 tokens to move, 0x0 for ETH\n     * @param amounts: total number of the ERC20 tokens to move, 0x0 for ETH\n     */\n    function updateAssets(address[] calldata assets, uint[] calldata amounts) external onlyPreVault returns(bool) {\n        require(assets.length == amounts.length,  errorToString(Errors.NOT_EQUAL));\n        require(Withdrawable(prevVault).paused(), errorToString(Errors.PREVAULT_NOT_PAUSED));\n        for (uint i = 0; i < assets.length; i++) {\n            totalDepositedToSCAmount[assets[i]] = totalDepositedToSCAmount[assets[i]].safeAdd(amounts[i]);\n        }\n        emit UpdateTokenTotal(assets, amounts);\n\n        return true;\n    }\n\n    /**\n     * @dev Payable receive function to receive Ether from oldVault when migrating\n     */\n    receive() external payable {}\n\n    /**\n     * @dev Check if transfer() and transferFrom() of ERC20 succeeded or not\n     * This check is needed to fix https://github.com/ethereum/solidity/issues/4116\n     * This function is copied from https://github.com/AdExNetwork/adex-protocol-eth/blob/master/contracts/libs/SafeERC20.sol\n     */\n    function checkSuccess() private pure returns (bool) {\n\t\tuint256 returnValue = 0;\n\t\tassembly {\n\t\t\t// check number of bytes returned from last function call\n\t\t\tswitch returndatasize()\n\n\t\t\t// no bytes returned: assume success\n\t\t\tcase 0x0 {\n\t\t\t\treturnValue := 1\n\t\t\t}\n\n\t\t\t// 32 bytes returned: check if non-zero\n\t\t\tcase 0x20 {\n\t\t\t\t// copy 32 bytes into scratch space\n\t\t\t\treturndatacopy(0x0, 0x0, 0x20)\n\n\t\t\t\t// load those bytes into returnValue\n\t\t\t\treturnValue := mload(0x0)\n\t\t\t}\n\n\t\t\t// not sure what was returned: don't mark as success\n\t\t\tdefault { }\n\t\t}\n\t\treturn returnValue != 0;\n\t}\n\n    /**\n     * @dev convert enum to string value\n     */\n     function errorToString(Errors error) internal pure returns(string memory) {\n        uint8 erroNum = uint8(error);\n        uint maxlength = 10;\n        bytes memory reversed = new bytes(maxlength);\n        uint i = 0;\n        while (erroNum != 0) {\n            uint8 remainder = erroNum % 10;\n            erroNum = erroNum / 10;\n            reversed[i++] = byte(48 + remainder);\n        }\n        bytes memory s = new bytes(i + 1);\n        for (uint j = 0; j <= i; j++) {\n            s[j] = reversed[i - j];\n        }\n        return string(s);\n    }\n\n    /**\n     * @dev Get the decimals of an ERC20 token, return 0 if it isn't defined\n     * We check the returndatasize to covert both cases that the token has\n     * and doesn't have the function decimals()\n     */\n    function getDecimals(address token) public view returns (uint8) {\n        IERC20 erc20 = IERC20(token);\n        return uint8(erc20.decimals());\n    }\n\n    /**\n     * @dev Get the amount of coin deposited to this smartcontract\n     */\n    function balanceOf(address token) public view returns (uint) {\n        if (token == ETH_TOKEN) {\n            return address(this).balance;\n        }\n        return IERC20(token).balanceOf(address(this));\n    }\n}",
        "function": "sigToAddress(bytes,bytes32)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinspect-Incognito Audit/bridge-eth-4879219669a38d601265582f815596b6775855b6/bridge/contracts/vault.sol",
        "vulnerability": "Exception State (SWC 110)",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract Vault {\n    using SafeMath for uint;\n    /**\n     * @dev Storage slot with the incognito proxy.\n     * This is the keccak-256 hash of \"eip1967.proxy.incognito.\" subtracted by 1\n     */\n    bytes32 private constant _INCOGNITO_SLOT = 0x62135fc083646fdb4e1a9d700e351b886a4a5a39da980650269edd1ade91ffd2;\n    address constant public ETH_TOKEN = 0x0000000000000000000000000000000000000000;\n    mapping(bytes32 => bool) public withdrawed;\n    mapping(bytes32 => bool) public sigDataUsed;\n    // address => token => amount\n    mapping(address => mapping(address => uint)) public withdrawRequests;\n    mapping(address => mapping(address => bool)) public migration;\n    mapping(address => uint) public totalDepositedToSCAmount;\n    Withdrawable public prevVault;\n    bool public notEntered = true;\n    bool public isInitialized = false;\n\n    struct BurnInstData {\n        uint8 meta; // type of the instruction\n        uint8 shard; // ID of the Incognito shard containing the instruction, must be 1\n        address token; // ETH address of the token contract (0x0 for ETH)\n        address payable to; // ETH address of the receiver of the token\n        uint amount; // burned amount (on Incognito)\n        bytes32 itx; // Incognito's burning tx\n    }\n\n    // error code\n    enum Errors {\n        EMPTY,\n        NO_REENTRANCE,\n        MAX_UINT_REACHED,\n        VALUE_OVER_FLOW,\n        INTERNAL_TX_ERROR,\n        ALREADY_USED,\n        INVALID_DATA,\n        TOKEN_NOT_ENOUGH,\n        WITHDRAW_REQUEST_TOKEN_NOT_ENOUGH,\n        INVALID_RETURN_DATA,\n        NOT_EQUAL,\n        NULL_VALUE,\n        ONLY_PREVAULT,\n        PREVAULT_NOT_PAUSED\n    }\n\n    event Deposit(address token, string incognitoAddress, uint amount);\n    event Withdraw(address token, address to, uint amount);\n    event UpdateTokenTotal(address[] assets, uint[] amounts);\n    event UpdateIncognitoProxy(address newIncognitoProxy);\n\n    /**\n     * modifier for contract version\n     */\n     modifier onlyPreVault(){\n        require(address(prevVault) != address(0x0) && msg.sender == address(prevVault), errorToString(Errors.ONLY_PREVAULT));\n        _;\n     }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, notEntered will be true\n        require(notEntered, errorToString(Errors.NO_REENTRANCE));\n\n        // Any calls to nonReentrant after this point will fail\n        notEntered = false;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        notEntered = true;\n    }\n\n    /**\n     * @dev Creates new Vault to hold assets for Incognito Chain\n     * @param _prevVault: previous version of the Vault to refer back if necessary\n     * After migrating all assets to a new Vault, we still need to refer\n     * back to previous Vault to make sure old withdrawals aren't being reused\n     */\n    function initialize(address _prevVault) external {\n        require(!isInitialized);\n        prevVault = Withdrawable(_prevVault);\n        isInitialized = true;\n        notEntered = true;\n    }\n\n    /**\n     * @dev Returns the current incognito proxy.\n     */\n    function _incognito() internal view returns (address icg) {\n        bytes32 slot = _INCOGNITO_SLOT;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            icg := sload(slot)\n        }\n    }\n\n    /**\n     * @dev Makes a ETH deposit to the vault to mint pETH over at Incognito Chain\n     * @notice This only works when the contract is not Paused\n     * @notice The maximum amount to deposit is capped since Incognito balance is stored as uint64\n     * @param incognitoAddress: Incognito Address to receive pETH\n     */\n    function deposit(string calldata incognitoAddress) external payable nonReentrant {\n        require(address(this).balance <= 10 ** 27, errorToString(Errors.MAX_UINT_REACHED));\n        emit Deposit(ETH_TOKEN, incognitoAddress, msg.value);\n    }\n\n    /**\n     * @dev Makes a ERC20 deposit to the vault to mint pERC20 over at Incognito Chain\n     * @notice This only works when the contract is not Paused\n     * @notice The maximum amount to deposit is capped since Incognito balance is stored as uint64\n     * @notice Before calling this function, enough ERC20 must be allowed to\n     * tranfer from msg.sender to this contract\n     * @param token: address of the ERC20 token\n     * @param amount: to deposit to the vault and mint on Incognito Chain\n     * @param incognitoAddress: Incognito Address to receive pERC20\n     */\n    function depositERC20(address token, uint amount, string calldata incognitoAddress) external payable nonReentrant {\n        IERC20 erc20Interface = IERC20(token);\n        uint8 decimals = getDecimals(address(token));\n        uint tokenBalance = erc20Interface.balanceOf(address(this));\n        uint beforeTransfer = tokenBalance;\n        uint emitAmount = amount;\n        if (decimals > 9) {\n            emitAmount = emitAmount / (10 ** (uint(decimals) - 9));\n            tokenBalance = tokenBalance / (10 ** (uint(decimals) - 9));\n        }\n        require(emitAmount <= 10 ** 18 && tokenBalance <= 10 ** 18 && emitAmount.safeAdd(tokenBalance) <= 10 ** 18, errorToString(Errors.VALUE_OVER_FLOW));\n        erc20Interface.transferFrom(msg.sender, address(this), amount);\n        require(checkSuccess(), errorToString(Errors.INTERNAL_TX_ERROR));\n        require(balanceOf(token).safeSub(beforeTransfer) == amount, errorToString(Errors.NOT_EQUAL));\n\n        emit Deposit(token, incognitoAddress, emitAmount);\n    }\n\n    /**\n     * @dev Checks if a burn proof has been used before\n     * @notice First, we check inside the storage of this contract itself. If the\n     * hash has been used before, we return the result. Otherwise, we query\n     * previous vault recursively until the first Vault (prevVault address is 0x0)\n     * @param hash: of the burn proof\n     * @return bool: whether the proof has been used or not\n     */\n    function isWithdrawed(bytes32 hash) public view returns(bool) {\n        if (withdrawed[hash]) {\n            return true;\n        } else if (address(prevVault) == address(0)) {\n            return false;\n        }\n        return prevVault.isWithdrawed(hash);\n    }\n\n    /**\n     * @dev Parses a burn instruction and returns the components\n     * @param inst: the full instruction, containing both metadata and body\n     */\n    function parseBurnInst(bytes memory inst) public pure returns (BurnInstData memory) {\n        BurnInstData memory data;\n        data.meta = uint8(inst[0]);\n        data.shard = uint8(inst[1]);\n        address token;\n        address payable to;\n        uint amount;\n        bytes32 itx;\n        assembly {\n            // skip first 0x20 bytes (stored length of inst)\n            token := mload(add(inst, 0x22)) // [3:34]\n            to := mload(add(inst, 0x42)) // [34:66]\n            amount := mload(add(inst, 0x62)) // [66:98]\n            itx := mload(add(inst, 0x82)) // [98:130]\n        }\n        data.token = token;\n        data.to = to;\n        data.amount = amount;\n        data.itx = itx;\n        return data;\n    }\n\n    /**\n     * @dev Verifies that a burn instruction is valid\n     * @notice All params except inst are the list of 2 elements corresponding to\n     * the proof on beacon and bridge\n     * @notice All params are the same as in `withdraw`\n     */\n    function verifyInst(\n        bytes memory inst,\n        uint heights,\n        bytes32[] memory instPaths,\n        bool[] memory instPathIsLefts,\n        bytes32 instRoots,\n        bytes32 blkData,\n        uint[] memory sigIdxs,\n        uint8[] memory sigVs,\n        bytes32[] memory sigRs,\n        bytes32[] memory sigSs\n    ) view internal {\n        // Each instruction can only by redeemed once\n        bytes32 beaconInstHash = keccak256(abi.encodePacked(inst, heights));\n\n        // Verify instruction on beacon\n        require(Incognito(_incognito()).instructionApproved(\n            true, // Only check instruction on beacon\n            beaconInstHash,\n            heights,\n            instPaths,\n            instPathIsLefts,\n            instRoots,\n            blkData,\n            sigIdxs,\n            sigVs,\n            sigRs,\n            sigSs\n        ), errorToString(Errors.INVALID_DATA));\n    }\n\n    /**\n     * @dev Withdraws pETH/pIERC20 by providing a burn proof over at Incognito Chain\n     * @notice This function takes a burn instruction on Incognito Chain, checks\n     * for its validity and returns the token back to ETH chain\n     * @notice This only works when the contract is not Paused\n     * @param inst: the decoded instruction as a list of bytes\n     * @param heights: the blocks containing the instruction\n     * @param instPaths: merkle path of the instruction\n     * @param instPathIsLefts: whether each node on the path is the left or right child\n     * @param instRoots: root of the merkle tree contains all instructions\n     * @param blkData: merkle has of the block body\n     * @param sigIdxs: indices of the validators who signed this block\n     * @param sigVs: part of the signatures of the validators\n     * @param sigRs: part of the signatures of the validators\n     * @param sigSs: part of the signatures of the validators\n     */\n    function withdraw(\n        bytes memory inst,\n        uint heights,\n        bytes32[] memory instPaths,\n        bool[] memory instPathIsLefts,\n        bytes32 instRoots,\n        bytes32 blkData,\n        uint[] memory sigIdxs,\n        uint8[] memory sigVs,\n        bytes32[] memory sigRs,\n        bytes32[] memory sigSs\n    ) public nonReentrant {\n        require(inst.length >= 130);\n        BurnInstData memory data = parseBurnInst(inst);\n        require(data.meta == 241 && data.shard == 1); // Check instruction type\n\n        // Not withdrawed\n        require(!isWithdrawed(data.itx), errorToString(Errors.ALREADY_USED));\n        withdrawed[data.itx] = true;\n\n        // Check if balance is enough\n        if (data.token == ETH_TOKEN) {\n            require(address(this).balance >= data.amount.safeAdd(totalDepositedToSCAmount[data.token]), errorToString(Errors.TOKEN_NOT_ENOUGH));\n        } else {\n            uint8 decimals = getDecimals(data.token);\n            if (decimals > 9) {\n                data.amount = data.amount * (10 ** (uint(decimals) - 9));\n            }\n            require(IERC20(data.token).balanceOf(address(this)) >= data.amount.safeAdd(totalDepositedToSCAmount[data.token]), errorToString(Errors.TOKEN_NOT_ENOUGH));\n        }\n\n        verifyInst(\n            inst,\n            heights,\n            instPaths,\n            instPathIsLefts,\n            instRoots,\n            blkData,\n            sigIdxs,\n            sigVs,\n            sigRs,\n            sigSs\n        );\n\n        // Send and notify\n        if (data.token == ETH_TOKEN) {\n          (bool success, ) =  data.to.call{value: data.amount}(\"\");\n          require(success, errorToString(Errors.INTERNAL_TX_ERROR));\n        } else {\n            IERC20(data.token).transfer(data.to, data.amount);\n            require(checkSuccess(), errorToString(Errors.INTERNAL_TX_ERROR));\n        }\n        emit Withdraw(data.token, data.to, data.amount);\n    }\n\n    /**\n     * @dev Burnt Proof is submited to store burnt amount of p-token/p-ETH and receiver's address\n     * Receiver then can call withdrawRequest to withdraw these token to he/she incognito address.\n     * @notice This function takes a burn instruction on Incognito Chain, checks\n     * for its validity and returns the token back to ETH chain\n     * @notice This only works when the contract is not Paused\n     * @param inst: the decoded instruction as a list of bytes\n     * @param heights: the blocks containing the instruction\n     * @param instPaths: merkle path of the instruction\n     * @param instPathIsLefts: whether each node on the path is the left or right child\n     * @param instRoots: root of the merkle tree contains all instructions\n     * @param blkData: merkle has of the block body\n     * @param sigIdxs: indices of the validators who signed this block\n     * @param sigVs: part of the signatures of the validators\n     * @param sigRs: part of the signatures of the validators\n     * @param sigSs: part of the signatures of the validators\n     */\n    function submitBurnProof(\n        bytes memory inst,\n        uint heights,\n        bytes32[] memory instPaths,\n        bool[] memory instPathIsLefts,\n        bytes32 instRoots,\n        bytes32 blkData,\n        uint[] memory sigIdxs,\n        uint8[] memory sigVs,\n        bytes32[] memory sigRs,\n        bytes32[] memory sigSs\n    ) public nonReentrant {\n        require(inst.length >= 130);\n        BurnInstData memory data = parseBurnInst(inst);\n        require(data.meta == 243 && data.shard == 1); // Check instruction type\n\n        // Not withdrawed\n        require(!isWithdrawed(data.itx), errorToString(Errors.ALREADY_USED));\n        withdrawed[data.itx] = true;\n\n        // Check if balance is enough\n        if (data.token == ETH_TOKEN) {\n            require(address(this).balance >= data.amount.safeAdd(totalDepositedToSCAmount[data.token]), errorToString(Errors.TOKEN_NOT_ENOUGH));\n        } else {\n            uint8 decimals = getDecimals(data.token);\n            if (decimals > 9) {\n                // SWC-101-Integer Overflow and Underflow: L409\n                data.amount = data.amount * (10 ** (uint(decimals) - 9));\n            }\n            require(IERC20(data.token).balanceOf(address(this)) >= data.amount.safeAdd(totalDepositedToSCAmount[data.token]), errorToString(Errors.TOKEN_NOT_ENOUGH));\n        }\n\n        verifyInst(\n            inst,\n            heights,\n            instPaths,\n            instPathIsLefts,\n            instRoots,\n            blkData,\n            sigIdxs,\n            sigVs,\n            sigRs,\n            sigSs\n        );\n\n        withdrawRequests[data.to][data.token] = withdrawRequests[data.to][data.token].safeAdd(data.amount);\n        totalDepositedToSCAmount[data.token] = totalDepositedToSCAmount[data.token].safeAdd(data.amount);\n    }\n\n    /**\n     * @dev generate address from signature data and hash.\n     */\n    function sigToAddress(bytes memory signData, bytes32 hash) public pure returns (address) {\n        bytes32 s;\n        bytes32 r;\n        uint8 v;\n        assembly {\n            r := mload(add(signData, 0x20))\n            s := mload(add(signData, 0x40))\n        }\n        v = uint8(signData[64]) + 27;\n        return ecrecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Checks if a sig data has been used before\n     * @notice First, we check inside the storage of this contract itself. If the\n     * hash has been used before, we return the result. Otherwise, we query\n     * previous vault recursively until the first Vault (prevVault address is 0x0)\n     * @param hash: of the sig data\n     * @return bool: whether the sig data has been used or not\n     */\n    function isSigDataUsed(bytes32 hash) public view returns(bool) {\n        if (sigDataUsed[hash]) {\n            return true;\n        } else if (address(prevVault) == address(0)) {\n            return false;\n        }\n        return prevVault.isSigDataUsed(hash);\n    }\n\n    /**\n     * @dev User requests withdraw token contains in withdrawRequests.\n     * Deposit event will be emitted to let incognito recognize and mint new p-tokens for the user.\n     * @param incognitoAddress: incognito's address that will receive minted p-tokens.\n     * @param token: ethereum's token address (eg., ETH, DAI, ...)\n     * @param amount: amount of the token in ethereum's denomination\n     * @param signData: signature of an unique data that is signed by an account which is generated from user's incognito privkey\n     * @param timestamp: unique data generated from client (timestamp for example)\n     */\n    function requestWithdraw(\n        string calldata incognitoAddress,\n        address token,\n        uint amount,\n        bytes calldata signData,\n        bytes calldata timestamp\n    ) external nonReentrant {\n        // verify owner signs data\n        address verifier = verifySignData(abi.encode(incognitoAddress, token, timestamp, amount), signData);\n\n        // migrate from preVault\n        migrateBalance(verifier, token);\n\n        require(withdrawRequests[verifier][token] >= amount, errorToString(Errors.WITHDRAW_REQUEST_TOKEN_NOT_ENOUGH));\n        withdrawRequests[verifier][token] = withdrawRequests[verifier][token].safeSub(amount);\n        totalDepositedToSCAmount[token] = totalDepositedToSCAmount[token].safeSub(amount);\n\n        // convert denomination from ethereum's to incognito's (pcoin)\n        uint emitAmount = amount;\n        if (token != ETH_TOKEN) {\n            uint8 decimals = getDecimals(token);\n            if (decimals > 9) {\n                emitAmount = amount / (10 ** (uint(decimals) - 9));\n            }\n        }\n\n        emit Deposit(token, incognitoAddress, emitAmount);\n    }\n\n    /**\n     * @dev execute is a general function that plays a role as proxy to interact to other smart contracts.\n     * @param token: ethereum's token address (eg., ETH, DAI, ...)\n     * @param amount: amount of the token in ethereum's denomination\n     * @param recipientToken: received token address.\n     * @param exchangeAddress: address of targeting smart contract that actually executes the desired logics like trade, invest, borrow and so on.\n     * @param callData: encoded with signature and params of function from targeting smart contract.\n     * @param timestamp: unique data generated from client (timestamp for example)\n     * @param signData: signature of an unique data that is signed by an account which is generated from user's incognito privkey\n     */\n    //  SWC-114-Transaction Order Dependence: L512 - L547\n    // SWC-105-Unprotected Ether Withdrawal: L513 - 548\n    function execute(\n        address token,\n        uint amount,\n        address recipientToken,\n        address exchangeAddress,\n        bytes calldata callData,\n        bytes calldata timestamp,\n        bytes calldata signData\n    ) external payable nonReentrant {\n        //verify ower signs data from input\n        address verifier = verifySignData(abi.encode(exchangeAddress, callData, timestamp, amount), signData);\n\n        // migrate from preVault\n        migrateBalance(verifier, token);\n        require(withdrawRequests[verifier][token] >= amount, errorToString(Errors.WITHDRAW_REQUEST_TOKEN_NOT_ENOUGH));\n\n        // update balance of verifier\n        totalDepositedToSCAmount[token] = totalDepositedToSCAmount[token].safeSub(amount);\n        withdrawRequests[verifier][token] = withdrawRequests[verifier][token].safeSub(amount);\n\n        // define number of eth spent for forwarder.\n        uint ethAmount = msg.value;\n        if (token == ETH_TOKEN) {\n            ethAmount = ethAmount.safeAdd(amount);\n        } else {\n            // transfer token to exchangeAddress.\n            require(IERC20(token).balanceOf(address(this)) >= amount, errorToString(Errors.TOKEN_NOT_ENOUGH));\n            IERC20(token).transfer(exchangeAddress, amount);\n            require(checkSuccess(), errorToString(Errors.INTERNAL_TX_ERROR));\n        }\n        uint returnedAmount = callExtFunc(recipientToken, ethAmount, callData, exchangeAddress);\n\n        // update withdrawRequests\n        withdrawRequests[verifier][recipientToken] = withdrawRequests[verifier][recipientToken].safeAdd(returnedAmount);\n        totalDepositedToSCAmount[recipientToken] = totalDepositedToSCAmount[recipientToken].safeAdd(returnedAmount);\n    }\n\n    /**\n     * @dev single trade\n     */\n    function callExtFunc(address recipientToken, uint ethAmount, bytes memory callData, address exchangeAddress) internal returns (uint) {\n         // get balance of recipient token before trade to compare after trade.\n        uint balanceBeforeTrade = balanceOf(recipientToken);\n        if (recipientToken == ETH_TOKEN) {\n            balanceBeforeTrade = balanceBeforeTrade.safeSub(msg.value);\n        }\n        require(address(this).balance >= ethAmount, errorToString(Errors.TOKEN_NOT_ENOUGH));\n        (bool success, bytes memory result) = exchangeAddress.call{value: ethAmount}(callData);\n        require(success);\n\n        (address returnedTokenAddress, uint returnedAmount) = abi.decode(result, (address, uint));\n        require(returnedTokenAddress == recipientToken && balanceOf(recipientToken).safeSub(balanceBeforeTrade) == returnedAmount, errorToString(Errors.INVALID_RETURN_DATA));\n\n        return returnedAmount;\n    }\n\n    /**\n     * @dev verify sign data\n     */\n     function verifySignData(bytes memory data, bytes memory signData) internal returns(address){\n        bytes32 hash = keccak256(data);\n        require(!isSigDataUsed(hash), errorToString(Errors.ALREADY_USED));\n        address verifier = sigToAddress(signData, hash);\n       // mark data hash of sig as used\n        sigDataUsed[hash] = true;\n\n        return verifier;\n     }\n\n    /**\n      * @dev migrate balance from previous vault\n      * Note: uncomment for next version\n      */\n    function migrateBalance(address owner, address token) internal {\n        if (address(prevVault) != address(0x0) && !migration[owner][token]) {\n            withdrawRequests[owner][token] = withdrawRequests[owner][token].safeAdd(prevVault.getDepositedBalance(token, owner));\n  \t        migration[owner][token] = true;\n  \t   }\n    }\n\n    /**\n     * @dev Get the amount of specific coin for specific wallet\n     */\n    function getDepositedBalance(\n        address token,\n        address owner\n    ) public view returns (uint) {\n        if (address(prevVault) != address(0x0) && !migration[owner][token]) {\n \t        return withdrawRequests[owner][token].safeAdd(prevVault.getDepositedBalance(token, owner));\n \t    }\n        return withdrawRequests[owner][token];\n    }\n\n    /**\n     * @dev Move total number of assets to newVault\n     * @notice This only works when the preVault is Paused\n     * @notice This can only be called by preVault\n     * @param assets: address of the ERC20 tokens to move, 0x0 for ETH\n     * @param amounts: total number of the ERC20 tokens to move, 0x0 for ETH\n     */\n    function updateAssets(address[] calldata assets, uint[] calldata amounts) external onlyPreVault returns(bool) {\n        require(assets.length == amounts.length,  errorToString(Errors.NOT_EQUAL));\n        require(Withdrawable(prevVault).paused(), errorToString(Errors.PREVAULT_NOT_PAUSED));\n        for (uint i = 0; i < assets.length; i++) {\n            totalDepositedToSCAmount[assets[i]] = totalDepositedToSCAmount[assets[i]].safeAdd(amounts[i]);\n        }\n        emit UpdateTokenTotal(assets, amounts);\n\n        return true;\n    }\n\n    /**\n     * @dev Payable receive function to receive Ether from oldVault when migrating\n     */\n    receive() external payable {}\n\n    /**\n     * @dev Check if transfer() and transferFrom() of ERC20 succeeded or not\n     * This check is needed to fix https://github.com/ethereum/solidity/issues/4116\n     * This function is copied from https://github.com/AdExNetwork/adex-protocol-eth/blob/master/contracts/libs/SafeERC20.sol\n     */\n    function checkSuccess() private pure returns (bool) {\n\t\tuint256 returnValue = 0;\n\t\tassembly {\n\t\t\t// check number of bytes returned from last function call\n\t\t\tswitch returndatasize()\n\n\t\t\t// no bytes returned: assume success\n\t\t\tcase 0x0 {\n\t\t\t\treturnValue := 1\n\t\t\t}\n\n\t\t\t// 32 bytes returned: check if non-zero\n\t\t\tcase 0x20 {\n\t\t\t\t// copy 32 bytes into scratch space\n\t\t\t\treturndatacopy(0x0, 0x0, 0x20)\n\n\t\t\t\t// load those bytes into returnValue\n\t\t\t\treturnValue := mload(0x0)\n\t\t\t}\n\n\t\t\t// not sure what was returned: don't mark as success\n\t\t\tdefault { }\n\t\t}\n\t\treturn returnValue != 0;\n\t}\n\n    /**\n     * @dev convert enum to string value\n     */\n     function errorToString(Errors error) internal pure returns(string memory) {\n        uint8 erroNum = uint8(error);\n        uint maxlength = 10;\n        bytes memory reversed = new bytes(maxlength);\n        uint i = 0;\n        while (erroNum != 0) {\n            uint8 remainder = erroNum % 10;\n            erroNum = erroNum / 10;\n            reversed[i++] = byte(48 + remainder);\n        }\n        bytes memory s = new bytes(i + 1);\n        for (uint j = 0; j <= i; j++) {\n            s[j] = reversed[i - j];\n        }\n        return string(s);\n    }\n\n    /**\n     * @dev Get the decimals of an ERC20 token, return 0 if it isn't defined\n     * We check the returndatasize to covert both cases that the token has\n     * and doesn't have the function decimals()\n     */\n    function getDecimals(address token) public view returns (uint8) {\n        IERC20 erc20 = IERC20(token);\n        return uint8(erc20.decimals());\n    }\n\n    /**\n     * @dev Get the amount of coin deposited to this smartcontract\n     */\n    function balanceOf(address token) public view returns (uint) {\n        if (token == ETH_TOKEN) {\n            return address(this).balance;\n        }\n        return IERC20(token).balanceOf(address(this));\n    }\n}",
        "function": "parseBurnInst(bytes)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinspect-Incognito Audit/bridge-eth-4879219669a38d601265582f815596b6775855b6/bridge/contracts/vault.sol",
        "vulnerability": "Exception State (SWC 110)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract AdminPausable {\n    address public admin;\n    address public successor;\n    bool public paused;\n    uint public expire;\n\n    constructor(address _admin) public {\n        admin = _admin;\n        paused = false;\n        expire = block.timestamp + 365 * 1 days;\n    }\n\n    event Paused(address pauser);\n    event Unpaused(address pauser);\n    event Extend(uint ndays);\n    event Claim(address claimer);\n\n    modifier onlyAdmin() {\n        require(msg.sender == admin, \"not admin\");\n        _;\n    }\n\n    modifier isPaused() {\n        require(paused, \"not paused right now\");\n        _;\n    }\n\n    modifier isNotPaused() {\n        require(!paused, \"paused right now\");\n        _;\n    }\n\n    modifier isNotExpired() {\n        require(block.timestamp < expire, \"expired\");\n        _;\n    }\n\n    function retire(address _successor) public onlyAdmin isNotExpired {\n        successor = _successor;\n    }\n\n    function claim() public isNotExpired {\n        require(msg.sender == successor, \"unauthorized\");\n        admin = successor;\n        emit Claim(admin);\n    }\n\n    function extend(uint n) public onlyAdmin isNotExpired {\n        require(n < 366, \"cannot extend for too long\"); // To prevent overflow\n        expire = expire + n * 1 days;\n        emit Extend(n);\n    }\n\n    function pause() public onlyAdmin isNotPaused isNotExpired {\n        paused = true;\n        emit Paused(msg.sender);\n    }\n\n    function unpause() public onlyAdmin isPaused {\n        paused = false;\n        emit Unpaused(msg.sender);\n    }\n}",
        "function": "constructor",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinspect-Incognito Audit/bridge-eth-4879219669a38d601265582f815596b6775855b6/bridge/contracts/incognito_proxy.sol",
        "vulnerability": "Integer Arithmetic Bugs (SWC 101)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract AdminPausable {\n    address public admin;\n    address public successor;\n    bool public paused;\n    uint public expire;\n\n    constructor(address _admin) public {\n        admin = _admin;\n        paused = false;\n        expire = block.timestamp + 365 * 1 days;\n    }\n\n    event Paused(address pauser);\n    event Unpaused(address pauser);\n    event Extend(uint ndays);\n    event Claim(address claimer);\n\n    modifier onlyAdmin() {\n        require(msg.sender == admin, \"not admin\");\n        _;\n    }\n\n    modifier isPaused() {\n        require(paused, \"not paused right now\");\n        _;\n    }\n\n    modifier isNotPaused() {\n        require(!paused, \"paused right now\");\n        _;\n    }\n\n    modifier isNotExpired() {\n        require(block.timestamp < expire, \"expired\");\n        _;\n    }\n\n    function retire(address _successor) public onlyAdmin isNotExpired {\n        successor = _successor;\n    }\n\n    function claim() public isNotExpired {\n        require(msg.sender == successor, \"unauthorized\");\n        admin = successor;\n        emit Claim(admin);\n    }\n\n    function extend(uint n) public onlyAdmin isNotExpired {\n        require(n < 366, \"cannot extend for too long\"); // To prevent overflow\n        expire = expire + n * 1 days;\n        emit Extend(n);\n    }\n\n    function pause() public onlyAdmin isNotPaused isNotExpired {\n        paused = true;\n        emit Paused(msg.sender);\n    }\n\n    function unpause() public onlyAdmin isPaused {\n        paused = false;\n        emit Unpaused(msg.sender);\n    }\n}",
        "function": "claim()",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinspect-Incognito Audit/bridge-eth-4879219669a38d601265582f815596b6775855b6/bridge/contracts/incognito_proxy.sol",
        "vulnerability": "Dependence on predictable environment variable (SWC 116)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract AdminPausable {\n    address public admin;\n    address public successor;\n    bool public paused;\n    uint public expire;\n\n    constructor(address _admin) public {\n        admin = _admin;\n        paused = false;\n        expire = block.timestamp + 365 * 1 days;\n    }\n\n    event Paused(address pauser);\n    event Unpaused(address pauser);\n    event Extend(uint ndays);\n    event Claim(address claimer);\n\n    modifier onlyAdmin() {\n        require(msg.sender == admin, \"not admin\");\n        _;\n    }\n\n    modifier isPaused() {\n        require(paused, \"not paused right now\");\n        _;\n    }\n\n    modifier isNotPaused() {\n        require(!paused, \"paused right now\");\n        _;\n    }\n\n    modifier isNotExpired() {\n        require(block.timestamp < expire, \"expired\");\n        _;\n    }\n\n    function retire(address _successor) public onlyAdmin isNotExpired {\n        successor = _successor;\n    }\n\n    function claim() public isNotExpired {\n        require(msg.sender == successor, \"unauthorized\");\n        admin = successor;\n        emit Claim(admin);\n    }\n\n    function extend(uint n) public onlyAdmin isNotExpired {\n        require(n < 366, \"cannot extend for too long\"); // To prevent overflow\n        expire = expire + n * 1 days;\n        emit Extend(n);\n    }\n\n    function pause() public onlyAdmin isNotPaused isNotExpired {\n        paused = true;\n        emit Paused(msg.sender);\n    }\n\n    function unpause() public onlyAdmin isPaused {\n        paused = false;\n        emit Unpaused(msg.sender);\n    }\n}",
        "function": "pause()",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinspect-Incognito Audit/bridge-eth-4879219669a38d601265582f815596b6775855b6/bridge/contracts/incognito_proxy.sol",
        "vulnerability": "Dependence on predictable environment variable (SWC 116)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract AdminPausable {\n    address public admin;\n    address public successor;\n    bool public paused;\n    uint public expire;\n\n    constructor(address _admin) public {\n        admin = _admin;\n        paused = false;\n        expire = block.timestamp + 365 * 1 days;\n    }\n\n    event Paused(address pauser);\n    event Unpaused(address pauser);\n    event Extend(uint ndays);\n    event Claim(address claimer);\n\n    modifier onlyAdmin() {\n        require(msg.sender == admin, \"not admin\");\n        _;\n    }\n\n    modifier isPaused() {\n        require(paused, \"not paused right now\");\n        _;\n    }\n\n    modifier isNotPaused() {\n        require(!paused, \"paused right now\");\n        _;\n    }\n\n    modifier isNotExpired() {\n        require(block.timestamp < expire, \"expired\");\n        _;\n    }\n\n    function retire(address _successor) public onlyAdmin isNotExpired {\n        successor = _successor;\n    }\n\n    function claim() public isNotExpired {\n        require(msg.sender == successor, \"unauthorized\");\n        admin = successor;\n        emit Claim(admin);\n    }\n\n    function extend(uint n) public onlyAdmin isNotExpired {\n        require(n < 366, \"cannot extend for too long\"); // To prevent overflow\n        expire = expire + n * 1 days;\n        emit Extend(n);\n    }\n\n    function pause() public onlyAdmin isNotPaused isNotExpired {\n        paused = true;\n        emit Paused(msg.sender);\n    }\n\n    function unpause() public onlyAdmin isPaused {\n        paused = false;\n        emit Unpaused(msg.sender);\n    }\n}",
        "function": "extend(uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinspect-Incognito Audit/bridge-eth-4879219669a38d601265582f815596b6775855b6/bridge/contracts/incognito_proxy.sol",
        "vulnerability": "Dependence on predictable environment variable (SWC 116)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract AdminPausable {\n    address public admin;\n    address public successor;\n    bool public paused;\n    uint public expire;\n\n    constructor(address _admin) public {\n        admin = _admin;\n        paused = false;\n        expire = block.timestamp + 365 * 1 days;\n    }\n\n    event Paused(address pauser);\n    event Unpaused(address pauser);\n    event Extend(uint ndays);\n    event Claim(address claimer);\n\n    modifier onlyAdmin() {\n        require(msg.sender == admin, \"not admin\");\n        _;\n    }\n\n    modifier isPaused() {\n        require(paused, \"not paused right now\");\n        _;\n    }\n\n    modifier isNotPaused() {\n        require(!paused, \"paused right now\");\n        _;\n    }\n\n    modifier isNotExpired() {\n        require(block.timestamp < expire, \"expired\");\n        _;\n    }\n\n    function retire(address _successor) public onlyAdmin isNotExpired {\n        successor = _successor;\n    }\n\n    function claim() public isNotExpired {\n        require(msg.sender == successor, \"unauthorized\");\n        admin = successor;\n        emit Claim(admin);\n    }\n\n    function extend(uint n) public onlyAdmin isNotExpired {\n        require(n < 366, \"cannot extend for too long\"); // To prevent overflow\n        expire = expire + n * 1 days;\n        emit Extend(n);\n    }\n\n    function pause() public onlyAdmin isNotPaused isNotExpired {\n        paused = true;\n        emit Paused(msg.sender);\n    }\n\n    function unpause() public onlyAdmin isPaused {\n        paused = false;\n        emit Unpaused(msg.sender);\n    }\n}",
        "function": "extend(uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinspect-Incognito Audit/bridge-eth-4879219669a38d601265582f815596b6775855b6/bridge/contracts/incognito_proxy.sol",
        "vulnerability": "Integer Arithmetic Bugs (SWC 101)",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract AdminPausable {\n    address public admin;\n    address public successor;\n    bool public paused;\n    uint public expire;\n\n    constructor(address _admin) public {\n        admin = _admin;\n        paused = false;\n        expire = block.timestamp + 365 * 1 days;\n    }\n\n    event Paused(address pauser);\n    event Unpaused(address pauser);\n    event Extend(uint ndays);\n    event Claim(address claimer);\n\n    modifier onlyAdmin() {\n        require(msg.sender == admin, \"not admin\");\n        _;\n    }\n\n    modifier isPaused() {\n        require(paused, \"not paused right now\");\n        _;\n    }\n\n    modifier isNotPaused() {\n        require(!paused, \"paused right now\");\n        _;\n    }\n\n    modifier isNotExpired() {\n        require(block.timestamp < expire, \"expired\");\n        _;\n    }\n\n    function retire(address _successor) public onlyAdmin isNotExpired {\n        successor = _successor;\n    }\n\n    function claim() public isNotExpired {\n        require(msg.sender == successor, \"unauthorized\");\n        admin = successor;\n        emit Claim(admin);\n    }\n\n    function extend(uint n) public onlyAdmin isNotExpired {\n        require(n < 366, \"cannot extend for too long\"); // To prevent overflow\n        expire = expire + n * 1 days;\n        emit Extend(n);\n    }\n\n    function pause() public onlyAdmin isNotPaused isNotExpired {\n        paused = true;\n        emit Paused(msg.sender);\n    }\n\n    function unpause() public onlyAdmin isPaused {\n        paused = false;\n        emit Unpaused(msg.sender);\n    }\n}",
        "function": "retire(address)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinspect-Incognito Audit/bridge-eth-4879219669a38d601265582f815596b6775855b6/bridge/contracts/incognito_proxy.sol",
        "vulnerability": "Dependence on predictable environment variable (SWC 116)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract BorrowerOperations is LiquityBase, Ownable, IBorrowerOperations {\n\n    // --- Connected contract declarations ---\n\n    ITroveManager public troveManager;\n\n    IPool public activePool;\n\n    IPool public defaultPool;\n\n    address stabilityPoolAddress;\n\n    ICollSurplusPool collSurplusPool;\n\n    IPriceFeed public priceFeed;\n\n    ILQTYStaking public lqtyStaking;\n    address public lqtyStakingAddress;\n\n    ILUSDToken public lusdToken;\n\n    // A doubly linked list of Troves, sorted by their sorted by their collateral ratios\n    ISortedTroves public sortedTroves;\n\n    /* --- Variable container structs  ---\n\n    Used to hold, return and assign variables inside a function, in order to avoid the error:\n    \"CompilerError: Stack too deep\". */\n\n     struct LocalVariables_adjustTrove {\n        uint price;\n        uint collChange;\n        uint rawDebtChange;\n        bool isCollIncrease;\n        uint debt;\n        uint coll;\n        uint newICR;\n        uint LUSDFee;\n        uint newDebt;\n        uint newColl;\n        uint stake;\n    }\n\n    enum BorrowerOperation {\n        openTrove,\n        closeTrove,\n        addColl,\n        withdrawColl,\n        withdrawLUSD,\n        repayLUSD,\n        adjustTrove\n    }\n\n    event TroveCreated(address indexed _borrower, uint arrayIndex);\n    event TroveUpdated(address indexed _borrower, uint _debt, uint _coll, uint stake, BorrowerOperation operation);\n    event LUSDBorrowingFeePaid(address indexed _borrower, uint _LUSDFee);\n\n    // --- Dependency setters ---\n\n    function setAddresses(\n        address _troveManagerAddress,\n        address _activePoolAddress,\n        address _defaultPoolAddress,\n        address _stabilityPoolAddress,\n        address _collSurplusPoolAddress,\n        address _priceFeedAddress,\n        address _sortedTrovesAddress,\n        address _lusdTokenAddress,\n        address _lqtyStakingAddress\n    )\n        external\n        override\n        onlyOwner\n    {\n        troveManager = ITroveManager(_troveManagerAddress);\n        activePool = IPool(_activePoolAddress);\n        defaultPool = IPool(_defaultPoolAddress);\n        stabilityPoolAddress = _stabilityPoolAddress;\n        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);\n        priceFeed = IPriceFeed(_priceFeedAddress);\n        sortedTroves = ISortedTroves(_sortedTrovesAddress);\n        lusdToken = ILUSDToken(_lusdTokenAddress);\n        lqtyStakingAddress = _lqtyStakingAddress;\n        lqtyStaking = ILQTYStaking(_lqtyStakingAddress);\n\n        emit TroveManagerAddressChanged(_troveManagerAddress);\n        emit ActivePoolAddressChanged(_activePoolAddress);\n        emit DefaultPoolAddressChanged(_defaultPoolAddress);\n        emit StabilityPoolAddressChanged(_stabilityPoolAddress);\n        emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);\n        emit LUSDTokenAddressChanged(_lusdTokenAddress);\n        emit PriceFeedAddressChanged(_priceFeedAddress);\n        emit SortedTrovesAddressChanged(_sortedTrovesAddress);\n        emit LUSDTokenAddressChanged(_lusdTokenAddress);\n        emit LQTYStakingAddressChanged(_lqtyStakingAddress);\n\n        _renounceOwnership();\n    }\n\n    // --- Borrower Trove Operations ---\n\n    function openTrove(uint _LUSDAmount, address _hint) external payable override {\n        uint price = priceFeed.getPrice();\n\n        _requireTroveisNotActive(msg.sender);\n\n        // Decay the base rate, and calculate the borrowing fee\n        troveManager.decayBaseRateFromBorrowing();\n        uint LUSDFee = troveManager.getBorrowingFee(_LUSDAmount);\n        uint rawDebt = _LUSDAmount.add(LUSDFee);\n\n        // ICR is based on the composite debt, i.e. the requested LUSD amount + LUSD borrowing fee + LUSD gas comp.\n        uint compositeDebt = _getCompositeDebt(rawDebt);\n        assert(compositeDebt > 0);\n        uint ICR = LiquityMath._computeCR(msg.value, compositeDebt, price);\n\n        if (_checkRecoveryMode()) {\n            _requireICRisAboveR_MCR(ICR);\n        } else {\n            _requireICRisAboveMCR(ICR);\n            _requireNewTCRisAboveCCR(msg.value, true, compositeDebt, true, price);  // bools: coll increase, debt increase\n        }\n\n        // Set the trove struct's properties\n        troveManager.setTroveStatus(msg.sender, 1);\n        troveManager.increaseTroveColl(msg.sender, msg.value);\n        troveManager.increaseTroveDebt(msg.sender, compositeDebt);\n\n        troveManager.updateTroveRewardSnapshots(msg.sender);\n        uint stake = troveManager.updateStakeAndTotalStakes(msg.sender);\n\n        sortedTroves.insert(msg.sender, ICR, price, _hint, _hint);\n        uint arrayIndex = troveManager.addTroveOwnerToArray(msg.sender);\n        emit TroveCreated(msg.sender, arrayIndex);\n\n        // Send the LUSD borrowing fee to the staking contract\n        lusdToken.mint(lqtyStakingAddress, LUSDFee);\n        lqtyStaking.increaseF_LUSD(LUSDFee);\n\n        // Move the ether to the Active Pool, and mint the LUSDAmount to the borrower\n        _activePoolAddColl(msg.value);\n        _withdrawLUSD(msg.sender, _LUSDAmount, rawDebt);\n        // Move the LUSD gas compensation to the Gas Pool\n        _withdrawLUSD(GAS_POOL_ADDRESS, LUSD_GAS_COMPENSATION, LUSD_GAS_COMPENSATION);\n\n        emit TroveUpdated(msg.sender, rawDebt, msg.value, stake, BorrowerOperation.openTrove);\n        emit LUSDBorrowingFeePaid(msg.sender, LUSDFee);\n    }\n\n    // Send ETH as collateral to a trove\n    function addColl(address _hint) external payable override {\n        _adjustTrove(msg.sender, 0, 0, false, _hint);\n    }\n\n    // Send ETH as collateral to a trove. Called by only the Stability Pool.\n    function moveETHGainToTrove(address _borrower, address _hint) external payable override {\n        _requireCallerIsStabilityPool();\n        _adjustTrove(_borrower, 0, 0, false, _hint);\n    }\n\n    // Withdraw ETH collateral from a trove\n    function withdrawColl(uint _collWithdrawal, address _hint) external override {\n        _adjustTrove(msg.sender, _collWithdrawal, 0, false, _hint);\n    }\n\n    // Withdraw LUSD tokens from a trove: mint new LUSD tokens to the owner, and increase the trove's debt accordingly\n    function withdrawLUSD(uint _LUSDAmount, address _hint) external override {\n        _adjustTrove(msg.sender, 0, _LUSDAmount, true, _hint);\n    }\n\n    // Repay LUSD tokens to a Trove: Burn the repaid LUSD tokens, and reduce the trove's debt accordingly\n    function repayLUSD(uint _LUSDAmount, address _hint) external override {\n        _adjustTrove(msg.sender, 0, _LUSDAmount, false, _hint);\n    }\n\n    /*\n    * If ETH is sent, the operation is considered as a collateral increase, and the first parameter\n    * _collWithdrawal must be zero\n    */\n    function adjustTrove(uint _collWithdrawal, uint _debtChange, bool _isDebtIncrease, address _hint) external payable override {\n        _adjustTrove(msg.sender, _collWithdrawal, _debtChange, _isDebtIncrease, _hint);\n    }\n\n    function _adjustTrove(address _borrower, uint _collWithdrawal, uint _debtChange, bool _isDebtIncrease, address _hint) internal {\n        require(msg.value == 0 || _collWithdrawal == 0, \"BorrowerOperations: Cannot withdraw and add coll\");\n        // The operation \"isWithdrawal\" if it removes collateral or LUSD, i.e. it removes funds and lowers the ICR\n        bool isWithdrawal = _collWithdrawal != 0 || _isDebtIncrease;\n        require(msg.sender == _borrower || !isWithdrawal, \"BorrowerOps: User must be sender for withdrawals\");\n        require(msg.value != 0 || _collWithdrawal != 0 || _debtChange != 0, \"BorrowerOps: There must be either a collateral change or a debt change\");\n\n        LocalVariables_adjustTrove memory L;\n\n        _requireTroveisActive(_borrower);\n        if (isWithdrawal) {_requireNotInRecoveryMode();}\n\n        L.price = priceFeed.getPrice();\n\n        troveManager.applyPendingRewards(_borrower);\n\n        (L.collChange, L.isCollIncrease) = _getCollChange(msg.value, _collWithdrawal);\n\n        L.rawDebtChange = _debtChange;\n        if (_isDebtIncrease && _debtChange > 0) {\n            // Decay the baseRate and get the fee\n            troveManager.decayBaseRateFromBorrowing();\n            L.LUSDFee = troveManager.getBorrowingFee(_debtChange);\n\n            // The raw debt change includes the fee, if there was one\n            L.rawDebtChange = L.rawDebtChange.add(L.LUSDFee);\n\n            // Send fee to LQTY staking contract\n            lqtyStaking.increaseF_LUSD(L.LUSDFee);\n            lusdToken.mint(lqtyStakingAddress, L.LUSDFee);\n        }\n\n        L.debt = troveManager.getTroveDebt(_borrower);\n        L.coll = troveManager.getTroveColl(_borrower);\n\n        L.newICR = _getNewICRFromTroveChange(L.coll, L.debt, L.collChange, L.isCollIncrease, L.rawDebtChange, _isDebtIncrease, L.price);\n\n        if (isWithdrawal) {_requireICRisAboveMCR(L.newICR);}\n        if (_isDebtIncrease && _debtChange > 0) {\n            _requireNewTCRisAboveCCR(L.collChange, L.isCollIncrease, L.rawDebtChange, _isDebtIncrease, L.price);\n        }\n        if (!L.isCollIncrease) {_requireCollAmountIsWithdrawable(L.coll, L.collChange);}\n        if (!_isDebtIncrease && _debtChange > 0) {_requireLUSDRepaymentAllowed(L.debt, L.rawDebtChange);}\n\n        (L.newColl, L.newDebt) = _updateTroveFromAdjustment(_borrower, L.collChange, L.isCollIncrease, L.rawDebtChange, _isDebtIncrease);\n        L.stake = troveManager.updateStakeAndTotalStakes(_borrower);\n\n        // Re-insert trove it in the sorted list\n        sortedTroves.reInsert(_borrower, L.newICR, L.price, _hint, _hint);\n\n        // Pass unmodified _debtChange here, as we don't send the fee to the user\n        _moveTokensAndETHfromAdjustment(msg.sender, L.collChange, L.isCollIncrease, _debtChange, _isDebtIncrease, L.rawDebtChange);\n\n        emit TroveUpdated(_borrower, L.newDebt, L.newColl, L.stake, BorrowerOperation.adjustTrove);\n        emit LUSDBorrowingFeePaid(msg.sender,  L.LUSDFee);\n    }\n\n    function closeTrove() external override {\n        _requireTroveisActive(msg.sender);\n        _requireNotInRecoveryMode();\n\n        troveManager.applyPendingRewards(msg.sender);\n\n        uint coll = troveManager.getTroveColl(msg.sender);\n        uint debt = troveManager.getTroveDebt(msg.sender);\n\n        troveManager.removeStake(msg.sender);\n        troveManager.closeTrove(msg.sender);\n\n        // Burn the debt from the user's balance, and send the collateral back to the user\n        _repayLUSD(msg.sender, debt.sub(LUSD_GAS_COMPENSATION));\n        activePool.sendETH(msg.sender, coll);\n        // Refund gas compensation\n        _repayLUSD(GAS_POOL_ADDRESS, LUSD_GAS_COMPENSATION);\n\n        emit TroveUpdated(msg.sender, 0, 0, 0, BorrowerOperation.closeTrove);\n    }\n\n    function claimRedeemedCollateral(address _user) external override {\n        // send ETH from CollSurplus Pool to owner\n        collSurplusPool.claimColl(_user);\n\n        emit RedeemedCollateralClaimed(_user);\n    }\n\n    // --- Helper functions ---\n\n    function _getUSDValue(uint _coll, uint _price) internal pure returns (uint) {\n        uint usdValue = _price.mul(_coll).div(1e18);\n\n        return usdValue;\n    }\n\n    function _getCollChange(\n        uint _collReceived,\n        uint _requestedCollWithdrawal\n    )\n        internal\n        pure\n        returns(uint collChange, bool isCollIncrease)\n    {\n        if (_collReceived != 0) {\n            collChange = _collReceived;\n            isCollIncrease = true;\n        } else {\n            collChange = _requestedCollWithdrawal;\n        }\n    }\n\n    // Update trove's coll and debt based on whether they increase or decrease\n    function _updateTroveFromAdjustment\n    (\n        address _borrower,\n        uint _collChange,\n        bool _isCollIncrease,\n        uint _debtChange,\n        bool _isDebtIncrease\n    )\n        internal\n        returns (uint, uint)\n    {\n        uint newColl = (_isCollIncrease) ? troveManager.increaseTroveColl(_borrower, _collChange)\n                                        : troveManager.decreaseTroveColl(_borrower, _collChange);\n        uint newDebt = (_isDebtIncrease) ? troveManager.increaseTroveDebt(_borrower, _debtChange)\n                                        : troveManager.decreaseTroveDebt(_borrower, _debtChange);\n\n        return (newColl, newDebt);\n    }\n\n    function _moveTokensAndETHfromAdjustment\n    (\n        address _borrower,\n        uint _collChange,\n        bool _isCollIncrease,\n        uint _debtChange,\n        bool _isDebtIncrease,\n        uint _rawDebtChange\n    )\n        internal\n    {\n        if (_isDebtIncrease) {\n            _withdrawLUSD(_borrower, _debtChange, _rawDebtChange);\n        } else {\n            _repayLUSD(_borrower, _debtChange);\n        }\n\n        if (_isCollIncrease) {\n            _activePoolAddColl(_collChange);\n        } else {\n            // SWC-107-Reentrancy: L351\n            activePool.sendETH(_borrower, _collChange);\n        }\n    }\n\n    // Send ETH to Active Pool and increase its recorded ETH balance\n    function _activePoolAddColl(uint _amount) internal {\n        (bool success, ) = address(activePool).call{value: _amount}(\"\");\n        assert(success == true);\n    }\n\n    // Issue the specified amount of LUSD to _account and increases the total active debt (_rawDebtIncrease potentially includes a LUSDFee)\n    function _withdrawLUSD(address _account, uint _LUSDAmount, uint _rawDebtIncrease) internal {\n        activePool.increaseLUSDDebt(_rawDebtIncrease);\n        lusdToken.mint(_account, _LUSDAmount);\n    }\n\n    // Burn the specified amount of LUSD from _account and decreases the total active debt\n    function _repayLUSD(address _account, uint _LUSD) internal {\n        activePool.decreaseLUSDDebt(_LUSD);\n        lusdToken.burn(_account, _LUSD);\n    }\n\n    // --- 'Require' wrapper functions ---\n\n    function _requireTroveisActive(address _borrower) internal view {\n        uint status = troveManager.getTroveStatus(_borrower);\n        require(status == 1, \"BorrowerOps: Trove does not exist or is closed\");\n    }\n\n    function _requireTroveisNotActive(address _borrower) internal view {\n        uint status = troveManager.getTroveStatus(_borrower);\n        require(status != 1, \"BorrowerOps: Trove is active\");\n    }\n\n    function _requireNotInRecoveryMode() internal view {\n        require(_checkRecoveryMode() == false, \"BorrowerOps: Operation not permitted during Recovery Mode\");\n    }\n\n    function _requireICRisAboveMCR(uint _newICR)  internal pure {\n        require(_newICR >= MCR, \"BorrowerOps: An operation that would result in ICR < MCR is not permitted\");\n    }\n\n    function _requireICRisAboveR_MCR(uint _newICR) internal pure {\n        require(_newICR >= R_MCR, \"BorrowerOps: In Recovery Mode new troves must have ICR >= R_MCR\");\n    }\n\n    function _requireNewTCRisAboveCCR\n    (\n        uint _collChange,\n        bool _isCollIncrease,\n        uint _debtChange,\n        bool _isDebtIncrease,\n        uint _price\n    )\n        internal\n        view\n    {\n        uint newTCR = _getNewTCRFromTroveChange(_collChange, _isCollIncrease, _debtChange, _isDebtIncrease, _price);\n        require(newTCR >= CCR, \"BorrowerOps: An operation that would result in TCR < CCR is not permitted\");\n    }\n\n    function _requireLUSDRepaymentAllowed(uint _currentDebt, uint _debtRepayment) internal pure {\n        require(_debtRepayment <= _currentDebt.sub(LUSD_GAS_COMPENSATION), \"BorrowerOps: Amount repaid must not be larger than the Trove's debt\");\n    }\n\n    function _requireCollAmountIsWithdrawable(uint _currentColl, uint _collWithdrawal)\n        internal\n        pure\n    {\n        require(_collWithdrawal <= _currentColl, \"BorrowerOps: Insufficient balance for ETH withdrawal\");\n    }\n\n    function _requireCallerIsStabilityPool() internal view {\n        require(msg.sender == stabilityPoolAddress, \"BorrowerOps: Caller is not Stability Pool\");\n    }\n\n    // --- ICR and TCR checks ---\n\n    // Compute the new collateral ratio, considering the change in coll and debt. Assumes 0 pending rewards.\n    function _getNewICRFromTroveChange\n    (\n        uint _coll,\n        uint _debt,\n        uint _collChange,\n        bool _isCollIncrease,\n        uint _debtChange,\n        bool _isDebtIncrease,\n        uint _price\n    )\n        pure\n        internal\n        returns (uint)\n    {\n        uint newColl = _coll;\n        uint newDebt = _debt;\n\n        newColl = _isCollIncrease ? _coll.add(_collChange) :  _coll.sub(_collChange);\n        newDebt = _isDebtIncrease ? _debt.add(_debtChange) : _debt.sub(_debtChange);\n\n        uint newICR = LiquityMath._computeCR(newColl, newDebt, _price);\n        return newICR;\n    }\n\n    function _getNewTCRFromTroveChange\n    (\n        uint _collChange,\n        bool _isCollIncrease,\n        uint _debtChange,\n        bool _isDebtIncrease,\n        uint _price\n    )\n        internal\n        view\n        returns (uint)\n    {\n        uint totalColl = activePool.getETH().add(defaultPool.getETH());\n        uint totalDebt = activePool.getLUSDDebt().add(defaultPool.getLUSDDebt());\n\n        totalColl = _isCollIncrease ? totalColl.add(_collChange) : totalColl.sub(_collChange);\n        totalDebt = _isDebtIncrease ? totalDebt.add(_debtChange) : totalDebt = totalDebt.sub(_debtChange);\n\n        uint newTCR = LiquityMath._computeCR(totalColl, totalDebt, _price);\n        return newTCR;\n    }\n\n    function getCompositeDebt(uint _debt) external pure override returns (uint) {\n        return _getCompositeDebt(_debt);\n    }\n\n    // --- Recovery Mode and TCR functions ---\n\n    function _checkRecoveryMode() internal view returns (bool) {\n        uint TCR = _getTCR();\n\n        if (TCR < CCR) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    function _getTCR() internal view returns (uint TCR) {\n        uint price = priceFeed.getPrice();\n        uint activeColl = activePool.getETH();\n        uint activeDebt = activePool.getLUSDDebt();\n        uint liquidatedColl = defaultPool.getETH();\n        uint closedDebt = defaultPool.getLUSDDebt();\n\n        uint totalCollateral = activeColl.add(liquidatedColl);\n        uint totalDebt = activeDebt.add(closedDebt);\n\n        TCR = LiquityMath._computeCR(totalCollateral, totalDebt, price);\n\n        return TCR;\n    }\n}",
        "function": "claimRedeemedCollateral(address)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-Liquity/dev-f0df3efa5a5f05b205752184cfce107c5bd6e06c/packages/contracts/contracts/BorrowerOperations.sol",
        "vulnerability": "External Call To User-Supplied Address (SWC 107)",
        "check": "TP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract TroveManager is LiquityBase, Ownable, ITroveManager {\n\n    // --- Connected contract declarations ---\n\n    address public borrowerOperationsAddress;\n\n    IPool public activePool;\n\n    IPool public defaultPool;\n\n    IStabilityPool public stabilityPool;\n\n    ICollSurplusPool collSurplusPool;\n\n    ILUSDToken public lusdToken;\n\n    IPriceFeed public priceFeed;\n\n    ILQTYStaking public lqtyStaking;\n    address public lqtyStakingAddress;\n\n    // A doubly linked list of Troves, sorted by their sorted by their collateral ratios\n    ISortedTroves public sortedTroves;\n\n    // --- Data structures ---\n\n    uint constant public SECONDS_IN_ONE_MINUTE = 60;\n    uint constant public MINUTE_DECAY_FACTOR = 999832508430720967;  // 18 digit decimal. Corresponds to an hourly decay factor of 0.99\n\n    /* \n    * BETA: 18 digit decimal. Parameter by which to divide the redeemed fraction, in order to calc the new base rate from a redemption. \n    * Corresponds to (1 / ALPHA) in the white paper. \n    */\n    uint constant public BETA = 2;\n\n    uint public baseRate;\n\n    // The timestamp of the latest fee operation (redemption or new LUSD issuance) \n    uint public lastFeeOperationTime;\n\n    enum Status { nonExistent, active, closed }\n\n    // Store the necessary data for a trove\n    struct Trove {\n        uint debt;\n        uint coll;\n        uint stake;\n        Status status;\n        uint128 arrayIndex;\n    }\n\n    mapping (address => Trove) public Troves;\n\n    uint public totalStakes;\n\n    // Snapshot of the value of totalStakes, taken immediately after the latest liquidation\n    uint public totalStakesSnapshot;\n\n    // Snapshot of the total collateral across the ActivePool and DefaultPool, immediately after the latest liquidation.\n    uint public totalCollateralSnapshot;\n\n    /*\n    * L_ETH and L_LUSDDebt track the sums of accumulated liquidation rewards per unit staked. During its lifetime, each stake earns:\n    *\n    * An ETH gain of ( stake * [L_ETH - L_ETH(0)] )\n    * A LUSDDebt increase  of ( stake * [L_LUSDDebt - L_LUSDDebt(0)] )\n    *\n    * Where L_ETH(0) and L_LUSDDebt(0) are snapshots of L_ETH and L_LUSDDebt for the active Trove taken at the instant the stake was made\n    */\n    uint public L_ETH;\n    uint public L_LUSDDebt;\n\n    // Map addresses with active troves to their RewardSnapshot\n    mapping (address => RewardSnapshot) public rewardSnapshots;\n\n    // Object containing the ETH and LUSD snapshots for a given active trove\n    struct RewardSnapshot { uint ETH; uint LUSDDebt;}\n\n    // Array of all active trove addresses - used to to compute an approximate hint off-chain, for the sorted list insertion\n    address[] public TroveOwners;\n\n    // Error trackers for the trove redistribution calculation\n    uint public lastETHError_Redistribution;\n    uint public lastLUSDDebtError_Redistribution;\n\n    /* \n    * --- Variable container structs for liquidations ---\n    *\n    * These structs are used to hold, return and assign variables inside the liquidation functions,\n    * in order to avoid the error: \"CompilerError: Stack too deep\". \n    **/\n\n    struct LocalVariables_OuterLiquidationFunction {\n        uint price;\n        uint LUSDInStabPool;\n        bool recoveryModeAtStart;\n        uint liquidatedDebt;\n        uint liquidatedColl;\n    }\n\n    struct LocalVariables_InnerSingleLiquidateFunction {\n        uint collToLiquidate;\n        uint pendingDebtReward;\n        uint pendingCollReward;\n    }\n\n    struct LocalVariables_LiquidationSequence {\n        uint remainingLUSDInStabPool;\n        uint i;\n        uint ICR;\n        address user;\n        bool backToNormalMode;\n        uint entireSystemDebt;\n        uint entireSystemColl;\n    }\n\n    struct LiquidationValues {\n        uint entireTroveDebt;\n        uint entireTroveColl;\n        uint collGasCompensation;\n        uint LUSDGasCompensation;\n        uint debtToOffset;\n        uint collToSendToSP;\n        uint debtToRedistribute;\n        uint collToRedistribute;\n        address partialAddr;\n        uint partialNewDebt;\n        uint partialNewColl;\n        address partialUpperHint;\n        address partialLowerHint;\n    }\n\n    struct LiquidationTotals {\n        uint totalCollInSequence;\n        uint totalDebtInSequence;\n        uint totalCollGasCompensation;\n        uint totalLUSDGasCompensation;\n        uint totalDebtToOffset;\n        uint totalCollToSendToSP;\n        uint totalDebtToRedistribute;\n        uint totalCollToRedistribute;\n        address partialAddr;\n        uint partialNewDebt;\n        uint partialNewColl;\n        address partialUpperHint;\n        address partialLowerHint;\n    }\n\n    // --- Variable container structs for redemptions ---\n\n    struct RedemptionTotals {\n        uint totalLUSDToRedeem;\n        uint totalETHDrawn;\n        uint ETHFee;\n        uint ETHToSendToRedeemer;\n        uint decayedBaseRate;\n    }\n\n    struct SingleRedemptionValues {\n        uint LUSDLot;\n        uint ETHLot;\n    }\n\n    // --- Events ---\n\n    event Liquidation(uint _liquidatedDebt, uint _liquidatedColl, uint _collGasCompensation, uint _LUSDGasCompensation);\n    event Redemption(uint _attemptedLUSDAmount, uint _actualLUSDAmount, uint _ETHSent, uint _ETHFee);\n\n    enum TroveManagerOperation {\n        applyPendingRewards,\n        liquidateInNormalMode,\n        liquidateInRecoveryMode,\n        partiallyLiquidateInRecoveryMode,\n        redeemCollateral\n    }\n\n    event TroveCreated(address indexed _borrower, uint _arrayIndex);\n    event TroveUpdated(address indexed _borrower, uint _debt, uint _coll, uint _stake, TroveManagerOperation _operation);\n    event TroveLiquidated(address indexed _borrower, uint _debt, uint _coll, TroveManagerOperation _operation);\n\n    // --- Dependency setter ---\n\n    function setAddresses(\n        address _borrowerOperationsAddress,\n        address _activePoolAddress,\n        address _defaultPoolAddress,\n        address _stabilityPoolAddress,\n        address _collSurplusPoolAddress,\n        address _priceFeedAddress,\n        address _lusdTokenAddress,\n        address _sortedTrovesAddress,\n        address _lqtyStakingAddress\n    )\n        external\n        override\n        onlyOwner\n    {\n        borrowerOperationsAddress = _borrowerOperationsAddress;\n        activePool = IPool(_activePoolAddress);\n        defaultPool = IPool(_defaultPoolAddress);\n        stabilityPool = IStabilityPool(_stabilityPoolAddress);\n        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);\n        priceFeed = IPriceFeed(_priceFeedAddress);\n        lusdToken = ILUSDToken(_lusdTokenAddress);\n        sortedTroves = ISortedTroves(_sortedTrovesAddress);\n        lqtyStakingAddress = _lqtyStakingAddress;\n        lqtyStaking = ILQTYStaking(_lqtyStakingAddress);\n\n        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);\n        emit ActivePoolAddressChanged(_activePoolAddress);\n        emit DefaultPoolAddressChanged(_defaultPoolAddress);\n        emit StabilityPoolAddressChanged(_stabilityPoolAddress);\n        emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);\n        emit PriceFeedAddressChanged(_priceFeedAddress);\n        emit LUSDTokenAddressChanged(_lusdTokenAddress);\n        emit SortedTrovesAddressChanged(_sortedTrovesAddress);\n        emit LQTYStakingAddressChanged(_lqtyStakingAddress);\n\n        _renounceOwnership();\n    }\n\n    // --- Getters ---\n\n    function getTroveOwnersCount() external view override returns (uint) {\n        return TroveOwners.length;\n    }\n\n    function getTroveFromTroveOwnersArray(uint _index) external view override returns (address) {\n        return TroveOwners[_index];\n    }\n\n    // --- Trove Liquidation functions ---\n\n    // Single liquidation function. Closes the trove if its ICR is lower than the minimum collateral ratio. \n    function liquidate(address _borrower) external override {\n        _requireTroveisActive(_borrower);\n\n        address[] memory borrowers = new address[](1);\n        borrowers[0] = _borrower;\n        batchLiquidateTroves(borrowers);\n    }\n\n    // --- Inner single liquidation functions ---\n\n    // Liquidate one trove, in Normal Mode.\n    function _liquidateNormalMode(address _borrower, uint _LUSDInStabPool) internal returns (LiquidationValues memory V) {\n        LocalVariables_InnerSingleLiquidateFunction memory L;\n\n        (V.entireTroveDebt,\n        V.entireTroveColl,\n        L.pendingDebtReward,\n        L.pendingCollReward) = getEntireDebtAndColl(_borrower);\n\n        _movePendingTroveRewardsToActivePool(L.pendingDebtReward, L.pendingCollReward);\n        _removeStake(_borrower);\n\n        V.collGasCompensation = _getCollGasCompensation(V.entireTroveColl);\n        V.LUSDGasCompensation = LUSD_GAS_COMPENSATION;\n        uint collToLiquidate = V.entireTroveColl.sub(V.collGasCompensation);\n\n        (V.debtToOffset,\n        V.collToSendToSP,\n        V.debtToRedistribute,\n        V.collToRedistribute) = _getOffsetAndRedistributionVals(V.entireTroveDebt, collToLiquidate, _LUSDInStabPool);\n\n        _closeTrove(_borrower);\n        emit TroveLiquidated(_borrower, V.entireTroveDebt, V.entireTroveColl, TroveManagerOperation.liquidateInNormalMode);\n\n        return V;\n    }\n\n    // Liquidate one trove, in Recovery Mode.\n    function _liquidateRecoveryMode(address _borrower, uint _ICR, uint _LUSDInStabPool, uint _TCR) internal returns (LiquidationValues memory V) {\n        LocalVariables_InnerSingleLiquidateFunction memory L;\n        \n        if (TroveOwners.length <= 1) { return V; } // don't liquidate if last trove\n\n        (V.entireTroveDebt,\n        V.entireTroveColl,\n        L.pendingDebtReward,\n        L.pendingCollReward) = getEntireDebtAndColl(_borrower);\n\n        _movePendingTroveRewardsToActivePool(L.pendingDebtReward, L.pendingCollReward);\n\n        V.collGasCompensation = _getCollGasCompensation(V.entireTroveColl);\n        // In case of a partial liquidation, V.LUSDGasCompensation will be overwritten to zero, in the third branch below\n        V.LUSDGasCompensation = LUSD_GAS_COMPENSATION;\n        L.collToLiquidate = V.entireTroveColl.sub(V.collGasCompensation);\n\n        // If ICR <= 100%, purely redistribute the Trove across all active Troves\n        if (_ICR <= _100pct) {\n            _removeStake(_borrower);\n\n            V.debtToOffset = 0;\n            V.collToSendToSP = 0;\n            V.debtToRedistribute = V.entireTroveDebt;\n            V.collToRedistribute = L.collToLiquidate;\n\n            _closeTrove(_borrower);\n            emit TroveLiquidated(_borrower, V.entireTroveDebt, V.entireTroveColl, TroveManagerOperation.liquidateInRecoveryMode);\n\n        // If 100% < ICR < MCR, offset as much as possible, and redistribute the remainder\n        } else if ((_ICR > _100pct) && (_ICR < MCR)) {\n            _removeStake(_borrower);\n\n            (V.debtToOffset,\n            V.collToSendToSP,\n            V.debtToRedistribute,\n            V.collToRedistribute) = _getOffsetAndRedistributionVals(V.entireTroveDebt, L.collToLiquidate, _LUSDInStabPool);\n\n            _closeTrove(_borrower);\n            emit TroveLiquidated(_borrower, V.entireTroveDebt, V.entireTroveColl, TroveManagerOperation.liquidateInRecoveryMode);\n\n        /* \n        * If 110% <= ICR < current TCR (accounting for the preceding liquidations in the current sequence)\n        * and there is LUSD in the Stability Pool, only offset it as much as possible, with no redistribution.\n        */\n        } else if ((_ICR >= MCR) && (_ICR < _TCR)) {\n            assert(_LUSDInStabPool != 0);\n\n            _removeStake(_borrower);\n            \n            V = _getFullOrPartialOffsetVals(_borrower, V.entireTroveDebt, V.entireTroveColl, _LUSDInStabPool);\n\n            _closeTrove(_borrower);\n        }\n        else if (_ICR >= _TCR) {\n            LiquidationValues memory zeroVals;\n            return zeroVals;\n        }\n\n        return V;\n    }\n\n    /* In a full liquidation, returns the values for a trove's coll and debt to be offset, and coll and debt to be \n    * redistributed to active troves. \n    */\n    function _getOffsetAndRedistributionVals\n    (\n        uint _debt,\n        uint _coll,\n        uint _LUSDInStabPool\n    )\n        internal\n        pure\n        returns (uint debtToOffset, uint collToSendToSP, uint debtToRedistribute, uint collToRedistribute)\n    {\n        if (_LUSDInStabPool > 0) {\n        /* \n        * Offset as much debt & collateral as possible against the Stability Pool, and redistribute the remainder\n        * between all active troves.\n        *\n        *  If the trove's debt is larger than the deposited LUSD in the Stability Pool:\n        *\n        *  - Offset an amount of the trove's debt equal to the LUSD in the Stability Pool\n        *  - Send a fraction of the trove's collateral to the Stability Pool, equal to the fraction of its offset debt\n        *\n        */\n            debtToOffset = LiquityMath._min(_debt, _LUSDInStabPool);\n            collToSendToSP = _coll.mul(debtToOffset).div(_debt);\n            debtToRedistribute = _debt.sub(debtToOffset);\n            collToRedistribute = _coll.sub(collToSendToSP);\n        } else {\n            debtToOffset = 0;\n            collToSendToSP = 0;\n            debtToRedistribute = _debt;\n            collToRedistribute = _coll;\n        }\n    }\n\n    /*\n    *  If it is a full offset, get its offset coll/debt and ETH gas comp, and close the trove.\n    *\n    * If it is a partial liquidation, get its offset coll/debt and ETH gas comp, and its new coll/debt, and its re-insertion hints.\n    */\n    function _getFullOrPartialOffsetVals\n    (\n        address _borrower,\n        uint _entireTroveDebt,\n        uint _entireTroveColl,\n        uint _LUSDInStabPool\n    )\n        internal\n        returns (LiquidationValues memory V)\n    {\n        V.entireTroveDebt = _entireTroveDebt;\n        V.entireTroveColl = _entireTroveColl;\n\n        // When Stability Pool can fully absorb the trove's debt, perform a full offset\n        if (_entireTroveDebt <= _LUSDInStabPool) {\n            V.collGasCompensation = _getCollGasCompensation(_entireTroveColl);\n            V.LUSDGasCompensation = LUSD_GAS_COMPENSATION;\n\n            V.debtToOffset = _entireTroveDebt;\n            V.collToSendToSP = _entireTroveColl.sub(V.collGasCompensation);\n            V.debtToRedistribute = 0;\n            V.collToRedistribute = 0;\n\n            emit TroveLiquidated(_borrower, _entireTroveDebt, _entireTroveColl, TroveManagerOperation.liquidateInRecoveryMode);\n        }\n        /* \n        * When trove's debt is greater than the Stability Pool, perform a partial liquidation: offset as much as possible,\n        * and do not redistribute the remainder. The trove remains active, with a reduced collateral and debt.\n        *\n        * ETH gas compensation is based on and drawn from the collateral fraction that corresponds to the partial offset. \n        * LUSD gas compensation is left untouched. \n        *\n        * Since ETH gas comp is drawn purely from the *liquidated* portion, the trove is left with the same ICR as before the \n        * liquidation.\n        */\n        else if (_entireTroveDebt > _LUSDInStabPool) {\n            // Remaining debt in the trove is lower-bounded by the trove's gas compensation\n            V.partialNewDebt = LiquityMath._max(_entireTroveDebt.sub(_LUSDInStabPool), LUSD_GAS_COMPENSATION);\n          \n            V.debtToOffset = _entireTroveDebt.sub(V.partialNewDebt);\n\n            uint collFraction = _entireTroveColl.mul(V.debtToOffset).div(_entireTroveDebt);\n            V.collGasCompensation = _getCollGasCompensation(collFraction);\n          \n            V.LUSDGasCompensation = 0;  // LUSD gas compensation remains untouched\n\n            V.collToSendToSP = collFraction.sub(V.collGasCompensation);\n            V.collToRedistribute = 0;\n            V.debtToRedistribute = 0;\n\n            V.partialAddr = _borrower;\n            V.partialNewColl = _entireTroveColl.sub(collFraction);\n\n            // Get the partial trove's neighbours, so we can re-insert it later to the same position\n            V.partialUpperHint = sortedTroves.getPrev(_borrower);  \n            V.partialLowerHint = sortedTroves.getNext(_borrower);\n        }\n    }\n\n    /* \n    * Liquidate a sequence of troves. Closes a maximum number of n under-collateralized Troves,\n    * starting from the one with the lowest collateral ratio in the system, and moving upwards\n    */\n    function liquidateTroves(uint _n) external override {\n        LocalVariables_OuterLiquidationFunction memory L;\n\n        LiquidationTotals memory T;\n\n        L.price = priceFeed.getPrice();\n        L.LUSDInStabPool = stabilityPool.getTotalLUSDDeposits();\n        L.recoveryModeAtStart = checkRecoveryMode();\n\n        // Perform the appropriate liquidation sequence - tally the values, and obtain their totals\n        if (L.recoveryModeAtStart == true) {\n            T = _getTotalsFromLiquidateTrovesSequence_RecoveryMode(L.price, L.LUSDInStabPool, _n);\n        } else if (L.recoveryModeAtStart == false) {\n            T = _getTotalsFromLiquidateTrovesSequence_NormalMode(L.price, L.LUSDInStabPool, _n);\n        }\n\n        // Move liquidated ETH and LUSD to the appropriate pools\n        stabilityPool.offset(T.totalDebtToOffset, T.totalCollToSendToSP);\n        _redistributeDebtAndColl(T.totalDebtToRedistribute, T.totalCollToRedistribute);\n\n        // Update system snapshots and the final partially liquidated trove, if there is one\n        _updateSystemSnapshots_excludeCollRemainder(T.partialNewColl.add(T.totalCollGasCompensation));\n        _updatePartiallyLiquidatedTrove(T.partialAddr, T.partialNewDebt, T.partialNewColl, T.partialUpperHint, T. partialLowerHint, L.price);\n\n        L.liquidatedDebt = T.totalDebtInSequence.sub(T.partialNewDebt);\n        L.liquidatedColl = T.totalCollInSequence.sub(T.totalCollGasCompensation).sub(T.partialNewColl);\n        emit Liquidation(L.liquidatedDebt, L.liquidatedColl, T.totalCollGasCompensation, T.totalLUSDGasCompensation);\n\n        // Send gas compensation to caller\n        _sendGasCompensation(msg.sender, T.totalLUSDGasCompensation, T.totalCollGasCompensation);\n    }\n\n    /*\n    * This function is used when the liquidateTroves sequence starts during Recovery Mode. However, it\n    * handle the case where the system *leaves* Recovery Mode, part way through the liquidation sequence\n    */\n    function _getTotalsFromLiquidateTrovesSequence_RecoveryMode\n    (\n        uint _price,\n        uint _LUSDInStabPool,\n        uint _n\n    )\n        internal\n        returns(LiquidationTotals memory T)\n    {\n        LocalVariables_LiquidationSequence memory L;\n        LiquidationValues memory V;\n\n        L.remainingLUSDInStabPool = _LUSDInStabPool;\n        L.backToNormalMode = false;\n        L.entireSystemDebt = activePool.getLUSDDebt().add(defaultPool.getLUSDDebt());\n        L.entireSystemColl = activePool.getETH().add(defaultPool.getETH());\n\n        L.i = 0;\n        while (L.i < _n) {\n            L.user = sortedTroves.getLast();\n            L.ICR = getCurrentICR(L.user, _price);\n\n            if (L.backToNormalMode == false) {\n                // Break the loop if ICR is greater than MCR and Stability Pool is empty\n                if (L.ICR >= MCR && L.remainingLUSDInStabPool == 0) { break; }\n\n                uint TCR = LiquityMath._computeCR(L.entireSystemColl, L.entireSystemDebt, _price);\n        \n                V = _liquidateRecoveryMode(L.user, L.ICR, L.remainingLUSDInStabPool, TCR);\n\n                // Update aggregate trackers\n                L.remainingLUSDInStabPool = L.remainingLUSDInStabPool.sub(V.debtToOffset);\n                L.entireSystemDebt = L.entireSystemDebt.sub(V.debtToOffset);\n                L.entireSystemColl = L.entireSystemColl.sub(V.collToSendToSP);\n\n                // Add liquidation values to their respective running totals\n                T = _addLiquidationValuesToTotals(T, V);\n\n                // Break the loop if it was a partial liquidation\n                if (V.partialAddr != address(0)) {break;}\n\n                L.backToNormalMode = !_checkPotentialRecoveryMode(L.entireSystemColl, L.entireSystemDebt, _price);\n            }\n            else if (L.backToNormalMode == true && L.ICR < MCR) {\n                V = _liquidateNormalMode(L.user, L.remainingLUSDInStabPool);\n\n                L.remainingLUSDInStabPool = L.remainingLUSDInStabPool.sub(V.debtToOffset);\n\n                // Add liquidation values to their respective running totals\n                T = _addLiquidationValuesToTotals(T, V);\n\n            }  else break;  // break if the loop reaches a Trove with ICR >= MCR\n\n            // Break the loop if it reaches the first Trove in the sorted list\n            if (L.user == sortedTroves.getFirst()) { break; }\n\n            L.i++;\n        }\n    }\n\n    function _getTotalsFromLiquidateTrovesSequence_NormalMode\n    (\n        uint _price,\n        uint _LUSDInStabPool,\n        uint _n\n    )\n        internal\n        returns(LiquidationTotals memory T)\n    {\n        LocalVariables_LiquidationSequence memory L;\n        LiquidationValues memory V;\n\n        L.remainingLUSDInStabPool = _LUSDInStabPool;\n\n        L.i = 0;\n        while (L.i < _n) {\n            L.user = sortedTroves.getLast();\n            L.ICR = getCurrentICR(L.user, _price);\n\n            if (L.ICR < MCR) {\n                V = _liquidateNormalMode(L.user, L.remainingLUSDInStabPool);\n\n                L.remainingLUSDInStabPool = L.remainingLUSDInStabPool.sub(V.debtToOffset);\n\n                // Add liquidation values to their respective running totals\n                T = _addLiquidationValuesToTotals(T, V);\n\n            } else break;  // break if the loop reaches a Trove with ICR >= MCR\n\n            // Break the loop if it reaches the first Trove in the sorted list\n            if (L.user == sortedTroves.getFirst()) { break; }\n            L.i++;\n        }\n    }\n\n    /* \n    * Attempt to liquidate a custom list of troves provided by the caller. The liquidation sequence stops if\n    * a partial liquidation is performed, so it's up to the caller to order the troves in the _troveArray parameter.\n    */\n    function batchLiquidateTroves(address[] memory _troveArray) public override {\n        require(_troveArray.length != 0, \"TroveManager: Calldata address array must not be empty\");\n\n        LocalVariables_OuterLiquidationFunction memory L;\n        LiquidationTotals memory T;\n\n        L.price = priceFeed.getPrice();\n        L.LUSDInStabPool = stabilityPool.getTotalLUSDDeposits();\n        L.recoveryModeAtStart = checkRecoveryMode();\n\n        // Perform the appropriate liquidation sequence - tally values and obtain their totals.\n        if (L.recoveryModeAtStart == true) {\n           T = _getTotalFromBatchLiquidate_RecoveryMode(L.price, L.LUSDInStabPool, _troveArray);\n        } else if (L.recoveryModeAtStart == false) {\n            T = _getTotalsFromBatchLiquidate_NormalMode(L.price, L.LUSDInStabPool, _troveArray);\n        }\n\n        // Move liquidated ETH and LUSD to the appropriate pools\n        stabilityPool.offset(T.totalDebtToOffset, T.totalCollToSendToSP);\n        _redistributeDebtAndColl(T.totalDebtToRedistribute, T.totalCollToRedistribute);\n\n        // Update system snapshots and the final partially liquidated trove, if there is one\n        _updateSystemSnapshots_excludeCollRemainder(T.partialNewColl.add(T.totalCollGasCompensation));\n        _updatePartiallyLiquidatedTrove(T.partialAddr, T.partialNewDebt, T.partialNewColl, T.partialUpperHint, T. partialLowerHint, L.price);\n\n        L.liquidatedDebt = T.totalDebtInSequence.sub(T.partialNewDebt);\n        L.liquidatedColl = T.totalCollInSequence.sub(T.totalCollGasCompensation).sub(T.partialNewColl);\n        emit Liquidation(L.liquidatedDebt, L.liquidatedColl, T.totalCollGasCompensation, T.totalLUSDGasCompensation);\n\n        // Send gas compensation to caller\n        _sendGasCompensation(msg.sender, T.totalLUSDGasCompensation, T.totalCollGasCompensation);\n    }\n\n    /* \n    * This function is used when the batch liquidation sequence starts during Recovery Mode. However, it\n    * handle the case where the system *leaves* Recovery Mode, part way through the liquidation sequence\n    */\n    function _getTotalFromBatchLiquidate_RecoveryMode\n    (\n        uint _price,\n        uint _LUSDInStabPool,\n        address[] memory _troveArray)\n        internal\n        returns(LiquidationTotals memory T)\n    {\n        LocalVariables_LiquidationSequence memory L;\n        LiquidationValues memory V;\n\n        L.remainingLUSDInStabPool = _LUSDInStabPool;\n        L.backToNormalMode = false;\n        L.entireSystemDebt = activePool.getLUSDDebt().add(defaultPool.getLUSDDebt());\n        L.entireSystemColl = activePool.getETH().add(defaultPool.getETH());\n\n        L.i = 0;\n        for (L.i = 0; L.i < _troveArray.length; L.i++) {\n            L.user = _troveArray[L.i];\n            L.ICR = getCurrentICR(L.user, _price);\n\n            if (L.backToNormalMode == false) {\n\n                // Skip this trove if ICR is greater than MCR and Stability Pool is empty\n                if (L.ICR >= MCR && L.remainingLUSDInStabPool == 0) { continue; }\n\n                uint TCR = LiquityMath._computeCR(L.entireSystemColl, L.entireSystemDebt, _price);\n\n                V = _liquidateRecoveryMode(L.user, L.ICR, L.remainingLUSDInStabPool, TCR);\n\n                // Update aggregate trackers\n                L.remainingLUSDInStabPool = L.remainingLUSDInStabPool.sub(V.debtToOffset);\n                L.entireSystemDebt = L.entireSystemDebt.sub(V.debtToOffset);\n                L.entireSystemColl = L.entireSystemColl.sub(V.collToSendToSP);\n\n                // Add liquidation values to their respective running totals\n                T = _addLiquidationValuesToTotals(T, V);\n\n                // Break the loop if it was a partial liquidation\n                if (V.partialAddr != address(0)) { break; }\n\n                L.backToNormalMode = !_checkPotentialRecoveryMode(L.entireSystemColl, L.entireSystemDebt, _price);\n            }\n\n            else if (L.backToNormalMode == true && L.ICR < MCR) {\n                V = _liquidateNormalMode(L.user, L.remainingLUSDInStabPool);\n                L.remainingLUSDInStabPool = L.remainingLUSDInStabPool.sub(V.debtToOffset);\n\n                // Add liquidation values to their respective running totals\n                T = _addLiquidationValuesToTotals(T, V);\n            }\n        }\n    }\n\n    function _getTotalsFromBatchLiquidate_NormalMode\n    (\n        uint _price,\n        uint _LUSDInStabPool,\n        address[] memory _troveArray\n    )\n        internal\n        returns(LiquidationTotals memory T)\n    {\n        LocalVariables_LiquidationSequence memory L;\n        LiquidationValues memory V;\n\n        L.remainingLUSDInStabPool = _LUSDInStabPool;\n\n        for (L.i = 0; L.i < _troveArray.length; L.i++) {\n            L.user = _troveArray[L.i];\n            L.ICR = getCurrentICR(L.user, _price);\n\n            if (L.ICR < MCR) {\n                V = _liquidateNormalMode(L.user, L.remainingLUSDInStabPool);\n                L.remainingLUSDInStabPool = L.remainingLUSDInStabPool.sub(V.debtToOffset);\n\n                // Add liquidation values to their respective running totals\n                T = _addLiquidationValuesToTotals(T, V);\n            }\n        }\n    }\n\n    // --- Liquidation helper functions ---\n\n    function _addLiquidationValuesToTotals(LiquidationTotals memory T1, LiquidationValues memory V)\n    internal pure returns(LiquidationTotals memory T2) {\n\n        // Tally all the values with their respective running totals\n        T2.totalCollGasCompensation = T1.totalCollGasCompensation.add(V.collGasCompensation);\n        T2.totalLUSDGasCompensation = T1.totalLUSDGasCompensation.add(V.LUSDGasCompensation);\n        T2.totalDebtInSequence = T1.totalDebtInSequence.add(V.entireTroveDebt);\n        T2.totalCollInSequence = T1.totalCollInSequence.add(V.entireTroveColl);\n        T2.totalDebtToOffset = T1.totalDebtToOffset.add(V.debtToOffset);\n        T2.totalCollToSendToSP = T1.totalCollToSendToSP.add(V.collToSendToSP);\n        T2.totalDebtToRedistribute = T1.totalDebtToRedistribute.add(V.debtToRedistribute);\n        T2.totalCollToRedistribute = T1.totalCollToRedistribute.add(V.collToRedistribute);\n\n        // Assign the address of the partially liquidated trove, and its new debt and coll values\n        T2.partialAddr = V.partialAddr;\n        T2.partialNewDebt = V.partialNewDebt;\n        T2.partialNewColl = V.partialNewColl;\n        T2.partialUpperHint = V.partialUpperHint;\n        T2.partialLowerHint = V.partialLowerHint;\n\n        return T2;\n    }\n\n    // Update the properties of the partially liquidated trove, and insert it back to the list\n    function _updatePartiallyLiquidatedTrove\n    (\n        address _borrower, \n        uint _newDebt, \n        uint _newColl, \n        address _upperHint,\n        address _lowerHint,\n        uint _price\n    ) \n        internal \n    {\n        if ( _borrower == address(0)) { return; }\n\n        Troves[_borrower].debt = _newDebt;\n        Troves[_borrower].coll = _newColl;\n        Troves[_borrower].status = Status.active;\n\n        _updateTroveRewardSnapshots(_borrower);\n        _updateStakeAndTotalStakes(_borrower);\n\n        uint ICR = getCurrentICR(_borrower, _price);\n\n        /* \n        * Insert to sorted list and add to TroveOwners array. The partially liquidated trove has the same\n        * ICR as it did before the liquidation, so insertion is O(1): in principle, its ICR does not change.\n        * In practice, due to rounding error, its ICR can change slightly - so re-insert, with its previous neighbours\n        * as hints.\n        */\n        sortedTroves.insert(_borrower, ICR, _price, _upperHint, _lowerHint);\n        _addTroveOwnerToArray(_borrower);\n        emit TroveUpdated(_borrower, _newDebt, _newColl, Troves[_borrower].stake, TroveManagerOperation.partiallyLiquidateInRecoveryMode);\n    }\n\n    function _sendGasCompensation(address _liquidator, uint _LUSD, uint _ETH) internal {\n        if (_LUSD > 0) {\n            lusdToken.returnFromPool(GAS_POOL_ADDRESS, _liquidator, _LUSD);\n        }\n\n        if (_ETH > 0) {\n            activePool.sendETH(_liquidator, _ETH);\n        }\n    }\n\n    // Move a Trove's pending debt and collateral rewards from distributions, from the Default Pool to the Active Pool\n    function _movePendingTroveRewardsToActivePool(uint _LUSD, uint _ETH) internal {\n        defaultPool.decreaseLUSDDebt(_LUSD);\n        activePool.increaseLUSDDebt(_LUSD);\n        defaultPool.sendETH(address(activePool), _ETH);\n    }\n\n    // --- Redemption functions ---\n\n    // Redeem as much collateral as possible from _borrower's Trove in exchange for LUSD up to _maxLUSDamount\n    function _redeemCollateralFromTrove(\n        address _borrower,\n        uint _maxLUSDamount,\n        uint _price,\n        address _partialRedemptionHint,\n        uint _partialRedemptionHintICR\n    )\n        internal returns (SingleRedemptionValues memory V)\n    {\n        // Determine the remaining amount (lot) to be redeemed, capped by the entire debt of the Trove minus the gas compensation\n        V.LUSDLot = LiquityMath._min(_maxLUSDamount, Troves[_borrower].debt.sub(LUSD_GAS_COMPENSATION));\n\n        // Get the ETHLot of equivalent value in USD\n        V.ETHLot = V.LUSDLot.mul(1e18).div(_price);\n\n        // Decrease the debt and collateral of the current Trove according to the LUSD lot and corresponding ETH to send\n        uint newDebt = (Troves[_borrower].debt).sub(V.LUSDLot);\n        uint newColl = (Troves[_borrower].coll).sub(V.ETHLot);\n\n        if (newDebt == LUSD_GAS_COMPENSATION) {\n            // No debt left in the Trove (except for the gas compensation), therefore the trove gets closed\n            _removeStake(_borrower);\n            _closeTrove(_borrower);\n            _redeemCloseTrove(_borrower, LUSD_GAS_COMPENSATION, newColl);\n\n        } else {\n            uint newICR = LiquityMath._computeCR(newColl, newDebt, _price);\n\n            // Check if the provided hint is fresh. If not, we bail since trying to reinsert without a good hint will almost\n            // certainly result in running out of gas.\n            if (newICR != _partialRedemptionHintICR) {\n                V.LUSDLot = 0;\n                V.ETHLot = 0;\n                return V;\n            }\n\n            sortedTroves.reInsert(_borrower, newICR, _price, _partialRedemptionHint, _partialRedemptionHint);\n\n            Troves[_borrower].debt = newDebt;\n            Troves[_borrower].coll = newColl;\n            _updateStakeAndTotalStakes(_borrower);\n        }\n        emit TroveUpdated(\n            _borrower,\n            newDebt, newColl,\n            Troves[_borrower].stake,\n            TroveManagerOperation.redeemCollateral\n        );\n        return V;\n    }\n\n    /* \n    * Called when a full redemption occurs, and closes the trove.\n    * The redeemer swaps (debt - 10) LUSD for (debt - 10) worth of ETH, so the 10 LUSD gas compensation left corresponds to the remaining debt.\n    * In order to close the trove, the 10 LUSD gas compensation is burned, and 10 debt is removed from the active pool.\n    * The debt recorded on the trove's struct is zero'd elswhere, in _closeTrove.\n    * Any surplus ETH left in the trove, is sent to the Coll surplus pool, and can be later claimed by the borrower.\n    */ \n    function _redeemCloseTrove(address _borrower, uint _LUSD, uint _ETH) internal {\n        lusdToken.burn(GAS_POOL_ADDRESS, _LUSD);\n        // Update Active Pool LUSD, and send ETH to account\n        activePool.decreaseLUSDDebt(_LUSD);\n\n        // send ETH from Active Pool to CollSurplus Pool\n        collSurplusPool.accountSurplus(_borrower, _ETH);\n        activePool.sendETH(address(collSurplusPool), _ETH);\n    }\n\n    function _isValidFirstRedemptionHint(address _firstRedemptionHint, uint _price) internal view returns (bool) {\n        if (_firstRedemptionHint == address(0) ||\n            !sortedTroves.contains(_firstRedemptionHint) ||\n            getCurrentICR(_firstRedemptionHint, _price) < MCR\n        ) {\n            return false;\n        }\n\n        address nextTrove = sortedTroves.getNext(_firstRedemptionHint);\n        return nextTrove == address(0) || getCurrentICR(nextTrove, _price) < MCR;\n    }\n\n    /* Send _LUSDamount LUSD to the system and redeem the corresponding amount of collateral from as many Troves as are needed to fill the redemption\n    * request.  Applies pending rewards to a Trove before reducing its debt and coll.\n    *\n    * Note that if _amount is very large, this function can run out of gas, specially if traversed troves are small. This can be easily avoided by \n    * splitting the total _amount in appropriate chunks and calling the function multiple times.\n    * \n    * Param `_maxIterations` can also be provided, so the loop through Troves is capped (if its zero, it will be ignored).This makes it easier to \n    * avoid OOG for the frontend, as only knowing approximately the average cost of an iteration is enough, without needing to know the topology \n    * of the trove list. It also avoids the need to set the cap in stone in the contract, nor doing gas calculations, as both gas price and opcode \n    * costs can vary.\n    * \n    * All Troves that are redeemed from -- with the likely exception of the last one -- will end up with no debt left, therefore they will be closed.\n    * If the last Trove does have some remaining debt, it has a finite ICR, and the reinsertion could be anywhere in the list, therefore it requires a hint. \n    * A frontend should use getRedemptionHints() to calculate what the ICR of this Trove will be after redemption, and pass a hint for its position \n    * in the sortedTroves list along with the ICR value that the hint was found for.\n    * \n    * If another transaction modifies the list between calling getRedemptionHints() and passing the hints to redeemCollateral(), it\n    * is very likely that the last (partially) redeemed Trove would end up with a different ICR than what the hint is for. In this case the\n    * redemption will stop after the last completely redeemed Trove and the sender will keep the remaining LUSD amount, which they can attempt\n    * to redeem later.\n    */\n    function redeemCollateral(\n        uint _LUSDamount,\n        address _firstRedemptionHint,\n        address _partialRedemptionHint,\n        uint _partialRedemptionHintICR,\n        uint _maxIterations\n    )\n        external\n        override\n    {\n        uint activeDebt = activePool.getLUSDDebt();\n        uint defaultedDebt = defaultPool.getLUSDDebt();\n\n        RedemptionTotals memory T;\n\n        _requireAmountGreaterThanZero(_LUSDamount);\n        _requireLUSDBalanceCoversRedemption(msg.sender, _LUSDamount);\n\n        // Confirm redeemer's balance is less than total systemic debt\n        assert(lusdToken.balanceOf(msg.sender) <= (activeDebt.add(defaultedDebt)));\n\n        uint remainingLUSD = _LUSDamount;\n        uint price = priceFeed.getPrice();\n        address currentBorrower;\n\n        if (_isValidFirstRedemptionHint(_firstRedemptionHint, price)) {\n            currentBorrower = _firstRedemptionHint;\n        } else {\n            currentBorrower = sortedTroves.getLast();\n            // Find the first trove with ICR >= MCR\n            // SWC-104-Unchecked Call Return Value: L920\n            while (currentBorrower != address(0) && getCurrentICR(currentBorrower, price) < MCR) {\n                currentBorrower = sortedTroves.getPrev(currentBorrower);\n            }\n        }\n\n        // Loop through the Troves starting from the one with lowest collateral ratio until _amount of LUSD is exchanged for collateral\n        if (_maxIterations == 0) { _maxIterations = uint(-1); }\n        while (currentBorrower != address(0) && remainingLUSD > 0 && _maxIterations > 0) {\n            _maxIterations--;\n            // Save the address of the Trove preceding the current one, before potentially modifying the list\n            address nextUserToCheck = sortedTroves.getPrev(currentBorrower);\n\n            _applyPendingRewards(currentBorrower);\n            SingleRedemptionValues memory V = _redeemCollateralFromTrove(\n                currentBorrower,\n                remainingLUSD,\n                price,\n                _partialRedemptionHint,\n                _partialRedemptionHintICR\n            );\n\n            if (V.LUSDLot == 0) break; // Partial redemption hint got out-of-date, therefore we could not redeem from the last Trove\n\n            T.totalLUSDToRedeem  = T.totalLUSDToRedeem.add(V.LUSDLot);\n            T.totalETHDrawn = T.totalETHDrawn.add(V.ETHLot);\n\n            remainingLUSD = remainingLUSD.sub(V.LUSDLot);\n            currentBorrower = nextUserToCheck;\n        }\n\n        // Decay the baseRate due to time passed, and then increase it according to the size of this redemption\n        _updateBaseRateFromRedemption(T.totalETHDrawn, price);\n\n        // Calculate the ETH fee and send it to the LQTY staking contract\n        T.ETHFee = _getRedemptionFee(T.totalETHDrawn);\n        activePool.sendETH(lqtyStakingAddress, T.ETHFee);\n        lqtyStaking.increaseF_ETH(T.ETHFee);\n\n        T.ETHToSendToRedeemer = T.totalETHDrawn.sub(T.ETHFee);\n\n        // Burn the total LUSD that is cancelled with debt, and send the redeemed ETH to msg.sender\n        _activePoolRedeemCollateral(msg.sender, T.totalLUSDToRedeem, T.ETHToSendToRedeemer);\n\n        emit Redemption(_LUSDamount, T.totalLUSDToRedeem, T.totalETHDrawn, T.ETHFee);\n    }\n\n    // Burn the received LUSD, transfer the redeemed ETH to _redeemer and updates the Active Pool\n    function _activePoolRedeemCollateral(address _redeemer, uint _LUSD, uint _ETH) internal {\n        // Update Active Pool LUSD, and send ETH to account\n        lusdToken.burn(_redeemer, _LUSD);\n        activePool.decreaseLUSDDebt(_LUSD);\n\n        activePool.sendETH(_redeemer, _ETH);\n    }\n\n    // --- Helper functions ---\n\n\n    // Return the current collateral ratio (ICR) of a given Trove. Takes a trove's pending coll and debt rewards from redistributions into account.\n    function getCurrentICR(address _borrower, uint _price) public view override returns (uint) {\n        uint pendingETHReward = getPendingETHReward(_borrower);\n        uint pendingLUSDDebtReward = getPendingLUSDDebtReward(_borrower);\n\n        uint currentETH = Troves[_borrower].coll.add(pendingETHReward);\n        uint currentLUSDDebt = Troves[_borrower].debt.add(pendingLUSDDebtReward);\n\n        uint ICR = LiquityMath._computeCR(currentETH, currentLUSDDebt, _price);\n        return ICR;\n    }\n\n    function applyPendingRewards(address _borrower) external override {\n        _requireCallerIsBorrowerOperations();\n        return _applyPendingRewards(_borrower);\n    }\n\n    // Add the borrowers's coll and debt rewards earned from redistributions, to their Trove\n    function _applyPendingRewards(address _borrower) internal {\n        if (hasPendingRewards(_borrower)) {\n            _requireTroveisActive(_borrower);\n\n            // Compute pending rewards\n            uint pendingETHReward = getPendingETHReward(_borrower);\n            uint pendingLUSDDebtReward = getPendingLUSDDebtReward(_borrower);\n\n            // Apply pending rewards to trove's state\n            Troves[_borrower].coll = Troves[_borrower].coll.add(pendingETHReward);\n            Troves[_borrower].debt = Troves[_borrower].debt.add(pendingLUSDDebtReward);\n\n            _updateTroveRewardSnapshots(_borrower);\n\n            // Transfer from DefaultPool to ActivePool\n            _movePendingTroveRewardsToActivePool(pendingLUSDDebtReward, pendingETHReward);\n\n            emit TroveUpdated(\n                _borrower, \n                Troves[_borrower].debt, \n                Troves[_borrower].coll, \n                Troves[_borrower].stake, \n                TroveManagerOperation.applyPendingRewards\n            );\n        }\n    }\n\n    // Update borrower's snapshots of L_ETH and L_LUSDDebt to reflect the current values\n    function updateTroveRewardSnapshots(address _borrower) external override {\n        _requireCallerIsBorrowerOperations();\n       return _updateTroveRewardSnapshots(_borrower);\n    }\n\n    function _updateTroveRewardSnapshots(address _borrower) internal {\n        rewardSnapshots[_borrower].ETH = L_ETH;\n        rewardSnapshots[_borrower].LUSDDebt = L_LUSDDebt;\n    }\n\n    // Get the borrower's pending accumulated ETH reward, earned by their stake\n    function getPendingETHReward(address _borrower) public view override returns (uint) {\n        uint snapshotETH = rewardSnapshots[_borrower].ETH;\n        uint rewardPerUnitStaked = L_ETH.sub(snapshotETH);\n\n        if ( rewardPerUnitStaked == 0 ) { return 0; }\n\n        uint stake = Troves[_borrower].stake;\n\n        uint pendingETHReward = stake.mul(rewardPerUnitStaked).div(1e18);\n\n        return pendingETHReward;\n    }\n\n     // Get the borrower's pending accumulated LUSD reward, earned by their stake\n    function getPendingLUSDDebtReward(address _borrower) public view override returns (uint) {\n        uint snapshotLUSDDebt = rewardSnapshots[_borrower].LUSDDebt;\n        uint rewardPerUnitStaked = L_LUSDDebt.sub(snapshotLUSDDebt);\n\n        if ( rewardPerUnitStaked == 0 ) { return 0; }\n\n        uint stake =  Troves[_borrower].stake;\n\n        uint pendingLUSDDebtReward = stake.mul(rewardPerUnitStaked).div(1e18);\n\n        return pendingLUSDDebtReward;\n    }\n\n    function hasPendingRewards(address _borrower) public view override returns (bool) {\n        /* \n        * A Trove has pending rewards if its snapshot is less than the current rewards per-unit-staked sum:\n        * this indicates that rewards have occured since the snapshot was made, and the user therefore has\n        * pending rewards \n        */\n        return (rewardSnapshots[_borrower].ETH < L_ETH);\n    }\n\n    // Return the Troves entire debt and coll, including pending rewards from redistributions.\n    function getEntireDebtAndColl(\n        address _borrower\n    )\n        public\n        view\n        override\n        returns (uint debt, uint coll, uint pendingLUSDDebtReward, uint pendingETHReward)\n    {\n        debt = Troves[_borrower].debt;\n        coll = Troves[_borrower].coll;\n\n        pendingLUSDDebtReward = getPendingLUSDDebtReward(_borrower);\n        pendingETHReward = getPendingETHReward(_borrower);\n\n        debt = debt.add(pendingLUSDDebtReward);\n        coll = coll.add(pendingETHReward);\n    }\n\n    function removeStake(address _borrower) external override {\n        _requireCallerIsBorrowerOperations();\n        return _removeStake(_borrower);\n    }\n\n    // Remove borrower's stake from the totalStakes sum, and set their stake to 0\n    function _removeStake(address _borrower) internal {\n        uint stake = Troves[_borrower].stake;\n        totalStakes = totalStakes.sub(stake);\n        Troves[_borrower].stake = 0;\n    }\n\n    function updateStakeAndTotalStakes(address _borrower) external override returns (uint) {\n        _requireCallerIsBorrowerOperations();\n        return _updateStakeAndTotalStakes(_borrower);\n    }\n\n    // Update borrower's stake based on their latest collateral value\n    function _updateStakeAndTotalStakes(address _borrower) internal returns (uint) {\n        uint newStake = _computeNewStake(Troves[_borrower].coll);\n        uint oldStake = Troves[_borrower].stake;\n        Troves[_borrower].stake = newStake;\n        totalStakes = totalStakes.sub(oldStake).add(newStake);\n\n        return newStake;\n    }\n\n    // Calculate a new stake based on the snapshots of the totalStakes and totalCollateral taken at the last liquidation\n    function _computeNewStake(uint _coll) internal view returns (uint) {\n        uint stake;\n        if (totalCollateralSnapshot == 0) {\n            stake = _coll;\n        } else {\n            /*  \n            * The following assert() holds true because:\n            * - The system always contains >= 1 trove \n            * - When we close or liquidate a trove, we redistribute the pending rewards, so if all troves were closed/liquidated, \n            * rewards wouldve been emptied and totalCollateralSnapshot would be zero too.\n            */\n            assert(totalStakesSnapshot > 0);\n            stake = _coll.mul(totalStakesSnapshot).div(totalCollateralSnapshot);\n        }\n        return stake;\n    }\n\n    function _redistributeDebtAndColl(uint _debt, uint _coll) internal {\n        if (_debt == 0) { return; }\n\n        if (totalStakes > 0) {\n            /* \n            * Add distributed coll and debt rewards-per-unit-staked to the running totals.\n            * Division uses a \"feedback\" error correction, to keep the cumulative error in\n            * the  L_ETH and L_LUSDDebt state variables low. \n            */\n            uint ETHNumerator = _coll.mul(1e18).add(lastETHError_Redistribution);\n            uint LUSDDebtNumerator = _debt.mul(1e18).add(lastLUSDDebtError_Redistribution);\n\n            uint ETHRewardPerUnitStaked = ETHNumerator.div(totalStakes);\n            uint LUSDDebtRewardPerUnitStaked = LUSDDebtNumerator.div(totalStakes);\n\n            lastETHError_Redistribution = ETHNumerator.sub(ETHRewardPerUnitStaked.mul(totalStakes));\n            lastLUSDDebtError_Redistribution = LUSDDebtNumerator.sub(LUSDDebtRewardPerUnitStaked.mul(totalStakes));\n\n            L_ETH = L_ETH.add(ETHRewardPerUnitStaked);\n            L_LUSDDebt = L_LUSDDebt.add(LUSDDebtRewardPerUnitStaked);\n        }\n\n        // Transfer coll and debt from ActivePool to DefaultPool\n        activePool.decreaseLUSDDebt(_debt);\n        defaultPool.increaseLUSDDebt(_debt);\n        activePool.sendETH(address(defaultPool), _coll);\n    }\n\n    function closeTrove(address _borrower) external override {\n        _requireCallerIsBorrowerOperations();\n        return _closeTrove(_borrower);\n    }\n\n    function _closeTrove(address _borrower) internal {\n        uint TroveOwnersArrayLength = TroveOwners.length;\n        _requireMoreThanOneTroveInSystem(TroveOwnersArrayLength);\n\n        Troves[_borrower].status = Status.closed;\n        Troves[_borrower].coll = 0;\n        Troves[_borrower].debt = 0;\n\n        rewardSnapshots[_borrower].ETH = 0;\n        rewardSnapshots[_borrower].LUSDDebt = 0;\n\n        _removeTroveOwner(_borrower, TroveOwnersArrayLength);\n        sortedTroves.remove(_borrower);\n    }\n\n    /* \n    * Updates snapshots of system total stakes and total collateral, excluding a given collateral remainder from the calculation. \n    * Used in a liquidation sequence.\n    *\n    * The calculation excludes two portions of collateral that are in the ActivePool: \n    *\n    * 1) the total ETH gas compensation from the liquidation sequence\n    * 2) The remaining collateral in a partially liquidated trove (if one occurred)\n    *\n    * The ETH as compensation must be excluded as it is always sent out at the very end of the liquidation sequence.\n    *\n    * The partially liquidated trove's remaining collateral stays in the ActivePool, but it is excluded here so the system \n    * can take snapshots before the partially liquidated trove's stake is updated (based on these snapshots). This ensures\n    * the partial's new stake doesn't double-count its own remaining collateral.\n    *\n    */\n    function _updateSystemSnapshots_excludeCollRemainder(uint _collRemainder) internal {\n        totalStakesSnapshot = totalStakes;\n\n        uint activeColl = activePool.getETH();\n        uint liquidatedColl = defaultPool.getETH();\n        totalCollateralSnapshot = activeColl.sub(_collRemainder).add(liquidatedColl);\n    }\n\n    // Push the owner's address to the Trove owners list, and record the corresponding array index on the Trove struct\n    function addTroveOwnerToArray(address _borrower) external override returns (uint index) {\n        _requireCallerIsBorrowerOperations();\n        return _addTroveOwnerToArray(_borrower);\n    }\n\n    function _addTroveOwnerToArray(address _borrower) internal returns (uint128 index) {\n        require(TroveOwners.length < 2**128 - 1, \"TroveManager: TroveOwners array has maximum size of 2^128 - 1\");\n\n        // Push the Troveowner to the array\n        TroveOwners.push(_borrower);\n\n        // Record the index of the new Troveowner on their Trove struct\n        index = uint128(TroveOwners.length.sub(1));\n        Troves[_borrower].arrayIndex = index;\n\n        return index;\n    }\n\n    /* \n    * Remove a Trove owner from the TroveOwners array, not preserving array order. Removing owner 'B' does the following:\n    * [A B C D E] => [A E C D], and updates E's Trove struct to point to its new array index. \n    */\n    function _removeTroveOwner(address _borrower, uint TroveOwnersArrayLength) internal {\n        require(Troves[_borrower].status == Status.closed, \"TroveManager: Trove is still active\");\n\n        uint128 index = Troves[_borrower].arrayIndex;\n        uint length = TroveOwnersArrayLength;\n        uint idxLast = length.sub(1);\n\n        assert(index <= idxLast);\n\n        address addressToMove = TroveOwners[idxLast];\n\n        TroveOwners[index] = addressToMove;\n        Troves[addressToMove].arrayIndex = index;\n        TroveOwners.pop();\n    }\n\n    // --- Recovery Mode and TCR functions ---\n\n    function checkRecoveryMode() public view override returns (bool) {\n        uint TCR = getTCR();\n\n        if (TCR < CCR) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    // Check whether or not the system *would be* in Recovery Mode, given an ETH:USD price, and the entire system coll and debt.\n    function _checkPotentialRecoveryMode(\n        uint _entireSystemColl,\n        uint _entireSystemDebt,\n        uint _price\n    )\n        internal\n        pure\n    returns (bool)\n    {\n        uint TCR = LiquityMath._computeCR(_entireSystemColl, _entireSystemDebt, _price);\n        if (TCR < CCR) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n    // SWC-135-Code With No Effects: L1276-L1284\n    function getTCR() public view override returns (uint TCR) {\n        uint price = priceFeed.getPrice();\n        uint entireSystemColl = getEntireSystemColl();\n        uint entireSystemDebt = getEntireSystemDebt();\n\n        TCR = LiquityMath._computeCR(entireSystemColl, entireSystemDebt, price);\n\n        return TCR;\n    }\n    // SWC-135-Code With No Effects: L1286-L1291\n    function getEntireSystemColl() public view override returns (uint entireSystemColl) {\n        uint activeColl = activePool.getETH();\n        uint liquidatedColl = defaultPool.getETH();\n\n        return activeColl.add(liquidatedColl);\n    }\n\n    function getEntireSystemDebt() public view override returns (uint entireSystemDebt) {\n        uint activeDebt = activePool.getLUSDDebt();\n        uint closedDebt = defaultPool.getLUSDDebt();\n\n        return activeDebt.add(closedDebt);\n    }\n\n    // --- Redemption fee functions ---\n\n    /* \n    * This function has two impacts on the baseRate state variable:\n    * 1) decays the baseRate based on time passed since last redemption or LUSD borrowing operation.\n    * then,\n    * 2) increases the baseRate based on the amount redeemed, as a proportion of total supply\n    */\n    function _updateBaseRateFromRedemption(uint _ETHDrawn,  uint _price) internal returns (uint) {\n        uint decayedBaseRate = _calcDecayedBaseRate();\n\n        uint activeDebt = activePool.getLUSDDebt();\n        uint closedDebt = defaultPool.getLUSDDebt();\n        uint totalLUSDSupply = activeDebt.add(closedDebt);\n\n        /* Convert the drawn ETH back to LUSD at face value rate (1 LUSD:1 USD), in order to get\n        * the fraction of total supply that was redeemed at face value. */\n        uint redeemedLUSDFraction = _ETHDrawn.mul(_price).div(totalLUSDSupply);\n\n        uint newBaseRate = decayedBaseRate.add(redeemedLUSDFraction.div(BETA));\n\n        // Update the baseRate state variable\n        baseRate = newBaseRate < 1e18 ? newBaseRate : 1e18;  // cap baseRate at a maximum of 100%\n        assert(baseRate <= 1e18 && baseRate > 0); // Base rate is always non-zero after redemption\n\n        _updateLastFeeOpTime();\n\n        return baseRate;\n    }\n\n    function _getRedemptionFee(uint _ETHDrawn) internal view returns (uint) {\n       return baseRate.mul(_ETHDrawn).div(1e18);\n    }\n\n    // --- Borrowing fee functions ---\n\n    function getBorrowingFee(uint _LUSDDebt) external view override returns (uint) {\n        return _LUSDDebt.mul(baseRate).div(1e18);\n    }\n\n    // Updates the baseRate state variable based on time elapsed since the last redemption or LUSD borrowing operation.\n    function decayBaseRateFromBorrowing() external override {\n        _requireCallerIsBorrowerOperations();\n\n        baseRate = _calcDecayedBaseRate();\n        assert(baseRate <= 1e18);  // The baseRate can decay to 0\n\n        _updateLastFeeOpTime();\n    }\n\n    // --- Internal fee functions ---\n\n    // Update the last fee operation time only if time passed >= decay interval. This prevents base rate griefing.\n    function _updateLastFeeOpTime() internal {\n        uint timePassed = block.timestamp.sub(lastFeeOperationTime);\n\n        if (timePassed >= SECONDS_IN_ONE_MINUTE) {\n            lastFeeOperationTime = block.timestamp;\n        }\n    }\n\n    function _calcDecayedBaseRate() internal view returns (uint) {\n        uint minutesPassed = _minutesPassedSinceLastFeeOp();\n        uint decayFactor = LiquityMath._decPow(MINUTE_DECAY_FACTOR, minutesPassed);\n\n        return baseRate.mul(decayFactor).div(1e18);\n    }\n\n    function _minutesPassedSinceLastFeeOp() internal view returns (uint) {\n        return (block.timestamp.sub(lastFeeOperationTime)).div(SECONDS_IN_ONE_MINUTE);\n    }\n\n    // --- 'require' wrapper functions ---\n\n    function _requireCallerIsBorrowerOperations() internal view {\n        require(msg.sender == borrowerOperationsAddress, \"TroveManager: Caller is not the BorrowerOperations contract\");\n    }\n\n    function _requireTroveisActive(address _borrower) internal view {\n        require(Troves[_borrower].status == Status.active, \"TroveManager: Trove does not exist or is closed\");\n    }\n\n    function _requireLUSDBalanceCoversRedemption(address _redeemer, uint _amount) internal view {\n        require(lusdToken.balanceOf(_redeemer) >= _amount, \"TroveManager: Requested redemption amount must be <= user's LUSD token balance\");\n    }\n\n    function _requireMoreThanOneTroveInSystem(uint TroveOwnersArrayLength) internal view {\n        require (TroveOwnersArrayLength > 1 && sortedTroves.getSize() > 1, \"TroveManager: Only one trove in the system\");\n    }\n\n    function _requireAmountGreaterThanZero(uint _amount) internal pure {\n        require(_amount > 0, \"TroveManager: Amount must be greater than zero\");\n    }\n\n    // --- Trove property getters ---\n\n    function getTroveStatus(address _borrower) external view override returns (uint) {\n        return uint(Troves[_borrower].status);\n    }\n\n    function getTroveStake(address _borrower) external view override returns (uint) {\n        return Troves[_borrower].stake;\n    }\n\n    function getTroveDebt(address _borrower) external view override returns (uint) {\n        return Troves[_borrower].debt;\n    }\n\n    function getTroveColl(address _borrower) external view override returns (uint) {\n        return Troves[_borrower].coll;\n    }\n\n    // --- Trove property setters, called by BorrowerOperations ---\n\n    function setTroveStatus(address _borrower, uint _num) external override {\n        _requireCallerIsBorrowerOperations();\n        Troves[_borrower].status = Status(_num);\n    }\n\n    function increaseTroveColl(address _borrower, uint _collIncrease) external override returns (uint) {\n        _requireCallerIsBorrowerOperations();\n        uint newColl = Troves[_borrower].coll.add(_collIncrease);\n        Troves[_borrower].coll = newColl;\n        return newColl;\n    }\n\n    function decreaseTroveColl(address _borrower, uint _collDecrease) external override returns (uint) {\n        _requireCallerIsBorrowerOperations();\n        uint newColl = Troves[_borrower].coll.sub(_collDecrease);\n        Troves[_borrower].coll = newColl;\n        return newColl;\n    }\n\n    function increaseTroveDebt(address _borrower, uint _debtIncrease) external override returns (uint) {\n        _requireCallerIsBorrowerOperations();\n        uint newDebt = Troves[_borrower].debt.add(_debtIncrease);\n        Troves[_borrower].debt = newDebt;\n        return newDebt;\n    }\n\n    function decreaseTroveDebt(address _borrower, uint _debtDecrease) external override returns (uint) {\n        _requireCallerIsBorrowerOperations();\n        uint newDebt = Troves[_borrower].debt.sub(_debtDecrease);\n        Troves[_borrower].debt = newDebt;\n        return newDebt;\n    }\n}",
        "function": "setTroveStatus(address,uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-Liquity/dev-f0df3efa5a5f05b205752184cfce107c5bd6e06c/packages/contracts/contracts/TroveManager.sol",
        "vulnerability": "Exception State (SWC 110)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract TroveManager is LiquityBase, Ownable, ITroveManager {\n\n    // --- Connected contract declarations ---\n\n    address public borrowerOperationsAddress;\n\n    IPool public activePool;\n\n    IPool public defaultPool;\n\n    IStabilityPool public stabilityPool;\n\n    ICollSurplusPool collSurplusPool;\n\n    ILUSDToken public lusdToken;\n\n    IPriceFeed public priceFeed;\n\n    ILQTYStaking public lqtyStaking;\n    address public lqtyStakingAddress;\n\n    // A doubly linked list of Troves, sorted by their sorted by their collateral ratios\n    ISortedTroves public sortedTroves;\n\n    // --- Data structures ---\n\n    uint constant public SECONDS_IN_ONE_MINUTE = 60;\n    uint constant public MINUTE_DECAY_FACTOR = 999832508430720967;  // 18 digit decimal. Corresponds to an hourly decay factor of 0.99\n\n    /* \n    * BETA: 18 digit decimal. Parameter by which to divide the redeemed fraction, in order to calc the new base rate from a redemption. \n    * Corresponds to (1 / ALPHA) in the white paper. \n    */\n    uint constant public BETA = 2;\n\n    uint public baseRate;\n\n    // The timestamp of the latest fee operation (redemption or new LUSD issuance) \n    uint public lastFeeOperationTime;\n\n    enum Status { nonExistent, active, closed }\n\n    // Store the necessary data for a trove\n    struct Trove {\n        uint debt;\n        uint coll;\n        uint stake;\n        Status status;\n        uint128 arrayIndex;\n    }\n\n    mapping (address => Trove) public Troves;\n\n    uint public totalStakes;\n\n    // Snapshot of the value of totalStakes, taken immediately after the latest liquidation\n    uint public totalStakesSnapshot;\n\n    // Snapshot of the total collateral across the ActivePool and DefaultPool, immediately after the latest liquidation.\n    uint public totalCollateralSnapshot;\n\n    /*\n    * L_ETH and L_LUSDDebt track the sums of accumulated liquidation rewards per unit staked. During its lifetime, each stake earns:\n    *\n    * An ETH gain of ( stake * [L_ETH - L_ETH(0)] )\n    * A LUSDDebt increase  of ( stake * [L_LUSDDebt - L_LUSDDebt(0)] )\n    *\n    * Where L_ETH(0) and L_LUSDDebt(0) are snapshots of L_ETH and L_LUSDDebt for the active Trove taken at the instant the stake was made\n    */\n    uint public L_ETH;\n    uint public L_LUSDDebt;\n\n    // Map addresses with active troves to their RewardSnapshot\n    mapping (address => RewardSnapshot) public rewardSnapshots;\n\n    // Object containing the ETH and LUSD snapshots for a given active trove\n    struct RewardSnapshot { uint ETH; uint LUSDDebt;}\n\n    // Array of all active trove addresses - used to to compute an approximate hint off-chain, for the sorted list insertion\n    address[] public TroveOwners;\n\n    // Error trackers for the trove redistribution calculation\n    uint public lastETHError_Redistribution;\n    uint public lastLUSDDebtError_Redistribution;\n\n    /* \n    * --- Variable container structs for liquidations ---\n    *\n    * These structs are used to hold, return and assign variables inside the liquidation functions,\n    * in order to avoid the error: \"CompilerError: Stack too deep\". \n    **/\n\n    struct LocalVariables_OuterLiquidationFunction {\n        uint price;\n        uint LUSDInStabPool;\n        bool recoveryModeAtStart;\n        uint liquidatedDebt;\n        uint liquidatedColl;\n    }\n\n    struct LocalVariables_InnerSingleLiquidateFunction {\n        uint collToLiquidate;\n        uint pendingDebtReward;\n        uint pendingCollReward;\n    }\n\n    struct LocalVariables_LiquidationSequence {\n        uint remainingLUSDInStabPool;\n        uint i;\n        uint ICR;\n        address user;\n        bool backToNormalMode;\n        uint entireSystemDebt;\n        uint entireSystemColl;\n    }\n\n    struct LiquidationValues {\n        uint entireTroveDebt;\n        uint entireTroveColl;\n        uint collGasCompensation;\n        uint LUSDGasCompensation;\n        uint debtToOffset;\n        uint collToSendToSP;\n        uint debtToRedistribute;\n        uint collToRedistribute;\n        address partialAddr;\n        uint partialNewDebt;\n        uint partialNewColl;\n        address partialUpperHint;\n        address partialLowerHint;\n    }\n\n    struct LiquidationTotals {\n        uint totalCollInSequence;\n        uint totalDebtInSequence;\n        uint totalCollGasCompensation;\n        uint totalLUSDGasCompensation;\n        uint totalDebtToOffset;\n        uint totalCollToSendToSP;\n        uint totalDebtToRedistribute;\n        uint totalCollToRedistribute;\n        address partialAddr;\n        uint partialNewDebt;\n        uint partialNewColl;\n        address partialUpperHint;\n        address partialLowerHint;\n    }\n\n    // --- Variable container structs for redemptions ---\n\n    struct RedemptionTotals {\n        uint totalLUSDToRedeem;\n        uint totalETHDrawn;\n        uint ETHFee;\n        uint ETHToSendToRedeemer;\n        uint decayedBaseRate;\n    }\n\n    struct SingleRedemptionValues {\n        uint LUSDLot;\n        uint ETHLot;\n    }\n\n    // --- Events ---\n\n    event Liquidation(uint _liquidatedDebt, uint _liquidatedColl, uint _collGasCompensation, uint _LUSDGasCompensation);\n    event Redemption(uint _attemptedLUSDAmount, uint _actualLUSDAmount, uint _ETHSent, uint _ETHFee);\n\n    enum TroveManagerOperation {\n        applyPendingRewards,\n        liquidateInNormalMode,\n        liquidateInRecoveryMode,\n        partiallyLiquidateInRecoveryMode,\n        redeemCollateral\n    }\n\n    event TroveCreated(address indexed _borrower, uint _arrayIndex);\n    event TroveUpdated(address indexed _borrower, uint _debt, uint _coll, uint _stake, TroveManagerOperation _operation);\n    event TroveLiquidated(address indexed _borrower, uint _debt, uint _coll, TroveManagerOperation _operation);\n\n    // --- Dependency setter ---\n\n    function setAddresses(\n        address _borrowerOperationsAddress,\n        address _activePoolAddress,\n        address _defaultPoolAddress,\n        address _stabilityPoolAddress,\n        address _collSurplusPoolAddress,\n        address _priceFeedAddress,\n        address _lusdTokenAddress,\n        address _sortedTrovesAddress,\n        address _lqtyStakingAddress\n    )\n        external\n        override\n        onlyOwner\n    {\n        borrowerOperationsAddress = _borrowerOperationsAddress;\n        activePool = IPool(_activePoolAddress);\n        defaultPool = IPool(_defaultPoolAddress);\n        stabilityPool = IStabilityPool(_stabilityPoolAddress);\n        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);\n        priceFeed = IPriceFeed(_priceFeedAddress);\n        lusdToken = ILUSDToken(_lusdTokenAddress);\n        sortedTroves = ISortedTroves(_sortedTrovesAddress);\n        lqtyStakingAddress = _lqtyStakingAddress;\n        lqtyStaking = ILQTYStaking(_lqtyStakingAddress);\n\n        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);\n        emit ActivePoolAddressChanged(_activePoolAddress);\n        emit DefaultPoolAddressChanged(_defaultPoolAddress);\n        emit StabilityPoolAddressChanged(_stabilityPoolAddress);\n        emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);\n        emit PriceFeedAddressChanged(_priceFeedAddress);\n        emit LUSDTokenAddressChanged(_lusdTokenAddress);\n        emit SortedTrovesAddressChanged(_sortedTrovesAddress);\n        emit LQTYStakingAddressChanged(_lqtyStakingAddress);\n\n        _renounceOwnership();\n    }\n\n    // --- Getters ---\n\n    function getTroveOwnersCount() external view override returns (uint) {\n        return TroveOwners.length;\n    }\n\n    function getTroveFromTroveOwnersArray(uint _index) external view override returns (address) {\n        return TroveOwners[_index];\n    }\n\n    // --- Trove Liquidation functions ---\n\n    // Single liquidation function. Closes the trove if its ICR is lower than the minimum collateral ratio. \n    function liquidate(address _borrower) external override {\n        _requireTroveisActive(_borrower);\n\n        address[] memory borrowers = new address[](1);\n        borrowers[0] = _borrower;\n        batchLiquidateTroves(borrowers);\n    }\n\n    // --- Inner single liquidation functions ---\n\n    // Liquidate one trove, in Normal Mode.\n    function _liquidateNormalMode(address _borrower, uint _LUSDInStabPool) internal returns (LiquidationValues memory V) {\n        LocalVariables_InnerSingleLiquidateFunction memory L;\n\n        (V.entireTroveDebt,\n        V.entireTroveColl,\n        L.pendingDebtReward,\n        L.pendingCollReward) = getEntireDebtAndColl(_borrower);\n\n        _movePendingTroveRewardsToActivePool(L.pendingDebtReward, L.pendingCollReward);\n        _removeStake(_borrower);\n\n        V.collGasCompensation = _getCollGasCompensation(V.entireTroveColl);\n        V.LUSDGasCompensation = LUSD_GAS_COMPENSATION;\n        uint collToLiquidate = V.entireTroveColl.sub(V.collGasCompensation);\n\n        (V.debtToOffset,\n        V.collToSendToSP,\n        V.debtToRedistribute,\n        V.collToRedistribute) = _getOffsetAndRedistributionVals(V.entireTroveDebt, collToLiquidate, _LUSDInStabPool);\n\n        _closeTrove(_borrower);\n        emit TroveLiquidated(_borrower, V.entireTroveDebt, V.entireTroveColl, TroveManagerOperation.liquidateInNormalMode);\n\n        return V;\n    }\n\n    // Liquidate one trove, in Recovery Mode.\n    function _liquidateRecoveryMode(address _borrower, uint _ICR, uint _LUSDInStabPool, uint _TCR) internal returns (LiquidationValues memory V) {\n        LocalVariables_InnerSingleLiquidateFunction memory L;\n        \n        if (TroveOwners.length <= 1) { return V; } // don't liquidate if last trove\n\n        (V.entireTroveDebt,\n        V.entireTroveColl,\n        L.pendingDebtReward,\n        L.pendingCollReward) = getEntireDebtAndColl(_borrower);\n\n        _movePendingTroveRewardsToActivePool(L.pendingDebtReward, L.pendingCollReward);\n\n        V.collGasCompensation = _getCollGasCompensation(V.entireTroveColl);\n        // In case of a partial liquidation, V.LUSDGasCompensation will be overwritten to zero, in the third branch below\n        V.LUSDGasCompensation = LUSD_GAS_COMPENSATION;\n        L.collToLiquidate = V.entireTroveColl.sub(V.collGasCompensation);\n\n        // If ICR <= 100%, purely redistribute the Trove across all active Troves\n        if (_ICR <= _100pct) {\n            _removeStake(_borrower);\n\n            V.debtToOffset = 0;\n            V.collToSendToSP = 0;\n            V.debtToRedistribute = V.entireTroveDebt;\n            V.collToRedistribute = L.collToLiquidate;\n\n            _closeTrove(_borrower);\n            emit TroveLiquidated(_borrower, V.entireTroveDebt, V.entireTroveColl, TroveManagerOperation.liquidateInRecoveryMode);\n\n        // If 100% < ICR < MCR, offset as much as possible, and redistribute the remainder\n        } else if ((_ICR > _100pct) && (_ICR < MCR)) {\n            _removeStake(_borrower);\n\n            (V.debtToOffset,\n            V.collToSendToSP,\n            V.debtToRedistribute,\n            V.collToRedistribute) = _getOffsetAndRedistributionVals(V.entireTroveDebt, L.collToLiquidate, _LUSDInStabPool);\n\n            _closeTrove(_borrower);\n            emit TroveLiquidated(_borrower, V.entireTroveDebt, V.entireTroveColl, TroveManagerOperation.liquidateInRecoveryMode);\n\n        /* \n        * If 110% <= ICR < current TCR (accounting for the preceding liquidations in the current sequence)\n        * and there is LUSD in the Stability Pool, only offset it as much as possible, with no redistribution.\n        */\n        } else if ((_ICR >= MCR) && (_ICR < _TCR)) {\n            assert(_LUSDInStabPool != 0);\n\n            _removeStake(_borrower);\n            \n            V = _getFullOrPartialOffsetVals(_borrower, V.entireTroveDebt, V.entireTroveColl, _LUSDInStabPool);\n\n            _closeTrove(_borrower);\n        }\n        else if (_ICR >= _TCR) {\n            LiquidationValues memory zeroVals;\n            return zeroVals;\n        }\n\n        return V;\n    }\n\n    /* In a full liquidation, returns the values for a trove's coll and debt to be offset, and coll and debt to be \n    * redistributed to active troves. \n    */\n    function _getOffsetAndRedistributionVals\n    (\n        uint _debt,\n        uint _coll,\n        uint _LUSDInStabPool\n    )\n        internal\n        pure\n        returns (uint debtToOffset, uint collToSendToSP, uint debtToRedistribute, uint collToRedistribute)\n    {\n        if (_LUSDInStabPool > 0) {\n        /* \n        * Offset as much debt & collateral as possible against the Stability Pool, and redistribute the remainder\n        * between all active troves.\n        *\n        *  If the trove's debt is larger than the deposited LUSD in the Stability Pool:\n        *\n        *  - Offset an amount of the trove's debt equal to the LUSD in the Stability Pool\n        *  - Send a fraction of the trove's collateral to the Stability Pool, equal to the fraction of its offset debt\n        *\n        */\n            debtToOffset = LiquityMath._min(_debt, _LUSDInStabPool);\n            collToSendToSP = _coll.mul(debtToOffset).div(_debt);\n            debtToRedistribute = _debt.sub(debtToOffset);\n            collToRedistribute = _coll.sub(collToSendToSP);\n        } else {\n            debtToOffset = 0;\n            collToSendToSP = 0;\n            debtToRedistribute = _debt;\n            collToRedistribute = _coll;\n        }\n    }\n\n    /*\n    *  If it is a full offset, get its offset coll/debt and ETH gas comp, and close the trove.\n    *\n    * If it is a partial liquidation, get its offset coll/debt and ETH gas comp, and its new coll/debt, and its re-insertion hints.\n    */\n    function _getFullOrPartialOffsetVals\n    (\n        address _borrower,\n        uint _entireTroveDebt,\n        uint _entireTroveColl,\n        uint _LUSDInStabPool\n    )\n        internal\n        returns (LiquidationValues memory V)\n    {\n        V.entireTroveDebt = _entireTroveDebt;\n        V.entireTroveColl = _entireTroveColl;\n\n        // When Stability Pool can fully absorb the trove's debt, perform a full offset\n        if (_entireTroveDebt <= _LUSDInStabPool) {\n            V.collGasCompensation = _getCollGasCompensation(_entireTroveColl);\n            V.LUSDGasCompensation = LUSD_GAS_COMPENSATION;\n\n            V.debtToOffset = _entireTroveDebt;\n            V.collToSendToSP = _entireTroveColl.sub(V.collGasCompensation);\n            V.debtToRedistribute = 0;\n            V.collToRedistribute = 0;\n\n            emit TroveLiquidated(_borrower, _entireTroveDebt, _entireTroveColl, TroveManagerOperation.liquidateInRecoveryMode);\n        }\n        /* \n        * When trove's debt is greater than the Stability Pool, perform a partial liquidation: offset as much as possible,\n        * and do not redistribute the remainder. The trove remains active, with a reduced collateral and debt.\n        *\n        * ETH gas compensation is based on and drawn from the collateral fraction that corresponds to the partial offset. \n        * LUSD gas compensation is left untouched. \n        *\n        * Since ETH gas comp is drawn purely from the *liquidated* portion, the trove is left with the same ICR as before the \n        * liquidation.\n        */\n        else if (_entireTroveDebt > _LUSDInStabPool) {\n            // Remaining debt in the trove is lower-bounded by the trove's gas compensation\n            V.partialNewDebt = LiquityMath._max(_entireTroveDebt.sub(_LUSDInStabPool), LUSD_GAS_COMPENSATION);\n          \n            V.debtToOffset = _entireTroveDebt.sub(V.partialNewDebt);\n\n            uint collFraction = _entireTroveColl.mul(V.debtToOffset).div(_entireTroveDebt);\n            V.collGasCompensation = _getCollGasCompensation(collFraction);\n          \n            V.LUSDGasCompensation = 0;  // LUSD gas compensation remains untouched\n\n            V.collToSendToSP = collFraction.sub(V.collGasCompensation);\n            V.collToRedistribute = 0;\n            V.debtToRedistribute = 0;\n\n            V.partialAddr = _borrower;\n            V.partialNewColl = _entireTroveColl.sub(collFraction);\n\n            // Get the partial trove's neighbours, so we can re-insert it later to the same position\n            V.partialUpperHint = sortedTroves.getPrev(_borrower);  \n            V.partialLowerHint = sortedTroves.getNext(_borrower);\n        }\n    }\n\n    /* \n    * Liquidate a sequence of troves. Closes a maximum number of n under-collateralized Troves,\n    * starting from the one with the lowest collateral ratio in the system, and moving upwards\n    */\n    function liquidateTroves(uint _n) external override {\n        LocalVariables_OuterLiquidationFunction memory L;\n\n        LiquidationTotals memory T;\n\n        L.price = priceFeed.getPrice();\n        L.LUSDInStabPool = stabilityPool.getTotalLUSDDeposits();\n        L.recoveryModeAtStart = checkRecoveryMode();\n\n        // Perform the appropriate liquidation sequence - tally the values, and obtain their totals\n        if (L.recoveryModeAtStart == true) {\n            T = _getTotalsFromLiquidateTrovesSequence_RecoveryMode(L.price, L.LUSDInStabPool, _n);\n        } else if (L.recoveryModeAtStart == false) {\n            T = _getTotalsFromLiquidateTrovesSequence_NormalMode(L.price, L.LUSDInStabPool, _n);\n        }\n\n        // Move liquidated ETH and LUSD to the appropriate pools\n        stabilityPool.offset(T.totalDebtToOffset, T.totalCollToSendToSP);\n        _redistributeDebtAndColl(T.totalDebtToRedistribute, T.totalCollToRedistribute);\n\n        // Update system snapshots and the final partially liquidated trove, if there is one\n        _updateSystemSnapshots_excludeCollRemainder(T.partialNewColl.add(T.totalCollGasCompensation));\n        _updatePartiallyLiquidatedTrove(T.partialAddr, T.partialNewDebt, T.partialNewColl, T.partialUpperHint, T. partialLowerHint, L.price);\n\n        L.liquidatedDebt = T.totalDebtInSequence.sub(T.partialNewDebt);\n        L.liquidatedColl = T.totalCollInSequence.sub(T.totalCollGasCompensation).sub(T.partialNewColl);\n        emit Liquidation(L.liquidatedDebt, L.liquidatedColl, T.totalCollGasCompensation, T.totalLUSDGasCompensation);\n\n        // Send gas compensation to caller\n        _sendGasCompensation(msg.sender, T.totalLUSDGasCompensation, T.totalCollGasCompensation);\n    }\n\n    /*\n    * This function is used when the liquidateTroves sequence starts during Recovery Mode. However, it\n    * handle the case where the system *leaves* Recovery Mode, part way through the liquidation sequence\n    */\n    function _getTotalsFromLiquidateTrovesSequence_RecoveryMode\n    (\n        uint _price,\n        uint _LUSDInStabPool,\n        uint _n\n    )\n        internal\n        returns(LiquidationTotals memory T)\n    {\n        LocalVariables_LiquidationSequence memory L;\n        LiquidationValues memory V;\n\n        L.remainingLUSDInStabPool = _LUSDInStabPool;\n        L.backToNormalMode = false;\n        L.entireSystemDebt = activePool.getLUSDDebt().add(defaultPool.getLUSDDebt());\n        L.entireSystemColl = activePool.getETH().add(defaultPool.getETH());\n\n        L.i = 0;\n        while (L.i < _n) {\n            L.user = sortedTroves.getLast();\n            L.ICR = getCurrentICR(L.user, _price);\n\n            if (L.backToNormalMode == false) {\n                // Break the loop if ICR is greater than MCR and Stability Pool is empty\n                if (L.ICR >= MCR && L.remainingLUSDInStabPool == 0) { break; }\n\n                uint TCR = LiquityMath._computeCR(L.entireSystemColl, L.entireSystemDebt, _price);\n        \n                V = _liquidateRecoveryMode(L.user, L.ICR, L.remainingLUSDInStabPool, TCR);\n\n                // Update aggregate trackers\n                L.remainingLUSDInStabPool = L.remainingLUSDInStabPool.sub(V.debtToOffset);\n                L.entireSystemDebt = L.entireSystemDebt.sub(V.debtToOffset);\n                L.entireSystemColl = L.entireSystemColl.sub(V.collToSendToSP);\n\n                // Add liquidation values to their respective running totals\n                T = _addLiquidationValuesToTotals(T, V);\n\n                // Break the loop if it was a partial liquidation\n                if (V.partialAddr != address(0)) {break;}\n\n                L.backToNormalMode = !_checkPotentialRecoveryMode(L.entireSystemColl, L.entireSystemDebt, _price);\n            }\n            else if (L.backToNormalMode == true && L.ICR < MCR) {\n                V = _liquidateNormalMode(L.user, L.remainingLUSDInStabPool);\n\n                L.remainingLUSDInStabPool = L.remainingLUSDInStabPool.sub(V.debtToOffset);\n\n                // Add liquidation values to their respective running totals\n                T = _addLiquidationValuesToTotals(T, V);\n\n            }  else break;  // break if the loop reaches a Trove with ICR >= MCR\n\n            // Break the loop if it reaches the first Trove in the sorted list\n            if (L.user == sortedTroves.getFirst()) { break; }\n\n            L.i++;\n        }\n    }\n\n    function _getTotalsFromLiquidateTrovesSequence_NormalMode\n    (\n        uint _price,\n        uint _LUSDInStabPool,\n        uint _n\n    )\n        internal\n        returns(LiquidationTotals memory T)\n    {\n        LocalVariables_LiquidationSequence memory L;\n        LiquidationValues memory V;\n\n        L.remainingLUSDInStabPool = _LUSDInStabPool;\n\n        L.i = 0;\n        while (L.i < _n) {\n            L.user = sortedTroves.getLast();\n            L.ICR = getCurrentICR(L.user, _price);\n\n            if (L.ICR < MCR) {\n                V = _liquidateNormalMode(L.user, L.remainingLUSDInStabPool);\n\n                L.remainingLUSDInStabPool = L.remainingLUSDInStabPool.sub(V.debtToOffset);\n\n                // Add liquidation values to their respective running totals\n                T = _addLiquidationValuesToTotals(T, V);\n\n            } else break;  // break if the loop reaches a Trove with ICR >= MCR\n\n            // Break the loop if it reaches the first Trove in the sorted list\n            if (L.user == sortedTroves.getFirst()) { break; }\n            L.i++;\n        }\n    }\n\n    /* \n    * Attempt to liquidate a custom list of troves provided by the caller. The liquidation sequence stops if\n    * a partial liquidation is performed, so it's up to the caller to order the troves in the _troveArray parameter.\n    */\n    function batchLiquidateTroves(address[] memory _troveArray) public override {\n        require(_troveArray.length != 0, \"TroveManager: Calldata address array must not be empty\");\n\n        LocalVariables_OuterLiquidationFunction memory L;\n        LiquidationTotals memory T;\n\n        L.price = priceFeed.getPrice();\n        L.LUSDInStabPool = stabilityPool.getTotalLUSDDeposits();\n        L.recoveryModeAtStart = checkRecoveryMode();\n\n        // Perform the appropriate liquidation sequence - tally values and obtain their totals.\n        if (L.recoveryModeAtStart == true) {\n           T = _getTotalFromBatchLiquidate_RecoveryMode(L.price, L.LUSDInStabPool, _troveArray);\n        } else if (L.recoveryModeAtStart == false) {\n            T = _getTotalsFromBatchLiquidate_NormalMode(L.price, L.LUSDInStabPool, _troveArray);\n        }\n\n        // Move liquidated ETH and LUSD to the appropriate pools\n        stabilityPool.offset(T.totalDebtToOffset, T.totalCollToSendToSP);\n        _redistributeDebtAndColl(T.totalDebtToRedistribute, T.totalCollToRedistribute);\n\n        // Update system snapshots and the final partially liquidated trove, if there is one\n        _updateSystemSnapshots_excludeCollRemainder(T.partialNewColl.add(T.totalCollGasCompensation));\n        _updatePartiallyLiquidatedTrove(T.partialAddr, T.partialNewDebt, T.partialNewColl, T.partialUpperHint, T. partialLowerHint, L.price);\n\n        L.liquidatedDebt = T.totalDebtInSequence.sub(T.partialNewDebt);\n        L.liquidatedColl = T.totalCollInSequence.sub(T.totalCollGasCompensation).sub(T.partialNewColl);\n        emit Liquidation(L.liquidatedDebt, L.liquidatedColl, T.totalCollGasCompensation, T.totalLUSDGasCompensation);\n\n        // Send gas compensation to caller\n        _sendGasCompensation(msg.sender, T.totalLUSDGasCompensation, T.totalCollGasCompensation);\n    }\n\n    /* \n    * This function is used when the batch liquidation sequence starts during Recovery Mode. However, it\n    * handle the case where the system *leaves* Recovery Mode, part way through the liquidation sequence\n    */\n    function _getTotalFromBatchLiquidate_RecoveryMode\n    (\n        uint _price,\n        uint _LUSDInStabPool,\n        address[] memory _troveArray)\n        internal\n        returns(LiquidationTotals memory T)\n    {\n        LocalVariables_LiquidationSequence memory L;\n        LiquidationValues memory V;\n\n        L.remainingLUSDInStabPool = _LUSDInStabPool;\n        L.backToNormalMode = false;\n        L.entireSystemDebt = activePool.getLUSDDebt().add(defaultPool.getLUSDDebt());\n        L.entireSystemColl = activePool.getETH().add(defaultPool.getETH());\n\n        L.i = 0;\n        for (L.i = 0; L.i < _troveArray.length; L.i++) {\n            L.user = _troveArray[L.i];\n            L.ICR = getCurrentICR(L.user, _price);\n\n            if (L.backToNormalMode == false) {\n\n                // Skip this trove if ICR is greater than MCR and Stability Pool is empty\n                if (L.ICR >= MCR && L.remainingLUSDInStabPool == 0) { continue; }\n\n                uint TCR = LiquityMath._computeCR(L.entireSystemColl, L.entireSystemDebt, _price);\n\n                V = _liquidateRecoveryMode(L.user, L.ICR, L.remainingLUSDInStabPool, TCR);\n\n                // Update aggregate trackers\n                L.remainingLUSDInStabPool = L.remainingLUSDInStabPool.sub(V.debtToOffset);\n                L.entireSystemDebt = L.entireSystemDebt.sub(V.debtToOffset);\n                L.entireSystemColl = L.entireSystemColl.sub(V.collToSendToSP);\n\n                // Add liquidation values to their respective running totals\n                T = _addLiquidationValuesToTotals(T, V);\n\n                // Break the loop if it was a partial liquidation\n                if (V.partialAddr != address(0)) { break; }\n\n                L.backToNormalMode = !_checkPotentialRecoveryMode(L.entireSystemColl, L.entireSystemDebt, _price);\n            }\n\n            else if (L.backToNormalMode == true && L.ICR < MCR) {\n                V = _liquidateNormalMode(L.user, L.remainingLUSDInStabPool);\n                L.remainingLUSDInStabPool = L.remainingLUSDInStabPool.sub(V.debtToOffset);\n\n                // Add liquidation values to their respective running totals\n                T = _addLiquidationValuesToTotals(T, V);\n            }\n        }\n    }\n\n    function _getTotalsFromBatchLiquidate_NormalMode\n    (\n        uint _price,\n        uint _LUSDInStabPool,\n        address[] memory _troveArray\n    )\n        internal\n        returns(LiquidationTotals memory T)\n    {\n        LocalVariables_LiquidationSequence memory L;\n        LiquidationValues memory V;\n\n        L.remainingLUSDInStabPool = _LUSDInStabPool;\n\n        for (L.i = 0; L.i < _troveArray.length; L.i++) {\n            L.user = _troveArray[L.i];\n            L.ICR = getCurrentICR(L.user, _price);\n\n            if (L.ICR < MCR) {\n                V = _liquidateNormalMode(L.user, L.remainingLUSDInStabPool);\n                L.remainingLUSDInStabPool = L.remainingLUSDInStabPool.sub(V.debtToOffset);\n\n                // Add liquidation values to their respective running totals\n                T = _addLiquidationValuesToTotals(T, V);\n            }\n        }\n    }\n\n    // --- Liquidation helper functions ---\n\n    function _addLiquidationValuesToTotals(LiquidationTotals memory T1, LiquidationValues memory V)\n    internal pure returns(LiquidationTotals memory T2) {\n\n        // Tally all the values with their respective running totals\n        T2.totalCollGasCompensation = T1.totalCollGasCompensation.add(V.collGasCompensation);\n        T2.totalLUSDGasCompensation = T1.totalLUSDGasCompensation.add(V.LUSDGasCompensation);\n        T2.totalDebtInSequence = T1.totalDebtInSequence.add(V.entireTroveDebt);\n        T2.totalCollInSequence = T1.totalCollInSequence.add(V.entireTroveColl);\n        T2.totalDebtToOffset = T1.totalDebtToOffset.add(V.debtToOffset);\n        T2.totalCollToSendToSP = T1.totalCollToSendToSP.add(V.collToSendToSP);\n        T2.totalDebtToRedistribute = T1.totalDebtToRedistribute.add(V.debtToRedistribute);\n        T2.totalCollToRedistribute = T1.totalCollToRedistribute.add(V.collToRedistribute);\n\n        // Assign the address of the partially liquidated trove, and its new debt and coll values\n        T2.partialAddr = V.partialAddr;\n        T2.partialNewDebt = V.partialNewDebt;\n        T2.partialNewColl = V.partialNewColl;\n        T2.partialUpperHint = V.partialUpperHint;\n        T2.partialLowerHint = V.partialLowerHint;\n\n        return T2;\n    }\n\n    // Update the properties of the partially liquidated trove, and insert it back to the list\n    function _updatePartiallyLiquidatedTrove\n    (\n        address _borrower, \n        uint _newDebt, \n        uint _newColl, \n        address _upperHint,\n        address _lowerHint,\n        uint _price\n    ) \n        internal \n    {\n        if ( _borrower == address(0)) { return; }\n\n        Troves[_borrower].debt = _newDebt;\n        Troves[_borrower].coll = _newColl;\n        Troves[_borrower].status = Status.active;\n\n        _updateTroveRewardSnapshots(_borrower);\n        _updateStakeAndTotalStakes(_borrower);\n\n        uint ICR = getCurrentICR(_borrower, _price);\n\n        /* \n        * Insert to sorted list and add to TroveOwners array. The partially liquidated trove has the same\n        * ICR as it did before the liquidation, so insertion is O(1): in principle, its ICR does not change.\n        * In practice, due to rounding error, its ICR can change slightly - so re-insert, with its previous neighbours\n        * as hints.\n        */\n        sortedTroves.insert(_borrower, ICR, _price, _upperHint, _lowerHint);\n        _addTroveOwnerToArray(_borrower);\n        emit TroveUpdated(_borrower, _newDebt, _newColl, Troves[_borrower].stake, TroveManagerOperation.partiallyLiquidateInRecoveryMode);\n    }\n\n    function _sendGasCompensation(address _liquidator, uint _LUSD, uint _ETH) internal {\n        if (_LUSD > 0) {\n            lusdToken.returnFromPool(GAS_POOL_ADDRESS, _liquidator, _LUSD);\n        }\n\n        if (_ETH > 0) {\n            activePool.sendETH(_liquidator, _ETH);\n        }\n    }\n\n    // Move a Trove's pending debt and collateral rewards from distributions, from the Default Pool to the Active Pool\n    function _movePendingTroveRewardsToActivePool(uint _LUSD, uint _ETH) internal {\n        defaultPool.decreaseLUSDDebt(_LUSD);\n        activePool.increaseLUSDDebt(_LUSD);\n        defaultPool.sendETH(address(activePool), _ETH);\n    }\n\n    // --- Redemption functions ---\n\n    // Redeem as much collateral as possible from _borrower's Trove in exchange for LUSD up to _maxLUSDamount\n    function _redeemCollateralFromTrove(\n        address _borrower,\n        uint _maxLUSDamount,\n        uint _price,\n        address _partialRedemptionHint,\n        uint _partialRedemptionHintICR\n    )\n        internal returns (SingleRedemptionValues memory V)\n    {\n        // Determine the remaining amount (lot) to be redeemed, capped by the entire debt of the Trove minus the gas compensation\n        V.LUSDLot = LiquityMath._min(_maxLUSDamount, Troves[_borrower].debt.sub(LUSD_GAS_COMPENSATION));\n\n        // Get the ETHLot of equivalent value in USD\n        V.ETHLot = V.LUSDLot.mul(1e18).div(_price);\n\n        // Decrease the debt and collateral of the current Trove according to the LUSD lot and corresponding ETH to send\n        uint newDebt = (Troves[_borrower].debt).sub(V.LUSDLot);\n        uint newColl = (Troves[_borrower].coll).sub(V.ETHLot);\n\n        if (newDebt == LUSD_GAS_COMPENSATION) {\n            // No debt left in the Trove (except for the gas compensation), therefore the trove gets closed\n            _removeStake(_borrower);\n            _closeTrove(_borrower);\n            _redeemCloseTrove(_borrower, LUSD_GAS_COMPENSATION, newColl);\n\n        } else {\n            uint newICR = LiquityMath._computeCR(newColl, newDebt, _price);\n\n            // Check if the provided hint is fresh. If not, we bail since trying to reinsert without a good hint will almost\n            // certainly result in running out of gas.\n            if (newICR != _partialRedemptionHintICR) {\n                V.LUSDLot = 0;\n                V.ETHLot = 0;\n                return V;\n            }\n\n            sortedTroves.reInsert(_borrower, newICR, _price, _partialRedemptionHint, _partialRedemptionHint);\n\n            Troves[_borrower].debt = newDebt;\n            Troves[_borrower].coll = newColl;\n            _updateStakeAndTotalStakes(_borrower);\n        }\n        emit TroveUpdated(\n            _borrower,\n            newDebt, newColl,\n            Troves[_borrower].stake,\n            TroveManagerOperation.redeemCollateral\n        );\n        return V;\n    }\n\n    /* \n    * Called when a full redemption occurs, and closes the trove.\n    * The redeemer swaps (debt - 10) LUSD for (debt - 10) worth of ETH, so the 10 LUSD gas compensation left corresponds to the remaining debt.\n    * In order to close the trove, the 10 LUSD gas compensation is burned, and 10 debt is removed from the active pool.\n    * The debt recorded on the trove's struct is zero'd elswhere, in _closeTrove.\n    * Any surplus ETH left in the trove, is sent to the Coll surplus pool, and can be later claimed by the borrower.\n    */ \n    function _redeemCloseTrove(address _borrower, uint _LUSD, uint _ETH) internal {\n        lusdToken.burn(GAS_POOL_ADDRESS, _LUSD);\n        // Update Active Pool LUSD, and send ETH to account\n        activePool.decreaseLUSDDebt(_LUSD);\n\n        // send ETH from Active Pool to CollSurplus Pool\n        collSurplusPool.accountSurplus(_borrower, _ETH);\n        activePool.sendETH(address(collSurplusPool), _ETH);\n    }\n\n    function _isValidFirstRedemptionHint(address _firstRedemptionHint, uint _price) internal view returns (bool) {\n        if (_firstRedemptionHint == address(0) ||\n            !sortedTroves.contains(_firstRedemptionHint) ||\n            getCurrentICR(_firstRedemptionHint, _price) < MCR\n        ) {\n            return false;\n        }\n\n        address nextTrove = sortedTroves.getNext(_firstRedemptionHint);\n        return nextTrove == address(0) || getCurrentICR(nextTrove, _price) < MCR;\n    }\n\n    /* Send _LUSDamount LUSD to the system and redeem the corresponding amount of collateral from as many Troves as are needed to fill the redemption\n    * request.  Applies pending rewards to a Trove before reducing its debt and coll.\n    *\n    * Note that if _amount is very large, this function can run out of gas, specially if traversed troves are small. This can be easily avoided by \n    * splitting the total _amount in appropriate chunks and calling the function multiple times.\n    * \n    * Param `_maxIterations` can also be provided, so the loop through Troves is capped (if its zero, it will be ignored).This makes it easier to \n    * avoid OOG for the frontend, as only knowing approximately the average cost of an iteration is enough, without needing to know the topology \n    * of the trove list. It also avoids the need to set the cap in stone in the contract, nor doing gas calculations, as both gas price and opcode \n    * costs can vary.\n    * \n    * All Troves that are redeemed from -- with the likely exception of the last one -- will end up with no debt left, therefore they will be closed.\n    * If the last Trove does have some remaining debt, it has a finite ICR, and the reinsertion could be anywhere in the list, therefore it requires a hint. \n    * A frontend should use getRedemptionHints() to calculate what the ICR of this Trove will be after redemption, and pass a hint for its position \n    * in the sortedTroves list along with the ICR value that the hint was found for.\n    * \n    * If another transaction modifies the list between calling getRedemptionHints() and passing the hints to redeemCollateral(), it\n    * is very likely that the last (partially) redeemed Trove would end up with a different ICR than what the hint is for. In this case the\n    * redemption will stop after the last completely redeemed Trove and the sender will keep the remaining LUSD amount, which they can attempt\n    * to redeem later.\n    */\n    function redeemCollateral(\n        uint _LUSDamount,\n        address _firstRedemptionHint,\n        address _partialRedemptionHint,\n        uint _partialRedemptionHintICR,\n        uint _maxIterations\n    )\n        external\n        override\n    {\n        uint activeDebt = activePool.getLUSDDebt();\n        uint defaultedDebt = defaultPool.getLUSDDebt();\n\n        RedemptionTotals memory T;\n\n        _requireAmountGreaterThanZero(_LUSDamount);\n        _requireLUSDBalanceCoversRedemption(msg.sender, _LUSDamount);\n\n        // Confirm redeemer's balance is less than total systemic debt\n        assert(lusdToken.balanceOf(msg.sender) <= (activeDebt.add(defaultedDebt)));\n\n        uint remainingLUSD = _LUSDamount;\n        uint price = priceFeed.getPrice();\n        address currentBorrower;\n\n        if (_isValidFirstRedemptionHint(_firstRedemptionHint, price)) {\n            currentBorrower = _firstRedemptionHint;\n        } else {\n            currentBorrower = sortedTroves.getLast();\n            // Find the first trove with ICR >= MCR\n            // SWC-104-Unchecked Call Return Value: L920\n            while (currentBorrower != address(0) && getCurrentICR(currentBorrower, price) < MCR) {\n                currentBorrower = sortedTroves.getPrev(currentBorrower);\n            }\n        }\n\n        // Loop through the Troves starting from the one with lowest collateral ratio until _amount of LUSD is exchanged for collateral\n        if (_maxIterations == 0) { _maxIterations = uint(-1); }\n        while (currentBorrower != address(0) && remainingLUSD > 0 && _maxIterations > 0) {\n            _maxIterations--;\n            // Save the address of the Trove preceding the current one, before potentially modifying the list\n            address nextUserToCheck = sortedTroves.getPrev(currentBorrower);\n\n            _applyPendingRewards(currentBorrower);\n            SingleRedemptionValues memory V = _redeemCollateralFromTrove(\n                currentBorrower,\n                remainingLUSD,\n                price,\n                _partialRedemptionHint,\n                _partialRedemptionHintICR\n            );\n\n            if (V.LUSDLot == 0) break; // Partial redemption hint got out-of-date, therefore we could not redeem from the last Trove\n\n            T.totalLUSDToRedeem  = T.totalLUSDToRedeem.add(V.LUSDLot);\n            T.totalETHDrawn = T.totalETHDrawn.add(V.ETHLot);\n\n            remainingLUSD = remainingLUSD.sub(V.LUSDLot);\n            currentBorrower = nextUserToCheck;\n        }\n\n        // Decay the baseRate due to time passed, and then increase it according to the size of this redemption\n        _updateBaseRateFromRedemption(T.totalETHDrawn, price);\n\n        // Calculate the ETH fee and send it to the LQTY staking contract\n        T.ETHFee = _getRedemptionFee(T.totalETHDrawn);\n        activePool.sendETH(lqtyStakingAddress, T.ETHFee);\n        lqtyStaking.increaseF_ETH(T.ETHFee);\n\n        T.ETHToSendToRedeemer = T.totalETHDrawn.sub(T.ETHFee);\n\n        // Burn the total LUSD that is cancelled with debt, and send the redeemed ETH to msg.sender\n        _activePoolRedeemCollateral(msg.sender, T.totalLUSDToRedeem, T.ETHToSendToRedeemer);\n\n        emit Redemption(_LUSDamount, T.totalLUSDToRedeem, T.totalETHDrawn, T.ETHFee);\n    }\n\n    // Burn the received LUSD, transfer the redeemed ETH to _redeemer and updates the Active Pool\n    function _activePoolRedeemCollateral(address _redeemer, uint _LUSD, uint _ETH) internal {\n        // Update Active Pool LUSD, and send ETH to account\n        lusdToken.burn(_redeemer, _LUSD);\n        activePool.decreaseLUSDDebt(_LUSD);\n\n        activePool.sendETH(_redeemer, _ETH);\n    }\n\n    // --- Helper functions ---\n\n\n    // Return the current collateral ratio (ICR) of a given Trove. Takes a trove's pending coll and debt rewards from redistributions into account.\n    function getCurrentICR(address _borrower, uint _price) public view override returns (uint) {\n        uint pendingETHReward = getPendingETHReward(_borrower);\n        uint pendingLUSDDebtReward = getPendingLUSDDebtReward(_borrower);\n\n        uint currentETH = Troves[_borrower].coll.add(pendingETHReward);\n        uint currentLUSDDebt = Troves[_borrower].debt.add(pendingLUSDDebtReward);\n\n        uint ICR = LiquityMath._computeCR(currentETH, currentLUSDDebt, _price);\n        return ICR;\n    }\n\n    function applyPendingRewards(address _borrower) external override {\n        _requireCallerIsBorrowerOperations();\n        return _applyPendingRewards(_borrower);\n    }\n\n    // Add the borrowers's coll and debt rewards earned from redistributions, to their Trove\n    function _applyPendingRewards(address _borrower) internal {\n        if (hasPendingRewards(_borrower)) {\n            _requireTroveisActive(_borrower);\n\n            // Compute pending rewards\n            uint pendingETHReward = getPendingETHReward(_borrower);\n            uint pendingLUSDDebtReward = getPendingLUSDDebtReward(_borrower);\n\n            // Apply pending rewards to trove's state\n            Troves[_borrower].coll = Troves[_borrower].coll.add(pendingETHReward);\n            Troves[_borrower].debt = Troves[_borrower].debt.add(pendingLUSDDebtReward);\n\n            _updateTroveRewardSnapshots(_borrower);\n\n            // Transfer from DefaultPool to ActivePool\n            _movePendingTroveRewardsToActivePool(pendingLUSDDebtReward, pendingETHReward);\n\n            emit TroveUpdated(\n                _borrower, \n                Troves[_borrower].debt, \n                Troves[_borrower].coll, \n                Troves[_borrower].stake, \n                TroveManagerOperation.applyPendingRewards\n            );\n        }\n    }\n\n    // Update borrower's snapshots of L_ETH and L_LUSDDebt to reflect the current values\n    function updateTroveRewardSnapshots(address _borrower) external override {\n        _requireCallerIsBorrowerOperations();\n       return _updateTroveRewardSnapshots(_borrower);\n    }\n\n    function _updateTroveRewardSnapshots(address _borrower) internal {\n        rewardSnapshots[_borrower].ETH = L_ETH;\n        rewardSnapshots[_borrower].LUSDDebt = L_LUSDDebt;\n    }\n\n    // Get the borrower's pending accumulated ETH reward, earned by their stake\n    function getPendingETHReward(address _borrower) public view override returns (uint) {\n        uint snapshotETH = rewardSnapshots[_borrower].ETH;\n        uint rewardPerUnitStaked = L_ETH.sub(snapshotETH);\n\n        if ( rewardPerUnitStaked == 0 ) { return 0; }\n\n        uint stake = Troves[_borrower].stake;\n\n        uint pendingETHReward = stake.mul(rewardPerUnitStaked).div(1e18);\n\n        return pendingETHReward;\n    }\n\n     // Get the borrower's pending accumulated LUSD reward, earned by their stake\n    function getPendingLUSDDebtReward(address _borrower) public view override returns (uint) {\n        uint snapshotLUSDDebt = rewardSnapshots[_borrower].LUSDDebt;\n        uint rewardPerUnitStaked = L_LUSDDebt.sub(snapshotLUSDDebt);\n\n        if ( rewardPerUnitStaked == 0 ) { return 0; }\n\n        uint stake =  Troves[_borrower].stake;\n\n        uint pendingLUSDDebtReward = stake.mul(rewardPerUnitStaked).div(1e18);\n\n        return pendingLUSDDebtReward;\n    }\n\n    function hasPendingRewards(address _borrower) public view override returns (bool) {\n        /* \n        * A Trove has pending rewards if its snapshot is less than the current rewards per-unit-staked sum:\n        * this indicates that rewards have occured since the snapshot was made, and the user therefore has\n        * pending rewards \n        */\n        return (rewardSnapshots[_borrower].ETH < L_ETH);\n    }\n\n    // Return the Troves entire debt and coll, including pending rewards from redistributions.\n    function getEntireDebtAndColl(\n        address _borrower\n    )\n        public\n        view\n        override\n        returns (uint debt, uint coll, uint pendingLUSDDebtReward, uint pendingETHReward)\n    {\n        debt = Troves[_borrower].debt;\n        coll = Troves[_borrower].coll;\n\n        pendingLUSDDebtReward = getPendingLUSDDebtReward(_borrower);\n        pendingETHReward = getPendingETHReward(_borrower);\n\n        debt = debt.add(pendingLUSDDebtReward);\n        coll = coll.add(pendingETHReward);\n    }\n\n    function removeStake(address _borrower) external override {\n        _requireCallerIsBorrowerOperations();\n        return _removeStake(_borrower);\n    }\n\n    // Remove borrower's stake from the totalStakes sum, and set their stake to 0\n    function _removeStake(address _borrower) internal {\n        uint stake = Troves[_borrower].stake;\n        totalStakes = totalStakes.sub(stake);\n        Troves[_borrower].stake = 0;\n    }\n\n    function updateStakeAndTotalStakes(address _borrower) external override returns (uint) {\n        _requireCallerIsBorrowerOperations();\n        return _updateStakeAndTotalStakes(_borrower);\n    }\n\n    // Update borrower's stake based on their latest collateral value\n    function _updateStakeAndTotalStakes(address _borrower) internal returns (uint) {\n        uint newStake = _computeNewStake(Troves[_borrower].coll);\n        uint oldStake = Troves[_borrower].stake;\n        Troves[_borrower].stake = newStake;\n        totalStakes = totalStakes.sub(oldStake).add(newStake);\n\n        return newStake;\n    }\n\n    // Calculate a new stake based on the snapshots of the totalStakes and totalCollateral taken at the last liquidation\n    function _computeNewStake(uint _coll) internal view returns (uint) {\n        uint stake;\n        if (totalCollateralSnapshot == 0) {\n            stake = _coll;\n        } else {\n            /*  \n            * The following assert() holds true because:\n            * - The system always contains >= 1 trove \n            * - When we close or liquidate a trove, we redistribute the pending rewards, so if all troves were closed/liquidated, \n            * rewards wouldve been emptied and totalCollateralSnapshot would be zero too.\n            */\n            assert(totalStakesSnapshot > 0);\n            stake = _coll.mul(totalStakesSnapshot).div(totalCollateralSnapshot);\n        }\n        return stake;\n    }\n\n    function _redistributeDebtAndColl(uint _debt, uint _coll) internal {\n        if (_debt == 0) { return; }\n\n        if (totalStakes > 0) {\n            /* \n            * Add distributed coll and debt rewards-per-unit-staked to the running totals.\n            * Division uses a \"feedback\" error correction, to keep the cumulative error in\n            * the  L_ETH and L_LUSDDebt state variables low. \n            */\n            uint ETHNumerator = _coll.mul(1e18).add(lastETHError_Redistribution);\n            uint LUSDDebtNumerator = _debt.mul(1e18).add(lastLUSDDebtError_Redistribution);\n\n            uint ETHRewardPerUnitStaked = ETHNumerator.div(totalStakes);\n            uint LUSDDebtRewardPerUnitStaked = LUSDDebtNumerator.div(totalStakes);\n\n            lastETHError_Redistribution = ETHNumerator.sub(ETHRewardPerUnitStaked.mul(totalStakes));\n            lastLUSDDebtError_Redistribution = LUSDDebtNumerator.sub(LUSDDebtRewardPerUnitStaked.mul(totalStakes));\n\n            L_ETH = L_ETH.add(ETHRewardPerUnitStaked);\n            L_LUSDDebt = L_LUSDDebt.add(LUSDDebtRewardPerUnitStaked);\n        }\n\n        // Transfer coll and debt from ActivePool to DefaultPool\n        activePool.decreaseLUSDDebt(_debt);\n        defaultPool.increaseLUSDDebt(_debt);\n        activePool.sendETH(address(defaultPool), _coll);\n    }\n\n    function closeTrove(address _borrower) external override {\n        _requireCallerIsBorrowerOperations();\n        return _closeTrove(_borrower);\n    }\n\n    function _closeTrove(address _borrower) internal {\n        uint TroveOwnersArrayLength = TroveOwners.length;\n        _requireMoreThanOneTroveInSystem(TroveOwnersArrayLength);\n\n        Troves[_borrower].status = Status.closed;\n        Troves[_borrower].coll = 0;\n        Troves[_borrower].debt = 0;\n\n        rewardSnapshots[_borrower].ETH = 0;\n        rewardSnapshots[_borrower].LUSDDebt = 0;\n\n        _removeTroveOwner(_borrower, TroveOwnersArrayLength);\n        sortedTroves.remove(_borrower);\n    }\n\n    /* \n    * Updates snapshots of system total stakes and total collateral, excluding a given collateral remainder from the calculation. \n    * Used in a liquidation sequence.\n    *\n    * The calculation excludes two portions of collateral that are in the ActivePool: \n    *\n    * 1) the total ETH gas compensation from the liquidation sequence\n    * 2) The remaining collateral in a partially liquidated trove (if one occurred)\n    *\n    * The ETH as compensation must be excluded as it is always sent out at the very end of the liquidation sequence.\n    *\n    * The partially liquidated trove's remaining collateral stays in the ActivePool, but it is excluded here so the system \n    * can take snapshots before the partially liquidated trove's stake is updated (based on these snapshots). This ensures\n    * the partial's new stake doesn't double-count its own remaining collateral.\n    *\n    */\n    function _updateSystemSnapshots_excludeCollRemainder(uint _collRemainder) internal {\n        totalStakesSnapshot = totalStakes;\n\n        uint activeColl = activePool.getETH();\n        uint liquidatedColl = defaultPool.getETH();\n        totalCollateralSnapshot = activeColl.sub(_collRemainder).add(liquidatedColl);\n    }\n\n    // Push the owner's address to the Trove owners list, and record the corresponding array index on the Trove struct\n    function addTroveOwnerToArray(address _borrower) external override returns (uint index) {\n        _requireCallerIsBorrowerOperations();\n        return _addTroveOwnerToArray(_borrower);\n    }\n\n    function _addTroveOwnerToArray(address _borrower) internal returns (uint128 index) {\n        require(TroveOwners.length < 2**128 - 1, \"TroveManager: TroveOwners array has maximum size of 2^128 - 1\");\n\n        // Push the Troveowner to the array\n        TroveOwners.push(_borrower);\n\n        // Record the index of the new Troveowner on their Trove struct\n        index = uint128(TroveOwners.length.sub(1));\n        Troves[_borrower].arrayIndex = index;\n\n        return index;\n    }\n\n    /* \n    * Remove a Trove owner from the TroveOwners array, not preserving array order. Removing owner 'B' does the following:\n    * [A B C D E] => [A E C D], and updates E's Trove struct to point to its new array index. \n    */\n    function _removeTroveOwner(address _borrower, uint TroveOwnersArrayLength) internal {\n        require(Troves[_borrower].status == Status.closed, \"TroveManager: Trove is still active\");\n\n        uint128 index = Troves[_borrower].arrayIndex;\n        uint length = TroveOwnersArrayLength;\n        uint idxLast = length.sub(1);\n\n        assert(index <= idxLast);\n\n        address addressToMove = TroveOwners[idxLast];\n\n        TroveOwners[index] = addressToMove;\n        Troves[addressToMove].arrayIndex = index;\n        TroveOwners.pop();\n    }\n\n    // --- Recovery Mode and TCR functions ---\n\n    function checkRecoveryMode() public view override returns (bool) {\n        uint TCR = getTCR();\n\n        if (TCR < CCR) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    // Check whether or not the system *would be* in Recovery Mode, given an ETH:USD price, and the entire system coll and debt.\n    function _checkPotentialRecoveryMode(\n        uint _entireSystemColl,\n        uint _entireSystemDebt,\n        uint _price\n    )\n        internal\n        pure\n    returns (bool)\n    {\n        uint TCR = LiquityMath._computeCR(_entireSystemColl, _entireSystemDebt, _price);\n        if (TCR < CCR) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n    // SWC-135-Code With No Effects: L1276-L1284\n    function getTCR() public view override returns (uint TCR) {\n        uint price = priceFeed.getPrice();\n        uint entireSystemColl = getEntireSystemColl();\n        uint entireSystemDebt = getEntireSystemDebt();\n\n        TCR = LiquityMath._computeCR(entireSystemColl, entireSystemDebt, price);\n\n        return TCR;\n    }\n    // SWC-135-Code With No Effects: L1286-L1291\n    function getEntireSystemColl() public view override returns (uint entireSystemColl) {\n        uint activeColl = activePool.getETH();\n        uint liquidatedColl = defaultPool.getETH();\n\n        return activeColl.add(liquidatedColl);\n    }\n\n    function getEntireSystemDebt() public view override returns (uint entireSystemDebt) {\n        uint activeDebt = activePool.getLUSDDebt();\n        uint closedDebt = defaultPool.getLUSDDebt();\n\n        return activeDebt.add(closedDebt);\n    }\n\n    // --- Redemption fee functions ---\n\n    /* \n    * This function has two impacts on the baseRate state variable:\n    * 1) decays the baseRate based on time passed since last redemption or LUSD borrowing operation.\n    * then,\n    * 2) increases the baseRate based on the amount redeemed, as a proportion of total supply\n    */\n    function _updateBaseRateFromRedemption(uint _ETHDrawn,  uint _price) internal returns (uint) {\n        uint decayedBaseRate = _calcDecayedBaseRate();\n\n        uint activeDebt = activePool.getLUSDDebt();\n        uint closedDebt = defaultPool.getLUSDDebt();\n        uint totalLUSDSupply = activeDebt.add(closedDebt);\n\n        /* Convert the drawn ETH back to LUSD at face value rate (1 LUSD:1 USD), in order to get\n        * the fraction of total supply that was redeemed at face value. */\n        uint redeemedLUSDFraction = _ETHDrawn.mul(_price).div(totalLUSDSupply);\n\n        uint newBaseRate = decayedBaseRate.add(redeemedLUSDFraction.div(BETA));\n\n        // Update the baseRate state variable\n        baseRate = newBaseRate < 1e18 ? newBaseRate : 1e18;  // cap baseRate at a maximum of 100%\n        assert(baseRate <= 1e18 && baseRate > 0); // Base rate is always non-zero after redemption\n\n        _updateLastFeeOpTime();\n\n        return baseRate;\n    }\n\n    function _getRedemptionFee(uint _ETHDrawn) internal view returns (uint) {\n       return baseRate.mul(_ETHDrawn).div(1e18);\n    }\n\n    // --- Borrowing fee functions ---\n\n    function getBorrowingFee(uint _LUSDDebt) external view override returns (uint) {\n        return _LUSDDebt.mul(baseRate).div(1e18);\n    }\n\n    // Updates the baseRate state variable based on time elapsed since the last redemption or LUSD borrowing operation.\n    function decayBaseRateFromBorrowing() external override {\n        _requireCallerIsBorrowerOperations();\n\n        baseRate = _calcDecayedBaseRate();\n        assert(baseRate <= 1e18);  // The baseRate can decay to 0\n\n        _updateLastFeeOpTime();\n    }\n\n    // --- Internal fee functions ---\n\n    // Update the last fee operation time only if time passed >= decay interval. This prevents base rate griefing.\n    function _updateLastFeeOpTime() internal {\n        uint timePassed = block.timestamp.sub(lastFeeOperationTime);\n\n        if (timePassed >= SECONDS_IN_ONE_MINUTE) {\n            lastFeeOperationTime = block.timestamp;\n        }\n    }\n\n    function _calcDecayedBaseRate() internal view returns (uint) {\n        uint minutesPassed = _minutesPassedSinceLastFeeOp();\n        uint decayFactor = LiquityMath._decPow(MINUTE_DECAY_FACTOR, minutesPassed);\n\n        return baseRate.mul(decayFactor).div(1e18);\n    }\n\n    function _minutesPassedSinceLastFeeOp() internal view returns (uint) {\n        return (block.timestamp.sub(lastFeeOperationTime)).div(SECONDS_IN_ONE_MINUTE);\n    }\n\n    // --- 'require' wrapper functions ---\n\n    function _requireCallerIsBorrowerOperations() internal view {\n        require(msg.sender == borrowerOperationsAddress, \"TroveManager: Caller is not the BorrowerOperations contract\");\n    }\n\n    function _requireTroveisActive(address _borrower) internal view {\n        require(Troves[_borrower].status == Status.active, \"TroveManager: Trove does not exist or is closed\");\n    }\n\n    function _requireLUSDBalanceCoversRedemption(address _redeemer, uint _amount) internal view {\n        require(lusdToken.balanceOf(_redeemer) >= _amount, \"TroveManager: Requested redemption amount must be <= user's LUSD token balance\");\n    }\n\n    function _requireMoreThanOneTroveInSystem(uint TroveOwnersArrayLength) internal view {\n        require (TroveOwnersArrayLength > 1 && sortedTroves.getSize() > 1, \"TroveManager: Only one trove in the system\");\n    }\n\n    function _requireAmountGreaterThanZero(uint _amount) internal pure {\n        require(_amount > 0, \"TroveManager: Amount must be greater than zero\");\n    }\n\n    // --- Trove property getters ---\n\n    function getTroveStatus(address _borrower) external view override returns (uint) {\n        return uint(Troves[_borrower].status);\n    }\n\n    function getTroveStake(address _borrower) external view override returns (uint) {\n        return Troves[_borrower].stake;\n    }\n\n    function getTroveDebt(address _borrower) external view override returns (uint) {\n        return Troves[_borrower].debt;\n    }\n\n    function getTroveColl(address _borrower) external view override returns (uint) {\n        return Troves[_borrower].coll;\n    }\n\n    // --- Trove property setters, called by BorrowerOperations ---\n\n    function setTroveStatus(address _borrower, uint _num) external override {\n        _requireCallerIsBorrowerOperations();\n        Troves[_borrower].status = Status(_num);\n    }\n\n    function increaseTroveColl(address _borrower, uint _collIncrease) external override returns (uint) {\n        _requireCallerIsBorrowerOperations();\n        uint newColl = Troves[_borrower].coll.add(_collIncrease);\n        Troves[_borrower].coll = newColl;\n        return newColl;\n    }\n\n    function decreaseTroveColl(address _borrower, uint _collDecrease) external override returns (uint) {\n        _requireCallerIsBorrowerOperations();\n        uint newColl = Troves[_borrower].coll.sub(_collDecrease);\n        Troves[_borrower].coll = newColl;\n        return newColl;\n    }\n\n    function increaseTroveDebt(address _borrower, uint _debtIncrease) external override returns (uint) {\n        _requireCallerIsBorrowerOperations();\n        uint newDebt = Troves[_borrower].debt.add(_debtIncrease);\n        Troves[_borrower].debt = newDebt;\n        return newDebt;\n    }\n\n    function decreaseTroveDebt(address _borrower, uint _debtDecrease) external override returns (uint) {\n        _requireCallerIsBorrowerOperations();\n        uint newDebt = Troves[_borrower].debt.sub(_debtDecrease);\n        Troves[_borrower].debt = newDebt;\n        return newDebt;\n    }\n}",
        "function": "TroveOwners(uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-Liquity/dev-f0df3efa5a5f05b205752184cfce107c5bd6e06c/packages/contracts/contracts/TroveManager.sol",
        "vulnerability": "Exception State (SWC 110)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract TroveManager is LiquityBase, Ownable, ITroveManager {\n\n    // --- Connected contract declarations ---\n\n    address public borrowerOperationsAddress;\n\n    IPool public activePool;\n\n    IPool public defaultPool;\n\n    IStabilityPool public stabilityPool;\n\n    ICollSurplusPool collSurplusPool;\n\n    ILUSDToken public lusdToken;\n\n    IPriceFeed public priceFeed;\n\n    ILQTYStaking public lqtyStaking;\n    address public lqtyStakingAddress;\n\n    // A doubly linked list of Troves, sorted by their sorted by their collateral ratios\n    ISortedTroves public sortedTroves;\n\n    // --- Data structures ---\n\n    uint constant public SECONDS_IN_ONE_MINUTE = 60;\n    uint constant public MINUTE_DECAY_FACTOR = 999832508430720967;  // 18 digit decimal. Corresponds to an hourly decay factor of 0.99\n\n    /* \n    * BETA: 18 digit decimal. Parameter by which to divide the redeemed fraction, in order to calc the new base rate from a redemption. \n    * Corresponds to (1 / ALPHA) in the white paper. \n    */\n    uint constant public BETA = 2;\n\n    uint public baseRate;\n\n    // The timestamp of the latest fee operation (redemption or new LUSD issuance) \n    uint public lastFeeOperationTime;\n\n    enum Status { nonExistent, active, closed }\n\n    // Store the necessary data for a trove\n    struct Trove {\n        uint debt;\n        uint coll;\n        uint stake;\n        Status status;\n        uint128 arrayIndex;\n    }\n\n    mapping (address => Trove) public Troves;\n\n    uint public totalStakes;\n\n    // Snapshot of the value of totalStakes, taken immediately after the latest liquidation\n    uint public totalStakesSnapshot;\n\n    // Snapshot of the total collateral across the ActivePool and DefaultPool, immediately after the latest liquidation.\n    uint public totalCollateralSnapshot;\n\n    /*\n    * L_ETH and L_LUSDDebt track the sums of accumulated liquidation rewards per unit staked. During its lifetime, each stake earns:\n    *\n    * An ETH gain of ( stake * [L_ETH - L_ETH(0)] )\n    * A LUSDDebt increase  of ( stake * [L_LUSDDebt - L_LUSDDebt(0)] )\n    *\n    * Where L_ETH(0) and L_LUSDDebt(0) are snapshots of L_ETH and L_LUSDDebt for the active Trove taken at the instant the stake was made\n    */\n    uint public L_ETH;\n    uint public L_LUSDDebt;\n\n    // Map addresses with active troves to their RewardSnapshot\n    mapping (address => RewardSnapshot) public rewardSnapshots;\n\n    // Object containing the ETH and LUSD snapshots for a given active trove\n    struct RewardSnapshot { uint ETH; uint LUSDDebt;}\n\n    // Array of all active trove addresses - used to to compute an approximate hint off-chain, for the sorted list insertion\n    address[] public TroveOwners;\n\n    // Error trackers for the trove redistribution calculation\n    uint public lastETHError_Redistribution;\n    uint public lastLUSDDebtError_Redistribution;\n\n    /* \n    * --- Variable container structs for liquidations ---\n    *\n    * These structs are used to hold, return and assign variables inside the liquidation functions,\n    * in order to avoid the error: \"CompilerError: Stack too deep\". \n    **/\n\n    struct LocalVariables_OuterLiquidationFunction {\n        uint price;\n        uint LUSDInStabPool;\n        bool recoveryModeAtStart;\n        uint liquidatedDebt;\n        uint liquidatedColl;\n    }\n\n    struct LocalVariables_InnerSingleLiquidateFunction {\n        uint collToLiquidate;\n        uint pendingDebtReward;\n        uint pendingCollReward;\n    }\n\n    struct LocalVariables_LiquidationSequence {\n        uint remainingLUSDInStabPool;\n        uint i;\n        uint ICR;\n        address user;\n        bool backToNormalMode;\n        uint entireSystemDebt;\n        uint entireSystemColl;\n    }\n\n    struct LiquidationValues {\n        uint entireTroveDebt;\n        uint entireTroveColl;\n        uint collGasCompensation;\n        uint LUSDGasCompensation;\n        uint debtToOffset;\n        uint collToSendToSP;\n        uint debtToRedistribute;\n        uint collToRedistribute;\n        address partialAddr;\n        uint partialNewDebt;\n        uint partialNewColl;\n        address partialUpperHint;\n        address partialLowerHint;\n    }\n\n    struct LiquidationTotals {\n        uint totalCollInSequence;\n        uint totalDebtInSequence;\n        uint totalCollGasCompensation;\n        uint totalLUSDGasCompensation;\n        uint totalDebtToOffset;\n        uint totalCollToSendToSP;\n        uint totalDebtToRedistribute;\n        uint totalCollToRedistribute;\n        address partialAddr;\n        uint partialNewDebt;\n        uint partialNewColl;\n        address partialUpperHint;\n        address partialLowerHint;\n    }\n\n    // --- Variable container structs for redemptions ---\n\n    struct RedemptionTotals {\n        uint totalLUSDToRedeem;\n        uint totalETHDrawn;\n        uint ETHFee;\n        uint ETHToSendToRedeemer;\n        uint decayedBaseRate;\n    }\n\n    struct SingleRedemptionValues {\n        uint LUSDLot;\n        uint ETHLot;\n    }\n\n    // --- Events ---\n\n    event Liquidation(uint _liquidatedDebt, uint _liquidatedColl, uint _collGasCompensation, uint _LUSDGasCompensation);\n    event Redemption(uint _attemptedLUSDAmount, uint _actualLUSDAmount, uint _ETHSent, uint _ETHFee);\n\n    enum TroveManagerOperation {\n        applyPendingRewards,\n        liquidateInNormalMode,\n        liquidateInRecoveryMode,\n        partiallyLiquidateInRecoveryMode,\n        redeemCollateral\n    }\n\n    event TroveCreated(address indexed _borrower, uint _arrayIndex);\n    event TroveUpdated(address indexed _borrower, uint _debt, uint _coll, uint _stake, TroveManagerOperation _operation);\n    event TroveLiquidated(address indexed _borrower, uint _debt, uint _coll, TroveManagerOperation _operation);\n\n    // --- Dependency setter ---\n\n    function setAddresses(\n        address _borrowerOperationsAddress,\n        address _activePoolAddress,\n        address _defaultPoolAddress,\n        address _stabilityPoolAddress,\n        address _collSurplusPoolAddress,\n        address _priceFeedAddress,\n        address _lusdTokenAddress,\n        address _sortedTrovesAddress,\n        address _lqtyStakingAddress\n    )\n        external\n        override\n        onlyOwner\n    {\n        borrowerOperationsAddress = _borrowerOperationsAddress;\n        activePool = IPool(_activePoolAddress);\n        defaultPool = IPool(_defaultPoolAddress);\n        stabilityPool = IStabilityPool(_stabilityPoolAddress);\n        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);\n        priceFeed = IPriceFeed(_priceFeedAddress);\n        lusdToken = ILUSDToken(_lusdTokenAddress);\n        sortedTroves = ISortedTroves(_sortedTrovesAddress);\n        lqtyStakingAddress = _lqtyStakingAddress;\n        lqtyStaking = ILQTYStaking(_lqtyStakingAddress);\n\n        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);\n        emit ActivePoolAddressChanged(_activePoolAddress);\n        emit DefaultPoolAddressChanged(_defaultPoolAddress);\n        emit StabilityPoolAddressChanged(_stabilityPoolAddress);\n        emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);\n        emit PriceFeedAddressChanged(_priceFeedAddress);\n        emit LUSDTokenAddressChanged(_lusdTokenAddress);\n        emit SortedTrovesAddressChanged(_sortedTrovesAddress);\n        emit LQTYStakingAddressChanged(_lqtyStakingAddress);\n\n        _renounceOwnership();\n    }\n\n    // --- Getters ---\n\n    function getTroveOwnersCount() external view override returns (uint) {\n        return TroveOwners.length;\n    }\n\n    function getTroveFromTroveOwnersArray(uint _index) external view override returns (address) {\n        return TroveOwners[_index];\n    }\n\n    // --- Trove Liquidation functions ---\n\n    // Single liquidation function. Closes the trove if its ICR is lower than the minimum collateral ratio. \n    function liquidate(address _borrower) external override {\n        _requireTroveisActive(_borrower);\n\n        address[] memory borrowers = new address[](1);\n        borrowers[0] = _borrower;\n        batchLiquidateTroves(borrowers);\n    }\n\n    // --- Inner single liquidation functions ---\n\n    // Liquidate one trove, in Normal Mode.\n    function _liquidateNormalMode(address _borrower, uint _LUSDInStabPool) internal returns (LiquidationValues memory V) {\n        LocalVariables_InnerSingleLiquidateFunction memory L;\n\n        (V.entireTroveDebt,\n        V.entireTroveColl,\n        L.pendingDebtReward,\n        L.pendingCollReward) = getEntireDebtAndColl(_borrower);\n\n        _movePendingTroveRewardsToActivePool(L.pendingDebtReward, L.pendingCollReward);\n        _removeStake(_borrower);\n\n        V.collGasCompensation = _getCollGasCompensation(V.entireTroveColl);\n        V.LUSDGasCompensation = LUSD_GAS_COMPENSATION;\n        uint collToLiquidate = V.entireTroveColl.sub(V.collGasCompensation);\n\n        (V.debtToOffset,\n        V.collToSendToSP,\n        V.debtToRedistribute,\n        V.collToRedistribute) = _getOffsetAndRedistributionVals(V.entireTroveDebt, collToLiquidate, _LUSDInStabPool);\n\n        _closeTrove(_borrower);\n        emit TroveLiquidated(_borrower, V.entireTroveDebt, V.entireTroveColl, TroveManagerOperation.liquidateInNormalMode);\n\n        return V;\n    }\n\n    // Liquidate one trove, in Recovery Mode.\n    function _liquidateRecoveryMode(address _borrower, uint _ICR, uint _LUSDInStabPool, uint _TCR) internal returns (LiquidationValues memory V) {\n        LocalVariables_InnerSingleLiquidateFunction memory L;\n        \n        if (TroveOwners.length <= 1) { return V; } // don't liquidate if last trove\n\n        (V.entireTroveDebt,\n        V.entireTroveColl,\n        L.pendingDebtReward,\n        L.pendingCollReward) = getEntireDebtAndColl(_borrower);\n\n        _movePendingTroveRewardsToActivePool(L.pendingDebtReward, L.pendingCollReward);\n\n        V.collGasCompensation = _getCollGasCompensation(V.entireTroveColl);\n        // In case of a partial liquidation, V.LUSDGasCompensation will be overwritten to zero, in the third branch below\n        V.LUSDGasCompensation = LUSD_GAS_COMPENSATION;\n        L.collToLiquidate = V.entireTroveColl.sub(V.collGasCompensation);\n\n        // If ICR <= 100%, purely redistribute the Trove across all active Troves\n        if (_ICR <= _100pct) {\n            _removeStake(_borrower);\n\n            V.debtToOffset = 0;\n            V.collToSendToSP = 0;\n            V.debtToRedistribute = V.entireTroveDebt;\n            V.collToRedistribute = L.collToLiquidate;\n\n            _closeTrove(_borrower);\n            emit TroveLiquidated(_borrower, V.entireTroveDebt, V.entireTroveColl, TroveManagerOperation.liquidateInRecoveryMode);\n\n        // If 100% < ICR < MCR, offset as much as possible, and redistribute the remainder\n        } else if ((_ICR > _100pct) && (_ICR < MCR)) {\n            _removeStake(_borrower);\n\n            (V.debtToOffset,\n            V.collToSendToSP,\n            V.debtToRedistribute,\n            V.collToRedistribute) = _getOffsetAndRedistributionVals(V.entireTroveDebt, L.collToLiquidate, _LUSDInStabPool);\n\n            _closeTrove(_borrower);\n            emit TroveLiquidated(_borrower, V.entireTroveDebt, V.entireTroveColl, TroveManagerOperation.liquidateInRecoveryMode);\n\n        /* \n        * If 110% <= ICR < current TCR (accounting for the preceding liquidations in the current sequence)\n        * and there is LUSD in the Stability Pool, only offset it as much as possible, with no redistribution.\n        */\n        } else if ((_ICR >= MCR) && (_ICR < _TCR)) {\n            assert(_LUSDInStabPool != 0);\n\n            _removeStake(_borrower);\n            \n            V = _getFullOrPartialOffsetVals(_borrower, V.entireTroveDebt, V.entireTroveColl, _LUSDInStabPool);\n\n            _closeTrove(_borrower);\n        }\n        else if (_ICR >= _TCR) {\n            LiquidationValues memory zeroVals;\n            return zeroVals;\n        }\n\n        return V;\n    }\n\n    /* In a full liquidation, returns the values for a trove's coll and debt to be offset, and coll and debt to be \n    * redistributed to active troves. \n    */\n    function _getOffsetAndRedistributionVals\n    (\n        uint _debt,\n        uint _coll,\n        uint _LUSDInStabPool\n    )\n        internal\n        pure\n        returns (uint debtToOffset, uint collToSendToSP, uint debtToRedistribute, uint collToRedistribute)\n    {\n        if (_LUSDInStabPool > 0) {\n        /* \n        * Offset as much debt & collateral as possible against the Stability Pool, and redistribute the remainder\n        * between all active troves.\n        *\n        *  If the trove's debt is larger than the deposited LUSD in the Stability Pool:\n        *\n        *  - Offset an amount of the trove's debt equal to the LUSD in the Stability Pool\n        *  - Send a fraction of the trove's collateral to the Stability Pool, equal to the fraction of its offset debt\n        *\n        */\n            debtToOffset = LiquityMath._min(_debt, _LUSDInStabPool);\n            collToSendToSP = _coll.mul(debtToOffset).div(_debt);\n            debtToRedistribute = _debt.sub(debtToOffset);\n            collToRedistribute = _coll.sub(collToSendToSP);\n        } else {\n            debtToOffset = 0;\n            collToSendToSP = 0;\n            debtToRedistribute = _debt;\n            collToRedistribute = _coll;\n        }\n    }\n\n    /*\n    *  If it is a full offset, get its offset coll/debt and ETH gas comp, and close the trove.\n    *\n    * If it is a partial liquidation, get its offset coll/debt and ETH gas comp, and its new coll/debt, and its re-insertion hints.\n    */\n    function _getFullOrPartialOffsetVals\n    (\n        address _borrower,\n        uint _entireTroveDebt,\n        uint _entireTroveColl,\n        uint _LUSDInStabPool\n    )\n        internal\n        returns (LiquidationValues memory V)\n    {\n        V.entireTroveDebt = _entireTroveDebt;\n        V.entireTroveColl = _entireTroveColl;\n\n        // When Stability Pool can fully absorb the trove's debt, perform a full offset\n        if (_entireTroveDebt <= _LUSDInStabPool) {\n            V.collGasCompensation = _getCollGasCompensation(_entireTroveColl);\n            V.LUSDGasCompensation = LUSD_GAS_COMPENSATION;\n\n            V.debtToOffset = _entireTroveDebt;\n            V.collToSendToSP = _entireTroveColl.sub(V.collGasCompensation);\n            V.debtToRedistribute = 0;\n            V.collToRedistribute = 0;\n\n            emit TroveLiquidated(_borrower, _entireTroveDebt, _entireTroveColl, TroveManagerOperation.liquidateInRecoveryMode);\n        }\n        /* \n        * When trove's debt is greater than the Stability Pool, perform a partial liquidation: offset as much as possible,\n        * and do not redistribute the remainder. The trove remains active, with a reduced collateral and debt.\n        *\n        * ETH gas compensation is based on and drawn from the collateral fraction that corresponds to the partial offset. \n        * LUSD gas compensation is left untouched. \n        *\n        * Since ETH gas comp is drawn purely from the *liquidated* portion, the trove is left with the same ICR as before the \n        * liquidation.\n        */\n        else if (_entireTroveDebt > _LUSDInStabPool) {\n            // Remaining debt in the trove is lower-bounded by the trove's gas compensation\n            V.partialNewDebt = LiquityMath._max(_entireTroveDebt.sub(_LUSDInStabPool), LUSD_GAS_COMPENSATION);\n          \n            V.debtToOffset = _entireTroveDebt.sub(V.partialNewDebt);\n\n            uint collFraction = _entireTroveColl.mul(V.debtToOffset).div(_entireTroveDebt);\n            V.collGasCompensation = _getCollGasCompensation(collFraction);\n          \n            V.LUSDGasCompensation = 0;  // LUSD gas compensation remains untouched\n\n            V.collToSendToSP = collFraction.sub(V.collGasCompensation);\n            V.collToRedistribute = 0;\n            V.debtToRedistribute = 0;\n\n            V.partialAddr = _borrower;\n            V.partialNewColl = _entireTroveColl.sub(collFraction);\n\n            // Get the partial trove's neighbours, so we can re-insert it later to the same position\n            V.partialUpperHint = sortedTroves.getPrev(_borrower);  \n            V.partialLowerHint = sortedTroves.getNext(_borrower);\n        }\n    }\n\n    /* \n    * Liquidate a sequence of troves. Closes a maximum number of n under-collateralized Troves,\n    * starting from the one with the lowest collateral ratio in the system, and moving upwards\n    */\n    function liquidateTroves(uint _n) external override {\n        LocalVariables_OuterLiquidationFunction memory L;\n\n        LiquidationTotals memory T;\n\n        L.price = priceFeed.getPrice();\n        L.LUSDInStabPool = stabilityPool.getTotalLUSDDeposits();\n        L.recoveryModeAtStart = checkRecoveryMode();\n\n        // Perform the appropriate liquidation sequence - tally the values, and obtain their totals\n        if (L.recoveryModeAtStart == true) {\n            T = _getTotalsFromLiquidateTrovesSequence_RecoveryMode(L.price, L.LUSDInStabPool, _n);\n        } else if (L.recoveryModeAtStart == false) {\n            T = _getTotalsFromLiquidateTrovesSequence_NormalMode(L.price, L.LUSDInStabPool, _n);\n        }\n\n        // Move liquidated ETH and LUSD to the appropriate pools\n        stabilityPool.offset(T.totalDebtToOffset, T.totalCollToSendToSP);\n        _redistributeDebtAndColl(T.totalDebtToRedistribute, T.totalCollToRedistribute);\n\n        // Update system snapshots and the final partially liquidated trove, if there is one\n        _updateSystemSnapshots_excludeCollRemainder(T.partialNewColl.add(T.totalCollGasCompensation));\n        _updatePartiallyLiquidatedTrove(T.partialAddr, T.partialNewDebt, T.partialNewColl, T.partialUpperHint, T. partialLowerHint, L.price);\n\n        L.liquidatedDebt = T.totalDebtInSequence.sub(T.partialNewDebt);\n        L.liquidatedColl = T.totalCollInSequence.sub(T.totalCollGasCompensation).sub(T.partialNewColl);\n        emit Liquidation(L.liquidatedDebt, L.liquidatedColl, T.totalCollGasCompensation, T.totalLUSDGasCompensation);\n\n        // Send gas compensation to caller\n        _sendGasCompensation(msg.sender, T.totalLUSDGasCompensation, T.totalCollGasCompensation);\n    }\n\n    /*\n    * This function is used when the liquidateTroves sequence starts during Recovery Mode. However, it\n    * handle the case where the system *leaves* Recovery Mode, part way through the liquidation sequence\n    */\n    function _getTotalsFromLiquidateTrovesSequence_RecoveryMode\n    (\n        uint _price,\n        uint _LUSDInStabPool,\n        uint _n\n    )\n        internal\n        returns(LiquidationTotals memory T)\n    {\n        LocalVariables_LiquidationSequence memory L;\n        LiquidationValues memory V;\n\n        L.remainingLUSDInStabPool = _LUSDInStabPool;\n        L.backToNormalMode = false;\n        L.entireSystemDebt = activePool.getLUSDDebt().add(defaultPool.getLUSDDebt());\n        L.entireSystemColl = activePool.getETH().add(defaultPool.getETH());\n\n        L.i = 0;\n        while (L.i < _n) {\n            L.user = sortedTroves.getLast();\n            L.ICR = getCurrentICR(L.user, _price);\n\n            if (L.backToNormalMode == false) {\n                // Break the loop if ICR is greater than MCR and Stability Pool is empty\n                if (L.ICR >= MCR && L.remainingLUSDInStabPool == 0) { break; }\n\n                uint TCR = LiquityMath._computeCR(L.entireSystemColl, L.entireSystemDebt, _price);\n        \n                V = _liquidateRecoveryMode(L.user, L.ICR, L.remainingLUSDInStabPool, TCR);\n\n                // Update aggregate trackers\n                L.remainingLUSDInStabPool = L.remainingLUSDInStabPool.sub(V.debtToOffset);\n                L.entireSystemDebt = L.entireSystemDebt.sub(V.debtToOffset);\n                L.entireSystemColl = L.entireSystemColl.sub(V.collToSendToSP);\n\n                // Add liquidation values to their respective running totals\n                T = _addLiquidationValuesToTotals(T, V);\n\n                // Break the loop if it was a partial liquidation\n                if (V.partialAddr != address(0)) {break;}\n\n                L.backToNormalMode = !_checkPotentialRecoveryMode(L.entireSystemColl, L.entireSystemDebt, _price);\n            }\n            else if (L.backToNormalMode == true && L.ICR < MCR) {\n                V = _liquidateNormalMode(L.user, L.remainingLUSDInStabPool);\n\n                L.remainingLUSDInStabPool = L.remainingLUSDInStabPool.sub(V.debtToOffset);\n\n                // Add liquidation values to their respective running totals\n                T = _addLiquidationValuesToTotals(T, V);\n\n            }  else break;  // break if the loop reaches a Trove with ICR >= MCR\n\n            // Break the loop if it reaches the first Trove in the sorted list\n            if (L.user == sortedTroves.getFirst()) { break; }\n\n            L.i++;\n        }\n    }\n\n    function _getTotalsFromLiquidateTrovesSequence_NormalMode\n    (\n        uint _price,\n        uint _LUSDInStabPool,\n        uint _n\n    )\n        internal\n        returns(LiquidationTotals memory T)\n    {\n        LocalVariables_LiquidationSequence memory L;\n        LiquidationValues memory V;\n\n        L.remainingLUSDInStabPool = _LUSDInStabPool;\n\n        L.i = 0;\n        while (L.i < _n) {\n            L.user = sortedTroves.getLast();\n            L.ICR = getCurrentICR(L.user, _price);\n\n            if (L.ICR < MCR) {\n                V = _liquidateNormalMode(L.user, L.remainingLUSDInStabPool);\n\n                L.remainingLUSDInStabPool = L.remainingLUSDInStabPool.sub(V.debtToOffset);\n\n                // Add liquidation values to their respective running totals\n                T = _addLiquidationValuesToTotals(T, V);\n\n            } else break;  // break if the loop reaches a Trove with ICR >= MCR\n\n            // Break the loop if it reaches the first Trove in the sorted list\n            if (L.user == sortedTroves.getFirst()) { break; }\n            L.i++;\n        }\n    }\n\n    /* \n    * Attempt to liquidate a custom list of troves provided by the caller. The liquidation sequence stops if\n    * a partial liquidation is performed, so it's up to the caller to order the troves in the _troveArray parameter.\n    */\n    function batchLiquidateTroves(address[] memory _troveArray) public override {\n        require(_troveArray.length != 0, \"TroveManager: Calldata address array must not be empty\");\n\n        LocalVariables_OuterLiquidationFunction memory L;\n        LiquidationTotals memory T;\n\n        L.price = priceFeed.getPrice();\n        L.LUSDInStabPool = stabilityPool.getTotalLUSDDeposits();\n        L.recoveryModeAtStart = checkRecoveryMode();\n\n        // Perform the appropriate liquidation sequence - tally values and obtain their totals.\n        if (L.recoveryModeAtStart == true) {\n           T = _getTotalFromBatchLiquidate_RecoveryMode(L.price, L.LUSDInStabPool, _troveArray);\n        } else if (L.recoveryModeAtStart == false) {\n            T = _getTotalsFromBatchLiquidate_NormalMode(L.price, L.LUSDInStabPool, _troveArray);\n        }\n\n        // Move liquidated ETH and LUSD to the appropriate pools\n        stabilityPool.offset(T.totalDebtToOffset, T.totalCollToSendToSP);\n        _redistributeDebtAndColl(T.totalDebtToRedistribute, T.totalCollToRedistribute);\n\n        // Update system snapshots and the final partially liquidated trove, if there is one\n        _updateSystemSnapshots_excludeCollRemainder(T.partialNewColl.add(T.totalCollGasCompensation));\n        _updatePartiallyLiquidatedTrove(T.partialAddr, T.partialNewDebt, T.partialNewColl, T.partialUpperHint, T. partialLowerHint, L.price);\n\n        L.liquidatedDebt = T.totalDebtInSequence.sub(T.partialNewDebt);\n        L.liquidatedColl = T.totalCollInSequence.sub(T.totalCollGasCompensation).sub(T.partialNewColl);\n        emit Liquidation(L.liquidatedDebt, L.liquidatedColl, T.totalCollGasCompensation, T.totalLUSDGasCompensation);\n\n        // Send gas compensation to caller\n        _sendGasCompensation(msg.sender, T.totalLUSDGasCompensation, T.totalCollGasCompensation);\n    }\n\n    /* \n    * This function is used when the batch liquidation sequence starts during Recovery Mode. However, it\n    * handle the case where the system *leaves* Recovery Mode, part way through the liquidation sequence\n    */\n    function _getTotalFromBatchLiquidate_RecoveryMode\n    (\n        uint _price,\n        uint _LUSDInStabPool,\n        address[] memory _troveArray)\n        internal\n        returns(LiquidationTotals memory T)\n    {\n        LocalVariables_LiquidationSequence memory L;\n        LiquidationValues memory V;\n\n        L.remainingLUSDInStabPool = _LUSDInStabPool;\n        L.backToNormalMode = false;\n        L.entireSystemDebt = activePool.getLUSDDebt().add(defaultPool.getLUSDDebt());\n        L.entireSystemColl = activePool.getETH().add(defaultPool.getETH());\n\n        L.i = 0;\n        for (L.i = 0; L.i < _troveArray.length; L.i++) {\n            L.user = _troveArray[L.i];\n            L.ICR = getCurrentICR(L.user, _price);\n\n            if (L.backToNormalMode == false) {\n\n                // Skip this trove if ICR is greater than MCR and Stability Pool is empty\n                if (L.ICR >= MCR && L.remainingLUSDInStabPool == 0) { continue; }\n\n                uint TCR = LiquityMath._computeCR(L.entireSystemColl, L.entireSystemDebt, _price);\n\n                V = _liquidateRecoveryMode(L.user, L.ICR, L.remainingLUSDInStabPool, TCR);\n\n                // Update aggregate trackers\n                L.remainingLUSDInStabPool = L.remainingLUSDInStabPool.sub(V.debtToOffset);\n                L.entireSystemDebt = L.entireSystemDebt.sub(V.debtToOffset);\n                L.entireSystemColl = L.entireSystemColl.sub(V.collToSendToSP);\n\n                // Add liquidation values to their respective running totals\n                T = _addLiquidationValuesToTotals(T, V);\n\n                // Break the loop if it was a partial liquidation\n                if (V.partialAddr != address(0)) { break; }\n\n                L.backToNormalMode = !_checkPotentialRecoveryMode(L.entireSystemColl, L.entireSystemDebt, _price);\n            }\n\n            else if (L.backToNormalMode == true && L.ICR < MCR) {\n                V = _liquidateNormalMode(L.user, L.remainingLUSDInStabPool);\n                L.remainingLUSDInStabPool = L.remainingLUSDInStabPool.sub(V.debtToOffset);\n\n                // Add liquidation values to their respective running totals\n                T = _addLiquidationValuesToTotals(T, V);\n            }\n        }\n    }\n\n    function _getTotalsFromBatchLiquidate_NormalMode\n    (\n        uint _price,\n        uint _LUSDInStabPool,\n        address[] memory _troveArray\n    )\n        internal\n        returns(LiquidationTotals memory T)\n    {\n        LocalVariables_LiquidationSequence memory L;\n        LiquidationValues memory V;\n\n        L.remainingLUSDInStabPool = _LUSDInStabPool;\n\n        for (L.i = 0; L.i < _troveArray.length; L.i++) {\n            L.user = _troveArray[L.i];\n            L.ICR = getCurrentICR(L.user, _price);\n\n            if (L.ICR < MCR) {\n                V = _liquidateNormalMode(L.user, L.remainingLUSDInStabPool);\n                L.remainingLUSDInStabPool = L.remainingLUSDInStabPool.sub(V.debtToOffset);\n\n                // Add liquidation values to their respective running totals\n                T = _addLiquidationValuesToTotals(T, V);\n            }\n        }\n    }\n\n    // --- Liquidation helper functions ---\n\n    function _addLiquidationValuesToTotals(LiquidationTotals memory T1, LiquidationValues memory V)\n    internal pure returns(LiquidationTotals memory T2) {\n\n        // Tally all the values with their respective running totals\n        T2.totalCollGasCompensation = T1.totalCollGasCompensation.add(V.collGasCompensation);\n        T2.totalLUSDGasCompensation = T1.totalLUSDGasCompensation.add(V.LUSDGasCompensation);\n        T2.totalDebtInSequence = T1.totalDebtInSequence.add(V.entireTroveDebt);\n        T2.totalCollInSequence = T1.totalCollInSequence.add(V.entireTroveColl);\n        T2.totalDebtToOffset = T1.totalDebtToOffset.add(V.debtToOffset);\n        T2.totalCollToSendToSP = T1.totalCollToSendToSP.add(V.collToSendToSP);\n        T2.totalDebtToRedistribute = T1.totalDebtToRedistribute.add(V.debtToRedistribute);\n        T2.totalCollToRedistribute = T1.totalCollToRedistribute.add(V.collToRedistribute);\n\n        // Assign the address of the partially liquidated trove, and its new debt and coll values\n        T2.partialAddr = V.partialAddr;\n        T2.partialNewDebt = V.partialNewDebt;\n        T2.partialNewColl = V.partialNewColl;\n        T2.partialUpperHint = V.partialUpperHint;\n        T2.partialLowerHint = V.partialLowerHint;\n\n        return T2;\n    }\n\n    // Update the properties of the partially liquidated trove, and insert it back to the list\n    function _updatePartiallyLiquidatedTrove\n    (\n        address _borrower, \n        uint _newDebt, \n        uint _newColl, \n        address _upperHint,\n        address _lowerHint,\n        uint _price\n    ) \n        internal \n    {\n        if ( _borrower == address(0)) { return; }\n\n        Troves[_borrower].debt = _newDebt;\n        Troves[_borrower].coll = _newColl;\n        Troves[_borrower].status = Status.active;\n\n        _updateTroveRewardSnapshots(_borrower);\n        _updateStakeAndTotalStakes(_borrower);\n\n        uint ICR = getCurrentICR(_borrower, _price);\n\n        /* \n        * Insert to sorted list and add to TroveOwners array. The partially liquidated trove has the same\n        * ICR as it did before the liquidation, so insertion is O(1): in principle, its ICR does not change.\n        * In practice, due to rounding error, its ICR can change slightly - so re-insert, with its previous neighbours\n        * as hints.\n        */\n        sortedTroves.insert(_borrower, ICR, _price, _upperHint, _lowerHint);\n        _addTroveOwnerToArray(_borrower);\n        emit TroveUpdated(_borrower, _newDebt, _newColl, Troves[_borrower].stake, TroveManagerOperation.partiallyLiquidateInRecoveryMode);\n    }\n\n    function _sendGasCompensation(address _liquidator, uint _LUSD, uint _ETH) internal {\n        if (_LUSD > 0) {\n            lusdToken.returnFromPool(GAS_POOL_ADDRESS, _liquidator, _LUSD);\n        }\n\n        if (_ETH > 0) {\n            activePool.sendETH(_liquidator, _ETH);\n        }\n    }\n\n    // Move a Trove's pending debt and collateral rewards from distributions, from the Default Pool to the Active Pool\n    function _movePendingTroveRewardsToActivePool(uint _LUSD, uint _ETH) internal {\n        defaultPool.decreaseLUSDDebt(_LUSD);\n        activePool.increaseLUSDDebt(_LUSD);\n        defaultPool.sendETH(address(activePool), _ETH);\n    }\n\n    // --- Redemption functions ---\n\n    // Redeem as much collateral as possible from _borrower's Trove in exchange for LUSD up to _maxLUSDamount\n    function _redeemCollateralFromTrove(\n        address _borrower,\n        uint _maxLUSDamount,\n        uint _price,\n        address _partialRedemptionHint,\n        uint _partialRedemptionHintICR\n    )\n        internal returns (SingleRedemptionValues memory V)\n    {\n        // Determine the remaining amount (lot) to be redeemed, capped by the entire debt of the Trove minus the gas compensation\n        V.LUSDLot = LiquityMath._min(_maxLUSDamount, Troves[_borrower].debt.sub(LUSD_GAS_COMPENSATION));\n\n        // Get the ETHLot of equivalent value in USD\n        V.ETHLot = V.LUSDLot.mul(1e18).div(_price);\n\n        // Decrease the debt and collateral of the current Trove according to the LUSD lot and corresponding ETH to send\n        uint newDebt = (Troves[_borrower].debt).sub(V.LUSDLot);\n        uint newColl = (Troves[_borrower].coll).sub(V.ETHLot);\n\n        if (newDebt == LUSD_GAS_COMPENSATION) {\n            // No debt left in the Trove (except for the gas compensation), therefore the trove gets closed\n            _removeStake(_borrower);\n            _closeTrove(_borrower);\n            _redeemCloseTrove(_borrower, LUSD_GAS_COMPENSATION, newColl);\n\n        } else {\n            uint newICR = LiquityMath._computeCR(newColl, newDebt, _price);\n\n            // Check if the provided hint is fresh. If not, we bail since trying to reinsert without a good hint will almost\n            // certainly result in running out of gas.\n            if (newICR != _partialRedemptionHintICR) {\n                V.LUSDLot = 0;\n                V.ETHLot = 0;\n                return V;\n            }\n\n            sortedTroves.reInsert(_borrower, newICR, _price, _partialRedemptionHint, _partialRedemptionHint);\n\n            Troves[_borrower].debt = newDebt;\n            Troves[_borrower].coll = newColl;\n            _updateStakeAndTotalStakes(_borrower);\n        }\n        emit TroveUpdated(\n            _borrower,\n            newDebt, newColl,\n            Troves[_borrower].stake,\n            TroveManagerOperation.redeemCollateral\n        );\n        return V;\n    }\n\n    /* \n    * Called when a full redemption occurs, and closes the trove.\n    * The redeemer swaps (debt - 10) LUSD for (debt - 10) worth of ETH, so the 10 LUSD gas compensation left corresponds to the remaining debt.\n    * In order to close the trove, the 10 LUSD gas compensation is burned, and 10 debt is removed from the active pool.\n    * The debt recorded on the trove's struct is zero'd elswhere, in _closeTrove.\n    * Any surplus ETH left in the trove, is sent to the Coll surplus pool, and can be later claimed by the borrower.\n    */ \n    function _redeemCloseTrove(address _borrower, uint _LUSD, uint _ETH) internal {\n        lusdToken.burn(GAS_POOL_ADDRESS, _LUSD);\n        // Update Active Pool LUSD, and send ETH to account\n        activePool.decreaseLUSDDebt(_LUSD);\n\n        // send ETH from Active Pool to CollSurplus Pool\n        collSurplusPool.accountSurplus(_borrower, _ETH);\n        activePool.sendETH(address(collSurplusPool), _ETH);\n    }\n\n    function _isValidFirstRedemptionHint(address _firstRedemptionHint, uint _price) internal view returns (bool) {\n        if (_firstRedemptionHint == address(0) ||\n            !sortedTroves.contains(_firstRedemptionHint) ||\n            getCurrentICR(_firstRedemptionHint, _price) < MCR\n        ) {\n            return false;\n        }\n\n        address nextTrove = sortedTroves.getNext(_firstRedemptionHint);\n        return nextTrove == address(0) || getCurrentICR(nextTrove, _price) < MCR;\n    }\n\n    /* Send _LUSDamount LUSD to the system and redeem the corresponding amount of collateral from as many Troves as are needed to fill the redemption\n    * request.  Applies pending rewards to a Trove before reducing its debt and coll.\n    *\n    * Note that if _amount is very large, this function can run out of gas, specially if traversed troves are small. This can be easily avoided by \n    * splitting the total _amount in appropriate chunks and calling the function multiple times.\n    * \n    * Param `_maxIterations` can also be provided, so the loop through Troves is capped (if its zero, it will be ignored).This makes it easier to \n    * avoid OOG for the frontend, as only knowing approximately the average cost of an iteration is enough, without needing to know the topology \n    * of the trove list. It also avoids the need to set the cap in stone in the contract, nor doing gas calculations, as both gas price and opcode \n    * costs can vary.\n    * \n    * All Troves that are redeemed from -- with the likely exception of the last one -- will end up with no debt left, therefore they will be closed.\n    * If the last Trove does have some remaining debt, it has a finite ICR, and the reinsertion could be anywhere in the list, therefore it requires a hint. \n    * A frontend should use getRedemptionHints() to calculate what the ICR of this Trove will be after redemption, and pass a hint for its position \n    * in the sortedTroves list along with the ICR value that the hint was found for.\n    * \n    * If another transaction modifies the list between calling getRedemptionHints() and passing the hints to redeemCollateral(), it\n    * is very likely that the last (partially) redeemed Trove would end up with a different ICR than what the hint is for. In this case the\n    * redemption will stop after the last completely redeemed Trove and the sender will keep the remaining LUSD amount, which they can attempt\n    * to redeem later.\n    */\n    function redeemCollateral(\n        uint _LUSDamount,\n        address _firstRedemptionHint,\n        address _partialRedemptionHint,\n        uint _partialRedemptionHintICR,\n        uint _maxIterations\n    )\n        external\n        override\n    {\n        uint activeDebt = activePool.getLUSDDebt();\n        uint defaultedDebt = defaultPool.getLUSDDebt();\n\n        RedemptionTotals memory T;\n\n        _requireAmountGreaterThanZero(_LUSDamount);\n        _requireLUSDBalanceCoversRedemption(msg.sender, _LUSDamount);\n\n        // Confirm redeemer's balance is less than total systemic debt\n        assert(lusdToken.balanceOf(msg.sender) <= (activeDebt.add(defaultedDebt)));\n\n        uint remainingLUSD = _LUSDamount;\n        uint price = priceFeed.getPrice();\n        address currentBorrower;\n\n        if (_isValidFirstRedemptionHint(_firstRedemptionHint, price)) {\n            currentBorrower = _firstRedemptionHint;\n        } else {\n            currentBorrower = sortedTroves.getLast();\n            // Find the first trove with ICR >= MCR\n            // SWC-104-Unchecked Call Return Value: L920\n            while (currentBorrower != address(0) && getCurrentICR(currentBorrower, price) < MCR) {\n                currentBorrower = sortedTroves.getPrev(currentBorrower);\n            }\n        }\n\n        // Loop through the Troves starting from the one with lowest collateral ratio until _amount of LUSD is exchanged for collateral\n        if (_maxIterations == 0) { _maxIterations = uint(-1); }\n        while (currentBorrower != address(0) && remainingLUSD > 0 && _maxIterations > 0) {\n            _maxIterations--;\n            // Save the address of the Trove preceding the current one, before potentially modifying the list\n            address nextUserToCheck = sortedTroves.getPrev(currentBorrower);\n\n            _applyPendingRewards(currentBorrower);\n            SingleRedemptionValues memory V = _redeemCollateralFromTrove(\n                currentBorrower,\n                remainingLUSD,\n                price,\n                _partialRedemptionHint,\n                _partialRedemptionHintICR\n            );\n\n            if (V.LUSDLot == 0) break; // Partial redemption hint got out-of-date, therefore we could not redeem from the last Trove\n\n            T.totalLUSDToRedeem  = T.totalLUSDToRedeem.add(V.LUSDLot);\n            T.totalETHDrawn = T.totalETHDrawn.add(V.ETHLot);\n\n            remainingLUSD = remainingLUSD.sub(V.LUSDLot);\n            currentBorrower = nextUserToCheck;\n        }\n\n        // Decay the baseRate due to time passed, and then increase it according to the size of this redemption\n        _updateBaseRateFromRedemption(T.totalETHDrawn, price);\n\n        // Calculate the ETH fee and send it to the LQTY staking contract\n        T.ETHFee = _getRedemptionFee(T.totalETHDrawn);\n        activePool.sendETH(lqtyStakingAddress, T.ETHFee);\n        lqtyStaking.increaseF_ETH(T.ETHFee);\n\n        T.ETHToSendToRedeemer = T.totalETHDrawn.sub(T.ETHFee);\n\n        // Burn the total LUSD that is cancelled with debt, and send the redeemed ETH to msg.sender\n        _activePoolRedeemCollateral(msg.sender, T.totalLUSDToRedeem, T.ETHToSendToRedeemer);\n\n        emit Redemption(_LUSDamount, T.totalLUSDToRedeem, T.totalETHDrawn, T.ETHFee);\n    }\n\n    // Burn the received LUSD, transfer the redeemed ETH to _redeemer and updates the Active Pool\n    function _activePoolRedeemCollateral(address _redeemer, uint _LUSD, uint _ETH) internal {\n        // Update Active Pool LUSD, and send ETH to account\n        lusdToken.burn(_redeemer, _LUSD);\n        activePool.decreaseLUSDDebt(_LUSD);\n\n        activePool.sendETH(_redeemer, _ETH);\n    }\n\n    // --- Helper functions ---\n\n\n    // Return the current collateral ratio (ICR) of a given Trove. Takes a trove's pending coll and debt rewards from redistributions into account.\n    function getCurrentICR(address _borrower, uint _price) public view override returns (uint) {\n        uint pendingETHReward = getPendingETHReward(_borrower);\n        uint pendingLUSDDebtReward = getPendingLUSDDebtReward(_borrower);\n\n        uint currentETH = Troves[_borrower].coll.add(pendingETHReward);\n        uint currentLUSDDebt = Troves[_borrower].debt.add(pendingLUSDDebtReward);\n\n        uint ICR = LiquityMath._computeCR(currentETH, currentLUSDDebt, _price);\n        return ICR;\n    }\n\n    function applyPendingRewards(address _borrower) external override {\n        _requireCallerIsBorrowerOperations();\n        return _applyPendingRewards(_borrower);\n    }\n\n    // Add the borrowers's coll and debt rewards earned from redistributions, to their Trove\n    function _applyPendingRewards(address _borrower) internal {\n        if (hasPendingRewards(_borrower)) {\n            _requireTroveisActive(_borrower);\n\n            // Compute pending rewards\n            uint pendingETHReward = getPendingETHReward(_borrower);\n            uint pendingLUSDDebtReward = getPendingLUSDDebtReward(_borrower);\n\n            // Apply pending rewards to trove's state\n            Troves[_borrower].coll = Troves[_borrower].coll.add(pendingETHReward);\n            Troves[_borrower].debt = Troves[_borrower].debt.add(pendingLUSDDebtReward);\n\n            _updateTroveRewardSnapshots(_borrower);\n\n            // Transfer from DefaultPool to ActivePool\n            _movePendingTroveRewardsToActivePool(pendingLUSDDebtReward, pendingETHReward);\n\n            emit TroveUpdated(\n                _borrower, \n                Troves[_borrower].debt, \n                Troves[_borrower].coll, \n                Troves[_borrower].stake, \n                TroveManagerOperation.applyPendingRewards\n            );\n        }\n    }\n\n    // Update borrower's snapshots of L_ETH and L_LUSDDebt to reflect the current values\n    function updateTroveRewardSnapshots(address _borrower) external override {\n        _requireCallerIsBorrowerOperations();\n       return _updateTroveRewardSnapshots(_borrower);\n    }\n\n    function _updateTroveRewardSnapshots(address _borrower) internal {\n        rewardSnapshots[_borrower].ETH = L_ETH;\n        rewardSnapshots[_borrower].LUSDDebt = L_LUSDDebt;\n    }\n\n    // Get the borrower's pending accumulated ETH reward, earned by their stake\n    function getPendingETHReward(address _borrower) public view override returns (uint) {\n        uint snapshotETH = rewardSnapshots[_borrower].ETH;\n        uint rewardPerUnitStaked = L_ETH.sub(snapshotETH);\n\n        if ( rewardPerUnitStaked == 0 ) { return 0; }\n\n        uint stake = Troves[_borrower].stake;\n\n        uint pendingETHReward = stake.mul(rewardPerUnitStaked).div(1e18);\n\n        return pendingETHReward;\n    }\n\n     // Get the borrower's pending accumulated LUSD reward, earned by their stake\n    function getPendingLUSDDebtReward(address _borrower) public view override returns (uint) {\n        uint snapshotLUSDDebt = rewardSnapshots[_borrower].LUSDDebt;\n        uint rewardPerUnitStaked = L_LUSDDebt.sub(snapshotLUSDDebt);\n\n        if ( rewardPerUnitStaked == 0 ) { return 0; }\n\n        uint stake =  Troves[_borrower].stake;\n\n        uint pendingLUSDDebtReward = stake.mul(rewardPerUnitStaked).div(1e18);\n\n        return pendingLUSDDebtReward;\n    }\n\n    function hasPendingRewards(address _borrower) public view override returns (bool) {\n        /* \n        * A Trove has pending rewards if its snapshot is less than the current rewards per-unit-staked sum:\n        * this indicates that rewards have occured since the snapshot was made, and the user therefore has\n        * pending rewards \n        */\n        return (rewardSnapshots[_borrower].ETH < L_ETH);\n    }\n\n    // Return the Troves entire debt and coll, including pending rewards from redistributions.\n    function getEntireDebtAndColl(\n        address _borrower\n    )\n        public\n        view\n        override\n        returns (uint debt, uint coll, uint pendingLUSDDebtReward, uint pendingETHReward)\n    {\n        debt = Troves[_borrower].debt;\n        coll = Troves[_borrower].coll;\n\n        pendingLUSDDebtReward = getPendingLUSDDebtReward(_borrower);\n        pendingETHReward = getPendingETHReward(_borrower);\n\n        debt = debt.add(pendingLUSDDebtReward);\n        coll = coll.add(pendingETHReward);\n    }\n\n    function removeStake(address _borrower) external override {\n        _requireCallerIsBorrowerOperations();\n        return _removeStake(_borrower);\n    }\n\n    // Remove borrower's stake from the totalStakes sum, and set their stake to 0\n    function _removeStake(address _borrower) internal {\n        uint stake = Troves[_borrower].stake;\n        totalStakes = totalStakes.sub(stake);\n        Troves[_borrower].stake = 0;\n    }\n\n    function updateStakeAndTotalStakes(address _borrower) external override returns (uint) {\n        _requireCallerIsBorrowerOperations();\n        return _updateStakeAndTotalStakes(_borrower);\n    }\n\n    // Update borrower's stake based on their latest collateral value\n    function _updateStakeAndTotalStakes(address _borrower) internal returns (uint) {\n        uint newStake = _computeNewStake(Troves[_borrower].coll);\n        uint oldStake = Troves[_borrower].stake;\n        Troves[_borrower].stake = newStake;\n        totalStakes = totalStakes.sub(oldStake).add(newStake);\n\n        return newStake;\n    }\n\n    // Calculate a new stake based on the snapshots of the totalStakes and totalCollateral taken at the last liquidation\n    function _computeNewStake(uint _coll) internal view returns (uint) {\n        uint stake;\n        if (totalCollateralSnapshot == 0) {\n            stake = _coll;\n        } else {\n            /*  \n            * The following assert() holds true because:\n            * - The system always contains >= 1 trove \n            * - When we close or liquidate a trove, we redistribute the pending rewards, so if all troves were closed/liquidated, \n            * rewards wouldve been emptied and totalCollateralSnapshot would be zero too.\n            */\n            assert(totalStakesSnapshot > 0);\n            stake = _coll.mul(totalStakesSnapshot).div(totalCollateralSnapshot);\n        }\n        return stake;\n    }\n\n    function _redistributeDebtAndColl(uint _debt, uint _coll) internal {\n        if (_debt == 0) { return; }\n\n        if (totalStakes > 0) {\n            /* \n            * Add distributed coll and debt rewards-per-unit-staked to the running totals.\n            * Division uses a \"feedback\" error correction, to keep the cumulative error in\n            * the  L_ETH and L_LUSDDebt state variables low. \n            */\n            uint ETHNumerator = _coll.mul(1e18).add(lastETHError_Redistribution);\n            uint LUSDDebtNumerator = _debt.mul(1e18).add(lastLUSDDebtError_Redistribution);\n\n            uint ETHRewardPerUnitStaked = ETHNumerator.div(totalStakes);\n            uint LUSDDebtRewardPerUnitStaked = LUSDDebtNumerator.div(totalStakes);\n\n            lastETHError_Redistribution = ETHNumerator.sub(ETHRewardPerUnitStaked.mul(totalStakes));\n            lastLUSDDebtError_Redistribution = LUSDDebtNumerator.sub(LUSDDebtRewardPerUnitStaked.mul(totalStakes));\n\n            L_ETH = L_ETH.add(ETHRewardPerUnitStaked);\n            L_LUSDDebt = L_LUSDDebt.add(LUSDDebtRewardPerUnitStaked);\n        }\n\n        // Transfer coll and debt from ActivePool to DefaultPool\n        activePool.decreaseLUSDDebt(_debt);\n        defaultPool.increaseLUSDDebt(_debt);\n        activePool.sendETH(address(defaultPool), _coll);\n    }\n\n    function closeTrove(address _borrower) external override {\n        _requireCallerIsBorrowerOperations();\n        return _closeTrove(_borrower);\n    }\n\n    function _closeTrove(address _borrower) internal {\n        uint TroveOwnersArrayLength = TroveOwners.length;\n        _requireMoreThanOneTroveInSystem(TroveOwnersArrayLength);\n\n        Troves[_borrower].status = Status.closed;\n        Troves[_borrower].coll = 0;\n        Troves[_borrower].debt = 0;\n\n        rewardSnapshots[_borrower].ETH = 0;\n        rewardSnapshots[_borrower].LUSDDebt = 0;\n\n        _removeTroveOwner(_borrower, TroveOwnersArrayLength);\n        sortedTroves.remove(_borrower);\n    }\n\n    /* \n    * Updates snapshots of system total stakes and total collateral, excluding a given collateral remainder from the calculation. \n    * Used in a liquidation sequence.\n    *\n    * The calculation excludes two portions of collateral that are in the ActivePool: \n    *\n    * 1) the total ETH gas compensation from the liquidation sequence\n    * 2) The remaining collateral in a partially liquidated trove (if one occurred)\n    *\n    * The ETH as compensation must be excluded as it is always sent out at the very end of the liquidation sequence.\n    *\n    * The partially liquidated trove's remaining collateral stays in the ActivePool, but it is excluded here so the system \n    * can take snapshots before the partially liquidated trove's stake is updated (based on these snapshots). This ensures\n    * the partial's new stake doesn't double-count its own remaining collateral.\n    *\n    */\n    function _updateSystemSnapshots_excludeCollRemainder(uint _collRemainder) internal {\n        totalStakesSnapshot = totalStakes;\n\n        uint activeColl = activePool.getETH();\n        uint liquidatedColl = defaultPool.getETH();\n        totalCollateralSnapshot = activeColl.sub(_collRemainder).add(liquidatedColl);\n    }\n\n    // Push the owner's address to the Trove owners list, and record the corresponding array index on the Trove struct\n    function addTroveOwnerToArray(address _borrower) external override returns (uint index) {\n        _requireCallerIsBorrowerOperations();\n        return _addTroveOwnerToArray(_borrower);\n    }\n\n    function _addTroveOwnerToArray(address _borrower) internal returns (uint128 index) {\n        require(TroveOwners.length < 2**128 - 1, \"TroveManager: TroveOwners array has maximum size of 2^128 - 1\");\n\n        // Push the Troveowner to the array\n        TroveOwners.push(_borrower);\n\n        // Record the index of the new Troveowner on their Trove struct\n        index = uint128(TroveOwners.length.sub(1));\n        Troves[_borrower].arrayIndex = index;\n\n        return index;\n    }\n\n    /* \n    * Remove a Trove owner from the TroveOwners array, not preserving array order. Removing owner 'B' does the following:\n    * [A B C D E] => [A E C D], and updates E's Trove struct to point to its new array index. \n    */\n    function _removeTroveOwner(address _borrower, uint TroveOwnersArrayLength) internal {\n        require(Troves[_borrower].status == Status.closed, \"TroveManager: Trove is still active\");\n\n        uint128 index = Troves[_borrower].arrayIndex;\n        uint length = TroveOwnersArrayLength;\n        uint idxLast = length.sub(1);\n\n        assert(index <= idxLast);\n\n        address addressToMove = TroveOwners[idxLast];\n\n        TroveOwners[index] = addressToMove;\n        Troves[addressToMove].arrayIndex = index;\n        TroveOwners.pop();\n    }\n\n    // --- Recovery Mode and TCR functions ---\n\n    function checkRecoveryMode() public view override returns (bool) {\n        uint TCR = getTCR();\n\n        if (TCR < CCR) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    // Check whether or not the system *would be* in Recovery Mode, given an ETH:USD price, and the entire system coll and debt.\n    function _checkPotentialRecoveryMode(\n        uint _entireSystemColl,\n        uint _entireSystemDebt,\n        uint _price\n    )\n        internal\n        pure\n    returns (bool)\n    {\n        uint TCR = LiquityMath._computeCR(_entireSystemColl, _entireSystemDebt, _price);\n        if (TCR < CCR) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n    // SWC-135-Code With No Effects: L1276-L1284\n    function getTCR() public view override returns (uint TCR) {\n        uint price = priceFeed.getPrice();\n        uint entireSystemColl = getEntireSystemColl();\n        uint entireSystemDebt = getEntireSystemDebt();\n\n        TCR = LiquityMath._computeCR(entireSystemColl, entireSystemDebt, price);\n\n        return TCR;\n    }\n    // SWC-135-Code With No Effects: L1286-L1291\n    function getEntireSystemColl() public view override returns (uint entireSystemColl) {\n        uint activeColl = activePool.getETH();\n        uint liquidatedColl = defaultPool.getETH();\n\n        return activeColl.add(liquidatedColl);\n    }\n\n    function getEntireSystemDebt() public view override returns (uint entireSystemDebt) {\n        uint activeDebt = activePool.getLUSDDebt();\n        uint closedDebt = defaultPool.getLUSDDebt();\n\n        return activeDebt.add(closedDebt);\n    }\n\n    // --- Redemption fee functions ---\n\n    /* \n    * This function has two impacts on the baseRate state variable:\n    * 1) decays the baseRate based on time passed since last redemption or LUSD borrowing operation.\n    * then,\n    * 2) increases the baseRate based on the amount redeemed, as a proportion of total supply\n    */\n    function _updateBaseRateFromRedemption(uint _ETHDrawn,  uint _price) internal returns (uint) {\n        uint decayedBaseRate = _calcDecayedBaseRate();\n\n        uint activeDebt = activePool.getLUSDDebt();\n        uint closedDebt = defaultPool.getLUSDDebt();\n        uint totalLUSDSupply = activeDebt.add(closedDebt);\n\n        /* Convert the drawn ETH back to LUSD at face value rate (1 LUSD:1 USD), in order to get\n        * the fraction of total supply that was redeemed at face value. */\n        uint redeemedLUSDFraction = _ETHDrawn.mul(_price).div(totalLUSDSupply);\n\n        uint newBaseRate = decayedBaseRate.add(redeemedLUSDFraction.div(BETA));\n\n        // Update the baseRate state variable\n        baseRate = newBaseRate < 1e18 ? newBaseRate : 1e18;  // cap baseRate at a maximum of 100%\n        assert(baseRate <= 1e18 && baseRate > 0); // Base rate is always non-zero after redemption\n\n        _updateLastFeeOpTime();\n\n        return baseRate;\n    }\n\n    function _getRedemptionFee(uint _ETHDrawn) internal view returns (uint) {\n       return baseRate.mul(_ETHDrawn).div(1e18);\n    }\n\n    // --- Borrowing fee functions ---\n\n    function getBorrowingFee(uint _LUSDDebt) external view override returns (uint) {\n        return _LUSDDebt.mul(baseRate).div(1e18);\n    }\n\n    // Updates the baseRate state variable based on time elapsed since the last redemption or LUSD borrowing operation.\n    function decayBaseRateFromBorrowing() external override {\n        _requireCallerIsBorrowerOperations();\n\n        baseRate = _calcDecayedBaseRate();\n        assert(baseRate <= 1e18);  // The baseRate can decay to 0\n\n        _updateLastFeeOpTime();\n    }\n\n    // --- Internal fee functions ---\n\n    // Update the last fee operation time only if time passed >= decay interval. This prevents base rate griefing.\n    function _updateLastFeeOpTime() internal {\n        uint timePassed = block.timestamp.sub(lastFeeOperationTime);\n\n        if (timePassed >= SECONDS_IN_ONE_MINUTE) {\n            lastFeeOperationTime = block.timestamp;\n        }\n    }\n\n    function _calcDecayedBaseRate() internal view returns (uint) {\n        uint minutesPassed = _minutesPassedSinceLastFeeOp();\n        uint decayFactor = LiquityMath._decPow(MINUTE_DECAY_FACTOR, minutesPassed);\n\n        return baseRate.mul(decayFactor).div(1e18);\n    }\n\n    function _minutesPassedSinceLastFeeOp() internal view returns (uint) {\n        return (block.timestamp.sub(lastFeeOperationTime)).div(SECONDS_IN_ONE_MINUTE);\n    }\n\n    // --- 'require' wrapper functions ---\n\n    function _requireCallerIsBorrowerOperations() internal view {\n        require(msg.sender == borrowerOperationsAddress, \"TroveManager: Caller is not the BorrowerOperations contract\");\n    }\n\n    function _requireTroveisActive(address _borrower) internal view {\n        require(Troves[_borrower].status == Status.active, \"TroveManager: Trove does not exist or is closed\");\n    }\n\n    function _requireLUSDBalanceCoversRedemption(address _redeemer, uint _amount) internal view {\n        require(lusdToken.balanceOf(_redeemer) >= _amount, \"TroveManager: Requested redemption amount must be <= user's LUSD token balance\");\n    }\n\n    function _requireMoreThanOneTroveInSystem(uint TroveOwnersArrayLength) internal view {\n        require (TroveOwnersArrayLength > 1 && sortedTroves.getSize() > 1, \"TroveManager: Only one trove in the system\");\n    }\n\n    function _requireAmountGreaterThanZero(uint _amount) internal pure {\n        require(_amount > 0, \"TroveManager: Amount must be greater than zero\");\n    }\n\n    // --- Trove property getters ---\n\n    function getTroveStatus(address _borrower) external view override returns (uint) {\n        return uint(Troves[_borrower].status);\n    }\n\n    function getTroveStake(address _borrower) external view override returns (uint) {\n        return Troves[_borrower].stake;\n    }\n\n    function getTroveDebt(address _borrower) external view override returns (uint) {\n        return Troves[_borrower].debt;\n    }\n\n    function getTroveColl(address _borrower) external view override returns (uint) {\n        return Troves[_borrower].coll;\n    }\n\n    // --- Trove property setters, called by BorrowerOperations ---\n\n    function setTroveStatus(address _borrower, uint _num) external override {\n        _requireCallerIsBorrowerOperations();\n        Troves[_borrower].status = Status(_num);\n    }\n\n    function increaseTroveColl(address _borrower, uint _collIncrease) external override returns (uint) {\n        _requireCallerIsBorrowerOperations();\n        uint newColl = Troves[_borrower].coll.add(_collIncrease);\n        Troves[_borrower].coll = newColl;\n        return newColl;\n    }\n\n    function decreaseTroveColl(address _borrower, uint _collDecrease) external override returns (uint) {\n        _requireCallerIsBorrowerOperations();\n        uint newColl = Troves[_borrower].coll.sub(_collDecrease);\n        Troves[_borrower].coll = newColl;\n        return newColl;\n    }\n\n    function increaseTroveDebt(address _borrower, uint _debtIncrease) external override returns (uint) {\n        _requireCallerIsBorrowerOperations();\n        uint newDebt = Troves[_borrower].debt.add(_debtIncrease);\n        Troves[_borrower].debt = newDebt;\n        return newDebt;\n    }\n\n    function decreaseTroveDebt(address _borrower, uint _debtDecrease) external override returns (uint) {\n        _requireCallerIsBorrowerOperations();\n        uint newDebt = Troves[_borrower].debt.sub(_debtDecrease);\n        Troves[_borrower].debt = newDebt;\n        return newDebt;\n    }\n}",
        "function": "getEntireSystemDebt()",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-Liquity/dev-f0df3efa5a5f05b205752184cfce107c5bd6e06c/packages/contracts/contracts/TroveManager.sol",
        "vulnerability": "Multiple Calls in a Single Transaction (SWC 113)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract TroveManager is LiquityBase, Ownable, ITroveManager {\n\n    // --- Connected contract declarations ---\n\n    address public borrowerOperationsAddress;\n\n    IPool public activePool;\n\n    IPool public defaultPool;\n\n    IStabilityPool public stabilityPool;\n\n    ICollSurplusPool collSurplusPool;\n\n    ILUSDToken public lusdToken;\n\n    IPriceFeed public priceFeed;\n\n    ILQTYStaking public lqtyStaking;\n    address public lqtyStakingAddress;\n\n    // A doubly linked list of Troves, sorted by their sorted by their collateral ratios\n    ISortedTroves public sortedTroves;\n\n    // --- Data structures ---\n\n    uint constant public SECONDS_IN_ONE_MINUTE = 60;\n    uint constant public MINUTE_DECAY_FACTOR = 999832508430720967;  // 18 digit decimal. Corresponds to an hourly decay factor of 0.99\n\n    /* \n    * BETA: 18 digit decimal. Parameter by which to divide the redeemed fraction, in order to calc the new base rate from a redemption. \n    * Corresponds to (1 / ALPHA) in the white paper. \n    */\n    uint constant public BETA = 2;\n\n    uint public baseRate;\n\n    // The timestamp of the latest fee operation (redemption or new LUSD issuance) \n    uint public lastFeeOperationTime;\n\n    enum Status { nonExistent, active, closed }\n\n    // Store the necessary data for a trove\n    struct Trove {\n        uint debt;\n        uint coll;\n        uint stake;\n        Status status;\n        uint128 arrayIndex;\n    }\n\n    mapping (address => Trove) public Troves;\n\n    uint public totalStakes;\n\n    // Snapshot of the value of totalStakes, taken immediately after the latest liquidation\n    uint public totalStakesSnapshot;\n\n    // Snapshot of the total collateral across the ActivePool and DefaultPool, immediately after the latest liquidation.\n    uint public totalCollateralSnapshot;\n\n    /*\n    * L_ETH and L_LUSDDebt track the sums of accumulated liquidation rewards per unit staked. During its lifetime, each stake earns:\n    *\n    * An ETH gain of ( stake * [L_ETH - L_ETH(0)] )\n    * A LUSDDebt increase  of ( stake * [L_LUSDDebt - L_LUSDDebt(0)] )\n    *\n    * Where L_ETH(0) and L_LUSDDebt(0) are snapshots of L_ETH and L_LUSDDebt for the active Trove taken at the instant the stake was made\n    */\n    uint public L_ETH;\n    uint public L_LUSDDebt;\n\n    // Map addresses with active troves to their RewardSnapshot\n    mapping (address => RewardSnapshot) public rewardSnapshots;\n\n    // Object containing the ETH and LUSD snapshots for a given active trove\n    struct RewardSnapshot { uint ETH; uint LUSDDebt;}\n\n    // Array of all active trove addresses - used to to compute an approximate hint off-chain, for the sorted list insertion\n    address[] public TroveOwners;\n\n    // Error trackers for the trove redistribution calculation\n    uint public lastETHError_Redistribution;\n    uint public lastLUSDDebtError_Redistribution;\n\n    /* \n    * --- Variable container structs for liquidations ---\n    *\n    * These structs are used to hold, return and assign variables inside the liquidation functions,\n    * in order to avoid the error: \"CompilerError: Stack too deep\". \n    **/\n\n    struct LocalVariables_OuterLiquidationFunction {\n        uint price;\n        uint LUSDInStabPool;\n        bool recoveryModeAtStart;\n        uint liquidatedDebt;\n        uint liquidatedColl;\n    }\n\n    struct LocalVariables_InnerSingleLiquidateFunction {\n        uint collToLiquidate;\n        uint pendingDebtReward;\n        uint pendingCollReward;\n    }\n\n    struct LocalVariables_LiquidationSequence {\n        uint remainingLUSDInStabPool;\n        uint i;\n        uint ICR;\n        address user;\n        bool backToNormalMode;\n        uint entireSystemDebt;\n        uint entireSystemColl;\n    }\n\n    struct LiquidationValues {\n        uint entireTroveDebt;\n        uint entireTroveColl;\n        uint collGasCompensation;\n        uint LUSDGasCompensation;\n        uint debtToOffset;\n        uint collToSendToSP;\n        uint debtToRedistribute;\n        uint collToRedistribute;\n        address partialAddr;\n        uint partialNewDebt;\n        uint partialNewColl;\n        address partialUpperHint;\n        address partialLowerHint;\n    }\n\n    struct LiquidationTotals {\n        uint totalCollInSequence;\n        uint totalDebtInSequence;\n        uint totalCollGasCompensation;\n        uint totalLUSDGasCompensation;\n        uint totalDebtToOffset;\n        uint totalCollToSendToSP;\n        uint totalDebtToRedistribute;\n        uint totalCollToRedistribute;\n        address partialAddr;\n        uint partialNewDebt;\n        uint partialNewColl;\n        address partialUpperHint;\n        address partialLowerHint;\n    }\n\n    // --- Variable container structs for redemptions ---\n\n    struct RedemptionTotals {\n        uint totalLUSDToRedeem;\n        uint totalETHDrawn;\n        uint ETHFee;\n        uint ETHToSendToRedeemer;\n        uint decayedBaseRate;\n    }\n\n    struct SingleRedemptionValues {\n        uint LUSDLot;\n        uint ETHLot;\n    }\n\n    // --- Events ---\n\n    event Liquidation(uint _liquidatedDebt, uint _liquidatedColl, uint _collGasCompensation, uint _LUSDGasCompensation);\n    event Redemption(uint _attemptedLUSDAmount, uint _actualLUSDAmount, uint _ETHSent, uint _ETHFee);\n\n    enum TroveManagerOperation {\n        applyPendingRewards,\n        liquidateInNormalMode,\n        liquidateInRecoveryMode,\n        partiallyLiquidateInRecoveryMode,\n        redeemCollateral\n    }\n\n    event TroveCreated(address indexed _borrower, uint _arrayIndex);\n    event TroveUpdated(address indexed _borrower, uint _debt, uint _coll, uint _stake, TroveManagerOperation _operation);\n    event TroveLiquidated(address indexed _borrower, uint _debt, uint _coll, TroveManagerOperation _operation);\n\n    // --- Dependency setter ---\n\n    function setAddresses(\n        address _borrowerOperationsAddress,\n        address _activePoolAddress,\n        address _defaultPoolAddress,\n        address _stabilityPoolAddress,\n        address _collSurplusPoolAddress,\n        address _priceFeedAddress,\n        address _lusdTokenAddress,\n        address _sortedTrovesAddress,\n        address _lqtyStakingAddress\n    )\n        external\n        override\n        onlyOwner\n    {\n        borrowerOperationsAddress = _borrowerOperationsAddress;\n        activePool = IPool(_activePoolAddress);\n        defaultPool = IPool(_defaultPoolAddress);\n        stabilityPool = IStabilityPool(_stabilityPoolAddress);\n        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);\n        priceFeed = IPriceFeed(_priceFeedAddress);\n        lusdToken = ILUSDToken(_lusdTokenAddress);\n        sortedTroves = ISortedTroves(_sortedTrovesAddress);\n        lqtyStakingAddress = _lqtyStakingAddress;\n        lqtyStaking = ILQTYStaking(_lqtyStakingAddress);\n\n        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);\n        emit ActivePoolAddressChanged(_activePoolAddress);\n        emit DefaultPoolAddressChanged(_defaultPoolAddress);\n        emit StabilityPoolAddressChanged(_stabilityPoolAddress);\n        emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);\n        emit PriceFeedAddressChanged(_priceFeedAddress);\n        emit LUSDTokenAddressChanged(_lusdTokenAddress);\n        emit SortedTrovesAddressChanged(_sortedTrovesAddress);\n        emit LQTYStakingAddressChanged(_lqtyStakingAddress);\n\n        _renounceOwnership();\n    }\n\n    // --- Getters ---\n\n    function getTroveOwnersCount() external view override returns (uint) {\n        return TroveOwners.length;\n    }\n\n    function getTroveFromTroveOwnersArray(uint _index) external view override returns (address) {\n        return TroveOwners[_index];\n    }\n\n    // --- Trove Liquidation functions ---\n\n    // Single liquidation function. Closes the trove if its ICR is lower than the minimum collateral ratio. \n    function liquidate(address _borrower) external override {\n        _requireTroveisActive(_borrower);\n\n        address[] memory borrowers = new address[](1);\n        borrowers[0] = _borrower;\n        batchLiquidateTroves(borrowers);\n    }\n\n    // --- Inner single liquidation functions ---\n\n    // Liquidate one trove, in Normal Mode.\n    function _liquidateNormalMode(address _borrower, uint _LUSDInStabPool) internal returns (LiquidationValues memory V) {\n        LocalVariables_InnerSingleLiquidateFunction memory L;\n\n        (V.entireTroveDebt,\n        V.entireTroveColl,\n        L.pendingDebtReward,\n        L.pendingCollReward) = getEntireDebtAndColl(_borrower);\n\n        _movePendingTroveRewardsToActivePool(L.pendingDebtReward, L.pendingCollReward);\n        _removeStake(_borrower);\n\n        V.collGasCompensation = _getCollGasCompensation(V.entireTroveColl);\n        V.LUSDGasCompensation = LUSD_GAS_COMPENSATION;\n        uint collToLiquidate = V.entireTroveColl.sub(V.collGasCompensation);\n\n        (V.debtToOffset,\n        V.collToSendToSP,\n        V.debtToRedistribute,\n        V.collToRedistribute) = _getOffsetAndRedistributionVals(V.entireTroveDebt, collToLiquidate, _LUSDInStabPool);\n\n        _closeTrove(_borrower);\n        emit TroveLiquidated(_borrower, V.entireTroveDebt, V.entireTroveColl, TroveManagerOperation.liquidateInNormalMode);\n\n        return V;\n    }\n\n    // Liquidate one trove, in Recovery Mode.\n    function _liquidateRecoveryMode(address _borrower, uint _ICR, uint _LUSDInStabPool, uint _TCR) internal returns (LiquidationValues memory V) {\n        LocalVariables_InnerSingleLiquidateFunction memory L;\n        \n        if (TroveOwners.length <= 1) { return V; } // don't liquidate if last trove\n\n        (V.entireTroveDebt,\n        V.entireTroveColl,\n        L.pendingDebtReward,\n        L.pendingCollReward) = getEntireDebtAndColl(_borrower);\n\n        _movePendingTroveRewardsToActivePool(L.pendingDebtReward, L.pendingCollReward);\n\n        V.collGasCompensation = _getCollGasCompensation(V.entireTroveColl);\n        // In case of a partial liquidation, V.LUSDGasCompensation will be overwritten to zero, in the third branch below\n        V.LUSDGasCompensation = LUSD_GAS_COMPENSATION;\n        L.collToLiquidate = V.entireTroveColl.sub(V.collGasCompensation);\n\n        // If ICR <= 100%, purely redistribute the Trove across all active Troves\n        if (_ICR <= _100pct) {\n            _removeStake(_borrower);\n\n            V.debtToOffset = 0;\n            V.collToSendToSP = 0;\n            V.debtToRedistribute = V.entireTroveDebt;\n            V.collToRedistribute = L.collToLiquidate;\n\n            _closeTrove(_borrower);\n            emit TroveLiquidated(_borrower, V.entireTroveDebt, V.entireTroveColl, TroveManagerOperation.liquidateInRecoveryMode);\n\n        // If 100% < ICR < MCR, offset as much as possible, and redistribute the remainder\n        } else if ((_ICR > _100pct) && (_ICR < MCR)) {\n            _removeStake(_borrower);\n\n            (V.debtToOffset,\n            V.collToSendToSP,\n            V.debtToRedistribute,\n            V.collToRedistribute) = _getOffsetAndRedistributionVals(V.entireTroveDebt, L.collToLiquidate, _LUSDInStabPool);\n\n            _closeTrove(_borrower);\n            emit TroveLiquidated(_borrower, V.entireTroveDebt, V.entireTroveColl, TroveManagerOperation.liquidateInRecoveryMode);\n\n        /* \n        * If 110% <= ICR < current TCR (accounting for the preceding liquidations in the current sequence)\n        * and there is LUSD in the Stability Pool, only offset it as much as possible, with no redistribution.\n        */\n        } else if ((_ICR >= MCR) && (_ICR < _TCR)) {\n            assert(_LUSDInStabPool != 0);\n\n            _removeStake(_borrower);\n            \n            V = _getFullOrPartialOffsetVals(_borrower, V.entireTroveDebt, V.entireTroveColl, _LUSDInStabPool);\n\n            _closeTrove(_borrower);\n        }\n        else if (_ICR >= _TCR) {\n            LiquidationValues memory zeroVals;\n            return zeroVals;\n        }\n\n        return V;\n    }\n\n    /* In a full liquidation, returns the values for a trove's coll and debt to be offset, and coll and debt to be \n    * redistributed to active troves. \n    */\n    function _getOffsetAndRedistributionVals\n    (\n        uint _debt,\n        uint _coll,\n        uint _LUSDInStabPool\n    )\n        internal\n        pure\n        returns (uint debtToOffset, uint collToSendToSP, uint debtToRedistribute, uint collToRedistribute)\n    {\n        if (_LUSDInStabPool > 0) {\n        /* \n        * Offset as much debt & collateral as possible against the Stability Pool, and redistribute the remainder\n        * between all active troves.\n        *\n        *  If the trove's debt is larger than the deposited LUSD in the Stability Pool:\n        *\n        *  - Offset an amount of the trove's debt equal to the LUSD in the Stability Pool\n        *  - Send a fraction of the trove's collateral to the Stability Pool, equal to the fraction of its offset debt\n        *\n        */\n            debtToOffset = LiquityMath._min(_debt, _LUSDInStabPool);\n            collToSendToSP = _coll.mul(debtToOffset).div(_debt);\n            debtToRedistribute = _debt.sub(debtToOffset);\n            collToRedistribute = _coll.sub(collToSendToSP);\n        } else {\n            debtToOffset = 0;\n            collToSendToSP = 0;\n            debtToRedistribute = _debt;\n            collToRedistribute = _coll;\n        }\n    }\n\n    /*\n    *  If it is a full offset, get its offset coll/debt and ETH gas comp, and close the trove.\n    *\n    * If it is a partial liquidation, get its offset coll/debt and ETH gas comp, and its new coll/debt, and its re-insertion hints.\n    */\n    function _getFullOrPartialOffsetVals\n    (\n        address _borrower,\n        uint _entireTroveDebt,\n        uint _entireTroveColl,\n        uint _LUSDInStabPool\n    )\n        internal\n        returns (LiquidationValues memory V)\n    {\n        V.entireTroveDebt = _entireTroveDebt;\n        V.entireTroveColl = _entireTroveColl;\n\n        // When Stability Pool can fully absorb the trove's debt, perform a full offset\n        if (_entireTroveDebt <= _LUSDInStabPool) {\n            V.collGasCompensation = _getCollGasCompensation(_entireTroveColl);\n            V.LUSDGasCompensation = LUSD_GAS_COMPENSATION;\n\n            V.debtToOffset = _entireTroveDebt;\n            V.collToSendToSP = _entireTroveColl.sub(V.collGasCompensation);\n            V.debtToRedistribute = 0;\n            V.collToRedistribute = 0;\n\n            emit TroveLiquidated(_borrower, _entireTroveDebt, _entireTroveColl, TroveManagerOperation.liquidateInRecoveryMode);\n        }\n        /* \n        * When trove's debt is greater than the Stability Pool, perform a partial liquidation: offset as much as possible,\n        * and do not redistribute the remainder. The trove remains active, with a reduced collateral and debt.\n        *\n        * ETH gas compensation is based on and drawn from the collateral fraction that corresponds to the partial offset. \n        * LUSD gas compensation is left untouched. \n        *\n        * Since ETH gas comp is drawn purely from the *liquidated* portion, the trove is left with the same ICR as before the \n        * liquidation.\n        */\n        else if (_entireTroveDebt > _LUSDInStabPool) {\n            // Remaining debt in the trove is lower-bounded by the trove's gas compensation\n            V.partialNewDebt = LiquityMath._max(_entireTroveDebt.sub(_LUSDInStabPool), LUSD_GAS_COMPENSATION);\n          \n            V.debtToOffset = _entireTroveDebt.sub(V.partialNewDebt);\n\n            uint collFraction = _entireTroveColl.mul(V.debtToOffset).div(_entireTroveDebt);\n            V.collGasCompensation = _getCollGasCompensation(collFraction);\n          \n            V.LUSDGasCompensation = 0;  // LUSD gas compensation remains untouched\n\n            V.collToSendToSP = collFraction.sub(V.collGasCompensation);\n            V.collToRedistribute = 0;\n            V.debtToRedistribute = 0;\n\n            V.partialAddr = _borrower;\n            V.partialNewColl = _entireTroveColl.sub(collFraction);\n\n            // Get the partial trove's neighbours, so we can re-insert it later to the same position\n            V.partialUpperHint = sortedTroves.getPrev(_borrower);  \n            V.partialLowerHint = sortedTroves.getNext(_borrower);\n        }\n    }\n\n    /* \n    * Liquidate a sequence of troves. Closes a maximum number of n under-collateralized Troves,\n    * starting from the one with the lowest collateral ratio in the system, and moving upwards\n    */\n    function liquidateTroves(uint _n) external override {\n        LocalVariables_OuterLiquidationFunction memory L;\n\n        LiquidationTotals memory T;\n\n        L.price = priceFeed.getPrice();\n        L.LUSDInStabPool = stabilityPool.getTotalLUSDDeposits();\n        L.recoveryModeAtStart = checkRecoveryMode();\n\n        // Perform the appropriate liquidation sequence - tally the values, and obtain their totals\n        if (L.recoveryModeAtStart == true) {\n            T = _getTotalsFromLiquidateTrovesSequence_RecoveryMode(L.price, L.LUSDInStabPool, _n);\n        } else if (L.recoveryModeAtStart == false) {\n            T = _getTotalsFromLiquidateTrovesSequence_NormalMode(L.price, L.LUSDInStabPool, _n);\n        }\n\n        // Move liquidated ETH and LUSD to the appropriate pools\n        stabilityPool.offset(T.totalDebtToOffset, T.totalCollToSendToSP);\n        _redistributeDebtAndColl(T.totalDebtToRedistribute, T.totalCollToRedistribute);\n\n        // Update system snapshots and the final partially liquidated trove, if there is one\n        _updateSystemSnapshots_excludeCollRemainder(T.partialNewColl.add(T.totalCollGasCompensation));\n        _updatePartiallyLiquidatedTrove(T.partialAddr, T.partialNewDebt, T.partialNewColl, T.partialUpperHint, T. partialLowerHint, L.price);\n\n        L.liquidatedDebt = T.totalDebtInSequence.sub(T.partialNewDebt);\n        L.liquidatedColl = T.totalCollInSequence.sub(T.totalCollGasCompensation).sub(T.partialNewColl);\n        emit Liquidation(L.liquidatedDebt, L.liquidatedColl, T.totalCollGasCompensation, T.totalLUSDGasCompensation);\n\n        // Send gas compensation to caller\n        _sendGasCompensation(msg.sender, T.totalLUSDGasCompensation, T.totalCollGasCompensation);\n    }\n\n    /*\n    * This function is used when the liquidateTroves sequence starts during Recovery Mode. However, it\n    * handle the case where the system *leaves* Recovery Mode, part way through the liquidation sequence\n    */\n    function _getTotalsFromLiquidateTrovesSequence_RecoveryMode\n    (\n        uint _price,\n        uint _LUSDInStabPool,\n        uint _n\n    )\n        internal\n        returns(LiquidationTotals memory T)\n    {\n        LocalVariables_LiquidationSequence memory L;\n        LiquidationValues memory V;\n\n        L.remainingLUSDInStabPool = _LUSDInStabPool;\n        L.backToNormalMode = false;\n        L.entireSystemDebt = activePool.getLUSDDebt().add(defaultPool.getLUSDDebt());\n        L.entireSystemColl = activePool.getETH().add(defaultPool.getETH());\n\n        L.i = 0;\n        while (L.i < _n) {\n            L.user = sortedTroves.getLast();\n            L.ICR = getCurrentICR(L.user, _price);\n\n            if (L.backToNormalMode == false) {\n                // Break the loop if ICR is greater than MCR and Stability Pool is empty\n                if (L.ICR >= MCR && L.remainingLUSDInStabPool == 0) { break; }\n\n                uint TCR = LiquityMath._computeCR(L.entireSystemColl, L.entireSystemDebt, _price);\n        \n                V = _liquidateRecoveryMode(L.user, L.ICR, L.remainingLUSDInStabPool, TCR);\n\n                // Update aggregate trackers\n                L.remainingLUSDInStabPool = L.remainingLUSDInStabPool.sub(V.debtToOffset);\n                L.entireSystemDebt = L.entireSystemDebt.sub(V.debtToOffset);\n                L.entireSystemColl = L.entireSystemColl.sub(V.collToSendToSP);\n\n                // Add liquidation values to their respective running totals\n                T = _addLiquidationValuesToTotals(T, V);\n\n                // Break the loop if it was a partial liquidation\n                if (V.partialAddr != address(0)) {break;}\n\n                L.backToNormalMode = !_checkPotentialRecoveryMode(L.entireSystemColl, L.entireSystemDebt, _price);\n            }\n            else if (L.backToNormalMode == true && L.ICR < MCR) {\n                V = _liquidateNormalMode(L.user, L.remainingLUSDInStabPool);\n\n                L.remainingLUSDInStabPool = L.remainingLUSDInStabPool.sub(V.debtToOffset);\n\n                // Add liquidation values to their respective running totals\n                T = _addLiquidationValuesToTotals(T, V);\n\n            }  else break;  // break if the loop reaches a Trove with ICR >= MCR\n\n            // Break the loop if it reaches the first Trove in the sorted list\n            if (L.user == sortedTroves.getFirst()) { break; }\n\n            L.i++;\n        }\n    }\n\n    function _getTotalsFromLiquidateTrovesSequence_NormalMode\n    (\n        uint _price,\n        uint _LUSDInStabPool,\n        uint _n\n    )\n        internal\n        returns(LiquidationTotals memory T)\n    {\n        LocalVariables_LiquidationSequence memory L;\n        LiquidationValues memory V;\n\n        L.remainingLUSDInStabPool = _LUSDInStabPool;\n\n        L.i = 0;\n        while (L.i < _n) {\n            L.user = sortedTroves.getLast();\n            L.ICR = getCurrentICR(L.user, _price);\n\n            if (L.ICR < MCR) {\n                V = _liquidateNormalMode(L.user, L.remainingLUSDInStabPool);\n\n                L.remainingLUSDInStabPool = L.remainingLUSDInStabPool.sub(V.debtToOffset);\n\n                // Add liquidation values to their respective running totals\n                T = _addLiquidationValuesToTotals(T, V);\n\n            } else break;  // break if the loop reaches a Trove with ICR >= MCR\n\n            // Break the loop if it reaches the first Trove in the sorted list\n            if (L.user == sortedTroves.getFirst()) { break; }\n            L.i++;\n        }\n    }\n\n    /* \n    * Attempt to liquidate a custom list of troves provided by the caller. The liquidation sequence stops if\n    * a partial liquidation is performed, so it's up to the caller to order the troves in the _troveArray parameter.\n    */\n    function batchLiquidateTroves(address[] memory _troveArray) public override {\n        require(_troveArray.length != 0, \"TroveManager: Calldata address array must not be empty\");\n\n        LocalVariables_OuterLiquidationFunction memory L;\n        LiquidationTotals memory T;\n\n        L.price = priceFeed.getPrice();\n        L.LUSDInStabPool = stabilityPool.getTotalLUSDDeposits();\n        L.recoveryModeAtStart = checkRecoveryMode();\n\n        // Perform the appropriate liquidation sequence - tally values and obtain their totals.\n        if (L.recoveryModeAtStart == true) {\n           T = _getTotalFromBatchLiquidate_RecoveryMode(L.price, L.LUSDInStabPool, _troveArray);\n        } else if (L.recoveryModeAtStart == false) {\n            T = _getTotalsFromBatchLiquidate_NormalMode(L.price, L.LUSDInStabPool, _troveArray);\n        }\n\n        // Move liquidated ETH and LUSD to the appropriate pools\n        stabilityPool.offset(T.totalDebtToOffset, T.totalCollToSendToSP);\n        _redistributeDebtAndColl(T.totalDebtToRedistribute, T.totalCollToRedistribute);\n\n        // Update system snapshots and the final partially liquidated trove, if there is one\n        _updateSystemSnapshots_excludeCollRemainder(T.partialNewColl.add(T.totalCollGasCompensation));\n        _updatePartiallyLiquidatedTrove(T.partialAddr, T.partialNewDebt, T.partialNewColl, T.partialUpperHint, T. partialLowerHint, L.price);\n\n        L.liquidatedDebt = T.totalDebtInSequence.sub(T.partialNewDebt);\n        L.liquidatedColl = T.totalCollInSequence.sub(T.totalCollGasCompensation).sub(T.partialNewColl);\n        emit Liquidation(L.liquidatedDebt, L.liquidatedColl, T.totalCollGasCompensation, T.totalLUSDGasCompensation);\n\n        // Send gas compensation to caller\n        _sendGasCompensation(msg.sender, T.totalLUSDGasCompensation, T.totalCollGasCompensation);\n    }\n\n    /* \n    * This function is used when the batch liquidation sequence starts during Recovery Mode. However, it\n    * handle the case where the system *leaves* Recovery Mode, part way through the liquidation sequence\n    */\n    function _getTotalFromBatchLiquidate_RecoveryMode\n    (\n        uint _price,\n        uint _LUSDInStabPool,\n        address[] memory _troveArray)\n        internal\n        returns(LiquidationTotals memory T)\n    {\n        LocalVariables_LiquidationSequence memory L;\n        LiquidationValues memory V;\n\n        L.remainingLUSDInStabPool = _LUSDInStabPool;\n        L.backToNormalMode = false;\n        L.entireSystemDebt = activePool.getLUSDDebt().add(defaultPool.getLUSDDebt());\n        L.entireSystemColl = activePool.getETH().add(defaultPool.getETH());\n\n        L.i = 0;\n        for (L.i = 0; L.i < _troveArray.length; L.i++) {\n            L.user = _troveArray[L.i];\n            L.ICR = getCurrentICR(L.user, _price);\n\n            if (L.backToNormalMode == false) {\n\n                // Skip this trove if ICR is greater than MCR and Stability Pool is empty\n                if (L.ICR >= MCR && L.remainingLUSDInStabPool == 0) { continue; }\n\n                uint TCR = LiquityMath._computeCR(L.entireSystemColl, L.entireSystemDebt, _price);\n\n                V = _liquidateRecoveryMode(L.user, L.ICR, L.remainingLUSDInStabPool, TCR);\n\n                // Update aggregate trackers\n                L.remainingLUSDInStabPool = L.remainingLUSDInStabPool.sub(V.debtToOffset);\n                L.entireSystemDebt = L.entireSystemDebt.sub(V.debtToOffset);\n                L.entireSystemColl = L.entireSystemColl.sub(V.collToSendToSP);\n\n                // Add liquidation values to their respective running totals\n                T = _addLiquidationValuesToTotals(T, V);\n\n                // Break the loop if it was a partial liquidation\n                if (V.partialAddr != address(0)) { break; }\n\n                L.backToNormalMode = !_checkPotentialRecoveryMode(L.entireSystemColl, L.entireSystemDebt, _price);\n            }\n\n            else if (L.backToNormalMode == true && L.ICR < MCR) {\n                V = _liquidateNormalMode(L.user, L.remainingLUSDInStabPool);\n                L.remainingLUSDInStabPool = L.remainingLUSDInStabPool.sub(V.debtToOffset);\n\n                // Add liquidation values to their respective running totals\n                T = _addLiquidationValuesToTotals(T, V);\n            }\n        }\n    }\n\n    function _getTotalsFromBatchLiquidate_NormalMode\n    (\n        uint _price,\n        uint _LUSDInStabPool,\n        address[] memory _troveArray\n    )\n        internal\n        returns(LiquidationTotals memory T)\n    {\n        LocalVariables_LiquidationSequence memory L;\n        LiquidationValues memory V;\n\n        L.remainingLUSDInStabPool = _LUSDInStabPool;\n\n        for (L.i = 0; L.i < _troveArray.length; L.i++) {\n            L.user = _troveArray[L.i];\n            L.ICR = getCurrentICR(L.user, _price);\n\n            if (L.ICR < MCR) {\n                V = _liquidateNormalMode(L.user, L.remainingLUSDInStabPool);\n                L.remainingLUSDInStabPool = L.remainingLUSDInStabPool.sub(V.debtToOffset);\n\n                // Add liquidation values to their respective running totals\n                T = _addLiquidationValuesToTotals(T, V);\n            }\n        }\n    }\n\n    // --- Liquidation helper functions ---\n\n    function _addLiquidationValuesToTotals(LiquidationTotals memory T1, LiquidationValues memory V)\n    internal pure returns(LiquidationTotals memory T2) {\n\n        // Tally all the values with their respective running totals\n        T2.totalCollGasCompensation = T1.totalCollGasCompensation.add(V.collGasCompensation);\n        T2.totalLUSDGasCompensation = T1.totalLUSDGasCompensation.add(V.LUSDGasCompensation);\n        T2.totalDebtInSequence = T1.totalDebtInSequence.add(V.entireTroveDebt);\n        T2.totalCollInSequence = T1.totalCollInSequence.add(V.entireTroveColl);\n        T2.totalDebtToOffset = T1.totalDebtToOffset.add(V.debtToOffset);\n        T2.totalCollToSendToSP = T1.totalCollToSendToSP.add(V.collToSendToSP);\n        T2.totalDebtToRedistribute = T1.totalDebtToRedistribute.add(V.debtToRedistribute);\n        T2.totalCollToRedistribute = T1.totalCollToRedistribute.add(V.collToRedistribute);\n\n        // Assign the address of the partially liquidated trove, and its new debt and coll values\n        T2.partialAddr = V.partialAddr;\n        T2.partialNewDebt = V.partialNewDebt;\n        T2.partialNewColl = V.partialNewColl;\n        T2.partialUpperHint = V.partialUpperHint;\n        T2.partialLowerHint = V.partialLowerHint;\n\n        return T2;\n    }\n\n    // Update the properties of the partially liquidated trove, and insert it back to the list\n    function _updatePartiallyLiquidatedTrove\n    (\n        address _borrower, \n        uint _newDebt, \n        uint _newColl, \n        address _upperHint,\n        address _lowerHint,\n        uint _price\n    ) \n        internal \n    {\n        if ( _borrower == address(0)) { return; }\n\n        Troves[_borrower].debt = _newDebt;\n        Troves[_borrower].coll = _newColl;\n        Troves[_borrower].status = Status.active;\n\n        _updateTroveRewardSnapshots(_borrower);\n        _updateStakeAndTotalStakes(_borrower);\n\n        uint ICR = getCurrentICR(_borrower, _price);\n\n        /* \n        * Insert to sorted list and add to TroveOwners array. The partially liquidated trove has the same\n        * ICR as it did before the liquidation, so insertion is O(1): in principle, its ICR does not change.\n        * In practice, due to rounding error, its ICR can change slightly - so re-insert, with its previous neighbours\n        * as hints.\n        */\n        sortedTroves.insert(_borrower, ICR, _price, _upperHint, _lowerHint);\n        _addTroveOwnerToArray(_borrower);\n        emit TroveUpdated(_borrower, _newDebt, _newColl, Troves[_borrower].stake, TroveManagerOperation.partiallyLiquidateInRecoveryMode);\n    }\n\n    function _sendGasCompensation(address _liquidator, uint _LUSD, uint _ETH) internal {\n        if (_LUSD > 0) {\n            lusdToken.returnFromPool(GAS_POOL_ADDRESS, _liquidator, _LUSD);\n        }\n\n        if (_ETH > 0) {\n            activePool.sendETH(_liquidator, _ETH);\n        }\n    }\n\n    // Move a Trove's pending debt and collateral rewards from distributions, from the Default Pool to the Active Pool\n    function _movePendingTroveRewardsToActivePool(uint _LUSD, uint _ETH) internal {\n        defaultPool.decreaseLUSDDebt(_LUSD);\n        activePool.increaseLUSDDebt(_LUSD);\n        defaultPool.sendETH(address(activePool), _ETH);\n    }\n\n    // --- Redemption functions ---\n\n    // Redeem as much collateral as possible from _borrower's Trove in exchange for LUSD up to _maxLUSDamount\n    function _redeemCollateralFromTrove(\n        address _borrower,\n        uint _maxLUSDamount,\n        uint _price,\n        address _partialRedemptionHint,\n        uint _partialRedemptionHintICR\n    )\n        internal returns (SingleRedemptionValues memory V)\n    {\n        // Determine the remaining amount (lot) to be redeemed, capped by the entire debt of the Trove minus the gas compensation\n        V.LUSDLot = LiquityMath._min(_maxLUSDamount, Troves[_borrower].debt.sub(LUSD_GAS_COMPENSATION));\n\n        // Get the ETHLot of equivalent value in USD\n        V.ETHLot = V.LUSDLot.mul(1e18).div(_price);\n\n        // Decrease the debt and collateral of the current Trove according to the LUSD lot and corresponding ETH to send\n        uint newDebt = (Troves[_borrower].debt).sub(V.LUSDLot);\n        uint newColl = (Troves[_borrower].coll).sub(V.ETHLot);\n\n        if (newDebt == LUSD_GAS_COMPENSATION) {\n            // No debt left in the Trove (except for the gas compensation), therefore the trove gets closed\n            _removeStake(_borrower);\n            _closeTrove(_borrower);\n            _redeemCloseTrove(_borrower, LUSD_GAS_COMPENSATION, newColl);\n\n        } else {\n            uint newICR = LiquityMath._computeCR(newColl, newDebt, _price);\n\n            // Check if the provided hint is fresh. If not, we bail since trying to reinsert without a good hint will almost\n            // certainly result in running out of gas.\n            if (newICR != _partialRedemptionHintICR) {\n                V.LUSDLot = 0;\n                V.ETHLot = 0;\n                return V;\n            }\n\n            sortedTroves.reInsert(_borrower, newICR, _price, _partialRedemptionHint, _partialRedemptionHint);\n\n            Troves[_borrower].debt = newDebt;\n            Troves[_borrower].coll = newColl;\n            _updateStakeAndTotalStakes(_borrower);\n        }\n        emit TroveUpdated(\n            _borrower,\n            newDebt, newColl,\n            Troves[_borrower].stake,\n            TroveManagerOperation.redeemCollateral\n        );\n        return V;\n    }\n\n    /* \n    * Called when a full redemption occurs, and closes the trove.\n    * The redeemer swaps (debt - 10) LUSD for (debt - 10) worth of ETH, so the 10 LUSD gas compensation left corresponds to the remaining debt.\n    * In order to close the trove, the 10 LUSD gas compensation is burned, and 10 debt is removed from the active pool.\n    * The debt recorded on the trove's struct is zero'd elswhere, in _closeTrove.\n    * Any surplus ETH left in the trove, is sent to the Coll surplus pool, and can be later claimed by the borrower.\n    */ \n    function _redeemCloseTrove(address _borrower, uint _LUSD, uint _ETH) internal {\n        lusdToken.burn(GAS_POOL_ADDRESS, _LUSD);\n        // Update Active Pool LUSD, and send ETH to account\n        activePool.decreaseLUSDDebt(_LUSD);\n\n        // send ETH from Active Pool to CollSurplus Pool\n        collSurplusPool.accountSurplus(_borrower, _ETH);\n        activePool.sendETH(address(collSurplusPool), _ETH);\n    }\n\n    function _isValidFirstRedemptionHint(address _firstRedemptionHint, uint _price) internal view returns (bool) {\n        if (_firstRedemptionHint == address(0) ||\n            !sortedTroves.contains(_firstRedemptionHint) ||\n            getCurrentICR(_firstRedemptionHint, _price) < MCR\n        ) {\n            return false;\n        }\n\n        address nextTrove = sortedTroves.getNext(_firstRedemptionHint);\n        return nextTrove == address(0) || getCurrentICR(nextTrove, _price) < MCR;\n    }\n\n    /* Send _LUSDamount LUSD to the system and redeem the corresponding amount of collateral from as many Troves as are needed to fill the redemption\n    * request.  Applies pending rewards to a Trove before reducing its debt and coll.\n    *\n    * Note that if _amount is very large, this function can run out of gas, specially if traversed troves are small. This can be easily avoided by \n    * splitting the total _amount in appropriate chunks and calling the function multiple times.\n    * \n    * Param `_maxIterations` can also be provided, so the loop through Troves is capped (if its zero, it will be ignored).This makes it easier to \n    * avoid OOG for the frontend, as only knowing approximately the average cost of an iteration is enough, without needing to know the topology \n    * of the trove list. It also avoids the need to set the cap in stone in the contract, nor doing gas calculations, as both gas price and opcode \n    * costs can vary.\n    * \n    * All Troves that are redeemed from -- with the likely exception of the last one -- will end up with no debt left, therefore they will be closed.\n    * If the last Trove does have some remaining debt, it has a finite ICR, and the reinsertion could be anywhere in the list, therefore it requires a hint. \n    * A frontend should use getRedemptionHints() to calculate what the ICR of this Trove will be after redemption, and pass a hint for its position \n    * in the sortedTroves list along with the ICR value that the hint was found for.\n    * \n    * If another transaction modifies the list between calling getRedemptionHints() and passing the hints to redeemCollateral(), it\n    * is very likely that the last (partially) redeemed Trove would end up with a different ICR than what the hint is for. In this case the\n    * redemption will stop after the last completely redeemed Trove and the sender will keep the remaining LUSD amount, which they can attempt\n    * to redeem later.\n    */\n    function redeemCollateral(\n        uint _LUSDamount,\n        address _firstRedemptionHint,\n        address _partialRedemptionHint,\n        uint _partialRedemptionHintICR,\n        uint _maxIterations\n    )\n        external\n        override\n    {\n        uint activeDebt = activePool.getLUSDDebt();\n        uint defaultedDebt = defaultPool.getLUSDDebt();\n\n        RedemptionTotals memory T;\n\n        _requireAmountGreaterThanZero(_LUSDamount);\n        _requireLUSDBalanceCoversRedemption(msg.sender, _LUSDamount);\n\n        // Confirm redeemer's balance is less than total systemic debt\n        assert(lusdToken.balanceOf(msg.sender) <= (activeDebt.add(defaultedDebt)));\n\n        uint remainingLUSD = _LUSDamount;\n        uint price = priceFeed.getPrice();\n        address currentBorrower;\n\n        if (_isValidFirstRedemptionHint(_firstRedemptionHint, price)) {\n            currentBorrower = _firstRedemptionHint;\n        } else {\n            currentBorrower = sortedTroves.getLast();\n            // Find the first trove with ICR >= MCR\n            // SWC-104-Unchecked Call Return Value: L920\n            while (currentBorrower != address(0) && getCurrentICR(currentBorrower, price) < MCR) {\n                currentBorrower = sortedTroves.getPrev(currentBorrower);\n            }\n        }\n\n        // Loop through the Troves starting from the one with lowest collateral ratio until _amount of LUSD is exchanged for collateral\n        if (_maxIterations == 0) { _maxIterations = uint(-1); }\n        while (currentBorrower != address(0) && remainingLUSD > 0 && _maxIterations > 0) {\n            _maxIterations--;\n            // Save the address of the Trove preceding the current one, before potentially modifying the list\n            address nextUserToCheck = sortedTroves.getPrev(currentBorrower);\n\n            _applyPendingRewards(currentBorrower);\n            SingleRedemptionValues memory V = _redeemCollateralFromTrove(\n                currentBorrower,\n                remainingLUSD,\n                price,\n                _partialRedemptionHint,\n                _partialRedemptionHintICR\n            );\n\n            if (V.LUSDLot == 0) break; // Partial redemption hint got out-of-date, therefore we could not redeem from the last Trove\n\n            T.totalLUSDToRedeem  = T.totalLUSDToRedeem.add(V.LUSDLot);\n            T.totalETHDrawn = T.totalETHDrawn.add(V.ETHLot);\n\n            remainingLUSD = remainingLUSD.sub(V.LUSDLot);\n            currentBorrower = nextUserToCheck;\n        }\n\n        // Decay the baseRate due to time passed, and then increase it according to the size of this redemption\n        _updateBaseRateFromRedemption(T.totalETHDrawn, price);\n\n        // Calculate the ETH fee and send it to the LQTY staking contract\n        T.ETHFee = _getRedemptionFee(T.totalETHDrawn);\n        activePool.sendETH(lqtyStakingAddress, T.ETHFee);\n        lqtyStaking.increaseF_ETH(T.ETHFee);\n\n        T.ETHToSendToRedeemer = T.totalETHDrawn.sub(T.ETHFee);\n\n        // Burn the total LUSD that is cancelled with debt, and send the redeemed ETH to msg.sender\n        _activePoolRedeemCollateral(msg.sender, T.totalLUSDToRedeem, T.ETHToSendToRedeemer);\n\n        emit Redemption(_LUSDamount, T.totalLUSDToRedeem, T.totalETHDrawn, T.ETHFee);\n    }\n\n    // Burn the received LUSD, transfer the redeemed ETH to _redeemer and updates the Active Pool\n    function _activePoolRedeemCollateral(address _redeemer, uint _LUSD, uint _ETH) internal {\n        // Update Active Pool LUSD, and send ETH to account\n        lusdToken.burn(_redeemer, _LUSD);\n        activePool.decreaseLUSDDebt(_LUSD);\n\n        activePool.sendETH(_redeemer, _ETH);\n    }\n\n    // --- Helper functions ---\n\n\n    // Return the current collateral ratio (ICR) of a given Trove. Takes a trove's pending coll and debt rewards from redistributions into account.\n    function getCurrentICR(address _borrower, uint _price) public view override returns (uint) {\n        uint pendingETHReward = getPendingETHReward(_borrower);\n        uint pendingLUSDDebtReward = getPendingLUSDDebtReward(_borrower);\n\n        uint currentETH = Troves[_borrower].coll.add(pendingETHReward);\n        uint currentLUSDDebt = Troves[_borrower].debt.add(pendingLUSDDebtReward);\n\n        uint ICR = LiquityMath._computeCR(currentETH, currentLUSDDebt, _price);\n        return ICR;\n    }\n\n    function applyPendingRewards(address _borrower) external override {\n        _requireCallerIsBorrowerOperations();\n        return _applyPendingRewards(_borrower);\n    }\n\n    // Add the borrowers's coll and debt rewards earned from redistributions, to their Trove\n    function _applyPendingRewards(address _borrower) internal {\n        if (hasPendingRewards(_borrower)) {\n            _requireTroveisActive(_borrower);\n\n            // Compute pending rewards\n            uint pendingETHReward = getPendingETHReward(_borrower);\n            uint pendingLUSDDebtReward = getPendingLUSDDebtReward(_borrower);\n\n            // Apply pending rewards to trove's state\n            Troves[_borrower].coll = Troves[_borrower].coll.add(pendingETHReward);\n            Troves[_borrower].debt = Troves[_borrower].debt.add(pendingLUSDDebtReward);\n\n            _updateTroveRewardSnapshots(_borrower);\n\n            // Transfer from DefaultPool to ActivePool\n            _movePendingTroveRewardsToActivePool(pendingLUSDDebtReward, pendingETHReward);\n\n            emit TroveUpdated(\n                _borrower, \n                Troves[_borrower].debt, \n                Troves[_borrower].coll, \n                Troves[_borrower].stake, \n                TroveManagerOperation.applyPendingRewards\n            );\n        }\n    }\n\n    // Update borrower's snapshots of L_ETH and L_LUSDDebt to reflect the current values\n    function updateTroveRewardSnapshots(address _borrower) external override {\n        _requireCallerIsBorrowerOperations();\n       return _updateTroveRewardSnapshots(_borrower);\n    }\n\n    function _updateTroveRewardSnapshots(address _borrower) internal {\n        rewardSnapshots[_borrower].ETH = L_ETH;\n        rewardSnapshots[_borrower].LUSDDebt = L_LUSDDebt;\n    }\n\n    // Get the borrower's pending accumulated ETH reward, earned by their stake\n    function getPendingETHReward(address _borrower) public view override returns (uint) {\n        uint snapshotETH = rewardSnapshots[_borrower].ETH;\n        uint rewardPerUnitStaked = L_ETH.sub(snapshotETH);\n\n        if ( rewardPerUnitStaked == 0 ) { return 0; }\n\n        uint stake = Troves[_borrower].stake;\n\n        uint pendingETHReward = stake.mul(rewardPerUnitStaked).div(1e18);\n\n        return pendingETHReward;\n    }\n\n     // Get the borrower's pending accumulated LUSD reward, earned by their stake\n    function getPendingLUSDDebtReward(address _borrower) public view override returns (uint) {\n        uint snapshotLUSDDebt = rewardSnapshots[_borrower].LUSDDebt;\n        uint rewardPerUnitStaked = L_LUSDDebt.sub(snapshotLUSDDebt);\n\n        if ( rewardPerUnitStaked == 0 ) { return 0; }\n\n        uint stake =  Troves[_borrower].stake;\n\n        uint pendingLUSDDebtReward = stake.mul(rewardPerUnitStaked).div(1e18);\n\n        return pendingLUSDDebtReward;\n    }\n\n    function hasPendingRewards(address _borrower) public view override returns (bool) {\n        /* \n        * A Trove has pending rewards if its snapshot is less than the current rewards per-unit-staked sum:\n        * this indicates that rewards have occured since the snapshot was made, and the user therefore has\n        * pending rewards \n        */\n        return (rewardSnapshots[_borrower].ETH < L_ETH);\n    }\n\n    // Return the Troves entire debt and coll, including pending rewards from redistributions.\n    function getEntireDebtAndColl(\n        address _borrower\n    )\n        public\n        view\n        override\n        returns (uint debt, uint coll, uint pendingLUSDDebtReward, uint pendingETHReward)\n    {\n        debt = Troves[_borrower].debt;\n        coll = Troves[_borrower].coll;\n\n        pendingLUSDDebtReward = getPendingLUSDDebtReward(_borrower);\n        pendingETHReward = getPendingETHReward(_borrower);\n\n        debt = debt.add(pendingLUSDDebtReward);\n        coll = coll.add(pendingETHReward);\n    }\n\n    function removeStake(address _borrower) external override {\n        _requireCallerIsBorrowerOperations();\n        return _removeStake(_borrower);\n    }\n\n    // Remove borrower's stake from the totalStakes sum, and set their stake to 0\n    function _removeStake(address _borrower) internal {\n        uint stake = Troves[_borrower].stake;\n        totalStakes = totalStakes.sub(stake);\n        Troves[_borrower].stake = 0;\n    }\n\n    function updateStakeAndTotalStakes(address _borrower) external override returns (uint) {\n        _requireCallerIsBorrowerOperations();\n        return _updateStakeAndTotalStakes(_borrower);\n    }\n\n    // Update borrower's stake based on their latest collateral value\n    function _updateStakeAndTotalStakes(address _borrower) internal returns (uint) {\n        uint newStake = _computeNewStake(Troves[_borrower].coll);\n        uint oldStake = Troves[_borrower].stake;\n        Troves[_borrower].stake = newStake;\n        totalStakes = totalStakes.sub(oldStake).add(newStake);\n\n        return newStake;\n    }\n\n    // Calculate a new stake based on the snapshots of the totalStakes and totalCollateral taken at the last liquidation\n    function _computeNewStake(uint _coll) internal view returns (uint) {\n        uint stake;\n        if (totalCollateralSnapshot == 0) {\n            stake = _coll;\n        } else {\n            /*  \n            * The following assert() holds true because:\n            * - The system always contains >= 1 trove \n            * - When we close or liquidate a trove, we redistribute the pending rewards, so if all troves were closed/liquidated, \n            * rewards wouldve been emptied and totalCollateralSnapshot would be zero too.\n            */\n            assert(totalStakesSnapshot > 0);\n            stake = _coll.mul(totalStakesSnapshot).div(totalCollateralSnapshot);\n        }\n        return stake;\n    }\n\n    function _redistributeDebtAndColl(uint _debt, uint _coll) internal {\n        if (_debt == 0) { return; }\n\n        if (totalStakes > 0) {\n            /* \n            * Add distributed coll and debt rewards-per-unit-staked to the running totals.\n            * Division uses a \"feedback\" error correction, to keep the cumulative error in\n            * the  L_ETH and L_LUSDDebt state variables low. \n            */\n            uint ETHNumerator = _coll.mul(1e18).add(lastETHError_Redistribution);\n            uint LUSDDebtNumerator = _debt.mul(1e18).add(lastLUSDDebtError_Redistribution);\n\n            uint ETHRewardPerUnitStaked = ETHNumerator.div(totalStakes);\n            uint LUSDDebtRewardPerUnitStaked = LUSDDebtNumerator.div(totalStakes);\n\n            lastETHError_Redistribution = ETHNumerator.sub(ETHRewardPerUnitStaked.mul(totalStakes));\n            lastLUSDDebtError_Redistribution = LUSDDebtNumerator.sub(LUSDDebtRewardPerUnitStaked.mul(totalStakes));\n\n            L_ETH = L_ETH.add(ETHRewardPerUnitStaked);\n            L_LUSDDebt = L_LUSDDebt.add(LUSDDebtRewardPerUnitStaked);\n        }\n\n        // Transfer coll and debt from ActivePool to DefaultPool\n        activePool.decreaseLUSDDebt(_debt);\n        defaultPool.increaseLUSDDebt(_debt);\n        activePool.sendETH(address(defaultPool), _coll);\n    }\n\n    function closeTrove(address _borrower) external override {\n        _requireCallerIsBorrowerOperations();\n        return _closeTrove(_borrower);\n    }\n\n    function _closeTrove(address _borrower) internal {\n        uint TroveOwnersArrayLength = TroveOwners.length;\n        _requireMoreThanOneTroveInSystem(TroveOwnersArrayLength);\n\n        Troves[_borrower].status = Status.closed;\n        Troves[_borrower].coll = 0;\n        Troves[_borrower].debt = 0;\n\n        rewardSnapshots[_borrower].ETH = 0;\n        rewardSnapshots[_borrower].LUSDDebt = 0;\n\n        _removeTroveOwner(_borrower, TroveOwnersArrayLength);\n        sortedTroves.remove(_borrower);\n    }\n\n    /* \n    * Updates snapshots of system total stakes and total collateral, excluding a given collateral remainder from the calculation. \n    * Used in a liquidation sequence.\n    *\n    * The calculation excludes two portions of collateral that are in the ActivePool: \n    *\n    * 1) the total ETH gas compensation from the liquidation sequence\n    * 2) The remaining collateral in a partially liquidated trove (if one occurred)\n    *\n    * The ETH as compensation must be excluded as it is always sent out at the very end of the liquidation sequence.\n    *\n    * The partially liquidated trove's remaining collateral stays in the ActivePool, but it is excluded here so the system \n    * can take snapshots before the partially liquidated trove's stake is updated (based on these snapshots). This ensures\n    * the partial's new stake doesn't double-count its own remaining collateral.\n    *\n    */\n    function _updateSystemSnapshots_excludeCollRemainder(uint _collRemainder) internal {\n        totalStakesSnapshot = totalStakes;\n\n        uint activeColl = activePool.getETH();\n        uint liquidatedColl = defaultPool.getETH();\n        totalCollateralSnapshot = activeColl.sub(_collRemainder).add(liquidatedColl);\n    }\n\n    // Push the owner's address to the Trove owners list, and record the corresponding array index on the Trove struct\n    function addTroveOwnerToArray(address _borrower) external override returns (uint index) {\n        _requireCallerIsBorrowerOperations();\n        return _addTroveOwnerToArray(_borrower);\n    }\n\n    function _addTroveOwnerToArray(address _borrower) internal returns (uint128 index) {\n        require(TroveOwners.length < 2**128 - 1, \"TroveManager: TroveOwners array has maximum size of 2^128 - 1\");\n\n        // Push the Troveowner to the array\n        TroveOwners.push(_borrower);\n\n        // Record the index of the new Troveowner on their Trove struct\n        index = uint128(TroveOwners.length.sub(1));\n        Troves[_borrower].arrayIndex = index;\n\n        return index;\n    }\n\n    /* \n    * Remove a Trove owner from the TroveOwners array, not preserving array order. Removing owner 'B' does the following:\n    * [A B C D E] => [A E C D], and updates E's Trove struct to point to its new array index. \n    */\n    function _removeTroveOwner(address _borrower, uint TroveOwnersArrayLength) internal {\n        require(Troves[_borrower].status == Status.closed, \"TroveManager: Trove is still active\");\n\n        uint128 index = Troves[_borrower].arrayIndex;\n        uint length = TroveOwnersArrayLength;\n        uint idxLast = length.sub(1);\n\n        assert(index <= idxLast);\n\n        address addressToMove = TroveOwners[idxLast];\n\n        TroveOwners[index] = addressToMove;\n        Troves[addressToMove].arrayIndex = index;\n        TroveOwners.pop();\n    }\n\n    // --- Recovery Mode and TCR functions ---\n\n    function checkRecoveryMode() public view override returns (bool) {\n        uint TCR = getTCR();\n\n        if (TCR < CCR) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    // Check whether or not the system *would be* in Recovery Mode, given an ETH:USD price, and the entire system coll and debt.\n    function _checkPotentialRecoveryMode(\n        uint _entireSystemColl,\n        uint _entireSystemDebt,\n        uint _price\n    )\n        internal\n        pure\n    returns (bool)\n    {\n        uint TCR = LiquityMath._computeCR(_entireSystemColl, _entireSystemDebt, _price);\n        if (TCR < CCR) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n    // SWC-135-Code With No Effects: L1276-L1284\n    function getTCR() public view override returns (uint TCR) {\n        uint price = priceFeed.getPrice();\n        uint entireSystemColl = getEntireSystemColl();\n        uint entireSystemDebt = getEntireSystemDebt();\n\n        TCR = LiquityMath._computeCR(entireSystemColl, entireSystemDebt, price);\n\n        return TCR;\n    }\n    // SWC-135-Code With No Effects: L1286-L1291\n    function getEntireSystemColl() public view override returns (uint entireSystemColl) {\n        uint activeColl = activePool.getETH();\n        uint liquidatedColl = defaultPool.getETH();\n\n        return activeColl.add(liquidatedColl);\n    }\n\n    function getEntireSystemDebt() public view override returns (uint entireSystemDebt) {\n        uint activeDebt = activePool.getLUSDDebt();\n        uint closedDebt = defaultPool.getLUSDDebt();\n\n        return activeDebt.add(closedDebt);\n    }\n\n    // --- Redemption fee functions ---\n\n    /* \n    * This function has two impacts on the baseRate state variable:\n    * 1) decays the baseRate based on time passed since last redemption or LUSD borrowing operation.\n    * then,\n    * 2) increases the baseRate based on the amount redeemed, as a proportion of total supply\n    */\n    function _updateBaseRateFromRedemption(uint _ETHDrawn,  uint _price) internal returns (uint) {\n        uint decayedBaseRate = _calcDecayedBaseRate();\n\n        uint activeDebt = activePool.getLUSDDebt();\n        uint closedDebt = defaultPool.getLUSDDebt();\n        uint totalLUSDSupply = activeDebt.add(closedDebt);\n\n        /* Convert the drawn ETH back to LUSD at face value rate (1 LUSD:1 USD), in order to get\n        * the fraction of total supply that was redeemed at face value. */\n        uint redeemedLUSDFraction = _ETHDrawn.mul(_price).div(totalLUSDSupply);\n\n        uint newBaseRate = decayedBaseRate.add(redeemedLUSDFraction.div(BETA));\n\n        // Update the baseRate state variable\n        baseRate = newBaseRate < 1e18 ? newBaseRate : 1e18;  // cap baseRate at a maximum of 100%\n        assert(baseRate <= 1e18 && baseRate > 0); // Base rate is always non-zero after redemption\n\n        _updateLastFeeOpTime();\n\n        return baseRate;\n    }\n\n    function _getRedemptionFee(uint _ETHDrawn) internal view returns (uint) {\n       return baseRate.mul(_ETHDrawn).div(1e18);\n    }\n\n    // --- Borrowing fee functions ---\n\n    function getBorrowingFee(uint _LUSDDebt) external view override returns (uint) {\n        return _LUSDDebt.mul(baseRate).div(1e18);\n    }\n\n    // Updates the baseRate state variable based on time elapsed since the last redemption or LUSD borrowing operation.\n    function decayBaseRateFromBorrowing() external override {\n        _requireCallerIsBorrowerOperations();\n\n        baseRate = _calcDecayedBaseRate();\n        assert(baseRate <= 1e18);  // The baseRate can decay to 0\n\n        _updateLastFeeOpTime();\n    }\n\n    // --- Internal fee functions ---\n\n    // Update the last fee operation time only if time passed >= decay interval. This prevents base rate griefing.\n    function _updateLastFeeOpTime() internal {\n        uint timePassed = block.timestamp.sub(lastFeeOperationTime);\n\n        if (timePassed >= SECONDS_IN_ONE_MINUTE) {\n            lastFeeOperationTime = block.timestamp;\n        }\n    }\n\n    function _calcDecayedBaseRate() internal view returns (uint) {\n        uint minutesPassed = _minutesPassedSinceLastFeeOp();\n        uint decayFactor = LiquityMath._decPow(MINUTE_DECAY_FACTOR, minutesPassed);\n\n        return baseRate.mul(decayFactor).div(1e18);\n    }\n\n    function _minutesPassedSinceLastFeeOp() internal view returns (uint) {\n        return (block.timestamp.sub(lastFeeOperationTime)).div(SECONDS_IN_ONE_MINUTE);\n    }\n\n    // --- 'require' wrapper functions ---\n\n    function _requireCallerIsBorrowerOperations() internal view {\n        require(msg.sender == borrowerOperationsAddress, \"TroveManager: Caller is not the BorrowerOperations contract\");\n    }\n\n    function _requireTroveisActive(address _borrower) internal view {\n        require(Troves[_borrower].status == Status.active, \"TroveManager: Trove does not exist or is closed\");\n    }\n\n    function _requireLUSDBalanceCoversRedemption(address _redeemer, uint _amount) internal view {\n        require(lusdToken.balanceOf(_redeemer) >= _amount, \"TroveManager: Requested redemption amount must be <= user's LUSD token balance\");\n    }\n\n    function _requireMoreThanOneTroveInSystem(uint TroveOwnersArrayLength) internal view {\n        require (TroveOwnersArrayLength > 1 && sortedTroves.getSize() > 1, \"TroveManager: Only one trove in the system\");\n    }\n\n    function _requireAmountGreaterThanZero(uint _amount) internal pure {\n        require(_amount > 0, \"TroveManager: Amount must be greater than zero\");\n    }\n\n    // --- Trove property getters ---\n\n    function getTroveStatus(address _borrower) external view override returns (uint) {\n        return uint(Troves[_borrower].status);\n    }\n\n    function getTroveStake(address _borrower) external view override returns (uint) {\n        return Troves[_borrower].stake;\n    }\n\n    function getTroveDebt(address _borrower) external view override returns (uint) {\n        return Troves[_borrower].debt;\n    }\n\n    function getTroveColl(address _borrower) external view override returns (uint) {\n        return Troves[_borrower].coll;\n    }\n\n    // --- Trove property setters, called by BorrowerOperations ---\n\n    function setTroveStatus(address _borrower, uint _num) external override {\n        _requireCallerIsBorrowerOperations();\n        Troves[_borrower].status = Status(_num);\n    }\n\n    function increaseTroveColl(address _borrower, uint _collIncrease) external override returns (uint) {\n        _requireCallerIsBorrowerOperations();\n        uint newColl = Troves[_borrower].coll.add(_collIncrease);\n        Troves[_borrower].coll = newColl;\n        return newColl;\n    }\n\n    function decreaseTroveColl(address _borrower, uint _collDecrease) external override returns (uint) {\n        _requireCallerIsBorrowerOperations();\n        uint newColl = Troves[_borrower].coll.sub(_collDecrease);\n        Troves[_borrower].coll = newColl;\n        return newColl;\n    }\n\n    function increaseTroveDebt(address _borrower, uint _debtIncrease) external override returns (uint) {\n        _requireCallerIsBorrowerOperations();\n        uint newDebt = Troves[_borrower].debt.add(_debtIncrease);\n        Troves[_borrower].debt = newDebt;\n        return newDebt;\n    }\n\n    function decreaseTroveDebt(address _borrower, uint _debtDecrease) external override returns (uint) {\n        _requireCallerIsBorrowerOperations();\n        uint newDebt = Troves[_borrower].debt.sub(_debtDecrease);\n        Troves[_borrower].debt = newDebt;\n        return newDebt;\n    }\n}",
        "function": "getTCR()",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-Liquity/dev-f0df3efa5a5f05b205752184cfce107c5bd6e06c/packages/contracts/contracts/TroveManager.sol",
        "vulnerability": "Multiple Calls in a Single Transaction (SWC 113)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract TroveManager is LiquityBase, Ownable, ITroveManager {\n\n    // --- Connected contract declarations ---\n\n    address public borrowerOperationsAddress;\n\n    IPool public activePool;\n\n    IPool public defaultPool;\n\n    IStabilityPool public stabilityPool;\n\n    ICollSurplusPool collSurplusPool;\n\n    ILUSDToken public lusdToken;\n\n    IPriceFeed public priceFeed;\n\n    ILQTYStaking public lqtyStaking;\n    address public lqtyStakingAddress;\n\n    // A doubly linked list of Troves, sorted by their sorted by their collateral ratios\n    ISortedTroves public sortedTroves;\n\n    // --- Data structures ---\n\n    uint constant public SECONDS_IN_ONE_MINUTE = 60;\n    uint constant public MINUTE_DECAY_FACTOR = 999832508430720967;  // 18 digit decimal. Corresponds to an hourly decay factor of 0.99\n\n    /* \n    * BETA: 18 digit decimal. Parameter by which to divide the redeemed fraction, in order to calc the new base rate from a redemption. \n    * Corresponds to (1 / ALPHA) in the white paper. \n    */\n    uint constant public BETA = 2;\n\n    uint public baseRate;\n\n    // The timestamp of the latest fee operation (redemption or new LUSD issuance) \n    uint public lastFeeOperationTime;\n\n    enum Status { nonExistent, active, closed }\n\n    // Store the necessary data for a trove\n    struct Trove {\n        uint debt;\n        uint coll;\n        uint stake;\n        Status status;\n        uint128 arrayIndex;\n    }\n\n    mapping (address => Trove) public Troves;\n\n    uint public totalStakes;\n\n    // Snapshot of the value of totalStakes, taken immediately after the latest liquidation\n    uint public totalStakesSnapshot;\n\n    // Snapshot of the total collateral across the ActivePool and DefaultPool, immediately after the latest liquidation.\n    uint public totalCollateralSnapshot;\n\n    /*\n    * L_ETH and L_LUSDDebt track the sums of accumulated liquidation rewards per unit staked. During its lifetime, each stake earns:\n    *\n    * An ETH gain of ( stake * [L_ETH - L_ETH(0)] )\n    * A LUSDDebt increase  of ( stake * [L_LUSDDebt - L_LUSDDebt(0)] )\n    *\n    * Where L_ETH(0) and L_LUSDDebt(0) are snapshots of L_ETH and L_LUSDDebt for the active Trove taken at the instant the stake was made\n    */\n    uint public L_ETH;\n    uint public L_LUSDDebt;\n\n    // Map addresses with active troves to their RewardSnapshot\n    mapping (address => RewardSnapshot) public rewardSnapshots;\n\n    // Object containing the ETH and LUSD snapshots for a given active trove\n    struct RewardSnapshot { uint ETH; uint LUSDDebt;}\n\n    // Array of all active trove addresses - used to to compute an approximate hint off-chain, for the sorted list insertion\n    address[] public TroveOwners;\n\n    // Error trackers for the trove redistribution calculation\n    uint public lastETHError_Redistribution;\n    uint public lastLUSDDebtError_Redistribution;\n\n    /* \n    * --- Variable container structs for liquidations ---\n    *\n    * These structs are used to hold, return and assign variables inside the liquidation functions,\n    * in order to avoid the error: \"CompilerError: Stack too deep\". \n    **/\n\n    struct LocalVariables_OuterLiquidationFunction {\n        uint price;\n        uint LUSDInStabPool;\n        bool recoveryModeAtStart;\n        uint liquidatedDebt;\n        uint liquidatedColl;\n    }\n\n    struct LocalVariables_InnerSingleLiquidateFunction {\n        uint collToLiquidate;\n        uint pendingDebtReward;\n        uint pendingCollReward;\n    }\n\n    struct LocalVariables_LiquidationSequence {\n        uint remainingLUSDInStabPool;\n        uint i;\n        uint ICR;\n        address user;\n        bool backToNormalMode;\n        uint entireSystemDebt;\n        uint entireSystemColl;\n    }\n\n    struct LiquidationValues {\n        uint entireTroveDebt;\n        uint entireTroveColl;\n        uint collGasCompensation;\n        uint LUSDGasCompensation;\n        uint debtToOffset;\n        uint collToSendToSP;\n        uint debtToRedistribute;\n        uint collToRedistribute;\n        address partialAddr;\n        uint partialNewDebt;\n        uint partialNewColl;\n        address partialUpperHint;\n        address partialLowerHint;\n    }\n\n    struct LiquidationTotals {\n        uint totalCollInSequence;\n        uint totalDebtInSequence;\n        uint totalCollGasCompensation;\n        uint totalLUSDGasCompensation;\n        uint totalDebtToOffset;\n        uint totalCollToSendToSP;\n        uint totalDebtToRedistribute;\n        uint totalCollToRedistribute;\n        address partialAddr;\n        uint partialNewDebt;\n        uint partialNewColl;\n        address partialUpperHint;\n        address partialLowerHint;\n    }\n\n    // --- Variable container structs for redemptions ---\n\n    struct RedemptionTotals {\n        uint totalLUSDToRedeem;\n        uint totalETHDrawn;\n        uint ETHFee;\n        uint ETHToSendToRedeemer;\n        uint decayedBaseRate;\n    }\n\n    struct SingleRedemptionValues {\n        uint LUSDLot;\n        uint ETHLot;\n    }\n\n    // --- Events ---\n\n    event Liquidation(uint _liquidatedDebt, uint _liquidatedColl, uint _collGasCompensation, uint _LUSDGasCompensation);\n    event Redemption(uint _attemptedLUSDAmount, uint _actualLUSDAmount, uint _ETHSent, uint _ETHFee);\n\n    enum TroveManagerOperation {\n        applyPendingRewards,\n        liquidateInNormalMode,\n        liquidateInRecoveryMode,\n        partiallyLiquidateInRecoveryMode,\n        redeemCollateral\n    }\n\n    event TroveCreated(address indexed _borrower, uint _arrayIndex);\n    event TroveUpdated(address indexed _borrower, uint _debt, uint _coll, uint _stake, TroveManagerOperation _operation);\n    event TroveLiquidated(address indexed _borrower, uint _debt, uint _coll, TroveManagerOperation _operation);\n\n    // --- Dependency setter ---\n\n    function setAddresses(\n        address _borrowerOperationsAddress,\n        address _activePoolAddress,\n        address _defaultPoolAddress,\n        address _stabilityPoolAddress,\n        address _collSurplusPoolAddress,\n        address _priceFeedAddress,\n        address _lusdTokenAddress,\n        address _sortedTrovesAddress,\n        address _lqtyStakingAddress\n    )\n        external\n        override\n        onlyOwner\n    {\n        borrowerOperationsAddress = _borrowerOperationsAddress;\n        activePool = IPool(_activePoolAddress);\n        defaultPool = IPool(_defaultPoolAddress);\n        stabilityPool = IStabilityPool(_stabilityPoolAddress);\n        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);\n        priceFeed = IPriceFeed(_priceFeedAddress);\n        lusdToken = ILUSDToken(_lusdTokenAddress);\n        sortedTroves = ISortedTroves(_sortedTrovesAddress);\n        lqtyStakingAddress = _lqtyStakingAddress;\n        lqtyStaking = ILQTYStaking(_lqtyStakingAddress);\n\n        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);\n        emit ActivePoolAddressChanged(_activePoolAddress);\n        emit DefaultPoolAddressChanged(_defaultPoolAddress);\n        emit StabilityPoolAddressChanged(_stabilityPoolAddress);\n        emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);\n        emit PriceFeedAddressChanged(_priceFeedAddress);\n        emit LUSDTokenAddressChanged(_lusdTokenAddress);\n        emit SortedTrovesAddressChanged(_sortedTrovesAddress);\n        emit LQTYStakingAddressChanged(_lqtyStakingAddress);\n\n        _renounceOwnership();\n    }\n\n    // --- Getters ---\n\n    function getTroveOwnersCount() external view override returns (uint) {\n        return TroveOwners.length;\n    }\n\n    function getTroveFromTroveOwnersArray(uint _index) external view override returns (address) {\n        return TroveOwners[_index];\n    }\n\n    // --- Trove Liquidation functions ---\n\n    // Single liquidation function. Closes the trove if its ICR is lower than the minimum collateral ratio. \n    function liquidate(address _borrower) external override {\n        _requireTroveisActive(_borrower);\n\n        address[] memory borrowers = new address[](1);\n        borrowers[0] = _borrower;\n        batchLiquidateTroves(borrowers);\n    }\n\n    // --- Inner single liquidation functions ---\n\n    // Liquidate one trove, in Normal Mode.\n    function _liquidateNormalMode(address _borrower, uint _LUSDInStabPool) internal returns (LiquidationValues memory V) {\n        LocalVariables_InnerSingleLiquidateFunction memory L;\n\n        (V.entireTroveDebt,\n        V.entireTroveColl,\n        L.pendingDebtReward,\n        L.pendingCollReward) = getEntireDebtAndColl(_borrower);\n\n        _movePendingTroveRewardsToActivePool(L.pendingDebtReward, L.pendingCollReward);\n        _removeStake(_borrower);\n\n        V.collGasCompensation = _getCollGasCompensation(V.entireTroveColl);\n        V.LUSDGasCompensation = LUSD_GAS_COMPENSATION;\n        uint collToLiquidate = V.entireTroveColl.sub(V.collGasCompensation);\n\n        (V.debtToOffset,\n        V.collToSendToSP,\n        V.debtToRedistribute,\n        V.collToRedistribute) = _getOffsetAndRedistributionVals(V.entireTroveDebt, collToLiquidate, _LUSDInStabPool);\n\n        _closeTrove(_borrower);\n        emit TroveLiquidated(_borrower, V.entireTroveDebt, V.entireTroveColl, TroveManagerOperation.liquidateInNormalMode);\n\n        return V;\n    }\n\n    // Liquidate one trove, in Recovery Mode.\n    function _liquidateRecoveryMode(address _borrower, uint _ICR, uint _LUSDInStabPool, uint _TCR) internal returns (LiquidationValues memory V) {\n        LocalVariables_InnerSingleLiquidateFunction memory L;\n        \n        if (TroveOwners.length <= 1) { return V; } // don't liquidate if last trove\n\n        (V.entireTroveDebt,\n        V.entireTroveColl,\n        L.pendingDebtReward,\n        L.pendingCollReward) = getEntireDebtAndColl(_borrower);\n\n        _movePendingTroveRewardsToActivePool(L.pendingDebtReward, L.pendingCollReward);\n\n        V.collGasCompensation = _getCollGasCompensation(V.entireTroveColl);\n        // In case of a partial liquidation, V.LUSDGasCompensation will be overwritten to zero, in the third branch below\n        V.LUSDGasCompensation = LUSD_GAS_COMPENSATION;\n        L.collToLiquidate = V.entireTroveColl.sub(V.collGasCompensation);\n\n        // If ICR <= 100%, purely redistribute the Trove across all active Troves\n        if (_ICR <= _100pct) {\n            _removeStake(_borrower);\n\n            V.debtToOffset = 0;\n            V.collToSendToSP = 0;\n            V.debtToRedistribute = V.entireTroveDebt;\n            V.collToRedistribute = L.collToLiquidate;\n\n            _closeTrove(_borrower);\n            emit TroveLiquidated(_borrower, V.entireTroveDebt, V.entireTroveColl, TroveManagerOperation.liquidateInRecoveryMode);\n\n        // If 100% < ICR < MCR, offset as much as possible, and redistribute the remainder\n        } else if ((_ICR > _100pct) && (_ICR < MCR)) {\n            _removeStake(_borrower);\n\n            (V.debtToOffset,\n            V.collToSendToSP,\n            V.debtToRedistribute,\n            V.collToRedistribute) = _getOffsetAndRedistributionVals(V.entireTroveDebt, L.collToLiquidate, _LUSDInStabPool);\n\n            _closeTrove(_borrower);\n            emit TroveLiquidated(_borrower, V.entireTroveDebt, V.entireTroveColl, TroveManagerOperation.liquidateInRecoveryMode);\n\n        /* \n        * If 110% <= ICR < current TCR (accounting for the preceding liquidations in the current sequence)\n        * and there is LUSD in the Stability Pool, only offset it as much as possible, with no redistribution.\n        */\n        } else if ((_ICR >= MCR) && (_ICR < _TCR)) {\n            assert(_LUSDInStabPool != 0);\n\n            _removeStake(_borrower);\n            \n            V = _getFullOrPartialOffsetVals(_borrower, V.entireTroveDebt, V.entireTroveColl, _LUSDInStabPool);\n\n            _closeTrove(_borrower);\n        }\n        else if (_ICR >= _TCR) {\n            LiquidationValues memory zeroVals;\n            return zeroVals;\n        }\n\n        return V;\n    }\n\n    /* In a full liquidation, returns the values for a trove's coll and debt to be offset, and coll and debt to be \n    * redistributed to active troves. \n    */\n    function _getOffsetAndRedistributionVals\n    (\n        uint _debt,\n        uint _coll,\n        uint _LUSDInStabPool\n    )\n        internal\n        pure\n        returns (uint debtToOffset, uint collToSendToSP, uint debtToRedistribute, uint collToRedistribute)\n    {\n        if (_LUSDInStabPool > 0) {\n        /* \n        * Offset as much debt & collateral as possible against the Stability Pool, and redistribute the remainder\n        * between all active troves.\n        *\n        *  If the trove's debt is larger than the deposited LUSD in the Stability Pool:\n        *\n        *  - Offset an amount of the trove's debt equal to the LUSD in the Stability Pool\n        *  - Send a fraction of the trove's collateral to the Stability Pool, equal to the fraction of its offset debt\n        *\n        */\n            debtToOffset = LiquityMath._min(_debt, _LUSDInStabPool);\n            collToSendToSP = _coll.mul(debtToOffset).div(_debt);\n            debtToRedistribute = _debt.sub(debtToOffset);\n            collToRedistribute = _coll.sub(collToSendToSP);\n        } else {\n            debtToOffset = 0;\n            collToSendToSP = 0;\n            debtToRedistribute = _debt;\n            collToRedistribute = _coll;\n        }\n    }\n\n    /*\n    *  If it is a full offset, get its offset coll/debt and ETH gas comp, and close the trove.\n    *\n    * If it is a partial liquidation, get its offset coll/debt and ETH gas comp, and its new coll/debt, and its re-insertion hints.\n    */\n    function _getFullOrPartialOffsetVals\n    (\n        address _borrower,\n        uint _entireTroveDebt,\n        uint _entireTroveColl,\n        uint _LUSDInStabPool\n    )\n        internal\n        returns (LiquidationValues memory V)\n    {\n        V.entireTroveDebt = _entireTroveDebt;\n        V.entireTroveColl = _entireTroveColl;\n\n        // When Stability Pool can fully absorb the trove's debt, perform a full offset\n        if (_entireTroveDebt <= _LUSDInStabPool) {\n            V.collGasCompensation = _getCollGasCompensation(_entireTroveColl);\n            V.LUSDGasCompensation = LUSD_GAS_COMPENSATION;\n\n            V.debtToOffset = _entireTroveDebt;\n            V.collToSendToSP = _entireTroveColl.sub(V.collGasCompensation);\n            V.debtToRedistribute = 0;\n            V.collToRedistribute = 0;\n\n            emit TroveLiquidated(_borrower, _entireTroveDebt, _entireTroveColl, TroveManagerOperation.liquidateInRecoveryMode);\n        }\n        /* \n        * When trove's debt is greater than the Stability Pool, perform a partial liquidation: offset as much as possible,\n        * and do not redistribute the remainder. The trove remains active, with a reduced collateral and debt.\n        *\n        * ETH gas compensation is based on and drawn from the collateral fraction that corresponds to the partial offset. \n        * LUSD gas compensation is left untouched. \n        *\n        * Since ETH gas comp is drawn purely from the *liquidated* portion, the trove is left with the same ICR as before the \n        * liquidation.\n        */\n        else if (_entireTroveDebt > _LUSDInStabPool) {\n            // Remaining debt in the trove is lower-bounded by the trove's gas compensation\n            V.partialNewDebt = LiquityMath._max(_entireTroveDebt.sub(_LUSDInStabPool), LUSD_GAS_COMPENSATION);\n          \n            V.debtToOffset = _entireTroveDebt.sub(V.partialNewDebt);\n\n            uint collFraction = _entireTroveColl.mul(V.debtToOffset).div(_entireTroveDebt);\n            V.collGasCompensation = _getCollGasCompensation(collFraction);\n          \n            V.LUSDGasCompensation = 0;  // LUSD gas compensation remains untouched\n\n            V.collToSendToSP = collFraction.sub(V.collGasCompensation);\n            V.collToRedistribute = 0;\n            V.debtToRedistribute = 0;\n\n            V.partialAddr = _borrower;\n            V.partialNewColl = _entireTroveColl.sub(collFraction);\n\n            // Get the partial trove's neighbours, so we can re-insert it later to the same position\n            V.partialUpperHint = sortedTroves.getPrev(_borrower);  \n            V.partialLowerHint = sortedTroves.getNext(_borrower);\n        }\n    }\n\n    /* \n    * Liquidate a sequence of troves. Closes a maximum number of n under-collateralized Troves,\n    * starting from the one with the lowest collateral ratio in the system, and moving upwards\n    */\n    function liquidateTroves(uint _n) external override {\n        LocalVariables_OuterLiquidationFunction memory L;\n\n        LiquidationTotals memory T;\n\n        L.price = priceFeed.getPrice();\n        L.LUSDInStabPool = stabilityPool.getTotalLUSDDeposits();\n        L.recoveryModeAtStart = checkRecoveryMode();\n\n        // Perform the appropriate liquidation sequence - tally the values, and obtain their totals\n        if (L.recoveryModeAtStart == true) {\n            T = _getTotalsFromLiquidateTrovesSequence_RecoveryMode(L.price, L.LUSDInStabPool, _n);\n        } else if (L.recoveryModeAtStart == false) {\n            T = _getTotalsFromLiquidateTrovesSequence_NormalMode(L.price, L.LUSDInStabPool, _n);\n        }\n\n        // Move liquidated ETH and LUSD to the appropriate pools\n        stabilityPool.offset(T.totalDebtToOffset, T.totalCollToSendToSP);\n        _redistributeDebtAndColl(T.totalDebtToRedistribute, T.totalCollToRedistribute);\n\n        // Update system snapshots and the final partially liquidated trove, if there is one\n        _updateSystemSnapshots_excludeCollRemainder(T.partialNewColl.add(T.totalCollGasCompensation));\n        _updatePartiallyLiquidatedTrove(T.partialAddr, T.partialNewDebt, T.partialNewColl, T.partialUpperHint, T. partialLowerHint, L.price);\n\n        L.liquidatedDebt = T.totalDebtInSequence.sub(T.partialNewDebt);\n        L.liquidatedColl = T.totalCollInSequence.sub(T.totalCollGasCompensation).sub(T.partialNewColl);\n        emit Liquidation(L.liquidatedDebt, L.liquidatedColl, T.totalCollGasCompensation, T.totalLUSDGasCompensation);\n\n        // Send gas compensation to caller\n        _sendGasCompensation(msg.sender, T.totalLUSDGasCompensation, T.totalCollGasCompensation);\n    }\n\n    /*\n    * This function is used when the liquidateTroves sequence starts during Recovery Mode. However, it\n    * handle the case where the system *leaves* Recovery Mode, part way through the liquidation sequence\n    */\n    function _getTotalsFromLiquidateTrovesSequence_RecoveryMode\n    (\n        uint _price,\n        uint _LUSDInStabPool,\n        uint _n\n    )\n        internal\n        returns(LiquidationTotals memory T)\n    {\n        LocalVariables_LiquidationSequence memory L;\n        LiquidationValues memory V;\n\n        L.remainingLUSDInStabPool = _LUSDInStabPool;\n        L.backToNormalMode = false;\n        L.entireSystemDebt = activePool.getLUSDDebt().add(defaultPool.getLUSDDebt());\n        L.entireSystemColl = activePool.getETH().add(defaultPool.getETH());\n\n        L.i = 0;\n        while (L.i < _n) {\n            L.user = sortedTroves.getLast();\n            L.ICR = getCurrentICR(L.user, _price);\n\n            if (L.backToNormalMode == false) {\n                // Break the loop if ICR is greater than MCR and Stability Pool is empty\n                if (L.ICR >= MCR && L.remainingLUSDInStabPool == 0) { break; }\n\n                uint TCR = LiquityMath._computeCR(L.entireSystemColl, L.entireSystemDebt, _price);\n        \n                V = _liquidateRecoveryMode(L.user, L.ICR, L.remainingLUSDInStabPool, TCR);\n\n                // Update aggregate trackers\n                L.remainingLUSDInStabPool = L.remainingLUSDInStabPool.sub(V.debtToOffset);\n                L.entireSystemDebt = L.entireSystemDebt.sub(V.debtToOffset);\n                L.entireSystemColl = L.entireSystemColl.sub(V.collToSendToSP);\n\n                // Add liquidation values to their respective running totals\n                T = _addLiquidationValuesToTotals(T, V);\n\n                // Break the loop if it was a partial liquidation\n                if (V.partialAddr != address(0)) {break;}\n\n                L.backToNormalMode = !_checkPotentialRecoveryMode(L.entireSystemColl, L.entireSystemDebt, _price);\n            }\n            else if (L.backToNormalMode == true && L.ICR < MCR) {\n                V = _liquidateNormalMode(L.user, L.remainingLUSDInStabPool);\n\n                L.remainingLUSDInStabPool = L.remainingLUSDInStabPool.sub(V.debtToOffset);\n\n                // Add liquidation values to their respective running totals\n                T = _addLiquidationValuesToTotals(T, V);\n\n            }  else break;  // break if the loop reaches a Trove with ICR >= MCR\n\n            // Break the loop if it reaches the first Trove in the sorted list\n            if (L.user == sortedTroves.getFirst()) { break; }\n\n            L.i++;\n        }\n    }\n\n    function _getTotalsFromLiquidateTrovesSequence_NormalMode\n    (\n        uint _price,\n        uint _LUSDInStabPool,\n        uint _n\n    )\n        internal\n        returns(LiquidationTotals memory T)\n    {\n        LocalVariables_LiquidationSequence memory L;\n        LiquidationValues memory V;\n\n        L.remainingLUSDInStabPool = _LUSDInStabPool;\n\n        L.i = 0;\n        while (L.i < _n) {\n            L.user = sortedTroves.getLast();\n            L.ICR = getCurrentICR(L.user, _price);\n\n            if (L.ICR < MCR) {\n                V = _liquidateNormalMode(L.user, L.remainingLUSDInStabPool);\n\n                L.remainingLUSDInStabPool = L.remainingLUSDInStabPool.sub(V.debtToOffset);\n\n                // Add liquidation values to their respective running totals\n                T = _addLiquidationValuesToTotals(T, V);\n\n            } else break;  // break if the loop reaches a Trove with ICR >= MCR\n\n            // Break the loop if it reaches the first Trove in the sorted list\n            if (L.user == sortedTroves.getFirst()) { break; }\n            L.i++;\n        }\n    }\n\n    /* \n    * Attempt to liquidate a custom list of troves provided by the caller. The liquidation sequence stops if\n    * a partial liquidation is performed, so it's up to the caller to order the troves in the _troveArray parameter.\n    */\n    function batchLiquidateTroves(address[] memory _troveArray) public override {\n        require(_troveArray.length != 0, \"TroveManager: Calldata address array must not be empty\");\n\n        LocalVariables_OuterLiquidationFunction memory L;\n        LiquidationTotals memory T;\n\n        L.price = priceFeed.getPrice();\n        L.LUSDInStabPool = stabilityPool.getTotalLUSDDeposits();\n        L.recoveryModeAtStart = checkRecoveryMode();\n\n        // Perform the appropriate liquidation sequence - tally values and obtain their totals.\n        if (L.recoveryModeAtStart == true) {\n           T = _getTotalFromBatchLiquidate_RecoveryMode(L.price, L.LUSDInStabPool, _troveArray);\n        } else if (L.recoveryModeAtStart == false) {\n            T = _getTotalsFromBatchLiquidate_NormalMode(L.price, L.LUSDInStabPool, _troveArray);\n        }\n\n        // Move liquidated ETH and LUSD to the appropriate pools\n        stabilityPool.offset(T.totalDebtToOffset, T.totalCollToSendToSP);\n        _redistributeDebtAndColl(T.totalDebtToRedistribute, T.totalCollToRedistribute);\n\n        // Update system snapshots and the final partially liquidated trove, if there is one\n        _updateSystemSnapshots_excludeCollRemainder(T.partialNewColl.add(T.totalCollGasCompensation));\n        _updatePartiallyLiquidatedTrove(T.partialAddr, T.partialNewDebt, T.partialNewColl, T.partialUpperHint, T. partialLowerHint, L.price);\n\n        L.liquidatedDebt = T.totalDebtInSequence.sub(T.partialNewDebt);\n        L.liquidatedColl = T.totalCollInSequence.sub(T.totalCollGasCompensation).sub(T.partialNewColl);\n        emit Liquidation(L.liquidatedDebt, L.liquidatedColl, T.totalCollGasCompensation, T.totalLUSDGasCompensation);\n\n        // Send gas compensation to caller\n        _sendGasCompensation(msg.sender, T.totalLUSDGasCompensation, T.totalCollGasCompensation);\n    }\n\n    /* \n    * This function is used when the batch liquidation sequence starts during Recovery Mode. However, it\n    * handle the case where the system *leaves* Recovery Mode, part way through the liquidation sequence\n    */\n    function _getTotalFromBatchLiquidate_RecoveryMode\n    (\n        uint _price,\n        uint _LUSDInStabPool,\n        address[] memory _troveArray)\n        internal\n        returns(LiquidationTotals memory T)\n    {\n        LocalVariables_LiquidationSequence memory L;\n        LiquidationValues memory V;\n\n        L.remainingLUSDInStabPool = _LUSDInStabPool;\n        L.backToNormalMode = false;\n        L.entireSystemDebt = activePool.getLUSDDebt().add(defaultPool.getLUSDDebt());\n        L.entireSystemColl = activePool.getETH().add(defaultPool.getETH());\n\n        L.i = 0;\n        for (L.i = 0; L.i < _troveArray.length; L.i++) {\n            L.user = _troveArray[L.i];\n            L.ICR = getCurrentICR(L.user, _price);\n\n            if (L.backToNormalMode == false) {\n\n                // Skip this trove if ICR is greater than MCR and Stability Pool is empty\n                if (L.ICR >= MCR && L.remainingLUSDInStabPool == 0) { continue; }\n\n                uint TCR = LiquityMath._computeCR(L.entireSystemColl, L.entireSystemDebt, _price);\n\n                V = _liquidateRecoveryMode(L.user, L.ICR, L.remainingLUSDInStabPool, TCR);\n\n                // Update aggregate trackers\n                L.remainingLUSDInStabPool = L.remainingLUSDInStabPool.sub(V.debtToOffset);\n                L.entireSystemDebt = L.entireSystemDebt.sub(V.debtToOffset);\n                L.entireSystemColl = L.entireSystemColl.sub(V.collToSendToSP);\n\n                // Add liquidation values to their respective running totals\n                T = _addLiquidationValuesToTotals(T, V);\n\n                // Break the loop if it was a partial liquidation\n                if (V.partialAddr != address(0)) { break; }\n\n                L.backToNormalMode = !_checkPotentialRecoveryMode(L.entireSystemColl, L.entireSystemDebt, _price);\n            }\n\n            else if (L.backToNormalMode == true && L.ICR < MCR) {\n                V = _liquidateNormalMode(L.user, L.remainingLUSDInStabPool);\n                L.remainingLUSDInStabPool = L.remainingLUSDInStabPool.sub(V.debtToOffset);\n\n                // Add liquidation values to their respective running totals\n                T = _addLiquidationValuesToTotals(T, V);\n            }\n        }\n    }\n\n    function _getTotalsFromBatchLiquidate_NormalMode\n    (\n        uint _price,\n        uint _LUSDInStabPool,\n        address[] memory _troveArray\n    )\n        internal\n        returns(LiquidationTotals memory T)\n    {\n        LocalVariables_LiquidationSequence memory L;\n        LiquidationValues memory V;\n\n        L.remainingLUSDInStabPool = _LUSDInStabPool;\n\n        for (L.i = 0; L.i < _troveArray.length; L.i++) {\n            L.user = _troveArray[L.i];\n            L.ICR = getCurrentICR(L.user, _price);\n\n            if (L.ICR < MCR) {\n                V = _liquidateNormalMode(L.user, L.remainingLUSDInStabPool);\n                L.remainingLUSDInStabPool = L.remainingLUSDInStabPool.sub(V.debtToOffset);\n\n                // Add liquidation values to their respective running totals\n                T = _addLiquidationValuesToTotals(T, V);\n            }\n        }\n    }\n\n    // --- Liquidation helper functions ---\n\n    function _addLiquidationValuesToTotals(LiquidationTotals memory T1, LiquidationValues memory V)\n    internal pure returns(LiquidationTotals memory T2) {\n\n        // Tally all the values with their respective running totals\n        T2.totalCollGasCompensation = T1.totalCollGasCompensation.add(V.collGasCompensation);\n        T2.totalLUSDGasCompensation = T1.totalLUSDGasCompensation.add(V.LUSDGasCompensation);\n        T2.totalDebtInSequence = T1.totalDebtInSequence.add(V.entireTroveDebt);\n        T2.totalCollInSequence = T1.totalCollInSequence.add(V.entireTroveColl);\n        T2.totalDebtToOffset = T1.totalDebtToOffset.add(V.debtToOffset);\n        T2.totalCollToSendToSP = T1.totalCollToSendToSP.add(V.collToSendToSP);\n        T2.totalDebtToRedistribute = T1.totalDebtToRedistribute.add(V.debtToRedistribute);\n        T2.totalCollToRedistribute = T1.totalCollToRedistribute.add(V.collToRedistribute);\n\n        // Assign the address of the partially liquidated trove, and its new debt and coll values\n        T2.partialAddr = V.partialAddr;\n        T2.partialNewDebt = V.partialNewDebt;\n        T2.partialNewColl = V.partialNewColl;\n        T2.partialUpperHint = V.partialUpperHint;\n        T2.partialLowerHint = V.partialLowerHint;\n\n        return T2;\n    }\n\n    // Update the properties of the partially liquidated trove, and insert it back to the list\n    function _updatePartiallyLiquidatedTrove\n    (\n        address _borrower, \n        uint _newDebt, \n        uint _newColl, \n        address _upperHint,\n        address _lowerHint,\n        uint _price\n    ) \n        internal \n    {\n        if ( _borrower == address(0)) { return; }\n\n        Troves[_borrower].debt = _newDebt;\n        Troves[_borrower].coll = _newColl;\n        Troves[_borrower].status = Status.active;\n\n        _updateTroveRewardSnapshots(_borrower);\n        _updateStakeAndTotalStakes(_borrower);\n\n        uint ICR = getCurrentICR(_borrower, _price);\n\n        /* \n        * Insert to sorted list and add to TroveOwners array. The partially liquidated trove has the same\n        * ICR as it did before the liquidation, so insertion is O(1): in principle, its ICR does not change.\n        * In practice, due to rounding error, its ICR can change slightly - so re-insert, with its previous neighbours\n        * as hints.\n        */\n        sortedTroves.insert(_borrower, ICR, _price, _upperHint, _lowerHint);\n        _addTroveOwnerToArray(_borrower);\n        emit TroveUpdated(_borrower, _newDebt, _newColl, Troves[_borrower].stake, TroveManagerOperation.partiallyLiquidateInRecoveryMode);\n    }\n\n    function _sendGasCompensation(address _liquidator, uint _LUSD, uint _ETH) internal {\n        if (_LUSD > 0) {\n            lusdToken.returnFromPool(GAS_POOL_ADDRESS, _liquidator, _LUSD);\n        }\n\n        if (_ETH > 0) {\n            activePool.sendETH(_liquidator, _ETH);\n        }\n    }\n\n    // Move a Trove's pending debt and collateral rewards from distributions, from the Default Pool to the Active Pool\n    function _movePendingTroveRewardsToActivePool(uint _LUSD, uint _ETH) internal {\n        defaultPool.decreaseLUSDDebt(_LUSD);\n        activePool.increaseLUSDDebt(_LUSD);\n        defaultPool.sendETH(address(activePool), _ETH);\n    }\n\n    // --- Redemption functions ---\n\n    // Redeem as much collateral as possible from _borrower's Trove in exchange for LUSD up to _maxLUSDamount\n    function _redeemCollateralFromTrove(\n        address _borrower,\n        uint _maxLUSDamount,\n        uint _price,\n        address _partialRedemptionHint,\n        uint _partialRedemptionHintICR\n    )\n        internal returns (SingleRedemptionValues memory V)\n    {\n        // Determine the remaining amount (lot) to be redeemed, capped by the entire debt of the Trove minus the gas compensation\n        V.LUSDLot = LiquityMath._min(_maxLUSDamount, Troves[_borrower].debt.sub(LUSD_GAS_COMPENSATION));\n\n        // Get the ETHLot of equivalent value in USD\n        V.ETHLot = V.LUSDLot.mul(1e18).div(_price);\n\n        // Decrease the debt and collateral of the current Trove according to the LUSD lot and corresponding ETH to send\n        uint newDebt = (Troves[_borrower].debt).sub(V.LUSDLot);\n        uint newColl = (Troves[_borrower].coll).sub(V.ETHLot);\n\n        if (newDebt == LUSD_GAS_COMPENSATION) {\n            // No debt left in the Trove (except for the gas compensation), therefore the trove gets closed\n            _removeStake(_borrower);\n            _closeTrove(_borrower);\n            _redeemCloseTrove(_borrower, LUSD_GAS_COMPENSATION, newColl);\n\n        } else {\n            uint newICR = LiquityMath._computeCR(newColl, newDebt, _price);\n\n            // Check if the provided hint is fresh. If not, we bail since trying to reinsert without a good hint will almost\n            // certainly result in running out of gas.\n            if (newICR != _partialRedemptionHintICR) {\n                V.LUSDLot = 0;\n                V.ETHLot = 0;\n                return V;\n            }\n\n            sortedTroves.reInsert(_borrower, newICR, _price, _partialRedemptionHint, _partialRedemptionHint);\n\n            Troves[_borrower].debt = newDebt;\n            Troves[_borrower].coll = newColl;\n            _updateStakeAndTotalStakes(_borrower);\n        }\n        emit TroveUpdated(\n            _borrower,\n            newDebt, newColl,\n            Troves[_borrower].stake,\n            TroveManagerOperation.redeemCollateral\n        );\n        return V;\n    }\n\n    /* \n    * Called when a full redemption occurs, and closes the trove.\n    * The redeemer swaps (debt - 10) LUSD for (debt - 10) worth of ETH, so the 10 LUSD gas compensation left corresponds to the remaining debt.\n    * In order to close the trove, the 10 LUSD gas compensation is burned, and 10 debt is removed from the active pool.\n    * The debt recorded on the trove's struct is zero'd elswhere, in _closeTrove.\n    * Any surplus ETH left in the trove, is sent to the Coll surplus pool, and can be later claimed by the borrower.\n    */ \n    function _redeemCloseTrove(address _borrower, uint _LUSD, uint _ETH) internal {\n        lusdToken.burn(GAS_POOL_ADDRESS, _LUSD);\n        // Update Active Pool LUSD, and send ETH to account\n        activePool.decreaseLUSDDebt(_LUSD);\n\n        // send ETH from Active Pool to CollSurplus Pool\n        collSurplusPool.accountSurplus(_borrower, _ETH);\n        activePool.sendETH(address(collSurplusPool), _ETH);\n    }\n\n    function _isValidFirstRedemptionHint(address _firstRedemptionHint, uint _price) internal view returns (bool) {\n        if (_firstRedemptionHint == address(0) ||\n            !sortedTroves.contains(_firstRedemptionHint) ||\n            getCurrentICR(_firstRedemptionHint, _price) < MCR\n        ) {\n            return false;\n        }\n\n        address nextTrove = sortedTroves.getNext(_firstRedemptionHint);\n        return nextTrove == address(0) || getCurrentICR(nextTrove, _price) < MCR;\n    }\n\n    /* Send _LUSDamount LUSD to the system and redeem the corresponding amount of collateral from as many Troves as are needed to fill the redemption\n    * request.  Applies pending rewards to a Trove before reducing its debt and coll.\n    *\n    * Note that if _amount is very large, this function can run out of gas, specially if traversed troves are small. This can be easily avoided by \n    * splitting the total _amount in appropriate chunks and calling the function multiple times.\n    * \n    * Param `_maxIterations` can also be provided, so the loop through Troves is capped (if its zero, it will be ignored).This makes it easier to \n    * avoid OOG for the frontend, as only knowing approximately the average cost of an iteration is enough, without needing to know the topology \n    * of the trove list. It also avoids the need to set the cap in stone in the contract, nor doing gas calculations, as both gas price and opcode \n    * costs can vary.\n    * \n    * All Troves that are redeemed from -- with the likely exception of the last one -- will end up with no debt left, therefore they will be closed.\n    * If the last Trove does have some remaining debt, it has a finite ICR, and the reinsertion could be anywhere in the list, therefore it requires a hint. \n    * A frontend should use getRedemptionHints() to calculate what the ICR of this Trove will be after redemption, and pass a hint for its position \n    * in the sortedTroves list along with the ICR value that the hint was found for.\n    * \n    * If another transaction modifies the list between calling getRedemptionHints() and passing the hints to redeemCollateral(), it\n    * is very likely that the last (partially) redeemed Trove would end up with a different ICR than what the hint is for. In this case the\n    * redemption will stop after the last completely redeemed Trove and the sender will keep the remaining LUSD amount, which they can attempt\n    * to redeem later.\n    */\n    function redeemCollateral(\n        uint _LUSDamount,\n        address _firstRedemptionHint,\n        address _partialRedemptionHint,\n        uint _partialRedemptionHintICR,\n        uint _maxIterations\n    )\n        external\n        override\n    {\n        uint activeDebt = activePool.getLUSDDebt();\n        uint defaultedDebt = defaultPool.getLUSDDebt();\n\n        RedemptionTotals memory T;\n\n        _requireAmountGreaterThanZero(_LUSDamount);\n        _requireLUSDBalanceCoversRedemption(msg.sender, _LUSDamount);\n\n        // Confirm redeemer's balance is less than total systemic debt\n        assert(lusdToken.balanceOf(msg.sender) <= (activeDebt.add(defaultedDebt)));\n\n        uint remainingLUSD = _LUSDamount;\n        uint price = priceFeed.getPrice();\n        address currentBorrower;\n\n        if (_isValidFirstRedemptionHint(_firstRedemptionHint, price)) {\n            currentBorrower = _firstRedemptionHint;\n        } else {\n            currentBorrower = sortedTroves.getLast();\n            // Find the first trove with ICR >= MCR\n            // SWC-104-Unchecked Call Return Value: L920\n            while (currentBorrower != address(0) && getCurrentICR(currentBorrower, price) < MCR) {\n                currentBorrower = sortedTroves.getPrev(currentBorrower);\n            }\n        }\n\n        // Loop through the Troves starting from the one with lowest collateral ratio until _amount of LUSD is exchanged for collateral\n        if (_maxIterations == 0) { _maxIterations = uint(-1); }\n        while (currentBorrower != address(0) && remainingLUSD > 0 && _maxIterations > 0) {\n            _maxIterations--;\n            // Save the address of the Trove preceding the current one, before potentially modifying the list\n            address nextUserToCheck = sortedTroves.getPrev(currentBorrower);\n\n            _applyPendingRewards(currentBorrower);\n            SingleRedemptionValues memory V = _redeemCollateralFromTrove(\n                currentBorrower,\n                remainingLUSD,\n                price,\n                _partialRedemptionHint,\n                _partialRedemptionHintICR\n            );\n\n            if (V.LUSDLot == 0) break; // Partial redemption hint got out-of-date, therefore we could not redeem from the last Trove\n\n            T.totalLUSDToRedeem  = T.totalLUSDToRedeem.add(V.LUSDLot);\n            T.totalETHDrawn = T.totalETHDrawn.add(V.ETHLot);\n\n            remainingLUSD = remainingLUSD.sub(V.LUSDLot);\n            currentBorrower = nextUserToCheck;\n        }\n\n        // Decay the baseRate due to time passed, and then increase it according to the size of this redemption\n        _updateBaseRateFromRedemption(T.totalETHDrawn, price);\n\n        // Calculate the ETH fee and send it to the LQTY staking contract\n        T.ETHFee = _getRedemptionFee(T.totalETHDrawn);\n        activePool.sendETH(lqtyStakingAddress, T.ETHFee);\n        lqtyStaking.increaseF_ETH(T.ETHFee);\n\n        T.ETHToSendToRedeemer = T.totalETHDrawn.sub(T.ETHFee);\n\n        // Burn the total LUSD that is cancelled with debt, and send the redeemed ETH to msg.sender\n        _activePoolRedeemCollateral(msg.sender, T.totalLUSDToRedeem, T.ETHToSendToRedeemer);\n\n        emit Redemption(_LUSDamount, T.totalLUSDToRedeem, T.totalETHDrawn, T.ETHFee);\n    }\n\n    // Burn the received LUSD, transfer the redeemed ETH to _redeemer and updates the Active Pool\n    function _activePoolRedeemCollateral(address _redeemer, uint _LUSD, uint _ETH) internal {\n        // Update Active Pool LUSD, and send ETH to account\n        lusdToken.burn(_redeemer, _LUSD);\n        activePool.decreaseLUSDDebt(_LUSD);\n\n        activePool.sendETH(_redeemer, _ETH);\n    }\n\n    // --- Helper functions ---\n\n\n    // Return the current collateral ratio (ICR) of a given Trove. Takes a trove's pending coll and debt rewards from redistributions into account.\n    function getCurrentICR(address _borrower, uint _price) public view override returns (uint) {\n        uint pendingETHReward = getPendingETHReward(_borrower);\n        uint pendingLUSDDebtReward = getPendingLUSDDebtReward(_borrower);\n\n        uint currentETH = Troves[_borrower].coll.add(pendingETHReward);\n        uint currentLUSDDebt = Troves[_borrower].debt.add(pendingLUSDDebtReward);\n\n        uint ICR = LiquityMath._computeCR(currentETH, currentLUSDDebt, _price);\n        return ICR;\n    }\n\n    function applyPendingRewards(address _borrower) external override {\n        _requireCallerIsBorrowerOperations();\n        return _applyPendingRewards(_borrower);\n    }\n\n    // Add the borrowers's coll and debt rewards earned from redistributions, to their Trove\n    function _applyPendingRewards(address _borrower) internal {\n        if (hasPendingRewards(_borrower)) {\n            _requireTroveisActive(_borrower);\n\n            // Compute pending rewards\n            uint pendingETHReward = getPendingETHReward(_borrower);\n            uint pendingLUSDDebtReward = getPendingLUSDDebtReward(_borrower);\n\n            // Apply pending rewards to trove's state\n            Troves[_borrower].coll = Troves[_borrower].coll.add(pendingETHReward);\n            Troves[_borrower].debt = Troves[_borrower].debt.add(pendingLUSDDebtReward);\n\n            _updateTroveRewardSnapshots(_borrower);\n\n            // Transfer from DefaultPool to ActivePool\n            _movePendingTroveRewardsToActivePool(pendingLUSDDebtReward, pendingETHReward);\n\n            emit TroveUpdated(\n                _borrower, \n                Troves[_borrower].debt, \n                Troves[_borrower].coll, \n                Troves[_borrower].stake, \n                TroveManagerOperation.applyPendingRewards\n            );\n        }\n    }\n\n    // Update borrower's snapshots of L_ETH and L_LUSDDebt to reflect the current values\n    function updateTroveRewardSnapshots(address _borrower) external override {\n        _requireCallerIsBorrowerOperations();\n       return _updateTroveRewardSnapshots(_borrower);\n    }\n\n    function _updateTroveRewardSnapshots(address _borrower) internal {\n        rewardSnapshots[_borrower].ETH = L_ETH;\n        rewardSnapshots[_borrower].LUSDDebt = L_LUSDDebt;\n    }\n\n    // Get the borrower's pending accumulated ETH reward, earned by their stake\n    function getPendingETHReward(address _borrower) public view override returns (uint) {\n        uint snapshotETH = rewardSnapshots[_borrower].ETH;\n        uint rewardPerUnitStaked = L_ETH.sub(snapshotETH);\n\n        if ( rewardPerUnitStaked == 0 ) { return 0; }\n\n        uint stake = Troves[_borrower].stake;\n\n        uint pendingETHReward = stake.mul(rewardPerUnitStaked).div(1e18);\n\n        return pendingETHReward;\n    }\n\n     // Get the borrower's pending accumulated LUSD reward, earned by their stake\n    function getPendingLUSDDebtReward(address _borrower) public view override returns (uint) {\n        uint snapshotLUSDDebt = rewardSnapshots[_borrower].LUSDDebt;\n        uint rewardPerUnitStaked = L_LUSDDebt.sub(snapshotLUSDDebt);\n\n        if ( rewardPerUnitStaked == 0 ) { return 0; }\n\n        uint stake =  Troves[_borrower].stake;\n\n        uint pendingLUSDDebtReward = stake.mul(rewardPerUnitStaked).div(1e18);\n\n        return pendingLUSDDebtReward;\n    }\n\n    function hasPendingRewards(address _borrower) public view override returns (bool) {\n        /* \n        * A Trove has pending rewards if its snapshot is less than the current rewards per-unit-staked sum:\n        * this indicates that rewards have occured since the snapshot was made, and the user therefore has\n        * pending rewards \n        */\n        return (rewardSnapshots[_borrower].ETH < L_ETH);\n    }\n\n    // Return the Troves entire debt and coll, including pending rewards from redistributions.\n    function getEntireDebtAndColl(\n        address _borrower\n    )\n        public\n        view\n        override\n        returns (uint debt, uint coll, uint pendingLUSDDebtReward, uint pendingETHReward)\n    {\n        debt = Troves[_borrower].debt;\n        coll = Troves[_borrower].coll;\n\n        pendingLUSDDebtReward = getPendingLUSDDebtReward(_borrower);\n        pendingETHReward = getPendingETHReward(_borrower);\n\n        debt = debt.add(pendingLUSDDebtReward);\n        coll = coll.add(pendingETHReward);\n    }\n\n    function removeStake(address _borrower) external override {\n        _requireCallerIsBorrowerOperations();\n        return _removeStake(_borrower);\n    }\n\n    // Remove borrower's stake from the totalStakes sum, and set their stake to 0\n    function _removeStake(address _borrower) internal {\n        uint stake = Troves[_borrower].stake;\n        totalStakes = totalStakes.sub(stake);\n        Troves[_borrower].stake = 0;\n    }\n\n    function updateStakeAndTotalStakes(address _borrower) external override returns (uint) {\n        _requireCallerIsBorrowerOperations();\n        return _updateStakeAndTotalStakes(_borrower);\n    }\n\n    // Update borrower's stake based on their latest collateral value\n    function _updateStakeAndTotalStakes(address _borrower) internal returns (uint) {\n        uint newStake = _computeNewStake(Troves[_borrower].coll);\n        uint oldStake = Troves[_borrower].stake;\n        Troves[_borrower].stake = newStake;\n        totalStakes = totalStakes.sub(oldStake).add(newStake);\n\n        return newStake;\n    }\n\n    // Calculate a new stake based on the snapshots of the totalStakes and totalCollateral taken at the last liquidation\n    function _computeNewStake(uint _coll) internal view returns (uint) {\n        uint stake;\n        if (totalCollateralSnapshot == 0) {\n            stake = _coll;\n        } else {\n            /*  \n            * The following assert() holds true because:\n            * - The system always contains >= 1 trove \n            * - When we close or liquidate a trove, we redistribute the pending rewards, so if all troves were closed/liquidated, \n            * rewards wouldve been emptied and totalCollateralSnapshot would be zero too.\n            */\n            assert(totalStakesSnapshot > 0);\n            stake = _coll.mul(totalStakesSnapshot).div(totalCollateralSnapshot);\n        }\n        return stake;\n    }\n\n    function _redistributeDebtAndColl(uint _debt, uint _coll) internal {\n        if (_debt == 0) { return; }\n\n        if (totalStakes > 0) {\n            /* \n            * Add distributed coll and debt rewards-per-unit-staked to the running totals.\n            * Division uses a \"feedback\" error correction, to keep the cumulative error in\n            * the  L_ETH and L_LUSDDebt state variables low. \n            */\n            uint ETHNumerator = _coll.mul(1e18).add(lastETHError_Redistribution);\n            uint LUSDDebtNumerator = _debt.mul(1e18).add(lastLUSDDebtError_Redistribution);\n\n            uint ETHRewardPerUnitStaked = ETHNumerator.div(totalStakes);\n            uint LUSDDebtRewardPerUnitStaked = LUSDDebtNumerator.div(totalStakes);\n\n            lastETHError_Redistribution = ETHNumerator.sub(ETHRewardPerUnitStaked.mul(totalStakes));\n            lastLUSDDebtError_Redistribution = LUSDDebtNumerator.sub(LUSDDebtRewardPerUnitStaked.mul(totalStakes));\n\n            L_ETH = L_ETH.add(ETHRewardPerUnitStaked);\n            L_LUSDDebt = L_LUSDDebt.add(LUSDDebtRewardPerUnitStaked);\n        }\n\n        // Transfer coll and debt from ActivePool to DefaultPool\n        activePool.decreaseLUSDDebt(_debt);\n        defaultPool.increaseLUSDDebt(_debt);\n        activePool.sendETH(address(defaultPool), _coll);\n    }\n\n    function closeTrove(address _borrower) external override {\n        _requireCallerIsBorrowerOperations();\n        return _closeTrove(_borrower);\n    }\n\n    function _closeTrove(address _borrower) internal {\n        uint TroveOwnersArrayLength = TroveOwners.length;\n        _requireMoreThanOneTroveInSystem(TroveOwnersArrayLength);\n\n        Troves[_borrower].status = Status.closed;\n        Troves[_borrower].coll = 0;\n        Troves[_borrower].debt = 0;\n\n        rewardSnapshots[_borrower].ETH = 0;\n        rewardSnapshots[_borrower].LUSDDebt = 0;\n\n        _removeTroveOwner(_borrower, TroveOwnersArrayLength);\n        sortedTroves.remove(_borrower);\n    }\n\n    /* \n    * Updates snapshots of system total stakes and total collateral, excluding a given collateral remainder from the calculation. \n    * Used in a liquidation sequence.\n    *\n    * The calculation excludes two portions of collateral that are in the ActivePool: \n    *\n    * 1) the total ETH gas compensation from the liquidation sequence\n    * 2) The remaining collateral in a partially liquidated trove (if one occurred)\n    *\n    * The ETH as compensation must be excluded as it is always sent out at the very end of the liquidation sequence.\n    *\n    * The partially liquidated trove's remaining collateral stays in the ActivePool, but it is excluded here so the system \n    * can take snapshots before the partially liquidated trove's stake is updated (based on these snapshots). This ensures\n    * the partial's new stake doesn't double-count its own remaining collateral.\n    *\n    */\n    function _updateSystemSnapshots_excludeCollRemainder(uint _collRemainder) internal {\n        totalStakesSnapshot = totalStakes;\n\n        uint activeColl = activePool.getETH();\n        uint liquidatedColl = defaultPool.getETH();\n        totalCollateralSnapshot = activeColl.sub(_collRemainder).add(liquidatedColl);\n    }\n\n    // Push the owner's address to the Trove owners list, and record the corresponding array index on the Trove struct\n    function addTroveOwnerToArray(address _borrower) external override returns (uint index) {\n        _requireCallerIsBorrowerOperations();\n        return _addTroveOwnerToArray(_borrower);\n    }\n\n    function _addTroveOwnerToArray(address _borrower) internal returns (uint128 index) {\n        require(TroveOwners.length < 2**128 - 1, \"TroveManager: TroveOwners array has maximum size of 2^128 - 1\");\n\n        // Push the Troveowner to the array\n        TroveOwners.push(_borrower);\n\n        // Record the index of the new Troveowner on their Trove struct\n        index = uint128(TroveOwners.length.sub(1));\n        Troves[_borrower].arrayIndex = index;\n\n        return index;\n    }\n\n    /* \n    * Remove a Trove owner from the TroveOwners array, not preserving array order. Removing owner 'B' does the following:\n    * [A B C D E] => [A E C D], and updates E's Trove struct to point to its new array index. \n    */\n    function _removeTroveOwner(address _borrower, uint TroveOwnersArrayLength) internal {\n        require(Troves[_borrower].status == Status.closed, \"TroveManager: Trove is still active\");\n\n        uint128 index = Troves[_borrower].arrayIndex;\n        uint length = TroveOwnersArrayLength;\n        uint idxLast = length.sub(1);\n\n        assert(index <= idxLast);\n\n        address addressToMove = TroveOwners[idxLast];\n\n        TroveOwners[index] = addressToMove;\n        Troves[addressToMove].arrayIndex = index;\n        TroveOwners.pop();\n    }\n\n    // --- Recovery Mode and TCR functions ---\n\n    function checkRecoveryMode() public view override returns (bool) {\n        uint TCR = getTCR();\n\n        if (TCR < CCR) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    // Check whether or not the system *would be* in Recovery Mode, given an ETH:USD price, and the entire system coll and debt.\n    function _checkPotentialRecoveryMode(\n        uint _entireSystemColl,\n        uint _entireSystemDebt,\n        uint _price\n    )\n        internal\n        pure\n    returns (bool)\n    {\n        uint TCR = LiquityMath._computeCR(_entireSystemColl, _entireSystemDebt, _price);\n        if (TCR < CCR) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n    // SWC-135-Code With No Effects: L1276-L1284\n    function getTCR() public view override returns (uint TCR) {\n        uint price = priceFeed.getPrice();\n        uint entireSystemColl = getEntireSystemColl();\n        uint entireSystemDebt = getEntireSystemDebt();\n\n        TCR = LiquityMath._computeCR(entireSystemColl, entireSystemDebt, price);\n\n        return TCR;\n    }\n    // SWC-135-Code With No Effects: L1286-L1291\n    function getEntireSystemColl() public view override returns (uint entireSystemColl) {\n        uint activeColl = activePool.getETH();\n        uint liquidatedColl = defaultPool.getETH();\n\n        return activeColl.add(liquidatedColl);\n    }\n\n    function getEntireSystemDebt() public view override returns (uint entireSystemDebt) {\n        uint activeDebt = activePool.getLUSDDebt();\n        uint closedDebt = defaultPool.getLUSDDebt();\n\n        return activeDebt.add(closedDebt);\n    }\n\n    // --- Redemption fee functions ---\n\n    /* \n    * This function has two impacts on the baseRate state variable:\n    * 1) decays the baseRate based on time passed since last redemption or LUSD borrowing operation.\n    * then,\n    * 2) increases the baseRate based on the amount redeemed, as a proportion of total supply\n    */\n    function _updateBaseRateFromRedemption(uint _ETHDrawn,  uint _price) internal returns (uint) {\n        uint decayedBaseRate = _calcDecayedBaseRate();\n\n        uint activeDebt = activePool.getLUSDDebt();\n        uint closedDebt = defaultPool.getLUSDDebt();\n        uint totalLUSDSupply = activeDebt.add(closedDebt);\n\n        /* Convert the drawn ETH back to LUSD at face value rate (1 LUSD:1 USD), in order to get\n        * the fraction of total supply that was redeemed at face value. */\n        uint redeemedLUSDFraction = _ETHDrawn.mul(_price).div(totalLUSDSupply);\n\n        uint newBaseRate = decayedBaseRate.add(redeemedLUSDFraction.div(BETA));\n\n        // Update the baseRate state variable\n        baseRate = newBaseRate < 1e18 ? newBaseRate : 1e18;  // cap baseRate at a maximum of 100%\n        assert(baseRate <= 1e18 && baseRate > 0); // Base rate is always non-zero after redemption\n\n        _updateLastFeeOpTime();\n\n        return baseRate;\n    }\n\n    function _getRedemptionFee(uint _ETHDrawn) internal view returns (uint) {\n       return baseRate.mul(_ETHDrawn).div(1e18);\n    }\n\n    // --- Borrowing fee functions ---\n\n    function getBorrowingFee(uint _LUSDDebt) external view override returns (uint) {\n        return _LUSDDebt.mul(baseRate).div(1e18);\n    }\n\n    // Updates the baseRate state variable based on time elapsed since the last redemption or LUSD borrowing operation.\n    function decayBaseRateFromBorrowing() external override {\n        _requireCallerIsBorrowerOperations();\n\n        baseRate = _calcDecayedBaseRate();\n        assert(baseRate <= 1e18);  // The baseRate can decay to 0\n\n        _updateLastFeeOpTime();\n    }\n\n    // --- Internal fee functions ---\n\n    // Update the last fee operation time only if time passed >= decay interval. This prevents base rate griefing.\n    function _updateLastFeeOpTime() internal {\n        uint timePassed = block.timestamp.sub(lastFeeOperationTime);\n\n        if (timePassed >= SECONDS_IN_ONE_MINUTE) {\n            lastFeeOperationTime = block.timestamp;\n        }\n    }\n\n    function _calcDecayedBaseRate() internal view returns (uint) {\n        uint minutesPassed = _minutesPassedSinceLastFeeOp();\n        uint decayFactor = LiquityMath._decPow(MINUTE_DECAY_FACTOR, minutesPassed);\n\n        return baseRate.mul(decayFactor).div(1e18);\n    }\n\n    function _minutesPassedSinceLastFeeOp() internal view returns (uint) {\n        return (block.timestamp.sub(lastFeeOperationTime)).div(SECONDS_IN_ONE_MINUTE);\n    }\n\n    // --- 'require' wrapper functions ---\n\n    function _requireCallerIsBorrowerOperations() internal view {\n        require(msg.sender == borrowerOperationsAddress, \"TroveManager: Caller is not the BorrowerOperations contract\");\n    }\n\n    function _requireTroveisActive(address _borrower) internal view {\n        require(Troves[_borrower].status == Status.active, \"TroveManager: Trove does not exist or is closed\");\n    }\n\n    function _requireLUSDBalanceCoversRedemption(address _redeemer, uint _amount) internal view {\n        require(lusdToken.balanceOf(_redeemer) >= _amount, \"TroveManager: Requested redemption amount must be <= user's LUSD token balance\");\n    }\n\n    function _requireMoreThanOneTroveInSystem(uint TroveOwnersArrayLength) internal view {\n        require (TroveOwnersArrayLength > 1 && sortedTroves.getSize() > 1, \"TroveManager: Only one trove in the system\");\n    }\n\n    function _requireAmountGreaterThanZero(uint _amount) internal pure {\n        require(_amount > 0, \"TroveManager: Amount must be greater than zero\");\n    }\n\n    // --- Trove property getters ---\n\n    function getTroveStatus(address _borrower) external view override returns (uint) {\n        return uint(Troves[_borrower].status);\n    }\n\n    function getTroveStake(address _borrower) external view override returns (uint) {\n        return Troves[_borrower].stake;\n    }\n\n    function getTroveDebt(address _borrower) external view override returns (uint) {\n        return Troves[_borrower].debt;\n    }\n\n    function getTroveColl(address _borrower) external view override returns (uint) {\n        return Troves[_borrower].coll;\n    }\n\n    // --- Trove property setters, called by BorrowerOperations ---\n\n    function setTroveStatus(address _borrower, uint _num) external override {\n        _requireCallerIsBorrowerOperations();\n        Troves[_borrower].status = Status(_num);\n    }\n\n    function increaseTroveColl(address _borrower, uint _collIncrease) external override returns (uint) {\n        _requireCallerIsBorrowerOperations();\n        uint newColl = Troves[_borrower].coll.add(_collIncrease);\n        Troves[_borrower].coll = newColl;\n        return newColl;\n    }\n\n    function decreaseTroveColl(address _borrower, uint _collDecrease) external override returns (uint) {\n        _requireCallerIsBorrowerOperations();\n        uint newColl = Troves[_borrower].coll.sub(_collDecrease);\n        Troves[_borrower].coll = newColl;\n        return newColl;\n    }\n\n    function increaseTroveDebt(address _borrower, uint _debtIncrease) external override returns (uint) {\n        _requireCallerIsBorrowerOperations();\n        uint newDebt = Troves[_borrower].debt.add(_debtIncrease);\n        Troves[_borrower].debt = newDebt;\n        return newDebt;\n    }\n\n    function decreaseTroveDebt(address _borrower, uint _debtDecrease) external override returns (uint) {\n        _requireCallerIsBorrowerOperations();\n        uint newDebt = Troves[_borrower].debt.sub(_debtDecrease);\n        Troves[_borrower].debt = newDebt;\n        return newDebt;\n    }\n}",
        "function": "checkRecoveryMode()",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-Liquity/dev-f0df3efa5a5f05b205752184cfce107c5bd6e06c/packages/contracts/contracts/TroveManager.sol",
        "vulnerability": "Multiple Calls in a Single Transaction (SWC 113)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract TroveManager is LiquityBase, Ownable, ITroveManager {\n\n    // --- Connected contract declarations ---\n\n    address public borrowerOperationsAddress;\n\n    IPool public activePool;\n\n    IPool public defaultPool;\n\n    IStabilityPool public stabilityPool;\n\n    ICollSurplusPool collSurplusPool;\n\n    ILUSDToken public lusdToken;\n\n    IPriceFeed public priceFeed;\n\n    ILQTYStaking public lqtyStaking;\n    address public lqtyStakingAddress;\n\n    // A doubly linked list of Troves, sorted by their sorted by their collateral ratios\n    ISortedTroves public sortedTroves;\n\n    // --- Data structures ---\n\n    uint constant public SECONDS_IN_ONE_MINUTE = 60;\n    uint constant public MINUTE_DECAY_FACTOR = 999832508430720967;  // 18 digit decimal. Corresponds to an hourly decay factor of 0.99\n\n    /* \n    * BETA: 18 digit decimal. Parameter by which to divide the redeemed fraction, in order to calc the new base rate from a redemption. \n    * Corresponds to (1 / ALPHA) in the white paper. \n    */\n    uint constant public BETA = 2;\n\n    uint public baseRate;\n\n    // The timestamp of the latest fee operation (redemption or new LUSD issuance) \n    uint public lastFeeOperationTime;\n\n    enum Status { nonExistent, active, closed }\n\n    // Store the necessary data for a trove\n    struct Trove {\n        uint debt;\n        uint coll;\n        uint stake;\n        Status status;\n        uint128 arrayIndex;\n    }\n\n    mapping (address => Trove) public Troves;\n\n    uint public totalStakes;\n\n    // Snapshot of the value of totalStakes, taken immediately after the latest liquidation\n    uint public totalStakesSnapshot;\n\n    // Snapshot of the total collateral across the ActivePool and DefaultPool, immediately after the latest liquidation.\n    uint public totalCollateralSnapshot;\n\n    /*\n    * L_ETH and L_LUSDDebt track the sums of accumulated liquidation rewards per unit staked. During its lifetime, each stake earns:\n    *\n    * An ETH gain of ( stake * [L_ETH - L_ETH(0)] )\n    * A LUSDDebt increase  of ( stake * [L_LUSDDebt - L_LUSDDebt(0)] )\n    *\n    * Where L_ETH(0) and L_LUSDDebt(0) are snapshots of L_ETH and L_LUSDDebt for the active Trove taken at the instant the stake was made\n    */\n    uint public L_ETH;\n    uint public L_LUSDDebt;\n\n    // Map addresses with active troves to their RewardSnapshot\n    mapping (address => RewardSnapshot) public rewardSnapshots;\n\n    // Object containing the ETH and LUSD snapshots for a given active trove\n    struct RewardSnapshot { uint ETH; uint LUSDDebt;}\n\n    // Array of all active trove addresses - used to to compute an approximate hint off-chain, for the sorted list insertion\n    address[] public TroveOwners;\n\n    // Error trackers for the trove redistribution calculation\n    uint public lastETHError_Redistribution;\n    uint public lastLUSDDebtError_Redistribution;\n\n    /* \n    * --- Variable container structs for liquidations ---\n    *\n    * These structs are used to hold, return and assign variables inside the liquidation functions,\n    * in order to avoid the error: \"CompilerError: Stack too deep\". \n    **/\n\n    struct LocalVariables_OuterLiquidationFunction {\n        uint price;\n        uint LUSDInStabPool;\n        bool recoveryModeAtStart;\n        uint liquidatedDebt;\n        uint liquidatedColl;\n    }\n\n    struct LocalVariables_InnerSingleLiquidateFunction {\n        uint collToLiquidate;\n        uint pendingDebtReward;\n        uint pendingCollReward;\n    }\n\n    struct LocalVariables_LiquidationSequence {\n        uint remainingLUSDInStabPool;\n        uint i;\n        uint ICR;\n        address user;\n        bool backToNormalMode;\n        uint entireSystemDebt;\n        uint entireSystemColl;\n    }\n\n    struct LiquidationValues {\n        uint entireTroveDebt;\n        uint entireTroveColl;\n        uint collGasCompensation;\n        uint LUSDGasCompensation;\n        uint debtToOffset;\n        uint collToSendToSP;\n        uint debtToRedistribute;\n        uint collToRedistribute;\n        address partialAddr;\n        uint partialNewDebt;\n        uint partialNewColl;\n        address partialUpperHint;\n        address partialLowerHint;\n    }\n\n    struct LiquidationTotals {\n        uint totalCollInSequence;\n        uint totalDebtInSequence;\n        uint totalCollGasCompensation;\n        uint totalLUSDGasCompensation;\n        uint totalDebtToOffset;\n        uint totalCollToSendToSP;\n        uint totalDebtToRedistribute;\n        uint totalCollToRedistribute;\n        address partialAddr;\n        uint partialNewDebt;\n        uint partialNewColl;\n        address partialUpperHint;\n        address partialLowerHint;\n    }\n\n    // --- Variable container structs for redemptions ---\n\n    struct RedemptionTotals {\n        uint totalLUSDToRedeem;\n        uint totalETHDrawn;\n        uint ETHFee;\n        uint ETHToSendToRedeemer;\n        uint decayedBaseRate;\n    }\n\n    struct SingleRedemptionValues {\n        uint LUSDLot;\n        uint ETHLot;\n    }\n\n    // --- Events ---\n\n    event Liquidation(uint _liquidatedDebt, uint _liquidatedColl, uint _collGasCompensation, uint _LUSDGasCompensation);\n    event Redemption(uint _attemptedLUSDAmount, uint _actualLUSDAmount, uint _ETHSent, uint _ETHFee);\n\n    enum TroveManagerOperation {\n        applyPendingRewards,\n        liquidateInNormalMode,\n        liquidateInRecoveryMode,\n        partiallyLiquidateInRecoveryMode,\n        redeemCollateral\n    }\n\n    event TroveCreated(address indexed _borrower, uint _arrayIndex);\n    event TroveUpdated(address indexed _borrower, uint _debt, uint _coll, uint _stake, TroveManagerOperation _operation);\n    event TroveLiquidated(address indexed _borrower, uint _debt, uint _coll, TroveManagerOperation _operation);\n\n    // --- Dependency setter ---\n\n    function setAddresses(\n        address _borrowerOperationsAddress,\n        address _activePoolAddress,\n        address _defaultPoolAddress,\n        address _stabilityPoolAddress,\n        address _collSurplusPoolAddress,\n        address _priceFeedAddress,\n        address _lusdTokenAddress,\n        address _sortedTrovesAddress,\n        address _lqtyStakingAddress\n    )\n        external\n        override\n        onlyOwner\n    {\n        borrowerOperationsAddress = _borrowerOperationsAddress;\n        activePool = IPool(_activePoolAddress);\n        defaultPool = IPool(_defaultPoolAddress);\n        stabilityPool = IStabilityPool(_stabilityPoolAddress);\n        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);\n        priceFeed = IPriceFeed(_priceFeedAddress);\n        lusdToken = ILUSDToken(_lusdTokenAddress);\n        sortedTroves = ISortedTroves(_sortedTrovesAddress);\n        lqtyStakingAddress = _lqtyStakingAddress;\n        lqtyStaking = ILQTYStaking(_lqtyStakingAddress);\n\n        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);\n        emit ActivePoolAddressChanged(_activePoolAddress);\n        emit DefaultPoolAddressChanged(_defaultPoolAddress);\n        emit StabilityPoolAddressChanged(_stabilityPoolAddress);\n        emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);\n        emit PriceFeedAddressChanged(_priceFeedAddress);\n        emit LUSDTokenAddressChanged(_lusdTokenAddress);\n        emit SortedTrovesAddressChanged(_sortedTrovesAddress);\n        emit LQTYStakingAddressChanged(_lqtyStakingAddress);\n\n        _renounceOwnership();\n    }\n\n    // --- Getters ---\n\n    function getTroveOwnersCount() external view override returns (uint) {\n        return TroveOwners.length;\n    }\n\n    function getTroveFromTroveOwnersArray(uint _index) external view override returns (address) {\n        return TroveOwners[_index];\n    }\n\n    // --- Trove Liquidation functions ---\n\n    // Single liquidation function. Closes the trove if its ICR is lower than the minimum collateral ratio. \n    function liquidate(address _borrower) external override {\n        _requireTroveisActive(_borrower);\n\n        address[] memory borrowers = new address[](1);\n        borrowers[0] = _borrower;\n        batchLiquidateTroves(borrowers);\n    }\n\n    // --- Inner single liquidation functions ---\n\n    // Liquidate one trove, in Normal Mode.\n    function _liquidateNormalMode(address _borrower, uint _LUSDInStabPool) internal returns (LiquidationValues memory V) {\n        LocalVariables_InnerSingleLiquidateFunction memory L;\n\n        (V.entireTroveDebt,\n        V.entireTroveColl,\n        L.pendingDebtReward,\n        L.pendingCollReward) = getEntireDebtAndColl(_borrower);\n\n        _movePendingTroveRewardsToActivePool(L.pendingDebtReward, L.pendingCollReward);\n        _removeStake(_borrower);\n\n        V.collGasCompensation = _getCollGasCompensation(V.entireTroveColl);\n        V.LUSDGasCompensation = LUSD_GAS_COMPENSATION;\n        uint collToLiquidate = V.entireTroveColl.sub(V.collGasCompensation);\n\n        (V.debtToOffset,\n        V.collToSendToSP,\n        V.debtToRedistribute,\n        V.collToRedistribute) = _getOffsetAndRedistributionVals(V.entireTroveDebt, collToLiquidate, _LUSDInStabPool);\n\n        _closeTrove(_borrower);\n        emit TroveLiquidated(_borrower, V.entireTroveDebt, V.entireTroveColl, TroveManagerOperation.liquidateInNormalMode);\n\n        return V;\n    }\n\n    // Liquidate one trove, in Recovery Mode.\n    function _liquidateRecoveryMode(address _borrower, uint _ICR, uint _LUSDInStabPool, uint _TCR) internal returns (LiquidationValues memory V) {\n        LocalVariables_InnerSingleLiquidateFunction memory L;\n        \n        if (TroveOwners.length <= 1) { return V; } // don't liquidate if last trove\n\n        (V.entireTroveDebt,\n        V.entireTroveColl,\n        L.pendingDebtReward,\n        L.pendingCollReward) = getEntireDebtAndColl(_borrower);\n\n        _movePendingTroveRewardsToActivePool(L.pendingDebtReward, L.pendingCollReward);\n\n        V.collGasCompensation = _getCollGasCompensation(V.entireTroveColl);\n        // In case of a partial liquidation, V.LUSDGasCompensation will be overwritten to zero, in the third branch below\n        V.LUSDGasCompensation = LUSD_GAS_COMPENSATION;\n        L.collToLiquidate = V.entireTroveColl.sub(V.collGasCompensation);\n\n        // If ICR <= 100%, purely redistribute the Trove across all active Troves\n        if (_ICR <= _100pct) {\n            _removeStake(_borrower);\n\n            V.debtToOffset = 0;\n            V.collToSendToSP = 0;\n            V.debtToRedistribute = V.entireTroveDebt;\n            V.collToRedistribute = L.collToLiquidate;\n\n            _closeTrove(_borrower);\n            emit TroveLiquidated(_borrower, V.entireTroveDebt, V.entireTroveColl, TroveManagerOperation.liquidateInRecoveryMode);\n\n        // If 100% < ICR < MCR, offset as much as possible, and redistribute the remainder\n        } else if ((_ICR > _100pct) && (_ICR < MCR)) {\n            _removeStake(_borrower);\n\n            (V.debtToOffset,\n            V.collToSendToSP,\n            V.debtToRedistribute,\n            V.collToRedistribute) = _getOffsetAndRedistributionVals(V.entireTroveDebt, L.collToLiquidate, _LUSDInStabPool);\n\n            _closeTrove(_borrower);\n            emit TroveLiquidated(_borrower, V.entireTroveDebt, V.entireTroveColl, TroveManagerOperation.liquidateInRecoveryMode);\n\n        /* \n        * If 110% <= ICR < current TCR (accounting for the preceding liquidations in the current sequence)\n        * and there is LUSD in the Stability Pool, only offset it as much as possible, with no redistribution.\n        */\n        } else if ((_ICR >= MCR) && (_ICR < _TCR)) {\n            assert(_LUSDInStabPool != 0);\n\n            _removeStake(_borrower);\n            \n            V = _getFullOrPartialOffsetVals(_borrower, V.entireTroveDebt, V.entireTroveColl, _LUSDInStabPool);\n\n            _closeTrove(_borrower);\n        }\n        else if (_ICR >= _TCR) {\n            LiquidationValues memory zeroVals;\n            return zeroVals;\n        }\n\n        return V;\n    }\n\n    /* In a full liquidation, returns the values for a trove's coll and debt to be offset, and coll and debt to be \n    * redistributed to active troves. \n    */\n    function _getOffsetAndRedistributionVals\n    (\n        uint _debt,\n        uint _coll,\n        uint _LUSDInStabPool\n    )\n        internal\n        pure\n        returns (uint debtToOffset, uint collToSendToSP, uint debtToRedistribute, uint collToRedistribute)\n    {\n        if (_LUSDInStabPool > 0) {\n        /* \n        * Offset as much debt & collateral as possible against the Stability Pool, and redistribute the remainder\n        * between all active troves.\n        *\n        *  If the trove's debt is larger than the deposited LUSD in the Stability Pool:\n        *\n        *  - Offset an amount of the trove's debt equal to the LUSD in the Stability Pool\n        *  - Send a fraction of the trove's collateral to the Stability Pool, equal to the fraction of its offset debt\n        *\n        */\n            debtToOffset = LiquityMath._min(_debt, _LUSDInStabPool);\n            collToSendToSP = _coll.mul(debtToOffset).div(_debt);\n            debtToRedistribute = _debt.sub(debtToOffset);\n            collToRedistribute = _coll.sub(collToSendToSP);\n        } else {\n            debtToOffset = 0;\n            collToSendToSP = 0;\n            debtToRedistribute = _debt;\n            collToRedistribute = _coll;\n        }\n    }\n\n    /*\n    *  If it is a full offset, get its offset coll/debt and ETH gas comp, and close the trove.\n    *\n    * If it is a partial liquidation, get its offset coll/debt and ETH gas comp, and its new coll/debt, and its re-insertion hints.\n    */\n    function _getFullOrPartialOffsetVals\n    (\n        address _borrower,\n        uint _entireTroveDebt,\n        uint _entireTroveColl,\n        uint _LUSDInStabPool\n    )\n        internal\n        returns (LiquidationValues memory V)\n    {\n        V.entireTroveDebt = _entireTroveDebt;\n        V.entireTroveColl = _entireTroveColl;\n\n        // When Stability Pool can fully absorb the trove's debt, perform a full offset\n        if (_entireTroveDebt <= _LUSDInStabPool) {\n            V.collGasCompensation = _getCollGasCompensation(_entireTroveColl);\n            V.LUSDGasCompensation = LUSD_GAS_COMPENSATION;\n\n            V.debtToOffset = _entireTroveDebt;\n            V.collToSendToSP = _entireTroveColl.sub(V.collGasCompensation);\n            V.debtToRedistribute = 0;\n            V.collToRedistribute = 0;\n\n            emit TroveLiquidated(_borrower, _entireTroveDebt, _entireTroveColl, TroveManagerOperation.liquidateInRecoveryMode);\n        }\n        /* \n        * When trove's debt is greater than the Stability Pool, perform a partial liquidation: offset as much as possible,\n        * and do not redistribute the remainder. The trove remains active, with a reduced collateral and debt.\n        *\n        * ETH gas compensation is based on and drawn from the collateral fraction that corresponds to the partial offset. \n        * LUSD gas compensation is left untouched. \n        *\n        * Since ETH gas comp is drawn purely from the *liquidated* portion, the trove is left with the same ICR as before the \n        * liquidation.\n        */\n        else if (_entireTroveDebt > _LUSDInStabPool) {\n            // Remaining debt in the trove is lower-bounded by the trove's gas compensation\n            V.partialNewDebt = LiquityMath._max(_entireTroveDebt.sub(_LUSDInStabPool), LUSD_GAS_COMPENSATION);\n          \n            V.debtToOffset = _entireTroveDebt.sub(V.partialNewDebt);\n\n            uint collFraction = _entireTroveColl.mul(V.debtToOffset).div(_entireTroveDebt);\n            V.collGasCompensation = _getCollGasCompensation(collFraction);\n          \n            V.LUSDGasCompensation = 0;  // LUSD gas compensation remains untouched\n\n            V.collToSendToSP = collFraction.sub(V.collGasCompensation);\n            V.collToRedistribute = 0;\n            V.debtToRedistribute = 0;\n\n            V.partialAddr = _borrower;\n            V.partialNewColl = _entireTroveColl.sub(collFraction);\n\n            // Get the partial trove's neighbours, so we can re-insert it later to the same position\n            V.partialUpperHint = sortedTroves.getPrev(_borrower);  \n            V.partialLowerHint = sortedTroves.getNext(_borrower);\n        }\n    }\n\n    /* \n    * Liquidate a sequence of troves. Closes a maximum number of n under-collateralized Troves,\n    * starting from the one with the lowest collateral ratio in the system, and moving upwards\n    */\n    function liquidateTroves(uint _n) external override {\n        LocalVariables_OuterLiquidationFunction memory L;\n\n        LiquidationTotals memory T;\n\n        L.price = priceFeed.getPrice();\n        L.LUSDInStabPool = stabilityPool.getTotalLUSDDeposits();\n        L.recoveryModeAtStart = checkRecoveryMode();\n\n        // Perform the appropriate liquidation sequence - tally the values, and obtain their totals\n        if (L.recoveryModeAtStart == true) {\n            T = _getTotalsFromLiquidateTrovesSequence_RecoveryMode(L.price, L.LUSDInStabPool, _n);\n        } else if (L.recoveryModeAtStart == false) {\n            T = _getTotalsFromLiquidateTrovesSequence_NormalMode(L.price, L.LUSDInStabPool, _n);\n        }\n\n        // Move liquidated ETH and LUSD to the appropriate pools\n        stabilityPool.offset(T.totalDebtToOffset, T.totalCollToSendToSP);\n        _redistributeDebtAndColl(T.totalDebtToRedistribute, T.totalCollToRedistribute);\n\n        // Update system snapshots and the final partially liquidated trove, if there is one\n        _updateSystemSnapshots_excludeCollRemainder(T.partialNewColl.add(T.totalCollGasCompensation));\n        _updatePartiallyLiquidatedTrove(T.partialAddr, T.partialNewDebt, T.partialNewColl, T.partialUpperHint, T. partialLowerHint, L.price);\n\n        L.liquidatedDebt = T.totalDebtInSequence.sub(T.partialNewDebt);\n        L.liquidatedColl = T.totalCollInSequence.sub(T.totalCollGasCompensation).sub(T.partialNewColl);\n        emit Liquidation(L.liquidatedDebt, L.liquidatedColl, T.totalCollGasCompensation, T.totalLUSDGasCompensation);\n\n        // Send gas compensation to caller\n        _sendGasCompensation(msg.sender, T.totalLUSDGasCompensation, T.totalCollGasCompensation);\n    }\n\n    /*\n    * This function is used when the liquidateTroves sequence starts during Recovery Mode. However, it\n    * handle the case where the system *leaves* Recovery Mode, part way through the liquidation sequence\n    */\n    function _getTotalsFromLiquidateTrovesSequence_RecoveryMode\n    (\n        uint _price,\n        uint _LUSDInStabPool,\n        uint _n\n    )\n        internal\n        returns(LiquidationTotals memory T)\n    {\n        LocalVariables_LiquidationSequence memory L;\n        LiquidationValues memory V;\n\n        L.remainingLUSDInStabPool = _LUSDInStabPool;\n        L.backToNormalMode = false;\n        L.entireSystemDebt = activePool.getLUSDDebt().add(defaultPool.getLUSDDebt());\n        L.entireSystemColl = activePool.getETH().add(defaultPool.getETH());\n\n        L.i = 0;\n        while (L.i < _n) {\n            L.user = sortedTroves.getLast();\n            L.ICR = getCurrentICR(L.user, _price);\n\n            if (L.backToNormalMode == false) {\n                // Break the loop if ICR is greater than MCR and Stability Pool is empty\n                if (L.ICR >= MCR && L.remainingLUSDInStabPool == 0) { break; }\n\n                uint TCR = LiquityMath._computeCR(L.entireSystemColl, L.entireSystemDebt, _price);\n        \n                V = _liquidateRecoveryMode(L.user, L.ICR, L.remainingLUSDInStabPool, TCR);\n\n                // Update aggregate trackers\n                L.remainingLUSDInStabPool = L.remainingLUSDInStabPool.sub(V.debtToOffset);\n                L.entireSystemDebt = L.entireSystemDebt.sub(V.debtToOffset);\n                L.entireSystemColl = L.entireSystemColl.sub(V.collToSendToSP);\n\n                // Add liquidation values to their respective running totals\n                T = _addLiquidationValuesToTotals(T, V);\n\n                // Break the loop if it was a partial liquidation\n                if (V.partialAddr != address(0)) {break;}\n\n                L.backToNormalMode = !_checkPotentialRecoveryMode(L.entireSystemColl, L.entireSystemDebt, _price);\n            }\n            else if (L.backToNormalMode == true && L.ICR < MCR) {\n                V = _liquidateNormalMode(L.user, L.remainingLUSDInStabPool);\n\n                L.remainingLUSDInStabPool = L.remainingLUSDInStabPool.sub(V.debtToOffset);\n\n                // Add liquidation values to their respective running totals\n                T = _addLiquidationValuesToTotals(T, V);\n\n            }  else break;  // break if the loop reaches a Trove with ICR >= MCR\n\n            // Break the loop if it reaches the first Trove in the sorted list\n            if (L.user == sortedTroves.getFirst()) { break; }\n\n            L.i++;\n        }\n    }\n\n    function _getTotalsFromLiquidateTrovesSequence_NormalMode\n    (\n        uint _price,\n        uint _LUSDInStabPool,\n        uint _n\n    )\n        internal\n        returns(LiquidationTotals memory T)\n    {\n        LocalVariables_LiquidationSequence memory L;\n        LiquidationValues memory V;\n\n        L.remainingLUSDInStabPool = _LUSDInStabPool;\n\n        L.i = 0;\n        while (L.i < _n) {\n            L.user = sortedTroves.getLast();\n            L.ICR = getCurrentICR(L.user, _price);\n\n            if (L.ICR < MCR) {\n                V = _liquidateNormalMode(L.user, L.remainingLUSDInStabPool);\n\n                L.remainingLUSDInStabPool = L.remainingLUSDInStabPool.sub(V.debtToOffset);\n\n                // Add liquidation values to their respective running totals\n                T = _addLiquidationValuesToTotals(T, V);\n\n            } else break;  // break if the loop reaches a Trove with ICR >= MCR\n\n            // Break the loop if it reaches the first Trove in the sorted list\n            if (L.user == sortedTroves.getFirst()) { break; }\n            L.i++;\n        }\n    }\n\n    /* \n    * Attempt to liquidate a custom list of troves provided by the caller. The liquidation sequence stops if\n    * a partial liquidation is performed, so it's up to the caller to order the troves in the _troveArray parameter.\n    */\n    function batchLiquidateTroves(address[] memory _troveArray) public override {\n        require(_troveArray.length != 0, \"TroveManager: Calldata address array must not be empty\");\n\n        LocalVariables_OuterLiquidationFunction memory L;\n        LiquidationTotals memory T;\n\n        L.price = priceFeed.getPrice();\n        L.LUSDInStabPool = stabilityPool.getTotalLUSDDeposits();\n        L.recoveryModeAtStart = checkRecoveryMode();\n\n        // Perform the appropriate liquidation sequence - tally values and obtain their totals.\n        if (L.recoveryModeAtStart == true) {\n           T = _getTotalFromBatchLiquidate_RecoveryMode(L.price, L.LUSDInStabPool, _troveArray);\n        } else if (L.recoveryModeAtStart == false) {\n            T = _getTotalsFromBatchLiquidate_NormalMode(L.price, L.LUSDInStabPool, _troveArray);\n        }\n\n        // Move liquidated ETH and LUSD to the appropriate pools\n        stabilityPool.offset(T.totalDebtToOffset, T.totalCollToSendToSP);\n        _redistributeDebtAndColl(T.totalDebtToRedistribute, T.totalCollToRedistribute);\n\n        // Update system snapshots and the final partially liquidated trove, if there is one\n        _updateSystemSnapshots_excludeCollRemainder(T.partialNewColl.add(T.totalCollGasCompensation));\n        _updatePartiallyLiquidatedTrove(T.partialAddr, T.partialNewDebt, T.partialNewColl, T.partialUpperHint, T. partialLowerHint, L.price);\n\n        L.liquidatedDebt = T.totalDebtInSequence.sub(T.partialNewDebt);\n        L.liquidatedColl = T.totalCollInSequence.sub(T.totalCollGasCompensation).sub(T.partialNewColl);\n        emit Liquidation(L.liquidatedDebt, L.liquidatedColl, T.totalCollGasCompensation, T.totalLUSDGasCompensation);\n\n        // Send gas compensation to caller\n        _sendGasCompensation(msg.sender, T.totalLUSDGasCompensation, T.totalCollGasCompensation);\n    }\n\n    /* \n    * This function is used when the batch liquidation sequence starts during Recovery Mode. However, it\n    * handle the case where the system *leaves* Recovery Mode, part way through the liquidation sequence\n    */\n    function _getTotalFromBatchLiquidate_RecoveryMode\n    (\n        uint _price,\n        uint _LUSDInStabPool,\n        address[] memory _troveArray)\n        internal\n        returns(LiquidationTotals memory T)\n    {\n        LocalVariables_LiquidationSequence memory L;\n        LiquidationValues memory V;\n\n        L.remainingLUSDInStabPool = _LUSDInStabPool;\n        L.backToNormalMode = false;\n        L.entireSystemDebt = activePool.getLUSDDebt().add(defaultPool.getLUSDDebt());\n        L.entireSystemColl = activePool.getETH().add(defaultPool.getETH());\n\n        L.i = 0;\n        for (L.i = 0; L.i < _troveArray.length; L.i++) {\n            L.user = _troveArray[L.i];\n            L.ICR = getCurrentICR(L.user, _price);\n\n            if (L.backToNormalMode == false) {\n\n                // Skip this trove if ICR is greater than MCR and Stability Pool is empty\n                if (L.ICR >= MCR && L.remainingLUSDInStabPool == 0) { continue; }\n\n                uint TCR = LiquityMath._computeCR(L.entireSystemColl, L.entireSystemDebt, _price);\n\n                V = _liquidateRecoveryMode(L.user, L.ICR, L.remainingLUSDInStabPool, TCR);\n\n                // Update aggregate trackers\n                L.remainingLUSDInStabPool = L.remainingLUSDInStabPool.sub(V.debtToOffset);\n                L.entireSystemDebt = L.entireSystemDebt.sub(V.debtToOffset);\n                L.entireSystemColl = L.entireSystemColl.sub(V.collToSendToSP);\n\n                // Add liquidation values to their respective running totals\n                T = _addLiquidationValuesToTotals(T, V);\n\n                // Break the loop if it was a partial liquidation\n                if (V.partialAddr != address(0)) { break; }\n\n                L.backToNormalMode = !_checkPotentialRecoveryMode(L.entireSystemColl, L.entireSystemDebt, _price);\n            }\n\n            else if (L.backToNormalMode == true && L.ICR < MCR) {\n                V = _liquidateNormalMode(L.user, L.remainingLUSDInStabPool);\n                L.remainingLUSDInStabPool = L.remainingLUSDInStabPool.sub(V.debtToOffset);\n\n                // Add liquidation values to their respective running totals\n                T = _addLiquidationValuesToTotals(T, V);\n            }\n        }\n    }\n\n    function _getTotalsFromBatchLiquidate_NormalMode\n    (\n        uint _price,\n        uint _LUSDInStabPool,\n        address[] memory _troveArray\n    )\n        internal\n        returns(LiquidationTotals memory T)\n    {\n        LocalVariables_LiquidationSequence memory L;\n        LiquidationValues memory V;\n\n        L.remainingLUSDInStabPool = _LUSDInStabPool;\n\n        for (L.i = 0; L.i < _troveArray.length; L.i++) {\n            L.user = _troveArray[L.i];\n            L.ICR = getCurrentICR(L.user, _price);\n\n            if (L.ICR < MCR) {\n                V = _liquidateNormalMode(L.user, L.remainingLUSDInStabPool);\n                L.remainingLUSDInStabPool = L.remainingLUSDInStabPool.sub(V.debtToOffset);\n\n                // Add liquidation values to their respective running totals\n                T = _addLiquidationValuesToTotals(T, V);\n            }\n        }\n    }\n\n    // --- Liquidation helper functions ---\n\n    function _addLiquidationValuesToTotals(LiquidationTotals memory T1, LiquidationValues memory V)\n    internal pure returns(LiquidationTotals memory T2) {\n\n        // Tally all the values with their respective running totals\n        T2.totalCollGasCompensation = T1.totalCollGasCompensation.add(V.collGasCompensation);\n        T2.totalLUSDGasCompensation = T1.totalLUSDGasCompensation.add(V.LUSDGasCompensation);\n        T2.totalDebtInSequence = T1.totalDebtInSequence.add(V.entireTroveDebt);\n        T2.totalCollInSequence = T1.totalCollInSequence.add(V.entireTroveColl);\n        T2.totalDebtToOffset = T1.totalDebtToOffset.add(V.debtToOffset);\n        T2.totalCollToSendToSP = T1.totalCollToSendToSP.add(V.collToSendToSP);\n        T2.totalDebtToRedistribute = T1.totalDebtToRedistribute.add(V.debtToRedistribute);\n        T2.totalCollToRedistribute = T1.totalCollToRedistribute.add(V.collToRedistribute);\n\n        // Assign the address of the partially liquidated trove, and its new debt and coll values\n        T2.partialAddr = V.partialAddr;\n        T2.partialNewDebt = V.partialNewDebt;\n        T2.partialNewColl = V.partialNewColl;\n        T2.partialUpperHint = V.partialUpperHint;\n        T2.partialLowerHint = V.partialLowerHint;\n\n        return T2;\n    }\n\n    // Update the properties of the partially liquidated trove, and insert it back to the list\n    function _updatePartiallyLiquidatedTrove\n    (\n        address _borrower, \n        uint _newDebt, \n        uint _newColl, \n        address _upperHint,\n        address _lowerHint,\n        uint _price\n    ) \n        internal \n    {\n        if ( _borrower == address(0)) { return; }\n\n        Troves[_borrower].debt = _newDebt;\n        Troves[_borrower].coll = _newColl;\n        Troves[_borrower].status = Status.active;\n\n        _updateTroveRewardSnapshots(_borrower);\n        _updateStakeAndTotalStakes(_borrower);\n\n        uint ICR = getCurrentICR(_borrower, _price);\n\n        /* \n        * Insert to sorted list and add to TroveOwners array. The partially liquidated trove has the same\n        * ICR as it did before the liquidation, so insertion is O(1): in principle, its ICR does not change.\n        * In practice, due to rounding error, its ICR can change slightly - so re-insert, with its previous neighbours\n        * as hints.\n        */\n        sortedTroves.insert(_borrower, ICR, _price, _upperHint, _lowerHint);\n        _addTroveOwnerToArray(_borrower);\n        emit TroveUpdated(_borrower, _newDebt, _newColl, Troves[_borrower].stake, TroveManagerOperation.partiallyLiquidateInRecoveryMode);\n    }\n\n    function _sendGasCompensation(address _liquidator, uint _LUSD, uint _ETH) internal {\n        if (_LUSD > 0) {\n            lusdToken.returnFromPool(GAS_POOL_ADDRESS, _liquidator, _LUSD);\n        }\n\n        if (_ETH > 0) {\n            activePool.sendETH(_liquidator, _ETH);\n        }\n    }\n\n    // Move a Trove's pending debt and collateral rewards from distributions, from the Default Pool to the Active Pool\n    function _movePendingTroveRewardsToActivePool(uint _LUSD, uint _ETH) internal {\n        defaultPool.decreaseLUSDDebt(_LUSD);\n        activePool.increaseLUSDDebt(_LUSD);\n        defaultPool.sendETH(address(activePool), _ETH);\n    }\n\n    // --- Redemption functions ---\n\n    // Redeem as much collateral as possible from _borrower's Trove in exchange for LUSD up to _maxLUSDamount\n    function _redeemCollateralFromTrove(\n        address _borrower,\n        uint _maxLUSDamount,\n        uint _price,\n        address _partialRedemptionHint,\n        uint _partialRedemptionHintICR\n    )\n        internal returns (SingleRedemptionValues memory V)\n    {\n        // Determine the remaining amount (lot) to be redeemed, capped by the entire debt of the Trove minus the gas compensation\n        V.LUSDLot = LiquityMath._min(_maxLUSDamount, Troves[_borrower].debt.sub(LUSD_GAS_COMPENSATION));\n\n        // Get the ETHLot of equivalent value in USD\n        V.ETHLot = V.LUSDLot.mul(1e18).div(_price);\n\n        // Decrease the debt and collateral of the current Trove according to the LUSD lot and corresponding ETH to send\n        uint newDebt = (Troves[_borrower].debt).sub(V.LUSDLot);\n        uint newColl = (Troves[_borrower].coll).sub(V.ETHLot);\n\n        if (newDebt == LUSD_GAS_COMPENSATION) {\n            // No debt left in the Trove (except for the gas compensation), therefore the trove gets closed\n            _removeStake(_borrower);\n            _closeTrove(_borrower);\n            _redeemCloseTrove(_borrower, LUSD_GAS_COMPENSATION, newColl);\n\n        } else {\n            uint newICR = LiquityMath._computeCR(newColl, newDebt, _price);\n\n            // Check if the provided hint is fresh. If not, we bail since trying to reinsert without a good hint will almost\n            // certainly result in running out of gas.\n            if (newICR != _partialRedemptionHintICR) {\n                V.LUSDLot = 0;\n                V.ETHLot = 0;\n                return V;\n            }\n\n            sortedTroves.reInsert(_borrower, newICR, _price, _partialRedemptionHint, _partialRedemptionHint);\n\n            Troves[_borrower].debt = newDebt;\n            Troves[_borrower].coll = newColl;\n            _updateStakeAndTotalStakes(_borrower);\n        }\n        emit TroveUpdated(\n            _borrower,\n            newDebt, newColl,\n            Troves[_borrower].stake,\n            TroveManagerOperation.redeemCollateral\n        );\n        return V;\n    }\n\n    /* \n    * Called when a full redemption occurs, and closes the trove.\n    * The redeemer swaps (debt - 10) LUSD for (debt - 10) worth of ETH, so the 10 LUSD gas compensation left corresponds to the remaining debt.\n    * In order to close the trove, the 10 LUSD gas compensation is burned, and 10 debt is removed from the active pool.\n    * The debt recorded on the trove's struct is zero'd elswhere, in _closeTrove.\n    * Any surplus ETH left in the trove, is sent to the Coll surplus pool, and can be later claimed by the borrower.\n    */ \n    function _redeemCloseTrove(address _borrower, uint _LUSD, uint _ETH) internal {\n        lusdToken.burn(GAS_POOL_ADDRESS, _LUSD);\n        // Update Active Pool LUSD, and send ETH to account\n        activePool.decreaseLUSDDebt(_LUSD);\n\n        // send ETH from Active Pool to CollSurplus Pool\n        collSurplusPool.accountSurplus(_borrower, _ETH);\n        activePool.sendETH(address(collSurplusPool), _ETH);\n    }\n\n    function _isValidFirstRedemptionHint(address _firstRedemptionHint, uint _price) internal view returns (bool) {\n        if (_firstRedemptionHint == address(0) ||\n            !sortedTroves.contains(_firstRedemptionHint) ||\n            getCurrentICR(_firstRedemptionHint, _price) < MCR\n        ) {\n            return false;\n        }\n\n        address nextTrove = sortedTroves.getNext(_firstRedemptionHint);\n        return nextTrove == address(0) || getCurrentICR(nextTrove, _price) < MCR;\n    }\n\n    /* Send _LUSDamount LUSD to the system and redeem the corresponding amount of collateral from as many Troves as are needed to fill the redemption\n    * request.  Applies pending rewards to a Trove before reducing its debt and coll.\n    *\n    * Note that if _amount is very large, this function can run out of gas, specially if traversed troves are small. This can be easily avoided by \n    * splitting the total _amount in appropriate chunks and calling the function multiple times.\n    * \n    * Param `_maxIterations` can also be provided, so the loop through Troves is capped (if its zero, it will be ignored).This makes it easier to \n    * avoid OOG for the frontend, as only knowing approximately the average cost of an iteration is enough, without needing to know the topology \n    * of the trove list. It also avoids the need to set the cap in stone in the contract, nor doing gas calculations, as both gas price and opcode \n    * costs can vary.\n    * \n    * All Troves that are redeemed from -- with the likely exception of the last one -- will end up with no debt left, therefore they will be closed.\n    * If the last Trove does have some remaining debt, it has a finite ICR, and the reinsertion could be anywhere in the list, therefore it requires a hint. \n    * A frontend should use getRedemptionHints() to calculate what the ICR of this Trove will be after redemption, and pass a hint for its position \n    * in the sortedTroves list along with the ICR value that the hint was found for.\n    * \n    * If another transaction modifies the list between calling getRedemptionHints() and passing the hints to redeemCollateral(), it\n    * is very likely that the last (partially) redeemed Trove would end up with a different ICR than what the hint is for. In this case the\n    * redemption will stop after the last completely redeemed Trove and the sender will keep the remaining LUSD amount, which they can attempt\n    * to redeem later.\n    */\n    function redeemCollateral(\n        uint _LUSDamount,\n        address _firstRedemptionHint,\n        address _partialRedemptionHint,\n        uint _partialRedemptionHintICR,\n        uint _maxIterations\n    )\n        external\n        override\n    {\n        uint activeDebt = activePool.getLUSDDebt();\n        uint defaultedDebt = defaultPool.getLUSDDebt();\n\n        RedemptionTotals memory T;\n\n        _requireAmountGreaterThanZero(_LUSDamount);\n        _requireLUSDBalanceCoversRedemption(msg.sender, _LUSDamount);\n\n        // Confirm redeemer's balance is less than total systemic debt\n        assert(lusdToken.balanceOf(msg.sender) <= (activeDebt.add(defaultedDebt)));\n\n        uint remainingLUSD = _LUSDamount;\n        uint price = priceFeed.getPrice();\n        address currentBorrower;\n\n        if (_isValidFirstRedemptionHint(_firstRedemptionHint, price)) {\n            currentBorrower = _firstRedemptionHint;\n        } else {\n            currentBorrower = sortedTroves.getLast();\n            // Find the first trove with ICR >= MCR\n            // SWC-104-Unchecked Call Return Value: L920\n            while (currentBorrower != address(0) && getCurrentICR(currentBorrower, price) < MCR) {\n                currentBorrower = sortedTroves.getPrev(currentBorrower);\n            }\n        }\n\n        // Loop through the Troves starting from the one with lowest collateral ratio until _amount of LUSD is exchanged for collateral\n        if (_maxIterations == 0) { _maxIterations = uint(-1); }\n        while (currentBorrower != address(0) && remainingLUSD > 0 && _maxIterations > 0) {\n            _maxIterations--;\n            // Save the address of the Trove preceding the current one, before potentially modifying the list\n            address nextUserToCheck = sortedTroves.getPrev(currentBorrower);\n\n            _applyPendingRewards(currentBorrower);\n            SingleRedemptionValues memory V = _redeemCollateralFromTrove(\n                currentBorrower,\n                remainingLUSD,\n                price,\n                _partialRedemptionHint,\n                _partialRedemptionHintICR\n            );\n\n            if (V.LUSDLot == 0) break; // Partial redemption hint got out-of-date, therefore we could not redeem from the last Trove\n\n            T.totalLUSDToRedeem  = T.totalLUSDToRedeem.add(V.LUSDLot);\n            T.totalETHDrawn = T.totalETHDrawn.add(V.ETHLot);\n\n            remainingLUSD = remainingLUSD.sub(V.LUSDLot);\n            currentBorrower = nextUserToCheck;\n        }\n\n        // Decay the baseRate due to time passed, and then increase it according to the size of this redemption\n        _updateBaseRateFromRedemption(T.totalETHDrawn, price);\n\n        // Calculate the ETH fee and send it to the LQTY staking contract\n        T.ETHFee = _getRedemptionFee(T.totalETHDrawn);\n        activePool.sendETH(lqtyStakingAddress, T.ETHFee);\n        lqtyStaking.increaseF_ETH(T.ETHFee);\n\n        T.ETHToSendToRedeemer = T.totalETHDrawn.sub(T.ETHFee);\n\n        // Burn the total LUSD that is cancelled with debt, and send the redeemed ETH to msg.sender\n        _activePoolRedeemCollateral(msg.sender, T.totalLUSDToRedeem, T.ETHToSendToRedeemer);\n\n        emit Redemption(_LUSDamount, T.totalLUSDToRedeem, T.totalETHDrawn, T.ETHFee);\n    }\n\n    // Burn the received LUSD, transfer the redeemed ETH to _redeemer and updates the Active Pool\n    function _activePoolRedeemCollateral(address _redeemer, uint _LUSD, uint _ETH) internal {\n        // Update Active Pool LUSD, and send ETH to account\n        lusdToken.burn(_redeemer, _LUSD);\n        activePool.decreaseLUSDDebt(_LUSD);\n\n        activePool.sendETH(_redeemer, _ETH);\n    }\n\n    // --- Helper functions ---\n\n\n    // Return the current collateral ratio (ICR) of a given Trove. Takes a trove's pending coll and debt rewards from redistributions into account.\n    function getCurrentICR(address _borrower, uint _price) public view override returns (uint) {\n        uint pendingETHReward = getPendingETHReward(_borrower);\n        uint pendingLUSDDebtReward = getPendingLUSDDebtReward(_borrower);\n\n        uint currentETH = Troves[_borrower].coll.add(pendingETHReward);\n        uint currentLUSDDebt = Troves[_borrower].debt.add(pendingLUSDDebtReward);\n\n        uint ICR = LiquityMath._computeCR(currentETH, currentLUSDDebt, _price);\n        return ICR;\n    }\n\n    function applyPendingRewards(address _borrower) external override {\n        _requireCallerIsBorrowerOperations();\n        return _applyPendingRewards(_borrower);\n    }\n\n    // Add the borrowers's coll and debt rewards earned from redistributions, to their Trove\n    function _applyPendingRewards(address _borrower) internal {\n        if (hasPendingRewards(_borrower)) {\n            _requireTroveisActive(_borrower);\n\n            // Compute pending rewards\n            uint pendingETHReward = getPendingETHReward(_borrower);\n            uint pendingLUSDDebtReward = getPendingLUSDDebtReward(_borrower);\n\n            // Apply pending rewards to trove's state\n            Troves[_borrower].coll = Troves[_borrower].coll.add(pendingETHReward);\n            Troves[_borrower].debt = Troves[_borrower].debt.add(pendingLUSDDebtReward);\n\n            _updateTroveRewardSnapshots(_borrower);\n\n            // Transfer from DefaultPool to ActivePool\n            _movePendingTroveRewardsToActivePool(pendingLUSDDebtReward, pendingETHReward);\n\n            emit TroveUpdated(\n                _borrower, \n                Troves[_borrower].debt, \n                Troves[_borrower].coll, \n                Troves[_borrower].stake, \n                TroveManagerOperation.applyPendingRewards\n            );\n        }\n    }\n\n    // Update borrower's snapshots of L_ETH and L_LUSDDebt to reflect the current values\n    function updateTroveRewardSnapshots(address _borrower) external override {\n        _requireCallerIsBorrowerOperations();\n       return _updateTroveRewardSnapshots(_borrower);\n    }\n\n    function _updateTroveRewardSnapshots(address _borrower) internal {\n        rewardSnapshots[_borrower].ETH = L_ETH;\n        rewardSnapshots[_borrower].LUSDDebt = L_LUSDDebt;\n    }\n\n    // Get the borrower's pending accumulated ETH reward, earned by their stake\n    function getPendingETHReward(address _borrower) public view override returns (uint) {\n        uint snapshotETH = rewardSnapshots[_borrower].ETH;\n        uint rewardPerUnitStaked = L_ETH.sub(snapshotETH);\n\n        if ( rewardPerUnitStaked == 0 ) { return 0; }\n\n        uint stake = Troves[_borrower].stake;\n\n        uint pendingETHReward = stake.mul(rewardPerUnitStaked).div(1e18);\n\n        return pendingETHReward;\n    }\n\n     // Get the borrower's pending accumulated LUSD reward, earned by their stake\n    function getPendingLUSDDebtReward(address _borrower) public view override returns (uint) {\n        uint snapshotLUSDDebt = rewardSnapshots[_borrower].LUSDDebt;\n        uint rewardPerUnitStaked = L_LUSDDebt.sub(snapshotLUSDDebt);\n\n        if ( rewardPerUnitStaked == 0 ) { return 0; }\n\n        uint stake =  Troves[_borrower].stake;\n\n        uint pendingLUSDDebtReward = stake.mul(rewardPerUnitStaked).div(1e18);\n\n        return pendingLUSDDebtReward;\n    }\n\n    function hasPendingRewards(address _borrower) public view override returns (bool) {\n        /* \n        * A Trove has pending rewards if its snapshot is less than the current rewards per-unit-staked sum:\n        * this indicates that rewards have occured since the snapshot was made, and the user therefore has\n        * pending rewards \n        */\n        return (rewardSnapshots[_borrower].ETH < L_ETH);\n    }\n\n    // Return the Troves entire debt and coll, including pending rewards from redistributions.\n    function getEntireDebtAndColl(\n        address _borrower\n    )\n        public\n        view\n        override\n        returns (uint debt, uint coll, uint pendingLUSDDebtReward, uint pendingETHReward)\n    {\n        debt = Troves[_borrower].debt;\n        coll = Troves[_borrower].coll;\n\n        pendingLUSDDebtReward = getPendingLUSDDebtReward(_borrower);\n        pendingETHReward = getPendingETHReward(_borrower);\n\n        debt = debt.add(pendingLUSDDebtReward);\n        coll = coll.add(pendingETHReward);\n    }\n\n    function removeStake(address _borrower) external override {\n        _requireCallerIsBorrowerOperations();\n        return _removeStake(_borrower);\n    }\n\n    // Remove borrower's stake from the totalStakes sum, and set their stake to 0\n    function _removeStake(address _borrower) internal {\n        uint stake = Troves[_borrower].stake;\n        totalStakes = totalStakes.sub(stake);\n        Troves[_borrower].stake = 0;\n    }\n\n    function updateStakeAndTotalStakes(address _borrower) external override returns (uint) {\n        _requireCallerIsBorrowerOperations();\n        return _updateStakeAndTotalStakes(_borrower);\n    }\n\n    // Update borrower's stake based on their latest collateral value\n    function _updateStakeAndTotalStakes(address _borrower) internal returns (uint) {\n        uint newStake = _computeNewStake(Troves[_borrower].coll);\n        uint oldStake = Troves[_borrower].stake;\n        Troves[_borrower].stake = newStake;\n        totalStakes = totalStakes.sub(oldStake).add(newStake);\n\n        return newStake;\n    }\n\n    // Calculate a new stake based on the snapshots of the totalStakes and totalCollateral taken at the last liquidation\n    function _computeNewStake(uint _coll) internal view returns (uint) {\n        uint stake;\n        if (totalCollateralSnapshot == 0) {\n            stake = _coll;\n        } else {\n            /*  \n            * The following assert() holds true because:\n            * - The system always contains >= 1 trove \n            * - When we close or liquidate a trove, we redistribute the pending rewards, so if all troves were closed/liquidated, \n            * rewards wouldve been emptied and totalCollateralSnapshot would be zero too.\n            */\n            assert(totalStakesSnapshot > 0);\n            stake = _coll.mul(totalStakesSnapshot).div(totalCollateralSnapshot);\n        }\n        return stake;\n    }\n\n    function _redistributeDebtAndColl(uint _debt, uint _coll) internal {\n        if (_debt == 0) { return; }\n\n        if (totalStakes > 0) {\n            /* \n            * Add distributed coll and debt rewards-per-unit-staked to the running totals.\n            * Division uses a \"feedback\" error correction, to keep the cumulative error in\n            * the  L_ETH and L_LUSDDebt state variables low. \n            */\n            uint ETHNumerator = _coll.mul(1e18).add(lastETHError_Redistribution);\n            uint LUSDDebtNumerator = _debt.mul(1e18).add(lastLUSDDebtError_Redistribution);\n\n            uint ETHRewardPerUnitStaked = ETHNumerator.div(totalStakes);\n            uint LUSDDebtRewardPerUnitStaked = LUSDDebtNumerator.div(totalStakes);\n\n            lastETHError_Redistribution = ETHNumerator.sub(ETHRewardPerUnitStaked.mul(totalStakes));\n            lastLUSDDebtError_Redistribution = LUSDDebtNumerator.sub(LUSDDebtRewardPerUnitStaked.mul(totalStakes));\n\n            L_ETH = L_ETH.add(ETHRewardPerUnitStaked);\n            L_LUSDDebt = L_LUSDDebt.add(LUSDDebtRewardPerUnitStaked);\n        }\n\n        // Transfer coll and debt from ActivePool to DefaultPool\n        activePool.decreaseLUSDDebt(_debt);\n        defaultPool.increaseLUSDDebt(_debt);\n        activePool.sendETH(address(defaultPool), _coll);\n    }\n\n    function closeTrove(address _borrower) external override {\n        _requireCallerIsBorrowerOperations();\n        return _closeTrove(_borrower);\n    }\n\n    function _closeTrove(address _borrower) internal {\n        uint TroveOwnersArrayLength = TroveOwners.length;\n        _requireMoreThanOneTroveInSystem(TroveOwnersArrayLength);\n\n        Troves[_borrower].status = Status.closed;\n        Troves[_borrower].coll = 0;\n        Troves[_borrower].debt = 0;\n\n        rewardSnapshots[_borrower].ETH = 0;\n        rewardSnapshots[_borrower].LUSDDebt = 0;\n\n        _removeTroveOwner(_borrower, TroveOwnersArrayLength);\n        sortedTroves.remove(_borrower);\n    }\n\n    /* \n    * Updates snapshots of system total stakes and total collateral, excluding a given collateral remainder from the calculation. \n    * Used in a liquidation sequence.\n    *\n    * The calculation excludes two portions of collateral that are in the ActivePool: \n    *\n    * 1) the total ETH gas compensation from the liquidation sequence\n    * 2) The remaining collateral in a partially liquidated trove (if one occurred)\n    *\n    * The ETH as compensation must be excluded as it is always sent out at the very end of the liquidation sequence.\n    *\n    * The partially liquidated trove's remaining collateral stays in the ActivePool, but it is excluded here so the system \n    * can take snapshots before the partially liquidated trove's stake is updated (based on these snapshots). This ensures\n    * the partial's new stake doesn't double-count its own remaining collateral.\n    *\n    */\n    function _updateSystemSnapshots_excludeCollRemainder(uint _collRemainder) internal {\n        totalStakesSnapshot = totalStakes;\n\n        uint activeColl = activePool.getETH();\n        uint liquidatedColl = defaultPool.getETH();\n        totalCollateralSnapshot = activeColl.sub(_collRemainder).add(liquidatedColl);\n    }\n\n    // Push the owner's address to the Trove owners list, and record the corresponding array index on the Trove struct\n    function addTroveOwnerToArray(address _borrower) external override returns (uint index) {\n        _requireCallerIsBorrowerOperations();\n        return _addTroveOwnerToArray(_borrower);\n    }\n\n    function _addTroveOwnerToArray(address _borrower) internal returns (uint128 index) {\n        require(TroveOwners.length < 2**128 - 1, \"TroveManager: TroveOwners array has maximum size of 2^128 - 1\");\n\n        // Push the Troveowner to the array\n        TroveOwners.push(_borrower);\n\n        // Record the index of the new Troveowner on their Trove struct\n        index = uint128(TroveOwners.length.sub(1));\n        Troves[_borrower].arrayIndex = index;\n\n        return index;\n    }\n\n    /* \n    * Remove a Trove owner from the TroveOwners array, not preserving array order. Removing owner 'B' does the following:\n    * [A B C D E] => [A E C D], and updates E's Trove struct to point to its new array index. \n    */\n    function _removeTroveOwner(address _borrower, uint TroveOwnersArrayLength) internal {\n        require(Troves[_borrower].status == Status.closed, \"TroveManager: Trove is still active\");\n\n        uint128 index = Troves[_borrower].arrayIndex;\n        uint length = TroveOwnersArrayLength;\n        uint idxLast = length.sub(1);\n\n        assert(index <= idxLast);\n\n        address addressToMove = TroveOwners[idxLast];\n\n        TroveOwners[index] = addressToMove;\n        Troves[addressToMove].arrayIndex = index;\n        TroveOwners.pop();\n    }\n\n    // --- Recovery Mode and TCR functions ---\n\n    function checkRecoveryMode() public view override returns (bool) {\n        uint TCR = getTCR();\n\n        if (TCR < CCR) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    // Check whether or not the system *would be* in Recovery Mode, given an ETH:USD price, and the entire system coll and debt.\n    function _checkPotentialRecoveryMode(\n        uint _entireSystemColl,\n        uint _entireSystemDebt,\n        uint _price\n    )\n        internal\n        pure\n    returns (bool)\n    {\n        uint TCR = LiquityMath._computeCR(_entireSystemColl, _entireSystemDebt, _price);\n        if (TCR < CCR) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n    // SWC-135-Code With No Effects: L1276-L1284\n    function getTCR() public view override returns (uint TCR) {\n        uint price = priceFeed.getPrice();\n        uint entireSystemColl = getEntireSystemColl();\n        uint entireSystemDebt = getEntireSystemDebt();\n\n        TCR = LiquityMath._computeCR(entireSystemColl, entireSystemDebt, price);\n\n        return TCR;\n    }\n    // SWC-135-Code With No Effects: L1286-L1291\n    function getEntireSystemColl() public view override returns (uint entireSystemColl) {\n        uint activeColl = activePool.getETH();\n        uint liquidatedColl = defaultPool.getETH();\n\n        return activeColl.add(liquidatedColl);\n    }\n\n    function getEntireSystemDebt() public view override returns (uint entireSystemDebt) {\n        uint activeDebt = activePool.getLUSDDebt();\n        uint closedDebt = defaultPool.getLUSDDebt();\n\n        return activeDebt.add(closedDebt);\n    }\n\n    // --- Redemption fee functions ---\n\n    /* \n    * This function has two impacts on the baseRate state variable:\n    * 1) decays the baseRate based on time passed since last redemption or LUSD borrowing operation.\n    * then,\n    * 2) increases the baseRate based on the amount redeemed, as a proportion of total supply\n    */\n    function _updateBaseRateFromRedemption(uint _ETHDrawn,  uint _price) internal returns (uint) {\n        uint decayedBaseRate = _calcDecayedBaseRate();\n\n        uint activeDebt = activePool.getLUSDDebt();\n        uint closedDebt = defaultPool.getLUSDDebt();\n        uint totalLUSDSupply = activeDebt.add(closedDebt);\n\n        /* Convert the drawn ETH back to LUSD at face value rate (1 LUSD:1 USD), in order to get\n        * the fraction of total supply that was redeemed at face value. */\n        uint redeemedLUSDFraction = _ETHDrawn.mul(_price).div(totalLUSDSupply);\n\n        uint newBaseRate = decayedBaseRate.add(redeemedLUSDFraction.div(BETA));\n\n        // Update the baseRate state variable\n        baseRate = newBaseRate < 1e18 ? newBaseRate : 1e18;  // cap baseRate at a maximum of 100%\n        assert(baseRate <= 1e18 && baseRate > 0); // Base rate is always non-zero after redemption\n\n        _updateLastFeeOpTime();\n\n        return baseRate;\n    }\n\n    function _getRedemptionFee(uint _ETHDrawn) internal view returns (uint) {\n       return baseRate.mul(_ETHDrawn).div(1e18);\n    }\n\n    // --- Borrowing fee functions ---\n\n    function getBorrowingFee(uint _LUSDDebt) external view override returns (uint) {\n        return _LUSDDebt.mul(baseRate).div(1e18);\n    }\n\n    // Updates the baseRate state variable based on time elapsed since the last redemption or LUSD borrowing operation.\n    function decayBaseRateFromBorrowing() external override {\n        _requireCallerIsBorrowerOperations();\n\n        baseRate = _calcDecayedBaseRate();\n        assert(baseRate <= 1e18);  // The baseRate can decay to 0\n\n        _updateLastFeeOpTime();\n    }\n\n    // --- Internal fee functions ---\n\n    // Update the last fee operation time only if time passed >= decay interval. This prevents base rate griefing.\n    function _updateLastFeeOpTime() internal {\n        uint timePassed = block.timestamp.sub(lastFeeOperationTime);\n\n        if (timePassed >= SECONDS_IN_ONE_MINUTE) {\n            lastFeeOperationTime = block.timestamp;\n        }\n    }\n\n    function _calcDecayedBaseRate() internal view returns (uint) {\n        uint minutesPassed = _minutesPassedSinceLastFeeOp();\n        uint decayFactor = LiquityMath._decPow(MINUTE_DECAY_FACTOR, minutesPassed);\n\n        return baseRate.mul(decayFactor).div(1e18);\n    }\n\n    function _minutesPassedSinceLastFeeOp() internal view returns (uint) {\n        return (block.timestamp.sub(lastFeeOperationTime)).div(SECONDS_IN_ONE_MINUTE);\n    }\n\n    // --- 'require' wrapper functions ---\n\n    function _requireCallerIsBorrowerOperations() internal view {\n        require(msg.sender == borrowerOperationsAddress, \"TroveManager: Caller is not the BorrowerOperations contract\");\n    }\n\n    function _requireTroveisActive(address _borrower) internal view {\n        require(Troves[_borrower].status == Status.active, \"TroveManager: Trove does not exist or is closed\");\n    }\n\n    function _requireLUSDBalanceCoversRedemption(address _redeemer, uint _amount) internal view {\n        require(lusdToken.balanceOf(_redeemer) >= _amount, \"TroveManager: Requested redemption amount must be <= user's LUSD token balance\");\n    }\n\n    function _requireMoreThanOneTroveInSystem(uint TroveOwnersArrayLength) internal view {\n        require (TroveOwnersArrayLength > 1 && sortedTroves.getSize() > 1, \"TroveManager: Only one trove in the system\");\n    }\n\n    function _requireAmountGreaterThanZero(uint _amount) internal pure {\n        require(_amount > 0, \"TroveManager: Amount must be greater than zero\");\n    }\n\n    // --- Trove property getters ---\n\n    function getTroveStatus(address _borrower) external view override returns (uint) {\n        return uint(Troves[_borrower].status);\n    }\n\n    function getTroveStake(address _borrower) external view override returns (uint) {\n        return Troves[_borrower].stake;\n    }\n\n    function getTroveDebt(address _borrower) external view override returns (uint) {\n        return Troves[_borrower].debt;\n    }\n\n    function getTroveColl(address _borrower) external view override returns (uint) {\n        return Troves[_borrower].coll;\n    }\n\n    // --- Trove property setters, called by BorrowerOperations ---\n\n    function setTroveStatus(address _borrower, uint _num) external override {\n        _requireCallerIsBorrowerOperations();\n        Troves[_borrower].status = Status(_num);\n    }\n\n    function increaseTroveColl(address _borrower, uint _collIncrease) external override returns (uint) {\n        _requireCallerIsBorrowerOperations();\n        uint newColl = Troves[_borrower].coll.add(_collIncrease);\n        Troves[_borrower].coll = newColl;\n        return newColl;\n    }\n\n    function decreaseTroveColl(address _borrower, uint _collDecrease) external override returns (uint) {\n        _requireCallerIsBorrowerOperations();\n        uint newColl = Troves[_borrower].coll.sub(_collDecrease);\n        Troves[_borrower].coll = newColl;\n        return newColl;\n    }\n\n    function increaseTroveDebt(address _borrower, uint _debtIncrease) external override returns (uint) {\n        _requireCallerIsBorrowerOperations();\n        uint newDebt = Troves[_borrower].debt.add(_debtIncrease);\n        Troves[_borrower].debt = newDebt;\n        return newDebt;\n    }\n\n    function decreaseTroveDebt(address _borrower, uint _debtDecrease) external override returns (uint) {\n        _requireCallerIsBorrowerOperations();\n        uint newDebt = Troves[_borrower].debt.sub(_debtDecrease);\n        Troves[_borrower].debt = newDebt;\n        return newDebt;\n    }\n}",
        "function": "getEntireSystemColl()",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-Liquity/dev-f0df3efa5a5f05b205752184cfce107c5bd6e06c/packages/contracts/contracts/TroveManager.sol",
        "vulnerability": "Multiple Calls in a Single Transaction (SWC 113)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract TroveManager is LiquityBase, Ownable, ITroveManager {\n\n    // --- Connected contract declarations ---\n\n    address public borrowerOperationsAddress;\n\n    IPool public activePool;\n\n    IPool public defaultPool;\n\n    IStabilityPool public stabilityPool;\n\n    ICollSurplusPool collSurplusPool;\n\n    ILUSDToken public lusdToken;\n\n    IPriceFeed public priceFeed;\n\n    ILQTYStaking public lqtyStaking;\n    address public lqtyStakingAddress;\n\n    // A doubly linked list of Troves, sorted by their sorted by their collateral ratios\n    ISortedTroves public sortedTroves;\n\n    // --- Data structures ---\n\n    uint constant public SECONDS_IN_ONE_MINUTE = 60;\n    uint constant public MINUTE_DECAY_FACTOR = 999832508430720967;  // 18 digit decimal. Corresponds to an hourly decay factor of 0.99\n\n    /* \n    * BETA: 18 digit decimal. Parameter by which to divide the redeemed fraction, in order to calc the new base rate from a redemption. \n    * Corresponds to (1 / ALPHA) in the white paper. \n    */\n    uint constant public BETA = 2;\n\n    uint public baseRate;\n\n    // The timestamp of the latest fee operation (redemption or new LUSD issuance) \n    uint public lastFeeOperationTime;\n\n    enum Status { nonExistent, active, closed }\n\n    // Store the necessary data for a trove\n    struct Trove {\n        uint debt;\n        uint coll;\n        uint stake;\n        Status status;\n        uint128 arrayIndex;\n    }\n\n    mapping (address => Trove) public Troves;\n\n    uint public totalStakes;\n\n    // Snapshot of the value of totalStakes, taken immediately after the latest liquidation\n    uint public totalStakesSnapshot;\n\n    // Snapshot of the total collateral across the ActivePool and DefaultPool, immediately after the latest liquidation.\n    uint public totalCollateralSnapshot;\n\n    /*\n    * L_ETH and L_LUSDDebt track the sums of accumulated liquidation rewards per unit staked. During its lifetime, each stake earns:\n    *\n    * An ETH gain of ( stake * [L_ETH - L_ETH(0)] )\n    * A LUSDDebt increase  of ( stake * [L_LUSDDebt - L_LUSDDebt(0)] )\n    *\n    * Where L_ETH(0) and L_LUSDDebt(0) are snapshots of L_ETH and L_LUSDDebt for the active Trove taken at the instant the stake was made\n    */\n    uint public L_ETH;\n    uint public L_LUSDDebt;\n\n    // Map addresses with active troves to their RewardSnapshot\n    mapping (address => RewardSnapshot) public rewardSnapshots;\n\n    // Object containing the ETH and LUSD snapshots for a given active trove\n    struct RewardSnapshot { uint ETH; uint LUSDDebt;}\n\n    // Array of all active trove addresses - used to to compute an approximate hint off-chain, for the sorted list insertion\n    address[] public TroveOwners;\n\n    // Error trackers for the trove redistribution calculation\n    uint public lastETHError_Redistribution;\n    uint public lastLUSDDebtError_Redistribution;\n\n    /* \n    * --- Variable container structs for liquidations ---\n    *\n    * These structs are used to hold, return and assign variables inside the liquidation functions,\n    * in order to avoid the error: \"CompilerError: Stack too deep\". \n    **/\n\n    struct LocalVariables_OuterLiquidationFunction {\n        uint price;\n        uint LUSDInStabPool;\n        bool recoveryModeAtStart;\n        uint liquidatedDebt;\n        uint liquidatedColl;\n    }\n\n    struct LocalVariables_InnerSingleLiquidateFunction {\n        uint collToLiquidate;\n        uint pendingDebtReward;\n        uint pendingCollReward;\n    }\n\n    struct LocalVariables_LiquidationSequence {\n        uint remainingLUSDInStabPool;\n        uint i;\n        uint ICR;\n        address user;\n        bool backToNormalMode;\n        uint entireSystemDebt;\n        uint entireSystemColl;\n    }\n\n    struct LiquidationValues {\n        uint entireTroveDebt;\n        uint entireTroveColl;\n        uint collGasCompensation;\n        uint LUSDGasCompensation;\n        uint debtToOffset;\n        uint collToSendToSP;\n        uint debtToRedistribute;\n        uint collToRedistribute;\n        address partialAddr;\n        uint partialNewDebt;\n        uint partialNewColl;\n        address partialUpperHint;\n        address partialLowerHint;\n    }\n\n    struct LiquidationTotals {\n        uint totalCollInSequence;\n        uint totalDebtInSequence;\n        uint totalCollGasCompensation;\n        uint totalLUSDGasCompensation;\n        uint totalDebtToOffset;\n        uint totalCollToSendToSP;\n        uint totalDebtToRedistribute;\n        uint totalCollToRedistribute;\n        address partialAddr;\n        uint partialNewDebt;\n        uint partialNewColl;\n        address partialUpperHint;\n        address partialLowerHint;\n    }\n\n    // --- Variable container structs for redemptions ---\n\n    struct RedemptionTotals {\n        uint totalLUSDToRedeem;\n        uint totalETHDrawn;\n        uint ETHFee;\n        uint ETHToSendToRedeemer;\n        uint decayedBaseRate;\n    }\n\n    struct SingleRedemptionValues {\n        uint LUSDLot;\n        uint ETHLot;\n    }\n\n    // --- Events ---\n\n    event Liquidation(uint _liquidatedDebt, uint _liquidatedColl, uint _collGasCompensation, uint _LUSDGasCompensation);\n    event Redemption(uint _attemptedLUSDAmount, uint _actualLUSDAmount, uint _ETHSent, uint _ETHFee);\n\n    enum TroveManagerOperation {\n        applyPendingRewards,\n        liquidateInNormalMode,\n        liquidateInRecoveryMode,\n        partiallyLiquidateInRecoveryMode,\n        redeemCollateral\n    }\n\n    event TroveCreated(address indexed _borrower, uint _arrayIndex);\n    event TroveUpdated(address indexed _borrower, uint _debt, uint _coll, uint _stake, TroveManagerOperation _operation);\n    event TroveLiquidated(address indexed _borrower, uint _debt, uint _coll, TroveManagerOperation _operation);\n\n    // --- Dependency setter ---\n\n    function setAddresses(\n        address _borrowerOperationsAddress,\n        address _activePoolAddress,\n        address _defaultPoolAddress,\n        address _stabilityPoolAddress,\n        address _collSurplusPoolAddress,\n        address _priceFeedAddress,\n        address _lusdTokenAddress,\n        address _sortedTrovesAddress,\n        address _lqtyStakingAddress\n    )\n        external\n        override\n        onlyOwner\n    {\n        borrowerOperationsAddress = _borrowerOperationsAddress;\n        activePool = IPool(_activePoolAddress);\n        defaultPool = IPool(_defaultPoolAddress);\n        stabilityPool = IStabilityPool(_stabilityPoolAddress);\n        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);\n        priceFeed = IPriceFeed(_priceFeedAddress);\n        lusdToken = ILUSDToken(_lusdTokenAddress);\n        sortedTroves = ISortedTroves(_sortedTrovesAddress);\n        lqtyStakingAddress = _lqtyStakingAddress;\n        lqtyStaking = ILQTYStaking(_lqtyStakingAddress);\n\n        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);\n        emit ActivePoolAddressChanged(_activePoolAddress);\n        emit DefaultPoolAddressChanged(_defaultPoolAddress);\n        emit StabilityPoolAddressChanged(_stabilityPoolAddress);\n        emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);\n        emit PriceFeedAddressChanged(_priceFeedAddress);\n        emit LUSDTokenAddressChanged(_lusdTokenAddress);\n        emit SortedTrovesAddressChanged(_sortedTrovesAddress);\n        emit LQTYStakingAddressChanged(_lqtyStakingAddress);\n\n        _renounceOwnership();\n    }\n\n    // --- Getters ---\n\n    function getTroveOwnersCount() external view override returns (uint) {\n        return TroveOwners.length;\n    }\n\n    function getTroveFromTroveOwnersArray(uint _index) external view override returns (address) {\n        return TroveOwners[_index];\n    }\n\n    // --- Trove Liquidation functions ---\n\n    // Single liquidation function. Closes the trove if its ICR is lower than the minimum collateral ratio. \n    function liquidate(address _borrower) external override {\n        _requireTroveisActive(_borrower);\n\n        address[] memory borrowers = new address[](1);\n        borrowers[0] = _borrower;\n        batchLiquidateTroves(borrowers);\n    }\n\n    // --- Inner single liquidation functions ---\n\n    // Liquidate one trove, in Normal Mode.\n    function _liquidateNormalMode(address _borrower, uint _LUSDInStabPool) internal returns (LiquidationValues memory V) {\n        LocalVariables_InnerSingleLiquidateFunction memory L;\n\n        (V.entireTroveDebt,\n        V.entireTroveColl,\n        L.pendingDebtReward,\n        L.pendingCollReward) = getEntireDebtAndColl(_borrower);\n\n        _movePendingTroveRewardsToActivePool(L.pendingDebtReward, L.pendingCollReward);\n        _removeStake(_borrower);\n\n        V.collGasCompensation = _getCollGasCompensation(V.entireTroveColl);\n        V.LUSDGasCompensation = LUSD_GAS_COMPENSATION;\n        uint collToLiquidate = V.entireTroveColl.sub(V.collGasCompensation);\n\n        (V.debtToOffset,\n        V.collToSendToSP,\n        V.debtToRedistribute,\n        V.collToRedistribute) = _getOffsetAndRedistributionVals(V.entireTroveDebt, collToLiquidate, _LUSDInStabPool);\n\n        _closeTrove(_borrower);\n        emit TroveLiquidated(_borrower, V.entireTroveDebt, V.entireTroveColl, TroveManagerOperation.liquidateInNormalMode);\n\n        return V;\n    }\n\n    // Liquidate one trove, in Recovery Mode.\n    function _liquidateRecoveryMode(address _borrower, uint _ICR, uint _LUSDInStabPool, uint _TCR) internal returns (LiquidationValues memory V) {\n        LocalVariables_InnerSingleLiquidateFunction memory L;\n        \n        if (TroveOwners.length <= 1) { return V; } // don't liquidate if last trove\n\n        (V.entireTroveDebt,\n        V.entireTroveColl,\n        L.pendingDebtReward,\n        L.pendingCollReward) = getEntireDebtAndColl(_borrower);\n\n        _movePendingTroveRewardsToActivePool(L.pendingDebtReward, L.pendingCollReward);\n\n        V.collGasCompensation = _getCollGasCompensation(V.entireTroveColl);\n        // In case of a partial liquidation, V.LUSDGasCompensation will be overwritten to zero, in the third branch below\n        V.LUSDGasCompensation = LUSD_GAS_COMPENSATION;\n        L.collToLiquidate = V.entireTroveColl.sub(V.collGasCompensation);\n\n        // If ICR <= 100%, purely redistribute the Trove across all active Troves\n        if (_ICR <= _100pct) {\n            _removeStake(_borrower);\n\n            V.debtToOffset = 0;\n            V.collToSendToSP = 0;\n            V.debtToRedistribute = V.entireTroveDebt;\n            V.collToRedistribute = L.collToLiquidate;\n\n            _closeTrove(_borrower);\n            emit TroveLiquidated(_borrower, V.entireTroveDebt, V.entireTroveColl, TroveManagerOperation.liquidateInRecoveryMode);\n\n        // If 100% < ICR < MCR, offset as much as possible, and redistribute the remainder\n        } else if ((_ICR > _100pct) && (_ICR < MCR)) {\n            _removeStake(_borrower);\n\n            (V.debtToOffset,\n            V.collToSendToSP,\n            V.debtToRedistribute,\n            V.collToRedistribute) = _getOffsetAndRedistributionVals(V.entireTroveDebt, L.collToLiquidate, _LUSDInStabPool);\n\n            _closeTrove(_borrower);\n            emit TroveLiquidated(_borrower, V.entireTroveDebt, V.entireTroveColl, TroveManagerOperation.liquidateInRecoveryMode);\n\n        /* \n        * If 110% <= ICR < current TCR (accounting for the preceding liquidations in the current sequence)\n        * and there is LUSD in the Stability Pool, only offset it as much as possible, with no redistribution.\n        */\n        } else if ((_ICR >= MCR) && (_ICR < _TCR)) {\n            assert(_LUSDInStabPool != 0);\n\n            _removeStake(_borrower);\n            \n            V = _getFullOrPartialOffsetVals(_borrower, V.entireTroveDebt, V.entireTroveColl, _LUSDInStabPool);\n\n            _closeTrove(_borrower);\n        }\n        else if (_ICR >= _TCR) {\n            LiquidationValues memory zeroVals;\n            return zeroVals;\n        }\n\n        return V;\n    }\n\n    /* In a full liquidation, returns the values for a trove's coll and debt to be offset, and coll and debt to be \n    * redistributed to active troves. \n    */\n    function _getOffsetAndRedistributionVals\n    (\n        uint _debt,\n        uint _coll,\n        uint _LUSDInStabPool\n    )\n        internal\n        pure\n        returns (uint debtToOffset, uint collToSendToSP, uint debtToRedistribute, uint collToRedistribute)\n    {\n        if (_LUSDInStabPool > 0) {\n        /* \n        * Offset as much debt & collateral as possible against the Stability Pool, and redistribute the remainder\n        * between all active troves.\n        *\n        *  If the trove's debt is larger than the deposited LUSD in the Stability Pool:\n        *\n        *  - Offset an amount of the trove's debt equal to the LUSD in the Stability Pool\n        *  - Send a fraction of the trove's collateral to the Stability Pool, equal to the fraction of its offset debt\n        *\n        */\n            debtToOffset = LiquityMath._min(_debt, _LUSDInStabPool);\n            collToSendToSP = _coll.mul(debtToOffset).div(_debt);\n            debtToRedistribute = _debt.sub(debtToOffset);\n            collToRedistribute = _coll.sub(collToSendToSP);\n        } else {\n            debtToOffset = 0;\n            collToSendToSP = 0;\n            debtToRedistribute = _debt;\n            collToRedistribute = _coll;\n        }\n    }\n\n    /*\n    *  If it is a full offset, get its offset coll/debt and ETH gas comp, and close the trove.\n    *\n    * If it is a partial liquidation, get its offset coll/debt and ETH gas comp, and its new coll/debt, and its re-insertion hints.\n    */\n    function _getFullOrPartialOffsetVals\n    (\n        address _borrower,\n        uint _entireTroveDebt,\n        uint _entireTroveColl,\n        uint _LUSDInStabPool\n    )\n        internal\n        returns (LiquidationValues memory V)\n    {\n        V.entireTroveDebt = _entireTroveDebt;\n        V.entireTroveColl = _entireTroveColl;\n\n        // When Stability Pool can fully absorb the trove's debt, perform a full offset\n        if (_entireTroveDebt <= _LUSDInStabPool) {\n            V.collGasCompensation = _getCollGasCompensation(_entireTroveColl);\n            V.LUSDGasCompensation = LUSD_GAS_COMPENSATION;\n\n            V.debtToOffset = _entireTroveDebt;\n            V.collToSendToSP = _entireTroveColl.sub(V.collGasCompensation);\n            V.debtToRedistribute = 0;\n            V.collToRedistribute = 0;\n\n            emit TroveLiquidated(_borrower, _entireTroveDebt, _entireTroveColl, TroveManagerOperation.liquidateInRecoveryMode);\n        }\n        /* \n        * When trove's debt is greater than the Stability Pool, perform a partial liquidation: offset as much as possible,\n        * and do not redistribute the remainder. The trove remains active, with a reduced collateral and debt.\n        *\n        * ETH gas compensation is based on and drawn from the collateral fraction that corresponds to the partial offset. \n        * LUSD gas compensation is left untouched. \n        *\n        * Since ETH gas comp is drawn purely from the *liquidated* portion, the trove is left with the same ICR as before the \n        * liquidation.\n        */\n        else if (_entireTroveDebt > _LUSDInStabPool) {\n            // Remaining debt in the trove is lower-bounded by the trove's gas compensation\n            V.partialNewDebt = LiquityMath._max(_entireTroveDebt.sub(_LUSDInStabPool), LUSD_GAS_COMPENSATION);\n          \n            V.debtToOffset = _entireTroveDebt.sub(V.partialNewDebt);\n\n            uint collFraction = _entireTroveColl.mul(V.debtToOffset).div(_entireTroveDebt);\n            V.collGasCompensation = _getCollGasCompensation(collFraction);\n          \n            V.LUSDGasCompensation = 0;  // LUSD gas compensation remains untouched\n\n            V.collToSendToSP = collFraction.sub(V.collGasCompensation);\n            V.collToRedistribute = 0;\n            V.debtToRedistribute = 0;\n\n            V.partialAddr = _borrower;\n            V.partialNewColl = _entireTroveColl.sub(collFraction);\n\n            // Get the partial trove's neighbours, so we can re-insert it later to the same position\n            V.partialUpperHint = sortedTroves.getPrev(_borrower);  \n            V.partialLowerHint = sortedTroves.getNext(_borrower);\n        }\n    }\n\n    /* \n    * Liquidate a sequence of troves. Closes a maximum number of n under-collateralized Troves,\n    * starting from the one with the lowest collateral ratio in the system, and moving upwards\n    */\n    function liquidateTroves(uint _n) external override {\n        LocalVariables_OuterLiquidationFunction memory L;\n\n        LiquidationTotals memory T;\n\n        L.price = priceFeed.getPrice();\n        L.LUSDInStabPool = stabilityPool.getTotalLUSDDeposits();\n        L.recoveryModeAtStart = checkRecoveryMode();\n\n        // Perform the appropriate liquidation sequence - tally the values, and obtain their totals\n        if (L.recoveryModeAtStart == true) {\n            T = _getTotalsFromLiquidateTrovesSequence_RecoveryMode(L.price, L.LUSDInStabPool, _n);\n        } else if (L.recoveryModeAtStart == false) {\n            T = _getTotalsFromLiquidateTrovesSequence_NormalMode(L.price, L.LUSDInStabPool, _n);\n        }\n\n        // Move liquidated ETH and LUSD to the appropriate pools\n        stabilityPool.offset(T.totalDebtToOffset, T.totalCollToSendToSP);\n        _redistributeDebtAndColl(T.totalDebtToRedistribute, T.totalCollToRedistribute);\n\n        // Update system snapshots and the final partially liquidated trove, if there is one\n        _updateSystemSnapshots_excludeCollRemainder(T.partialNewColl.add(T.totalCollGasCompensation));\n        _updatePartiallyLiquidatedTrove(T.partialAddr, T.partialNewDebt, T.partialNewColl, T.partialUpperHint, T. partialLowerHint, L.price);\n\n        L.liquidatedDebt = T.totalDebtInSequence.sub(T.partialNewDebt);\n        L.liquidatedColl = T.totalCollInSequence.sub(T.totalCollGasCompensation).sub(T.partialNewColl);\n        emit Liquidation(L.liquidatedDebt, L.liquidatedColl, T.totalCollGasCompensation, T.totalLUSDGasCompensation);\n\n        // Send gas compensation to caller\n        _sendGasCompensation(msg.sender, T.totalLUSDGasCompensation, T.totalCollGasCompensation);\n    }\n\n    /*\n    * This function is used when the liquidateTroves sequence starts during Recovery Mode. However, it\n    * handle the case where the system *leaves* Recovery Mode, part way through the liquidation sequence\n    */\n    function _getTotalsFromLiquidateTrovesSequence_RecoveryMode\n    (\n        uint _price,\n        uint _LUSDInStabPool,\n        uint _n\n    )\n        internal\n        returns(LiquidationTotals memory T)\n    {\n        LocalVariables_LiquidationSequence memory L;\n        LiquidationValues memory V;\n\n        L.remainingLUSDInStabPool = _LUSDInStabPool;\n        L.backToNormalMode = false;\n        L.entireSystemDebt = activePool.getLUSDDebt().add(defaultPool.getLUSDDebt());\n        L.entireSystemColl = activePool.getETH().add(defaultPool.getETH());\n\n        L.i = 0;\n        while (L.i < _n) {\n            L.user = sortedTroves.getLast();\n            L.ICR = getCurrentICR(L.user, _price);\n\n            if (L.backToNormalMode == false) {\n                // Break the loop if ICR is greater than MCR and Stability Pool is empty\n                if (L.ICR >= MCR && L.remainingLUSDInStabPool == 0) { break; }\n\n                uint TCR = LiquityMath._computeCR(L.entireSystemColl, L.entireSystemDebt, _price);\n        \n                V = _liquidateRecoveryMode(L.user, L.ICR, L.remainingLUSDInStabPool, TCR);\n\n                // Update aggregate trackers\n                L.remainingLUSDInStabPool = L.remainingLUSDInStabPool.sub(V.debtToOffset);\n                L.entireSystemDebt = L.entireSystemDebt.sub(V.debtToOffset);\n                L.entireSystemColl = L.entireSystemColl.sub(V.collToSendToSP);\n\n                // Add liquidation values to their respective running totals\n                T = _addLiquidationValuesToTotals(T, V);\n\n                // Break the loop if it was a partial liquidation\n                if (V.partialAddr != address(0)) {break;}\n\n                L.backToNormalMode = !_checkPotentialRecoveryMode(L.entireSystemColl, L.entireSystemDebt, _price);\n            }\n            else if (L.backToNormalMode == true && L.ICR < MCR) {\n                V = _liquidateNormalMode(L.user, L.remainingLUSDInStabPool);\n\n                L.remainingLUSDInStabPool = L.remainingLUSDInStabPool.sub(V.debtToOffset);\n\n                // Add liquidation values to their respective running totals\n                T = _addLiquidationValuesToTotals(T, V);\n\n            }  else break;  // break if the loop reaches a Trove with ICR >= MCR\n\n            // Break the loop if it reaches the first Trove in the sorted list\n            if (L.user == sortedTroves.getFirst()) { break; }\n\n            L.i++;\n        }\n    }\n\n    function _getTotalsFromLiquidateTrovesSequence_NormalMode\n    (\n        uint _price,\n        uint _LUSDInStabPool,\n        uint _n\n    )\n        internal\n        returns(LiquidationTotals memory T)\n    {\n        LocalVariables_LiquidationSequence memory L;\n        LiquidationValues memory V;\n\n        L.remainingLUSDInStabPool = _LUSDInStabPool;\n\n        L.i = 0;\n        while (L.i < _n) {\n            L.user = sortedTroves.getLast();\n            L.ICR = getCurrentICR(L.user, _price);\n\n            if (L.ICR < MCR) {\n                V = _liquidateNormalMode(L.user, L.remainingLUSDInStabPool);\n\n                L.remainingLUSDInStabPool = L.remainingLUSDInStabPool.sub(V.debtToOffset);\n\n                // Add liquidation values to their respective running totals\n                T = _addLiquidationValuesToTotals(T, V);\n\n            } else break;  // break if the loop reaches a Trove with ICR >= MCR\n\n            // Break the loop if it reaches the first Trove in the sorted list\n            if (L.user == sortedTroves.getFirst()) { break; }\n            L.i++;\n        }\n    }\n\n    /* \n    * Attempt to liquidate a custom list of troves provided by the caller. The liquidation sequence stops if\n    * a partial liquidation is performed, so it's up to the caller to order the troves in the _troveArray parameter.\n    */\n    function batchLiquidateTroves(address[] memory _troveArray) public override {\n        require(_troveArray.length != 0, \"TroveManager: Calldata address array must not be empty\");\n\n        LocalVariables_OuterLiquidationFunction memory L;\n        LiquidationTotals memory T;\n\n        L.price = priceFeed.getPrice();\n        L.LUSDInStabPool = stabilityPool.getTotalLUSDDeposits();\n        L.recoveryModeAtStart = checkRecoveryMode();\n\n        // Perform the appropriate liquidation sequence - tally values and obtain their totals.\n        if (L.recoveryModeAtStart == true) {\n           T = _getTotalFromBatchLiquidate_RecoveryMode(L.price, L.LUSDInStabPool, _troveArray);\n        } else if (L.recoveryModeAtStart == false) {\n            T = _getTotalsFromBatchLiquidate_NormalMode(L.price, L.LUSDInStabPool, _troveArray);\n        }\n\n        // Move liquidated ETH and LUSD to the appropriate pools\n        stabilityPool.offset(T.totalDebtToOffset, T.totalCollToSendToSP);\n        _redistributeDebtAndColl(T.totalDebtToRedistribute, T.totalCollToRedistribute);\n\n        // Update system snapshots and the final partially liquidated trove, if there is one\n        _updateSystemSnapshots_excludeCollRemainder(T.partialNewColl.add(T.totalCollGasCompensation));\n        _updatePartiallyLiquidatedTrove(T.partialAddr, T.partialNewDebt, T.partialNewColl, T.partialUpperHint, T. partialLowerHint, L.price);\n\n        L.liquidatedDebt = T.totalDebtInSequence.sub(T.partialNewDebt);\n        L.liquidatedColl = T.totalCollInSequence.sub(T.totalCollGasCompensation).sub(T.partialNewColl);\n        emit Liquidation(L.liquidatedDebt, L.liquidatedColl, T.totalCollGasCompensation, T.totalLUSDGasCompensation);\n\n        // Send gas compensation to caller\n        _sendGasCompensation(msg.sender, T.totalLUSDGasCompensation, T.totalCollGasCompensation);\n    }\n\n    /* \n    * This function is used when the batch liquidation sequence starts during Recovery Mode. However, it\n    * handle the case where the system *leaves* Recovery Mode, part way through the liquidation sequence\n    */\n    function _getTotalFromBatchLiquidate_RecoveryMode\n    (\n        uint _price,\n        uint _LUSDInStabPool,\n        address[] memory _troveArray)\n        internal\n        returns(LiquidationTotals memory T)\n    {\n        LocalVariables_LiquidationSequence memory L;\n        LiquidationValues memory V;\n\n        L.remainingLUSDInStabPool = _LUSDInStabPool;\n        L.backToNormalMode = false;\n        L.entireSystemDebt = activePool.getLUSDDebt().add(defaultPool.getLUSDDebt());\n        L.entireSystemColl = activePool.getETH().add(defaultPool.getETH());\n\n        L.i = 0;\n        for (L.i = 0; L.i < _troveArray.length; L.i++) {\n            L.user = _troveArray[L.i];\n            L.ICR = getCurrentICR(L.user, _price);\n\n            if (L.backToNormalMode == false) {\n\n                // Skip this trove if ICR is greater than MCR and Stability Pool is empty\n                if (L.ICR >= MCR && L.remainingLUSDInStabPool == 0) { continue; }\n\n                uint TCR = LiquityMath._computeCR(L.entireSystemColl, L.entireSystemDebt, _price);\n\n                V = _liquidateRecoveryMode(L.user, L.ICR, L.remainingLUSDInStabPool, TCR);\n\n                // Update aggregate trackers\n                L.remainingLUSDInStabPool = L.remainingLUSDInStabPool.sub(V.debtToOffset);\n                L.entireSystemDebt = L.entireSystemDebt.sub(V.debtToOffset);\n                L.entireSystemColl = L.entireSystemColl.sub(V.collToSendToSP);\n\n                // Add liquidation values to their respective running totals\n                T = _addLiquidationValuesToTotals(T, V);\n\n                // Break the loop if it was a partial liquidation\n                if (V.partialAddr != address(0)) { break; }\n\n                L.backToNormalMode = !_checkPotentialRecoveryMode(L.entireSystemColl, L.entireSystemDebt, _price);\n            }\n\n            else if (L.backToNormalMode == true && L.ICR < MCR) {\n                V = _liquidateNormalMode(L.user, L.remainingLUSDInStabPool);\n                L.remainingLUSDInStabPool = L.remainingLUSDInStabPool.sub(V.debtToOffset);\n\n                // Add liquidation values to their respective running totals\n                T = _addLiquidationValuesToTotals(T, V);\n            }\n        }\n    }\n\n    function _getTotalsFromBatchLiquidate_NormalMode\n    (\n        uint _price,\n        uint _LUSDInStabPool,\n        address[] memory _troveArray\n    )\n        internal\n        returns(LiquidationTotals memory T)\n    {\n        LocalVariables_LiquidationSequence memory L;\n        LiquidationValues memory V;\n\n        L.remainingLUSDInStabPool = _LUSDInStabPool;\n\n        for (L.i = 0; L.i < _troveArray.length; L.i++) {\n            L.user = _troveArray[L.i];\n            L.ICR = getCurrentICR(L.user, _price);\n\n            if (L.ICR < MCR) {\n                V = _liquidateNormalMode(L.user, L.remainingLUSDInStabPool);\n                L.remainingLUSDInStabPool = L.remainingLUSDInStabPool.sub(V.debtToOffset);\n\n                // Add liquidation values to their respective running totals\n                T = _addLiquidationValuesToTotals(T, V);\n            }\n        }\n    }\n\n    // --- Liquidation helper functions ---\n\n    function _addLiquidationValuesToTotals(LiquidationTotals memory T1, LiquidationValues memory V)\n    internal pure returns(LiquidationTotals memory T2) {\n\n        // Tally all the values with their respective running totals\n        T2.totalCollGasCompensation = T1.totalCollGasCompensation.add(V.collGasCompensation);\n        T2.totalLUSDGasCompensation = T1.totalLUSDGasCompensation.add(V.LUSDGasCompensation);\n        T2.totalDebtInSequence = T1.totalDebtInSequence.add(V.entireTroveDebt);\n        T2.totalCollInSequence = T1.totalCollInSequence.add(V.entireTroveColl);\n        T2.totalDebtToOffset = T1.totalDebtToOffset.add(V.debtToOffset);\n        T2.totalCollToSendToSP = T1.totalCollToSendToSP.add(V.collToSendToSP);\n        T2.totalDebtToRedistribute = T1.totalDebtToRedistribute.add(V.debtToRedistribute);\n        T2.totalCollToRedistribute = T1.totalCollToRedistribute.add(V.collToRedistribute);\n\n        // Assign the address of the partially liquidated trove, and its new debt and coll values\n        T2.partialAddr = V.partialAddr;\n        T2.partialNewDebt = V.partialNewDebt;\n        T2.partialNewColl = V.partialNewColl;\n        T2.partialUpperHint = V.partialUpperHint;\n        T2.partialLowerHint = V.partialLowerHint;\n\n        return T2;\n    }\n\n    // Update the properties of the partially liquidated trove, and insert it back to the list\n    function _updatePartiallyLiquidatedTrove\n    (\n        address _borrower, \n        uint _newDebt, \n        uint _newColl, \n        address _upperHint,\n        address _lowerHint,\n        uint _price\n    ) \n        internal \n    {\n        if ( _borrower == address(0)) { return; }\n\n        Troves[_borrower].debt = _newDebt;\n        Troves[_borrower].coll = _newColl;\n        Troves[_borrower].status = Status.active;\n\n        _updateTroveRewardSnapshots(_borrower);\n        _updateStakeAndTotalStakes(_borrower);\n\n        uint ICR = getCurrentICR(_borrower, _price);\n\n        /* \n        * Insert to sorted list and add to TroveOwners array. The partially liquidated trove has the same\n        * ICR as it did before the liquidation, so insertion is O(1): in principle, its ICR does not change.\n        * In practice, due to rounding error, its ICR can change slightly - so re-insert, with its previous neighbours\n        * as hints.\n        */\n        sortedTroves.insert(_borrower, ICR, _price, _upperHint, _lowerHint);\n        _addTroveOwnerToArray(_borrower);\n        emit TroveUpdated(_borrower, _newDebt, _newColl, Troves[_borrower].stake, TroveManagerOperation.partiallyLiquidateInRecoveryMode);\n    }\n\n    function _sendGasCompensation(address _liquidator, uint _LUSD, uint _ETH) internal {\n        if (_LUSD > 0) {\n            lusdToken.returnFromPool(GAS_POOL_ADDRESS, _liquidator, _LUSD);\n        }\n\n        if (_ETH > 0) {\n            activePool.sendETH(_liquidator, _ETH);\n        }\n    }\n\n    // Move a Trove's pending debt and collateral rewards from distributions, from the Default Pool to the Active Pool\n    function _movePendingTroveRewardsToActivePool(uint _LUSD, uint _ETH) internal {\n        defaultPool.decreaseLUSDDebt(_LUSD);\n        activePool.increaseLUSDDebt(_LUSD);\n        defaultPool.sendETH(address(activePool), _ETH);\n    }\n\n    // --- Redemption functions ---\n\n    // Redeem as much collateral as possible from _borrower's Trove in exchange for LUSD up to _maxLUSDamount\n    function _redeemCollateralFromTrove(\n        address _borrower,\n        uint _maxLUSDamount,\n        uint _price,\n        address _partialRedemptionHint,\n        uint _partialRedemptionHintICR\n    )\n        internal returns (SingleRedemptionValues memory V)\n    {\n        // Determine the remaining amount (lot) to be redeemed, capped by the entire debt of the Trove minus the gas compensation\n        V.LUSDLot = LiquityMath._min(_maxLUSDamount, Troves[_borrower].debt.sub(LUSD_GAS_COMPENSATION));\n\n        // Get the ETHLot of equivalent value in USD\n        V.ETHLot = V.LUSDLot.mul(1e18).div(_price);\n\n        // Decrease the debt and collateral of the current Trove according to the LUSD lot and corresponding ETH to send\n        uint newDebt = (Troves[_borrower].debt).sub(V.LUSDLot);\n        uint newColl = (Troves[_borrower].coll).sub(V.ETHLot);\n\n        if (newDebt == LUSD_GAS_COMPENSATION) {\n            // No debt left in the Trove (except for the gas compensation), therefore the trove gets closed\n            _removeStake(_borrower);\n            _closeTrove(_borrower);\n            _redeemCloseTrove(_borrower, LUSD_GAS_COMPENSATION, newColl);\n\n        } else {\n            uint newICR = LiquityMath._computeCR(newColl, newDebt, _price);\n\n            // Check if the provided hint is fresh. If not, we bail since trying to reinsert without a good hint will almost\n            // certainly result in running out of gas.\n            if (newICR != _partialRedemptionHintICR) {\n                V.LUSDLot = 0;\n                V.ETHLot = 0;\n                return V;\n            }\n\n            sortedTroves.reInsert(_borrower, newICR, _price, _partialRedemptionHint, _partialRedemptionHint);\n\n            Troves[_borrower].debt = newDebt;\n            Troves[_borrower].coll = newColl;\n            _updateStakeAndTotalStakes(_borrower);\n        }\n        emit TroveUpdated(\n            _borrower,\n            newDebt, newColl,\n            Troves[_borrower].stake,\n            TroveManagerOperation.redeemCollateral\n        );\n        return V;\n    }\n\n    /* \n    * Called when a full redemption occurs, and closes the trove.\n    * The redeemer swaps (debt - 10) LUSD for (debt - 10) worth of ETH, so the 10 LUSD gas compensation left corresponds to the remaining debt.\n    * In order to close the trove, the 10 LUSD gas compensation is burned, and 10 debt is removed from the active pool.\n    * The debt recorded on the trove's struct is zero'd elswhere, in _closeTrove.\n    * Any surplus ETH left in the trove, is sent to the Coll surplus pool, and can be later claimed by the borrower.\n    */ \n    function _redeemCloseTrove(address _borrower, uint _LUSD, uint _ETH) internal {\n        lusdToken.burn(GAS_POOL_ADDRESS, _LUSD);\n        // Update Active Pool LUSD, and send ETH to account\n        activePool.decreaseLUSDDebt(_LUSD);\n\n        // send ETH from Active Pool to CollSurplus Pool\n        collSurplusPool.accountSurplus(_borrower, _ETH);\n        activePool.sendETH(address(collSurplusPool), _ETH);\n    }\n\n    function _isValidFirstRedemptionHint(address _firstRedemptionHint, uint _price) internal view returns (bool) {\n        if (_firstRedemptionHint == address(0) ||\n            !sortedTroves.contains(_firstRedemptionHint) ||\n            getCurrentICR(_firstRedemptionHint, _price) < MCR\n        ) {\n            return false;\n        }\n\n        address nextTrove = sortedTroves.getNext(_firstRedemptionHint);\n        return nextTrove == address(0) || getCurrentICR(nextTrove, _price) < MCR;\n    }\n\n    /* Send _LUSDamount LUSD to the system and redeem the corresponding amount of collateral from as many Troves as are needed to fill the redemption\n    * request.  Applies pending rewards to a Trove before reducing its debt and coll.\n    *\n    * Note that if _amount is very large, this function can run out of gas, specially if traversed troves are small. This can be easily avoided by \n    * splitting the total _amount in appropriate chunks and calling the function multiple times.\n    * \n    * Param `_maxIterations` can also be provided, so the loop through Troves is capped (if its zero, it will be ignored).This makes it easier to \n    * avoid OOG for the frontend, as only knowing approximately the average cost of an iteration is enough, without needing to know the topology \n    * of the trove list. It also avoids the need to set the cap in stone in the contract, nor doing gas calculations, as both gas price and opcode \n    * costs can vary.\n    * \n    * All Troves that are redeemed from -- with the likely exception of the last one -- will end up with no debt left, therefore they will be closed.\n    * If the last Trove does have some remaining debt, it has a finite ICR, and the reinsertion could be anywhere in the list, therefore it requires a hint. \n    * A frontend should use getRedemptionHints() to calculate what the ICR of this Trove will be after redemption, and pass a hint for its position \n    * in the sortedTroves list along with the ICR value that the hint was found for.\n    * \n    * If another transaction modifies the list between calling getRedemptionHints() and passing the hints to redeemCollateral(), it\n    * is very likely that the last (partially) redeemed Trove would end up with a different ICR than what the hint is for. In this case the\n    * redemption will stop after the last completely redeemed Trove and the sender will keep the remaining LUSD amount, which they can attempt\n    * to redeem later.\n    */\n    function redeemCollateral(\n        uint _LUSDamount,\n        address _firstRedemptionHint,\n        address _partialRedemptionHint,\n        uint _partialRedemptionHintICR,\n        uint _maxIterations\n    )\n        external\n        override\n    {\n        uint activeDebt = activePool.getLUSDDebt();\n        uint defaultedDebt = defaultPool.getLUSDDebt();\n\n        RedemptionTotals memory T;\n\n        _requireAmountGreaterThanZero(_LUSDamount);\n        _requireLUSDBalanceCoversRedemption(msg.sender, _LUSDamount);\n\n        // Confirm redeemer's balance is less than total systemic debt\n        assert(lusdToken.balanceOf(msg.sender) <= (activeDebt.add(defaultedDebt)));\n\n        uint remainingLUSD = _LUSDamount;\n        uint price = priceFeed.getPrice();\n        address currentBorrower;\n\n        if (_isValidFirstRedemptionHint(_firstRedemptionHint, price)) {\n            currentBorrower = _firstRedemptionHint;\n        } else {\n            currentBorrower = sortedTroves.getLast();\n            // Find the first trove with ICR >= MCR\n            // SWC-104-Unchecked Call Return Value: L920\n            while (currentBorrower != address(0) && getCurrentICR(currentBorrower, price) < MCR) {\n                currentBorrower = sortedTroves.getPrev(currentBorrower);\n            }\n        }\n\n        // Loop through the Troves starting from the one with lowest collateral ratio until _amount of LUSD is exchanged for collateral\n        if (_maxIterations == 0) { _maxIterations = uint(-1); }\n        while (currentBorrower != address(0) && remainingLUSD > 0 && _maxIterations > 0) {\n            _maxIterations--;\n            // Save the address of the Trove preceding the current one, before potentially modifying the list\n            address nextUserToCheck = sortedTroves.getPrev(currentBorrower);\n\n            _applyPendingRewards(currentBorrower);\n            SingleRedemptionValues memory V = _redeemCollateralFromTrove(\n                currentBorrower,\n                remainingLUSD,\n                price,\n                _partialRedemptionHint,\n                _partialRedemptionHintICR\n            );\n\n            if (V.LUSDLot == 0) break; // Partial redemption hint got out-of-date, therefore we could not redeem from the last Trove\n\n            T.totalLUSDToRedeem  = T.totalLUSDToRedeem.add(V.LUSDLot);\n            T.totalETHDrawn = T.totalETHDrawn.add(V.ETHLot);\n\n            remainingLUSD = remainingLUSD.sub(V.LUSDLot);\n            currentBorrower = nextUserToCheck;\n        }\n\n        // Decay the baseRate due to time passed, and then increase it according to the size of this redemption\n        _updateBaseRateFromRedemption(T.totalETHDrawn, price);\n\n        // Calculate the ETH fee and send it to the LQTY staking contract\n        T.ETHFee = _getRedemptionFee(T.totalETHDrawn);\n        activePool.sendETH(lqtyStakingAddress, T.ETHFee);\n        lqtyStaking.increaseF_ETH(T.ETHFee);\n\n        T.ETHToSendToRedeemer = T.totalETHDrawn.sub(T.ETHFee);\n\n        // Burn the total LUSD that is cancelled with debt, and send the redeemed ETH to msg.sender\n        _activePoolRedeemCollateral(msg.sender, T.totalLUSDToRedeem, T.ETHToSendToRedeemer);\n\n        emit Redemption(_LUSDamount, T.totalLUSDToRedeem, T.totalETHDrawn, T.ETHFee);\n    }\n\n    // Burn the received LUSD, transfer the redeemed ETH to _redeemer and updates the Active Pool\n    function _activePoolRedeemCollateral(address _redeemer, uint _LUSD, uint _ETH) internal {\n        // Update Active Pool LUSD, and send ETH to account\n        lusdToken.burn(_redeemer, _LUSD);\n        activePool.decreaseLUSDDebt(_LUSD);\n\n        activePool.sendETH(_redeemer, _ETH);\n    }\n\n    // --- Helper functions ---\n\n\n    // Return the current collateral ratio (ICR) of a given Trove. Takes a trove's pending coll and debt rewards from redistributions into account.\n    function getCurrentICR(address _borrower, uint _price) public view override returns (uint) {\n        uint pendingETHReward = getPendingETHReward(_borrower);\n        uint pendingLUSDDebtReward = getPendingLUSDDebtReward(_borrower);\n\n        uint currentETH = Troves[_borrower].coll.add(pendingETHReward);\n        uint currentLUSDDebt = Troves[_borrower].debt.add(pendingLUSDDebtReward);\n\n        uint ICR = LiquityMath._computeCR(currentETH, currentLUSDDebt, _price);\n        return ICR;\n    }\n\n    function applyPendingRewards(address _borrower) external override {\n        _requireCallerIsBorrowerOperations();\n        return _applyPendingRewards(_borrower);\n    }\n\n    // Add the borrowers's coll and debt rewards earned from redistributions, to their Trove\n    function _applyPendingRewards(address _borrower) internal {\n        if (hasPendingRewards(_borrower)) {\n            _requireTroveisActive(_borrower);\n\n            // Compute pending rewards\n            uint pendingETHReward = getPendingETHReward(_borrower);\n            uint pendingLUSDDebtReward = getPendingLUSDDebtReward(_borrower);\n\n            // Apply pending rewards to trove's state\n            Troves[_borrower].coll = Troves[_borrower].coll.add(pendingETHReward);\n            Troves[_borrower].debt = Troves[_borrower].debt.add(pendingLUSDDebtReward);\n\n            _updateTroveRewardSnapshots(_borrower);\n\n            // Transfer from DefaultPool to ActivePool\n            _movePendingTroveRewardsToActivePool(pendingLUSDDebtReward, pendingETHReward);\n\n            emit TroveUpdated(\n                _borrower, \n                Troves[_borrower].debt, \n                Troves[_borrower].coll, \n                Troves[_borrower].stake, \n                TroveManagerOperation.applyPendingRewards\n            );\n        }\n    }\n\n    // Update borrower's snapshots of L_ETH and L_LUSDDebt to reflect the current values\n    function updateTroveRewardSnapshots(address _borrower) external override {\n        _requireCallerIsBorrowerOperations();\n       return _updateTroveRewardSnapshots(_borrower);\n    }\n\n    function _updateTroveRewardSnapshots(address _borrower) internal {\n        rewardSnapshots[_borrower].ETH = L_ETH;\n        rewardSnapshots[_borrower].LUSDDebt = L_LUSDDebt;\n    }\n\n    // Get the borrower's pending accumulated ETH reward, earned by their stake\n    function getPendingETHReward(address _borrower) public view override returns (uint) {\n        uint snapshotETH = rewardSnapshots[_borrower].ETH;\n        uint rewardPerUnitStaked = L_ETH.sub(snapshotETH);\n\n        if ( rewardPerUnitStaked == 0 ) { return 0; }\n\n        uint stake = Troves[_borrower].stake;\n\n        uint pendingETHReward = stake.mul(rewardPerUnitStaked).div(1e18);\n\n        return pendingETHReward;\n    }\n\n     // Get the borrower's pending accumulated LUSD reward, earned by their stake\n    function getPendingLUSDDebtReward(address _borrower) public view override returns (uint) {\n        uint snapshotLUSDDebt = rewardSnapshots[_borrower].LUSDDebt;\n        uint rewardPerUnitStaked = L_LUSDDebt.sub(snapshotLUSDDebt);\n\n        if ( rewardPerUnitStaked == 0 ) { return 0; }\n\n        uint stake =  Troves[_borrower].stake;\n\n        uint pendingLUSDDebtReward = stake.mul(rewardPerUnitStaked).div(1e18);\n\n        return pendingLUSDDebtReward;\n    }\n\n    function hasPendingRewards(address _borrower) public view override returns (bool) {\n        /* \n        * A Trove has pending rewards if its snapshot is less than the current rewards per-unit-staked sum:\n        * this indicates that rewards have occured since the snapshot was made, and the user therefore has\n        * pending rewards \n        */\n        return (rewardSnapshots[_borrower].ETH < L_ETH);\n    }\n\n    // Return the Troves entire debt and coll, including pending rewards from redistributions.\n    function getEntireDebtAndColl(\n        address _borrower\n    )\n        public\n        view\n        override\n        returns (uint debt, uint coll, uint pendingLUSDDebtReward, uint pendingETHReward)\n    {\n        debt = Troves[_borrower].debt;\n        coll = Troves[_borrower].coll;\n\n        pendingLUSDDebtReward = getPendingLUSDDebtReward(_borrower);\n        pendingETHReward = getPendingETHReward(_borrower);\n\n        debt = debt.add(pendingLUSDDebtReward);\n        coll = coll.add(pendingETHReward);\n    }\n\n    function removeStake(address _borrower) external override {\n        _requireCallerIsBorrowerOperations();\n        return _removeStake(_borrower);\n    }\n\n    // Remove borrower's stake from the totalStakes sum, and set their stake to 0\n    function _removeStake(address _borrower) internal {\n        uint stake = Troves[_borrower].stake;\n        totalStakes = totalStakes.sub(stake);\n        Troves[_borrower].stake = 0;\n    }\n\n    function updateStakeAndTotalStakes(address _borrower) external override returns (uint) {\n        _requireCallerIsBorrowerOperations();\n        return _updateStakeAndTotalStakes(_borrower);\n    }\n\n    // Update borrower's stake based on their latest collateral value\n    function _updateStakeAndTotalStakes(address _borrower) internal returns (uint) {\n        uint newStake = _computeNewStake(Troves[_borrower].coll);\n        uint oldStake = Troves[_borrower].stake;\n        Troves[_borrower].stake = newStake;\n        totalStakes = totalStakes.sub(oldStake).add(newStake);\n\n        return newStake;\n    }\n\n    // Calculate a new stake based on the snapshots of the totalStakes and totalCollateral taken at the last liquidation\n    function _computeNewStake(uint _coll) internal view returns (uint) {\n        uint stake;\n        if (totalCollateralSnapshot == 0) {\n            stake = _coll;\n        } else {\n            /*  \n            * The following assert() holds true because:\n            * - The system always contains >= 1 trove \n            * - When we close or liquidate a trove, we redistribute the pending rewards, so if all troves were closed/liquidated, \n            * rewards wouldve been emptied and totalCollateralSnapshot would be zero too.\n            */\n            assert(totalStakesSnapshot > 0);\n            stake = _coll.mul(totalStakesSnapshot).div(totalCollateralSnapshot);\n        }\n        return stake;\n    }\n\n    function _redistributeDebtAndColl(uint _debt, uint _coll) internal {\n        if (_debt == 0) { return; }\n\n        if (totalStakes > 0) {\n            /* \n            * Add distributed coll and debt rewards-per-unit-staked to the running totals.\n            * Division uses a \"feedback\" error correction, to keep the cumulative error in\n            * the  L_ETH and L_LUSDDebt state variables low. \n            */\n            uint ETHNumerator = _coll.mul(1e18).add(lastETHError_Redistribution);\n            uint LUSDDebtNumerator = _debt.mul(1e18).add(lastLUSDDebtError_Redistribution);\n\n            uint ETHRewardPerUnitStaked = ETHNumerator.div(totalStakes);\n            uint LUSDDebtRewardPerUnitStaked = LUSDDebtNumerator.div(totalStakes);\n\n            lastETHError_Redistribution = ETHNumerator.sub(ETHRewardPerUnitStaked.mul(totalStakes));\n            lastLUSDDebtError_Redistribution = LUSDDebtNumerator.sub(LUSDDebtRewardPerUnitStaked.mul(totalStakes));\n\n            L_ETH = L_ETH.add(ETHRewardPerUnitStaked);\n            L_LUSDDebt = L_LUSDDebt.add(LUSDDebtRewardPerUnitStaked);\n        }\n\n        // Transfer coll and debt from ActivePool to DefaultPool\n        activePool.decreaseLUSDDebt(_debt);\n        defaultPool.increaseLUSDDebt(_debt);\n        activePool.sendETH(address(defaultPool), _coll);\n    }\n\n    function closeTrove(address _borrower) external override {\n        _requireCallerIsBorrowerOperations();\n        return _closeTrove(_borrower);\n    }\n\n    function _closeTrove(address _borrower) internal {\n        uint TroveOwnersArrayLength = TroveOwners.length;\n        _requireMoreThanOneTroveInSystem(TroveOwnersArrayLength);\n\n        Troves[_borrower].status = Status.closed;\n        Troves[_borrower].coll = 0;\n        Troves[_borrower].debt = 0;\n\n        rewardSnapshots[_borrower].ETH = 0;\n        rewardSnapshots[_borrower].LUSDDebt = 0;\n\n        _removeTroveOwner(_borrower, TroveOwnersArrayLength);\n        sortedTroves.remove(_borrower);\n    }\n\n    /* \n    * Updates snapshots of system total stakes and total collateral, excluding a given collateral remainder from the calculation. \n    * Used in a liquidation sequence.\n    *\n    * The calculation excludes two portions of collateral that are in the ActivePool: \n    *\n    * 1) the total ETH gas compensation from the liquidation sequence\n    * 2) The remaining collateral in a partially liquidated trove (if one occurred)\n    *\n    * The ETH as compensation must be excluded as it is always sent out at the very end of the liquidation sequence.\n    *\n    * The partially liquidated trove's remaining collateral stays in the ActivePool, but it is excluded here so the system \n    * can take snapshots before the partially liquidated trove's stake is updated (based on these snapshots). This ensures\n    * the partial's new stake doesn't double-count its own remaining collateral.\n    *\n    */\n    function _updateSystemSnapshots_excludeCollRemainder(uint _collRemainder) internal {\n        totalStakesSnapshot = totalStakes;\n\n        uint activeColl = activePool.getETH();\n        uint liquidatedColl = defaultPool.getETH();\n        totalCollateralSnapshot = activeColl.sub(_collRemainder).add(liquidatedColl);\n    }\n\n    // Push the owner's address to the Trove owners list, and record the corresponding array index on the Trove struct\n    function addTroveOwnerToArray(address _borrower) external override returns (uint index) {\n        _requireCallerIsBorrowerOperations();\n        return _addTroveOwnerToArray(_borrower);\n    }\n\n    function _addTroveOwnerToArray(address _borrower) internal returns (uint128 index) {\n        require(TroveOwners.length < 2**128 - 1, \"TroveManager: TroveOwners array has maximum size of 2^128 - 1\");\n\n        // Push the Troveowner to the array\n        TroveOwners.push(_borrower);\n\n        // Record the index of the new Troveowner on their Trove struct\n        index = uint128(TroveOwners.length.sub(1));\n        Troves[_borrower].arrayIndex = index;\n\n        return index;\n    }\n\n    /* \n    * Remove a Trove owner from the TroveOwners array, not preserving array order. Removing owner 'B' does the following:\n    * [A B C D E] => [A E C D], and updates E's Trove struct to point to its new array index. \n    */\n    function _removeTroveOwner(address _borrower, uint TroveOwnersArrayLength) internal {\n        require(Troves[_borrower].status == Status.closed, \"TroveManager: Trove is still active\");\n\n        uint128 index = Troves[_borrower].arrayIndex;\n        uint length = TroveOwnersArrayLength;\n        uint idxLast = length.sub(1);\n\n        assert(index <= idxLast);\n\n        address addressToMove = TroveOwners[idxLast];\n\n        TroveOwners[index] = addressToMove;\n        Troves[addressToMove].arrayIndex = index;\n        TroveOwners.pop();\n    }\n\n    // --- Recovery Mode and TCR functions ---\n\n    function checkRecoveryMode() public view override returns (bool) {\n        uint TCR = getTCR();\n\n        if (TCR < CCR) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    // Check whether or not the system *would be* in Recovery Mode, given an ETH:USD price, and the entire system coll and debt.\n    function _checkPotentialRecoveryMode(\n        uint _entireSystemColl,\n        uint _entireSystemDebt,\n        uint _price\n    )\n        internal\n        pure\n    returns (bool)\n    {\n        uint TCR = LiquityMath._computeCR(_entireSystemColl, _entireSystemDebt, _price);\n        if (TCR < CCR) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n    // SWC-135-Code With No Effects: L1276-L1284\n    function getTCR() public view override returns (uint TCR) {\n        uint price = priceFeed.getPrice();\n        uint entireSystemColl = getEntireSystemColl();\n        uint entireSystemDebt = getEntireSystemDebt();\n\n        TCR = LiquityMath._computeCR(entireSystemColl, entireSystemDebt, price);\n\n        return TCR;\n    }\n    // SWC-135-Code With No Effects: L1286-L1291\n    function getEntireSystemColl() public view override returns (uint entireSystemColl) {\n        uint activeColl = activePool.getETH();\n        uint liquidatedColl = defaultPool.getETH();\n\n        return activeColl.add(liquidatedColl);\n    }\n\n    function getEntireSystemDebt() public view override returns (uint entireSystemDebt) {\n        uint activeDebt = activePool.getLUSDDebt();\n        uint closedDebt = defaultPool.getLUSDDebt();\n\n        return activeDebt.add(closedDebt);\n    }\n\n    // --- Redemption fee functions ---\n\n    /* \n    * This function has two impacts on the baseRate state variable:\n    * 1) decays the baseRate based on time passed since last redemption or LUSD borrowing operation.\n    * then,\n    * 2) increases the baseRate based on the amount redeemed, as a proportion of total supply\n    */\n    function _updateBaseRateFromRedemption(uint _ETHDrawn,  uint _price) internal returns (uint) {\n        uint decayedBaseRate = _calcDecayedBaseRate();\n\n        uint activeDebt = activePool.getLUSDDebt();\n        uint closedDebt = defaultPool.getLUSDDebt();\n        uint totalLUSDSupply = activeDebt.add(closedDebt);\n\n        /* Convert the drawn ETH back to LUSD at face value rate (1 LUSD:1 USD), in order to get\n        * the fraction of total supply that was redeemed at face value. */\n        uint redeemedLUSDFraction = _ETHDrawn.mul(_price).div(totalLUSDSupply);\n\n        uint newBaseRate = decayedBaseRate.add(redeemedLUSDFraction.div(BETA));\n\n        // Update the baseRate state variable\n        baseRate = newBaseRate < 1e18 ? newBaseRate : 1e18;  // cap baseRate at a maximum of 100%\n        assert(baseRate <= 1e18 && baseRate > 0); // Base rate is always non-zero after redemption\n\n        _updateLastFeeOpTime();\n\n        return baseRate;\n    }\n\n    function _getRedemptionFee(uint _ETHDrawn) internal view returns (uint) {\n       return baseRate.mul(_ETHDrawn).div(1e18);\n    }\n\n    // --- Borrowing fee functions ---\n\n    function getBorrowingFee(uint _LUSDDebt) external view override returns (uint) {\n        return _LUSDDebt.mul(baseRate).div(1e18);\n    }\n\n    // Updates the baseRate state variable based on time elapsed since the last redemption or LUSD borrowing operation.\n    function decayBaseRateFromBorrowing() external override {\n        _requireCallerIsBorrowerOperations();\n\n        baseRate = _calcDecayedBaseRate();\n        assert(baseRate <= 1e18);  // The baseRate can decay to 0\n\n        _updateLastFeeOpTime();\n    }\n\n    // --- Internal fee functions ---\n\n    // Update the last fee operation time only if time passed >= decay interval. This prevents base rate griefing.\n    function _updateLastFeeOpTime() internal {\n        uint timePassed = block.timestamp.sub(lastFeeOperationTime);\n\n        if (timePassed >= SECONDS_IN_ONE_MINUTE) {\n            lastFeeOperationTime = block.timestamp;\n        }\n    }\n\n    function _calcDecayedBaseRate() internal view returns (uint) {\n        uint minutesPassed = _minutesPassedSinceLastFeeOp();\n        uint decayFactor = LiquityMath._decPow(MINUTE_DECAY_FACTOR, minutesPassed);\n\n        return baseRate.mul(decayFactor).div(1e18);\n    }\n\n    function _minutesPassedSinceLastFeeOp() internal view returns (uint) {\n        return (block.timestamp.sub(lastFeeOperationTime)).div(SECONDS_IN_ONE_MINUTE);\n    }\n\n    // --- 'require' wrapper functions ---\n\n    function _requireCallerIsBorrowerOperations() internal view {\n        require(msg.sender == borrowerOperationsAddress, \"TroveManager: Caller is not the BorrowerOperations contract\");\n    }\n\n    function _requireTroveisActive(address _borrower) internal view {\n        require(Troves[_borrower].status == Status.active, \"TroveManager: Trove does not exist or is closed\");\n    }\n\n    function _requireLUSDBalanceCoversRedemption(address _redeemer, uint _amount) internal view {\n        require(lusdToken.balanceOf(_redeemer) >= _amount, \"TroveManager: Requested redemption amount must be <= user's LUSD token balance\");\n    }\n\n    function _requireMoreThanOneTroveInSystem(uint TroveOwnersArrayLength) internal view {\n        require (TroveOwnersArrayLength > 1 && sortedTroves.getSize() > 1, \"TroveManager: Only one trove in the system\");\n    }\n\n    function _requireAmountGreaterThanZero(uint _amount) internal pure {\n        require(_amount > 0, \"TroveManager: Amount must be greater than zero\");\n    }\n\n    // --- Trove property getters ---\n\n    function getTroveStatus(address _borrower) external view override returns (uint) {\n        return uint(Troves[_borrower].status);\n    }\n\n    function getTroveStake(address _borrower) external view override returns (uint) {\n        return Troves[_borrower].stake;\n    }\n\n    function getTroveDebt(address _borrower) external view override returns (uint) {\n        return Troves[_borrower].debt;\n    }\n\n    function getTroveColl(address _borrower) external view override returns (uint) {\n        return Troves[_borrower].coll;\n    }\n\n    // --- Trove property setters, called by BorrowerOperations ---\n\n    function setTroveStatus(address _borrower, uint _num) external override {\n        _requireCallerIsBorrowerOperations();\n        Troves[_borrower].status = Status(_num);\n    }\n\n    function increaseTroveColl(address _borrower, uint _collIncrease) external override returns (uint) {\n        _requireCallerIsBorrowerOperations();\n        uint newColl = Troves[_borrower].coll.add(_collIncrease);\n        Troves[_borrower].coll = newColl;\n        return newColl;\n    }\n\n    function decreaseTroveColl(address _borrower, uint _collDecrease) external override returns (uint) {\n        _requireCallerIsBorrowerOperations();\n        uint newColl = Troves[_borrower].coll.sub(_collDecrease);\n        Troves[_borrower].coll = newColl;\n        return newColl;\n    }\n\n    function increaseTroveDebt(address _borrower, uint _debtIncrease) external override returns (uint) {\n        _requireCallerIsBorrowerOperations();\n        uint newDebt = Troves[_borrower].debt.add(_debtIncrease);\n        Troves[_borrower].debt = newDebt;\n        return newDebt;\n    }\n\n    function decreaseTroveDebt(address _borrower, uint _debtDecrease) external override returns (uint) {\n        _requireCallerIsBorrowerOperations();\n        uint newDebt = Troves[_borrower].debt.sub(_debtDecrease);\n        Troves[_borrower].debt = newDebt;\n        return newDebt;\n    }\n}",
        "function": "redeemCollateral(uint256,address,address,uint256,uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-Liquity/dev-f0df3efa5a5f05b205752184cfce107c5bd6e06c/packages/contracts/contracts/TroveManager.sol",
        "vulnerability": "Exception State (SWC 110)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract TroveManager is LiquityBase, Ownable, ITroveManager {\n\n    // --- Connected contract declarations ---\n\n    address public borrowerOperationsAddress;\n\n    IPool public activePool;\n\n    IPool public defaultPool;\n\n    IStabilityPool public stabilityPool;\n\n    ICollSurplusPool collSurplusPool;\n\n    ILUSDToken public lusdToken;\n\n    IPriceFeed public priceFeed;\n\n    ILQTYStaking public lqtyStaking;\n    address public lqtyStakingAddress;\n\n    // A doubly linked list of Troves, sorted by their sorted by their collateral ratios\n    ISortedTroves public sortedTroves;\n\n    // --- Data structures ---\n\n    uint constant public SECONDS_IN_ONE_MINUTE = 60;\n    uint constant public MINUTE_DECAY_FACTOR = 999832508430720967;  // 18 digit decimal. Corresponds to an hourly decay factor of 0.99\n\n    /* \n    * BETA: 18 digit decimal. Parameter by which to divide the redeemed fraction, in order to calc the new base rate from a redemption. \n    * Corresponds to (1 / ALPHA) in the white paper. \n    */\n    uint constant public BETA = 2;\n\n    uint public baseRate;\n\n    // The timestamp of the latest fee operation (redemption or new LUSD issuance) \n    uint public lastFeeOperationTime;\n\n    enum Status { nonExistent, active, closed }\n\n    // Store the necessary data for a trove\n    struct Trove {\n        uint debt;\n        uint coll;\n        uint stake;\n        Status status;\n        uint128 arrayIndex;\n    }\n\n    mapping (address => Trove) public Troves;\n\n    uint public totalStakes;\n\n    // Snapshot of the value of totalStakes, taken immediately after the latest liquidation\n    uint public totalStakesSnapshot;\n\n    // Snapshot of the total collateral across the ActivePool and DefaultPool, immediately after the latest liquidation.\n    uint public totalCollateralSnapshot;\n\n    /*\n    * L_ETH and L_LUSDDebt track the sums of accumulated liquidation rewards per unit staked. During its lifetime, each stake earns:\n    *\n    * An ETH gain of ( stake * [L_ETH - L_ETH(0)] )\n    * A LUSDDebt increase  of ( stake * [L_LUSDDebt - L_LUSDDebt(0)] )\n    *\n    * Where L_ETH(0) and L_LUSDDebt(0) are snapshots of L_ETH and L_LUSDDebt for the active Trove taken at the instant the stake was made\n    */\n    uint public L_ETH;\n    uint public L_LUSDDebt;\n\n    // Map addresses with active troves to their RewardSnapshot\n    mapping (address => RewardSnapshot) public rewardSnapshots;\n\n    // Object containing the ETH and LUSD snapshots for a given active trove\n    struct RewardSnapshot { uint ETH; uint LUSDDebt;}\n\n    // Array of all active trove addresses - used to to compute an approximate hint off-chain, for the sorted list insertion\n    address[] public TroveOwners;\n\n    // Error trackers for the trove redistribution calculation\n    uint public lastETHError_Redistribution;\n    uint public lastLUSDDebtError_Redistribution;\n\n    /* \n    * --- Variable container structs for liquidations ---\n    *\n    * These structs are used to hold, return and assign variables inside the liquidation functions,\n    * in order to avoid the error: \"CompilerError: Stack too deep\". \n    **/\n\n    struct LocalVariables_OuterLiquidationFunction {\n        uint price;\n        uint LUSDInStabPool;\n        bool recoveryModeAtStart;\n        uint liquidatedDebt;\n        uint liquidatedColl;\n    }\n\n    struct LocalVariables_InnerSingleLiquidateFunction {\n        uint collToLiquidate;\n        uint pendingDebtReward;\n        uint pendingCollReward;\n    }\n\n    struct LocalVariables_LiquidationSequence {\n        uint remainingLUSDInStabPool;\n        uint i;\n        uint ICR;\n        address user;\n        bool backToNormalMode;\n        uint entireSystemDebt;\n        uint entireSystemColl;\n    }\n\n    struct LiquidationValues {\n        uint entireTroveDebt;\n        uint entireTroveColl;\n        uint collGasCompensation;\n        uint LUSDGasCompensation;\n        uint debtToOffset;\n        uint collToSendToSP;\n        uint debtToRedistribute;\n        uint collToRedistribute;\n        address partialAddr;\n        uint partialNewDebt;\n        uint partialNewColl;\n        address partialUpperHint;\n        address partialLowerHint;\n    }\n\n    struct LiquidationTotals {\n        uint totalCollInSequence;\n        uint totalDebtInSequence;\n        uint totalCollGasCompensation;\n        uint totalLUSDGasCompensation;\n        uint totalDebtToOffset;\n        uint totalCollToSendToSP;\n        uint totalDebtToRedistribute;\n        uint totalCollToRedistribute;\n        address partialAddr;\n        uint partialNewDebt;\n        uint partialNewColl;\n        address partialUpperHint;\n        address partialLowerHint;\n    }\n\n    // --- Variable container structs for redemptions ---\n\n    struct RedemptionTotals {\n        uint totalLUSDToRedeem;\n        uint totalETHDrawn;\n        uint ETHFee;\n        uint ETHToSendToRedeemer;\n        uint decayedBaseRate;\n    }\n\n    struct SingleRedemptionValues {\n        uint LUSDLot;\n        uint ETHLot;\n    }\n\n    // --- Events ---\n\n    event Liquidation(uint _liquidatedDebt, uint _liquidatedColl, uint _collGasCompensation, uint _LUSDGasCompensation);\n    event Redemption(uint _attemptedLUSDAmount, uint _actualLUSDAmount, uint _ETHSent, uint _ETHFee);\n\n    enum TroveManagerOperation {\n        applyPendingRewards,\n        liquidateInNormalMode,\n        liquidateInRecoveryMode,\n        partiallyLiquidateInRecoveryMode,\n        redeemCollateral\n    }\n\n    event TroveCreated(address indexed _borrower, uint _arrayIndex);\n    event TroveUpdated(address indexed _borrower, uint _debt, uint _coll, uint _stake, TroveManagerOperation _operation);\n    event TroveLiquidated(address indexed _borrower, uint _debt, uint _coll, TroveManagerOperation _operation);\n\n    // --- Dependency setter ---\n\n    function setAddresses(\n        address _borrowerOperationsAddress,\n        address _activePoolAddress,\n        address _defaultPoolAddress,\n        address _stabilityPoolAddress,\n        address _collSurplusPoolAddress,\n        address _priceFeedAddress,\n        address _lusdTokenAddress,\n        address _sortedTrovesAddress,\n        address _lqtyStakingAddress\n    )\n        external\n        override\n        onlyOwner\n    {\n        borrowerOperationsAddress = _borrowerOperationsAddress;\n        activePool = IPool(_activePoolAddress);\n        defaultPool = IPool(_defaultPoolAddress);\n        stabilityPool = IStabilityPool(_stabilityPoolAddress);\n        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);\n        priceFeed = IPriceFeed(_priceFeedAddress);\n        lusdToken = ILUSDToken(_lusdTokenAddress);\n        sortedTroves = ISortedTroves(_sortedTrovesAddress);\n        lqtyStakingAddress = _lqtyStakingAddress;\n        lqtyStaking = ILQTYStaking(_lqtyStakingAddress);\n\n        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);\n        emit ActivePoolAddressChanged(_activePoolAddress);\n        emit DefaultPoolAddressChanged(_defaultPoolAddress);\n        emit StabilityPoolAddressChanged(_stabilityPoolAddress);\n        emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);\n        emit PriceFeedAddressChanged(_priceFeedAddress);\n        emit LUSDTokenAddressChanged(_lusdTokenAddress);\n        emit SortedTrovesAddressChanged(_sortedTrovesAddress);\n        emit LQTYStakingAddressChanged(_lqtyStakingAddress);\n\n        _renounceOwnership();\n    }\n\n    // --- Getters ---\n\n    function getTroveOwnersCount() external view override returns (uint) {\n        return TroveOwners.length;\n    }\n\n    function getTroveFromTroveOwnersArray(uint _index) external view override returns (address) {\n        return TroveOwners[_index];\n    }\n\n    // --- Trove Liquidation functions ---\n\n    // Single liquidation function. Closes the trove if its ICR is lower than the minimum collateral ratio. \n    function liquidate(address _borrower) external override {\n        _requireTroveisActive(_borrower);\n\n        address[] memory borrowers = new address[](1);\n        borrowers[0] = _borrower;\n        batchLiquidateTroves(borrowers);\n    }\n\n    // --- Inner single liquidation functions ---\n\n    // Liquidate one trove, in Normal Mode.\n    function _liquidateNormalMode(address _borrower, uint _LUSDInStabPool) internal returns (LiquidationValues memory V) {\n        LocalVariables_InnerSingleLiquidateFunction memory L;\n\n        (V.entireTroveDebt,\n        V.entireTroveColl,\n        L.pendingDebtReward,\n        L.pendingCollReward) = getEntireDebtAndColl(_borrower);\n\n        _movePendingTroveRewardsToActivePool(L.pendingDebtReward, L.pendingCollReward);\n        _removeStake(_borrower);\n\n        V.collGasCompensation = _getCollGasCompensation(V.entireTroveColl);\n        V.LUSDGasCompensation = LUSD_GAS_COMPENSATION;\n        uint collToLiquidate = V.entireTroveColl.sub(V.collGasCompensation);\n\n        (V.debtToOffset,\n        V.collToSendToSP,\n        V.debtToRedistribute,\n        V.collToRedistribute) = _getOffsetAndRedistributionVals(V.entireTroveDebt, collToLiquidate, _LUSDInStabPool);\n\n        _closeTrove(_borrower);\n        emit TroveLiquidated(_borrower, V.entireTroveDebt, V.entireTroveColl, TroveManagerOperation.liquidateInNormalMode);\n\n        return V;\n    }\n\n    // Liquidate one trove, in Recovery Mode.\n    function _liquidateRecoveryMode(address _borrower, uint _ICR, uint _LUSDInStabPool, uint _TCR) internal returns (LiquidationValues memory V) {\n        LocalVariables_InnerSingleLiquidateFunction memory L;\n        \n        if (TroveOwners.length <= 1) { return V; } // don't liquidate if last trove\n\n        (V.entireTroveDebt,\n        V.entireTroveColl,\n        L.pendingDebtReward,\n        L.pendingCollReward) = getEntireDebtAndColl(_borrower);\n\n        _movePendingTroveRewardsToActivePool(L.pendingDebtReward, L.pendingCollReward);\n\n        V.collGasCompensation = _getCollGasCompensation(V.entireTroveColl);\n        // In case of a partial liquidation, V.LUSDGasCompensation will be overwritten to zero, in the third branch below\n        V.LUSDGasCompensation = LUSD_GAS_COMPENSATION;\n        L.collToLiquidate = V.entireTroveColl.sub(V.collGasCompensation);\n\n        // If ICR <= 100%, purely redistribute the Trove across all active Troves\n        if (_ICR <= _100pct) {\n            _removeStake(_borrower);\n\n            V.debtToOffset = 0;\n            V.collToSendToSP = 0;\n            V.debtToRedistribute = V.entireTroveDebt;\n            V.collToRedistribute = L.collToLiquidate;\n\n            _closeTrove(_borrower);\n            emit TroveLiquidated(_borrower, V.entireTroveDebt, V.entireTroveColl, TroveManagerOperation.liquidateInRecoveryMode);\n\n        // If 100% < ICR < MCR, offset as much as possible, and redistribute the remainder\n        } else if ((_ICR > _100pct) && (_ICR < MCR)) {\n            _removeStake(_borrower);\n\n            (V.debtToOffset,\n            V.collToSendToSP,\n            V.debtToRedistribute,\n            V.collToRedistribute) = _getOffsetAndRedistributionVals(V.entireTroveDebt, L.collToLiquidate, _LUSDInStabPool);\n\n            _closeTrove(_borrower);\n            emit TroveLiquidated(_borrower, V.entireTroveDebt, V.entireTroveColl, TroveManagerOperation.liquidateInRecoveryMode);\n\n        /* \n        * If 110% <= ICR < current TCR (accounting for the preceding liquidations in the current sequence)\n        * and there is LUSD in the Stability Pool, only offset it as much as possible, with no redistribution.\n        */\n        } else if ((_ICR >= MCR) && (_ICR < _TCR)) {\n            assert(_LUSDInStabPool != 0);\n\n            _removeStake(_borrower);\n            \n            V = _getFullOrPartialOffsetVals(_borrower, V.entireTroveDebt, V.entireTroveColl, _LUSDInStabPool);\n\n            _closeTrove(_borrower);\n        }\n        else if (_ICR >= _TCR) {\n            LiquidationValues memory zeroVals;\n            return zeroVals;\n        }\n\n        return V;\n    }\n\n    /* In a full liquidation, returns the values for a trove's coll and debt to be offset, and coll and debt to be \n    * redistributed to active troves. \n    */\n    function _getOffsetAndRedistributionVals\n    (\n        uint _debt,\n        uint _coll,\n        uint _LUSDInStabPool\n    )\n        internal\n        pure\n        returns (uint debtToOffset, uint collToSendToSP, uint debtToRedistribute, uint collToRedistribute)\n    {\n        if (_LUSDInStabPool > 0) {\n        /* \n        * Offset as much debt & collateral as possible against the Stability Pool, and redistribute the remainder\n        * between all active troves.\n        *\n        *  If the trove's debt is larger than the deposited LUSD in the Stability Pool:\n        *\n        *  - Offset an amount of the trove's debt equal to the LUSD in the Stability Pool\n        *  - Send a fraction of the trove's collateral to the Stability Pool, equal to the fraction of its offset debt\n        *\n        */\n            debtToOffset = LiquityMath._min(_debt, _LUSDInStabPool);\n            collToSendToSP = _coll.mul(debtToOffset).div(_debt);\n            debtToRedistribute = _debt.sub(debtToOffset);\n            collToRedistribute = _coll.sub(collToSendToSP);\n        } else {\n            debtToOffset = 0;\n            collToSendToSP = 0;\n            debtToRedistribute = _debt;\n            collToRedistribute = _coll;\n        }\n    }\n\n    /*\n    *  If it is a full offset, get its offset coll/debt and ETH gas comp, and close the trove.\n    *\n    * If it is a partial liquidation, get its offset coll/debt and ETH gas comp, and its new coll/debt, and its re-insertion hints.\n    */\n    function _getFullOrPartialOffsetVals\n    (\n        address _borrower,\n        uint _entireTroveDebt,\n        uint _entireTroveColl,\n        uint _LUSDInStabPool\n    )\n        internal\n        returns (LiquidationValues memory V)\n    {\n        V.entireTroveDebt = _entireTroveDebt;\n        V.entireTroveColl = _entireTroveColl;\n\n        // When Stability Pool can fully absorb the trove's debt, perform a full offset\n        if (_entireTroveDebt <= _LUSDInStabPool) {\n            V.collGasCompensation = _getCollGasCompensation(_entireTroveColl);\n            V.LUSDGasCompensation = LUSD_GAS_COMPENSATION;\n\n            V.debtToOffset = _entireTroveDebt;\n            V.collToSendToSP = _entireTroveColl.sub(V.collGasCompensation);\n            V.debtToRedistribute = 0;\n            V.collToRedistribute = 0;\n\n            emit TroveLiquidated(_borrower, _entireTroveDebt, _entireTroveColl, TroveManagerOperation.liquidateInRecoveryMode);\n        }\n        /* \n        * When trove's debt is greater than the Stability Pool, perform a partial liquidation: offset as much as possible,\n        * and do not redistribute the remainder. The trove remains active, with a reduced collateral and debt.\n        *\n        * ETH gas compensation is based on and drawn from the collateral fraction that corresponds to the partial offset. \n        * LUSD gas compensation is left untouched. \n        *\n        * Since ETH gas comp is drawn purely from the *liquidated* portion, the trove is left with the same ICR as before the \n        * liquidation.\n        */\n        else if (_entireTroveDebt > _LUSDInStabPool) {\n            // Remaining debt in the trove is lower-bounded by the trove's gas compensation\n            V.partialNewDebt = LiquityMath._max(_entireTroveDebt.sub(_LUSDInStabPool), LUSD_GAS_COMPENSATION);\n          \n            V.debtToOffset = _entireTroveDebt.sub(V.partialNewDebt);\n\n            uint collFraction = _entireTroveColl.mul(V.debtToOffset).div(_entireTroveDebt);\n            V.collGasCompensation = _getCollGasCompensation(collFraction);\n          \n            V.LUSDGasCompensation = 0;  // LUSD gas compensation remains untouched\n\n            V.collToSendToSP = collFraction.sub(V.collGasCompensation);\n            V.collToRedistribute = 0;\n            V.debtToRedistribute = 0;\n\n            V.partialAddr = _borrower;\n            V.partialNewColl = _entireTroveColl.sub(collFraction);\n\n            // Get the partial trove's neighbours, so we can re-insert it later to the same position\n            V.partialUpperHint = sortedTroves.getPrev(_borrower);  \n            V.partialLowerHint = sortedTroves.getNext(_borrower);\n        }\n    }\n\n    /* \n    * Liquidate a sequence of troves. Closes a maximum number of n under-collateralized Troves,\n    * starting from the one with the lowest collateral ratio in the system, and moving upwards\n    */\n    function liquidateTroves(uint _n) external override {\n        LocalVariables_OuterLiquidationFunction memory L;\n\n        LiquidationTotals memory T;\n\n        L.price = priceFeed.getPrice();\n        L.LUSDInStabPool = stabilityPool.getTotalLUSDDeposits();\n        L.recoveryModeAtStart = checkRecoveryMode();\n\n        // Perform the appropriate liquidation sequence - tally the values, and obtain their totals\n        if (L.recoveryModeAtStart == true) {\n            T = _getTotalsFromLiquidateTrovesSequence_RecoveryMode(L.price, L.LUSDInStabPool, _n);\n        } else if (L.recoveryModeAtStart == false) {\n            T = _getTotalsFromLiquidateTrovesSequence_NormalMode(L.price, L.LUSDInStabPool, _n);\n        }\n\n        // Move liquidated ETH and LUSD to the appropriate pools\n        stabilityPool.offset(T.totalDebtToOffset, T.totalCollToSendToSP);\n        _redistributeDebtAndColl(T.totalDebtToRedistribute, T.totalCollToRedistribute);\n\n        // Update system snapshots and the final partially liquidated trove, if there is one\n        _updateSystemSnapshots_excludeCollRemainder(T.partialNewColl.add(T.totalCollGasCompensation));\n        _updatePartiallyLiquidatedTrove(T.partialAddr, T.partialNewDebt, T.partialNewColl, T.partialUpperHint, T. partialLowerHint, L.price);\n\n        L.liquidatedDebt = T.totalDebtInSequence.sub(T.partialNewDebt);\n        L.liquidatedColl = T.totalCollInSequence.sub(T.totalCollGasCompensation).sub(T.partialNewColl);\n        emit Liquidation(L.liquidatedDebt, L.liquidatedColl, T.totalCollGasCompensation, T.totalLUSDGasCompensation);\n\n        // Send gas compensation to caller\n        _sendGasCompensation(msg.sender, T.totalLUSDGasCompensation, T.totalCollGasCompensation);\n    }\n\n    /*\n    * This function is used when the liquidateTroves sequence starts during Recovery Mode. However, it\n    * handle the case where the system *leaves* Recovery Mode, part way through the liquidation sequence\n    */\n    function _getTotalsFromLiquidateTrovesSequence_RecoveryMode\n    (\n        uint _price,\n        uint _LUSDInStabPool,\n        uint _n\n    )\n        internal\n        returns(LiquidationTotals memory T)\n    {\n        LocalVariables_LiquidationSequence memory L;\n        LiquidationValues memory V;\n\n        L.remainingLUSDInStabPool = _LUSDInStabPool;\n        L.backToNormalMode = false;\n        L.entireSystemDebt = activePool.getLUSDDebt().add(defaultPool.getLUSDDebt());\n        L.entireSystemColl = activePool.getETH().add(defaultPool.getETH());\n\n        L.i = 0;\n        while (L.i < _n) {\n            L.user = sortedTroves.getLast();\n            L.ICR = getCurrentICR(L.user, _price);\n\n            if (L.backToNormalMode == false) {\n                // Break the loop if ICR is greater than MCR and Stability Pool is empty\n                if (L.ICR >= MCR && L.remainingLUSDInStabPool == 0) { break; }\n\n                uint TCR = LiquityMath._computeCR(L.entireSystemColl, L.entireSystemDebt, _price);\n        \n                V = _liquidateRecoveryMode(L.user, L.ICR, L.remainingLUSDInStabPool, TCR);\n\n                // Update aggregate trackers\n                L.remainingLUSDInStabPool = L.remainingLUSDInStabPool.sub(V.debtToOffset);\n                L.entireSystemDebt = L.entireSystemDebt.sub(V.debtToOffset);\n                L.entireSystemColl = L.entireSystemColl.sub(V.collToSendToSP);\n\n                // Add liquidation values to their respective running totals\n                T = _addLiquidationValuesToTotals(T, V);\n\n                // Break the loop if it was a partial liquidation\n                if (V.partialAddr != address(0)) {break;}\n\n                L.backToNormalMode = !_checkPotentialRecoveryMode(L.entireSystemColl, L.entireSystemDebt, _price);\n            }\n            else if (L.backToNormalMode == true && L.ICR < MCR) {\n                V = _liquidateNormalMode(L.user, L.remainingLUSDInStabPool);\n\n                L.remainingLUSDInStabPool = L.remainingLUSDInStabPool.sub(V.debtToOffset);\n\n                // Add liquidation values to their respective running totals\n                T = _addLiquidationValuesToTotals(T, V);\n\n            }  else break;  // break if the loop reaches a Trove with ICR >= MCR\n\n            // Break the loop if it reaches the first Trove in the sorted list\n            if (L.user == sortedTroves.getFirst()) { break; }\n\n            L.i++;\n        }\n    }\n\n    function _getTotalsFromLiquidateTrovesSequence_NormalMode\n    (\n        uint _price,\n        uint _LUSDInStabPool,\n        uint _n\n    )\n        internal\n        returns(LiquidationTotals memory T)\n    {\n        LocalVariables_LiquidationSequence memory L;\n        LiquidationValues memory V;\n\n        L.remainingLUSDInStabPool = _LUSDInStabPool;\n\n        L.i = 0;\n        while (L.i < _n) {\n            L.user = sortedTroves.getLast();\n            L.ICR = getCurrentICR(L.user, _price);\n\n            if (L.ICR < MCR) {\n                V = _liquidateNormalMode(L.user, L.remainingLUSDInStabPool);\n\n                L.remainingLUSDInStabPool = L.remainingLUSDInStabPool.sub(V.debtToOffset);\n\n                // Add liquidation values to their respective running totals\n                T = _addLiquidationValuesToTotals(T, V);\n\n            } else break;  // break if the loop reaches a Trove with ICR >= MCR\n\n            // Break the loop if it reaches the first Trove in the sorted list\n            if (L.user == sortedTroves.getFirst()) { break; }\n            L.i++;\n        }\n    }\n\n    /* \n    * Attempt to liquidate a custom list of troves provided by the caller. The liquidation sequence stops if\n    * a partial liquidation is performed, so it's up to the caller to order the troves in the _troveArray parameter.\n    */\n    function batchLiquidateTroves(address[] memory _troveArray) public override {\n        require(_troveArray.length != 0, \"TroveManager: Calldata address array must not be empty\");\n\n        LocalVariables_OuterLiquidationFunction memory L;\n        LiquidationTotals memory T;\n\n        L.price = priceFeed.getPrice();\n        L.LUSDInStabPool = stabilityPool.getTotalLUSDDeposits();\n        L.recoveryModeAtStart = checkRecoveryMode();\n\n        // Perform the appropriate liquidation sequence - tally values and obtain their totals.\n        if (L.recoveryModeAtStart == true) {\n           T = _getTotalFromBatchLiquidate_RecoveryMode(L.price, L.LUSDInStabPool, _troveArray);\n        } else if (L.recoveryModeAtStart == false) {\n            T = _getTotalsFromBatchLiquidate_NormalMode(L.price, L.LUSDInStabPool, _troveArray);\n        }\n\n        // Move liquidated ETH and LUSD to the appropriate pools\n        stabilityPool.offset(T.totalDebtToOffset, T.totalCollToSendToSP);\n        _redistributeDebtAndColl(T.totalDebtToRedistribute, T.totalCollToRedistribute);\n\n        // Update system snapshots and the final partially liquidated trove, if there is one\n        _updateSystemSnapshots_excludeCollRemainder(T.partialNewColl.add(T.totalCollGasCompensation));\n        _updatePartiallyLiquidatedTrove(T.partialAddr, T.partialNewDebt, T.partialNewColl, T.partialUpperHint, T. partialLowerHint, L.price);\n\n        L.liquidatedDebt = T.totalDebtInSequence.sub(T.partialNewDebt);\n        L.liquidatedColl = T.totalCollInSequence.sub(T.totalCollGasCompensation).sub(T.partialNewColl);\n        emit Liquidation(L.liquidatedDebt, L.liquidatedColl, T.totalCollGasCompensation, T.totalLUSDGasCompensation);\n\n        // Send gas compensation to caller\n        _sendGasCompensation(msg.sender, T.totalLUSDGasCompensation, T.totalCollGasCompensation);\n    }\n\n    /* \n    * This function is used when the batch liquidation sequence starts during Recovery Mode. However, it\n    * handle the case where the system *leaves* Recovery Mode, part way through the liquidation sequence\n    */\n    function _getTotalFromBatchLiquidate_RecoveryMode\n    (\n        uint _price,\n        uint _LUSDInStabPool,\n        address[] memory _troveArray)\n        internal\n        returns(LiquidationTotals memory T)\n    {\n        LocalVariables_LiquidationSequence memory L;\n        LiquidationValues memory V;\n\n        L.remainingLUSDInStabPool = _LUSDInStabPool;\n        L.backToNormalMode = false;\n        L.entireSystemDebt = activePool.getLUSDDebt().add(defaultPool.getLUSDDebt());\n        L.entireSystemColl = activePool.getETH().add(defaultPool.getETH());\n\n        L.i = 0;\n        for (L.i = 0; L.i < _troveArray.length; L.i++) {\n            L.user = _troveArray[L.i];\n            L.ICR = getCurrentICR(L.user, _price);\n\n            if (L.backToNormalMode == false) {\n\n                // Skip this trove if ICR is greater than MCR and Stability Pool is empty\n                if (L.ICR >= MCR && L.remainingLUSDInStabPool == 0) { continue; }\n\n                uint TCR = LiquityMath._computeCR(L.entireSystemColl, L.entireSystemDebt, _price);\n\n                V = _liquidateRecoveryMode(L.user, L.ICR, L.remainingLUSDInStabPool, TCR);\n\n                // Update aggregate trackers\n                L.remainingLUSDInStabPool = L.remainingLUSDInStabPool.sub(V.debtToOffset);\n                L.entireSystemDebt = L.entireSystemDebt.sub(V.debtToOffset);\n                L.entireSystemColl = L.entireSystemColl.sub(V.collToSendToSP);\n\n                // Add liquidation values to their respective running totals\n                T = _addLiquidationValuesToTotals(T, V);\n\n                // Break the loop if it was a partial liquidation\n                if (V.partialAddr != address(0)) { break; }\n\n                L.backToNormalMode = !_checkPotentialRecoveryMode(L.entireSystemColl, L.entireSystemDebt, _price);\n            }\n\n            else if (L.backToNormalMode == true && L.ICR < MCR) {\n                V = _liquidateNormalMode(L.user, L.remainingLUSDInStabPool);\n                L.remainingLUSDInStabPool = L.remainingLUSDInStabPool.sub(V.debtToOffset);\n\n                // Add liquidation values to their respective running totals\n                T = _addLiquidationValuesToTotals(T, V);\n            }\n        }\n    }\n\n    function _getTotalsFromBatchLiquidate_NormalMode\n    (\n        uint _price,\n        uint _LUSDInStabPool,\n        address[] memory _troveArray\n    )\n        internal\n        returns(LiquidationTotals memory T)\n    {\n        LocalVariables_LiquidationSequence memory L;\n        LiquidationValues memory V;\n\n        L.remainingLUSDInStabPool = _LUSDInStabPool;\n\n        for (L.i = 0; L.i < _troveArray.length; L.i++) {\n            L.user = _troveArray[L.i];\n            L.ICR = getCurrentICR(L.user, _price);\n\n            if (L.ICR < MCR) {\n                V = _liquidateNormalMode(L.user, L.remainingLUSDInStabPool);\n                L.remainingLUSDInStabPool = L.remainingLUSDInStabPool.sub(V.debtToOffset);\n\n                // Add liquidation values to their respective running totals\n                T = _addLiquidationValuesToTotals(T, V);\n            }\n        }\n    }\n\n    // --- Liquidation helper functions ---\n\n    function _addLiquidationValuesToTotals(LiquidationTotals memory T1, LiquidationValues memory V)\n    internal pure returns(LiquidationTotals memory T2) {\n\n        // Tally all the values with their respective running totals\n        T2.totalCollGasCompensation = T1.totalCollGasCompensation.add(V.collGasCompensation);\n        T2.totalLUSDGasCompensation = T1.totalLUSDGasCompensation.add(V.LUSDGasCompensation);\n        T2.totalDebtInSequence = T1.totalDebtInSequence.add(V.entireTroveDebt);\n        T2.totalCollInSequence = T1.totalCollInSequence.add(V.entireTroveColl);\n        T2.totalDebtToOffset = T1.totalDebtToOffset.add(V.debtToOffset);\n        T2.totalCollToSendToSP = T1.totalCollToSendToSP.add(V.collToSendToSP);\n        T2.totalDebtToRedistribute = T1.totalDebtToRedistribute.add(V.debtToRedistribute);\n        T2.totalCollToRedistribute = T1.totalCollToRedistribute.add(V.collToRedistribute);\n\n        // Assign the address of the partially liquidated trove, and its new debt and coll values\n        T2.partialAddr = V.partialAddr;\n        T2.partialNewDebt = V.partialNewDebt;\n        T2.partialNewColl = V.partialNewColl;\n        T2.partialUpperHint = V.partialUpperHint;\n        T2.partialLowerHint = V.partialLowerHint;\n\n        return T2;\n    }\n\n    // Update the properties of the partially liquidated trove, and insert it back to the list\n    function _updatePartiallyLiquidatedTrove\n    (\n        address _borrower, \n        uint _newDebt, \n        uint _newColl, \n        address _upperHint,\n        address _lowerHint,\n        uint _price\n    ) \n        internal \n    {\n        if ( _borrower == address(0)) { return; }\n\n        Troves[_borrower].debt = _newDebt;\n        Troves[_borrower].coll = _newColl;\n        Troves[_borrower].status = Status.active;\n\n        _updateTroveRewardSnapshots(_borrower);\n        _updateStakeAndTotalStakes(_borrower);\n\n        uint ICR = getCurrentICR(_borrower, _price);\n\n        /* \n        * Insert to sorted list and add to TroveOwners array. The partially liquidated trove has the same\n        * ICR as it did before the liquidation, so insertion is O(1): in principle, its ICR does not change.\n        * In practice, due to rounding error, its ICR can change slightly - so re-insert, with its previous neighbours\n        * as hints.\n        */\n        sortedTroves.insert(_borrower, ICR, _price, _upperHint, _lowerHint);\n        _addTroveOwnerToArray(_borrower);\n        emit TroveUpdated(_borrower, _newDebt, _newColl, Troves[_borrower].stake, TroveManagerOperation.partiallyLiquidateInRecoveryMode);\n    }\n\n    function _sendGasCompensation(address _liquidator, uint _LUSD, uint _ETH) internal {\n        if (_LUSD > 0) {\n            lusdToken.returnFromPool(GAS_POOL_ADDRESS, _liquidator, _LUSD);\n        }\n\n        if (_ETH > 0) {\n            activePool.sendETH(_liquidator, _ETH);\n        }\n    }\n\n    // Move a Trove's pending debt and collateral rewards from distributions, from the Default Pool to the Active Pool\n    function _movePendingTroveRewardsToActivePool(uint _LUSD, uint _ETH) internal {\n        defaultPool.decreaseLUSDDebt(_LUSD);\n        activePool.increaseLUSDDebt(_LUSD);\n        defaultPool.sendETH(address(activePool), _ETH);\n    }\n\n    // --- Redemption functions ---\n\n    // Redeem as much collateral as possible from _borrower's Trove in exchange for LUSD up to _maxLUSDamount\n    function _redeemCollateralFromTrove(\n        address _borrower,\n        uint _maxLUSDamount,\n        uint _price,\n        address _partialRedemptionHint,\n        uint _partialRedemptionHintICR\n    )\n        internal returns (SingleRedemptionValues memory V)\n    {\n        // Determine the remaining amount (lot) to be redeemed, capped by the entire debt of the Trove minus the gas compensation\n        V.LUSDLot = LiquityMath._min(_maxLUSDamount, Troves[_borrower].debt.sub(LUSD_GAS_COMPENSATION));\n\n        // Get the ETHLot of equivalent value in USD\n        V.ETHLot = V.LUSDLot.mul(1e18).div(_price);\n\n        // Decrease the debt and collateral of the current Trove according to the LUSD lot and corresponding ETH to send\n        uint newDebt = (Troves[_borrower].debt).sub(V.LUSDLot);\n        uint newColl = (Troves[_borrower].coll).sub(V.ETHLot);\n\n        if (newDebt == LUSD_GAS_COMPENSATION) {\n            // No debt left in the Trove (except for the gas compensation), therefore the trove gets closed\n            _removeStake(_borrower);\n            _closeTrove(_borrower);\n            _redeemCloseTrove(_borrower, LUSD_GAS_COMPENSATION, newColl);\n\n        } else {\n            uint newICR = LiquityMath._computeCR(newColl, newDebt, _price);\n\n            // Check if the provided hint is fresh. If not, we bail since trying to reinsert without a good hint will almost\n            // certainly result in running out of gas.\n            if (newICR != _partialRedemptionHintICR) {\n                V.LUSDLot = 0;\n                V.ETHLot = 0;\n                return V;\n            }\n\n            sortedTroves.reInsert(_borrower, newICR, _price, _partialRedemptionHint, _partialRedemptionHint);\n\n            Troves[_borrower].debt = newDebt;\n            Troves[_borrower].coll = newColl;\n            _updateStakeAndTotalStakes(_borrower);\n        }\n        emit TroveUpdated(\n            _borrower,\n            newDebt, newColl,\n            Troves[_borrower].stake,\n            TroveManagerOperation.redeemCollateral\n        );\n        return V;\n    }\n\n    /* \n    * Called when a full redemption occurs, and closes the trove.\n    * The redeemer swaps (debt - 10) LUSD for (debt - 10) worth of ETH, so the 10 LUSD gas compensation left corresponds to the remaining debt.\n    * In order to close the trove, the 10 LUSD gas compensation is burned, and 10 debt is removed from the active pool.\n    * The debt recorded on the trove's struct is zero'd elswhere, in _closeTrove.\n    * Any surplus ETH left in the trove, is sent to the Coll surplus pool, and can be later claimed by the borrower.\n    */ \n    function _redeemCloseTrove(address _borrower, uint _LUSD, uint _ETH) internal {\n        lusdToken.burn(GAS_POOL_ADDRESS, _LUSD);\n        // Update Active Pool LUSD, and send ETH to account\n        activePool.decreaseLUSDDebt(_LUSD);\n\n        // send ETH from Active Pool to CollSurplus Pool\n        collSurplusPool.accountSurplus(_borrower, _ETH);\n        activePool.sendETH(address(collSurplusPool), _ETH);\n    }\n\n    function _isValidFirstRedemptionHint(address _firstRedemptionHint, uint _price) internal view returns (bool) {\n        if (_firstRedemptionHint == address(0) ||\n            !sortedTroves.contains(_firstRedemptionHint) ||\n            getCurrentICR(_firstRedemptionHint, _price) < MCR\n        ) {\n            return false;\n        }\n\n        address nextTrove = sortedTroves.getNext(_firstRedemptionHint);\n        return nextTrove == address(0) || getCurrentICR(nextTrove, _price) < MCR;\n    }\n\n    /* Send _LUSDamount LUSD to the system and redeem the corresponding amount of collateral from as many Troves as are needed to fill the redemption\n    * request.  Applies pending rewards to a Trove before reducing its debt and coll.\n    *\n    * Note that if _amount is very large, this function can run out of gas, specially if traversed troves are small. This can be easily avoided by \n    * splitting the total _amount in appropriate chunks and calling the function multiple times.\n    * \n    * Param `_maxIterations` can also be provided, so the loop through Troves is capped (if its zero, it will be ignored).This makes it easier to \n    * avoid OOG for the frontend, as only knowing approximately the average cost of an iteration is enough, without needing to know the topology \n    * of the trove list. It also avoids the need to set the cap in stone in the contract, nor doing gas calculations, as both gas price and opcode \n    * costs can vary.\n    * \n    * All Troves that are redeemed from -- with the likely exception of the last one -- will end up with no debt left, therefore they will be closed.\n    * If the last Trove does have some remaining debt, it has a finite ICR, and the reinsertion could be anywhere in the list, therefore it requires a hint. \n    * A frontend should use getRedemptionHints() to calculate what the ICR of this Trove will be after redemption, and pass a hint for its position \n    * in the sortedTroves list along with the ICR value that the hint was found for.\n    * \n    * If another transaction modifies the list between calling getRedemptionHints() and passing the hints to redeemCollateral(), it\n    * is very likely that the last (partially) redeemed Trove would end up with a different ICR than what the hint is for. In this case the\n    * redemption will stop after the last completely redeemed Trove and the sender will keep the remaining LUSD amount, which they can attempt\n    * to redeem later.\n    */\n    function redeemCollateral(\n        uint _LUSDamount,\n        address _firstRedemptionHint,\n        address _partialRedemptionHint,\n        uint _partialRedemptionHintICR,\n        uint _maxIterations\n    )\n        external\n        override\n    {\n        uint activeDebt = activePool.getLUSDDebt();\n        uint defaultedDebt = defaultPool.getLUSDDebt();\n\n        RedemptionTotals memory T;\n\n        _requireAmountGreaterThanZero(_LUSDamount);\n        _requireLUSDBalanceCoversRedemption(msg.sender, _LUSDamount);\n\n        // Confirm redeemer's balance is less than total systemic debt\n        assert(lusdToken.balanceOf(msg.sender) <= (activeDebt.add(defaultedDebt)));\n\n        uint remainingLUSD = _LUSDamount;\n        uint price = priceFeed.getPrice();\n        address currentBorrower;\n\n        if (_isValidFirstRedemptionHint(_firstRedemptionHint, price)) {\n            currentBorrower = _firstRedemptionHint;\n        } else {\n            currentBorrower = sortedTroves.getLast();\n            // Find the first trove with ICR >= MCR\n            // SWC-104-Unchecked Call Return Value: L920\n            while (currentBorrower != address(0) && getCurrentICR(currentBorrower, price) < MCR) {\n                currentBorrower = sortedTroves.getPrev(currentBorrower);\n            }\n        }\n\n        // Loop through the Troves starting from the one with lowest collateral ratio until _amount of LUSD is exchanged for collateral\n        if (_maxIterations == 0) { _maxIterations = uint(-1); }\n        while (currentBorrower != address(0) && remainingLUSD > 0 && _maxIterations > 0) {\n            _maxIterations--;\n            // Save the address of the Trove preceding the current one, before potentially modifying the list\n            address nextUserToCheck = sortedTroves.getPrev(currentBorrower);\n\n            _applyPendingRewards(currentBorrower);\n            SingleRedemptionValues memory V = _redeemCollateralFromTrove(\n                currentBorrower,\n                remainingLUSD,\n                price,\n                _partialRedemptionHint,\n                _partialRedemptionHintICR\n            );\n\n            if (V.LUSDLot == 0) break; // Partial redemption hint got out-of-date, therefore we could not redeem from the last Trove\n\n            T.totalLUSDToRedeem  = T.totalLUSDToRedeem.add(V.LUSDLot);\n            T.totalETHDrawn = T.totalETHDrawn.add(V.ETHLot);\n\n            remainingLUSD = remainingLUSD.sub(V.LUSDLot);\n            currentBorrower = nextUserToCheck;\n        }\n\n        // Decay the baseRate due to time passed, and then increase it according to the size of this redemption\n        _updateBaseRateFromRedemption(T.totalETHDrawn, price);\n\n        // Calculate the ETH fee and send it to the LQTY staking contract\n        T.ETHFee = _getRedemptionFee(T.totalETHDrawn);\n        activePool.sendETH(lqtyStakingAddress, T.ETHFee);\n        lqtyStaking.increaseF_ETH(T.ETHFee);\n\n        T.ETHToSendToRedeemer = T.totalETHDrawn.sub(T.ETHFee);\n\n        // Burn the total LUSD that is cancelled with debt, and send the redeemed ETH to msg.sender\n        _activePoolRedeemCollateral(msg.sender, T.totalLUSDToRedeem, T.ETHToSendToRedeemer);\n\n        emit Redemption(_LUSDamount, T.totalLUSDToRedeem, T.totalETHDrawn, T.ETHFee);\n    }\n\n    // Burn the received LUSD, transfer the redeemed ETH to _redeemer and updates the Active Pool\n    function _activePoolRedeemCollateral(address _redeemer, uint _LUSD, uint _ETH) internal {\n        // Update Active Pool LUSD, and send ETH to account\n        lusdToken.burn(_redeemer, _LUSD);\n        activePool.decreaseLUSDDebt(_LUSD);\n\n        activePool.sendETH(_redeemer, _ETH);\n    }\n\n    // --- Helper functions ---\n\n\n    // Return the current collateral ratio (ICR) of a given Trove. Takes a trove's pending coll and debt rewards from redistributions into account.\n    function getCurrentICR(address _borrower, uint _price) public view override returns (uint) {\n        uint pendingETHReward = getPendingETHReward(_borrower);\n        uint pendingLUSDDebtReward = getPendingLUSDDebtReward(_borrower);\n\n        uint currentETH = Troves[_borrower].coll.add(pendingETHReward);\n        uint currentLUSDDebt = Troves[_borrower].debt.add(pendingLUSDDebtReward);\n\n        uint ICR = LiquityMath._computeCR(currentETH, currentLUSDDebt, _price);\n        return ICR;\n    }\n\n    function applyPendingRewards(address _borrower) external override {\n        _requireCallerIsBorrowerOperations();\n        return _applyPendingRewards(_borrower);\n    }\n\n    // Add the borrowers's coll and debt rewards earned from redistributions, to their Trove\n    function _applyPendingRewards(address _borrower) internal {\n        if (hasPendingRewards(_borrower)) {\n            _requireTroveisActive(_borrower);\n\n            // Compute pending rewards\n            uint pendingETHReward = getPendingETHReward(_borrower);\n            uint pendingLUSDDebtReward = getPendingLUSDDebtReward(_borrower);\n\n            // Apply pending rewards to trove's state\n            Troves[_borrower].coll = Troves[_borrower].coll.add(pendingETHReward);\n            Troves[_borrower].debt = Troves[_borrower].debt.add(pendingLUSDDebtReward);\n\n            _updateTroveRewardSnapshots(_borrower);\n\n            // Transfer from DefaultPool to ActivePool\n            _movePendingTroveRewardsToActivePool(pendingLUSDDebtReward, pendingETHReward);\n\n            emit TroveUpdated(\n                _borrower, \n                Troves[_borrower].debt, \n                Troves[_borrower].coll, \n                Troves[_borrower].stake, \n                TroveManagerOperation.applyPendingRewards\n            );\n        }\n    }\n\n    // Update borrower's snapshots of L_ETH and L_LUSDDebt to reflect the current values\n    function updateTroveRewardSnapshots(address _borrower) external override {\n        _requireCallerIsBorrowerOperations();\n       return _updateTroveRewardSnapshots(_borrower);\n    }\n\n    function _updateTroveRewardSnapshots(address _borrower) internal {\n        rewardSnapshots[_borrower].ETH = L_ETH;\n        rewardSnapshots[_borrower].LUSDDebt = L_LUSDDebt;\n    }\n\n    // Get the borrower's pending accumulated ETH reward, earned by their stake\n    function getPendingETHReward(address _borrower) public view override returns (uint) {\n        uint snapshotETH = rewardSnapshots[_borrower].ETH;\n        uint rewardPerUnitStaked = L_ETH.sub(snapshotETH);\n\n        if ( rewardPerUnitStaked == 0 ) { return 0; }\n\n        uint stake = Troves[_borrower].stake;\n\n        uint pendingETHReward = stake.mul(rewardPerUnitStaked).div(1e18);\n\n        return pendingETHReward;\n    }\n\n     // Get the borrower's pending accumulated LUSD reward, earned by their stake\n    function getPendingLUSDDebtReward(address _borrower) public view override returns (uint) {\n        uint snapshotLUSDDebt = rewardSnapshots[_borrower].LUSDDebt;\n        uint rewardPerUnitStaked = L_LUSDDebt.sub(snapshotLUSDDebt);\n\n        if ( rewardPerUnitStaked == 0 ) { return 0; }\n\n        uint stake =  Troves[_borrower].stake;\n\n        uint pendingLUSDDebtReward = stake.mul(rewardPerUnitStaked).div(1e18);\n\n        return pendingLUSDDebtReward;\n    }\n\n    function hasPendingRewards(address _borrower) public view override returns (bool) {\n        /* \n        * A Trove has pending rewards if its snapshot is less than the current rewards per-unit-staked sum:\n        * this indicates that rewards have occured since the snapshot was made, and the user therefore has\n        * pending rewards \n        */\n        return (rewardSnapshots[_borrower].ETH < L_ETH);\n    }\n\n    // Return the Troves entire debt and coll, including pending rewards from redistributions.\n    function getEntireDebtAndColl(\n        address _borrower\n    )\n        public\n        view\n        override\n        returns (uint debt, uint coll, uint pendingLUSDDebtReward, uint pendingETHReward)\n    {\n        debt = Troves[_borrower].debt;\n        coll = Troves[_borrower].coll;\n\n        pendingLUSDDebtReward = getPendingLUSDDebtReward(_borrower);\n        pendingETHReward = getPendingETHReward(_borrower);\n\n        debt = debt.add(pendingLUSDDebtReward);\n        coll = coll.add(pendingETHReward);\n    }\n\n    function removeStake(address _borrower) external override {\n        _requireCallerIsBorrowerOperations();\n        return _removeStake(_borrower);\n    }\n\n    // Remove borrower's stake from the totalStakes sum, and set their stake to 0\n    function _removeStake(address _borrower) internal {\n        uint stake = Troves[_borrower].stake;\n        totalStakes = totalStakes.sub(stake);\n        Troves[_borrower].stake = 0;\n    }\n\n    function updateStakeAndTotalStakes(address _borrower) external override returns (uint) {\n        _requireCallerIsBorrowerOperations();\n        return _updateStakeAndTotalStakes(_borrower);\n    }\n\n    // Update borrower's stake based on their latest collateral value\n    function _updateStakeAndTotalStakes(address _borrower) internal returns (uint) {\n        uint newStake = _computeNewStake(Troves[_borrower].coll);\n        uint oldStake = Troves[_borrower].stake;\n        Troves[_borrower].stake = newStake;\n        totalStakes = totalStakes.sub(oldStake).add(newStake);\n\n        return newStake;\n    }\n\n    // Calculate a new stake based on the snapshots of the totalStakes and totalCollateral taken at the last liquidation\n    function _computeNewStake(uint _coll) internal view returns (uint) {\n        uint stake;\n        if (totalCollateralSnapshot == 0) {\n            stake = _coll;\n        } else {\n            /*  \n            * The following assert() holds true because:\n            * - The system always contains >= 1 trove \n            * - When we close or liquidate a trove, we redistribute the pending rewards, so if all troves were closed/liquidated, \n            * rewards wouldve been emptied and totalCollateralSnapshot would be zero too.\n            */\n            assert(totalStakesSnapshot > 0);\n            stake = _coll.mul(totalStakesSnapshot).div(totalCollateralSnapshot);\n        }\n        return stake;\n    }\n\n    function _redistributeDebtAndColl(uint _debt, uint _coll) internal {\n        if (_debt == 0) { return; }\n\n        if (totalStakes > 0) {\n            /* \n            * Add distributed coll and debt rewards-per-unit-staked to the running totals.\n            * Division uses a \"feedback\" error correction, to keep the cumulative error in\n            * the  L_ETH and L_LUSDDebt state variables low. \n            */\n            uint ETHNumerator = _coll.mul(1e18).add(lastETHError_Redistribution);\n            uint LUSDDebtNumerator = _debt.mul(1e18).add(lastLUSDDebtError_Redistribution);\n\n            uint ETHRewardPerUnitStaked = ETHNumerator.div(totalStakes);\n            uint LUSDDebtRewardPerUnitStaked = LUSDDebtNumerator.div(totalStakes);\n\n            lastETHError_Redistribution = ETHNumerator.sub(ETHRewardPerUnitStaked.mul(totalStakes));\n            lastLUSDDebtError_Redistribution = LUSDDebtNumerator.sub(LUSDDebtRewardPerUnitStaked.mul(totalStakes));\n\n            L_ETH = L_ETH.add(ETHRewardPerUnitStaked);\n            L_LUSDDebt = L_LUSDDebt.add(LUSDDebtRewardPerUnitStaked);\n        }\n\n        // Transfer coll and debt from ActivePool to DefaultPool\n        activePool.decreaseLUSDDebt(_debt);\n        defaultPool.increaseLUSDDebt(_debt);\n        activePool.sendETH(address(defaultPool), _coll);\n    }\n\n    function closeTrove(address _borrower) external override {\n        _requireCallerIsBorrowerOperations();\n        return _closeTrove(_borrower);\n    }\n\n    function _closeTrove(address _borrower) internal {\n        uint TroveOwnersArrayLength = TroveOwners.length;\n        _requireMoreThanOneTroveInSystem(TroveOwnersArrayLength);\n\n        Troves[_borrower].status = Status.closed;\n        Troves[_borrower].coll = 0;\n        Troves[_borrower].debt = 0;\n\n        rewardSnapshots[_borrower].ETH = 0;\n        rewardSnapshots[_borrower].LUSDDebt = 0;\n\n        _removeTroveOwner(_borrower, TroveOwnersArrayLength);\n        sortedTroves.remove(_borrower);\n    }\n\n    /* \n    * Updates snapshots of system total stakes and total collateral, excluding a given collateral remainder from the calculation. \n    * Used in a liquidation sequence.\n    *\n    * The calculation excludes two portions of collateral that are in the ActivePool: \n    *\n    * 1) the total ETH gas compensation from the liquidation sequence\n    * 2) The remaining collateral in a partially liquidated trove (if one occurred)\n    *\n    * The ETH as compensation must be excluded as it is always sent out at the very end of the liquidation sequence.\n    *\n    * The partially liquidated trove's remaining collateral stays in the ActivePool, but it is excluded here so the system \n    * can take snapshots before the partially liquidated trove's stake is updated (based on these snapshots). This ensures\n    * the partial's new stake doesn't double-count its own remaining collateral.\n    *\n    */\n    function _updateSystemSnapshots_excludeCollRemainder(uint _collRemainder) internal {\n        totalStakesSnapshot = totalStakes;\n\n        uint activeColl = activePool.getETH();\n        uint liquidatedColl = defaultPool.getETH();\n        totalCollateralSnapshot = activeColl.sub(_collRemainder).add(liquidatedColl);\n    }\n\n    // Push the owner's address to the Trove owners list, and record the corresponding array index on the Trove struct\n    function addTroveOwnerToArray(address _borrower) external override returns (uint index) {\n        _requireCallerIsBorrowerOperations();\n        return _addTroveOwnerToArray(_borrower);\n    }\n\n    function _addTroveOwnerToArray(address _borrower) internal returns (uint128 index) {\n        require(TroveOwners.length < 2**128 - 1, \"TroveManager: TroveOwners array has maximum size of 2^128 - 1\");\n\n        // Push the Troveowner to the array\n        TroveOwners.push(_borrower);\n\n        // Record the index of the new Troveowner on their Trove struct\n        index = uint128(TroveOwners.length.sub(1));\n        Troves[_borrower].arrayIndex = index;\n\n        return index;\n    }\n\n    /* \n    * Remove a Trove owner from the TroveOwners array, not preserving array order. Removing owner 'B' does the following:\n    * [A B C D E] => [A E C D], and updates E's Trove struct to point to its new array index. \n    */\n    function _removeTroveOwner(address _borrower, uint TroveOwnersArrayLength) internal {\n        require(Troves[_borrower].status == Status.closed, \"TroveManager: Trove is still active\");\n\n        uint128 index = Troves[_borrower].arrayIndex;\n        uint length = TroveOwnersArrayLength;\n        uint idxLast = length.sub(1);\n\n        assert(index <= idxLast);\n\n        address addressToMove = TroveOwners[idxLast];\n\n        TroveOwners[index] = addressToMove;\n        Troves[addressToMove].arrayIndex = index;\n        TroveOwners.pop();\n    }\n\n    // --- Recovery Mode and TCR functions ---\n\n    function checkRecoveryMode() public view override returns (bool) {\n        uint TCR = getTCR();\n\n        if (TCR < CCR) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    // Check whether or not the system *would be* in Recovery Mode, given an ETH:USD price, and the entire system coll and debt.\n    function _checkPotentialRecoveryMode(\n        uint _entireSystemColl,\n        uint _entireSystemDebt,\n        uint _price\n    )\n        internal\n        pure\n    returns (bool)\n    {\n        uint TCR = LiquityMath._computeCR(_entireSystemColl, _entireSystemDebt, _price);\n        if (TCR < CCR) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n    // SWC-135-Code With No Effects: L1276-L1284\n    function getTCR() public view override returns (uint TCR) {\n        uint price = priceFeed.getPrice();\n        uint entireSystemColl = getEntireSystemColl();\n        uint entireSystemDebt = getEntireSystemDebt();\n\n        TCR = LiquityMath._computeCR(entireSystemColl, entireSystemDebt, price);\n\n        return TCR;\n    }\n    // SWC-135-Code With No Effects: L1286-L1291\n    function getEntireSystemColl() public view override returns (uint entireSystemColl) {\n        uint activeColl = activePool.getETH();\n        uint liquidatedColl = defaultPool.getETH();\n\n        return activeColl.add(liquidatedColl);\n    }\n\n    function getEntireSystemDebt() public view override returns (uint entireSystemDebt) {\n        uint activeDebt = activePool.getLUSDDebt();\n        uint closedDebt = defaultPool.getLUSDDebt();\n\n        return activeDebt.add(closedDebt);\n    }\n\n    // --- Redemption fee functions ---\n\n    /* \n    * This function has two impacts on the baseRate state variable:\n    * 1) decays the baseRate based on time passed since last redemption or LUSD borrowing operation.\n    * then,\n    * 2) increases the baseRate based on the amount redeemed, as a proportion of total supply\n    */\n    function _updateBaseRateFromRedemption(uint _ETHDrawn,  uint _price) internal returns (uint) {\n        uint decayedBaseRate = _calcDecayedBaseRate();\n\n        uint activeDebt = activePool.getLUSDDebt();\n        uint closedDebt = defaultPool.getLUSDDebt();\n        uint totalLUSDSupply = activeDebt.add(closedDebt);\n\n        /* Convert the drawn ETH back to LUSD at face value rate (1 LUSD:1 USD), in order to get\n        * the fraction of total supply that was redeemed at face value. */\n        uint redeemedLUSDFraction = _ETHDrawn.mul(_price).div(totalLUSDSupply);\n\n        uint newBaseRate = decayedBaseRate.add(redeemedLUSDFraction.div(BETA));\n\n        // Update the baseRate state variable\n        baseRate = newBaseRate < 1e18 ? newBaseRate : 1e18;  // cap baseRate at a maximum of 100%\n        assert(baseRate <= 1e18 && baseRate > 0); // Base rate is always non-zero after redemption\n\n        _updateLastFeeOpTime();\n\n        return baseRate;\n    }\n\n    function _getRedemptionFee(uint _ETHDrawn) internal view returns (uint) {\n       return baseRate.mul(_ETHDrawn).div(1e18);\n    }\n\n    // --- Borrowing fee functions ---\n\n    function getBorrowingFee(uint _LUSDDebt) external view override returns (uint) {\n        return _LUSDDebt.mul(baseRate).div(1e18);\n    }\n\n    // Updates the baseRate state variable based on time elapsed since the last redemption or LUSD borrowing operation.\n    function decayBaseRateFromBorrowing() external override {\n        _requireCallerIsBorrowerOperations();\n\n        baseRate = _calcDecayedBaseRate();\n        assert(baseRate <= 1e18);  // The baseRate can decay to 0\n\n        _updateLastFeeOpTime();\n    }\n\n    // --- Internal fee functions ---\n\n    // Update the last fee operation time only if time passed >= decay interval. This prevents base rate griefing.\n    function _updateLastFeeOpTime() internal {\n        uint timePassed = block.timestamp.sub(lastFeeOperationTime);\n\n        if (timePassed >= SECONDS_IN_ONE_MINUTE) {\n            lastFeeOperationTime = block.timestamp;\n        }\n    }\n\n    function _calcDecayedBaseRate() internal view returns (uint) {\n        uint minutesPassed = _minutesPassedSinceLastFeeOp();\n        uint decayFactor = LiquityMath._decPow(MINUTE_DECAY_FACTOR, minutesPassed);\n\n        return baseRate.mul(decayFactor).div(1e18);\n    }\n\n    function _minutesPassedSinceLastFeeOp() internal view returns (uint) {\n        return (block.timestamp.sub(lastFeeOperationTime)).div(SECONDS_IN_ONE_MINUTE);\n    }\n\n    // --- 'require' wrapper functions ---\n\n    function _requireCallerIsBorrowerOperations() internal view {\n        require(msg.sender == borrowerOperationsAddress, \"TroveManager: Caller is not the BorrowerOperations contract\");\n    }\n\n    function _requireTroveisActive(address _borrower) internal view {\n        require(Troves[_borrower].status == Status.active, \"TroveManager: Trove does not exist or is closed\");\n    }\n\n    function _requireLUSDBalanceCoversRedemption(address _redeemer, uint _amount) internal view {\n        require(lusdToken.balanceOf(_redeemer) >= _amount, \"TroveManager: Requested redemption amount must be <= user's LUSD token balance\");\n    }\n\n    function _requireMoreThanOneTroveInSystem(uint TroveOwnersArrayLength) internal view {\n        require (TroveOwnersArrayLength > 1 && sortedTroves.getSize() > 1, \"TroveManager: Only one trove in the system\");\n    }\n\n    function _requireAmountGreaterThanZero(uint _amount) internal pure {\n        require(_amount > 0, \"TroveManager: Amount must be greater than zero\");\n    }\n\n    // --- Trove property getters ---\n\n    function getTroveStatus(address _borrower) external view override returns (uint) {\n        return uint(Troves[_borrower].status);\n    }\n\n    function getTroveStake(address _borrower) external view override returns (uint) {\n        return Troves[_borrower].stake;\n    }\n\n    function getTroveDebt(address _borrower) external view override returns (uint) {\n        return Troves[_borrower].debt;\n    }\n\n    function getTroveColl(address _borrower) external view override returns (uint) {\n        return Troves[_borrower].coll;\n    }\n\n    // --- Trove property setters, called by BorrowerOperations ---\n\n    function setTroveStatus(address _borrower, uint _num) external override {\n        _requireCallerIsBorrowerOperations();\n        Troves[_borrower].status = Status(_num);\n    }\n\n    function increaseTroveColl(address _borrower, uint _collIncrease) external override returns (uint) {\n        _requireCallerIsBorrowerOperations();\n        uint newColl = Troves[_borrower].coll.add(_collIncrease);\n        Troves[_borrower].coll = newColl;\n        return newColl;\n    }\n\n    function decreaseTroveColl(address _borrower, uint _collDecrease) external override returns (uint) {\n        _requireCallerIsBorrowerOperations();\n        uint newColl = Troves[_borrower].coll.sub(_collDecrease);\n        Troves[_borrower].coll = newColl;\n        return newColl;\n    }\n\n    function increaseTroveDebt(address _borrower, uint _debtIncrease) external override returns (uint) {\n        _requireCallerIsBorrowerOperations();\n        uint newDebt = Troves[_borrower].debt.add(_debtIncrease);\n        Troves[_borrower].debt = newDebt;\n        return newDebt;\n    }\n\n    function decreaseTroveDebt(address _borrower, uint _debtDecrease) external override returns (uint) {\n        _requireCallerIsBorrowerOperations();\n        uint newDebt = Troves[_borrower].debt.sub(_debtDecrease);\n        Troves[_borrower].debt = newDebt;\n        return newDebt;\n    }\n}",
        "function": "getTroveFromTroveOwnersArray(uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-Liquity/dev-f0df3efa5a5f05b205752184cfce107c5bd6e06c/packages/contracts/contracts/TroveManager.sol",
        "vulnerability": "Exception State (SWC 110)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract TroveManager is LiquityBase, Ownable, ITroveManager {\n\n    // --- Connected contract declarations ---\n\n    address public borrowerOperationsAddress;\n\n    IPool public activePool;\n\n    IPool public defaultPool;\n\n    IStabilityPool public stabilityPool;\n\n    ICollSurplusPool collSurplusPool;\n\n    ILUSDToken public lusdToken;\n\n    IPriceFeed public priceFeed;\n\n    ILQTYStaking public lqtyStaking;\n    address public lqtyStakingAddress;\n\n    // A doubly linked list of Troves, sorted by their sorted by their collateral ratios\n    ISortedTroves public sortedTroves;\n\n    // --- Data structures ---\n\n    uint constant public SECONDS_IN_ONE_MINUTE = 60;\n    uint constant public MINUTE_DECAY_FACTOR = 999832508430720967;  // 18 digit decimal. Corresponds to an hourly decay factor of 0.99\n\n    /* \n    * BETA: 18 digit decimal. Parameter by which to divide the redeemed fraction, in order to calc the new base rate from a redemption. \n    * Corresponds to (1 / ALPHA) in the white paper. \n    */\n    uint constant public BETA = 2;\n\n    uint public baseRate;\n\n    // The timestamp of the latest fee operation (redemption or new LUSD issuance) \n    uint public lastFeeOperationTime;\n\n    enum Status { nonExistent, active, closed }\n\n    // Store the necessary data for a trove\n    struct Trove {\n        uint debt;\n        uint coll;\n        uint stake;\n        Status status;\n        uint128 arrayIndex;\n    }\n\n    mapping (address => Trove) public Troves;\n\n    uint public totalStakes;\n\n    // Snapshot of the value of totalStakes, taken immediately after the latest liquidation\n    uint public totalStakesSnapshot;\n\n    // Snapshot of the total collateral across the ActivePool and DefaultPool, immediately after the latest liquidation.\n    uint public totalCollateralSnapshot;\n\n    /*\n    * L_ETH and L_LUSDDebt track the sums of accumulated liquidation rewards per unit staked. During its lifetime, each stake earns:\n    *\n    * An ETH gain of ( stake * [L_ETH - L_ETH(0)] )\n    * A LUSDDebt increase  of ( stake * [L_LUSDDebt - L_LUSDDebt(0)] )\n    *\n    * Where L_ETH(0) and L_LUSDDebt(0) are snapshots of L_ETH and L_LUSDDebt for the active Trove taken at the instant the stake was made\n    */\n    uint public L_ETH;\n    uint public L_LUSDDebt;\n\n    // Map addresses with active troves to their RewardSnapshot\n    mapping (address => RewardSnapshot) public rewardSnapshots;\n\n    // Object containing the ETH and LUSD snapshots for a given active trove\n    struct RewardSnapshot { uint ETH; uint LUSDDebt;}\n\n    // Array of all active trove addresses - used to to compute an approximate hint off-chain, for the sorted list insertion\n    address[] public TroveOwners;\n\n    // Error trackers for the trove redistribution calculation\n    uint public lastETHError_Redistribution;\n    uint public lastLUSDDebtError_Redistribution;\n\n    /* \n    * --- Variable container structs for liquidations ---\n    *\n    * These structs are used to hold, return and assign variables inside the liquidation functions,\n    * in order to avoid the error: \"CompilerError: Stack too deep\". \n    **/\n\n    struct LocalVariables_OuterLiquidationFunction {\n        uint price;\n        uint LUSDInStabPool;\n        bool recoveryModeAtStart;\n        uint liquidatedDebt;\n        uint liquidatedColl;\n    }\n\n    struct LocalVariables_InnerSingleLiquidateFunction {\n        uint collToLiquidate;\n        uint pendingDebtReward;\n        uint pendingCollReward;\n    }\n\n    struct LocalVariables_LiquidationSequence {\n        uint remainingLUSDInStabPool;\n        uint i;\n        uint ICR;\n        address user;\n        bool backToNormalMode;\n        uint entireSystemDebt;\n        uint entireSystemColl;\n    }\n\n    struct LiquidationValues {\n        uint entireTroveDebt;\n        uint entireTroveColl;\n        uint collGasCompensation;\n        uint LUSDGasCompensation;\n        uint debtToOffset;\n        uint collToSendToSP;\n        uint debtToRedistribute;\n        uint collToRedistribute;\n        address partialAddr;\n        uint partialNewDebt;\n        uint partialNewColl;\n        address partialUpperHint;\n        address partialLowerHint;\n    }\n\n    struct LiquidationTotals {\n        uint totalCollInSequence;\n        uint totalDebtInSequence;\n        uint totalCollGasCompensation;\n        uint totalLUSDGasCompensation;\n        uint totalDebtToOffset;\n        uint totalCollToSendToSP;\n        uint totalDebtToRedistribute;\n        uint totalCollToRedistribute;\n        address partialAddr;\n        uint partialNewDebt;\n        uint partialNewColl;\n        address partialUpperHint;\n        address partialLowerHint;\n    }\n\n    // --- Variable container structs for redemptions ---\n\n    struct RedemptionTotals {\n        uint totalLUSDToRedeem;\n        uint totalETHDrawn;\n        uint ETHFee;\n        uint ETHToSendToRedeemer;\n        uint decayedBaseRate;\n    }\n\n    struct SingleRedemptionValues {\n        uint LUSDLot;\n        uint ETHLot;\n    }\n\n    // --- Events ---\n\n    event Liquidation(uint _liquidatedDebt, uint _liquidatedColl, uint _collGasCompensation, uint _LUSDGasCompensation);\n    event Redemption(uint _attemptedLUSDAmount, uint _actualLUSDAmount, uint _ETHSent, uint _ETHFee);\n\n    enum TroveManagerOperation {\n        applyPendingRewards,\n        liquidateInNormalMode,\n        liquidateInRecoveryMode,\n        partiallyLiquidateInRecoveryMode,\n        redeemCollateral\n    }\n\n    event TroveCreated(address indexed _borrower, uint _arrayIndex);\n    event TroveUpdated(address indexed _borrower, uint _debt, uint _coll, uint _stake, TroveManagerOperation _operation);\n    event TroveLiquidated(address indexed _borrower, uint _debt, uint _coll, TroveManagerOperation _operation);\n\n    // --- Dependency setter ---\n\n    function setAddresses(\n        address _borrowerOperationsAddress,\n        address _activePoolAddress,\n        address _defaultPoolAddress,\n        address _stabilityPoolAddress,\n        address _collSurplusPoolAddress,\n        address _priceFeedAddress,\n        address _lusdTokenAddress,\n        address _sortedTrovesAddress,\n        address _lqtyStakingAddress\n    )\n        external\n        override\n        onlyOwner\n    {\n        borrowerOperationsAddress = _borrowerOperationsAddress;\n        activePool = IPool(_activePoolAddress);\n        defaultPool = IPool(_defaultPoolAddress);\n        stabilityPool = IStabilityPool(_stabilityPoolAddress);\n        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);\n        priceFeed = IPriceFeed(_priceFeedAddress);\n        lusdToken = ILUSDToken(_lusdTokenAddress);\n        sortedTroves = ISortedTroves(_sortedTrovesAddress);\n        lqtyStakingAddress = _lqtyStakingAddress;\n        lqtyStaking = ILQTYStaking(_lqtyStakingAddress);\n\n        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);\n        emit ActivePoolAddressChanged(_activePoolAddress);\n        emit DefaultPoolAddressChanged(_defaultPoolAddress);\n        emit StabilityPoolAddressChanged(_stabilityPoolAddress);\n        emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);\n        emit PriceFeedAddressChanged(_priceFeedAddress);\n        emit LUSDTokenAddressChanged(_lusdTokenAddress);\n        emit SortedTrovesAddressChanged(_sortedTrovesAddress);\n        emit LQTYStakingAddressChanged(_lqtyStakingAddress);\n\n        _renounceOwnership();\n    }\n\n    // --- Getters ---\n\n    function getTroveOwnersCount() external view override returns (uint) {\n        return TroveOwners.length;\n    }\n\n    function getTroveFromTroveOwnersArray(uint _index) external view override returns (address) {\n        return TroveOwners[_index];\n    }\n\n    // --- Trove Liquidation functions ---\n\n    // Single liquidation function. Closes the trove if its ICR is lower than the minimum collateral ratio. \n    function liquidate(address _borrower) external override {\n        _requireTroveisActive(_borrower);\n\n        address[] memory borrowers = new address[](1);\n        borrowers[0] = _borrower;\n        batchLiquidateTroves(borrowers);\n    }\n\n    // --- Inner single liquidation functions ---\n\n    // Liquidate one trove, in Normal Mode.\n    function _liquidateNormalMode(address _borrower, uint _LUSDInStabPool) internal returns (LiquidationValues memory V) {\n        LocalVariables_InnerSingleLiquidateFunction memory L;\n\n        (V.entireTroveDebt,\n        V.entireTroveColl,\n        L.pendingDebtReward,\n        L.pendingCollReward) = getEntireDebtAndColl(_borrower);\n\n        _movePendingTroveRewardsToActivePool(L.pendingDebtReward, L.pendingCollReward);\n        _removeStake(_borrower);\n\n        V.collGasCompensation = _getCollGasCompensation(V.entireTroveColl);\n        V.LUSDGasCompensation = LUSD_GAS_COMPENSATION;\n        uint collToLiquidate = V.entireTroveColl.sub(V.collGasCompensation);\n\n        (V.debtToOffset,\n        V.collToSendToSP,\n        V.debtToRedistribute,\n        V.collToRedistribute) = _getOffsetAndRedistributionVals(V.entireTroveDebt, collToLiquidate, _LUSDInStabPool);\n\n        _closeTrove(_borrower);\n        emit TroveLiquidated(_borrower, V.entireTroveDebt, V.entireTroveColl, TroveManagerOperation.liquidateInNormalMode);\n\n        return V;\n    }\n\n    // Liquidate one trove, in Recovery Mode.\n    function _liquidateRecoveryMode(address _borrower, uint _ICR, uint _LUSDInStabPool, uint _TCR) internal returns (LiquidationValues memory V) {\n        LocalVariables_InnerSingleLiquidateFunction memory L;\n        \n        if (TroveOwners.length <= 1) { return V; } // don't liquidate if last trove\n\n        (V.entireTroveDebt,\n        V.entireTroveColl,\n        L.pendingDebtReward,\n        L.pendingCollReward) = getEntireDebtAndColl(_borrower);\n\n        _movePendingTroveRewardsToActivePool(L.pendingDebtReward, L.pendingCollReward);\n\n        V.collGasCompensation = _getCollGasCompensation(V.entireTroveColl);\n        // In case of a partial liquidation, V.LUSDGasCompensation will be overwritten to zero, in the third branch below\n        V.LUSDGasCompensation = LUSD_GAS_COMPENSATION;\n        L.collToLiquidate = V.entireTroveColl.sub(V.collGasCompensation);\n\n        // If ICR <= 100%, purely redistribute the Trove across all active Troves\n        if (_ICR <= _100pct) {\n            _removeStake(_borrower);\n\n            V.debtToOffset = 0;\n            V.collToSendToSP = 0;\n            V.debtToRedistribute = V.entireTroveDebt;\n            V.collToRedistribute = L.collToLiquidate;\n\n            _closeTrove(_borrower);\n            emit TroveLiquidated(_borrower, V.entireTroveDebt, V.entireTroveColl, TroveManagerOperation.liquidateInRecoveryMode);\n\n        // If 100% < ICR < MCR, offset as much as possible, and redistribute the remainder\n        } else if ((_ICR > _100pct) && (_ICR < MCR)) {\n            _removeStake(_borrower);\n\n            (V.debtToOffset,\n            V.collToSendToSP,\n            V.debtToRedistribute,\n            V.collToRedistribute) = _getOffsetAndRedistributionVals(V.entireTroveDebt, L.collToLiquidate, _LUSDInStabPool);\n\n            _closeTrove(_borrower);\n            emit TroveLiquidated(_borrower, V.entireTroveDebt, V.entireTroveColl, TroveManagerOperation.liquidateInRecoveryMode);\n\n        /* \n        * If 110% <= ICR < current TCR (accounting for the preceding liquidations in the current sequence)\n        * and there is LUSD in the Stability Pool, only offset it as much as possible, with no redistribution.\n        */\n        } else if ((_ICR >= MCR) && (_ICR < _TCR)) {\n            assert(_LUSDInStabPool != 0);\n\n            _removeStake(_borrower);\n            \n            V = _getFullOrPartialOffsetVals(_borrower, V.entireTroveDebt, V.entireTroveColl, _LUSDInStabPool);\n\n            _closeTrove(_borrower);\n        }\n        else if (_ICR >= _TCR) {\n            LiquidationValues memory zeroVals;\n            return zeroVals;\n        }\n\n        return V;\n    }\n\n    /* In a full liquidation, returns the values for a trove's coll and debt to be offset, and coll and debt to be \n    * redistributed to active troves. \n    */\n    function _getOffsetAndRedistributionVals\n    (\n        uint _debt,\n        uint _coll,\n        uint _LUSDInStabPool\n    )\n        internal\n        pure\n        returns (uint debtToOffset, uint collToSendToSP, uint debtToRedistribute, uint collToRedistribute)\n    {\n        if (_LUSDInStabPool > 0) {\n        /* \n        * Offset as much debt & collateral as possible against the Stability Pool, and redistribute the remainder\n        * between all active troves.\n        *\n        *  If the trove's debt is larger than the deposited LUSD in the Stability Pool:\n        *\n        *  - Offset an amount of the trove's debt equal to the LUSD in the Stability Pool\n        *  - Send a fraction of the trove's collateral to the Stability Pool, equal to the fraction of its offset debt\n        *\n        */\n            debtToOffset = LiquityMath._min(_debt, _LUSDInStabPool);\n            collToSendToSP = _coll.mul(debtToOffset).div(_debt);\n            debtToRedistribute = _debt.sub(debtToOffset);\n            collToRedistribute = _coll.sub(collToSendToSP);\n        } else {\n            debtToOffset = 0;\n            collToSendToSP = 0;\n            debtToRedistribute = _debt;\n            collToRedistribute = _coll;\n        }\n    }\n\n    /*\n    *  If it is a full offset, get its offset coll/debt and ETH gas comp, and close the trove.\n    *\n    * If it is a partial liquidation, get its offset coll/debt and ETH gas comp, and its new coll/debt, and its re-insertion hints.\n    */\n    function _getFullOrPartialOffsetVals\n    (\n        address _borrower,\n        uint _entireTroveDebt,\n        uint _entireTroveColl,\n        uint _LUSDInStabPool\n    )\n        internal\n        returns (LiquidationValues memory V)\n    {\n        V.entireTroveDebt = _entireTroveDebt;\n        V.entireTroveColl = _entireTroveColl;\n\n        // When Stability Pool can fully absorb the trove's debt, perform a full offset\n        if (_entireTroveDebt <= _LUSDInStabPool) {\n            V.collGasCompensation = _getCollGasCompensation(_entireTroveColl);\n            V.LUSDGasCompensation = LUSD_GAS_COMPENSATION;\n\n            V.debtToOffset = _entireTroveDebt;\n            V.collToSendToSP = _entireTroveColl.sub(V.collGasCompensation);\n            V.debtToRedistribute = 0;\n            V.collToRedistribute = 0;\n\n            emit TroveLiquidated(_borrower, _entireTroveDebt, _entireTroveColl, TroveManagerOperation.liquidateInRecoveryMode);\n        }\n        /* \n        * When trove's debt is greater than the Stability Pool, perform a partial liquidation: offset as much as possible,\n        * and do not redistribute the remainder. The trove remains active, with a reduced collateral and debt.\n        *\n        * ETH gas compensation is based on and drawn from the collateral fraction that corresponds to the partial offset. \n        * LUSD gas compensation is left untouched. \n        *\n        * Since ETH gas comp is drawn purely from the *liquidated* portion, the trove is left with the same ICR as before the \n        * liquidation.\n        */\n        else if (_entireTroveDebt > _LUSDInStabPool) {\n            // Remaining debt in the trove is lower-bounded by the trove's gas compensation\n            V.partialNewDebt = LiquityMath._max(_entireTroveDebt.sub(_LUSDInStabPool), LUSD_GAS_COMPENSATION);\n          \n            V.debtToOffset = _entireTroveDebt.sub(V.partialNewDebt);\n\n            uint collFraction = _entireTroveColl.mul(V.debtToOffset).div(_entireTroveDebt);\n            V.collGasCompensation = _getCollGasCompensation(collFraction);\n          \n            V.LUSDGasCompensation = 0;  // LUSD gas compensation remains untouched\n\n            V.collToSendToSP = collFraction.sub(V.collGasCompensation);\n            V.collToRedistribute = 0;\n            V.debtToRedistribute = 0;\n\n            V.partialAddr = _borrower;\n            V.partialNewColl = _entireTroveColl.sub(collFraction);\n\n            // Get the partial trove's neighbours, so we can re-insert it later to the same position\n            V.partialUpperHint = sortedTroves.getPrev(_borrower);  \n            V.partialLowerHint = sortedTroves.getNext(_borrower);\n        }\n    }\n\n    /* \n    * Liquidate a sequence of troves. Closes a maximum number of n under-collateralized Troves,\n    * starting from the one with the lowest collateral ratio in the system, and moving upwards\n    */\n    function liquidateTroves(uint _n) external override {\n        LocalVariables_OuterLiquidationFunction memory L;\n\n        LiquidationTotals memory T;\n\n        L.price = priceFeed.getPrice();\n        L.LUSDInStabPool = stabilityPool.getTotalLUSDDeposits();\n        L.recoveryModeAtStart = checkRecoveryMode();\n\n        // Perform the appropriate liquidation sequence - tally the values, and obtain their totals\n        if (L.recoveryModeAtStart == true) {\n            T = _getTotalsFromLiquidateTrovesSequence_RecoveryMode(L.price, L.LUSDInStabPool, _n);\n        } else if (L.recoveryModeAtStart == false) {\n            T = _getTotalsFromLiquidateTrovesSequence_NormalMode(L.price, L.LUSDInStabPool, _n);\n        }\n\n        // Move liquidated ETH and LUSD to the appropriate pools\n        stabilityPool.offset(T.totalDebtToOffset, T.totalCollToSendToSP);\n        _redistributeDebtAndColl(T.totalDebtToRedistribute, T.totalCollToRedistribute);\n\n        // Update system snapshots and the final partially liquidated trove, if there is one\n        _updateSystemSnapshots_excludeCollRemainder(T.partialNewColl.add(T.totalCollGasCompensation));\n        _updatePartiallyLiquidatedTrove(T.partialAddr, T.partialNewDebt, T.partialNewColl, T.partialUpperHint, T. partialLowerHint, L.price);\n\n        L.liquidatedDebt = T.totalDebtInSequence.sub(T.partialNewDebt);\n        L.liquidatedColl = T.totalCollInSequence.sub(T.totalCollGasCompensation).sub(T.partialNewColl);\n        emit Liquidation(L.liquidatedDebt, L.liquidatedColl, T.totalCollGasCompensation, T.totalLUSDGasCompensation);\n\n        // Send gas compensation to caller\n        _sendGasCompensation(msg.sender, T.totalLUSDGasCompensation, T.totalCollGasCompensation);\n    }\n\n    /*\n    * This function is used when the liquidateTroves sequence starts during Recovery Mode. However, it\n    * handle the case where the system *leaves* Recovery Mode, part way through the liquidation sequence\n    */\n    function _getTotalsFromLiquidateTrovesSequence_RecoveryMode\n    (\n        uint _price,\n        uint _LUSDInStabPool,\n        uint _n\n    )\n        internal\n        returns(LiquidationTotals memory T)\n    {\n        LocalVariables_LiquidationSequence memory L;\n        LiquidationValues memory V;\n\n        L.remainingLUSDInStabPool = _LUSDInStabPool;\n        L.backToNormalMode = false;\n        L.entireSystemDebt = activePool.getLUSDDebt().add(defaultPool.getLUSDDebt());\n        L.entireSystemColl = activePool.getETH().add(defaultPool.getETH());\n\n        L.i = 0;\n        while (L.i < _n) {\n            L.user = sortedTroves.getLast();\n            L.ICR = getCurrentICR(L.user, _price);\n\n            if (L.backToNormalMode == false) {\n                // Break the loop if ICR is greater than MCR and Stability Pool is empty\n                if (L.ICR >= MCR && L.remainingLUSDInStabPool == 0) { break; }\n\n                uint TCR = LiquityMath._computeCR(L.entireSystemColl, L.entireSystemDebt, _price);\n        \n                V = _liquidateRecoveryMode(L.user, L.ICR, L.remainingLUSDInStabPool, TCR);\n\n                // Update aggregate trackers\n                L.remainingLUSDInStabPool = L.remainingLUSDInStabPool.sub(V.debtToOffset);\n                L.entireSystemDebt = L.entireSystemDebt.sub(V.debtToOffset);\n                L.entireSystemColl = L.entireSystemColl.sub(V.collToSendToSP);\n\n                // Add liquidation values to their respective running totals\n                T = _addLiquidationValuesToTotals(T, V);\n\n                // Break the loop if it was a partial liquidation\n                if (V.partialAddr != address(0)) {break;}\n\n                L.backToNormalMode = !_checkPotentialRecoveryMode(L.entireSystemColl, L.entireSystemDebt, _price);\n            }\n            else if (L.backToNormalMode == true && L.ICR < MCR) {\n                V = _liquidateNormalMode(L.user, L.remainingLUSDInStabPool);\n\n                L.remainingLUSDInStabPool = L.remainingLUSDInStabPool.sub(V.debtToOffset);\n\n                // Add liquidation values to their respective running totals\n                T = _addLiquidationValuesToTotals(T, V);\n\n            }  else break;  // break if the loop reaches a Trove with ICR >= MCR\n\n            // Break the loop if it reaches the first Trove in the sorted list\n            if (L.user == sortedTroves.getFirst()) { break; }\n\n            L.i++;\n        }\n    }\n\n    function _getTotalsFromLiquidateTrovesSequence_NormalMode\n    (\n        uint _price,\n        uint _LUSDInStabPool,\n        uint _n\n    )\n        internal\n        returns(LiquidationTotals memory T)\n    {\n        LocalVariables_LiquidationSequence memory L;\n        LiquidationValues memory V;\n\n        L.remainingLUSDInStabPool = _LUSDInStabPool;\n\n        L.i = 0;\n        while (L.i < _n) {\n            L.user = sortedTroves.getLast();\n            L.ICR = getCurrentICR(L.user, _price);\n\n            if (L.ICR < MCR) {\n                V = _liquidateNormalMode(L.user, L.remainingLUSDInStabPool);\n\n                L.remainingLUSDInStabPool = L.remainingLUSDInStabPool.sub(V.debtToOffset);\n\n                // Add liquidation values to their respective running totals\n                T = _addLiquidationValuesToTotals(T, V);\n\n            } else break;  // break if the loop reaches a Trove with ICR >= MCR\n\n            // Break the loop if it reaches the first Trove in the sorted list\n            if (L.user == sortedTroves.getFirst()) { break; }\n            L.i++;\n        }\n    }\n\n    /* \n    * Attempt to liquidate a custom list of troves provided by the caller. The liquidation sequence stops if\n    * a partial liquidation is performed, so it's up to the caller to order the troves in the _troveArray parameter.\n    */\n    function batchLiquidateTroves(address[] memory _troveArray) public override {\n        require(_troveArray.length != 0, \"TroveManager: Calldata address array must not be empty\");\n\n        LocalVariables_OuterLiquidationFunction memory L;\n        LiquidationTotals memory T;\n\n        L.price = priceFeed.getPrice();\n        L.LUSDInStabPool = stabilityPool.getTotalLUSDDeposits();\n        L.recoveryModeAtStart = checkRecoveryMode();\n\n        // Perform the appropriate liquidation sequence - tally values and obtain their totals.\n        if (L.recoveryModeAtStart == true) {\n           T = _getTotalFromBatchLiquidate_RecoveryMode(L.price, L.LUSDInStabPool, _troveArray);\n        } else if (L.recoveryModeAtStart == false) {\n            T = _getTotalsFromBatchLiquidate_NormalMode(L.price, L.LUSDInStabPool, _troveArray);\n        }\n\n        // Move liquidated ETH and LUSD to the appropriate pools\n        stabilityPool.offset(T.totalDebtToOffset, T.totalCollToSendToSP);\n        _redistributeDebtAndColl(T.totalDebtToRedistribute, T.totalCollToRedistribute);\n\n        // Update system snapshots and the final partially liquidated trove, if there is one\n        _updateSystemSnapshots_excludeCollRemainder(T.partialNewColl.add(T.totalCollGasCompensation));\n        _updatePartiallyLiquidatedTrove(T.partialAddr, T.partialNewDebt, T.partialNewColl, T.partialUpperHint, T. partialLowerHint, L.price);\n\n        L.liquidatedDebt = T.totalDebtInSequence.sub(T.partialNewDebt);\n        L.liquidatedColl = T.totalCollInSequence.sub(T.totalCollGasCompensation).sub(T.partialNewColl);\n        emit Liquidation(L.liquidatedDebt, L.liquidatedColl, T.totalCollGasCompensation, T.totalLUSDGasCompensation);\n\n        // Send gas compensation to caller\n        _sendGasCompensation(msg.sender, T.totalLUSDGasCompensation, T.totalCollGasCompensation);\n    }\n\n    /* \n    * This function is used when the batch liquidation sequence starts during Recovery Mode. However, it\n    * handle the case where the system *leaves* Recovery Mode, part way through the liquidation sequence\n    */\n    function _getTotalFromBatchLiquidate_RecoveryMode\n    (\n        uint _price,\n        uint _LUSDInStabPool,\n        address[] memory _troveArray)\n        internal\n        returns(LiquidationTotals memory T)\n    {\n        LocalVariables_LiquidationSequence memory L;\n        LiquidationValues memory V;\n\n        L.remainingLUSDInStabPool = _LUSDInStabPool;\n        L.backToNormalMode = false;\n        L.entireSystemDebt = activePool.getLUSDDebt().add(defaultPool.getLUSDDebt());\n        L.entireSystemColl = activePool.getETH().add(defaultPool.getETH());\n\n        L.i = 0;\n        for (L.i = 0; L.i < _troveArray.length; L.i++) {\n            L.user = _troveArray[L.i];\n            L.ICR = getCurrentICR(L.user, _price);\n\n            if (L.backToNormalMode == false) {\n\n                // Skip this trove if ICR is greater than MCR and Stability Pool is empty\n                if (L.ICR >= MCR && L.remainingLUSDInStabPool == 0) { continue; }\n\n                uint TCR = LiquityMath._computeCR(L.entireSystemColl, L.entireSystemDebt, _price);\n\n                V = _liquidateRecoveryMode(L.user, L.ICR, L.remainingLUSDInStabPool, TCR);\n\n                // Update aggregate trackers\n                L.remainingLUSDInStabPool = L.remainingLUSDInStabPool.sub(V.debtToOffset);\n                L.entireSystemDebt = L.entireSystemDebt.sub(V.debtToOffset);\n                L.entireSystemColl = L.entireSystemColl.sub(V.collToSendToSP);\n\n                // Add liquidation values to their respective running totals\n                T = _addLiquidationValuesToTotals(T, V);\n\n                // Break the loop if it was a partial liquidation\n                if (V.partialAddr != address(0)) { break; }\n\n                L.backToNormalMode = !_checkPotentialRecoveryMode(L.entireSystemColl, L.entireSystemDebt, _price);\n            }\n\n            else if (L.backToNormalMode == true && L.ICR < MCR) {\n                V = _liquidateNormalMode(L.user, L.remainingLUSDInStabPool);\n                L.remainingLUSDInStabPool = L.remainingLUSDInStabPool.sub(V.debtToOffset);\n\n                // Add liquidation values to their respective running totals\n                T = _addLiquidationValuesToTotals(T, V);\n            }\n        }\n    }\n\n    function _getTotalsFromBatchLiquidate_NormalMode\n    (\n        uint _price,\n        uint _LUSDInStabPool,\n        address[] memory _troveArray\n    )\n        internal\n        returns(LiquidationTotals memory T)\n    {\n        LocalVariables_LiquidationSequence memory L;\n        LiquidationValues memory V;\n\n        L.remainingLUSDInStabPool = _LUSDInStabPool;\n\n        for (L.i = 0; L.i < _troveArray.length; L.i++) {\n            L.user = _troveArray[L.i];\n            L.ICR = getCurrentICR(L.user, _price);\n\n            if (L.ICR < MCR) {\n                V = _liquidateNormalMode(L.user, L.remainingLUSDInStabPool);\n                L.remainingLUSDInStabPool = L.remainingLUSDInStabPool.sub(V.debtToOffset);\n\n                // Add liquidation values to their respective running totals\n                T = _addLiquidationValuesToTotals(T, V);\n            }\n        }\n    }\n\n    // --- Liquidation helper functions ---\n\n    function _addLiquidationValuesToTotals(LiquidationTotals memory T1, LiquidationValues memory V)\n    internal pure returns(LiquidationTotals memory T2) {\n\n        // Tally all the values with their respective running totals\n        T2.totalCollGasCompensation = T1.totalCollGasCompensation.add(V.collGasCompensation);\n        T2.totalLUSDGasCompensation = T1.totalLUSDGasCompensation.add(V.LUSDGasCompensation);\n        T2.totalDebtInSequence = T1.totalDebtInSequence.add(V.entireTroveDebt);\n        T2.totalCollInSequence = T1.totalCollInSequence.add(V.entireTroveColl);\n        T2.totalDebtToOffset = T1.totalDebtToOffset.add(V.debtToOffset);\n        T2.totalCollToSendToSP = T1.totalCollToSendToSP.add(V.collToSendToSP);\n        T2.totalDebtToRedistribute = T1.totalDebtToRedistribute.add(V.debtToRedistribute);\n        T2.totalCollToRedistribute = T1.totalCollToRedistribute.add(V.collToRedistribute);\n\n        // Assign the address of the partially liquidated trove, and its new debt and coll values\n        T2.partialAddr = V.partialAddr;\n        T2.partialNewDebt = V.partialNewDebt;\n        T2.partialNewColl = V.partialNewColl;\n        T2.partialUpperHint = V.partialUpperHint;\n        T2.partialLowerHint = V.partialLowerHint;\n\n        return T2;\n    }\n\n    // Update the properties of the partially liquidated trove, and insert it back to the list\n    function _updatePartiallyLiquidatedTrove\n    (\n        address _borrower, \n        uint _newDebt, \n        uint _newColl, \n        address _upperHint,\n        address _lowerHint,\n        uint _price\n    ) \n        internal \n    {\n        if ( _borrower == address(0)) { return; }\n\n        Troves[_borrower].debt = _newDebt;\n        Troves[_borrower].coll = _newColl;\n        Troves[_borrower].status = Status.active;\n\n        _updateTroveRewardSnapshots(_borrower);\n        _updateStakeAndTotalStakes(_borrower);\n\n        uint ICR = getCurrentICR(_borrower, _price);\n\n        /* \n        * Insert to sorted list and add to TroveOwners array. The partially liquidated trove has the same\n        * ICR as it did before the liquidation, so insertion is O(1): in principle, its ICR does not change.\n        * In practice, due to rounding error, its ICR can change slightly - so re-insert, with its previous neighbours\n        * as hints.\n        */\n        sortedTroves.insert(_borrower, ICR, _price, _upperHint, _lowerHint);\n        _addTroveOwnerToArray(_borrower);\n        emit TroveUpdated(_borrower, _newDebt, _newColl, Troves[_borrower].stake, TroveManagerOperation.partiallyLiquidateInRecoveryMode);\n    }\n\n    function _sendGasCompensation(address _liquidator, uint _LUSD, uint _ETH) internal {\n        if (_LUSD > 0) {\n            lusdToken.returnFromPool(GAS_POOL_ADDRESS, _liquidator, _LUSD);\n        }\n\n        if (_ETH > 0) {\n            activePool.sendETH(_liquidator, _ETH);\n        }\n    }\n\n    // Move a Trove's pending debt and collateral rewards from distributions, from the Default Pool to the Active Pool\n    function _movePendingTroveRewardsToActivePool(uint _LUSD, uint _ETH) internal {\n        defaultPool.decreaseLUSDDebt(_LUSD);\n        activePool.increaseLUSDDebt(_LUSD);\n        defaultPool.sendETH(address(activePool), _ETH);\n    }\n\n    // --- Redemption functions ---\n\n    // Redeem as much collateral as possible from _borrower's Trove in exchange for LUSD up to _maxLUSDamount\n    function _redeemCollateralFromTrove(\n        address _borrower,\n        uint _maxLUSDamount,\n        uint _price,\n        address _partialRedemptionHint,\n        uint _partialRedemptionHintICR\n    )\n        internal returns (SingleRedemptionValues memory V)\n    {\n        // Determine the remaining amount (lot) to be redeemed, capped by the entire debt of the Trove minus the gas compensation\n        V.LUSDLot = LiquityMath._min(_maxLUSDamount, Troves[_borrower].debt.sub(LUSD_GAS_COMPENSATION));\n\n        // Get the ETHLot of equivalent value in USD\n        V.ETHLot = V.LUSDLot.mul(1e18).div(_price);\n\n        // Decrease the debt and collateral of the current Trove according to the LUSD lot and corresponding ETH to send\n        uint newDebt = (Troves[_borrower].debt).sub(V.LUSDLot);\n        uint newColl = (Troves[_borrower].coll).sub(V.ETHLot);\n\n        if (newDebt == LUSD_GAS_COMPENSATION) {\n            // No debt left in the Trove (except for the gas compensation), therefore the trove gets closed\n            _removeStake(_borrower);\n            _closeTrove(_borrower);\n            _redeemCloseTrove(_borrower, LUSD_GAS_COMPENSATION, newColl);\n\n        } else {\n            uint newICR = LiquityMath._computeCR(newColl, newDebt, _price);\n\n            // Check if the provided hint is fresh. If not, we bail since trying to reinsert without a good hint will almost\n            // certainly result in running out of gas.\n            if (newICR != _partialRedemptionHintICR) {\n                V.LUSDLot = 0;\n                V.ETHLot = 0;\n                return V;\n            }\n\n            sortedTroves.reInsert(_borrower, newICR, _price, _partialRedemptionHint, _partialRedemptionHint);\n\n            Troves[_borrower].debt = newDebt;\n            Troves[_borrower].coll = newColl;\n            _updateStakeAndTotalStakes(_borrower);\n        }\n        emit TroveUpdated(\n            _borrower,\n            newDebt, newColl,\n            Troves[_borrower].stake,\n            TroveManagerOperation.redeemCollateral\n        );\n        return V;\n    }\n\n    /* \n    * Called when a full redemption occurs, and closes the trove.\n    * The redeemer swaps (debt - 10) LUSD for (debt - 10) worth of ETH, so the 10 LUSD gas compensation left corresponds to the remaining debt.\n    * In order to close the trove, the 10 LUSD gas compensation is burned, and 10 debt is removed from the active pool.\n    * The debt recorded on the trove's struct is zero'd elswhere, in _closeTrove.\n    * Any surplus ETH left in the trove, is sent to the Coll surplus pool, and can be later claimed by the borrower.\n    */ \n    function _redeemCloseTrove(address _borrower, uint _LUSD, uint _ETH) internal {\n        lusdToken.burn(GAS_POOL_ADDRESS, _LUSD);\n        // Update Active Pool LUSD, and send ETH to account\n        activePool.decreaseLUSDDebt(_LUSD);\n\n        // send ETH from Active Pool to CollSurplus Pool\n        collSurplusPool.accountSurplus(_borrower, _ETH);\n        activePool.sendETH(address(collSurplusPool), _ETH);\n    }\n\n    function _isValidFirstRedemptionHint(address _firstRedemptionHint, uint _price) internal view returns (bool) {\n        if (_firstRedemptionHint == address(0) ||\n            !sortedTroves.contains(_firstRedemptionHint) ||\n            getCurrentICR(_firstRedemptionHint, _price) < MCR\n        ) {\n            return false;\n        }\n\n        address nextTrove = sortedTroves.getNext(_firstRedemptionHint);\n        return nextTrove == address(0) || getCurrentICR(nextTrove, _price) < MCR;\n    }\n\n    /* Send _LUSDamount LUSD to the system and redeem the corresponding amount of collateral from as many Troves as are needed to fill the redemption\n    * request.  Applies pending rewards to a Trove before reducing its debt and coll.\n    *\n    * Note that if _amount is very large, this function can run out of gas, specially if traversed troves are small. This can be easily avoided by \n    * splitting the total _amount in appropriate chunks and calling the function multiple times.\n    * \n    * Param `_maxIterations` can also be provided, so the loop through Troves is capped (if its zero, it will be ignored).This makes it easier to \n    * avoid OOG for the frontend, as only knowing approximately the average cost of an iteration is enough, without needing to know the topology \n    * of the trove list. It also avoids the need to set the cap in stone in the contract, nor doing gas calculations, as both gas price and opcode \n    * costs can vary.\n    * \n    * All Troves that are redeemed from -- with the likely exception of the last one -- will end up with no debt left, therefore they will be closed.\n    * If the last Trove does have some remaining debt, it has a finite ICR, and the reinsertion could be anywhere in the list, therefore it requires a hint. \n    * A frontend should use getRedemptionHints() to calculate what the ICR of this Trove will be after redemption, and pass a hint for its position \n    * in the sortedTroves list along with the ICR value that the hint was found for.\n    * \n    * If another transaction modifies the list between calling getRedemptionHints() and passing the hints to redeemCollateral(), it\n    * is very likely that the last (partially) redeemed Trove would end up with a different ICR than what the hint is for. In this case the\n    * redemption will stop after the last completely redeemed Trove and the sender will keep the remaining LUSD amount, which they can attempt\n    * to redeem later.\n    */\n    function redeemCollateral(\n        uint _LUSDamount,\n        address _firstRedemptionHint,\n        address _partialRedemptionHint,\n        uint _partialRedemptionHintICR,\n        uint _maxIterations\n    )\n        external\n        override\n    {\n        uint activeDebt = activePool.getLUSDDebt();\n        uint defaultedDebt = defaultPool.getLUSDDebt();\n\n        RedemptionTotals memory T;\n\n        _requireAmountGreaterThanZero(_LUSDamount);\n        _requireLUSDBalanceCoversRedemption(msg.sender, _LUSDamount);\n\n        // Confirm redeemer's balance is less than total systemic debt\n        assert(lusdToken.balanceOf(msg.sender) <= (activeDebt.add(defaultedDebt)));\n\n        uint remainingLUSD = _LUSDamount;\n        uint price = priceFeed.getPrice();\n        address currentBorrower;\n\n        if (_isValidFirstRedemptionHint(_firstRedemptionHint, price)) {\n            currentBorrower = _firstRedemptionHint;\n        } else {\n            currentBorrower = sortedTroves.getLast();\n            // Find the first trove with ICR >= MCR\n            // SWC-104-Unchecked Call Return Value: L920\n            while (currentBorrower != address(0) && getCurrentICR(currentBorrower, price) < MCR) {\n                currentBorrower = sortedTroves.getPrev(currentBorrower);\n            }\n        }\n\n        // Loop through the Troves starting from the one with lowest collateral ratio until _amount of LUSD is exchanged for collateral\n        if (_maxIterations == 0) { _maxIterations = uint(-1); }\n        while (currentBorrower != address(0) && remainingLUSD > 0 && _maxIterations > 0) {\n            _maxIterations--;\n            // Save the address of the Trove preceding the current one, before potentially modifying the list\n            address nextUserToCheck = sortedTroves.getPrev(currentBorrower);\n\n            _applyPendingRewards(currentBorrower);\n            SingleRedemptionValues memory V = _redeemCollateralFromTrove(\n                currentBorrower,\n                remainingLUSD,\n                price,\n                _partialRedemptionHint,\n                _partialRedemptionHintICR\n            );\n\n            if (V.LUSDLot == 0) break; // Partial redemption hint got out-of-date, therefore we could not redeem from the last Trove\n\n            T.totalLUSDToRedeem  = T.totalLUSDToRedeem.add(V.LUSDLot);\n            T.totalETHDrawn = T.totalETHDrawn.add(V.ETHLot);\n\n            remainingLUSD = remainingLUSD.sub(V.LUSDLot);\n            currentBorrower = nextUserToCheck;\n        }\n\n        // Decay the baseRate due to time passed, and then increase it according to the size of this redemption\n        _updateBaseRateFromRedemption(T.totalETHDrawn, price);\n\n        // Calculate the ETH fee and send it to the LQTY staking contract\n        T.ETHFee = _getRedemptionFee(T.totalETHDrawn);\n        activePool.sendETH(lqtyStakingAddress, T.ETHFee);\n        lqtyStaking.increaseF_ETH(T.ETHFee);\n\n        T.ETHToSendToRedeemer = T.totalETHDrawn.sub(T.ETHFee);\n\n        // Burn the total LUSD that is cancelled with debt, and send the redeemed ETH to msg.sender\n        _activePoolRedeemCollateral(msg.sender, T.totalLUSDToRedeem, T.ETHToSendToRedeemer);\n\n        emit Redemption(_LUSDamount, T.totalLUSDToRedeem, T.totalETHDrawn, T.ETHFee);\n    }\n\n    // Burn the received LUSD, transfer the redeemed ETH to _redeemer and updates the Active Pool\n    function _activePoolRedeemCollateral(address _redeemer, uint _LUSD, uint _ETH) internal {\n        // Update Active Pool LUSD, and send ETH to account\n        lusdToken.burn(_redeemer, _LUSD);\n        activePool.decreaseLUSDDebt(_LUSD);\n\n        activePool.sendETH(_redeemer, _ETH);\n    }\n\n    // --- Helper functions ---\n\n\n    // Return the current collateral ratio (ICR) of a given Trove. Takes a trove's pending coll and debt rewards from redistributions into account.\n    function getCurrentICR(address _borrower, uint _price) public view override returns (uint) {\n        uint pendingETHReward = getPendingETHReward(_borrower);\n        uint pendingLUSDDebtReward = getPendingLUSDDebtReward(_borrower);\n\n        uint currentETH = Troves[_borrower].coll.add(pendingETHReward);\n        uint currentLUSDDebt = Troves[_borrower].debt.add(pendingLUSDDebtReward);\n\n        uint ICR = LiquityMath._computeCR(currentETH, currentLUSDDebt, _price);\n        return ICR;\n    }\n\n    function applyPendingRewards(address _borrower) external override {\n        _requireCallerIsBorrowerOperations();\n        return _applyPendingRewards(_borrower);\n    }\n\n    // Add the borrowers's coll and debt rewards earned from redistributions, to their Trove\n    function _applyPendingRewards(address _borrower) internal {\n        if (hasPendingRewards(_borrower)) {\n            _requireTroveisActive(_borrower);\n\n            // Compute pending rewards\n            uint pendingETHReward = getPendingETHReward(_borrower);\n            uint pendingLUSDDebtReward = getPendingLUSDDebtReward(_borrower);\n\n            // Apply pending rewards to trove's state\n            Troves[_borrower].coll = Troves[_borrower].coll.add(pendingETHReward);\n            Troves[_borrower].debt = Troves[_borrower].debt.add(pendingLUSDDebtReward);\n\n            _updateTroveRewardSnapshots(_borrower);\n\n            // Transfer from DefaultPool to ActivePool\n            _movePendingTroveRewardsToActivePool(pendingLUSDDebtReward, pendingETHReward);\n\n            emit TroveUpdated(\n                _borrower, \n                Troves[_borrower].debt, \n                Troves[_borrower].coll, \n                Troves[_borrower].stake, \n                TroveManagerOperation.applyPendingRewards\n            );\n        }\n    }\n\n    // Update borrower's snapshots of L_ETH and L_LUSDDebt to reflect the current values\n    function updateTroveRewardSnapshots(address _borrower) external override {\n        _requireCallerIsBorrowerOperations();\n       return _updateTroveRewardSnapshots(_borrower);\n    }\n\n    function _updateTroveRewardSnapshots(address _borrower) internal {\n        rewardSnapshots[_borrower].ETH = L_ETH;\n        rewardSnapshots[_borrower].LUSDDebt = L_LUSDDebt;\n    }\n\n    // Get the borrower's pending accumulated ETH reward, earned by their stake\n    function getPendingETHReward(address _borrower) public view override returns (uint) {\n        uint snapshotETH = rewardSnapshots[_borrower].ETH;\n        uint rewardPerUnitStaked = L_ETH.sub(snapshotETH);\n\n        if ( rewardPerUnitStaked == 0 ) { return 0; }\n\n        uint stake = Troves[_borrower].stake;\n\n        uint pendingETHReward = stake.mul(rewardPerUnitStaked).div(1e18);\n\n        return pendingETHReward;\n    }\n\n     // Get the borrower's pending accumulated LUSD reward, earned by their stake\n    function getPendingLUSDDebtReward(address _borrower) public view override returns (uint) {\n        uint snapshotLUSDDebt = rewardSnapshots[_borrower].LUSDDebt;\n        uint rewardPerUnitStaked = L_LUSDDebt.sub(snapshotLUSDDebt);\n\n        if ( rewardPerUnitStaked == 0 ) { return 0; }\n\n        uint stake =  Troves[_borrower].stake;\n\n        uint pendingLUSDDebtReward = stake.mul(rewardPerUnitStaked).div(1e18);\n\n        return pendingLUSDDebtReward;\n    }\n\n    function hasPendingRewards(address _borrower) public view override returns (bool) {\n        /* \n        * A Trove has pending rewards if its snapshot is less than the current rewards per-unit-staked sum:\n        * this indicates that rewards have occured since the snapshot was made, and the user therefore has\n        * pending rewards \n        */\n        return (rewardSnapshots[_borrower].ETH < L_ETH);\n    }\n\n    // Return the Troves entire debt and coll, including pending rewards from redistributions.\n    function getEntireDebtAndColl(\n        address _borrower\n    )\n        public\n        view\n        override\n        returns (uint debt, uint coll, uint pendingLUSDDebtReward, uint pendingETHReward)\n    {\n        debt = Troves[_borrower].debt;\n        coll = Troves[_borrower].coll;\n\n        pendingLUSDDebtReward = getPendingLUSDDebtReward(_borrower);\n        pendingETHReward = getPendingETHReward(_borrower);\n\n        debt = debt.add(pendingLUSDDebtReward);\n        coll = coll.add(pendingETHReward);\n    }\n\n    function removeStake(address _borrower) external override {\n        _requireCallerIsBorrowerOperations();\n        return _removeStake(_borrower);\n    }\n\n    // Remove borrower's stake from the totalStakes sum, and set their stake to 0\n    function _removeStake(address _borrower) internal {\n        uint stake = Troves[_borrower].stake;\n        totalStakes = totalStakes.sub(stake);\n        Troves[_borrower].stake = 0;\n    }\n\n    function updateStakeAndTotalStakes(address _borrower) external override returns (uint) {\n        _requireCallerIsBorrowerOperations();\n        return _updateStakeAndTotalStakes(_borrower);\n    }\n\n    // Update borrower's stake based on their latest collateral value\n    function _updateStakeAndTotalStakes(address _borrower) internal returns (uint) {\n        uint newStake = _computeNewStake(Troves[_borrower].coll);\n        uint oldStake = Troves[_borrower].stake;\n        Troves[_borrower].stake = newStake;\n        totalStakes = totalStakes.sub(oldStake).add(newStake);\n\n        return newStake;\n    }\n\n    // Calculate a new stake based on the snapshots of the totalStakes and totalCollateral taken at the last liquidation\n    function _computeNewStake(uint _coll) internal view returns (uint) {\n        uint stake;\n        if (totalCollateralSnapshot == 0) {\n            stake = _coll;\n        } else {\n            /*  \n            * The following assert() holds true because:\n            * - The system always contains >= 1 trove \n            * - When we close or liquidate a trove, we redistribute the pending rewards, so if all troves were closed/liquidated, \n            * rewards wouldve been emptied and totalCollateralSnapshot would be zero too.\n            */\n            assert(totalStakesSnapshot > 0);\n            stake = _coll.mul(totalStakesSnapshot).div(totalCollateralSnapshot);\n        }\n        return stake;\n    }\n\n    function _redistributeDebtAndColl(uint _debt, uint _coll) internal {\n        if (_debt == 0) { return; }\n\n        if (totalStakes > 0) {\n            /* \n            * Add distributed coll and debt rewards-per-unit-staked to the running totals.\n            * Division uses a \"feedback\" error correction, to keep the cumulative error in\n            * the  L_ETH and L_LUSDDebt state variables low. \n            */\n            uint ETHNumerator = _coll.mul(1e18).add(lastETHError_Redistribution);\n            uint LUSDDebtNumerator = _debt.mul(1e18).add(lastLUSDDebtError_Redistribution);\n\n            uint ETHRewardPerUnitStaked = ETHNumerator.div(totalStakes);\n            uint LUSDDebtRewardPerUnitStaked = LUSDDebtNumerator.div(totalStakes);\n\n            lastETHError_Redistribution = ETHNumerator.sub(ETHRewardPerUnitStaked.mul(totalStakes));\n            lastLUSDDebtError_Redistribution = LUSDDebtNumerator.sub(LUSDDebtRewardPerUnitStaked.mul(totalStakes));\n\n            L_ETH = L_ETH.add(ETHRewardPerUnitStaked);\n            L_LUSDDebt = L_LUSDDebt.add(LUSDDebtRewardPerUnitStaked);\n        }\n\n        // Transfer coll and debt from ActivePool to DefaultPool\n        activePool.decreaseLUSDDebt(_debt);\n        defaultPool.increaseLUSDDebt(_debt);\n        activePool.sendETH(address(defaultPool), _coll);\n    }\n\n    function closeTrove(address _borrower) external override {\n        _requireCallerIsBorrowerOperations();\n        return _closeTrove(_borrower);\n    }\n\n    function _closeTrove(address _borrower) internal {\n        uint TroveOwnersArrayLength = TroveOwners.length;\n        _requireMoreThanOneTroveInSystem(TroveOwnersArrayLength);\n\n        Troves[_borrower].status = Status.closed;\n        Troves[_borrower].coll = 0;\n        Troves[_borrower].debt = 0;\n\n        rewardSnapshots[_borrower].ETH = 0;\n        rewardSnapshots[_borrower].LUSDDebt = 0;\n\n        _removeTroveOwner(_borrower, TroveOwnersArrayLength);\n        sortedTroves.remove(_borrower);\n    }\n\n    /* \n    * Updates snapshots of system total stakes and total collateral, excluding a given collateral remainder from the calculation. \n    * Used in a liquidation sequence.\n    *\n    * The calculation excludes two portions of collateral that are in the ActivePool: \n    *\n    * 1) the total ETH gas compensation from the liquidation sequence\n    * 2) The remaining collateral in a partially liquidated trove (if one occurred)\n    *\n    * The ETH as compensation must be excluded as it is always sent out at the very end of the liquidation sequence.\n    *\n    * The partially liquidated trove's remaining collateral stays in the ActivePool, but it is excluded here so the system \n    * can take snapshots before the partially liquidated trove's stake is updated (based on these snapshots). This ensures\n    * the partial's new stake doesn't double-count its own remaining collateral.\n    *\n    */\n    function _updateSystemSnapshots_excludeCollRemainder(uint _collRemainder) internal {\n        totalStakesSnapshot = totalStakes;\n\n        uint activeColl = activePool.getETH();\n        uint liquidatedColl = defaultPool.getETH();\n        totalCollateralSnapshot = activeColl.sub(_collRemainder).add(liquidatedColl);\n    }\n\n    // Push the owner's address to the Trove owners list, and record the corresponding array index on the Trove struct\n    function addTroveOwnerToArray(address _borrower) external override returns (uint index) {\n        _requireCallerIsBorrowerOperations();\n        return _addTroveOwnerToArray(_borrower);\n    }\n\n    function _addTroveOwnerToArray(address _borrower) internal returns (uint128 index) {\n        require(TroveOwners.length < 2**128 - 1, \"TroveManager: TroveOwners array has maximum size of 2^128 - 1\");\n\n        // Push the Troveowner to the array\n        TroveOwners.push(_borrower);\n\n        // Record the index of the new Troveowner on their Trove struct\n        index = uint128(TroveOwners.length.sub(1));\n        Troves[_borrower].arrayIndex = index;\n\n        return index;\n    }\n\n    /* \n    * Remove a Trove owner from the TroveOwners array, not preserving array order. Removing owner 'B' does the following:\n    * [A B C D E] => [A E C D], and updates E's Trove struct to point to its new array index. \n    */\n    function _removeTroveOwner(address _borrower, uint TroveOwnersArrayLength) internal {\n        require(Troves[_borrower].status == Status.closed, \"TroveManager: Trove is still active\");\n\n        uint128 index = Troves[_borrower].arrayIndex;\n        uint length = TroveOwnersArrayLength;\n        uint idxLast = length.sub(1);\n\n        assert(index <= idxLast);\n\n        address addressToMove = TroveOwners[idxLast];\n\n        TroveOwners[index] = addressToMove;\n        Troves[addressToMove].arrayIndex = index;\n        TroveOwners.pop();\n    }\n\n    // --- Recovery Mode and TCR functions ---\n\n    function checkRecoveryMode() public view override returns (bool) {\n        uint TCR = getTCR();\n\n        if (TCR < CCR) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    // Check whether or not the system *would be* in Recovery Mode, given an ETH:USD price, and the entire system coll and debt.\n    function _checkPotentialRecoveryMode(\n        uint _entireSystemColl,\n        uint _entireSystemDebt,\n        uint _price\n    )\n        internal\n        pure\n    returns (bool)\n    {\n        uint TCR = LiquityMath._computeCR(_entireSystemColl, _entireSystemDebt, _price);\n        if (TCR < CCR) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n    // SWC-135-Code With No Effects: L1276-L1284\n    function getTCR() public view override returns (uint TCR) {\n        uint price = priceFeed.getPrice();\n        uint entireSystemColl = getEntireSystemColl();\n        uint entireSystemDebt = getEntireSystemDebt();\n\n        TCR = LiquityMath._computeCR(entireSystemColl, entireSystemDebt, price);\n\n        return TCR;\n    }\n    // SWC-135-Code With No Effects: L1286-L1291\n    function getEntireSystemColl() public view override returns (uint entireSystemColl) {\n        uint activeColl = activePool.getETH();\n        uint liquidatedColl = defaultPool.getETH();\n\n        return activeColl.add(liquidatedColl);\n    }\n\n    function getEntireSystemDebt() public view override returns (uint entireSystemDebt) {\n        uint activeDebt = activePool.getLUSDDebt();\n        uint closedDebt = defaultPool.getLUSDDebt();\n\n        return activeDebt.add(closedDebt);\n    }\n\n    // --- Redemption fee functions ---\n\n    /* \n    * This function has two impacts on the baseRate state variable:\n    * 1) decays the baseRate based on time passed since last redemption or LUSD borrowing operation.\n    * then,\n    * 2) increases the baseRate based on the amount redeemed, as a proportion of total supply\n    */\n    function _updateBaseRateFromRedemption(uint _ETHDrawn,  uint _price) internal returns (uint) {\n        uint decayedBaseRate = _calcDecayedBaseRate();\n\n        uint activeDebt = activePool.getLUSDDebt();\n        uint closedDebt = defaultPool.getLUSDDebt();\n        uint totalLUSDSupply = activeDebt.add(closedDebt);\n\n        /* Convert the drawn ETH back to LUSD at face value rate (1 LUSD:1 USD), in order to get\n        * the fraction of total supply that was redeemed at face value. */\n        uint redeemedLUSDFraction = _ETHDrawn.mul(_price).div(totalLUSDSupply);\n\n        uint newBaseRate = decayedBaseRate.add(redeemedLUSDFraction.div(BETA));\n\n        // Update the baseRate state variable\n        baseRate = newBaseRate < 1e18 ? newBaseRate : 1e18;  // cap baseRate at a maximum of 100%\n        assert(baseRate <= 1e18 && baseRate > 0); // Base rate is always non-zero after redemption\n\n        _updateLastFeeOpTime();\n\n        return baseRate;\n    }\n\n    function _getRedemptionFee(uint _ETHDrawn) internal view returns (uint) {\n       return baseRate.mul(_ETHDrawn).div(1e18);\n    }\n\n    // --- Borrowing fee functions ---\n\n    function getBorrowingFee(uint _LUSDDebt) external view override returns (uint) {\n        return _LUSDDebt.mul(baseRate).div(1e18);\n    }\n\n    // Updates the baseRate state variable based on time elapsed since the last redemption or LUSD borrowing operation.\n    function decayBaseRateFromBorrowing() external override {\n        _requireCallerIsBorrowerOperations();\n\n        baseRate = _calcDecayedBaseRate();\n        assert(baseRate <= 1e18);  // The baseRate can decay to 0\n\n        _updateLastFeeOpTime();\n    }\n\n    // --- Internal fee functions ---\n\n    // Update the last fee operation time only if time passed >= decay interval. This prevents base rate griefing.\n    function _updateLastFeeOpTime() internal {\n        uint timePassed = block.timestamp.sub(lastFeeOperationTime);\n\n        if (timePassed >= SECONDS_IN_ONE_MINUTE) {\n            lastFeeOperationTime = block.timestamp;\n        }\n    }\n\n    function _calcDecayedBaseRate() internal view returns (uint) {\n        uint minutesPassed = _minutesPassedSinceLastFeeOp();\n        uint decayFactor = LiquityMath._decPow(MINUTE_DECAY_FACTOR, minutesPassed);\n\n        return baseRate.mul(decayFactor).div(1e18);\n    }\n\n    function _minutesPassedSinceLastFeeOp() internal view returns (uint) {\n        return (block.timestamp.sub(lastFeeOperationTime)).div(SECONDS_IN_ONE_MINUTE);\n    }\n\n    // --- 'require' wrapper functions ---\n\n    function _requireCallerIsBorrowerOperations() internal view {\n        require(msg.sender == borrowerOperationsAddress, \"TroveManager: Caller is not the BorrowerOperations contract\");\n    }\n\n    function _requireTroveisActive(address _borrower) internal view {\n        require(Troves[_borrower].status == Status.active, \"TroveManager: Trove does not exist or is closed\");\n    }\n\n    function _requireLUSDBalanceCoversRedemption(address _redeemer, uint _amount) internal view {\n        require(lusdToken.balanceOf(_redeemer) >= _amount, \"TroveManager: Requested redemption amount must be <= user's LUSD token balance\");\n    }\n\n    function _requireMoreThanOneTroveInSystem(uint TroveOwnersArrayLength) internal view {\n        require (TroveOwnersArrayLength > 1 && sortedTroves.getSize() > 1, \"TroveManager: Only one trove in the system\");\n    }\n\n    function _requireAmountGreaterThanZero(uint _amount) internal pure {\n        require(_amount > 0, \"TroveManager: Amount must be greater than zero\");\n    }\n\n    // --- Trove property getters ---\n\n    function getTroveStatus(address _borrower) external view override returns (uint) {\n        return uint(Troves[_borrower].status);\n    }\n\n    function getTroveStake(address _borrower) external view override returns (uint) {\n        return Troves[_borrower].stake;\n    }\n\n    function getTroveDebt(address _borrower) external view override returns (uint) {\n        return Troves[_borrower].debt;\n    }\n\n    function getTroveColl(address _borrower) external view override returns (uint) {\n        return Troves[_borrower].coll;\n    }\n\n    // --- Trove property setters, called by BorrowerOperations ---\n\n    function setTroveStatus(address _borrower, uint _num) external override {\n        _requireCallerIsBorrowerOperations();\n        Troves[_borrower].status = Status(_num);\n    }\n\n    function increaseTroveColl(address _borrower, uint _collIncrease) external override returns (uint) {\n        _requireCallerIsBorrowerOperations();\n        uint newColl = Troves[_borrower].coll.add(_collIncrease);\n        Troves[_borrower].coll = newColl;\n        return newColl;\n    }\n\n    function decreaseTroveColl(address _borrower, uint _collDecrease) external override returns (uint) {\n        _requireCallerIsBorrowerOperations();\n        uint newColl = Troves[_borrower].coll.sub(_collDecrease);\n        Troves[_borrower].coll = newColl;\n        return newColl;\n    }\n\n    function increaseTroveDebt(address _borrower, uint _debtIncrease) external override returns (uint) {\n        _requireCallerIsBorrowerOperations();\n        uint newDebt = Troves[_borrower].debt.add(_debtIncrease);\n        Troves[_borrower].debt = newDebt;\n        return newDebt;\n    }\n\n    function decreaseTroveDebt(address _borrower, uint _debtDecrease) external override returns (uint) {\n        _requireCallerIsBorrowerOperations();\n        uint newDebt = Troves[_borrower].debt.sub(_debtDecrease);\n        Troves[_borrower].debt = newDebt;\n        return newDebt;\n    }\n}",
        "function": "decayBaseRateFromBorrowing()",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-Liquity/dev-f0df3efa5a5f05b205752184cfce107c5bd6e06c/packages/contracts/contracts/TroveManager.sol",
        "vulnerability": "Dependence on predictable environment variable (SWC 116)",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract TroveManager is LiquityBase, Ownable, ITroveManager {\n\n    // --- Connected contract declarations ---\n\n    address public borrowerOperationsAddress;\n\n    IPool public activePool;\n\n    IPool public defaultPool;\n\n    IStabilityPool public stabilityPool;\n\n    ICollSurplusPool collSurplusPool;\n\n    ILUSDToken public lusdToken;\n\n    IPriceFeed public priceFeed;\n\n    ILQTYStaking public lqtyStaking;\n    address public lqtyStakingAddress;\n\n    // A doubly linked list of Troves, sorted by their sorted by their collateral ratios\n    ISortedTroves public sortedTroves;\n\n    // --- Data structures ---\n\n    uint constant public SECONDS_IN_ONE_MINUTE = 60;\n    uint constant public MINUTE_DECAY_FACTOR = 999832508430720967;  // 18 digit decimal. Corresponds to an hourly decay factor of 0.99\n\n    /* \n    * BETA: 18 digit decimal. Parameter by which to divide the redeemed fraction, in order to calc the new base rate from a redemption. \n    * Corresponds to (1 / ALPHA) in the white paper. \n    */\n    uint constant public BETA = 2;\n\n    uint public baseRate;\n\n    // The timestamp of the latest fee operation (redemption or new LUSD issuance) \n    uint public lastFeeOperationTime;\n\n    enum Status { nonExistent, active, closed }\n\n    // Store the necessary data for a trove\n    struct Trove {\n        uint debt;\n        uint coll;\n        uint stake;\n        Status status;\n        uint128 arrayIndex;\n    }\n\n    mapping (address => Trove) public Troves;\n\n    uint public totalStakes;\n\n    // Snapshot of the value of totalStakes, taken immediately after the latest liquidation\n    uint public totalStakesSnapshot;\n\n    // Snapshot of the total collateral across the ActivePool and DefaultPool, immediately after the latest liquidation.\n    uint public totalCollateralSnapshot;\n\n    /*\n    * L_ETH and L_LUSDDebt track the sums of accumulated liquidation rewards per unit staked. During its lifetime, each stake earns:\n    *\n    * An ETH gain of ( stake * [L_ETH - L_ETH(0)] )\n    * A LUSDDebt increase  of ( stake * [L_LUSDDebt - L_LUSDDebt(0)] )\n    *\n    * Where L_ETH(0) and L_LUSDDebt(0) are snapshots of L_ETH and L_LUSDDebt for the active Trove taken at the instant the stake was made\n    */\n    uint public L_ETH;\n    uint public L_LUSDDebt;\n\n    // Map addresses with active troves to their RewardSnapshot\n    mapping (address => RewardSnapshot) public rewardSnapshots;\n\n    // Object containing the ETH and LUSD snapshots for a given active trove\n    struct RewardSnapshot { uint ETH; uint LUSDDebt;}\n\n    // Array of all active trove addresses - used to to compute an approximate hint off-chain, for the sorted list insertion\n    address[] public TroveOwners;\n\n    // Error trackers for the trove redistribution calculation\n    uint public lastETHError_Redistribution;\n    uint public lastLUSDDebtError_Redistribution;\n\n    /* \n    * --- Variable container structs for liquidations ---\n    *\n    * These structs are used to hold, return and assign variables inside the liquidation functions,\n    * in order to avoid the error: \"CompilerError: Stack too deep\". \n    **/\n\n    struct LocalVariables_OuterLiquidationFunction {\n        uint price;\n        uint LUSDInStabPool;\n        bool recoveryModeAtStart;\n        uint liquidatedDebt;\n        uint liquidatedColl;\n    }\n\n    struct LocalVariables_InnerSingleLiquidateFunction {\n        uint collToLiquidate;\n        uint pendingDebtReward;\n        uint pendingCollReward;\n    }\n\n    struct LocalVariables_LiquidationSequence {\n        uint remainingLUSDInStabPool;\n        uint i;\n        uint ICR;\n        address user;\n        bool backToNormalMode;\n        uint entireSystemDebt;\n        uint entireSystemColl;\n    }\n\n    struct LiquidationValues {\n        uint entireTroveDebt;\n        uint entireTroveColl;\n        uint collGasCompensation;\n        uint LUSDGasCompensation;\n        uint debtToOffset;\n        uint collToSendToSP;\n        uint debtToRedistribute;\n        uint collToRedistribute;\n        address partialAddr;\n        uint partialNewDebt;\n        uint partialNewColl;\n        address partialUpperHint;\n        address partialLowerHint;\n    }\n\n    struct LiquidationTotals {\n        uint totalCollInSequence;\n        uint totalDebtInSequence;\n        uint totalCollGasCompensation;\n        uint totalLUSDGasCompensation;\n        uint totalDebtToOffset;\n        uint totalCollToSendToSP;\n        uint totalDebtToRedistribute;\n        uint totalCollToRedistribute;\n        address partialAddr;\n        uint partialNewDebt;\n        uint partialNewColl;\n        address partialUpperHint;\n        address partialLowerHint;\n    }\n\n    // --- Variable container structs for redemptions ---\n\n    struct RedemptionTotals {\n        uint totalLUSDToRedeem;\n        uint totalETHDrawn;\n        uint ETHFee;\n        uint ETHToSendToRedeemer;\n        uint decayedBaseRate;\n    }\n\n    struct SingleRedemptionValues {\n        uint LUSDLot;\n        uint ETHLot;\n    }\n\n    // --- Events ---\n\n    event Liquidation(uint _liquidatedDebt, uint _liquidatedColl, uint _collGasCompensation, uint _LUSDGasCompensation);\n    event Redemption(uint _attemptedLUSDAmount, uint _actualLUSDAmount, uint _ETHSent, uint _ETHFee);\n\n    enum TroveManagerOperation {\n        applyPendingRewards,\n        liquidateInNormalMode,\n        liquidateInRecoveryMode,\n        partiallyLiquidateInRecoveryMode,\n        redeemCollateral\n    }\n\n    event TroveCreated(address indexed _borrower, uint _arrayIndex);\n    event TroveUpdated(address indexed _borrower, uint _debt, uint _coll, uint _stake, TroveManagerOperation _operation);\n    event TroveLiquidated(address indexed _borrower, uint _debt, uint _coll, TroveManagerOperation _operation);\n\n    // --- Dependency setter ---\n\n    function setAddresses(\n        address _borrowerOperationsAddress,\n        address _activePoolAddress,\n        address _defaultPoolAddress,\n        address _stabilityPoolAddress,\n        address _collSurplusPoolAddress,\n        address _priceFeedAddress,\n        address _lusdTokenAddress,\n        address _sortedTrovesAddress,\n        address _lqtyStakingAddress\n    )\n        external\n        override\n        onlyOwner\n    {\n        borrowerOperationsAddress = _borrowerOperationsAddress;\n        activePool = IPool(_activePoolAddress);\n        defaultPool = IPool(_defaultPoolAddress);\n        stabilityPool = IStabilityPool(_stabilityPoolAddress);\n        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);\n        priceFeed = IPriceFeed(_priceFeedAddress);\n        lusdToken = ILUSDToken(_lusdTokenAddress);\n        sortedTroves = ISortedTroves(_sortedTrovesAddress);\n        lqtyStakingAddress = _lqtyStakingAddress;\n        lqtyStaking = ILQTYStaking(_lqtyStakingAddress);\n\n        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);\n        emit ActivePoolAddressChanged(_activePoolAddress);\n        emit DefaultPoolAddressChanged(_defaultPoolAddress);\n        emit StabilityPoolAddressChanged(_stabilityPoolAddress);\n        emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);\n        emit PriceFeedAddressChanged(_priceFeedAddress);\n        emit LUSDTokenAddressChanged(_lusdTokenAddress);\n        emit SortedTrovesAddressChanged(_sortedTrovesAddress);\n        emit LQTYStakingAddressChanged(_lqtyStakingAddress);\n\n        _renounceOwnership();\n    }\n\n    // --- Getters ---\n\n    function getTroveOwnersCount() external view override returns (uint) {\n        return TroveOwners.length;\n    }\n\n    function getTroveFromTroveOwnersArray(uint _index) external view override returns (address) {\n        return TroveOwners[_index];\n    }\n\n    // --- Trove Liquidation functions ---\n\n    // Single liquidation function. Closes the trove if its ICR is lower than the minimum collateral ratio. \n    function liquidate(address _borrower) external override {\n        _requireTroveisActive(_borrower);\n\n        address[] memory borrowers = new address[](1);\n        borrowers[0] = _borrower;\n        batchLiquidateTroves(borrowers);\n    }\n\n    // --- Inner single liquidation functions ---\n\n    // Liquidate one trove, in Normal Mode.\n    function _liquidateNormalMode(address _borrower, uint _LUSDInStabPool) internal returns (LiquidationValues memory V) {\n        LocalVariables_InnerSingleLiquidateFunction memory L;\n\n        (V.entireTroveDebt,\n        V.entireTroveColl,\n        L.pendingDebtReward,\n        L.pendingCollReward) = getEntireDebtAndColl(_borrower);\n\n        _movePendingTroveRewardsToActivePool(L.pendingDebtReward, L.pendingCollReward);\n        _removeStake(_borrower);\n\n        V.collGasCompensation = _getCollGasCompensation(V.entireTroveColl);\n        V.LUSDGasCompensation = LUSD_GAS_COMPENSATION;\n        uint collToLiquidate = V.entireTroveColl.sub(V.collGasCompensation);\n\n        (V.debtToOffset,\n        V.collToSendToSP,\n        V.debtToRedistribute,\n        V.collToRedistribute) = _getOffsetAndRedistributionVals(V.entireTroveDebt, collToLiquidate, _LUSDInStabPool);\n\n        _closeTrove(_borrower);\n        emit TroveLiquidated(_borrower, V.entireTroveDebt, V.entireTroveColl, TroveManagerOperation.liquidateInNormalMode);\n\n        return V;\n    }\n\n    // Liquidate one trove, in Recovery Mode.\n    function _liquidateRecoveryMode(address _borrower, uint _ICR, uint _LUSDInStabPool, uint _TCR) internal returns (LiquidationValues memory V) {\n        LocalVariables_InnerSingleLiquidateFunction memory L;\n        \n        if (TroveOwners.length <= 1) { return V; } // don't liquidate if last trove\n\n        (V.entireTroveDebt,\n        V.entireTroveColl,\n        L.pendingDebtReward,\n        L.pendingCollReward) = getEntireDebtAndColl(_borrower);\n\n        _movePendingTroveRewardsToActivePool(L.pendingDebtReward, L.pendingCollReward);\n\n        V.collGasCompensation = _getCollGasCompensation(V.entireTroveColl);\n        // In case of a partial liquidation, V.LUSDGasCompensation will be overwritten to zero, in the third branch below\n        V.LUSDGasCompensation = LUSD_GAS_COMPENSATION;\n        L.collToLiquidate = V.entireTroveColl.sub(V.collGasCompensation);\n\n        // If ICR <= 100%, purely redistribute the Trove across all active Troves\n        if (_ICR <= _100pct) {\n            _removeStake(_borrower);\n\n            V.debtToOffset = 0;\n            V.collToSendToSP = 0;\n            V.debtToRedistribute = V.entireTroveDebt;\n            V.collToRedistribute = L.collToLiquidate;\n\n            _closeTrove(_borrower);\n            emit TroveLiquidated(_borrower, V.entireTroveDebt, V.entireTroveColl, TroveManagerOperation.liquidateInRecoveryMode);\n\n        // If 100% < ICR < MCR, offset as much as possible, and redistribute the remainder\n        } else if ((_ICR > _100pct) && (_ICR < MCR)) {\n            _removeStake(_borrower);\n\n            (V.debtToOffset,\n            V.collToSendToSP,\n            V.debtToRedistribute,\n            V.collToRedistribute) = _getOffsetAndRedistributionVals(V.entireTroveDebt, L.collToLiquidate, _LUSDInStabPool);\n\n            _closeTrove(_borrower);\n            emit TroveLiquidated(_borrower, V.entireTroveDebt, V.entireTroveColl, TroveManagerOperation.liquidateInRecoveryMode);\n\n        /* \n        * If 110% <= ICR < current TCR (accounting for the preceding liquidations in the current sequence)\n        * and there is LUSD in the Stability Pool, only offset it as much as possible, with no redistribution.\n        */\n        } else if ((_ICR >= MCR) && (_ICR < _TCR)) {\n            assert(_LUSDInStabPool != 0);\n\n            _removeStake(_borrower);\n            \n            V = _getFullOrPartialOffsetVals(_borrower, V.entireTroveDebt, V.entireTroveColl, _LUSDInStabPool);\n\n            _closeTrove(_borrower);\n        }\n        else if (_ICR >= _TCR) {\n            LiquidationValues memory zeroVals;\n            return zeroVals;\n        }\n\n        return V;\n    }\n\n    /* In a full liquidation, returns the values for a trove's coll and debt to be offset, and coll and debt to be \n    * redistributed to active troves. \n    */\n    function _getOffsetAndRedistributionVals\n    (\n        uint _debt,\n        uint _coll,\n        uint _LUSDInStabPool\n    )\n        internal\n        pure\n        returns (uint debtToOffset, uint collToSendToSP, uint debtToRedistribute, uint collToRedistribute)\n    {\n        if (_LUSDInStabPool > 0) {\n        /* \n        * Offset as much debt & collateral as possible against the Stability Pool, and redistribute the remainder\n        * between all active troves.\n        *\n        *  If the trove's debt is larger than the deposited LUSD in the Stability Pool:\n        *\n        *  - Offset an amount of the trove's debt equal to the LUSD in the Stability Pool\n        *  - Send a fraction of the trove's collateral to the Stability Pool, equal to the fraction of its offset debt\n        *\n        */\n            debtToOffset = LiquityMath._min(_debt, _LUSDInStabPool);\n            collToSendToSP = _coll.mul(debtToOffset).div(_debt);\n            debtToRedistribute = _debt.sub(debtToOffset);\n            collToRedistribute = _coll.sub(collToSendToSP);\n        } else {\n            debtToOffset = 0;\n            collToSendToSP = 0;\n            debtToRedistribute = _debt;\n            collToRedistribute = _coll;\n        }\n    }\n\n    /*\n    *  If it is a full offset, get its offset coll/debt and ETH gas comp, and close the trove.\n    *\n    * If it is a partial liquidation, get its offset coll/debt and ETH gas comp, and its new coll/debt, and its re-insertion hints.\n    */\n    function _getFullOrPartialOffsetVals\n    (\n        address _borrower,\n        uint _entireTroveDebt,\n        uint _entireTroveColl,\n        uint _LUSDInStabPool\n    )\n        internal\n        returns (LiquidationValues memory V)\n    {\n        V.entireTroveDebt = _entireTroveDebt;\n        V.entireTroveColl = _entireTroveColl;\n\n        // When Stability Pool can fully absorb the trove's debt, perform a full offset\n        if (_entireTroveDebt <= _LUSDInStabPool) {\n            V.collGasCompensation = _getCollGasCompensation(_entireTroveColl);\n            V.LUSDGasCompensation = LUSD_GAS_COMPENSATION;\n\n            V.debtToOffset = _entireTroveDebt;\n            V.collToSendToSP = _entireTroveColl.sub(V.collGasCompensation);\n            V.debtToRedistribute = 0;\n            V.collToRedistribute = 0;\n\n            emit TroveLiquidated(_borrower, _entireTroveDebt, _entireTroveColl, TroveManagerOperation.liquidateInRecoveryMode);\n        }\n        /* \n        * When trove's debt is greater than the Stability Pool, perform a partial liquidation: offset as much as possible,\n        * and do not redistribute the remainder. The trove remains active, with a reduced collateral and debt.\n        *\n        * ETH gas compensation is based on and drawn from the collateral fraction that corresponds to the partial offset. \n        * LUSD gas compensation is left untouched. \n        *\n        * Since ETH gas comp is drawn purely from the *liquidated* portion, the trove is left with the same ICR as before the \n        * liquidation.\n        */\n        else if (_entireTroveDebt > _LUSDInStabPool) {\n            // Remaining debt in the trove is lower-bounded by the trove's gas compensation\n            V.partialNewDebt = LiquityMath._max(_entireTroveDebt.sub(_LUSDInStabPool), LUSD_GAS_COMPENSATION);\n          \n            V.debtToOffset = _entireTroveDebt.sub(V.partialNewDebt);\n\n            uint collFraction = _entireTroveColl.mul(V.debtToOffset).div(_entireTroveDebt);\n            V.collGasCompensation = _getCollGasCompensation(collFraction);\n          \n            V.LUSDGasCompensation = 0;  // LUSD gas compensation remains untouched\n\n            V.collToSendToSP = collFraction.sub(V.collGasCompensation);\n            V.collToRedistribute = 0;\n            V.debtToRedistribute = 0;\n\n            V.partialAddr = _borrower;\n            V.partialNewColl = _entireTroveColl.sub(collFraction);\n\n            // Get the partial trove's neighbours, so we can re-insert it later to the same position\n            V.partialUpperHint = sortedTroves.getPrev(_borrower);  \n            V.partialLowerHint = sortedTroves.getNext(_borrower);\n        }\n    }\n\n    /* \n    * Liquidate a sequence of troves. Closes a maximum number of n under-collateralized Troves,\n    * starting from the one with the lowest collateral ratio in the system, and moving upwards\n    */\n    function liquidateTroves(uint _n) external override {\n        LocalVariables_OuterLiquidationFunction memory L;\n\n        LiquidationTotals memory T;\n\n        L.price = priceFeed.getPrice();\n        L.LUSDInStabPool = stabilityPool.getTotalLUSDDeposits();\n        L.recoveryModeAtStart = checkRecoveryMode();\n\n        // Perform the appropriate liquidation sequence - tally the values, and obtain their totals\n        if (L.recoveryModeAtStart == true) {\n            T = _getTotalsFromLiquidateTrovesSequence_RecoveryMode(L.price, L.LUSDInStabPool, _n);\n        } else if (L.recoveryModeAtStart == false) {\n            T = _getTotalsFromLiquidateTrovesSequence_NormalMode(L.price, L.LUSDInStabPool, _n);\n        }\n\n        // Move liquidated ETH and LUSD to the appropriate pools\n        stabilityPool.offset(T.totalDebtToOffset, T.totalCollToSendToSP);\n        _redistributeDebtAndColl(T.totalDebtToRedistribute, T.totalCollToRedistribute);\n\n        // Update system snapshots and the final partially liquidated trove, if there is one\n        _updateSystemSnapshots_excludeCollRemainder(T.partialNewColl.add(T.totalCollGasCompensation));\n        _updatePartiallyLiquidatedTrove(T.partialAddr, T.partialNewDebt, T.partialNewColl, T.partialUpperHint, T. partialLowerHint, L.price);\n\n        L.liquidatedDebt = T.totalDebtInSequence.sub(T.partialNewDebt);\n        L.liquidatedColl = T.totalCollInSequence.sub(T.totalCollGasCompensation).sub(T.partialNewColl);\n        emit Liquidation(L.liquidatedDebt, L.liquidatedColl, T.totalCollGasCompensation, T.totalLUSDGasCompensation);\n\n        // Send gas compensation to caller\n        _sendGasCompensation(msg.sender, T.totalLUSDGasCompensation, T.totalCollGasCompensation);\n    }\n\n    /*\n    * This function is used when the liquidateTroves sequence starts during Recovery Mode. However, it\n    * handle the case where the system *leaves* Recovery Mode, part way through the liquidation sequence\n    */\n    function _getTotalsFromLiquidateTrovesSequence_RecoveryMode\n    (\n        uint _price,\n        uint _LUSDInStabPool,\n        uint _n\n    )\n        internal\n        returns(LiquidationTotals memory T)\n    {\n        LocalVariables_LiquidationSequence memory L;\n        LiquidationValues memory V;\n\n        L.remainingLUSDInStabPool = _LUSDInStabPool;\n        L.backToNormalMode = false;\n        L.entireSystemDebt = activePool.getLUSDDebt().add(defaultPool.getLUSDDebt());\n        L.entireSystemColl = activePool.getETH().add(defaultPool.getETH());\n\n        L.i = 0;\n        while (L.i < _n) {\n            L.user = sortedTroves.getLast();\n            L.ICR = getCurrentICR(L.user, _price);\n\n            if (L.backToNormalMode == false) {\n                // Break the loop if ICR is greater than MCR and Stability Pool is empty\n                if (L.ICR >= MCR && L.remainingLUSDInStabPool == 0) { break; }\n\n                uint TCR = LiquityMath._computeCR(L.entireSystemColl, L.entireSystemDebt, _price);\n        \n                V = _liquidateRecoveryMode(L.user, L.ICR, L.remainingLUSDInStabPool, TCR);\n\n                // Update aggregate trackers\n                L.remainingLUSDInStabPool = L.remainingLUSDInStabPool.sub(V.debtToOffset);\n                L.entireSystemDebt = L.entireSystemDebt.sub(V.debtToOffset);\n                L.entireSystemColl = L.entireSystemColl.sub(V.collToSendToSP);\n\n                // Add liquidation values to their respective running totals\n                T = _addLiquidationValuesToTotals(T, V);\n\n                // Break the loop if it was a partial liquidation\n                if (V.partialAddr != address(0)) {break;}\n\n                L.backToNormalMode = !_checkPotentialRecoveryMode(L.entireSystemColl, L.entireSystemDebt, _price);\n            }\n            else if (L.backToNormalMode == true && L.ICR < MCR) {\n                V = _liquidateNormalMode(L.user, L.remainingLUSDInStabPool);\n\n                L.remainingLUSDInStabPool = L.remainingLUSDInStabPool.sub(V.debtToOffset);\n\n                // Add liquidation values to their respective running totals\n                T = _addLiquidationValuesToTotals(T, V);\n\n            }  else break;  // break if the loop reaches a Trove with ICR >= MCR\n\n            // Break the loop if it reaches the first Trove in the sorted list\n            if (L.user == sortedTroves.getFirst()) { break; }\n\n            L.i++;\n        }\n    }\n\n    function _getTotalsFromLiquidateTrovesSequence_NormalMode\n    (\n        uint _price,\n        uint _LUSDInStabPool,\n        uint _n\n    )\n        internal\n        returns(LiquidationTotals memory T)\n    {\n        LocalVariables_LiquidationSequence memory L;\n        LiquidationValues memory V;\n\n        L.remainingLUSDInStabPool = _LUSDInStabPool;\n\n        L.i = 0;\n        while (L.i < _n) {\n            L.user = sortedTroves.getLast();\n            L.ICR = getCurrentICR(L.user, _price);\n\n            if (L.ICR < MCR) {\n                V = _liquidateNormalMode(L.user, L.remainingLUSDInStabPool);\n\n                L.remainingLUSDInStabPool = L.remainingLUSDInStabPool.sub(V.debtToOffset);\n\n                // Add liquidation values to their respective running totals\n                T = _addLiquidationValuesToTotals(T, V);\n\n            } else break;  // break if the loop reaches a Trove with ICR >= MCR\n\n            // Break the loop if it reaches the first Trove in the sorted list\n            if (L.user == sortedTroves.getFirst()) { break; }\n            L.i++;\n        }\n    }\n\n    /* \n    * Attempt to liquidate a custom list of troves provided by the caller. The liquidation sequence stops if\n    * a partial liquidation is performed, so it's up to the caller to order the troves in the _troveArray parameter.\n    */\n    function batchLiquidateTroves(address[] memory _troveArray) public override {\n        require(_troveArray.length != 0, \"TroveManager: Calldata address array must not be empty\");\n\n        LocalVariables_OuterLiquidationFunction memory L;\n        LiquidationTotals memory T;\n\n        L.price = priceFeed.getPrice();\n        L.LUSDInStabPool = stabilityPool.getTotalLUSDDeposits();\n        L.recoveryModeAtStart = checkRecoveryMode();\n\n        // Perform the appropriate liquidation sequence - tally values and obtain their totals.\n        if (L.recoveryModeAtStart == true) {\n           T = _getTotalFromBatchLiquidate_RecoveryMode(L.price, L.LUSDInStabPool, _troveArray);\n        } else if (L.recoveryModeAtStart == false) {\n            T = _getTotalsFromBatchLiquidate_NormalMode(L.price, L.LUSDInStabPool, _troveArray);\n        }\n\n        // Move liquidated ETH and LUSD to the appropriate pools\n        stabilityPool.offset(T.totalDebtToOffset, T.totalCollToSendToSP);\n        _redistributeDebtAndColl(T.totalDebtToRedistribute, T.totalCollToRedistribute);\n\n        // Update system snapshots and the final partially liquidated trove, if there is one\n        _updateSystemSnapshots_excludeCollRemainder(T.partialNewColl.add(T.totalCollGasCompensation));\n        _updatePartiallyLiquidatedTrove(T.partialAddr, T.partialNewDebt, T.partialNewColl, T.partialUpperHint, T. partialLowerHint, L.price);\n\n        L.liquidatedDebt = T.totalDebtInSequence.sub(T.partialNewDebt);\n        L.liquidatedColl = T.totalCollInSequence.sub(T.totalCollGasCompensation).sub(T.partialNewColl);\n        emit Liquidation(L.liquidatedDebt, L.liquidatedColl, T.totalCollGasCompensation, T.totalLUSDGasCompensation);\n\n        // Send gas compensation to caller\n        _sendGasCompensation(msg.sender, T.totalLUSDGasCompensation, T.totalCollGasCompensation);\n    }\n\n    /* \n    * This function is used when the batch liquidation sequence starts during Recovery Mode. However, it\n    * handle the case where the system *leaves* Recovery Mode, part way through the liquidation sequence\n    */\n    function _getTotalFromBatchLiquidate_RecoveryMode\n    (\n        uint _price,\n        uint _LUSDInStabPool,\n        address[] memory _troveArray)\n        internal\n        returns(LiquidationTotals memory T)\n    {\n        LocalVariables_LiquidationSequence memory L;\n        LiquidationValues memory V;\n\n        L.remainingLUSDInStabPool = _LUSDInStabPool;\n        L.backToNormalMode = false;\n        L.entireSystemDebt = activePool.getLUSDDebt().add(defaultPool.getLUSDDebt());\n        L.entireSystemColl = activePool.getETH().add(defaultPool.getETH());\n\n        L.i = 0;\n        for (L.i = 0; L.i < _troveArray.length; L.i++) {\n            L.user = _troveArray[L.i];\n            L.ICR = getCurrentICR(L.user, _price);\n\n            if (L.backToNormalMode == false) {\n\n                // Skip this trove if ICR is greater than MCR and Stability Pool is empty\n                if (L.ICR >= MCR && L.remainingLUSDInStabPool == 0) { continue; }\n\n                uint TCR = LiquityMath._computeCR(L.entireSystemColl, L.entireSystemDebt, _price);\n\n                V = _liquidateRecoveryMode(L.user, L.ICR, L.remainingLUSDInStabPool, TCR);\n\n                // Update aggregate trackers\n                L.remainingLUSDInStabPool = L.remainingLUSDInStabPool.sub(V.debtToOffset);\n                L.entireSystemDebt = L.entireSystemDebt.sub(V.debtToOffset);\n                L.entireSystemColl = L.entireSystemColl.sub(V.collToSendToSP);\n\n                // Add liquidation values to their respective running totals\n                T = _addLiquidationValuesToTotals(T, V);\n\n                // Break the loop if it was a partial liquidation\n                if (V.partialAddr != address(0)) { break; }\n\n                L.backToNormalMode = !_checkPotentialRecoveryMode(L.entireSystemColl, L.entireSystemDebt, _price);\n            }\n\n            else if (L.backToNormalMode == true && L.ICR < MCR) {\n                V = _liquidateNormalMode(L.user, L.remainingLUSDInStabPool);\n                L.remainingLUSDInStabPool = L.remainingLUSDInStabPool.sub(V.debtToOffset);\n\n                // Add liquidation values to their respective running totals\n                T = _addLiquidationValuesToTotals(T, V);\n            }\n        }\n    }\n\n    function _getTotalsFromBatchLiquidate_NormalMode\n    (\n        uint _price,\n        uint _LUSDInStabPool,\n        address[] memory _troveArray\n    )\n        internal\n        returns(LiquidationTotals memory T)\n    {\n        LocalVariables_LiquidationSequence memory L;\n        LiquidationValues memory V;\n\n        L.remainingLUSDInStabPool = _LUSDInStabPool;\n\n        for (L.i = 0; L.i < _troveArray.length; L.i++) {\n            L.user = _troveArray[L.i];\n            L.ICR = getCurrentICR(L.user, _price);\n\n            if (L.ICR < MCR) {\n                V = _liquidateNormalMode(L.user, L.remainingLUSDInStabPool);\n                L.remainingLUSDInStabPool = L.remainingLUSDInStabPool.sub(V.debtToOffset);\n\n                // Add liquidation values to their respective running totals\n                T = _addLiquidationValuesToTotals(T, V);\n            }\n        }\n    }\n\n    // --- Liquidation helper functions ---\n\n    function _addLiquidationValuesToTotals(LiquidationTotals memory T1, LiquidationValues memory V)\n    internal pure returns(LiquidationTotals memory T2) {\n\n        // Tally all the values with their respective running totals\n        T2.totalCollGasCompensation = T1.totalCollGasCompensation.add(V.collGasCompensation);\n        T2.totalLUSDGasCompensation = T1.totalLUSDGasCompensation.add(V.LUSDGasCompensation);\n        T2.totalDebtInSequence = T1.totalDebtInSequence.add(V.entireTroveDebt);\n        T2.totalCollInSequence = T1.totalCollInSequence.add(V.entireTroveColl);\n        T2.totalDebtToOffset = T1.totalDebtToOffset.add(V.debtToOffset);\n        T2.totalCollToSendToSP = T1.totalCollToSendToSP.add(V.collToSendToSP);\n        T2.totalDebtToRedistribute = T1.totalDebtToRedistribute.add(V.debtToRedistribute);\n        T2.totalCollToRedistribute = T1.totalCollToRedistribute.add(V.collToRedistribute);\n\n        // Assign the address of the partially liquidated trove, and its new debt and coll values\n        T2.partialAddr = V.partialAddr;\n        T2.partialNewDebt = V.partialNewDebt;\n        T2.partialNewColl = V.partialNewColl;\n        T2.partialUpperHint = V.partialUpperHint;\n        T2.partialLowerHint = V.partialLowerHint;\n\n        return T2;\n    }\n\n    // Update the properties of the partially liquidated trove, and insert it back to the list\n    function _updatePartiallyLiquidatedTrove\n    (\n        address _borrower, \n        uint _newDebt, \n        uint _newColl, \n        address _upperHint,\n        address _lowerHint,\n        uint _price\n    ) \n        internal \n    {\n        if ( _borrower == address(0)) { return; }\n\n        Troves[_borrower].debt = _newDebt;\n        Troves[_borrower].coll = _newColl;\n        Troves[_borrower].status = Status.active;\n\n        _updateTroveRewardSnapshots(_borrower);\n        _updateStakeAndTotalStakes(_borrower);\n\n        uint ICR = getCurrentICR(_borrower, _price);\n\n        /* \n        * Insert to sorted list and add to TroveOwners array. The partially liquidated trove has the same\n        * ICR as it did before the liquidation, so insertion is O(1): in principle, its ICR does not change.\n        * In practice, due to rounding error, its ICR can change slightly - so re-insert, with its previous neighbours\n        * as hints.\n        */\n        sortedTroves.insert(_borrower, ICR, _price, _upperHint, _lowerHint);\n        _addTroveOwnerToArray(_borrower);\n        emit TroveUpdated(_borrower, _newDebt, _newColl, Troves[_borrower].stake, TroveManagerOperation.partiallyLiquidateInRecoveryMode);\n    }\n\n    function _sendGasCompensation(address _liquidator, uint _LUSD, uint _ETH) internal {\n        if (_LUSD > 0) {\n            lusdToken.returnFromPool(GAS_POOL_ADDRESS, _liquidator, _LUSD);\n        }\n\n        if (_ETH > 0) {\n            activePool.sendETH(_liquidator, _ETH);\n        }\n    }\n\n    // Move a Trove's pending debt and collateral rewards from distributions, from the Default Pool to the Active Pool\n    function _movePendingTroveRewardsToActivePool(uint _LUSD, uint _ETH) internal {\n        defaultPool.decreaseLUSDDebt(_LUSD);\n        activePool.increaseLUSDDebt(_LUSD);\n        defaultPool.sendETH(address(activePool), _ETH);\n    }\n\n    // --- Redemption functions ---\n\n    // Redeem as much collateral as possible from _borrower's Trove in exchange for LUSD up to _maxLUSDamount\n    function _redeemCollateralFromTrove(\n        address _borrower,\n        uint _maxLUSDamount,\n        uint _price,\n        address _partialRedemptionHint,\n        uint _partialRedemptionHintICR\n    )\n        internal returns (SingleRedemptionValues memory V)\n    {\n        // Determine the remaining amount (lot) to be redeemed, capped by the entire debt of the Trove minus the gas compensation\n        V.LUSDLot = LiquityMath._min(_maxLUSDamount, Troves[_borrower].debt.sub(LUSD_GAS_COMPENSATION));\n\n        // Get the ETHLot of equivalent value in USD\n        V.ETHLot = V.LUSDLot.mul(1e18).div(_price);\n\n        // Decrease the debt and collateral of the current Trove according to the LUSD lot and corresponding ETH to send\n        uint newDebt = (Troves[_borrower].debt).sub(V.LUSDLot);\n        uint newColl = (Troves[_borrower].coll).sub(V.ETHLot);\n\n        if (newDebt == LUSD_GAS_COMPENSATION) {\n            // No debt left in the Trove (except for the gas compensation), therefore the trove gets closed\n            _removeStake(_borrower);\n            _closeTrove(_borrower);\n            _redeemCloseTrove(_borrower, LUSD_GAS_COMPENSATION, newColl);\n\n        } else {\n            uint newICR = LiquityMath._computeCR(newColl, newDebt, _price);\n\n            // Check if the provided hint is fresh. If not, we bail since trying to reinsert without a good hint will almost\n            // certainly result in running out of gas.\n            if (newICR != _partialRedemptionHintICR) {\n                V.LUSDLot = 0;\n                V.ETHLot = 0;\n                return V;\n            }\n\n            sortedTroves.reInsert(_borrower, newICR, _price, _partialRedemptionHint, _partialRedemptionHint);\n\n            Troves[_borrower].debt = newDebt;\n            Troves[_borrower].coll = newColl;\n            _updateStakeAndTotalStakes(_borrower);\n        }\n        emit TroveUpdated(\n            _borrower,\n            newDebt, newColl,\n            Troves[_borrower].stake,\n            TroveManagerOperation.redeemCollateral\n        );\n        return V;\n    }\n\n    /* \n    * Called when a full redemption occurs, and closes the trove.\n    * The redeemer swaps (debt - 10) LUSD for (debt - 10) worth of ETH, so the 10 LUSD gas compensation left corresponds to the remaining debt.\n    * In order to close the trove, the 10 LUSD gas compensation is burned, and 10 debt is removed from the active pool.\n    * The debt recorded on the trove's struct is zero'd elswhere, in _closeTrove.\n    * Any surplus ETH left in the trove, is sent to the Coll surplus pool, and can be later claimed by the borrower.\n    */ \n    function _redeemCloseTrove(address _borrower, uint _LUSD, uint _ETH) internal {\n        lusdToken.burn(GAS_POOL_ADDRESS, _LUSD);\n        // Update Active Pool LUSD, and send ETH to account\n        activePool.decreaseLUSDDebt(_LUSD);\n\n        // send ETH from Active Pool to CollSurplus Pool\n        collSurplusPool.accountSurplus(_borrower, _ETH);\n        activePool.sendETH(address(collSurplusPool), _ETH);\n    }\n\n    function _isValidFirstRedemptionHint(address _firstRedemptionHint, uint _price) internal view returns (bool) {\n        if (_firstRedemptionHint == address(0) ||\n            !sortedTroves.contains(_firstRedemptionHint) ||\n            getCurrentICR(_firstRedemptionHint, _price) < MCR\n        ) {\n            return false;\n        }\n\n        address nextTrove = sortedTroves.getNext(_firstRedemptionHint);\n        return nextTrove == address(0) || getCurrentICR(nextTrove, _price) < MCR;\n    }\n\n    /* Send _LUSDamount LUSD to the system and redeem the corresponding amount of collateral from as many Troves as are needed to fill the redemption\n    * request.  Applies pending rewards to a Trove before reducing its debt and coll.\n    *\n    * Note that if _amount is very large, this function can run out of gas, specially if traversed troves are small. This can be easily avoided by \n    * splitting the total _amount in appropriate chunks and calling the function multiple times.\n    * \n    * Param `_maxIterations` can also be provided, so the loop through Troves is capped (if its zero, it will be ignored).This makes it easier to \n    * avoid OOG for the frontend, as only knowing approximately the average cost of an iteration is enough, without needing to know the topology \n    * of the trove list. It also avoids the need to set the cap in stone in the contract, nor doing gas calculations, as both gas price and opcode \n    * costs can vary.\n    * \n    * All Troves that are redeemed from -- with the likely exception of the last one -- will end up with no debt left, therefore they will be closed.\n    * If the last Trove does have some remaining debt, it has a finite ICR, and the reinsertion could be anywhere in the list, therefore it requires a hint. \n    * A frontend should use getRedemptionHints() to calculate what the ICR of this Trove will be after redemption, and pass a hint for its position \n    * in the sortedTroves list along with the ICR value that the hint was found for.\n    * \n    * If another transaction modifies the list between calling getRedemptionHints() and passing the hints to redeemCollateral(), it\n    * is very likely that the last (partially) redeemed Trove would end up with a different ICR than what the hint is for. In this case the\n    * redemption will stop after the last completely redeemed Trove and the sender will keep the remaining LUSD amount, which they can attempt\n    * to redeem later.\n    */\n    function redeemCollateral(\n        uint _LUSDamount,\n        address _firstRedemptionHint,\n        address _partialRedemptionHint,\n        uint _partialRedemptionHintICR,\n        uint _maxIterations\n    )\n        external\n        override\n    {\n        uint activeDebt = activePool.getLUSDDebt();\n        uint defaultedDebt = defaultPool.getLUSDDebt();\n\n        RedemptionTotals memory T;\n\n        _requireAmountGreaterThanZero(_LUSDamount);\n        _requireLUSDBalanceCoversRedemption(msg.sender, _LUSDamount);\n\n        // Confirm redeemer's balance is less than total systemic debt\n        assert(lusdToken.balanceOf(msg.sender) <= (activeDebt.add(defaultedDebt)));\n\n        uint remainingLUSD = _LUSDamount;\n        uint price = priceFeed.getPrice();\n        address currentBorrower;\n\n        if (_isValidFirstRedemptionHint(_firstRedemptionHint, price)) {\n            currentBorrower = _firstRedemptionHint;\n        } else {\n            currentBorrower = sortedTroves.getLast();\n            // Find the first trove with ICR >= MCR\n            // SWC-104-Unchecked Call Return Value: L920\n            while (currentBorrower != address(0) && getCurrentICR(currentBorrower, price) < MCR) {\n                currentBorrower = sortedTroves.getPrev(currentBorrower);\n            }\n        }\n\n        // Loop through the Troves starting from the one with lowest collateral ratio until _amount of LUSD is exchanged for collateral\n        if (_maxIterations == 0) { _maxIterations = uint(-1); }\n        while (currentBorrower != address(0) && remainingLUSD > 0 && _maxIterations > 0) {\n            _maxIterations--;\n            // Save the address of the Trove preceding the current one, before potentially modifying the list\n            address nextUserToCheck = sortedTroves.getPrev(currentBorrower);\n\n            _applyPendingRewards(currentBorrower);\n            SingleRedemptionValues memory V = _redeemCollateralFromTrove(\n                currentBorrower,\n                remainingLUSD,\n                price,\n                _partialRedemptionHint,\n                _partialRedemptionHintICR\n            );\n\n            if (V.LUSDLot == 0) break; // Partial redemption hint got out-of-date, therefore we could not redeem from the last Trove\n\n            T.totalLUSDToRedeem  = T.totalLUSDToRedeem.add(V.LUSDLot);\n            T.totalETHDrawn = T.totalETHDrawn.add(V.ETHLot);\n\n            remainingLUSD = remainingLUSD.sub(V.LUSDLot);\n            currentBorrower = nextUserToCheck;\n        }\n\n        // Decay the baseRate due to time passed, and then increase it according to the size of this redemption\n        _updateBaseRateFromRedemption(T.totalETHDrawn, price);\n\n        // Calculate the ETH fee and send it to the LQTY staking contract\n        T.ETHFee = _getRedemptionFee(T.totalETHDrawn);\n        activePool.sendETH(lqtyStakingAddress, T.ETHFee);\n        lqtyStaking.increaseF_ETH(T.ETHFee);\n\n        T.ETHToSendToRedeemer = T.totalETHDrawn.sub(T.ETHFee);\n\n        // Burn the total LUSD that is cancelled with debt, and send the redeemed ETH to msg.sender\n        _activePoolRedeemCollateral(msg.sender, T.totalLUSDToRedeem, T.ETHToSendToRedeemer);\n\n        emit Redemption(_LUSDamount, T.totalLUSDToRedeem, T.totalETHDrawn, T.ETHFee);\n    }\n\n    // Burn the received LUSD, transfer the redeemed ETH to _redeemer and updates the Active Pool\n    function _activePoolRedeemCollateral(address _redeemer, uint _LUSD, uint _ETH) internal {\n        // Update Active Pool LUSD, and send ETH to account\n        lusdToken.burn(_redeemer, _LUSD);\n        activePool.decreaseLUSDDebt(_LUSD);\n\n        activePool.sendETH(_redeemer, _ETH);\n    }\n\n    // --- Helper functions ---\n\n\n    // Return the current collateral ratio (ICR) of a given Trove. Takes a trove's pending coll and debt rewards from redistributions into account.\n    function getCurrentICR(address _borrower, uint _price) public view override returns (uint) {\n        uint pendingETHReward = getPendingETHReward(_borrower);\n        uint pendingLUSDDebtReward = getPendingLUSDDebtReward(_borrower);\n\n        uint currentETH = Troves[_borrower].coll.add(pendingETHReward);\n        uint currentLUSDDebt = Troves[_borrower].debt.add(pendingLUSDDebtReward);\n\n        uint ICR = LiquityMath._computeCR(currentETH, currentLUSDDebt, _price);\n        return ICR;\n    }\n\n    function applyPendingRewards(address _borrower) external override {\n        _requireCallerIsBorrowerOperations();\n        return _applyPendingRewards(_borrower);\n    }\n\n    // Add the borrowers's coll and debt rewards earned from redistributions, to their Trove\n    function _applyPendingRewards(address _borrower) internal {\n        if (hasPendingRewards(_borrower)) {\n            _requireTroveisActive(_borrower);\n\n            // Compute pending rewards\n            uint pendingETHReward = getPendingETHReward(_borrower);\n            uint pendingLUSDDebtReward = getPendingLUSDDebtReward(_borrower);\n\n            // Apply pending rewards to trove's state\n            Troves[_borrower].coll = Troves[_borrower].coll.add(pendingETHReward);\n            Troves[_borrower].debt = Troves[_borrower].debt.add(pendingLUSDDebtReward);\n\n            _updateTroveRewardSnapshots(_borrower);\n\n            // Transfer from DefaultPool to ActivePool\n            _movePendingTroveRewardsToActivePool(pendingLUSDDebtReward, pendingETHReward);\n\n            emit TroveUpdated(\n                _borrower, \n                Troves[_borrower].debt, \n                Troves[_borrower].coll, \n                Troves[_borrower].stake, \n                TroveManagerOperation.applyPendingRewards\n            );\n        }\n    }\n\n    // Update borrower's snapshots of L_ETH and L_LUSDDebt to reflect the current values\n    function updateTroveRewardSnapshots(address _borrower) external override {\n        _requireCallerIsBorrowerOperations();\n       return _updateTroveRewardSnapshots(_borrower);\n    }\n\n    function _updateTroveRewardSnapshots(address _borrower) internal {\n        rewardSnapshots[_borrower].ETH = L_ETH;\n        rewardSnapshots[_borrower].LUSDDebt = L_LUSDDebt;\n    }\n\n    // Get the borrower's pending accumulated ETH reward, earned by their stake\n    function getPendingETHReward(address _borrower) public view override returns (uint) {\n        uint snapshotETH = rewardSnapshots[_borrower].ETH;\n        uint rewardPerUnitStaked = L_ETH.sub(snapshotETH);\n\n        if ( rewardPerUnitStaked == 0 ) { return 0; }\n\n        uint stake = Troves[_borrower].stake;\n\n        uint pendingETHReward = stake.mul(rewardPerUnitStaked).div(1e18);\n\n        return pendingETHReward;\n    }\n\n     // Get the borrower's pending accumulated LUSD reward, earned by their stake\n    function getPendingLUSDDebtReward(address _borrower) public view override returns (uint) {\n        uint snapshotLUSDDebt = rewardSnapshots[_borrower].LUSDDebt;\n        uint rewardPerUnitStaked = L_LUSDDebt.sub(snapshotLUSDDebt);\n\n        if ( rewardPerUnitStaked == 0 ) { return 0; }\n\n        uint stake =  Troves[_borrower].stake;\n\n        uint pendingLUSDDebtReward = stake.mul(rewardPerUnitStaked).div(1e18);\n\n        return pendingLUSDDebtReward;\n    }\n\n    function hasPendingRewards(address _borrower) public view override returns (bool) {\n        /* \n        * A Trove has pending rewards if its snapshot is less than the current rewards per-unit-staked sum:\n        * this indicates that rewards have occured since the snapshot was made, and the user therefore has\n        * pending rewards \n        */\n        return (rewardSnapshots[_borrower].ETH < L_ETH);\n    }\n\n    // Return the Troves entire debt and coll, including pending rewards from redistributions.\n    function getEntireDebtAndColl(\n        address _borrower\n    )\n        public\n        view\n        override\n        returns (uint debt, uint coll, uint pendingLUSDDebtReward, uint pendingETHReward)\n    {\n        debt = Troves[_borrower].debt;\n        coll = Troves[_borrower].coll;\n\n        pendingLUSDDebtReward = getPendingLUSDDebtReward(_borrower);\n        pendingETHReward = getPendingETHReward(_borrower);\n\n        debt = debt.add(pendingLUSDDebtReward);\n        coll = coll.add(pendingETHReward);\n    }\n\n    function removeStake(address _borrower) external override {\n        _requireCallerIsBorrowerOperations();\n        return _removeStake(_borrower);\n    }\n\n    // Remove borrower's stake from the totalStakes sum, and set their stake to 0\n    function _removeStake(address _borrower) internal {\n        uint stake = Troves[_borrower].stake;\n        totalStakes = totalStakes.sub(stake);\n        Troves[_borrower].stake = 0;\n    }\n\n    function updateStakeAndTotalStakes(address _borrower) external override returns (uint) {\n        _requireCallerIsBorrowerOperations();\n        return _updateStakeAndTotalStakes(_borrower);\n    }\n\n    // Update borrower's stake based on their latest collateral value\n    function _updateStakeAndTotalStakes(address _borrower) internal returns (uint) {\n        uint newStake = _computeNewStake(Troves[_borrower].coll);\n        uint oldStake = Troves[_borrower].stake;\n        Troves[_borrower].stake = newStake;\n        totalStakes = totalStakes.sub(oldStake).add(newStake);\n\n        return newStake;\n    }\n\n    // Calculate a new stake based on the snapshots of the totalStakes and totalCollateral taken at the last liquidation\n    function _computeNewStake(uint _coll) internal view returns (uint) {\n        uint stake;\n        if (totalCollateralSnapshot == 0) {\n            stake = _coll;\n        } else {\n            /*  \n            * The following assert() holds true because:\n            * - The system always contains >= 1 trove \n            * - When we close or liquidate a trove, we redistribute the pending rewards, so if all troves were closed/liquidated, \n            * rewards wouldve been emptied and totalCollateralSnapshot would be zero too.\n            */\n            assert(totalStakesSnapshot > 0);\n            stake = _coll.mul(totalStakesSnapshot).div(totalCollateralSnapshot);\n        }\n        return stake;\n    }\n\n    function _redistributeDebtAndColl(uint _debt, uint _coll) internal {\n        if (_debt == 0) { return; }\n\n        if (totalStakes > 0) {\n            /* \n            * Add distributed coll and debt rewards-per-unit-staked to the running totals.\n            * Division uses a \"feedback\" error correction, to keep the cumulative error in\n            * the  L_ETH and L_LUSDDebt state variables low. \n            */\n            uint ETHNumerator = _coll.mul(1e18).add(lastETHError_Redistribution);\n            uint LUSDDebtNumerator = _debt.mul(1e18).add(lastLUSDDebtError_Redistribution);\n\n            uint ETHRewardPerUnitStaked = ETHNumerator.div(totalStakes);\n            uint LUSDDebtRewardPerUnitStaked = LUSDDebtNumerator.div(totalStakes);\n\n            lastETHError_Redistribution = ETHNumerator.sub(ETHRewardPerUnitStaked.mul(totalStakes));\n            lastLUSDDebtError_Redistribution = LUSDDebtNumerator.sub(LUSDDebtRewardPerUnitStaked.mul(totalStakes));\n\n            L_ETH = L_ETH.add(ETHRewardPerUnitStaked);\n            L_LUSDDebt = L_LUSDDebt.add(LUSDDebtRewardPerUnitStaked);\n        }\n\n        // Transfer coll and debt from ActivePool to DefaultPool\n        activePool.decreaseLUSDDebt(_debt);\n        defaultPool.increaseLUSDDebt(_debt);\n        activePool.sendETH(address(defaultPool), _coll);\n    }\n\n    function closeTrove(address _borrower) external override {\n        _requireCallerIsBorrowerOperations();\n        return _closeTrove(_borrower);\n    }\n\n    function _closeTrove(address _borrower) internal {\n        uint TroveOwnersArrayLength = TroveOwners.length;\n        _requireMoreThanOneTroveInSystem(TroveOwnersArrayLength);\n\n        Troves[_borrower].status = Status.closed;\n        Troves[_borrower].coll = 0;\n        Troves[_borrower].debt = 0;\n\n        rewardSnapshots[_borrower].ETH = 0;\n        rewardSnapshots[_borrower].LUSDDebt = 0;\n\n        _removeTroveOwner(_borrower, TroveOwnersArrayLength);\n        sortedTroves.remove(_borrower);\n    }\n\n    /* \n    * Updates snapshots of system total stakes and total collateral, excluding a given collateral remainder from the calculation. \n    * Used in a liquidation sequence.\n    *\n    * The calculation excludes two portions of collateral that are in the ActivePool: \n    *\n    * 1) the total ETH gas compensation from the liquidation sequence\n    * 2) The remaining collateral in a partially liquidated trove (if one occurred)\n    *\n    * The ETH as compensation must be excluded as it is always sent out at the very end of the liquidation sequence.\n    *\n    * The partially liquidated trove's remaining collateral stays in the ActivePool, but it is excluded here so the system \n    * can take snapshots before the partially liquidated trove's stake is updated (based on these snapshots). This ensures\n    * the partial's new stake doesn't double-count its own remaining collateral.\n    *\n    */\n    function _updateSystemSnapshots_excludeCollRemainder(uint _collRemainder) internal {\n        totalStakesSnapshot = totalStakes;\n\n        uint activeColl = activePool.getETH();\n        uint liquidatedColl = defaultPool.getETH();\n        totalCollateralSnapshot = activeColl.sub(_collRemainder).add(liquidatedColl);\n    }\n\n    // Push the owner's address to the Trove owners list, and record the corresponding array index on the Trove struct\n    function addTroveOwnerToArray(address _borrower) external override returns (uint index) {\n        _requireCallerIsBorrowerOperations();\n        return _addTroveOwnerToArray(_borrower);\n    }\n\n    function _addTroveOwnerToArray(address _borrower) internal returns (uint128 index) {\n        require(TroveOwners.length < 2**128 - 1, \"TroveManager: TroveOwners array has maximum size of 2^128 - 1\");\n\n        // Push the Troveowner to the array\n        TroveOwners.push(_borrower);\n\n        // Record the index of the new Troveowner on their Trove struct\n        index = uint128(TroveOwners.length.sub(1));\n        Troves[_borrower].arrayIndex = index;\n\n        return index;\n    }\n\n    /* \n    * Remove a Trove owner from the TroveOwners array, not preserving array order. Removing owner 'B' does the following:\n    * [A B C D E] => [A E C D], and updates E's Trove struct to point to its new array index. \n    */\n    function _removeTroveOwner(address _borrower, uint TroveOwnersArrayLength) internal {\n        require(Troves[_borrower].status == Status.closed, \"TroveManager: Trove is still active\");\n\n        uint128 index = Troves[_borrower].arrayIndex;\n        uint length = TroveOwnersArrayLength;\n        uint idxLast = length.sub(1);\n\n        assert(index <= idxLast);\n\n        address addressToMove = TroveOwners[idxLast];\n\n        TroveOwners[index] = addressToMove;\n        Troves[addressToMove].arrayIndex = index;\n        TroveOwners.pop();\n    }\n\n    // --- Recovery Mode and TCR functions ---\n\n    function checkRecoveryMode() public view override returns (bool) {\n        uint TCR = getTCR();\n\n        if (TCR < CCR) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    // Check whether or not the system *would be* in Recovery Mode, given an ETH:USD price, and the entire system coll and debt.\n    function _checkPotentialRecoveryMode(\n        uint _entireSystemColl,\n        uint _entireSystemDebt,\n        uint _price\n    )\n        internal\n        pure\n    returns (bool)\n    {\n        uint TCR = LiquityMath._computeCR(_entireSystemColl, _entireSystemDebt, _price);\n        if (TCR < CCR) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n    // SWC-135-Code With No Effects: L1276-L1284\n    function getTCR() public view override returns (uint TCR) {\n        uint price = priceFeed.getPrice();\n        uint entireSystemColl = getEntireSystemColl();\n        uint entireSystemDebt = getEntireSystemDebt();\n\n        TCR = LiquityMath._computeCR(entireSystemColl, entireSystemDebt, price);\n\n        return TCR;\n    }\n    // SWC-135-Code With No Effects: L1286-L1291\n    function getEntireSystemColl() public view override returns (uint entireSystemColl) {\n        uint activeColl = activePool.getETH();\n        uint liquidatedColl = defaultPool.getETH();\n\n        return activeColl.add(liquidatedColl);\n    }\n\n    function getEntireSystemDebt() public view override returns (uint entireSystemDebt) {\n        uint activeDebt = activePool.getLUSDDebt();\n        uint closedDebt = defaultPool.getLUSDDebt();\n\n        return activeDebt.add(closedDebt);\n    }\n\n    // --- Redemption fee functions ---\n\n    /* \n    * This function has two impacts on the baseRate state variable:\n    * 1) decays the baseRate based on time passed since last redemption or LUSD borrowing operation.\n    * then,\n    * 2) increases the baseRate based on the amount redeemed, as a proportion of total supply\n    */\n    function _updateBaseRateFromRedemption(uint _ETHDrawn,  uint _price) internal returns (uint) {\n        uint decayedBaseRate = _calcDecayedBaseRate();\n\n        uint activeDebt = activePool.getLUSDDebt();\n        uint closedDebt = defaultPool.getLUSDDebt();\n        uint totalLUSDSupply = activeDebt.add(closedDebt);\n\n        /* Convert the drawn ETH back to LUSD at face value rate (1 LUSD:1 USD), in order to get\n        * the fraction of total supply that was redeemed at face value. */\n        uint redeemedLUSDFraction = _ETHDrawn.mul(_price).div(totalLUSDSupply);\n\n        uint newBaseRate = decayedBaseRate.add(redeemedLUSDFraction.div(BETA));\n\n        // Update the baseRate state variable\n        baseRate = newBaseRate < 1e18 ? newBaseRate : 1e18;  // cap baseRate at a maximum of 100%\n        assert(baseRate <= 1e18 && baseRate > 0); // Base rate is always non-zero after redemption\n\n        _updateLastFeeOpTime();\n\n        return baseRate;\n    }\n\n    function _getRedemptionFee(uint _ETHDrawn) internal view returns (uint) {\n       return baseRate.mul(_ETHDrawn).div(1e18);\n    }\n\n    // --- Borrowing fee functions ---\n\n    function getBorrowingFee(uint _LUSDDebt) external view override returns (uint) {\n        return _LUSDDebt.mul(baseRate).div(1e18);\n    }\n\n    // Updates the baseRate state variable based on time elapsed since the last redemption or LUSD borrowing operation.\n    function decayBaseRateFromBorrowing() external override {\n        _requireCallerIsBorrowerOperations();\n\n        baseRate = _calcDecayedBaseRate();\n        assert(baseRate <= 1e18);  // The baseRate can decay to 0\n\n        _updateLastFeeOpTime();\n    }\n\n    // --- Internal fee functions ---\n\n    // Update the last fee operation time only if time passed >= decay interval. This prevents base rate griefing.\n    function _updateLastFeeOpTime() internal {\n        uint timePassed = block.timestamp.sub(lastFeeOperationTime);\n\n        if (timePassed >= SECONDS_IN_ONE_MINUTE) {\n            lastFeeOperationTime = block.timestamp;\n        }\n    }\n\n    function _calcDecayedBaseRate() internal view returns (uint) {\n        uint minutesPassed = _minutesPassedSinceLastFeeOp();\n        uint decayFactor = LiquityMath._decPow(MINUTE_DECAY_FACTOR, minutesPassed);\n\n        return baseRate.mul(decayFactor).div(1e18);\n    }\n\n    function _minutesPassedSinceLastFeeOp() internal view returns (uint) {\n        return (block.timestamp.sub(lastFeeOperationTime)).div(SECONDS_IN_ONE_MINUTE);\n    }\n\n    // --- 'require' wrapper functions ---\n\n    function _requireCallerIsBorrowerOperations() internal view {\n        require(msg.sender == borrowerOperationsAddress, \"TroveManager: Caller is not the BorrowerOperations contract\");\n    }\n\n    function _requireTroveisActive(address _borrower) internal view {\n        require(Troves[_borrower].status == Status.active, \"TroveManager: Trove does not exist or is closed\");\n    }\n\n    function _requireLUSDBalanceCoversRedemption(address _redeemer, uint _amount) internal view {\n        require(lusdToken.balanceOf(_redeemer) >= _amount, \"TroveManager: Requested redemption amount must be <= user's LUSD token balance\");\n    }\n\n    function _requireMoreThanOneTroveInSystem(uint TroveOwnersArrayLength) internal view {\n        require (TroveOwnersArrayLength > 1 && sortedTroves.getSize() > 1, \"TroveManager: Only one trove in the system\");\n    }\n\n    function _requireAmountGreaterThanZero(uint _amount) internal pure {\n        require(_amount > 0, \"TroveManager: Amount must be greater than zero\");\n    }\n\n    // --- Trove property getters ---\n\n    function getTroveStatus(address _borrower) external view override returns (uint) {\n        return uint(Troves[_borrower].status);\n    }\n\n    function getTroveStake(address _borrower) external view override returns (uint) {\n        return Troves[_borrower].stake;\n    }\n\n    function getTroveDebt(address _borrower) external view override returns (uint) {\n        return Troves[_borrower].debt;\n    }\n\n    function getTroveColl(address _borrower) external view override returns (uint) {\n        return Troves[_borrower].coll;\n    }\n\n    // --- Trove property setters, called by BorrowerOperations ---\n\n    function setTroveStatus(address _borrower, uint _num) external override {\n        _requireCallerIsBorrowerOperations();\n        Troves[_borrower].status = Status(_num);\n    }\n\n    function increaseTroveColl(address _borrower, uint _collIncrease) external override returns (uint) {\n        _requireCallerIsBorrowerOperations();\n        uint newColl = Troves[_borrower].coll.add(_collIncrease);\n        Troves[_borrower].coll = newColl;\n        return newColl;\n    }\n\n    function decreaseTroveColl(address _borrower, uint _collDecrease) external override returns (uint) {\n        _requireCallerIsBorrowerOperations();\n        uint newColl = Troves[_borrower].coll.sub(_collDecrease);\n        Troves[_borrower].coll = newColl;\n        return newColl;\n    }\n\n    function increaseTroveDebt(address _borrower, uint _debtIncrease) external override returns (uint) {\n        _requireCallerIsBorrowerOperations();\n        uint newDebt = Troves[_borrower].debt.add(_debtIncrease);\n        Troves[_borrower].debt = newDebt;\n        return newDebt;\n    }\n\n    function decreaseTroveDebt(address _borrower, uint _debtDecrease) external override returns (uint) {\n        _requireCallerIsBorrowerOperations();\n        uint newDebt = Troves[_borrower].debt.sub(_debtDecrease);\n        Troves[_borrower].debt = newDebt;\n        return newDebt;\n    }\n}",
        "function": "decayBaseRateFromBorrowing()",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-Liquity/dev-f0df3efa5a5f05b205752184cfce107c5bd6e06c/packages/contracts/contracts/TroveManager.sol",
        "vulnerability": "Dependence on predictable environment variable (SWC 116)",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract TroveManager is LiquityBase, Ownable, ITroveManager {\n\n    // --- Connected contract declarations ---\n\n    address public borrowerOperationsAddress;\n\n    IPool public activePool;\n\n    IPool public defaultPool;\n\n    IStabilityPool public stabilityPool;\n\n    ICollSurplusPool collSurplusPool;\n\n    ILUSDToken public lusdToken;\n\n    IPriceFeed public priceFeed;\n\n    ILQTYStaking public lqtyStaking;\n    address public lqtyStakingAddress;\n\n    // A doubly linked list of Troves, sorted by their sorted by their collateral ratios\n    ISortedTroves public sortedTroves;\n\n    // --- Data structures ---\n\n    uint constant public SECONDS_IN_ONE_MINUTE = 60;\n    uint constant public MINUTE_DECAY_FACTOR = 999832508430720967;  // 18 digit decimal. Corresponds to an hourly decay factor of 0.99\n\n    /* \n    * BETA: 18 digit decimal. Parameter by which to divide the redeemed fraction, in order to calc the new base rate from a redemption. \n    * Corresponds to (1 / ALPHA) in the white paper. \n    */\n    uint constant public BETA = 2;\n\n    uint public baseRate;\n\n    // The timestamp of the latest fee operation (redemption or new LUSD issuance) \n    uint public lastFeeOperationTime;\n\n    enum Status { nonExistent, active, closed }\n\n    // Store the necessary data for a trove\n    struct Trove {\n        uint debt;\n        uint coll;\n        uint stake;\n        Status status;\n        uint128 arrayIndex;\n    }\n\n    mapping (address => Trove) public Troves;\n\n    uint public totalStakes;\n\n    // Snapshot of the value of totalStakes, taken immediately after the latest liquidation\n    uint public totalStakesSnapshot;\n\n    // Snapshot of the total collateral across the ActivePool and DefaultPool, immediately after the latest liquidation.\n    uint public totalCollateralSnapshot;\n\n    /*\n    * L_ETH and L_LUSDDebt track the sums of accumulated liquidation rewards per unit staked. During its lifetime, each stake earns:\n    *\n    * An ETH gain of ( stake * [L_ETH - L_ETH(0)] )\n    * A LUSDDebt increase  of ( stake * [L_LUSDDebt - L_LUSDDebt(0)] )\n    *\n    * Where L_ETH(0) and L_LUSDDebt(0) are snapshots of L_ETH and L_LUSDDebt for the active Trove taken at the instant the stake was made\n    */\n    uint public L_ETH;\n    uint public L_LUSDDebt;\n\n    // Map addresses with active troves to their RewardSnapshot\n    mapping (address => RewardSnapshot) public rewardSnapshots;\n\n    // Object containing the ETH and LUSD snapshots for a given active trove\n    struct RewardSnapshot { uint ETH; uint LUSDDebt;}\n\n    // Array of all active trove addresses - used to to compute an approximate hint off-chain, for the sorted list insertion\n    address[] public TroveOwners;\n\n    // Error trackers for the trove redistribution calculation\n    uint public lastETHError_Redistribution;\n    uint public lastLUSDDebtError_Redistribution;\n\n    /* \n    * --- Variable container structs for liquidations ---\n    *\n    * These structs are used to hold, return and assign variables inside the liquidation functions,\n    * in order to avoid the error: \"CompilerError: Stack too deep\". \n    **/\n\n    struct LocalVariables_OuterLiquidationFunction {\n        uint price;\n        uint LUSDInStabPool;\n        bool recoveryModeAtStart;\n        uint liquidatedDebt;\n        uint liquidatedColl;\n    }\n\n    struct LocalVariables_InnerSingleLiquidateFunction {\n        uint collToLiquidate;\n        uint pendingDebtReward;\n        uint pendingCollReward;\n    }\n\n    struct LocalVariables_LiquidationSequence {\n        uint remainingLUSDInStabPool;\n        uint i;\n        uint ICR;\n        address user;\n        bool backToNormalMode;\n        uint entireSystemDebt;\n        uint entireSystemColl;\n    }\n\n    struct LiquidationValues {\n        uint entireTroveDebt;\n        uint entireTroveColl;\n        uint collGasCompensation;\n        uint LUSDGasCompensation;\n        uint debtToOffset;\n        uint collToSendToSP;\n        uint debtToRedistribute;\n        uint collToRedistribute;\n        address partialAddr;\n        uint partialNewDebt;\n        uint partialNewColl;\n        address partialUpperHint;\n        address partialLowerHint;\n    }\n\n    struct LiquidationTotals {\n        uint totalCollInSequence;\n        uint totalDebtInSequence;\n        uint totalCollGasCompensation;\n        uint totalLUSDGasCompensation;\n        uint totalDebtToOffset;\n        uint totalCollToSendToSP;\n        uint totalDebtToRedistribute;\n        uint totalCollToRedistribute;\n        address partialAddr;\n        uint partialNewDebt;\n        uint partialNewColl;\n        address partialUpperHint;\n        address partialLowerHint;\n    }\n\n    // --- Variable container structs for redemptions ---\n\n    struct RedemptionTotals {\n        uint totalLUSDToRedeem;\n        uint totalETHDrawn;\n        uint ETHFee;\n        uint ETHToSendToRedeemer;\n        uint decayedBaseRate;\n    }\n\n    struct SingleRedemptionValues {\n        uint LUSDLot;\n        uint ETHLot;\n    }\n\n    // --- Events ---\n\n    event Liquidation(uint _liquidatedDebt, uint _liquidatedColl, uint _collGasCompensation, uint _LUSDGasCompensation);\n    event Redemption(uint _attemptedLUSDAmount, uint _actualLUSDAmount, uint _ETHSent, uint _ETHFee);\n\n    enum TroveManagerOperation {\n        applyPendingRewards,\n        liquidateInNormalMode,\n        liquidateInRecoveryMode,\n        partiallyLiquidateInRecoveryMode,\n        redeemCollateral\n    }\n\n    event TroveCreated(address indexed _borrower, uint _arrayIndex);\n    event TroveUpdated(address indexed _borrower, uint _debt, uint _coll, uint _stake, TroveManagerOperation _operation);\n    event TroveLiquidated(address indexed _borrower, uint _debt, uint _coll, TroveManagerOperation _operation);\n\n    // --- Dependency setter ---\n\n    function setAddresses(\n        address _borrowerOperationsAddress,\n        address _activePoolAddress,\n        address _defaultPoolAddress,\n        address _stabilityPoolAddress,\n        address _collSurplusPoolAddress,\n        address _priceFeedAddress,\n        address _lusdTokenAddress,\n        address _sortedTrovesAddress,\n        address _lqtyStakingAddress\n    )\n        external\n        override\n        onlyOwner\n    {\n        borrowerOperationsAddress = _borrowerOperationsAddress;\n        activePool = IPool(_activePoolAddress);\n        defaultPool = IPool(_defaultPoolAddress);\n        stabilityPool = IStabilityPool(_stabilityPoolAddress);\n        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);\n        priceFeed = IPriceFeed(_priceFeedAddress);\n        lusdToken = ILUSDToken(_lusdTokenAddress);\n        sortedTroves = ISortedTroves(_sortedTrovesAddress);\n        lqtyStakingAddress = _lqtyStakingAddress;\n        lqtyStaking = ILQTYStaking(_lqtyStakingAddress);\n\n        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);\n        emit ActivePoolAddressChanged(_activePoolAddress);\n        emit DefaultPoolAddressChanged(_defaultPoolAddress);\n        emit StabilityPoolAddressChanged(_stabilityPoolAddress);\n        emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);\n        emit PriceFeedAddressChanged(_priceFeedAddress);\n        emit LUSDTokenAddressChanged(_lusdTokenAddress);\n        emit SortedTrovesAddressChanged(_sortedTrovesAddress);\n        emit LQTYStakingAddressChanged(_lqtyStakingAddress);\n\n        _renounceOwnership();\n    }\n\n    // --- Getters ---\n\n    function getTroveOwnersCount() external view override returns (uint) {\n        return TroveOwners.length;\n    }\n\n    function getTroveFromTroveOwnersArray(uint _index) external view override returns (address) {\n        return TroveOwners[_index];\n    }\n\n    // --- Trove Liquidation functions ---\n\n    // Single liquidation function. Closes the trove if its ICR is lower than the minimum collateral ratio. \n    function liquidate(address _borrower) external override {\n        _requireTroveisActive(_borrower);\n\n        address[] memory borrowers = new address[](1);\n        borrowers[0] = _borrower;\n        batchLiquidateTroves(borrowers);\n    }\n\n    // --- Inner single liquidation functions ---\n\n    // Liquidate one trove, in Normal Mode.\n    function _liquidateNormalMode(address _borrower, uint _LUSDInStabPool) internal returns (LiquidationValues memory V) {\n        LocalVariables_InnerSingleLiquidateFunction memory L;\n\n        (V.entireTroveDebt,\n        V.entireTroveColl,\n        L.pendingDebtReward,\n        L.pendingCollReward) = getEntireDebtAndColl(_borrower);\n\n        _movePendingTroveRewardsToActivePool(L.pendingDebtReward, L.pendingCollReward);\n        _removeStake(_borrower);\n\n        V.collGasCompensation = _getCollGasCompensation(V.entireTroveColl);\n        V.LUSDGasCompensation = LUSD_GAS_COMPENSATION;\n        uint collToLiquidate = V.entireTroveColl.sub(V.collGasCompensation);\n\n        (V.debtToOffset,\n        V.collToSendToSP,\n        V.debtToRedistribute,\n        V.collToRedistribute) = _getOffsetAndRedistributionVals(V.entireTroveDebt, collToLiquidate, _LUSDInStabPool);\n\n        _closeTrove(_borrower);\n        emit TroveLiquidated(_borrower, V.entireTroveDebt, V.entireTroveColl, TroveManagerOperation.liquidateInNormalMode);\n\n        return V;\n    }\n\n    // Liquidate one trove, in Recovery Mode.\n    function _liquidateRecoveryMode(address _borrower, uint _ICR, uint _LUSDInStabPool, uint _TCR) internal returns (LiquidationValues memory V) {\n        LocalVariables_InnerSingleLiquidateFunction memory L;\n        \n        if (TroveOwners.length <= 1) { return V; } // don't liquidate if last trove\n\n        (V.entireTroveDebt,\n        V.entireTroveColl,\n        L.pendingDebtReward,\n        L.pendingCollReward) = getEntireDebtAndColl(_borrower);\n\n        _movePendingTroveRewardsToActivePool(L.pendingDebtReward, L.pendingCollReward);\n\n        V.collGasCompensation = _getCollGasCompensation(V.entireTroveColl);\n        // In case of a partial liquidation, V.LUSDGasCompensation will be overwritten to zero, in the third branch below\n        V.LUSDGasCompensation = LUSD_GAS_COMPENSATION;\n        L.collToLiquidate = V.entireTroveColl.sub(V.collGasCompensation);\n\n        // If ICR <= 100%, purely redistribute the Trove across all active Troves\n        if (_ICR <= _100pct) {\n            _removeStake(_borrower);\n\n            V.debtToOffset = 0;\n            V.collToSendToSP = 0;\n            V.debtToRedistribute = V.entireTroveDebt;\n            V.collToRedistribute = L.collToLiquidate;\n\n            _closeTrove(_borrower);\n            emit TroveLiquidated(_borrower, V.entireTroveDebt, V.entireTroveColl, TroveManagerOperation.liquidateInRecoveryMode);\n\n        // If 100% < ICR < MCR, offset as much as possible, and redistribute the remainder\n        } else if ((_ICR > _100pct) && (_ICR < MCR)) {\n            _removeStake(_borrower);\n\n            (V.debtToOffset,\n            V.collToSendToSP,\n            V.debtToRedistribute,\n            V.collToRedistribute) = _getOffsetAndRedistributionVals(V.entireTroveDebt, L.collToLiquidate, _LUSDInStabPool);\n\n            _closeTrove(_borrower);\n            emit TroveLiquidated(_borrower, V.entireTroveDebt, V.entireTroveColl, TroveManagerOperation.liquidateInRecoveryMode);\n\n        /* \n        * If 110% <= ICR < current TCR (accounting for the preceding liquidations in the current sequence)\n        * and there is LUSD in the Stability Pool, only offset it as much as possible, with no redistribution.\n        */\n        } else if ((_ICR >= MCR) && (_ICR < _TCR)) {\n            assert(_LUSDInStabPool != 0);\n\n            _removeStake(_borrower);\n            \n            V = _getFullOrPartialOffsetVals(_borrower, V.entireTroveDebt, V.entireTroveColl, _LUSDInStabPool);\n\n            _closeTrove(_borrower);\n        }\n        else if (_ICR >= _TCR) {\n            LiquidationValues memory zeroVals;\n            return zeroVals;\n        }\n\n        return V;\n    }\n\n    /* In a full liquidation, returns the values for a trove's coll and debt to be offset, and coll and debt to be \n    * redistributed to active troves. \n    */\n    function _getOffsetAndRedistributionVals\n    (\n        uint _debt,\n        uint _coll,\n        uint _LUSDInStabPool\n    )\n        internal\n        pure\n        returns (uint debtToOffset, uint collToSendToSP, uint debtToRedistribute, uint collToRedistribute)\n    {\n        if (_LUSDInStabPool > 0) {\n        /* \n        * Offset as much debt & collateral as possible against the Stability Pool, and redistribute the remainder\n        * between all active troves.\n        *\n        *  If the trove's debt is larger than the deposited LUSD in the Stability Pool:\n        *\n        *  - Offset an amount of the trove's debt equal to the LUSD in the Stability Pool\n        *  - Send a fraction of the trove's collateral to the Stability Pool, equal to the fraction of its offset debt\n        *\n        */\n            debtToOffset = LiquityMath._min(_debt, _LUSDInStabPool);\n            collToSendToSP = _coll.mul(debtToOffset).div(_debt);\n            debtToRedistribute = _debt.sub(debtToOffset);\n            collToRedistribute = _coll.sub(collToSendToSP);\n        } else {\n            debtToOffset = 0;\n            collToSendToSP = 0;\n            debtToRedistribute = _debt;\n            collToRedistribute = _coll;\n        }\n    }\n\n    /*\n    *  If it is a full offset, get its offset coll/debt and ETH gas comp, and close the trove.\n    *\n    * If it is a partial liquidation, get its offset coll/debt and ETH gas comp, and its new coll/debt, and its re-insertion hints.\n    */\n    function _getFullOrPartialOffsetVals\n    (\n        address _borrower,\n        uint _entireTroveDebt,\n        uint _entireTroveColl,\n        uint _LUSDInStabPool\n    )\n        internal\n        returns (LiquidationValues memory V)\n    {\n        V.entireTroveDebt = _entireTroveDebt;\n        V.entireTroveColl = _entireTroveColl;\n\n        // When Stability Pool can fully absorb the trove's debt, perform a full offset\n        if (_entireTroveDebt <= _LUSDInStabPool) {\n            V.collGasCompensation = _getCollGasCompensation(_entireTroveColl);\n            V.LUSDGasCompensation = LUSD_GAS_COMPENSATION;\n\n            V.debtToOffset = _entireTroveDebt;\n            V.collToSendToSP = _entireTroveColl.sub(V.collGasCompensation);\n            V.debtToRedistribute = 0;\n            V.collToRedistribute = 0;\n\n            emit TroveLiquidated(_borrower, _entireTroveDebt, _entireTroveColl, TroveManagerOperation.liquidateInRecoveryMode);\n        }\n        /* \n        * When trove's debt is greater than the Stability Pool, perform a partial liquidation: offset as much as possible,\n        * and do not redistribute the remainder. The trove remains active, with a reduced collateral and debt.\n        *\n        * ETH gas compensation is based on and drawn from the collateral fraction that corresponds to the partial offset. \n        * LUSD gas compensation is left untouched. \n        *\n        * Since ETH gas comp is drawn purely from the *liquidated* portion, the trove is left with the same ICR as before the \n        * liquidation.\n        */\n        else if (_entireTroveDebt > _LUSDInStabPool) {\n            // Remaining debt in the trove is lower-bounded by the trove's gas compensation\n            V.partialNewDebt = LiquityMath._max(_entireTroveDebt.sub(_LUSDInStabPool), LUSD_GAS_COMPENSATION);\n          \n            V.debtToOffset = _entireTroveDebt.sub(V.partialNewDebt);\n\n            uint collFraction = _entireTroveColl.mul(V.debtToOffset).div(_entireTroveDebt);\n            V.collGasCompensation = _getCollGasCompensation(collFraction);\n          \n            V.LUSDGasCompensation = 0;  // LUSD gas compensation remains untouched\n\n            V.collToSendToSP = collFraction.sub(V.collGasCompensation);\n            V.collToRedistribute = 0;\n            V.debtToRedistribute = 0;\n\n            V.partialAddr = _borrower;\n            V.partialNewColl = _entireTroveColl.sub(collFraction);\n\n            // Get the partial trove's neighbours, so we can re-insert it later to the same position\n            V.partialUpperHint = sortedTroves.getPrev(_borrower);  \n            V.partialLowerHint = sortedTroves.getNext(_borrower);\n        }\n    }\n\n    /* \n    * Liquidate a sequence of troves. Closes a maximum number of n under-collateralized Troves,\n    * starting from the one with the lowest collateral ratio in the system, and moving upwards\n    */\n    function liquidateTroves(uint _n) external override {\n        LocalVariables_OuterLiquidationFunction memory L;\n\n        LiquidationTotals memory T;\n\n        L.price = priceFeed.getPrice();\n        L.LUSDInStabPool = stabilityPool.getTotalLUSDDeposits();\n        L.recoveryModeAtStart = checkRecoveryMode();\n\n        // Perform the appropriate liquidation sequence - tally the values, and obtain their totals\n        if (L.recoveryModeAtStart == true) {\n            T = _getTotalsFromLiquidateTrovesSequence_RecoveryMode(L.price, L.LUSDInStabPool, _n);\n        } else if (L.recoveryModeAtStart == false) {\n            T = _getTotalsFromLiquidateTrovesSequence_NormalMode(L.price, L.LUSDInStabPool, _n);\n        }\n\n        // Move liquidated ETH and LUSD to the appropriate pools\n        stabilityPool.offset(T.totalDebtToOffset, T.totalCollToSendToSP);\n        _redistributeDebtAndColl(T.totalDebtToRedistribute, T.totalCollToRedistribute);\n\n        // Update system snapshots and the final partially liquidated trove, if there is one\n        _updateSystemSnapshots_excludeCollRemainder(T.partialNewColl.add(T.totalCollGasCompensation));\n        _updatePartiallyLiquidatedTrove(T.partialAddr, T.partialNewDebt, T.partialNewColl, T.partialUpperHint, T. partialLowerHint, L.price);\n\n        L.liquidatedDebt = T.totalDebtInSequence.sub(T.partialNewDebt);\n        L.liquidatedColl = T.totalCollInSequence.sub(T.totalCollGasCompensation).sub(T.partialNewColl);\n        emit Liquidation(L.liquidatedDebt, L.liquidatedColl, T.totalCollGasCompensation, T.totalLUSDGasCompensation);\n\n        // Send gas compensation to caller\n        _sendGasCompensation(msg.sender, T.totalLUSDGasCompensation, T.totalCollGasCompensation);\n    }\n\n    /*\n    * This function is used when the liquidateTroves sequence starts during Recovery Mode. However, it\n    * handle the case where the system *leaves* Recovery Mode, part way through the liquidation sequence\n    */\n    function _getTotalsFromLiquidateTrovesSequence_RecoveryMode\n    (\n        uint _price,\n        uint _LUSDInStabPool,\n        uint _n\n    )\n        internal\n        returns(LiquidationTotals memory T)\n    {\n        LocalVariables_LiquidationSequence memory L;\n        LiquidationValues memory V;\n\n        L.remainingLUSDInStabPool = _LUSDInStabPool;\n        L.backToNormalMode = false;\n        L.entireSystemDebt = activePool.getLUSDDebt().add(defaultPool.getLUSDDebt());\n        L.entireSystemColl = activePool.getETH().add(defaultPool.getETH());\n\n        L.i = 0;\n        while (L.i < _n) {\n            L.user = sortedTroves.getLast();\n            L.ICR = getCurrentICR(L.user, _price);\n\n            if (L.backToNormalMode == false) {\n                // Break the loop if ICR is greater than MCR and Stability Pool is empty\n                if (L.ICR >= MCR && L.remainingLUSDInStabPool == 0) { break; }\n\n                uint TCR = LiquityMath._computeCR(L.entireSystemColl, L.entireSystemDebt, _price);\n        \n                V = _liquidateRecoveryMode(L.user, L.ICR, L.remainingLUSDInStabPool, TCR);\n\n                // Update aggregate trackers\n                L.remainingLUSDInStabPool = L.remainingLUSDInStabPool.sub(V.debtToOffset);\n                L.entireSystemDebt = L.entireSystemDebt.sub(V.debtToOffset);\n                L.entireSystemColl = L.entireSystemColl.sub(V.collToSendToSP);\n\n                // Add liquidation values to their respective running totals\n                T = _addLiquidationValuesToTotals(T, V);\n\n                // Break the loop if it was a partial liquidation\n                if (V.partialAddr != address(0)) {break;}\n\n                L.backToNormalMode = !_checkPotentialRecoveryMode(L.entireSystemColl, L.entireSystemDebt, _price);\n            }\n            else if (L.backToNormalMode == true && L.ICR < MCR) {\n                V = _liquidateNormalMode(L.user, L.remainingLUSDInStabPool);\n\n                L.remainingLUSDInStabPool = L.remainingLUSDInStabPool.sub(V.debtToOffset);\n\n                // Add liquidation values to their respective running totals\n                T = _addLiquidationValuesToTotals(T, V);\n\n            }  else break;  // break if the loop reaches a Trove with ICR >= MCR\n\n            // Break the loop if it reaches the first Trove in the sorted list\n            if (L.user == sortedTroves.getFirst()) { break; }\n\n            L.i++;\n        }\n    }\n\n    function _getTotalsFromLiquidateTrovesSequence_NormalMode\n    (\n        uint _price,\n        uint _LUSDInStabPool,\n        uint _n\n    )\n        internal\n        returns(LiquidationTotals memory T)\n    {\n        LocalVariables_LiquidationSequence memory L;\n        LiquidationValues memory V;\n\n        L.remainingLUSDInStabPool = _LUSDInStabPool;\n\n        L.i = 0;\n        while (L.i < _n) {\n            L.user = sortedTroves.getLast();\n            L.ICR = getCurrentICR(L.user, _price);\n\n            if (L.ICR < MCR) {\n                V = _liquidateNormalMode(L.user, L.remainingLUSDInStabPool);\n\n                L.remainingLUSDInStabPool = L.remainingLUSDInStabPool.sub(V.debtToOffset);\n\n                // Add liquidation values to their respective running totals\n                T = _addLiquidationValuesToTotals(T, V);\n\n            } else break;  // break if the loop reaches a Trove with ICR >= MCR\n\n            // Break the loop if it reaches the first Trove in the sorted list\n            if (L.user == sortedTroves.getFirst()) { break; }\n            L.i++;\n        }\n    }\n\n    /* \n    * Attempt to liquidate a custom list of troves provided by the caller. The liquidation sequence stops if\n    * a partial liquidation is performed, so it's up to the caller to order the troves in the _troveArray parameter.\n    */\n    function batchLiquidateTroves(address[] memory _troveArray) public override {\n        require(_troveArray.length != 0, \"TroveManager: Calldata address array must not be empty\");\n\n        LocalVariables_OuterLiquidationFunction memory L;\n        LiquidationTotals memory T;\n\n        L.price = priceFeed.getPrice();\n        L.LUSDInStabPool = stabilityPool.getTotalLUSDDeposits();\n        L.recoveryModeAtStart = checkRecoveryMode();\n\n        // Perform the appropriate liquidation sequence - tally values and obtain their totals.\n        if (L.recoveryModeAtStart == true) {\n           T = _getTotalFromBatchLiquidate_RecoveryMode(L.price, L.LUSDInStabPool, _troveArray);\n        } else if (L.recoveryModeAtStart == false) {\n            T = _getTotalsFromBatchLiquidate_NormalMode(L.price, L.LUSDInStabPool, _troveArray);\n        }\n\n        // Move liquidated ETH and LUSD to the appropriate pools\n        stabilityPool.offset(T.totalDebtToOffset, T.totalCollToSendToSP);\n        _redistributeDebtAndColl(T.totalDebtToRedistribute, T.totalCollToRedistribute);\n\n        // Update system snapshots and the final partially liquidated trove, if there is one\n        _updateSystemSnapshots_excludeCollRemainder(T.partialNewColl.add(T.totalCollGasCompensation));\n        _updatePartiallyLiquidatedTrove(T.partialAddr, T.partialNewDebt, T.partialNewColl, T.partialUpperHint, T. partialLowerHint, L.price);\n\n        L.liquidatedDebt = T.totalDebtInSequence.sub(T.partialNewDebt);\n        L.liquidatedColl = T.totalCollInSequence.sub(T.totalCollGasCompensation).sub(T.partialNewColl);\n        emit Liquidation(L.liquidatedDebt, L.liquidatedColl, T.totalCollGasCompensation, T.totalLUSDGasCompensation);\n\n        // Send gas compensation to caller\n        _sendGasCompensation(msg.sender, T.totalLUSDGasCompensation, T.totalCollGasCompensation);\n    }\n\n    /* \n    * This function is used when the batch liquidation sequence starts during Recovery Mode. However, it\n    * handle the case where the system *leaves* Recovery Mode, part way through the liquidation sequence\n    */\n    function _getTotalFromBatchLiquidate_RecoveryMode\n    (\n        uint _price,\n        uint _LUSDInStabPool,\n        address[] memory _troveArray)\n        internal\n        returns(LiquidationTotals memory T)\n    {\n        LocalVariables_LiquidationSequence memory L;\n        LiquidationValues memory V;\n\n        L.remainingLUSDInStabPool = _LUSDInStabPool;\n        L.backToNormalMode = false;\n        L.entireSystemDebt = activePool.getLUSDDebt().add(defaultPool.getLUSDDebt());\n        L.entireSystemColl = activePool.getETH().add(defaultPool.getETH());\n\n        L.i = 0;\n        for (L.i = 0; L.i < _troveArray.length; L.i++) {\n            L.user = _troveArray[L.i];\n            L.ICR = getCurrentICR(L.user, _price);\n\n            if (L.backToNormalMode == false) {\n\n                // Skip this trove if ICR is greater than MCR and Stability Pool is empty\n                if (L.ICR >= MCR && L.remainingLUSDInStabPool == 0) { continue; }\n\n                uint TCR = LiquityMath._computeCR(L.entireSystemColl, L.entireSystemDebt, _price);\n\n                V = _liquidateRecoveryMode(L.user, L.ICR, L.remainingLUSDInStabPool, TCR);\n\n                // Update aggregate trackers\n                L.remainingLUSDInStabPool = L.remainingLUSDInStabPool.sub(V.debtToOffset);\n                L.entireSystemDebt = L.entireSystemDebt.sub(V.debtToOffset);\n                L.entireSystemColl = L.entireSystemColl.sub(V.collToSendToSP);\n\n                // Add liquidation values to their respective running totals\n                T = _addLiquidationValuesToTotals(T, V);\n\n                // Break the loop if it was a partial liquidation\n                if (V.partialAddr != address(0)) { break; }\n\n                L.backToNormalMode = !_checkPotentialRecoveryMode(L.entireSystemColl, L.entireSystemDebt, _price);\n            }\n\n            else if (L.backToNormalMode == true && L.ICR < MCR) {\n                V = _liquidateNormalMode(L.user, L.remainingLUSDInStabPool);\n                L.remainingLUSDInStabPool = L.remainingLUSDInStabPool.sub(V.debtToOffset);\n\n                // Add liquidation values to their respective running totals\n                T = _addLiquidationValuesToTotals(T, V);\n            }\n        }\n    }\n\n    function _getTotalsFromBatchLiquidate_NormalMode\n    (\n        uint _price,\n        uint _LUSDInStabPool,\n        address[] memory _troveArray\n    )\n        internal\n        returns(LiquidationTotals memory T)\n    {\n        LocalVariables_LiquidationSequence memory L;\n        LiquidationValues memory V;\n\n        L.remainingLUSDInStabPool = _LUSDInStabPool;\n\n        for (L.i = 0; L.i < _troveArray.length; L.i++) {\n            L.user = _troveArray[L.i];\n            L.ICR = getCurrentICR(L.user, _price);\n\n            if (L.ICR < MCR) {\n                V = _liquidateNormalMode(L.user, L.remainingLUSDInStabPool);\n                L.remainingLUSDInStabPool = L.remainingLUSDInStabPool.sub(V.debtToOffset);\n\n                // Add liquidation values to their respective running totals\n                T = _addLiquidationValuesToTotals(T, V);\n            }\n        }\n    }\n\n    // --- Liquidation helper functions ---\n\n    function _addLiquidationValuesToTotals(LiquidationTotals memory T1, LiquidationValues memory V)\n    internal pure returns(LiquidationTotals memory T2) {\n\n        // Tally all the values with their respective running totals\n        T2.totalCollGasCompensation = T1.totalCollGasCompensation.add(V.collGasCompensation);\n        T2.totalLUSDGasCompensation = T1.totalLUSDGasCompensation.add(V.LUSDGasCompensation);\n        T2.totalDebtInSequence = T1.totalDebtInSequence.add(V.entireTroveDebt);\n        T2.totalCollInSequence = T1.totalCollInSequence.add(V.entireTroveColl);\n        T2.totalDebtToOffset = T1.totalDebtToOffset.add(V.debtToOffset);\n        T2.totalCollToSendToSP = T1.totalCollToSendToSP.add(V.collToSendToSP);\n        T2.totalDebtToRedistribute = T1.totalDebtToRedistribute.add(V.debtToRedistribute);\n        T2.totalCollToRedistribute = T1.totalCollToRedistribute.add(V.collToRedistribute);\n\n        // Assign the address of the partially liquidated trove, and its new debt and coll values\n        T2.partialAddr = V.partialAddr;\n        T2.partialNewDebt = V.partialNewDebt;\n        T2.partialNewColl = V.partialNewColl;\n        T2.partialUpperHint = V.partialUpperHint;\n        T2.partialLowerHint = V.partialLowerHint;\n\n        return T2;\n    }\n\n    // Update the properties of the partially liquidated trove, and insert it back to the list\n    function _updatePartiallyLiquidatedTrove\n    (\n        address _borrower, \n        uint _newDebt, \n        uint _newColl, \n        address _upperHint,\n        address _lowerHint,\n        uint _price\n    ) \n        internal \n    {\n        if ( _borrower == address(0)) { return; }\n\n        Troves[_borrower].debt = _newDebt;\n        Troves[_borrower].coll = _newColl;\n        Troves[_borrower].status = Status.active;\n\n        _updateTroveRewardSnapshots(_borrower);\n        _updateStakeAndTotalStakes(_borrower);\n\n        uint ICR = getCurrentICR(_borrower, _price);\n\n        /* \n        * Insert to sorted list and add to TroveOwners array. The partially liquidated trove has the same\n        * ICR as it did before the liquidation, so insertion is O(1): in principle, its ICR does not change.\n        * In practice, due to rounding error, its ICR can change slightly - so re-insert, with its previous neighbours\n        * as hints.\n        */\n        sortedTroves.insert(_borrower, ICR, _price, _upperHint, _lowerHint);\n        _addTroveOwnerToArray(_borrower);\n        emit TroveUpdated(_borrower, _newDebt, _newColl, Troves[_borrower].stake, TroveManagerOperation.partiallyLiquidateInRecoveryMode);\n    }\n\n    function _sendGasCompensation(address _liquidator, uint _LUSD, uint _ETH) internal {\n        if (_LUSD > 0) {\n            lusdToken.returnFromPool(GAS_POOL_ADDRESS, _liquidator, _LUSD);\n        }\n\n        if (_ETH > 0) {\n            activePool.sendETH(_liquidator, _ETH);\n        }\n    }\n\n    // Move a Trove's pending debt and collateral rewards from distributions, from the Default Pool to the Active Pool\n    function _movePendingTroveRewardsToActivePool(uint _LUSD, uint _ETH) internal {\n        defaultPool.decreaseLUSDDebt(_LUSD);\n        activePool.increaseLUSDDebt(_LUSD);\n        defaultPool.sendETH(address(activePool), _ETH);\n    }\n\n    // --- Redemption functions ---\n\n    // Redeem as much collateral as possible from _borrower's Trove in exchange for LUSD up to _maxLUSDamount\n    function _redeemCollateralFromTrove(\n        address _borrower,\n        uint _maxLUSDamount,\n        uint _price,\n        address _partialRedemptionHint,\n        uint _partialRedemptionHintICR\n    )\n        internal returns (SingleRedemptionValues memory V)\n    {\n        // Determine the remaining amount (lot) to be redeemed, capped by the entire debt of the Trove minus the gas compensation\n        V.LUSDLot = LiquityMath._min(_maxLUSDamount, Troves[_borrower].debt.sub(LUSD_GAS_COMPENSATION));\n\n        // Get the ETHLot of equivalent value in USD\n        V.ETHLot = V.LUSDLot.mul(1e18).div(_price);\n\n        // Decrease the debt and collateral of the current Trove according to the LUSD lot and corresponding ETH to send\n        uint newDebt = (Troves[_borrower].debt).sub(V.LUSDLot);\n        uint newColl = (Troves[_borrower].coll).sub(V.ETHLot);\n\n        if (newDebt == LUSD_GAS_COMPENSATION) {\n            // No debt left in the Trove (except for the gas compensation), therefore the trove gets closed\n            _removeStake(_borrower);\n            _closeTrove(_borrower);\n            _redeemCloseTrove(_borrower, LUSD_GAS_COMPENSATION, newColl);\n\n        } else {\n            uint newICR = LiquityMath._computeCR(newColl, newDebt, _price);\n\n            // Check if the provided hint is fresh. If not, we bail since trying to reinsert without a good hint will almost\n            // certainly result in running out of gas.\n            if (newICR != _partialRedemptionHintICR) {\n                V.LUSDLot = 0;\n                V.ETHLot = 0;\n                return V;\n            }\n\n            sortedTroves.reInsert(_borrower, newICR, _price, _partialRedemptionHint, _partialRedemptionHint);\n\n            Troves[_borrower].debt = newDebt;\n            Troves[_borrower].coll = newColl;\n            _updateStakeAndTotalStakes(_borrower);\n        }\n        emit TroveUpdated(\n            _borrower,\n            newDebt, newColl,\n            Troves[_borrower].stake,\n            TroveManagerOperation.redeemCollateral\n        );\n        return V;\n    }\n\n    /* \n    * Called when a full redemption occurs, and closes the trove.\n    * The redeemer swaps (debt - 10) LUSD for (debt - 10) worth of ETH, so the 10 LUSD gas compensation left corresponds to the remaining debt.\n    * In order to close the trove, the 10 LUSD gas compensation is burned, and 10 debt is removed from the active pool.\n    * The debt recorded on the trove's struct is zero'd elswhere, in _closeTrove.\n    * Any surplus ETH left in the trove, is sent to the Coll surplus pool, and can be later claimed by the borrower.\n    */ \n    function _redeemCloseTrove(address _borrower, uint _LUSD, uint _ETH) internal {\n        lusdToken.burn(GAS_POOL_ADDRESS, _LUSD);\n        // Update Active Pool LUSD, and send ETH to account\n        activePool.decreaseLUSDDebt(_LUSD);\n\n        // send ETH from Active Pool to CollSurplus Pool\n        collSurplusPool.accountSurplus(_borrower, _ETH);\n        activePool.sendETH(address(collSurplusPool), _ETH);\n    }\n\n    function _isValidFirstRedemptionHint(address _firstRedemptionHint, uint _price) internal view returns (bool) {\n        if (_firstRedemptionHint == address(0) ||\n            !sortedTroves.contains(_firstRedemptionHint) ||\n            getCurrentICR(_firstRedemptionHint, _price) < MCR\n        ) {\n            return false;\n        }\n\n        address nextTrove = sortedTroves.getNext(_firstRedemptionHint);\n        return nextTrove == address(0) || getCurrentICR(nextTrove, _price) < MCR;\n    }\n\n    /* Send _LUSDamount LUSD to the system and redeem the corresponding amount of collateral from as many Troves as are needed to fill the redemption\n    * request.  Applies pending rewards to a Trove before reducing its debt and coll.\n    *\n    * Note that if _amount is very large, this function can run out of gas, specially if traversed troves are small. This can be easily avoided by \n    * splitting the total _amount in appropriate chunks and calling the function multiple times.\n    * \n    * Param `_maxIterations` can also be provided, so the loop through Troves is capped (if its zero, it will be ignored).This makes it easier to \n    * avoid OOG for the frontend, as only knowing approximately the average cost of an iteration is enough, without needing to know the topology \n    * of the trove list. It also avoids the need to set the cap in stone in the contract, nor doing gas calculations, as both gas price and opcode \n    * costs can vary.\n    * \n    * All Troves that are redeemed from -- with the likely exception of the last one -- will end up with no debt left, therefore they will be closed.\n    * If the last Trove does have some remaining debt, it has a finite ICR, and the reinsertion could be anywhere in the list, therefore it requires a hint. \n    * A frontend should use getRedemptionHints() to calculate what the ICR of this Trove will be after redemption, and pass a hint for its position \n    * in the sortedTroves list along with the ICR value that the hint was found for.\n    * \n    * If another transaction modifies the list between calling getRedemptionHints() and passing the hints to redeemCollateral(), it\n    * is very likely that the last (partially) redeemed Trove would end up with a different ICR than what the hint is for. In this case the\n    * redemption will stop after the last completely redeemed Trove and the sender will keep the remaining LUSD amount, which they can attempt\n    * to redeem later.\n    */\n    function redeemCollateral(\n        uint _LUSDamount,\n        address _firstRedemptionHint,\n        address _partialRedemptionHint,\n        uint _partialRedemptionHintICR,\n        uint _maxIterations\n    )\n        external\n        override\n    {\n        uint activeDebt = activePool.getLUSDDebt();\n        uint defaultedDebt = defaultPool.getLUSDDebt();\n\n        RedemptionTotals memory T;\n\n        _requireAmountGreaterThanZero(_LUSDamount);\n        _requireLUSDBalanceCoversRedemption(msg.sender, _LUSDamount);\n\n        // Confirm redeemer's balance is less than total systemic debt\n        assert(lusdToken.balanceOf(msg.sender) <= (activeDebt.add(defaultedDebt)));\n\n        uint remainingLUSD = _LUSDamount;\n        uint price = priceFeed.getPrice();\n        address currentBorrower;\n\n        if (_isValidFirstRedemptionHint(_firstRedemptionHint, price)) {\n            currentBorrower = _firstRedemptionHint;\n        } else {\n            currentBorrower = sortedTroves.getLast();\n            // Find the first trove with ICR >= MCR\n            // SWC-104-Unchecked Call Return Value: L920\n            while (currentBorrower != address(0) && getCurrentICR(currentBorrower, price) < MCR) {\n                currentBorrower = sortedTroves.getPrev(currentBorrower);\n            }\n        }\n\n        // Loop through the Troves starting from the one with lowest collateral ratio until _amount of LUSD is exchanged for collateral\n        if (_maxIterations == 0) { _maxIterations = uint(-1); }\n        while (currentBorrower != address(0) && remainingLUSD > 0 && _maxIterations > 0) {\n            _maxIterations--;\n            // Save the address of the Trove preceding the current one, before potentially modifying the list\n            address nextUserToCheck = sortedTroves.getPrev(currentBorrower);\n\n            _applyPendingRewards(currentBorrower);\n            SingleRedemptionValues memory V = _redeemCollateralFromTrove(\n                currentBorrower,\n                remainingLUSD,\n                price,\n                _partialRedemptionHint,\n                _partialRedemptionHintICR\n            );\n\n            if (V.LUSDLot == 0) break; // Partial redemption hint got out-of-date, therefore we could not redeem from the last Trove\n\n            T.totalLUSDToRedeem  = T.totalLUSDToRedeem.add(V.LUSDLot);\n            T.totalETHDrawn = T.totalETHDrawn.add(V.ETHLot);\n\n            remainingLUSD = remainingLUSD.sub(V.LUSDLot);\n            currentBorrower = nextUserToCheck;\n        }\n\n        // Decay the baseRate due to time passed, and then increase it according to the size of this redemption\n        _updateBaseRateFromRedemption(T.totalETHDrawn, price);\n\n        // Calculate the ETH fee and send it to the LQTY staking contract\n        T.ETHFee = _getRedemptionFee(T.totalETHDrawn);\n        activePool.sendETH(lqtyStakingAddress, T.ETHFee);\n        lqtyStaking.increaseF_ETH(T.ETHFee);\n\n        T.ETHToSendToRedeemer = T.totalETHDrawn.sub(T.ETHFee);\n\n        // Burn the total LUSD that is cancelled with debt, and send the redeemed ETH to msg.sender\n        _activePoolRedeemCollateral(msg.sender, T.totalLUSDToRedeem, T.ETHToSendToRedeemer);\n\n        emit Redemption(_LUSDamount, T.totalLUSDToRedeem, T.totalETHDrawn, T.ETHFee);\n    }\n\n    // Burn the received LUSD, transfer the redeemed ETH to _redeemer and updates the Active Pool\n    function _activePoolRedeemCollateral(address _redeemer, uint _LUSD, uint _ETH) internal {\n        // Update Active Pool LUSD, and send ETH to account\n        lusdToken.burn(_redeemer, _LUSD);\n        activePool.decreaseLUSDDebt(_LUSD);\n\n        activePool.sendETH(_redeemer, _ETH);\n    }\n\n    // --- Helper functions ---\n\n\n    // Return the current collateral ratio (ICR) of a given Trove. Takes a trove's pending coll and debt rewards from redistributions into account.\n    function getCurrentICR(address _borrower, uint _price) public view override returns (uint) {\n        uint pendingETHReward = getPendingETHReward(_borrower);\n        uint pendingLUSDDebtReward = getPendingLUSDDebtReward(_borrower);\n\n        uint currentETH = Troves[_borrower].coll.add(pendingETHReward);\n        uint currentLUSDDebt = Troves[_borrower].debt.add(pendingLUSDDebtReward);\n\n        uint ICR = LiquityMath._computeCR(currentETH, currentLUSDDebt, _price);\n        return ICR;\n    }\n\n    function applyPendingRewards(address _borrower) external override {\n        _requireCallerIsBorrowerOperations();\n        return _applyPendingRewards(_borrower);\n    }\n\n    // Add the borrowers's coll and debt rewards earned from redistributions, to their Trove\n    function _applyPendingRewards(address _borrower) internal {\n        if (hasPendingRewards(_borrower)) {\n            _requireTroveisActive(_borrower);\n\n            // Compute pending rewards\n            uint pendingETHReward = getPendingETHReward(_borrower);\n            uint pendingLUSDDebtReward = getPendingLUSDDebtReward(_borrower);\n\n            // Apply pending rewards to trove's state\n            Troves[_borrower].coll = Troves[_borrower].coll.add(pendingETHReward);\n            Troves[_borrower].debt = Troves[_borrower].debt.add(pendingLUSDDebtReward);\n\n            _updateTroveRewardSnapshots(_borrower);\n\n            // Transfer from DefaultPool to ActivePool\n            _movePendingTroveRewardsToActivePool(pendingLUSDDebtReward, pendingETHReward);\n\n            emit TroveUpdated(\n                _borrower, \n                Troves[_borrower].debt, \n                Troves[_borrower].coll, \n                Troves[_borrower].stake, \n                TroveManagerOperation.applyPendingRewards\n            );\n        }\n    }\n\n    // Update borrower's snapshots of L_ETH and L_LUSDDebt to reflect the current values\n    function updateTroveRewardSnapshots(address _borrower) external override {\n        _requireCallerIsBorrowerOperations();\n       return _updateTroveRewardSnapshots(_borrower);\n    }\n\n    function _updateTroveRewardSnapshots(address _borrower) internal {\n        rewardSnapshots[_borrower].ETH = L_ETH;\n        rewardSnapshots[_borrower].LUSDDebt = L_LUSDDebt;\n    }\n\n    // Get the borrower's pending accumulated ETH reward, earned by their stake\n    function getPendingETHReward(address _borrower) public view override returns (uint) {\n        uint snapshotETH = rewardSnapshots[_borrower].ETH;\n        uint rewardPerUnitStaked = L_ETH.sub(snapshotETH);\n\n        if ( rewardPerUnitStaked == 0 ) { return 0; }\n\n        uint stake = Troves[_borrower].stake;\n\n        uint pendingETHReward = stake.mul(rewardPerUnitStaked).div(1e18);\n\n        return pendingETHReward;\n    }\n\n     // Get the borrower's pending accumulated LUSD reward, earned by their stake\n    function getPendingLUSDDebtReward(address _borrower) public view override returns (uint) {\n        uint snapshotLUSDDebt = rewardSnapshots[_borrower].LUSDDebt;\n        uint rewardPerUnitStaked = L_LUSDDebt.sub(snapshotLUSDDebt);\n\n        if ( rewardPerUnitStaked == 0 ) { return 0; }\n\n        uint stake =  Troves[_borrower].stake;\n\n        uint pendingLUSDDebtReward = stake.mul(rewardPerUnitStaked).div(1e18);\n\n        return pendingLUSDDebtReward;\n    }\n\n    function hasPendingRewards(address _borrower) public view override returns (bool) {\n        /* \n        * A Trove has pending rewards if its snapshot is less than the current rewards per-unit-staked sum:\n        * this indicates that rewards have occured since the snapshot was made, and the user therefore has\n        * pending rewards \n        */\n        return (rewardSnapshots[_borrower].ETH < L_ETH);\n    }\n\n    // Return the Troves entire debt and coll, including pending rewards from redistributions.\n    function getEntireDebtAndColl(\n        address _borrower\n    )\n        public\n        view\n        override\n        returns (uint debt, uint coll, uint pendingLUSDDebtReward, uint pendingETHReward)\n    {\n        debt = Troves[_borrower].debt;\n        coll = Troves[_borrower].coll;\n\n        pendingLUSDDebtReward = getPendingLUSDDebtReward(_borrower);\n        pendingETHReward = getPendingETHReward(_borrower);\n\n        debt = debt.add(pendingLUSDDebtReward);\n        coll = coll.add(pendingETHReward);\n    }\n\n    function removeStake(address _borrower) external override {\n        _requireCallerIsBorrowerOperations();\n        return _removeStake(_borrower);\n    }\n\n    // Remove borrower's stake from the totalStakes sum, and set their stake to 0\n    function _removeStake(address _borrower) internal {\n        uint stake = Troves[_borrower].stake;\n        totalStakes = totalStakes.sub(stake);\n        Troves[_borrower].stake = 0;\n    }\n\n    function updateStakeAndTotalStakes(address _borrower) external override returns (uint) {\n        _requireCallerIsBorrowerOperations();\n        return _updateStakeAndTotalStakes(_borrower);\n    }\n\n    // Update borrower's stake based on their latest collateral value\n    function _updateStakeAndTotalStakes(address _borrower) internal returns (uint) {\n        uint newStake = _computeNewStake(Troves[_borrower].coll);\n        uint oldStake = Troves[_borrower].stake;\n        Troves[_borrower].stake = newStake;\n        totalStakes = totalStakes.sub(oldStake).add(newStake);\n\n        return newStake;\n    }\n\n    // Calculate a new stake based on the snapshots of the totalStakes and totalCollateral taken at the last liquidation\n    function _computeNewStake(uint _coll) internal view returns (uint) {\n        uint stake;\n        if (totalCollateralSnapshot == 0) {\n            stake = _coll;\n        } else {\n            /*  \n            * The following assert() holds true because:\n            * - The system always contains >= 1 trove \n            * - When we close or liquidate a trove, we redistribute the pending rewards, so if all troves were closed/liquidated, \n            * rewards wouldve been emptied and totalCollateralSnapshot would be zero too.\n            */\n            assert(totalStakesSnapshot > 0);\n            stake = _coll.mul(totalStakesSnapshot).div(totalCollateralSnapshot);\n        }\n        return stake;\n    }\n\n    function _redistributeDebtAndColl(uint _debt, uint _coll) internal {\n        if (_debt == 0) { return; }\n\n        if (totalStakes > 0) {\n            /* \n            * Add distributed coll and debt rewards-per-unit-staked to the running totals.\n            * Division uses a \"feedback\" error correction, to keep the cumulative error in\n            * the  L_ETH and L_LUSDDebt state variables low. \n            */\n            uint ETHNumerator = _coll.mul(1e18).add(lastETHError_Redistribution);\n            uint LUSDDebtNumerator = _debt.mul(1e18).add(lastLUSDDebtError_Redistribution);\n\n            uint ETHRewardPerUnitStaked = ETHNumerator.div(totalStakes);\n            uint LUSDDebtRewardPerUnitStaked = LUSDDebtNumerator.div(totalStakes);\n\n            lastETHError_Redistribution = ETHNumerator.sub(ETHRewardPerUnitStaked.mul(totalStakes));\n            lastLUSDDebtError_Redistribution = LUSDDebtNumerator.sub(LUSDDebtRewardPerUnitStaked.mul(totalStakes));\n\n            L_ETH = L_ETH.add(ETHRewardPerUnitStaked);\n            L_LUSDDebt = L_LUSDDebt.add(LUSDDebtRewardPerUnitStaked);\n        }\n\n        // Transfer coll and debt from ActivePool to DefaultPool\n        activePool.decreaseLUSDDebt(_debt);\n        defaultPool.increaseLUSDDebt(_debt);\n        activePool.sendETH(address(defaultPool), _coll);\n    }\n\n    function closeTrove(address _borrower) external override {\n        _requireCallerIsBorrowerOperations();\n        return _closeTrove(_borrower);\n    }\n\n    function _closeTrove(address _borrower) internal {\n        uint TroveOwnersArrayLength = TroveOwners.length;\n        _requireMoreThanOneTroveInSystem(TroveOwnersArrayLength);\n\n        Troves[_borrower].status = Status.closed;\n        Troves[_borrower].coll = 0;\n        Troves[_borrower].debt = 0;\n\n        rewardSnapshots[_borrower].ETH = 0;\n        rewardSnapshots[_borrower].LUSDDebt = 0;\n\n        _removeTroveOwner(_borrower, TroveOwnersArrayLength);\n        sortedTroves.remove(_borrower);\n    }\n\n    /* \n    * Updates snapshots of system total stakes and total collateral, excluding a given collateral remainder from the calculation. \n    * Used in a liquidation sequence.\n    *\n    * The calculation excludes two portions of collateral that are in the ActivePool: \n    *\n    * 1) the total ETH gas compensation from the liquidation sequence\n    * 2) The remaining collateral in a partially liquidated trove (if one occurred)\n    *\n    * The ETH as compensation must be excluded as it is always sent out at the very end of the liquidation sequence.\n    *\n    * The partially liquidated trove's remaining collateral stays in the ActivePool, but it is excluded here so the system \n    * can take snapshots before the partially liquidated trove's stake is updated (based on these snapshots). This ensures\n    * the partial's new stake doesn't double-count its own remaining collateral.\n    *\n    */\n    function _updateSystemSnapshots_excludeCollRemainder(uint _collRemainder) internal {\n        totalStakesSnapshot = totalStakes;\n\n        uint activeColl = activePool.getETH();\n        uint liquidatedColl = defaultPool.getETH();\n        totalCollateralSnapshot = activeColl.sub(_collRemainder).add(liquidatedColl);\n    }\n\n    // Push the owner's address to the Trove owners list, and record the corresponding array index on the Trove struct\n    function addTroveOwnerToArray(address _borrower) external override returns (uint index) {\n        _requireCallerIsBorrowerOperations();\n        return _addTroveOwnerToArray(_borrower);\n    }\n\n    function _addTroveOwnerToArray(address _borrower) internal returns (uint128 index) {\n        require(TroveOwners.length < 2**128 - 1, \"TroveManager: TroveOwners array has maximum size of 2^128 - 1\");\n\n        // Push the Troveowner to the array\n        TroveOwners.push(_borrower);\n\n        // Record the index of the new Troveowner on their Trove struct\n        index = uint128(TroveOwners.length.sub(1));\n        Troves[_borrower].arrayIndex = index;\n\n        return index;\n    }\n\n    /* \n    * Remove a Trove owner from the TroveOwners array, not preserving array order. Removing owner 'B' does the following:\n    * [A B C D E] => [A E C D], and updates E's Trove struct to point to its new array index. \n    */\n    function _removeTroveOwner(address _borrower, uint TroveOwnersArrayLength) internal {\n        require(Troves[_borrower].status == Status.closed, \"TroveManager: Trove is still active\");\n\n        uint128 index = Troves[_borrower].arrayIndex;\n        uint length = TroveOwnersArrayLength;\n        uint idxLast = length.sub(1);\n\n        assert(index <= idxLast);\n\n        address addressToMove = TroveOwners[idxLast];\n\n        TroveOwners[index] = addressToMove;\n        Troves[addressToMove].arrayIndex = index;\n        TroveOwners.pop();\n    }\n\n    // --- Recovery Mode and TCR functions ---\n\n    function checkRecoveryMode() public view override returns (bool) {\n        uint TCR = getTCR();\n\n        if (TCR < CCR) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    // Check whether or not the system *would be* in Recovery Mode, given an ETH:USD price, and the entire system coll and debt.\n    function _checkPotentialRecoveryMode(\n        uint _entireSystemColl,\n        uint _entireSystemDebt,\n        uint _price\n    )\n        internal\n        pure\n    returns (bool)\n    {\n        uint TCR = LiquityMath._computeCR(_entireSystemColl, _entireSystemDebt, _price);\n        if (TCR < CCR) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n    // SWC-135-Code With No Effects: L1276-L1284\n    function getTCR() public view override returns (uint TCR) {\n        uint price = priceFeed.getPrice();\n        uint entireSystemColl = getEntireSystemColl();\n        uint entireSystemDebt = getEntireSystemDebt();\n\n        TCR = LiquityMath._computeCR(entireSystemColl, entireSystemDebt, price);\n\n        return TCR;\n    }\n    // SWC-135-Code With No Effects: L1286-L1291\n    function getEntireSystemColl() public view override returns (uint entireSystemColl) {\n        uint activeColl = activePool.getETH();\n        uint liquidatedColl = defaultPool.getETH();\n\n        return activeColl.add(liquidatedColl);\n    }\n\n    function getEntireSystemDebt() public view override returns (uint entireSystemDebt) {\n        uint activeDebt = activePool.getLUSDDebt();\n        uint closedDebt = defaultPool.getLUSDDebt();\n\n        return activeDebt.add(closedDebt);\n    }\n\n    // --- Redemption fee functions ---\n\n    /* \n    * This function has two impacts on the baseRate state variable:\n    * 1) decays the baseRate based on time passed since last redemption or LUSD borrowing operation.\n    * then,\n    * 2) increases the baseRate based on the amount redeemed, as a proportion of total supply\n    */\n    function _updateBaseRateFromRedemption(uint _ETHDrawn,  uint _price) internal returns (uint) {\n        uint decayedBaseRate = _calcDecayedBaseRate();\n\n        uint activeDebt = activePool.getLUSDDebt();\n        uint closedDebt = defaultPool.getLUSDDebt();\n        uint totalLUSDSupply = activeDebt.add(closedDebt);\n\n        /* Convert the drawn ETH back to LUSD at face value rate (1 LUSD:1 USD), in order to get\n        * the fraction of total supply that was redeemed at face value. */\n        uint redeemedLUSDFraction = _ETHDrawn.mul(_price).div(totalLUSDSupply);\n\n        uint newBaseRate = decayedBaseRate.add(redeemedLUSDFraction.div(BETA));\n\n        // Update the baseRate state variable\n        baseRate = newBaseRate < 1e18 ? newBaseRate : 1e18;  // cap baseRate at a maximum of 100%\n        assert(baseRate <= 1e18 && baseRate > 0); // Base rate is always non-zero after redemption\n\n        _updateLastFeeOpTime();\n\n        return baseRate;\n    }\n\n    function _getRedemptionFee(uint _ETHDrawn) internal view returns (uint) {\n       return baseRate.mul(_ETHDrawn).div(1e18);\n    }\n\n    // --- Borrowing fee functions ---\n\n    function getBorrowingFee(uint _LUSDDebt) external view override returns (uint) {\n        return _LUSDDebt.mul(baseRate).div(1e18);\n    }\n\n    // Updates the baseRate state variable based on time elapsed since the last redemption or LUSD borrowing operation.\n    function decayBaseRateFromBorrowing() external override {\n        _requireCallerIsBorrowerOperations();\n\n        baseRate = _calcDecayedBaseRate();\n        assert(baseRate <= 1e18);  // The baseRate can decay to 0\n\n        _updateLastFeeOpTime();\n    }\n\n    // --- Internal fee functions ---\n\n    // Update the last fee operation time only if time passed >= decay interval. This prevents base rate griefing.\n    function _updateLastFeeOpTime() internal {\n        uint timePassed = block.timestamp.sub(lastFeeOperationTime);\n\n        if (timePassed >= SECONDS_IN_ONE_MINUTE) {\n            lastFeeOperationTime = block.timestamp;\n        }\n    }\n\n    function _calcDecayedBaseRate() internal view returns (uint) {\n        uint minutesPassed = _minutesPassedSinceLastFeeOp();\n        uint decayFactor = LiquityMath._decPow(MINUTE_DECAY_FACTOR, minutesPassed);\n\n        return baseRate.mul(decayFactor).div(1e18);\n    }\n\n    function _minutesPassedSinceLastFeeOp() internal view returns (uint) {\n        return (block.timestamp.sub(lastFeeOperationTime)).div(SECONDS_IN_ONE_MINUTE);\n    }\n\n    // --- 'require' wrapper functions ---\n\n    function _requireCallerIsBorrowerOperations() internal view {\n        require(msg.sender == borrowerOperationsAddress, \"TroveManager: Caller is not the BorrowerOperations contract\");\n    }\n\n    function _requireTroveisActive(address _borrower) internal view {\n        require(Troves[_borrower].status == Status.active, \"TroveManager: Trove does not exist or is closed\");\n    }\n\n    function _requireLUSDBalanceCoversRedemption(address _redeemer, uint _amount) internal view {\n        require(lusdToken.balanceOf(_redeemer) >= _amount, \"TroveManager: Requested redemption amount must be <= user's LUSD token balance\");\n    }\n\n    function _requireMoreThanOneTroveInSystem(uint TroveOwnersArrayLength) internal view {\n        require (TroveOwnersArrayLength > 1 && sortedTroves.getSize() > 1, \"TroveManager: Only one trove in the system\");\n    }\n\n    function _requireAmountGreaterThanZero(uint _amount) internal pure {\n        require(_amount > 0, \"TroveManager: Amount must be greater than zero\");\n    }\n\n    // --- Trove property getters ---\n\n    function getTroveStatus(address _borrower) external view override returns (uint) {\n        return uint(Troves[_borrower].status);\n    }\n\n    function getTroveStake(address _borrower) external view override returns (uint) {\n        return Troves[_borrower].stake;\n    }\n\n    function getTroveDebt(address _borrower) external view override returns (uint) {\n        return Troves[_borrower].debt;\n    }\n\n    function getTroveColl(address _borrower) external view override returns (uint) {\n        return Troves[_borrower].coll;\n    }\n\n    // --- Trove property setters, called by BorrowerOperations ---\n\n    function setTroveStatus(address _borrower, uint _num) external override {\n        _requireCallerIsBorrowerOperations();\n        Troves[_borrower].status = Status(_num);\n    }\n\n    function increaseTroveColl(address _borrower, uint _collIncrease) external override returns (uint) {\n        _requireCallerIsBorrowerOperations();\n        uint newColl = Troves[_borrower].coll.add(_collIncrease);\n        Troves[_borrower].coll = newColl;\n        return newColl;\n    }\n\n    function decreaseTroveColl(address _borrower, uint _collDecrease) external override returns (uint) {\n        _requireCallerIsBorrowerOperations();\n        uint newColl = Troves[_borrower].coll.sub(_collDecrease);\n        Troves[_borrower].coll = newColl;\n        return newColl;\n    }\n\n    function increaseTroveDebt(address _borrower, uint _debtIncrease) external override returns (uint) {\n        _requireCallerIsBorrowerOperations();\n        uint newDebt = Troves[_borrower].debt.add(_debtIncrease);\n        Troves[_borrower].debt = newDebt;\n        return newDebt;\n    }\n\n    function decreaseTroveDebt(address _borrower, uint _debtDecrease) external override returns (uint) {\n        _requireCallerIsBorrowerOperations();\n        uint newDebt = Troves[_borrower].debt.sub(_debtDecrease);\n        Troves[_borrower].debt = newDebt;\n        return newDebt;\n    }\n}",
        "function": "decayBaseRateFromBorrowing()",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-Liquity/dev-f0df3efa5a5f05b205752184cfce107c5bd6e06c/packages/contracts/contracts/TroveManager.sol",
        "vulnerability": "Dependence on predictable environment variable (SWC 116)",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract TroveManager is LiquityBase, Ownable, ITroveManager {\n\n    // --- Connected contract declarations ---\n\n    address public borrowerOperationsAddress;\n\n    IPool public activePool;\n\n    IPool public defaultPool;\n\n    IStabilityPool public stabilityPool;\n\n    ICollSurplusPool collSurplusPool;\n\n    ILUSDToken public lusdToken;\n\n    IPriceFeed public priceFeed;\n\n    ILQTYStaking public lqtyStaking;\n    address public lqtyStakingAddress;\n\n    // A doubly linked list of Troves, sorted by their sorted by their collateral ratios\n    ISortedTroves public sortedTroves;\n\n    // --- Data structures ---\n\n    uint constant public SECONDS_IN_ONE_MINUTE = 60;\n    uint constant public MINUTE_DECAY_FACTOR = 999832508430720967;  // 18 digit decimal. Corresponds to an hourly decay factor of 0.99\n\n    /* \n    * BETA: 18 digit decimal. Parameter by which to divide the redeemed fraction, in order to calc the new base rate from a redemption. \n    * Corresponds to (1 / ALPHA) in the white paper. \n    */\n    uint constant public BETA = 2;\n\n    uint public baseRate;\n\n    // The timestamp of the latest fee operation (redemption or new LUSD issuance) \n    uint public lastFeeOperationTime;\n\n    enum Status { nonExistent, active, closed }\n\n    // Store the necessary data for a trove\n    struct Trove {\n        uint debt;\n        uint coll;\n        uint stake;\n        Status status;\n        uint128 arrayIndex;\n    }\n\n    mapping (address => Trove) public Troves;\n\n    uint public totalStakes;\n\n    // Snapshot of the value of totalStakes, taken immediately after the latest liquidation\n    uint public totalStakesSnapshot;\n\n    // Snapshot of the total collateral across the ActivePool and DefaultPool, immediately after the latest liquidation.\n    uint public totalCollateralSnapshot;\n\n    /*\n    * L_ETH and L_LUSDDebt track the sums of accumulated liquidation rewards per unit staked. During its lifetime, each stake earns:\n    *\n    * An ETH gain of ( stake * [L_ETH - L_ETH(0)] )\n    * A LUSDDebt increase  of ( stake * [L_LUSDDebt - L_LUSDDebt(0)] )\n    *\n    * Where L_ETH(0) and L_LUSDDebt(0) are snapshots of L_ETH and L_LUSDDebt for the active Trove taken at the instant the stake was made\n    */\n    uint public L_ETH;\n    uint public L_LUSDDebt;\n\n    // Map addresses with active troves to their RewardSnapshot\n    mapping (address => RewardSnapshot) public rewardSnapshots;\n\n    // Object containing the ETH and LUSD snapshots for a given active trove\n    struct RewardSnapshot { uint ETH; uint LUSDDebt;}\n\n    // Array of all active trove addresses - used to to compute an approximate hint off-chain, for the sorted list insertion\n    address[] public TroveOwners;\n\n    // Error trackers for the trove redistribution calculation\n    uint public lastETHError_Redistribution;\n    uint public lastLUSDDebtError_Redistribution;\n\n    /* \n    * --- Variable container structs for liquidations ---\n    *\n    * These structs are used to hold, return and assign variables inside the liquidation functions,\n    * in order to avoid the error: \"CompilerError: Stack too deep\". \n    **/\n\n    struct LocalVariables_OuterLiquidationFunction {\n        uint price;\n        uint LUSDInStabPool;\n        bool recoveryModeAtStart;\n        uint liquidatedDebt;\n        uint liquidatedColl;\n    }\n\n    struct LocalVariables_InnerSingleLiquidateFunction {\n        uint collToLiquidate;\n        uint pendingDebtReward;\n        uint pendingCollReward;\n    }\n\n    struct LocalVariables_LiquidationSequence {\n        uint remainingLUSDInStabPool;\n        uint i;\n        uint ICR;\n        address user;\n        bool backToNormalMode;\n        uint entireSystemDebt;\n        uint entireSystemColl;\n    }\n\n    struct LiquidationValues {\n        uint entireTroveDebt;\n        uint entireTroveColl;\n        uint collGasCompensation;\n        uint LUSDGasCompensation;\n        uint debtToOffset;\n        uint collToSendToSP;\n        uint debtToRedistribute;\n        uint collToRedistribute;\n        address partialAddr;\n        uint partialNewDebt;\n        uint partialNewColl;\n        address partialUpperHint;\n        address partialLowerHint;\n    }\n\n    struct LiquidationTotals {\n        uint totalCollInSequence;\n        uint totalDebtInSequence;\n        uint totalCollGasCompensation;\n        uint totalLUSDGasCompensation;\n        uint totalDebtToOffset;\n        uint totalCollToSendToSP;\n        uint totalDebtToRedistribute;\n        uint totalCollToRedistribute;\n        address partialAddr;\n        uint partialNewDebt;\n        uint partialNewColl;\n        address partialUpperHint;\n        address partialLowerHint;\n    }\n\n    // --- Variable container structs for redemptions ---\n\n    struct RedemptionTotals {\n        uint totalLUSDToRedeem;\n        uint totalETHDrawn;\n        uint ETHFee;\n        uint ETHToSendToRedeemer;\n        uint decayedBaseRate;\n    }\n\n    struct SingleRedemptionValues {\n        uint LUSDLot;\n        uint ETHLot;\n    }\n\n    // --- Events ---\n\n    event Liquidation(uint _liquidatedDebt, uint _liquidatedColl, uint _collGasCompensation, uint _LUSDGasCompensation);\n    event Redemption(uint _attemptedLUSDAmount, uint _actualLUSDAmount, uint _ETHSent, uint _ETHFee);\n\n    enum TroveManagerOperation {\n        applyPendingRewards,\n        liquidateInNormalMode,\n        liquidateInRecoveryMode,\n        partiallyLiquidateInRecoveryMode,\n        redeemCollateral\n    }\n\n    event TroveCreated(address indexed _borrower, uint _arrayIndex);\n    event TroveUpdated(address indexed _borrower, uint _debt, uint _coll, uint _stake, TroveManagerOperation _operation);\n    event TroveLiquidated(address indexed _borrower, uint _debt, uint _coll, TroveManagerOperation _operation);\n\n    // --- Dependency setter ---\n\n    function setAddresses(\n        address _borrowerOperationsAddress,\n        address _activePoolAddress,\n        address _defaultPoolAddress,\n        address _stabilityPoolAddress,\n        address _collSurplusPoolAddress,\n        address _priceFeedAddress,\n        address _lusdTokenAddress,\n        address _sortedTrovesAddress,\n        address _lqtyStakingAddress\n    )\n        external\n        override\n        onlyOwner\n    {\n        borrowerOperationsAddress = _borrowerOperationsAddress;\n        activePool = IPool(_activePoolAddress);\n        defaultPool = IPool(_defaultPoolAddress);\n        stabilityPool = IStabilityPool(_stabilityPoolAddress);\n        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);\n        priceFeed = IPriceFeed(_priceFeedAddress);\n        lusdToken = ILUSDToken(_lusdTokenAddress);\n        sortedTroves = ISortedTroves(_sortedTrovesAddress);\n        lqtyStakingAddress = _lqtyStakingAddress;\n        lqtyStaking = ILQTYStaking(_lqtyStakingAddress);\n\n        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);\n        emit ActivePoolAddressChanged(_activePoolAddress);\n        emit DefaultPoolAddressChanged(_defaultPoolAddress);\n        emit StabilityPoolAddressChanged(_stabilityPoolAddress);\n        emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);\n        emit PriceFeedAddressChanged(_priceFeedAddress);\n        emit LUSDTokenAddressChanged(_lusdTokenAddress);\n        emit SortedTrovesAddressChanged(_sortedTrovesAddress);\n        emit LQTYStakingAddressChanged(_lqtyStakingAddress);\n\n        _renounceOwnership();\n    }\n\n    // --- Getters ---\n\n    function getTroveOwnersCount() external view override returns (uint) {\n        return TroveOwners.length;\n    }\n\n    function getTroveFromTroveOwnersArray(uint _index) external view override returns (address) {\n        return TroveOwners[_index];\n    }\n\n    // --- Trove Liquidation functions ---\n\n    // Single liquidation function. Closes the trove if its ICR is lower than the minimum collateral ratio. \n    function liquidate(address _borrower) external override {\n        _requireTroveisActive(_borrower);\n\n        address[] memory borrowers = new address[](1);\n        borrowers[0] = _borrower;\n        batchLiquidateTroves(borrowers);\n    }\n\n    // --- Inner single liquidation functions ---\n\n    // Liquidate one trove, in Normal Mode.\n    function _liquidateNormalMode(address _borrower, uint _LUSDInStabPool) internal returns (LiquidationValues memory V) {\n        LocalVariables_InnerSingleLiquidateFunction memory L;\n\n        (V.entireTroveDebt,\n        V.entireTroveColl,\n        L.pendingDebtReward,\n        L.pendingCollReward) = getEntireDebtAndColl(_borrower);\n\n        _movePendingTroveRewardsToActivePool(L.pendingDebtReward, L.pendingCollReward);\n        _removeStake(_borrower);\n\n        V.collGasCompensation = _getCollGasCompensation(V.entireTroveColl);\n        V.LUSDGasCompensation = LUSD_GAS_COMPENSATION;\n        uint collToLiquidate = V.entireTroveColl.sub(V.collGasCompensation);\n\n        (V.debtToOffset,\n        V.collToSendToSP,\n        V.debtToRedistribute,\n        V.collToRedistribute) = _getOffsetAndRedistributionVals(V.entireTroveDebt, collToLiquidate, _LUSDInStabPool);\n\n        _closeTrove(_borrower);\n        emit TroveLiquidated(_borrower, V.entireTroveDebt, V.entireTroveColl, TroveManagerOperation.liquidateInNormalMode);\n\n        return V;\n    }\n\n    // Liquidate one trove, in Recovery Mode.\n    function _liquidateRecoveryMode(address _borrower, uint _ICR, uint _LUSDInStabPool, uint _TCR) internal returns (LiquidationValues memory V) {\n        LocalVariables_InnerSingleLiquidateFunction memory L;\n        \n        if (TroveOwners.length <= 1) { return V; } // don't liquidate if last trove\n\n        (V.entireTroveDebt,\n        V.entireTroveColl,\n        L.pendingDebtReward,\n        L.pendingCollReward) = getEntireDebtAndColl(_borrower);\n\n        _movePendingTroveRewardsToActivePool(L.pendingDebtReward, L.pendingCollReward);\n\n        V.collGasCompensation = _getCollGasCompensation(V.entireTroveColl);\n        // In case of a partial liquidation, V.LUSDGasCompensation will be overwritten to zero, in the third branch below\n        V.LUSDGasCompensation = LUSD_GAS_COMPENSATION;\n        L.collToLiquidate = V.entireTroveColl.sub(V.collGasCompensation);\n\n        // If ICR <= 100%, purely redistribute the Trove across all active Troves\n        if (_ICR <= _100pct) {\n            _removeStake(_borrower);\n\n            V.debtToOffset = 0;\n            V.collToSendToSP = 0;\n            V.debtToRedistribute = V.entireTroveDebt;\n            V.collToRedistribute = L.collToLiquidate;\n\n            _closeTrove(_borrower);\n            emit TroveLiquidated(_borrower, V.entireTroveDebt, V.entireTroveColl, TroveManagerOperation.liquidateInRecoveryMode);\n\n        // If 100% < ICR < MCR, offset as much as possible, and redistribute the remainder\n        } else if ((_ICR > _100pct) && (_ICR < MCR)) {\n            _removeStake(_borrower);\n\n            (V.debtToOffset,\n            V.collToSendToSP,\n            V.debtToRedistribute,\n            V.collToRedistribute) = _getOffsetAndRedistributionVals(V.entireTroveDebt, L.collToLiquidate, _LUSDInStabPool);\n\n            _closeTrove(_borrower);\n            emit TroveLiquidated(_borrower, V.entireTroveDebt, V.entireTroveColl, TroveManagerOperation.liquidateInRecoveryMode);\n\n        /* \n        * If 110% <= ICR < current TCR (accounting for the preceding liquidations in the current sequence)\n        * and there is LUSD in the Stability Pool, only offset it as much as possible, with no redistribution.\n        */\n        } else if ((_ICR >= MCR) && (_ICR < _TCR)) {\n            assert(_LUSDInStabPool != 0);\n\n            _removeStake(_borrower);\n            \n            V = _getFullOrPartialOffsetVals(_borrower, V.entireTroveDebt, V.entireTroveColl, _LUSDInStabPool);\n\n            _closeTrove(_borrower);\n        }\n        else if (_ICR >= _TCR) {\n            LiquidationValues memory zeroVals;\n            return zeroVals;\n        }\n\n        return V;\n    }\n\n    /* In a full liquidation, returns the values for a trove's coll and debt to be offset, and coll and debt to be \n    * redistributed to active troves. \n    */\n    function _getOffsetAndRedistributionVals\n    (\n        uint _debt,\n        uint _coll,\n        uint _LUSDInStabPool\n    )\n        internal\n        pure\n        returns (uint debtToOffset, uint collToSendToSP, uint debtToRedistribute, uint collToRedistribute)\n    {\n        if (_LUSDInStabPool > 0) {\n        /* \n        * Offset as much debt & collateral as possible against the Stability Pool, and redistribute the remainder\n        * between all active troves.\n        *\n        *  If the trove's debt is larger than the deposited LUSD in the Stability Pool:\n        *\n        *  - Offset an amount of the trove's debt equal to the LUSD in the Stability Pool\n        *  - Send a fraction of the trove's collateral to the Stability Pool, equal to the fraction of its offset debt\n        *\n        */\n            debtToOffset = LiquityMath._min(_debt, _LUSDInStabPool);\n            collToSendToSP = _coll.mul(debtToOffset).div(_debt);\n            debtToRedistribute = _debt.sub(debtToOffset);\n            collToRedistribute = _coll.sub(collToSendToSP);\n        } else {\n            debtToOffset = 0;\n            collToSendToSP = 0;\n            debtToRedistribute = _debt;\n            collToRedistribute = _coll;\n        }\n    }\n\n    /*\n    *  If it is a full offset, get its offset coll/debt and ETH gas comp, and close the trove.\n    *\n    * If it is a partial liquidation, get its offset coll/debt and ETH gas comp, and its new coll/debt, and its re-insertion hints.\n    */\n    function _getFullOrPartialOffsetVals\n    (\n        address _borrower,\n        uint _entireTroveDebt,\n        uint _entireTroveColl,\n        uint _LUSDInStabPool\n    )\n        internal\n        returns (LiquidationValues memory V)\n    {\n        V.entireTroveDebt = _entireTroveDebt;\n        V.entireTroveColl = _entireTroveColl;\n\n        // When Stability Pool can fully absorb the trove's debt, perform a full offset\n        if (_entireTroveDebt <= _LUSDInStabPool) {\n            V.collGasCompensation = _getCollGasCompensation(_entireTroveColl);\n            V.LUSDGasCompensation = LUSD_GAS_COMPENSATION;\n\n            V.debtToOffset = _entireTroveDebt;\n            V.collToSendToSP = _entireTroveColl.sub(V.collGasCompensation);\n            V.debtToRedistribute = 0;\n            V.collToRedistribute = 0;\n\n            emit TroveLiquidated(_borrower, _entireTroveDebt, _entireTroveColl, TroveManagerOperation.liquidateInRecoveryMode);\n        }\n        /* \n        * When trove's debt is greater than the Stability Pool, perform a partial liquidation: offset as much as possible,\n        * and do not redistribute the remainder. The trove remains active, with a reduced collateral and debt.\n        *\n        * ETH gas compensation is based on and drawn from the collateral fraction that corresponds to the partial offset. \n        * LUSD gas compensation is left untouched. \n        *\n        * Since ETH gas comp is drawn purely from the *liquidated* portion, the trove is left with the same ICR as before the \n        * liquidation.\n        */\n        else if (_entireTroveDebt > _LUSDInStabPool) {\n            // Remaining debt in the trove is lower-bounded by the trove's gas compensation\n            V.partialNewDebt = LiquityMath._max(_entireTroveDebt.sub(_LUSDInStabPool), LUSD_GAS_COMPENSATION);\n          \n            V.debtToOffset = _entireTroveDebt.sub(V.partialNewDebt);\n\n            uint collFraction = _entireTroveColl.mul(V.debtToOffset).div(_entireTroveDebt);\n            V.collGasCompensation = _getCollGasCompensation(collFraction);\n          \n            V.LUSDGasCompensation = 0;  // LUSD gas compensation remains untouched\n\n            V.collToSendToSP = collFraction.sub(V.collGasCompensation);\n            V.collToRedistribute = 0;\n            V.debtToRedistribute = 0;\n\n            V.partialAddr = _borrower;\n            V.partialNewColl = _entireTroveColl.sub(collFraction);\n\n            // Get the partial trove's neighbours, so we can re-insert it later to the same position\n            V.partialUpperHint = sortedTroves.getPrev(_borrower);  \n            V.partialLowerHint = sortedTroves.getNext(_borrower);\n        }\n    }\n\n    /* \n    * Liquidate a sequence of troves. Closes a maximum number of n under-collateralized Troves,\n    * starting from the one with the lowest collateral ratio in the system, and moving upwards\n    */\n    function liquidateTroves(uint _n) external override {\n        LocalVariables_OuterLiquidationFunction memory L;\n\n        LiquidationTotals memory T;\n\n        L.price = priceFeed.getPrice();\n        L.LUSDInStabPool = stabilityPool.getTotalLUSDDeposits();\n        L.recoveryModeAtStart = checkRecoveryMode();\n\n        // Perform the appropriate liquidation sequence - tally the values, and obtain their totals\n        if (L.recoveryModeAtStart == true) {\n            T = _getTotalsFromLiquidateTrovesSequence_RecoveryMode(L.price, L.LUSDInStabPool, _n);\n        } else if (L.recoveryModeAtStart == false) {\n            T = _getTotalsFromLiquidateTrovesSequence_NormalMode(L.price, L.LUSDInStabPool, _n);\n        }\n\n        // Move liquidated ETH and LUSD to the appropriate pools\n        stabilityPool.offset(T.totalDebtToOffset, T.totalCollToSendToSP);\n        _redistributeDebtAndColl(T.totalDebtToRedistribute, T.totalCollToRedistribute);\n\n        // Update system snapshots and the final partially liquidated trove, if there is one\n        _updateSystemSnapshots_excludeCollRemainder(T.partialNewColl.add(T.totalCollGasCompensation));\n        _updatePartiallyLiquidatedTrove(T.partialAddr, T.partialNewDebt, T.partialNewColl, T.partialUpperHint, T. partialLowerHint, L.price);\n\n        L.liquidatedDebt = T.totalDebtInSequence.sub(T.partialNewDebt);\n        L.liquidatedColl = T.totalCollInSequence.sub(T.totalCollGasCompensation).sub(T.partialNewColl);\n        emit Liquidation(L.liquidatedDebt, L.liquidatedColl, T.totalCollGasCompensation, T.totalLUSDGasCompensation);\n\n        // Send gas compensation to caller\n        _sendGasCompensation(msg.sender, T.totalLUSDGasCompensation, T.totalCollGasCompensation);\n    }\n\n    /*\n    * This function is used when the liquidateTroves sequence starts during Recovery Mode. However, it\n    * handle the case where the system *leaves* Recovery Mode, part way through the liquidation sequence\n    */\n    function _getTotalsFromLiquidateTrovesSequence_RecoveryMode\n    (\n        uint _price,\n        uint _LUSDInStabPool,\n        uint _n\n    )\n        internal\n        returns(LiquidationTotals memory T)\n    {\n        LocalVariables_LiquidationSequence memory L;\n        LiquidationValues memory V;\n\n        L.remainingLUSDInStabPool = _LUSDInStabPool;\n        L.backToNormalMode = false;\n        L.entireSystemDebt = activePool.getLUSDDebt().add(defaultPool.getLUSDDebt());\n        L.entireSystemColl = activePool.getETH().add(defaultPool.getETH());\n\n        L.i = 0;\n        while (L.i < _n) {\n            L.user = sortedTroves.getLast();\n            L.ICR = getCurrentICR(L.user, _price);\n\n            if (L.backToNormalMode == false) {\n                // Break the loop if ICR is greater than MCR and Stability Pool is empty\n                if (L.ICR >= MCR && L.remainingLUSDInStabPool == 0) { break; }\n\n                uint TCR = LiquityMath._computeCR(L.entireSystemColl, L.entireSystemDebt, _price);\n        \n                V = _liquidateRecoveryMode(L.user, L.ICR, L.remainingLUSDInStabPool, TCR);\n\n                // Update aggregate trackers\n                L.remainingLUSDInStabPool = L.remainingLUSDInStabPool.sub(V.debtToOffset);\n                L.entireSystemDebt = L.entireSystemDebt.sub(V.debtToOffset);\n                L.entireSystemColl = L.entireSystemColl.sub(V.collToSendToSP);\n\n                // Add liquidation values to their respective running totals\n                T = _addLiquidationValuesToTotals(T, V);\n\n                // Break the loop if it was a partial liquidation\n                if (V.partialAddr != address(0)) {break;}\n\n                L.backToNormalMode = !_checkPotentialRecoveryMode(L.entireSystemColl, L.entireSystemDebt, _price);\n            }\n            else if (L.backToNormalMode == true && L.ICR < MCR) {\n                V = _liquidateNormalMode(L.user, L.remainingLUSDInStabPool);\n\n                L.remainingLUSDInStabPool = L.remainingLUSDInStabPool.sub(V.debtToOffset);\n\n                // Add liquidation values to their respective running totals\n                T = _addLiquidationValuesToTotals(T, V);\n\n            }  else break;  // break if the loop reaches a Trove with ICR >= MCR\n\n            // Break the loop if it reaches the first Trove in the sorted list\n            if (L.user == sortedTroves.getFirst()) { break; }\n\n            L.i++;\n        }\n    }\n\n    function _getTotalsFromLiquidateTrovesSequence_NormalMode\n    (\n        uint _price,\n        uint _LUSDInStabPool,\n        uint _n\n    )\n        internal\n        returns(LiquidationTotals memory T)\n    {\n        LocalVariables_LiquidationSequence memory L;\n        LiquidationValues memory V;\n\n        L.remainingLUSDInStabPool = _LUSDInStabPool;\n\n        L.i = 0;\n        while (L.i < _n) {\n            L.user = sortedTroves.getLast();\n            L.ICR = getCurrentICR(L.user, _price);\n\n            if (L.ICR < MCR) {\n                V = _liquidateNormalMode(L.user, L.remainingLUSDInStabPool);\n\n                L.remainingLUSDInStabPool = L.remainingLUSDInStabPool.sub(V.debtToOffset);\n\n                // Add liquidation values to their respective running totals\n                T = _addLiquidationValuesToTotals(T, V);\n\n            } else break;  // break if the loop reaches a Trove with ICR >= MCR\n\n            // Break the loop if it reaches the first Trove in the sorted list\n            if (L.user == sortedTroves.getFirst()) { break; }\n            L.i++;\n        }\n    }\n\n    /* \n    * Attempt to liquidate a custom list of troves provided by the caller. The liquidation sequence stops if\n    * a partial liquidation is performed, so it's up to the caller to order the troves in the _troveArray parameter.\n    */\n    function batchLiquidateTroves(address[] memory _troveArray) public override {\n        require(_troveArray.length != 0, \"TroveManager: Calldata address array must not be empty\");\n\n        LocalVariables_OuterLiquidationFunction memory L;\n        LiquidationTotals memory T;\n\n        L.price = priceFeed.getPrice();\n        L.LUSDInStabPool = stabilityPool.getTotalLUSDDeposits();\n        L.recoveryModeAtStart = checkRecoveryMode();\n\n        // Perform the appropriate liquidation sequence - tally values and obtain their totals.\n        if (L.recoveryModeAtStart == true) {\n           T = _getTotalFromBatchLiquidate_RecoveryMode(L.price, L.LUSDInStabPool, _troveArray);\n        } else if (L.recoveryModeAtStart == false) {\n            T = _getTotalsFromBatchLiquidate_NormalMode(L.price, L.LUSDInStabPool, _troveArray);\n        }\n\n        // Move liquidated ETH and LUSD to the appropriate pools\n        stabilityPool.offset(T.totalDebtToOffset, T.totalCollToSendToSP);\n        _redistributeDebtAndColl(T.totalDebtToRedistribute, T.totalCollToRedistribute);\n\n        // Update system snapshots and the final partially liquidated trove, if there is one\n        _updateSystemSnapshots_excludeCollRemainder(T.partialNewColl.add(T.totalCollGasCompensation));\n        _updatePartiallyLiquidatedTrove(T.partialAddr, T.partialNewDebt, T.partialNewColl, T.partialUpperHint, T. partialLowerHint, L.price);\n\n        L.liquidatedDebt = T.totalDebtInSequence.sub(T.partialNewDebt);\n        L.liquidatedColl = T.totalCollInSequence.sub(T.totalCollGasCompensation).sub(T.partialNewColl);\n        emit Liquidation(L.liquidatedDebt, L.liquidatedColl, T.totalCollGasCompensation, T.totalLUSDGasCompensation);\n\n        // Send gas compensation to caller\n        _sendGasCompensation(msg.sender, T.totalLUSDGasCompensation, T.totalCollGasCompensation);\n    }\n\n    /* \n    * This function is used when the batch liquidation sequence starts during Recovery Mode. However, it\n    * handle the case where the system *leaves* Recovery Mode, part way through the liquidation sequence\n    */\n    function _getTotalFromBatchLiquidate_RecoveryMode\n    (\n        uint _price,\n        uint _LUSDInStabPool,\n        address[] memory _troveArray)\n        internal\n        returns(LiquidationTotals memory T)\n    {\n        LocalVariables_LiquidationSequence memory L;\n        LiquidationValues memory V;\n\n        L.remainingLUSDInStabPool = _LUSDInStabPool;\n        L.backToNormalMode = false;\n        L.entireSystemDebt = activePool.getLUSDDebt().add(defaultPool.getLUSDDebt());\n        L.entireSystemColl = activePool.getETH().add(defaultPool.getETH());\n\n        L.i = 0;\n        for (L.i = 0; L.i < _troveArray.length; L.i++) {\n            L.user = _troveArray[L.i];\n            L.ICR = getCurrentICR(L.user, _price);\n\n            if (L.backToNormalMode == false) {\n\n                // Skip this trove if ICR is greater than MCR and Stability Pool is empty\n                if (L.ICR >= MCR && L.remainingLUSDInStabPool == 0) { continue; }\n\n                uint TCR = LiquityMath._computeCR(L.entireSystemColl, L.entireSystemDebt, _price);\n\n                V = _liquidateRecoveryMode(L.user, L.ICR, L.remainingLUSDInStabPool, TCR);\n\n                // Update aggregate trackers\n                L.remainingLUSDInStabPool = L.remainingLUSDInStabPool.sub(V.debtToOffset);\n                L.entireSystemDebt = L.entireSystemDebt.sub(V.debtToOffset);\n                L.entireSystemColl = L.entireSystemColl.sub(V.collToSendToSP);\n\n                // Add liquidation values to their respective running totals\n                T = _addLiquidationValuesToTotals(T, V);\n\n                // Break the loop if it was a partial liquidation\n                if (V.partialAddr != address(0)) { break; }\n\n                L.backToNormalMode = !_checkPotentialRecoveryMode(L.entireSystemColl, L.entireSystemDebt, _price);\n            }\n\n            else if (L.backToNormalMode == true && L.ICR < MCR) {\n                V = _liquidateNormalMode(L.user, L.remainingLUSDInStabPool);\n                L.remainingLUSDInStabPool = L.remainingLUSDInStabPool.sub(V.debtToOffset);\n\n                // Add liquidation values to their respective running totals\n                T = _addLiquidationValuesToTotals(T, V);\n            }\n        }\n    }\n\n    function _getTotalsFromBatchLiquidate_NormalMode\n    (\n        uint _price,\n        uint _LUSDInStabPool,\n        address[] memory _troveArray\n    )\n        internal\n        returns(LiquidationTotals memory T)\n    {\n        LocalVariables_LiquidationSequence memory L;\n        LiquidationValues memory V;\n\n        L.remainingLUSDInStabPool = _LUSDInStabPool;\n\n        for (L.i = 0; L.i < _troveArray.length; L.i++) {\n            L.user = _troveArray[L.i];\n            L.ICR = getCurrentICR(L.user, _price);\n\n            if (L.ICR < MCR) {\n                V = _liquidateNormalMode(L.user, L.remainingLUSDInStabPool);\n                L.remainingLUSDInStabPool = L.remainingLUSDInStabPool.sub(V.debtToOffset);\n\n                // Add liquidation values to their respective running totals\n                T = _addLiquidationValuesToTotals(T, V);\n            }\n        }\n    }\n\n    // --- Liquidation helper functions ---\n\n    function _addLiquidationValuesToTotals(LiquidationTotals memory T1, LiquidationValues memory V)\n    internal pure returns(LiquidationTotals memory T2) {\n\n        // Tally all the values with their respective running totals\n        T2.totalCollGasCompensation = T1.totalCollGasCompensation.add(V.collGasCompensation);\n        T2.totalLUSDGasCompensation = T1.totalLUSDGasCompensation.add(V.LUSDGasCompensation);\n        T2.totalDebtInSequence = T1.totalDebtInSequence.add(V.entireTroveDebt);\n        T2.totalCollInSequence = T1.totalCollInSequence.add(V.entireTroveColl);\n        T2.totalDebtToOffset = T1.totalDebtToOffset.add(V.debtToOffset);\n        T2.totalCollToSendToSP = T1.totalCollToSendToSP.add(V.collToSendToSP);\n        T2.totalDebtToRedistribute = T1.totalDebtToRedistribute.add(V.debtToRedistribute);\n        T2.totalCollToRedistribute = T1.totalCollToRedistribute.add(V.collToRedistribute);\n\n        // Assign the address of the partially liquidated trove, and its new debt and coll values\n        T2.partialAddr = V.partialAddr;\n        T2.partialNewDebt = V.partialNewDebt;\n        T2.partialNewColl = V.partialNewColl;\n        T2.partialUpperHint = V.partialUpperHint;\n        T2.partialLowerHint = V.partialLowerHint;\n\n        return T2;\n    }\n\n    // Update the properties of the partially liquidated trove, and insert it back to the list\n    function _updatePartiallyLiquidatedTrove\n    (\n        address _borrower, \n        uint _newDebt, \n        uint _newColl, \n        address _upperHint,\n        address _lowerHint,\n        uint _price\n    ) \n        internal \n    {\n        if ( _borrower == address(0)) { return; }\n\n        Troves[_borrower].debt = _newDebt;\n        Troves[_borrower].coll = _newColl;\n        Troves[_borrower].status = Status.active;\n\n        _updateTroveRewardSnapshots(_borrower);\n        _updateStakeAndTotalStakes(_borrower);\n\n        uint ICR = getCurrentICR(_borrower, _price);\n\n        /* \n        * Insert to sorted list and add to TroveOwners array. The partially liquidated trove has the same\n        * ICR as it did before the liquidation, so insertion is O(1): in principle, its ICR does not change.\n        * In practice, due to rounding error, its ICR can change slightly - so re-insert, with its previous neighbours\n        * as hints.\n        */\n        sortedTroves.insert(_borrower, ICR, _price, _upperHint, _lowerHint);\n        _addTroveOwnerToArray(_borrower);\n        emit TroveUpdated(_borrower, _newDebt, _newColl, Troves[_borrower].stake, TroveManagerOperation.partiallyLiquidateInRecoveryMode);\n    }\n\n    function _sendGasCompensation(address _liquidator, uint _LUSD, uint _ETH) internal {\n        if (_LUSD > 0) {\n            lusdToken.returnFromPool(GAS_POOL_ADDRESS, _liquidator, _LUSD);\n        }\n\n        if (_ETH > 0) {\n            activePool.sendETH(_liquidator, _ETH);\n        }\n    }\n\n    // Move a Trove's pending debt and collateral rewards from distributions, from the Default Pool to the Active Pool\n    function _movePendingTroveRewardsToActivePool(uint _LUSD, uint _ETH) internal {\n        defaultPool.decreaseLUSDDebt(_LUSD);\n        activePool.increaseLUSDDebt(_LUSD);\n        defaultPool.sendETH(address(activePool), _ETH);\n    }\n\n    // --- Redemption functions ---\n\n    // Redeem as much collateral as possible from _borrower's Trove in exchange for LUSD up to _maxLUSDamount\n    function _redeemCollateralFromTrove(\n        address _borrower,\n        uint _maxLUSDamount,\n        uint _price,\n        address _partialRedemptionHint,\n        uint _partialRedemptionHintICR\n    )\n        internal returns (SingleRedemptionValues memory V)\n    {\n        // Determine the remaining amount (lot) to be redeemed, capped by the entire debt of the Trove minus the gas compensation\n        V.LUSDLot = LiquityMath._min(_maxLUSDamount, Troves[_borrower].debt.sub(LUSD_GAS_COMPENSATION));\n\n        // Get the ETHLot of equivalent value in USD\n        V.ETHLot = V.LUSDLot.mul(1e18).div(_price);\n\n        // Decrease the debt and collateral of the current Trove according to the LUSD lot and corresponding ETH to send\n        uint newDebt = (Troves[_borrower].debt).sub(V.LUSDLot);\n        uint newColl = (Troves[_borrower].coll).sub(V.ETHLot);\n\n        if (newDebt == LUSD_GAS_COMPENSATION) {\n            // No debt left in the Trove (except for the gas compensation), therefore the trove gets closed\n            _removeStake(_borrower);\n            _closeTrove(_borrower);\n            _redeemCloseTrove(_borrower, LUSD_GAS_COMPENSATION, newColl);\n\n        } else {\n            uint newICR = LiquityMath._computeCR(newColl, newDebt, _price);\n\n            // Check if the provided hint is fresh. If not, we bail since trying to reinsert without a good hint will almost\n            // certainly result in running out of gas.\n            if (newICR != _partialRedemptionHintICR) {\n                V.LUSDLot = 0;\n                V.ETHLot = 0;\n                return V;\n            }\n\n            sortedTroves.reInsert(_borrower, newICR, _price, _partialRedemptionHint, _partialRedemptionHint);\n\n            Troves[_borrower].debt = newDebt;\n            Troves[_borrower].coll = newColl;\n            _updateStakeAndTotalStakes(_borrower);\n        }\n        emit TroveUpdated(\n            _borrower,\n            newDebt, newColl,\n            Troves[_borrower].stake,\n            TroveManagerOperation.redeemCollateral\n        );\n        return V;\n    }\n\n    /* \n    * Called when a full redemption occurs, and closes the trove.\n    * The redeemer swaps (debt - 10) LUSD for (debt - 10) worth of ETH, so the 10 LUSD gas compensation left corresponds to the remaining debt.\n    * In order to close the trove, the 10 LUSD gas compensation is burned, and 10 debt is removed from the active pool.\n    * The debt recorded on the trove's struct is zero'd elswhere, in _closeTrove.\n    * Any surplus ETH left in the trove, is sent to the Coll surplus pool, and can be later claimed by the borrower.\n    */ \n    function _redeemCloseTrove(address _borrower, uint _LUSD, uint _ETH) internal {\n        lusdToken.burn(GAS_POOL_ADDRESS, _LUSD);\n        // Update Active Pool LUSD, and send ETH to account\n        activePool.decreaseLUSDDebt(_LUSD);\n\n        // send ETH from Active Pool to CollSurplus Pool\n        collSurplusPool.accountSurplus(_borrower, _ETH);\n        activePool.sendETH(address(collSurplusPool), _ETH);\n    }\n\n    function _isValidFirstRedemptionHint(address _firstRedemptionHint, uint _price) internal view returns (bool) {\n        if (_firstRedemptionHint == address(0) ||\n            !sortedTroves.contains(_firstRedemptionHint) ||\n            getCurrentICR(_firstRedemptionHint, _price) < MCR\n        ) {\n            return false;\n        }\n\n        address nextTrove = sortedTroves.getNext(_firstRedemptionHint);\n        return nextTrove == address(0) || getCurrentICR(nextTrove, _price) < MCR;\n    }\n\n    /* Send _LUSDamount LUSD to the system and redeem the corresponding amount of collateral from as many Troves as are needed to fill the redemption\n    * request.  Applies pending rewards to a Trove before reducing its debt and coll.\n    *\n    * Note that if _amount is very large, this function can run out of gas, specially if traversed troves are small. This can be easily avoided by \n    * splitting the total _amount in appropriate chunks and calling the function multiple times.\n    * \n    * Param `_maxIterations` can also be provided, so the loop through Troves is capped (if its zero, it will be ignored).This makes it easier to \n    * avoid OOG for the frontend, as only knowing approximately the average cost of an iteration is enough, without needing to know the topology \n    * of the trove list. It also avoids the need to set the cap in stone in the contract, nor doing gas calculations, as both gas price and opcode \n    * costs can vary.\n    * \n    * All Troves that are redeemed from -- with the likely exception of the last one -- will end up with no debt left, therefore they will be closed.\n    * If the last Trove does have some remaining debt, it has a finite ICR, and the reinsertion could be anywhere in the list, therefore it requires a hint. \n    * A frontend should use getRedemptionHints() to calculate what the ICR of this Trove will be after redemption, and pass a hint for its position \n    * in the sortedTroves list along with the ICR value that the hint was found for.\n    * \n    * If another transaction modifies the list between calling getRedemptionHints() and passing the hints to redeemCollateral(), it\n    * is very likely that the last (partially) redeemed Trove would end up with a different ICR than what the hint is for. In this case the\n    * redemption will stop after the last completely redeemed Trove and the sender will keep the remaining LUSD amount, which they can attempt\n    * to redeem later.\n    */\n    function redeemCollateral(\n        uint _LUSDamount,\n        address _firstRedemptionHint,\n        address _partialRedemptionHint,\n        uint _partialRedemptionHintICR,\n        uint _maxIterations\n    )\n        external\n        override\n    {\n        uint activeDebt = activePool.getLUSDDebt();\n        uint defaultedDebt = defaultPool.getLUSDDebt();\n\n        RedemptionTotals memory T;\n\n        _requireAmountGreaterThanZero(_LUSDamount);\n        _requireLUSDBalanceCoversRedemption(msg.sender, _LUSDamount);\n\n        // Confirm redeemer's balance is less than total systemic debt\n        assert(lusdToken.balanceOf(msg.sender) <= (activeDebt.add(defaultedDebt)));\n\n        uint remainingLUSD = _LUSDamount;\n        uint price = priceFeed.getPrice();\n        address currentBorrower;\n\n        if (_isValidFirstRedemptionHint(_firstRedemptionHint, price)) {\n            currentBorrower = _firstRedemptionHint;\n        } else {\n            currentBorrower = sortedTroves.getLast();\n            // Find the first trove with ICR >= MCR\n            // SWC-104-Unchecked Call Return Value: L920\n            while (currentBorrower != address(0) && getCurrentICR(currentBorrower, price) < MCR) {\n                currentBorrower = sortedTroves.getPrev(currentBorrower);\n            }\n        }\n\n        // Loop through the Troves starting from the one with lowest collateral ratio until _amount of LUSD is exchanged for collateral\n        if (_maxIterations == 0) { _maxIterations = uint(-1); }\n        while (currentBorrower != address(0) && remainingLUSD > 0 && _maxIterations > 0) {\n            _maxIterations--;\n            // Save the address of the Trove preceding the current one, before potentially modifying the list\n            address nextUserToCheck = sortedTroves.getPrev(currentBorrower);\n\n            _applyPendingRewards(currentBorrower);\n            SingleRedemptionValues memory V = _redeemCollateralFromTrove(\n                currentBorrower,\n                remainingLUSD,\n                price,\n                _partialRedemptionHint,\n                _partialRedemptionHintICR\n            );\n\n            if (V.LUSDLot == 0) break; // Partial redemption hint got out-of-date, therefore we could not redeem from the last Trove\n\n            T.totalLUSDToRedeem  = T.totalLUSDToRedeem.add(V.LUSDLot);\n            T.totalETHDrawn = T.totalETHDrawn.add(V.ETHLot);\n\n            remainingLUSD = remainingLUSD.sub(V.LUSDLot);\n            currentBorrower = nextUserToCheck;\n        }\n\n        // Decay the baseRate due to time passed, and then increase it according to the size of this redemption\n        _updateBaseRateFromRedemption(T.totalETHDrawn, price);\n\n        // Calculate the ETH fee and send it to the LQTY staking contract\n        T.ETHFee = _getRedemptionFee(T.totalETHDrawn);\n        activePool.sendETH(lqtyStakingAddress, T.ETHFee);\n        lqtyStaking.increaseF_ETH(T.ETHFee);\n\n        T.ETHToSendToRedeemer = T.totalETHDrawn.sub(T.ETHFee);\n\n        // Burn the total LUSD that is cancelled with debt, and send the redeemed ETH to msg.sender\n        _activePoolRedeemCollateral(msg.sender, T.totalLUSDToRedeem, T.ETHToSendToRedeemer);\n\n        emit Redemption(_LUSDamount, T.totalLUSDToRedeem, T.totalETHDrawn, T.ETHFee);\n    }\n\n    // Burn the received LUSD, transfer the redeemed ETH to _redeemer and updates the Active Pool\n    function _activePoolRedeemCollateral(address _redeemer, uint _LUSD, uint _ETH) internal {\n        // Update Active Pool LUSD, and send ETH to account\n        lusdToken.burn(_redeemer, _LUSD);\n        activePool.decreaseLUSDDebt(_LUSD);\n\n        activePool.sendETH(_redeemer, _ETH);\n    }\n\n    // --- Helper functions ---\n\n\n    // Return the current collateral ratio (ICR) of a given Trove. Takes a trove's pending coll and debt rewards from redistributions into account.\n    function getCurrentICR(address _borrower, uint _price) public view override returns (uint) {\n        uint pendingETHReward = getPendingETHReward(_borrower);\n        uint pendingLUSDDebtReward = getPendingLUSDDebtReward(_borrower);\n\n        uint currentETH = Troves[_borrower].coll.add(pendingETHReward);\n        uint currentLUSDDebt = Troves[_borrower].debt.add(pendingLUSDDebtReward);\n\n        uint ICR = LiquityMath._computeCR(currentETH, currentLUSDDebt, _price);\n        return ICR;\n    }\n\n    function applyPendingRewards(address _borrower) external override {\n        _requireCallerIsBorrowerOperations();\n        return _applyPendingRewards(_borrower);\n    }\n\n    // Add the borrowers's coll and debt rewards earned from redistributions, to their Trove\n    function _applyPendingRewards(address _borrower) internal {\n        if (hasPendingRewards(_borrower)) {\n            _requireTroveisActive(_borrower);\n\n            // Compute pending rewards\n            uint pendingETHReward = getPendingETHReward(_borrower);\n            uint pendingLUSDDebtReward = getPendingLUSDDebtReward(_borrower);\n\n            // Apply pending rewards to trove's state\n            Troves[_borrower].coll = Troves[_borrower].coll.add(pendingETHReward);\n            Troves[_borrower].debt = Troves[_borrower].debt.add(pendingLUSDDebtReward);\n\n            _updateTroveRewardSnapshots(_borrower);\n\n            // Transfer from DefaultPool to ActivePool\n            _movePendingTroveRewardsToActivePool(pendingLUSDDebtReward, pendingETHReward);\n\n            emit TroveUpdated(\n                _borrower, \n                Troves[_borrower].debt, \n                Troves[_borrower].coll, \n                Troves[_borrower].stake, \n                TroveManagerOperation.applyPendingRewards\n            );\n        }\n    }\n\n    // Update borrower's snapshots of L_ETH and L_LUSDDebt to reflect the current values\n    function updateTroveRewardSnapshots(address _borrower) external override {\n        _requireCallerIsBorrowerOperations();\n       return _updateTroveRewardSnapshots(_borrower);\n    }\n\n    function _updateTroveRewardSnapshots(address _borrower) internal {\n        rewardSnapshots[_borrower].ETH = L_ETH;\n        rewardSnapshots[_borrower].LUSDDebt = L_LUSDDebt;\n    }\n\n    // Get the borrower's pending accumulated ETH reward, earned by their stake\n    function getPendingETHReward(address _borrower) public view override returns (uint) {\n        uint snapshotETH = rewardSnapshots[_borrower].ETH;\n        uint rewardPerUnitStaked = L_ETH.sub(snapshotETH);\n\n        if ( rewardPerUnitStaked == 0 ) { return 0; }\n\n        uint stake = Troves[_borrower].stake;\n\n        uint pendingETHReward = stake.mul(rewardPerUnitStaked).div(1e18);\n\n        return pendingETHReward;\n    }\n\n     // Get the borrower's pending accumulated LUSD reward, earned by their stake\n    function getPendingLUSDDebtReward(address _borrower) public view override returns (uint) {\n        uint snapshotLUSDDebt = rewardSnapshots[_borrower].LUSDDebt;\n        uint rewardPerUnitStaked = L_LUSDDebt.sub(snapshotLUSDDebt);\n\n        if ( rewardPerUnitStaked == 0 ) { return 0; }\n\n        uint stake =  Troves[_borrower].stake;\n\n        uint pendingLUSDDebtReward = stake.mul(rewardPerUnitStaked).div(1e18);\n\n        return pendingLUSDDebtReward;\n    }\n\n    function hasPendingRewards(address _borrower) public view override returns (bool) {\n        /* \n        * A Trove has pending rewards if its snapshot is less than the current rewards per-unit-staked sum:\n        * this indicates that rewards have occured since the snapshot was made, and the user therefore has\n        * pending rewards \n        */\n        return (rewardSnapshots[_borrower].ETH < L_ETH);\n    }\n\n    // Return the Troves entire debt and coll, including pending rewards from redistributions.\n    function getEntireDebtAndColl(\n        address _borrower\n    )\n        public\n        view\n        override\n        returns (uint debt, uint coll, uint pendingLUSDDebtReward, uint pendingETHReward)\n    {\n        debt = Troves[_borrower].debt;\n        coll = Troves[_borrower].coll;\n\n        pendingLUSDDebtReward = getPendingLUSDDebtReward(_borrower);\n        pendingETHReward = getPendingETHReward(_borrower);\n\n        debt = debt.add(pendingLUSDDebtReward);\n        coll = coll.add(pendingETHReward);\n    }\n\n    function removeStake(address _borrower) external override {\n        _requireCallerIsBorrowerOperations();\n        return _removeStake(_borrower);\n    }\n\n    // Remove borrower's stake from the totalStakes sum, and set their stake to 0\n    function _removeStake(address _borrower) internal {\n        uint stake = Troves[_borrower].stake;\n        totalStakes = totalStakes.sub(stake);\n        Troves[_borrower].stake = 0;\n    }\n\n    function updateStakeAndTotalStakes(address _borrower) external override returns (uint) {\n        _requireCallerIsBorrowerOperations();\n        return _updateStakeAndTotalStakes(_borrower);\n    }\n\n    // Update borrower's stake based on their latest collateral value\n    function _updateStakeAndTotalStakes(address _borrower) internal returns (uint) {\n        uint newStake = _computeNewStake(Troves[_borrower].coll);\n        uint oldStake = Troves[_borrower].stake;\n        Troves[_borrower].stake = newStake;\n        totalStakes = totalStakes.sub(oldStake).add(newStake);\n\n        return newStake;\n    }\n\n    // Calculate a new stake based on the snapshots of the totalStakes and totalCollateral taken at the last liquidation\n    function _computeNewStake(uint _coll) internal view returns (uint) {\n        uint stake;\n        if (totalCollateralSnapshot == 0) {\n            stake = _coll;\n        } else {\n            /*  \n            * The following assert() holds true because:\n            * - The system always contains >= 1 trove \n            * - When we close or liquidate a trove, we redistribute the pending rewards, so if all troves were closed/liquidated, \n            * rewards wouldve been emptied and totalCollateralSnapshot would be zero too.\n            */\n            assert(totalStakesSnapshot > 0);\n            stake = _coll.mul(totalStakesSnapshot).div(totalCollateralSnapshot);\n        }\n        return stake;\n    }\n\n    function _redistributeDebtAndColl(uint _debt, uint _coll) internal {\n        if (_debt == 0) { return; }\n\n        if (totalStakes > 0) {\n            /* \n            * Add distributed coll and debt rewards-per-unit-staked to the running totals.\n            * Division uses a \"feedback\" error correction, to keep the cumulative error in\n            * the  L_ETH and L_LUSDDebt state variables low. \n            */\n            uint ETHNumerator = _coll.mul(1e18).add(lastETHError_Redistribution);\n            uint LUSDDebtNumerator = _debt.mul(1e18).add(lastLUSDDebtError_Redistribution);\n\n            uint ETHRewardPerUnitStaked = ETHNumerator.div(totalStakes);\n            uint LUSDDebtRewardPerUnitStaked = LUSDDebtNumerator.div(totalStakes);\n\n            lastETHError_Redistribution = ETHNumerator.sub(ETHRewardPerUnitStaked.mul(totalStakes));\n            lastLUSDDebtError_Redistribution = LUSDDebtNumerator.sub(LUSDDebtRewardPerUnitStaked.mul(totalStakes));\n\n            L_ETH = L_ETH.add(ETHRewardPerUnitStaked);\n            L_LUSDDebt = L_LUSDDebt.add(LUSDDebtRewardPerUnitStaked);\n        }\n\n        // Transfer coll and debt from ActivePool to DefaultPool\n        activePool.decreaseLUSDDebt(_debt);\n        defaultPool.increaseLUSDDebt(_debt);\n        activePool.sendETH(address(defaultPool), _coll);\n    }\n\n    function closeTrove(address _borrower) external override {\n        _requireCallerIsBorrowerOperations();\n        return _closeTrove(_borrower);\n    }\n\n    function _closeTrove(address _borrower) internal {\n        uint TroveOwnersArrayLength = TroveOwners.length;\n        _requireMoreThanOneTroveInSystem(TroveOwnersArrayLength);\n\n        Troves[_borrower].status = Status.closed;\n        Troves[_borrower].coll = 0;\n        Troves[_borrower].debt = 0;\n\n        rewardSnapshots[_borrower].ETH = 0;\n        rewardSnapshots[_borrower].LUSDDebt = 0;\n\n        _removeTroveOwner(_borrower, TroveOwnersArrayLength);\n        sortedTroves.remove(_borrower);\n    }\n\n    /* \n    * Updates snapshots of system total stakes and total collateral, excluding a given collateral remainder from the calculation. \n    * Used in a liquidation sequence.\n    *\n    * The calculation excludes two portions of collateral that are in the ActivePool: \n    *\n    * 1) the total ETH gas compensation from the liquidation sequence\n    * 2) The remaining collateral in a partially liquidated trove (if one occurred)\n    *\n    * The ETH as compensation must be excluded as it is always sent out at the very end of the liquidation sequence.\n    *\n    * The partially liquidated trove's remaining collateral stays in the ActivePool, but it is excluded here so the system \n    * can take snapshots before the partially liquidated trove's stake is updated (based on these snapshots). This ensures\n    * the partial's new stake doesn't double-count its own remaining collateral.\n    *\n    */\n    function _updateSystemSnapshots_excludeCollRemainder(uint _collRemainder) internal {\n        totalStakesSnapshot = totalStakes;\n\n        uint activeColl = activePool.getETH();\n        uint liquidatedColl = defaultPool.getETH();\n        totalCollateralSnapshot = activeColl.sub(_collRemainder).add(liquidatedColl);\n    }\n\n    // Push the owner's address to the Trove owners list, and record the corresponding array index on the Trove struct\n    function addTroveOwnerToArray(address _borrower) external override returns (uint index) {\n        _requireCallerIsBorrowerOperations();\n        return _addTroveOwnerToArray(_borrower);\n    }\n\n    function _addTroveOwnerToArray(address _borrower) internal returns (uint128 index) {\n        require(TroveOwners.length < 2**128 - 1, \"TroveManager: TroveOwners array has maximum size of 2^128 - 1\");\n\n        // Push the Troveowner to the array\n        TroveOwners.push(_borrower);\n\n        // Record the index of the new Troveowner on their Trove struct\n        index = uint128(TroveOwners.length.sub(1));\n        Troves[_borrower].arrayIndex = index;\n\n        return index;\n    }\n\n    /* \n    * Remove a Trove owner from the TroveOwners array, not preserving array order. Removing owner 'B' does the following:\n    * [A B C D E] => [A E C D], and updates E's Trove struct to point to its new array index. \n    */\n    function _removeTroveOwner(address _borrower, uint TroveOwnersArrayLength) internal {\n        require(Troves[_borrower].status == Status.closed, \"TroveManager: Trove is still active\");\n\n        uint128 index = Troves[_borrower].arrayIndex;\n        uint length = TroveOwnersArrayLength;\n        uint idxLast = length.sub(1);\n\n        assert(index <= idxLast);\n\n        address addressToMove = TroveOwners[idxLast];\n\n        TroveOwners[index] = addressToMove;\n        Troves[addressToMove].arrayIndex = index;\n        TroveOwners.pop();\n    }\n\n    // --- Recovery Mode and TCR functions ---\n\n    function checkRecoveryMode() public view override returns (bool) {\n        uint TCR = getTCR();\n\n        if (TCR < CCR) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    // Check whether or not the system *would be* in Recovery Mode, given an ETH:USD price, and the entire system coll and debt.\n    function _checkPotentialRecoveryMode(\n        uint _entireSystemColl,\n        uint _entireSystemDebt,\n        uint _price\n    )\n        internal\n        pure\n    returns (bool)\n    {\n        uint TCR = LiquityMath._computeCR(_entireSystemColl, _entireSystemDebt, _price);\n        if (TCR < CCR) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n    // SWC-135-Code With No Effects: L1276-L1284\n    function getTCR() public view override returns (uint TCR) {\n        uint price = priceFeed.getPrice();\n        uint entireSystemColl = getEntireSystemColl();\n        uint entireSystemDebt = getEntireSystemDebt();\n\n        TCR = LiquityMath._computeCR(entireSystemColl, entireSystemDebt, price);\n\n        return TCR;\n    }\n    // SWC-135-Code With No Effects: L1286-L1291\n    function getEntireSystemColl() public view override returns (uint entireSystemColl) {\n        uint activeColl = activePool.getETH();\n        uint liquidatedColl = defaultPool.getETH();\n\n        return activeColl.add(liquidatedColl);\n    }\n\n    function getEntireSystemDebt() public view override returns (uint entireSystemDebt) {\n        uint activeDebt = activePool.getLUSDDebt();\n        uint closedDebt = defaultPool.getLUSDDebt();\n\n        return activeDebt.add(closedDebt);\n    }\n\n    // --- Redemption fee functions ---\n\n    /* \n    * This function has two impacts on the baseRate state variable:\n    * 1) decays the baseRate based on time passed since last redemption or LUSD borrowing operation.\n    * then,\n    * 2) increases the baseRate based on the amount redeemed, as a proportion of total supply\n    */\n    function _updateBaseRateFromRedemption(uint _ETHDrawn,  uint _price) internal returns (uint) {\n        uint decayedBaseRate = _calcDecayedBaseRate();\n\n        uint activeDebt = activePool.getLUSDDebt();\n        uint closedDebt = defaultPool.getLUSDDebt();\n        uint totalLUSDSupply = activeDebt.add(closedDebt);\n\n        /* Convert the drawn ETH back to LUSD at face value rate (1 LUSD:1 USD), in order to get\n        * the fraction of total supply that was redeemed at face value. */\n        uint redeemedLUSDFraction = _ETHDrawn.mul(_price).div(totalLUSDSupply);\n\n        uint newBaseRate = decayedBaseRate.add(redeemedLUSDFraction.div(BETA));\n\n        // Update the baseRate state variable\n        baseRate = newBaseRate < 1e18 ? newBaseRate : 1e18;  // cap baseRate at a maximum of 100%\n        assert(baseRate <= 1e18 && baseRate > 0); // Base rate is always non-zero after redemption\n\n        _updateLastFeeOpTime();\n\n        return baseRate;\n    }\n\n    function _getRedemptionFee(uint _ETHDrawn) internal view returns (uint) {\n       return baseRate.mul(_ETHDrawn).div(1e18);\n    }\n\n    // --- Borrowing fee functions ---\n\n    function getBorrowingFee(uint _LUSDDebt) external view override returns (uint) {\n        return _LUSDDebt.mul(baseRate).div(1e18);\n    }\n\n    // Updates the baseRate state variable based on time elapsed since the last redemption or LUSD borrowing operation.\n    function decayBaseRateFromBorrowing() external override {\n        _requireCallerIsBorrowerOperations();\n\n        baseRate = _calcDecayedBaseRate();\n        assert(baseRate <= 1e18);  // The baseRate can decay to 0\n\n        _updateLastFeeOpTime();\n    }\n\n    // --- Internal fee functions ---\n\n    // Update the last fee operation time only if time passed >= decay interval. This prevents base rate griefing.\n    function _updateLastFeeOpTime() internal {\n        uint timePassed = block.timestamp.sub(lastFeeOperationTime);\n\n        if (timePassed >= SECONDS_IN_ONE_MINUTE) {\n            lastFeeOperationTime = block.timestamp;\n        }\n    }\n\n    function _calcDecayedBaseRate() internal view returns (uint) {\n        uint minutesPassed = _minutesPassedSinceLastFeeOp();\n        uint decayFactor = LiquityMath._decPow(MINUTE_DECAY_FACTOR, minutesPassed);\n\n        return baseRate.mul(decayFactor).div(1e18);\n    }\n\n    function _minutesPassedSinceLastFeeOp() internal view returns (uint) {\n        return (block.timestamp.sub(lastFeeOperationTime)).div(SECONDS_IN_ONE_MINUTE);\n    }\n\n    // --- 'require' wrapper functions ---\n\n    function _requireCallerIsBorrowerOperations() internal view {\n        require(msg.sender == borrowerOperationsAddress, \"TroveManager: Caller is not the BorrowerOperations contract\");\n    }\n\n    function _requireTroveisActive(address _borrower) internal view {\n        require(Troves[_borrower].status == Status.active, \"TroveManager: Trove does not exist or is closed\");\n    }\n\n    function _requireLUSDBalanceCoversRedemption(address _redeemer, uint _amount) internal view {\n        require(lusdToken.balanceOf(_redeemer) >= _amount, \"TroveManager: Requested redemption amount must be <= user's LUSD token balance\");\n    }\n\n    function _requireMoreThanOneTroveInSystem(uint TroveOwnersArrayLength) internal view {\n        require (TroveOwnersArrayLength > 1 && sortedTroves.getSize() > 1, \"TroveManager: Only one trove in the system\");\n    }\n\n    function _requireAmountGreaterThanZero(uint _amount) internal pure {\n        require(_amount > 0, \"TroveManager: Amount must be greater than zero\");\n    }\n\n    // --- Trove property getters ---\n\n    function getTroveStatus(address _borrower) external view override returns (uint) {\n        return uint(Troves[_borrower].status);\n    }\n\n    function getTroveStake(address _borrower) external view override returns (uint) {\n        return Troves[_borrower].stake;\n    }\n\n    function getTroveDebt(address _borrower) external view override returns (uint) {\n        return Troves[_borrower].debt;\n    }\n\n    function getTroveColl(address _borrower) external view override returns (uint) {\n        return Troves[_borrower].coll;\n    }\n\n    // --- Trove property setters, called by BorrowerOperations ---\n\n    function setTroveStatus(address _borrower, uint _num) external override {\n        _requireCallerIsBorrowerOperations();\n        Troves[_borrower].status = Status(_num);\n    }\n\n    function increaseTroveColl(address _borrower, uint _collIncrease) external override returns (uint) {\n        _requireCallerIsBorrowerOperations();\n        uint newColl = Troves[_borrower].coll.add(_collIncrease);\n        Troves[_borrower].coll = newColl;\n        return newColl;\n    }\n\n    function decreaseTroveColl(address _borrower, uint _collDecrease) external override returns (uint) {\n        _requireCallerIsBorrowerOperations();\n        uint newColl = Troves[_borrower].coll.sub(_collDecrease);\n        Troves[_borrower].coll = newColl;\n        return newColl;\n    }\n\n    function increaseTroveDebt(address _borrower, uint _debtIncrease) external override returns (uint) {\n        _requireCallerIsBorrowerOperations();\n        uint newDebt = Troves[_borrower].debt.add(_debtIncrease);\n        Troves[_borrower].debt = newDebt;\n        return newDebt;\n    }\n\n    function decreaseTroveDebt(address _borrower, uint _debtDecrease) external override returns (uint) {\n        _requireCallerIsBorrowerOperations();\n        uint newDebt = Troves[_borrower].debt.sub(_debtDecrease);\n        Troves[_borrower].debt = newDebt;\n        return newDebt;\n    }\n}",
        "function": "decayBaseRateFromBorrowing()",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-Liquity/dev-f0df3efa5a5f05b205752184cfce107c5bd6e06c/packages/contracts/contracts/TroveManager.sol",
        "vulnerability": "Dependence on predictable environment variable (SWC 116)",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract TroveManager is LiquityBase, Ownable, ITroveManager {\n\n    // --- Connected contract declarations ---\n\n    address public borrowerOperationsAddress;\n\n    IPool public activePool;\n\n    IPool public defaultPool;\n\n    IStabilityPool public stabilityPool;\n\n    ICollSurplusPool collSurplusPool;\n\n    ILUSDToken public lusdToken;\n\n    IPriceFeed public priceFeed;\n\n    ILQTYStaking public lqtyStaking;\n    address public lqtyStakingAddress;\n\n    // A doubly linked list of Troves, sorted by their sorted by their collateral ratios\n    ISortedTroves public sortedTroves;\n\n    // --- Data structures ---\n\n    uint constant public SECONDS_IN_ONE_MINUTE = 60;\n    uint constant public MINUTE_DECAY_FACTOR = 999832508430720967;  // 18 digit decimal. Corresponds to an hourly decay factor of 0.99\n\n    /* \n    * BETA: 18 digit decimal. Parameter by which to divide the redeemed fraction, in order to calc the new base rate from a redemption. \n    * Corresponds to (1 / ALPHA) in the white paper. \n    */\n    uint constant public BETA = 2;\n\n    uint public baseRate;\n\n    // The timestamp of the latest fee operation (redemption or new LUSD issuance) \n    uint public lastFeeOperationTime;\n\n    enum Status { nonExistent, active, closed }\n\n    // Store the necessary data for a trove\n    struct Trove {\n        uint debt;\n        uint coll;\n        uint stake;\n        Status status;\n        uint128 arrayIndex;\n    }\n\n    mapping (address => Trove) public Troves;\n\n    uint public totalStakes;\n\n    // Snapshot of the value of totalStakes, taken immediately after the latest liquidation\n    uint public totalStakesSnapshot;\n\n    // Snapshot of the total collateral across the ActivePool and DefaultPool, immediately after the latest liquidation.\n    uint public totalCollateralSnapshot;\n\n    /*\n    * L_ETH and L_LUSDDebt track the sums of accumulated liquidation rewards per unit staked. During its lifetime, each stake earns:\n    *\n    * An ETH gain of ( stake * [L_ETH - L_ETH(0)] )\n    * A LUSDDebt increase  of ( stake * [L_LUSDDebt - L_LUSDDebt(0)] )\n    *\n    * Where L_ETH(0) and L_LUSDDebt(0) are snapshots of L_ETH and L_LUSDDebt for the active Trove taken at the instant the stake was made\n    */\n    uint public L_ETH;\n    uint public L_LUSDDebt;\n\n    // Map addresses with active troves to their RewardSnapshot\n    mapping (address => RewardSnapshot) public rewardSnapshots;\n\n    // Object containing the ETH and LUSD snapshots for a given active trove\n    struct RewardSnapshot { uint ETH; uint LUSDDebt;}\n\n    // Array of all active trove addresses - used to to compute an approximate hint off-chain, for the sorted list insertion\n    address[] public TroveOwners;\n\n    // Error trackers for the trove redistribution calculation\n    uint public lastETHError_Redistribution;\n    uint public lastLUSDDebtError_Redistribution;\n\n    /* \n    * --- Variable container structs for liquidations ---\n    *\n    * These structs are used to hold, return and assign variables inside the liquidation functions,\n    * in order to avoid the error: \"CompilerError: Stack too deep\". \n    **/\n\n    struct LocalVariables_OuterLiquidationFunction {\n        uint price;\n        uint LUSDInStabPool;\n        bool recoveryModeAtStart;\n        uint liquidatedDebt;\n        uint liquidatedColl;\n    }\n\n    struct LocalVariables_InnerSingleLiquidateFunction {\n        uint collToLiquidate;\n        uint pendingDebtReward;\n        uint pendingCollReward;\n    }\n\n    struct LocalVariables_LiquidationSequence {\n        uint remainingLUSDInStabPool;\n        uint i;\n        uint ICR;\n        address user;\n        bool backToNormalMode;\n        uint entireSystemDebt;\n        uint entireSystemColl;\n    }\n\n    struct LiquidationValues {\n        uint entireTroveDebt;\n        uint entireTroveColl;\n        uint collGasCompensation;\n        uint LUSDGasCompensation;\n        uint debtToOffset;\n        uint collToSendToSP;\n        uint debtToRedistribute;\n        uint collToRedistribute;\n        address partialAddr;\n        uint partialNewDebt;\n        uint partialNewColl;\n        address partialUpperHint;\n        address partialLowerHint;\n    }\n\n    struct LiquidationTotals {\n        uint totalCollInSequence;\n        uint totalDebtInSequence;\n        uint totalCollGasCompensation;\n        uint totalLUSDGasCompensation;\n        uint totalDebtToOffset;\n        uint totalCollToSendToSP;\n        uint totalDebtToRedistribute;\n        uint totalCollToRedistribute;\n        address partialAddr;\n        uint partialNewDebt;\n        uint partialNewColl;\n        address partialUpperHint;\n        address partialLowerHint;\n    }\n\n    // --- Variable container structs for redemptions ---\n\n    struct RedemptionTotals {\n        uint totalLUSDToRedeem;\n        uint totalETHDrawn;\n        uint ETHFee;\n        uint ETHToSendToRedeemer;\n        uint decayedBaseRate;\n    }\n\n    struct SingleRedemptionValues {\n        uint LUSDLot;\n        uint ETHLot;\n    }\n\n    // --- Events ---\n\n    event Liquidation(uint _liquidatedDebt, uint _liquidatedColl, uint _collGasCompensation, uint _LUSDGasCompensation);\n    event Redemption(uint _attemptedLUSDAmount, uint _actualLUSDAmount, uint _ETHSent, uint _ETHFee);\n\n    enum TroveManagerOperation {\n        applyPendingRewards,\n        liquidateInNormalMode,\n        liquidateInRecoveryMode,\n        partiallyLiquidateInRecoveryMode,\n        redeemCollateral\n    }\n\n    event TroveCreated(address indexed _borrower, uint _arrayIndex);\n    event TroveUpdated(address indexed _borrower, uint _debt, uint _coll, uint _stake, TroveManagerOperation _operation);\n    event TroveLiquidated(address indexed _borrower, uint _debt, uint _coll, TroveManagerOperation _operation);\n\n    // --- Dependency setter ---\n\n    function setAddresses(\n        address _borrowerOperationsAddress,\n        address _activePoolAddress,\n        address _defaultPoolAddress,\n        address _stabilityPoolAddress,\n        address _collSurplusPoolAddress,\n        address _priceFeedAddress,\n        address _lusdTokenAddress,\n        address _sortedTrovesAddress,\n        address _lqtyStakingAddress\n    )\n        external\n        override\n        onlyOwner\n    {\n        borrowerOperationsAddress = _borrowerOperationsAddress;\n        activePool = IPool(_activePoolAddress);\n        defaultPool = IPool(_defaultPoolAddress);\n        stabilityPool = IStabilityPool(_stabilityPoolAddress);\n        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);\n        priceFeed = IPriceFeed(_priceFeedAddress);\n        lusdToken = ILUSDToken(_lusdTokenAddress);\n        sortedTroves = ISortedTroves(_sortedTrovesAddress);\n        lqtyStakingAddress = _lqtyStakingAddress;\n        lqtyStaking = ILQTYStaking(_lqtyStakingAddress);\n\n        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);\n        emit ActivePoolAddressChanged(_activePoolAddress);\n        emit DefaultPoolAddressChanged(_defaultPoolAddress);\n        emit StabilityPoolAddressChanged(_stabilityPoolAddress);\n        emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);\n        emit PriceFeedAddressChanged(_priceFeedAddress);\n        emit LUSDTokenAddressChanged(_lusdTokenAddress);\n        emit SortedTrovesAddressChanged(_sortedTrovesAddress);\n        emit LQTYStakingAddressChanged(_lqtyStakingAddress);\n\n        _renounceOwnership();\n    }\n\n    // --- Getters ---\n\n    function getTroveOwnersCount() external view override returns (uint) {\n        return TroveOwners.length;\n    }\n\n    function getTroveFromTroveOwnersArray(uint _index) external view override returns (address) {\n        return TroveOwners[_index];\n    }\n\n    // --- Trove Liquidation functions ---\n\n    // Single liquidation function. Closes the trove if its ICR is lower than the minimum collateral ratio. \n    function liquidate(address _borrower) external override {\n        _requireTroveisActive(_borrower);\n\n        address[] memory borrowers = new address[](1);\n        borrowers[0] = _borrower;\n        batchLiquidateTroves(borrowers);\n    }\n\n    // --- Inner single liquidation functions ---\n\n    // Liquidate one trove, in Normal Mode.\n    function _liquidateNormalMode(address _borrower, uint _LUSDInStabPool) internal returns (LiquidationValues memory V) {\n        LocalVariables_InnerSingleLiquidateFunction memory L;\n\n        (V.entireTroveDebt,\n        V.entireTroveColl,\n        L.pendingDebtReward,\n        L.pendingCollReward) = getEntireDebtAndColl(_borrower);\n\n        _movePendingTroveRewardsToActivePool(L.pendingDebtReward, L.pendingCollReward);\n        _removeStake(_borrower);\n\n        V.collGasCompensation = _getCollGasCompensation(V.entireTroveColl);\n        V.LUSDGasCompensation = LUSD_GAS_COMPENSATION;\n        uint collToLiquidate = V.entireTroveColl.sub(V.collGasCompensation);\n\n        (V.debtToOffset,\n        V.collToSendToSP,\n        V.debtToRedistribute,\n        V.collToRedistribute) = _getOffsetAndRedistributionVals(V.entireTroveDebt, collToLiquidate, _LUSDInStabPool);\n\n        _closeTrove(_borrower);\n        emit TroveLiquidated(_borrower, V.entireTroveDebt, V.entireTroveColl, TroveManagerOperation.liquidateInNormalMode);\n\n        return V;\n    }\n\n    // Liquidate one trove, in Recovery Mode.\n    function _liquidateRecoveryMode(address _borrower, uint _ICR, uint _LUSDInStabPool, uint _TCR) internal returns (LiquidationValues memory V) {\n        LocalVariables_InnerSingleLiquidateFunction memory L;\n        \n        if (TroveOwners.length <= 1) { return V; } // don't liquidate if last trove\n\n        (V.entireTroveDebt,\n        V.entireTroveColl,\n        L.pendingDebtReward,\n        L.pendingCollReward) = getEntireDebtAndColl(_borrower);\n\n        _movePendingTroveRewardsToActivePool(L.pendingDebtReward, L.pendingCollReward);\n\n        V.collGasCompensation = _getCollGasCompensation(V.entireTroveColl);\n        // In case of a partial liquidation, V.LUSDGasCompensation will be overwritten to zero, in the third branch below\n        V.LUSDGasCompensation = LUSD_GAS_COMPENSATION;\n        L.collToLiquidate = V.entireTroveColl.sub(V.collGasCompensation);\n\n        // If ICR <= 100%, purely redistribute the Trove across all active Troves\n        if (_ICR <= _100pct) {\n            _removeStake(_borrower);\n\n            V.debtToOffset = 0;\n            V.collToSendToSP = 0;\n            V.debtToRedistribute = V.entireTroveDebt;\n            V.collToRedistribute = L.collToLiquidate;\n\n            _closeTrove(_borrower);\n            emit TroveLiquidated(_borrower, V.entireTroveDebt, V.entireTroveColl, TroveManagerOperation.liquidateInRecoveryMode);\n\n        // If 100% < ICR < MCR, offset as much as possible, and redistribute the remainder\n        } else if ((_ICR > _100pct) && (_ICR < MCR)) {\n            _removeStake(_borrower);\n\n            (V.debtToOffset,\n            V.collToSendToSP,\n            V.debtToRedistribute,\n            V.collToRedistribute) = _getOffsetAndRedistributionVals(V.entireTroveDebt, L.collToLiquidate, _LUSDInStabPool);\n\n            _closeTrove(_borrower);\n            emit TroveLiquidated(_borrower, V.entireTroveDebt, V.entireTroveColl, TroveManagerOperation.liquidateInRecoveryMode);\n\n        /* \n        * If 110% <= ICR < current TCR (accounting for the preceding liquidations in the current sequence)\n        * and there is LUSD in the Stability Pool, only offset it as much as possible, with no redistribution.\n        */\n        } else if ((_ICR >= MCR) && (_ICR < _TCR)) {\n            assert(_LUSDInStabPool != 0);\n\n            _removeStake(_borrower);\n            \n            V = _getFullOrPartialOffsetVals(_borrower, V.entireTroveDebt, V.entireTroveColl, _LUSDInStabPool);\n\n            _closeTrove(_borrower);\n        }\n        else if (_ICR >= _TCR) {\n            LiquidationValues memory zeroVals;\n            return zeroVals;\n        }\n\n        return V;\n    }\n\n    /* In a full liquidation, returns the values for a trove's coll and debt to be offset, and coll and debt to be \n    * redistributed to active troves. \n    */\n    function _getOffsetAndRedistributionVals\n    (\n        uint _debt,\n        uint _coll,\n        uint _LUSDInStabPool\n    )\n        internal\n        pure\n        returns (uint debtToOffset, uint collToSendToSP, uint debtToRedistribute, uint collToRedistribute)\n    {\n        if (_LUSDInStabPool > 0) {\n        /* \n        * Offset as much debt & collateral as possible against the Stability Pool, and redistribute the remainder\n        * between all active troves.\n        *\n        *  If the trove's debt is larger than the deposited LUSD in the Stability Pool:\n        *\n        *  - Offset an amount of the trove's debt equal to the LUSD in the Stability Pool\n        *  - Send a fraction of the trove's collateral to the Stability Pool, equal to the fraction of its offset debt\n        *\n        */\n            debtToOffset = LiquityMath._min(_debt, _LUSDInStabPool);\n            collToSendToSP = _coll.mul(debtToOffset).div(_debt);\n            debtToRedistribute = _debt.sub(debtToOffset);\n            collToRedistribute = _coll.sub(collToSendToSP);\n        } else {\n            debtToOffset = 0;\n            collToSendToSP = 0;\n            debtToRedistribute = _debt;\n            collToRedistribute = _coll;\n        }\n    }\n\n    /*\n    *  If it is a full offset, get its offset coll/debt and ETH gas comp, and close the trove.\n    *\n    * If it is a partial liquidation, get its offset coll/debt and ETH gas comp, and its new coll/debt, and its re-insertion hints.\n    */\n    function _getFullOrPartialOffsetVals\n    (\n        address _borrower,\n        uint _entireTroveDebt,\n        uint _entireTroveColl,\n        uint _LUSDInStabPool\n    )\n        internal\n        returns (LiquidationValues memory V)\n    {\n        V.entireTroveDebt = _entireTroveDebt;\n        V.entireTroveColl = _entireTroveColl;\n\n        // When Stability Pool can fully absorb the trove's debt, perform a full offset\n        if (_entireTroveDebt <= _LUSDInStabPool) {\n            V.collGasCompensation = _getCollGasCompensation(_entireTroveColl);\n            V.LUSDGasCompensation = LUSD_GAS_COMPENSATION;\n\n            V.debtToOffset = _entireTroveDebt;\n            V.collToSendToSP = _entireTroveColl.sub(V.collGasCompensation);\n            V.debtToRedistribute = 0;\n            V.collToRedistribute = 0;\n\n            emit TroveLiquidated(_borrower, _entireTroveDebt, _entireTroveColl, TroveManagerOperation.liquidateInRecoveryMode);\n        }\n        /* \n        * When trove's debt is greater than the Stability Pool, perform a partial liquidation: offset as much as possible,\n        * and do not redistribute the remainder. The trove remains active, with a reduced collateral and debt.\n        *\n        * ETH gas compensation is based on and drawn from the collateral fraction that corresponds to the partial offset. \n        * LUSD gas compensation is left untouched. \n        *\n        * Since ETH gas comp is drawn purely from the *liquidated* portion, the trove is left with the same ICR as before the \n        * liquidation.\n        */\n        else if (_entireTroveDebt > _LUSDInStabPool) {\n            // Remaining debt in the trove is lower-bounded by the trove's gas compensation\n            V.partialNewDebt = LiquityMath._max(_entireTroveDebt.sub(_LUSDInStabPool), LUSD_GAS_COMPENSATION);\n          \n            V.debtToOffset = _entireTroveDebt.sub(V.partialNewDebt);\n\n            uint collFraction = _entireTroveColl.mul(V.debtToOffset).div(_entireTroveDebt);\n            V.collGasCompensation = _getCollGasCompensation(collFraction);\n          \n            V.LUSDGasCompensation = 0;  // LUSD gas compensation remains untouched\n\n            V.collToSendToSP = collFraction.sub(V.collGasCompensation);\n            V.collToRedistribute = 0;\n            V.debtToRedistribute = 0;\n\n            V.partialAddr = _borrower;\n            V.partialNewColl = _entireTroveColl.sub(collFraction);\n\n            // Get the partial trove's neighbours, so we can re-insert it later to the same position\n            V.partialUpperHint = sortedTroves.getPrev(_borrower);  \n            V.partialLowerHint = sortedTroves.getNext(_borrower);\n        }\n    }\n\n    /* \n    * Liquidate a sequence of troves. Closes a maximum number of n under-collateralized Troves,\n    * starting from the one with the lowest collateral ratio in the system, and moving upwards\n    */\n    function liquidateTroves(uint _n) external override {\n        LocalVariables_OuterLiquidationFunction memory L;\n\n        LiquidationTotals memory T;\n\n        L.price = priceFeed.getPrice();\n        L.LUSDInStabPool = stabilityPool.getTotalLUSDDeposits();\n        L.recoveryModeAtStart = checkRecoveryMode();\n\n        // Perform the appropriate liquidation sequence - tally the values, and obtain their totals\n        if (L.recoveryModeAtStart == true) {\n            T = _getTotalsFromLiquidateTrovesSequence_RecoveryMode(L.price, L.LUSDInStabPool, _n);\n        } else if (L.recoveryModeAtStart == false) {\n            T = _getTotalsFromLiquidateTrovesSequence_NormalMode(L.price, L.LUSDInStabPool, _n);\n        }\n\n        // Move liquidated ETH and LUSD to the appropriate pools\n        stabilityPool.offset(T.totalDebtToOffset, T.totalCollToSendToSP);\n        _redistributeDebtAndColl(T.totalDebtToRedistribute, T.totalCollToRedistribute);\n\n        // Update system snapshots and the final partially liquidated trove, if there is one\n        _updateSystemSnapshots_excludeCollRemainder(T.partialNewColl.add(T.totalCollGasCompensation));\n        _updatePartiallyLiquidatedTrove(T.partialAddr, T.partialNewDebt, T.partialNewColl, T.partialUpperHint, T. partialLowerHint, L.price);\n\n        L.liquidatedDebt = T.totalDebtInSequence.sub(T.partialNewDebt);\n        L.liquidatedColl = T.totalCollInSequence.sub(T.totalCollGasCompensation).sub(T.partialNewColl);\n        emit Liquidation(L.liquidatedDebt, L.liquidatedColl, T.totalCollGasCompensation, T.totalLUSDGasCompensation);\n\n        // Send gas compensation to caller\n        _sendGasCompensation(msg.sender, T.totalLUSDGasCompensation, T.totalCollGasCompensation);\n    }\n\n    /*\n    * This function is used when the liquidateTroves sequence starts during Recovery Mode. However, it\n    * handle the case where the system *leaves* Recovery Mode, part way through the liquidation sequence\n    */\n    function _getTotalsFromLiquidateTrovesSequence_RecoveryMode\n    (\n        uint _price,\n        uint _LUSDInStabPool,\n        uint _n\n    )\n        internal\n        returns(LiquidationTotals memory T)\n    {\n        LocalVariables_LiquidationSequence memory L;\n        LiquidationValues memory V;\n\n        L.remainingLUSDInStabPool = _LUSDInStabPool;\n        L.backToNormalMode = false;\n        L.entireSystemDebt = activePool.getLUSDDebt().add(defaultPool.getLUSDDebt());\n        L.entireSystemColl = activePool.getETH().add(defaultPool.getETH());\n\n        L.i = 0;\n        while (L.i < _n) {\n            L.user = sortedTroves.getLast();\n            L.ICR = getCurrentICR(L.user, _price);\n\n            if (L.backToNormalMode == false) {\n                // Break the loop if ICR is greater than MCR and Stability Pool is empty\n                if (L.ICR >= MCR && L.remainingLUSDInStabPool == 0) { break; }\n\n                uint TCR = LiquityMath._computeCR(L.entireSystemColl, L.entireSystemDebt, _price);\n        \n                V = _liquidateRecoveryMode(L.user, L.ICR, L.remainingLUSDInStabPool, TCR);\n\n                // Update aggregate trackers\n                L.remainingLUSDInStabPool = L.remainingLUSDInStabPool.sub(V.debtToOffset);\n                L.entireSystemDebt = L.entireSystemDebt.sub(V.debtToOffset);\n                L.entireSystemColl = L.entireSystemColl.sub(V.collToSendToSP);\n\n                // Add liquidation values to their respective running totals\n                T = _addLiquidationValuesToTotals(T, V);\n\n                // Break the loop if it was a partial liquidation\n                if (V.partialAddr != address(0)) {break;}\n\n                L.backToNormalMode = !_checkPotentialRecoveryMode(L.entireSystemColl, L.entireSystemDebt, _price);\n            }\n            else if (L.backToNormalMode == true && L.ICR < MCR) {\n                V = _liquidateNormalMode(L.user, L.remainingLUSDInStabPool);\n\n                L.remainingLUSDInStabPool = L.remainingLUSDInStabPool.sub(V.debtToOffset);\n\n                // Add liquidation values to their respective running totals\n                T = _addLiquidationValuesToTotals(T, V);\n\n            }  else break;  // break if the loop reaches a Trove with ICR >= MCR\n\n            // Break the loop if it reaches the first Trove in the sorted list\n            if (L.user == sortedTroves.getFirst()) { break; }\n\n            L.i++;\n        }\n    }\n\n    function _getTotalsFromLiquidateTrovesSequence_NormalMode\n    (\n        uint _price,\n        uint _LUSDInStabPool,\n        uint _n\n    )\n        internal\n        returns(LiquidationTotals memory T)\n    {\n        LocalVariables_LiquidationSequence memory L;\n        LiquidationValues memory V;\n\n        L.remainingLUSDInStabPool = _LUSDInStabPool;\n\n        L.i = 0;\n        while (L.i < _n) {\n            L.user = sortedTroves.getLast();\n            L.ICR = getCurrentICR(L.user, _price);\n\n            if (L.ICR < MCR) {\n                V = _liquidateNormalMode(L.user, L.remainingLUSDInStabPool);\n\n                L.remainingLUSDInStabPool = L.remainingLUSDInStabPool.sub(V.debtToOffset);\n\n                // Add liquidation values to their respective running totals\n                T = _addLiquidationValuesToTotals(T, V);\n\n            } else break;  // break if the loop reaches a Trove with ICR >= MCR\n\n            // Break the loop if it reaches the first Trove in the sorted list\n            if (L.user == sortedTroves.getFirst()) { break; }\n            L.i++;\n        }\n    }\n\n    /* \n    * Attempt to liquidate a custom list of troves provided by the caller. The liquidation sequence stops if\n    * a partial liquidation is performed, so it's up to the caller to order the troves in the _troveArray parameter.\n    */\n    function batchLiquidateTroves(address[] memory _troveArray) public override {\n        require(_troveArray.length != 0, \"TroveManager: Calldata address array must not be empty\");\n\n        LocalVariables_OuterLiquidationFunction memory L;\n        LiquidationTotals memory T;\n\n        L.price = priceFeed.getPrice();\n        L.LUSDInStabPool = stabilityPool.getTotalLUSDDeposits();\n        L.recoveryModeAtStart = checkRecoveryMode();\n\n        // Perform the appropriate liquidation sequence - tally values and obtain their totals.\n        if (L.recoveryModeAtStart == true) {\n           T = _getTotalFromBatchLiquidate_RecoveryMode(L.price, L.LUSDInStabPool, _troveArray);\n        } else if (L.recoveryModeAtStart == false) {\n            T = _getTotalsFromBatchLiquidate_NormalMode(L.price, L.LUSDInStabPool, _troveArray);\n        }\n\n        // Move liquidated ETH and LUSD to the appropriate pools\n        stabilityPool.offset(T.totalDebtToOffset, T.totalCollToSendToSP);\n        _redistributeDebtAndColl(T.totalDebtToRedistribute, T.totalCollToRedistribute);\n\n        // Update system snapshots and the final partially liquidated trove, if there is one\n        _updateSystemSnapshots_excludeCollRemainder(T.partialNewColl.add(T.totalCollGasCompensation));\n        _updatePartiallyLiquidatedTrove(T.partialAddr, T.partialNewDebt, T.partialNewColl, T.partialUpperHint, T. partialLowerHint, L.price);\n\n        L.liquidatedDebt = T.totalDebtInSequence.sub(T.partialNewDebt);\n        L.liquidatedColl = T.totalCollInSequence.sub(T.totalCollGasCompensation).sub(T.partialNewColl);\n        emit Liquidation(L.liquidatedDebt, L.liquidatedColl, T.totalCollGasCompensation, T.totalLUSDGasCompensation);\n\n        // Send gas compensation to caller\n        _sendGasCompensation(msg.sender, T.totalLUSDGasCompensation, T.totalCollGasCompensation);\n    }\n\n    /* \n    * This function is used when the batch liquidation sequence starts during Recovery Mode. However, it\n    * handle the case where the system *leaves* Recovery Mode, part way through the liquidation sequence\n    */\n    function _getTotalFromBatchLiquidate_RecoveryMode\n    (\n        uint _price,\n        uint _LUSDInStabPool,\n        address[] memory _troveArray)\n        internal\n        returns(LiquidationTotals memory T)\n    {\n        LocalVariables_LiquidationSequence memory L;\n        LiquidationValues memory V;\n\n        L.remainingLUSDInStabPool = _LUSDInStabPool;\n        L.backToNormalMode = false;\n        L.entireSystemDebt = activePool.getLUSDDebt().add(defaultPool.getLUSDDebt());\n        L.entireSystemColl = activePool.getETH().add(defaultPool.getETH());\n\n        L.i = 0;\n        for (L.i = 0; L.i < _troveArray.length; L.i++) {\n            L.user = _troveArray[L.i];\n            L.ICR = getCurrentICR(L.user, _price);\n\n            if (L.backToNormalMode == false) {\n\n                // Skip this trove if ICR is greater than MCR and Stability Pool is empty\n                if (L.ICR >= MCR && L.remainingLUSDInStabPool == 0) { continue; }\n\n                uint TCR = LiquityMath._computeCR(L.entireSystemColl, L.entireSystemDebt, _price);\n\n                V = _liquidateRecoveryMode(L.user, L.ICR, L.remainingLUSDInStabPool, TCR);\n\n                // Update aggregate trackers\n                L.remainingLUSDInStabPool = L.remainingLUSDInStabPool.sub(V.debtToOffset);\n                L.entireSystemDebt = L.entireSystemDebt.sub(V.debtToOffset);\n                L.entireSystemColl = L.entireSystemColl.sub(V.collToSendToSP);\n\n                // Add liquidation values to their respective running totals\n                T = _addLiquidationValuesToTotals(T, V);\n\n                // Break the loop if it was a partial liquidation\n                if (V.partialAddr != address(0)) { break; }\n\n                L.backToNormalMode = !_checkPotentialRecoveryMode(L.entireSystemColl, L.entireSystemDebt, _price);\n            }\n\n            else if (L.backToNormalMode == true && L.ICR < MCR) {\n                V = _liquidateNormalMode(L.user, L.remainingLUSDInStabPool);\n                L.remainingLUSDInStabPool = L.remainingLUSDInStabPool.sub(V.debtToOffset);\n\n                // Add liquidation values to their respective running totals\n                T = _addLiquidationValuesToTotals(T, V);\n            }\n        }\n    }\n\n    function _getTotalsFromBatchLiquidate_NormalMode\n    (\n        uint _price,\n        uint _LUSDInStabPool,\n        address[] memory _troveArray\n    )\n        internal\n        returns(LiquidationTotals memory T)\n    {\n        LocalVariables_LiquidationSequence memory L;\n        LiquidationValues memory V;\n\n        L.remainingLUSDInStabPool = _LUSDInStabPool;\n\n        for (L.i = 0; L.i < _troveArray.length; L.i++) {\n            L.user = _troveArray[L.i];\n            L.ICR = getCurrentICR(L.user, _price);\n\n            if (L.ICR < MCR) {\n                V = _liquidateNormalMode(L.user, L.remainingLUSDInStabPool);\n                L.remainingLUSDInStabPool = L.remainingLUSDInStabPool.sub(V.debtToOffset);\n\n                // Add liquidation values to their respective running totals\n                T = _addLiquidationValuesToTotals(T, V);\n            }\n        }\n    }\n\n    // --- Liquidation helper functions ---\n\n    function _addLiquidationValuesToTotals(LiquidationTotals memory T1, LiquidationValues memory V)\n    internal pure returns(LiquidationTotals memory T2) {\n\n        // Tally all the values with their respective running totals\n        T2.totalCollGasCompensation = T1.totalCollGasCompensation.add(V.collGasCompensation);\n        T2.totalLUSDGasCompensation = T1.totalLUSDGasCompensation.add(V.LUSDGasCompensation);\n        T2.totalDebtInSequence = T1.totalDebtInSequence.add(V.entireTroveDebt);\n        T2.totalCollInSequence = T1.totalCollInSequence.add(V.entireTroveColl);\n        T2.totalDebtToOffset = T1.totalDebtToOffset.add(V.debtToOffset);\n        T2.totalCollToSendToSP = T1.totalCollToSendToSP.add(V.collToSendToSP);\n        T2.totalDebtToRedistribute = T1.totalDebtToRedistribute.add(V.debtToRedistribute);\n        T2.totalCollToRedistribute = T1.totalCollToRedistribute.add(V.collToRedistribute);\n\n        // Assign the address of the partially liquidated trove, and its new debt and coll values\n        T2.partialAddr = V.partialAddr;\n        T2.partialNewDebt = V.partialNewDebt;\n        T2.partialNewColl = V.partialNewColl;\n        T2.partialUpperHint = V.partialUpperHint;\n        T2.partialLowerHint = V.partialLowerHint;\n\n        return T2;\n    }\n\n    // Update the properties of the partially liquidated trove, and insert it back to the list\n    function _updatePartiallyLiquidatedTrove\n    (\n        address _borrower, \n        uint _newDebt, \n        uint _newColl, \n        address _upperHint,\n        address _lowerHint,\n        uint _price\n    ) \n        internal \n    {\n        if ( _borrower == address(0)) { return; }\n\n        Troves[_borrower].debt = _newDebt;\n        Troves[_borrower].coll = _newColl;\n        Troves[_borrower].status = Status.active;\n\n        _updateTroveRewardSnapshots(_borrower);\n        _updateStakeAndTotalStakes(_borrower);\n\n        uint ICR = getCurrentICR(_borrower, _price);\n\n        /* \n        * Insert to sorted list and add to TroveOwners array. The partially liquidated trove has the same\n        * ICR as it did before the liquidation, so insertion is O(1): in principle, its ICR does not change.\n        * In practice, due to rounding error, its ICR can change slightly - so re-insert, with its previous neighbours\n        * as hints.\n        */\n        sortedTroves.insert(_borrower, ICR, _price, _upperHint, _lowerHint);\n        _addTroveOwnerToArray(_borrower);\n        emit TroveUpdated(_borrower, _newDebt, _newColl, Troves[_borrower].stake, TroveManagerOperation.partiallyLiquidateInRecoveryMode);\n    }\n\n    function _sendGasCompensation(address _liquidator, uint _LUSD, uint _ETH) internal {\n        if (_LUSD > 0) {\n            lusdToken.returnFromPool(GAS_POOL_ADDRESS, _liquidator, _LUSD);\n        }\n\n        if (_ETH > 0) {\n            activePool.sendETH(_liquidator, _ETH);\n        }\n    }\n\n    // Move a Trove's pending debt and collateral rewards from distributions, from the Default Pool to the Active Pool\n    function _movePendingTroveRewardsToActivePool(uint _LUSD, uint _ETH) internal {\n        defaultPool.decreaseLUSDDebt(_LUSD);\n        activePool.increaseLUSDDebt(_LUSD);\n        defaultPool.sendETH(address(activePool), _ETH);\n    }\n\n    // --- Redemption functions ---\n\n    // Redeem as much collateral as possible from _borrower's Trove in exchange for LUSD up to _maxLUSDamount\n    function _redeemCollateralFromTrove(\n        address _borrower,\n        uint _maxLUSDamount,\n        uint _price,\n        address _partialRedemptionHint,\n        uint _partialRedemptionHintICR\n    )\n        internal returns (SingleRedemptionValues memory V)\n    {\n        // Determine the remaining amount (lot) to be redeemed, capped by the entire debt of the Trove minus the gas compensation\n        V.LUSDLot = LiquityMath._min(_maxLUSDamount, Troves[_borrower].debt.sub(LUSD_GAS_COMPENSATION));\n\n        // Get the ETHLot of equivalent value in USD\n        V.ETHLot = V.LUSDLot.mul(1e18).div(_price);\n\n        // Decrease the debt and collateral of the current Trove according to the LUSD lot and corresponding ETH to send\n        uint newDebt = (Troves[_borrower].debt).sub(V.LUSDLot);\n        uint newColl = (Troves[_borrower].coll).sub(V.ETHLot);\n\n        if (newDebt == LUSD_GAS_COMPENSATION) {\n            // No debt left in the Trove (except for the gas compensation), therefore the trove gets closed\n            _removeStake(_borrower);\n            _closeTrove(_borrower);\n            _redeemCloseTrove(_borrower, LUSD_GAS_COMPENSATION, newColl);\n\n        } else {\n            uint newICR = LiquityMath._computeCR(newColl, newDebt, _price);\n\n            // Check if the provided hint is fresh. If not, we bail since trying to reinsert without a good hint will almost\n            // certainly result in running out of gas.\n            if (newICR != _partialRedemptionHintICR) {\n                V.LUSDLot = 0;\n                V.ETHLot = 0;\n                return V;\n            }\n\n            sortedTroves.reInsert(_borrower, newICR, _price, _partialRedemptionHint, _partialRedemptionHint);\n\n            Troves[_borrower].debt = newDebt;\n            Troves[_borrower].coll = newColl;\n            _updateStakeAndTotalStakes(_borrower);\n        }\n        emit TroveUpdated(\n            _borrower,\n            newDebt, newColl,\n            Troves[_borrower].stake,\n            TroveManagerOperation.redeemCollateral\n        );\n        return V;\n    }\n\n    /* \n    * Called when a full redemption occurs, and closes the trove.\n    * The redeemer swaps (debt - 10) LUSD for (debt - 10) worth of ETH, so the 10 LUSD gas compensation left corresponds to the remaining debt.\n    * In order to close the trove, the 10 LUSD gas compensation is burned, and 10 debt is removed from the active pool.\n    * The debt recorded on the trove's struct is zero'd elswhere, in _closeTrove.\n    * Any surplus ETH left in the trove, is sent to the Coll surplus pool, and can be later claimed by the borrower.\n    */ \n    function _redeemCloseTrove(address _borrower, uint _LUSD, uint _ETH) internal {\n        lusdToken.burn(GAS_POOL_ADDRESS, _LUSD);\n        // Update Active Pool LUSD, and send ETH to account\n        activePool.decreaseLUSDDebt(_LUSD);\n\n        // send ETH from Active Pool to CollSurplus Pool\n        collSurplusPool.accountSurplus(_borrower, _ETH);\n        activePool.sendETH(address(collSurplusPool), _ETH);\n    }\n\n    function _isValidFirstRedemptionHint(address _firstRedemptionHint, uint _price) internal view returns (bool) {\n        if (_firstRedemptionHint == address(0) ||\n            !sortedTroves.contains(_firstRedemptionHint) ||\n            getCurrentICR(_firstRedemptionHint, _price) < MCR\n        ) {\n            return false;\n        }\n\n        address nextTrove = sortedTroves.getNext(_firstRedemptionHint);\n        return nextTrove == address(0) || getCurrentICR(nextTrove, _price) < MCR;\n    }\n\n    /* Send _LUSDamount LUSD to the system and redeem the corresponding amount of collateral from as many Troves as are needed to fill the redemption\n    * request.  Applies pending rewards to a Trove before reducing its debt and coll.\n    *\n    * Note that if _amount is very large, this function can run out of gas, specially if traversed troves are small. This can be easily avoided by \n    * splitting the total _amount in appropriate chunks and calling the function multiple times.\n    * \n    * Param `_maxIterations` can also be provided, so the loop through Troves is capped (if its zero, it will be ignored).This makes it easier to \n    * avoid OOG for the frontend, as only knowing approximately the average cost of an iteration is enough, without needing to know the topology \n    * of the trove list. It also avoids the need to set the cap in stone in the contract, nor doing gas calculations, as both gas price and opcode \n    * costs can vary.\n    * \n    * All Troves that are redeemed from -- with the likely exception of the last one -- will end up with no debt left, therefore they will be closed.\n    * If the last Trove does have some remaining debt, it has a finite ICR, and the reinsertion could be anywhere in the list, therefore it requires a hint. \n    * A frontend should use getRedemptionHints() to calculate what the ICR of this Trove will be after redemption, and pass a hint for its position \n    * in the sortedTroves list along with the ICR value that the hint was found for.\n    * \n    * If another transaction modifies the list between calling getRedemptionHints() and passing the hints to redeemCollateral(), it\n    * is very likely that the last (partially) redeemed Trove would end up with a different ICR than what the hint is for. In this case the\n    * redemption will stop after the last completely redeemed Trove and the sender will keep the remaining LUSD amount, which they can attempt\n    * to redeem later.\n    */\n    function redeemCollateral(\n        uint _LUSDamount,\n        address _firstRedemptionHint,\n        address _partialRedemptionHint,\n        uint _partialRedemptionHintICR,\n        uint _maxIterations\n    )\n        external\n        override\n    {\n        uint activeDebt = activePool.getLUSDDebt();\n        uint defaultedDebt = defaultPool.getLUSDDebt();\n\n        RedemptionTotals memory T;\n\n        _requireAmountGreaterThanZero(_LUSDamount);\n        _requireLUSDBalanceCoversRedemption(msg.sender, _LUSDamount);\n\n        // Confirm redeemer's balance is less than total systemic debt\n        assert(lusdToken.balanceOf(msg.sender) <= (activeDebt.add(defaultedDebt)));\n\n        uint remainingLUSD = _LUSDamount;\n        uint price = priceFeed.getPrice();\n        address currentBorrower;\n\n        if (_isValidFirstRedemptionHint(_firstRedemptionHint, price)) {\n            currentBorrower = _firstRedemptionHint;\n        } else {\n            currentBorrower = sortedTroves.getLast();\n            // Find the first trove with ICR >= MCR\n            // SWC-104-Unchecked Call Return Value: L920\n            while (currentBorrower != address(0) && getCurrentICR(currentBorrower, price) < MCR) {\n                currentBorrower = sortedTroves.getPrev(currentBorrower);\n            }\n        }\n\n        // Loop through the Troves starting from the one with lowest collateral ratio until _amount of LUSD is exchanged for collateral\n        if (_maxIterations == 0) { _maxIterations = uint(-1); }\n        while (currentBorrower != address(0) && remainingLUSD > 0 && _maxIterations > 0) {\n            _maxIterations--;\n            // Save the address of the Trove preceding the current one, before potentially modifying the list\n            address nextUserToCheck = sortedTroves.getPrev(currentBorrower);\n\n            _applyPendingRewards(currentBorrower);\n            SingleRedemptionValues memory V = _redeemCollateralFromTrove(\n                currentBorrower,\n                remainingLUSD,\n                price,\n                _partialRedemptionHint,\n                _partialRedemptionHintICR\n            );\n\n            if (V.LUSDLot == 0) break; // Partial redemption hint got out-of-date, therefore we could not redeem from the last Trove\n\n            T.totalLUSDToRedeem  = T.totalLUSDToRedeem.add(V.LUSDLot);\n            T.totalETHDrawn = T.totalETHDrawn.add(V.ETHLot);\n\n            remainingLUSD = remainingLUSD.sub(V.LUSDLot);\n            currentBorrower = nextUserToCheck;\n        }\n\n        // Decay the baseRate due to time passed, and then increase it according to the size of this redemption\n        _updateBaseRateFromRedemption(T.totalETHDrawn, price);\n\n        // Calculate the ETH fee and send it to the LQTY staking contract\n        T.ETHFee = _getRedemptionFee(T.totalETHDrawn);\n        activePool.sendETH(lqtyStakingAddress, T.ETHFee);\n        lqtyStaking.increaseF_ETH(T.ETHFee);\n\n        T.ETHToSendToRedeemer = T.totalETHDrawn.sub(T.ETHFee);\n\n        // Burn the total LUSD that is cancelled with debt, and send the redeemed ETH to msg.sender\n        _activePoolRedeemCollateral(msg.sender, T.totalLUSDToRedeem, T.ETHToSendToRedeemer);\n\n        emit Redemption(_LUSDamount, T.totalLUSDToRedeem, T.totalETHDrawn, T.ETHFee);\n    }\n\n    // Burn the received LUSD, transfer the redeemed ETH to _redeemer and updates the Active Pool\n    function _activePoolRedeemCollateral(address _redeemer, uint _LUSD, uint _ETH) internal {\n        // Update Active Pool LUSD, and send ETH to account\n        lusdToken.burn(_redeemer, _LUSD);\n        activePool.decreaseLUSDDebt(_LUSD);\n\n        activePool.sendETH(_redeemer, _ETH);\n    }\n\n    // --- Helper functions ---\n\n\n    // Return the current collateral ratio (ICR) of a given Trove. Takes a trove's pending coll and debt rewards from redistributions into account.\n    function getCurrentICR(address _borrower, uint _price) public view override returns (uint) {\n        uint pendingETHReward = getPendingETHReward(_borrower);\n        uint pendingLUSDDebtReward = getPendingLUSDDebtReward(_borrower);\n\n        uint currentETH = Troves[_borrower].coll.add(pendingETHReward);\n        uint currentLUSDDebt = Troves[_borrower].debt.add(pendingLUSDDebtReward);\n\n        uint ICR = LiquityMath._computeCR(currentETH, currentLUSDDebt, _price);\n        return ICR;\n    }\n\n    function applyPendingRewards(address _borrower) external override {\n        _requireCallerIsBorrowerOperations();\n        return _applyPendingRewards(_borrower);\n    }\n\n    // Add the borrowers's coll and debt rewards earned from redistributions, to their Trove\n    function _applyPendingRewards(address _borrower) internal {\n        if (hasPendingRewards(_borrower)) {\n            _requireTroveisActive(_borrower);\n\n            // Compute pending rewards\n            uint pendingETHReward = getPendingETHReward(_borrower);\n            uint pendingLUSDDebtReward = getPendingLUSDDebtReward(_borrower);\n\n            // Apply pending rewards to trove's state\n            Troves[_borrower].coll = Troves[_borrower].coll.add(pendingETHReward);\n            Troves[_borrower].debt = Troves[_borrower].debt.add(pendingLUSDDebtReward);\n\n            _updateTroveRewardSnapshots(_borrower);\n\n            // Transfer from DefaultPool to ActivePool\n            _movePendingTroveRewardsToActivePool(pendingLUSDDebtReward, pendingETHReward);\n\n            emit TroveUpdated(\n                _borrower, \n                Troves[_borrower].debt, \n                Troves[_borrower].coll, \n                Troves[_borrower].stake, \n                TroveManagerOperation.applyPendingRewards\n            );\n        }\n    }\n\n    // Update borrower's snapshots of L_ETH and L_LUSDDebt to reflect the current values\n    function updateTroveRewardSnapshots(address _borrower) external override {\n        _requireCallerIsBorrowerOperations();\n       return _updateTroveRewardSnapshots(_borrower);\n    }\n\n    function _updateTroveRewardSnapshots(address _borrower) internal {\n        rewardSnapshots[_borrower].ETH = L_ETH;\n        rewardSnapshots[_borrower].LUSDDebt = L_LUSDDebt;\n    }\n\n    // Get the borrower's pending accumulated ETH reward, earned by their stake\n    function getPendingETHReward(address _borrower) public view override returns (uint) {\n        uint snapshotETH = rewardSnapshots[_borrower].ETH;\n        uint rewardPerUnitStaked = L_ETH.sub(snapshotETH);\n\n        if ( rewardPerUnitStaked == 0 ) { return 0; }\n\n        uint stake = Troves[_borrower].stake;\n\n        uint pendingETHReward = stake.mul(rewardPerUnitStaked).div(1e18);\n\n        return pendingETHReward;\n    }\n\n     // Get the borrower's pending accumulated LUSD reward, earned by their stake\n    function getPendingLUSDDebtReward(address _borrower) public view override returns (uint) {\n        uint snapshotLUSDDebt = rewardSnapshots[_borrower].LUSDDebt;\n        uint rewardPerUnitStaked = L_LUSDDebt.sub(snapshotLUSDDebt);\n\n        if ( rewardPerUnitStaked == 0 ) { return 0; }\n\n        uint stake =  Troves[_borrower].stake;\n\n        uint pendingLUSDDebtReward = stake.mul(rewardPerUnitStaked).div(1e18);\n\n        return pendingLUSDDebtReward;\n    }\n\n    function hasPendingRewards(address _borrower) public view override returns (bool) {\n        /* \n        * A Trove has pending rewards if its snapshot is less than the current rewards per-unit-staked sum:\n        * this indicates that rewards have occured since the snapshot was made, and the user therefore has\n        * pending rewards \n        */\n        return (rewardSnapshots[_borrower].ETH < L_ETH);\n    }\n\n    // Return the Troves entire debt and coll, including pending rewards from redistributions.\n    function getEntireDebtAndColl(\n        address _borrower\n    )\n        public\n        view\n        override\n        returns (uint debt, uint coll, uint pendingLUSDDebtReward, uint pendingETHReward)\n    {\n        debt = Troves[_borrower].debt;\n        coll = Troves[_borrower].coll;\n\n        pendingLUSDDebtReward = getPendingLUSDDebtReward(_borrower);\n        pendingETHReward = getPendingETHReward(_borrower);\n\n        debt = debt.add(pendingLUSDDebtReward);\n        coll = coll.add(pendingETHReward);\n    }\n\n    function removeStake(address _borrower) external override {\n        _requireCallerIsBorrowerOperations();\n        return _removeStake(_borrower);\n    }\n\n    // Remove borrower's stake from the totalStakes sum, and set their stake to 0\n    function _removeStake(address _borrower) internal {\n        uint stake = Troves[_borrower].stake;\n        totalStakes = totalStakes.sub(stake);\n        Troves[_borrower].stake = 0;\n    }\n\n    function updateStakeAndTotalStakes(address _borrower) external override returns (uint) {\n        _requireCallerIsBorrowerOperations();\n        return _updateStakeAndTotalStakes(_borrower);\n    }\n\n    // Update borrower's stake based on their latest collateral value\n    function _updateStakeAndTotalStakes(address _borrower) internal returns (uint) {\n        uint newStake = _computeNewStake(Troves[_borrower].coll);\n        uint oldStake = Troves[_borrower].stake;\n        Troves[_borrower].stake = newStake;\n        totalStakes = totalStakes.sub(oldStake).add(newStake);\n\n        return newStake;\n    }\n\n    // Calculate a new stake based on the snapshots of the totalStakes and totalCollateral taken at the last liquidation\n    function _computeNewStake(uint _coll) internal view returns (uint) {\n        uint stake;\n        if (totalCollateralSnapshot == 0) {\n            stake = _coll;\n        } else {\n            /*  \n            * The following assert() holds true because:\n            * - The system always contains >= 1 trove \n            * - When we close or liquidate a trove, we redistribute the pending rewards, so if all troves were closed/liquidated, \n            * rewards wouldve been emptied and totalCollateralSnapshot would be zero too.\n            */\n            assert(totalStakesSnapshot > 0);\n            stake = _coll.mul(totalStakesSnapshot).div(totalCollateralSnapshot);\n        }\n        return stake;\n    }\n\n    function _redistributeDebtAndColl(uint _debt, uint _coll) internal {\n        if (_debt == 0) { return; }\n\n        if (totalStakes > 0) {\n            /* \n            * Add distributed coll and debt rewards-per-unit-staked to the running totals.\n            * Division uses a \"feedback\" error correction, to keep the cumulative error in\n            * the  L_ETH and L_LUSDDebt state variables low. \n            */\n            uint ETHNumerator = _coll.mul(1e18).add(lastETHError_Redistribution);\n            uint LUSDDebtNumerator = _debt.mul(1e18).add(lastLUSDDebtError_Redistribution);\n\n            uint ETHRewardPerUnitStaked = ETHNumerator.div(totalStakes);\n            uint LUSDDebtRewardPerUnitStaked = LUSDDebtNumerator.div(totalStakes);\n\n            lastETHError_Redistribution = ETHNumerator.sub(ETHRewardPerUnitStaked.mul(totalStakes));\n            lastLUSDDebtError_Redistribution = LUSDDebtNumerator.sub(LUSDDebtRewardPerUnitStaked.mul(totalStakes));\n\n            L_ETH = L_ETH.add(ETHRewardPerUnitStaked);\n            L_LUSDDebt = L_LUSDDebt.add(LUSDDebtRewardPerUnitStaked);\n        }\n\n        // Transfer coll and debt from ActivePool to DefaultPool\n        activePool.decreaseLUSDDebt(_debt);\n        defaultPool.increaseLUSDDebt(_debt);\n        activePool.sendETH(address(defaultPool), _coll);\n    }\n\n    function closeTrove(address _borrower) external override {\n        _requireCallerIsBorrowerOperations();\n        return _closeTrove(_borrower);\n    }\n\n    function _closeTrove(address _borrower) internal {\n        uint TroveOwnersArrayLength = TroveOwners.length;\n        _requireMoreThanOneTroveInSystem(TroveOwnersArrayLength);\n\n        Troves[_borrower].status = Status.closed;\n        Troves[_borrower].coll = 0;\n        Troves[_borrower].debt = 0;\n\n        rewardSnapshots[_borrower].ETH = 0;\n        rewardSnapshots[_borrower].LUSDDebt = 0;\n\n        _removeTroveOwner(_borrower, TroveOwnersArrayLength);\n        sortedTroves.remove(_borrower);\n    }\n\n    /* \n    * Updates snapshots of system total stakes and total collateral, excluding a given collateral remainder from the calculation. \n    * Used in a liquidation sequence.\n    *\n    * The calculation excludes two portions of collateral that are in the ActivePool: \n    *\n    * 1) the total ETH gas compensation from the liquidation sequence\n    * 2) The remaining collateral in a partially liquidated trove (if one occurred)\n    *\n    * The ETH as compensation must be excluded as it is always sent out at the very end of the liquidation sequence.\n    *\n    * The partially liquidated trove's remaining collateral stays in the ActivePool, but it is excluded here so the system \n    * can take snapshots before the partially liquidated trove's stake is updated (based on these snapshots). This ensures\n    * the partial's new stake doesn't double-count its own remaining collateral.\n    *\n    */\n    function _updateSystemSnapshots_excludeCollRemainder(uint _collRemainder) internal {\n        totalStakesSnapshot = totalStakes;\n\n        uint activeColl = activePool.getETH();\n        uint liquidatedColl = defaultPool.getETH();\n        totalCollateralSnapshot = activeColl.sub(_collRemainder).add(liquidatedColl);\n    }\n\n    // Push the owner's address to the Trove owners list, and record the corresponding array index on the Trove struct\n    function addTroveOwnerToArray(address _borrower) external override returns (uint index) {\n        _requireCallerIsBorrowerOperations();\n        return _addTroveOwnerToArray(_borrower);\n    }\n\n    function _addTroveOwnerToArray(address _borrower) internal returns (uint128 index) {\n        require(TroveOwners.length < 2**128 - 1, \"TroveManager: TroveOwners array has maximum size of 2^128 - 1\");\n\n        // Push the Troveowner to the array\n        TroveOwners.push(_borrower);\n\n        // Record the index of the new Troveowner on their Trove struct\n        index = uint128(TroveOwners.length.sub(1));\n        Troves[_borrower].arrayIndex = index;\n\n        return index;\n    }\n\n    /* \n    * Remove a Trove owner from the TroveOwners array, not preserving array order. Removing owner 'B' does the following:\n    * [A B C D E] => [A E C D], and updates E's Trove struct to point to its new array index. \n    */\n    function _removeTroveOwner(address _borrower, uint TroveOwnersArrayLength) internal {\n        require(Troves[_borrower].status == Status.closed, \"TroveManager: Trove is still active\");\n\n        uint128 index = Troves[_borrower].arrayIndex;\n        uint length = TroveOwnersArrayLength;\n        uint idxLast = length.sub(1);\n\n        assert(index <= idxLast);\n\n        address addressToMove = TroveOwners[idxLast];\n\n        TroveOwners[index] = addressToMove;\n        Troves[addressToMove].arrayIndex = index;\n        TroveOwners.pop();\n    }\n\n    // --- Recovery Mode and TCR functions ---\n\n    function checkRecoveryMode() public view override returns (bool) {\n        uint TCR = getTCR();\n\n        if (TCR < CCR) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    // Check whether or not the system *would be* in Recovery Mode, given an ETH:USD price, and the entire system coll and debt.\n    function _checkPotentialRecoveryMode(\n        uint _entireSystemColl,\n        uint _entireSystemDebt,\n        uint _price\n    )\n        internal\n        pure\n    returns (bool)\n    {\n        uint TCR = LiquityMath._computeCR(_entireSystemColl, _entireSystemDebt, _price);\n        if (TCR < CCR) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n    // SWC-135-Code With No Effects: L1276-L1284\n    function getTCR() public view override returns (uint TCR) {\n        uint price = priceFeed.getPrice();\n        uint entireSystemColl = getEntireSystemColl();\n        uint entireSystemDebt = getEntireSystemDebt();\n\n        TCR = LiquityMath._computeCR(entireSystemColl, entireSystemDebt, price);\n\n        return TCR;\n    }\n    // SWC-135-Code With No Effects: L1286-L1291\n    function getEntireSystemColl() public view override returns (uint entireSystemColl) {\n        uint activeColl = activePool.getETH();\n        uint liquidatedColl = defaultPool.getETH();\n\n        return activeColl.add(liquidatedColl);\n    }\n\n    function getEntireSystemDebt() public view override returns (uint entireSystemDebt) {\n        uint activeDebt = activePool.getLUSDDebt();\n        uint closedDebt = defaultPool.getLUSDDebt();\n\n        return activeDebt.add(closedDebt);\n    }\n\n    // --- Redemption fee functions ---\n\n    /* \n    * This function has two impacts on the baseRate state variable:\n    * 1) decays the baseRate based on time passed since last redemption or LUSD borrowing operation.\n    * then,\n    * 2) increases the baseRate based on the amount redeemed, as a proportion of total supply\n    */\n    function _updateBaseRateFromRedemption(uint _ETHDrawn,  uint _price) internal returns (uint) {\n        uint decayedBaseRate = _calcDecayedBaseRate();\n\n        uint activeDebt = activePool.getLUSDDebt();\n        uint closedDebt = defaultPool.getLUSDDebt();\n        uint totalLUSDSupply = activeDebt.add(closedDebt);\n\n        /* Convert the drawn ETH back to LUSD at face value rate (1 LUSD:1 USD), in order to get\n        * the fraction of total supply that was redeemed at face value. */\n        uint redeemedLUSDFraction = _ETHDrawn.mul(_price).div(totalLUSDSupply);\n\n        uint newBaseRate = decayedBaseRate.add(redeemedLUSDFraction.div(BETA));\n\n        // Update the baseRate state variable\n        baseRate = newBaseRate < 1e18 ? newBaseRate : 1e18;  // cap baseRate at a maximum of 100%\n        assert(baseRate <= 1e18 && baseRate > 0); // Base rate is always non-zero after redemption\n\n        _updateLastFeeOpTime();\n\n        return baseRate;\n    }\n\n    function _getRedemptionFee(uint _ETHDrawn) internal view returns (uint) {\n       return baseRate.mul(_ETHDrawn).div(1e18);\n    }\n\n    // --- Borrowing fee functions ---\n\n    function getBorrowingFee(uint _LUSDDebt) external view override returns (uint) {\n        return _LUSDDebt.mul(baseRate).div(1e18);\n    }\n\n    // Updates the baseRate state variable based on time elapsed since the last redemption or LUSD borrowing operation.\n    function decayBaseRateFromBorrowing() external override {\n        _requireCallerIsBorrowerOperations();\n\n        baseRate = _calcDecayedBaseRate();\n        assert(baseRate <= 1e18);  // The baseRate can decay to 0\n\n        _updateLastFeeOpTime();\n    }\n\n    // --- Internal fee functions ---\n\n    // Update the last fee operation time only if time passed >= decay interval. This prevents base rate griefing.\n    function _updateLastFeeOpTime() internal {\n        uint timePassed = block.timestamp.sub(lastFeeOperationTime);\n\n        if (timePassed >= SECONDS_IN_ONE_MINUTE) {\n            lastFeeOperationTime = block.timestamp;\n        }\n    }\n\n    function _calcDecayedBaseRate() internal view returns (uint) {\n        uint minutesPassed = _minutesPassedSinceLastFeeOp();\n        uint decayFactor = LiquityMath._decPow(MINUTE_DECAY_FACTOR, minutesPassed);\n\n        return baseRate.mul(decayFactor).div(1e18);\n    }\n\n    function _minutesPassedSinceLastFeeOp() internal view returns (uint) {\n        return (block.timestamp.sub(lastFeeOperationTime)).div(SECONDS_IN_ONE_MINUTE);\n    }\n\n    // --- 'require' wrapper functions ---\n\n    function _requireCallerIsBorrowerOperations() internal view {\n        require(msg.sender == borrowerOperationsAddress, \"TroveManager: Caller is not the BorrowerOperations contract\");\n    }\n\n    function _requireTroveisActive(address _borrower) internal view {\n        require(Troves[_borrower].status == Status.active, \"TroveManager: Trove does not exist or is closed\");\n    }\n\n    function _requireLUSDBalanceCoversRedemption(address _redeemer, uint _amount) internal view {\n        require(lusdToken.balanceOf(_redeemer) >= _amount, \"TroveManager: Requested redemption amount must be <= user's LUSD token balance\");\n    }\n\n    function _requireMoreThanOneTroveInSystem(uint TroveOwnersArrayLength) internal view {\n        require (TroveOwnersArrayLength > 1 && sortedTroves.getSize() > 1, \"TroveManager: Only one trove in the system\");\n    }\n\n    function _requireAmountGreaterThanZero(uint _amount) internal pure {\n        require(_amount > 0, \"TroveManager: Amount must be greater than zero\");\n    }\n\n    // --- Trove property getters ---\n\n    function getTroveStatus(address _borrower) external view override returns (uint) {\n        return uint(Troves[_borrower].status);\n    }\n\n    function getTroveStake(address _borrower) external view override returns (uint) {\n        return Troves[_borrower].stake;\n    }\n\n    function getTroveDebt(address _borrower) external view override returns (uint) {\n        return Troves[_borrower].debt;\n    }\n\n    function getTroveColl(address _borrower) external view override returns (uint) {\n        return Troves[_borrower].coll;\n    }\n\n    // --- Trove property setters, called by BorrowerOperations ---\n\n    function setTroveStatus(address _borrower, uint _num) external override {\n        _requireCallerIsBorrowerOperations();\n        Troves[_borrower].status = Status(_num);\n    }\n\n    function increaseTroveColl(address _borrower, uint _collIncrease) external override returns (uint) {\n        _requireCallerIsBorrowerOperations();\n        uint newColl = Troves[_borrower].coll.add(_collIncrease);\n        Troves[_borrower].coll = newColl;\n        return newColl;\n    }\n\n    function decreaseTroveColl(address _borrower, uint _collDecrease) external override returns (uint) {\n        _requireCallerIsBorrowerOperations();\n        uint newColl = Troves[_borrower].coll.sub(_collDecrease);\n        Troves[_borrower].coll = newColl;\n        return newColl;\n    }\n\n    function increaseTroveDebt(address _borrower, uint _debtIncrease) external override returns (uint) {\n        _requireCallerIsBorrowerOperations();\n        uint newDebt = Troves[_borrower].debt.add(_debtIncrease);\n        Troves[_borrower].debt = newDebt;\n        return newDebt;\n    }\n\n    function decreaseTroveDebt(address _borrower, uint _debtDecrease) external override returns (uint) {\n        _requireCallerIsBorrowerOperations();\n        uint newDebt = Troves[_borrower].debt.sub(_debtDecrease);\n        Troves[_borrower].debt = newDebt;\n        return newDebt;\n    }\n}",
        "function": "decayBaseRateFromBorrowing()",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-Liquity/dev-f0df3efa5a5f05b205752184cfce107c5bd6e06c/packages/contracts/contracts/TroveManager.sol",
        "vulnerability": "Dependence on predictable environment variable (SWC 116)",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract TroveManager is LiquityBase, Ownable, ITroveManager {\n\n    // --- Connected contract declarations ---\n\n    address public borrowerOperationsAddress;\n\n    IPool public activePool;\n\n    IPool public defaultPool;\n\n    IStabilityPool public stabilityPool;\n\n    ICollSurplusPool collSurplusPool;\n\n    ILUSDToken public lusdToken;\n\n    IPriceFeed public priceFeed;\n\n    ILQTYStaking public lqtyStaking;\n    address public lqtyStakingAddress;\n\n    // A doubly linked list of Troves, sorted by their sorted by their collateral ratios\n    ISortedTroves public sortedTroves;\n\n    // --- Data structures ---\n\n    uint constant public SECONDS_IN_ONE_MINUTE = 60;\n    uint constant public MINUTE_DECAY_FACTOR = 999832508430720967;  // 18 digit decimal. Corresponds to an hourly decay factor of 0.99\n\n    /* \n    * BETA: 18 digit decimal. Parameter by which to divide the redeemed fraction, in order to calc the new base rate from a redemption. \n    * Corresponds to (1 / ALPHA) in the white paper. \n    */\n    uint constant public BETA = 2;\n\n    uint public baseRate;\n\n    // The timestamp of the latest fee operation (redemption or new LUSD issuance) \n    uint public lastFeeOperationTime;\n\n    enum Status { nonExistent, active, closed }\n\n    // Store the necessary data for a trove\n    struct Trove {\n        uint debt;\n        uint coll;\n        uint stake;\n        Status status;\n        uint128 arrayIndex;\n    }\n\n    mapping (address => Trove) public Troves;\n\n    uint public totalStakes;\n\n    // Snapshot of the value of totalStakes, taken immediately after the latest liquidation\n    uint public totalStakesSnapshot;\n\n    // Snapshot of the total collateral across the ActivePool and DefaultPool, immediately after the latest liquidation.\n    uint public totalCollateralSnapshot;\n\n    /*\n    * L_ETH and L_LUSDDebt track the sums of accumulated liquidation rewards per unit staked. During its lifetime, each stake earns:\n    *\n    * An ETH gain of ( stake * [L_ETH - L_ETH(0)] )\n    * A LUSDDebt increase  of ( stake * [L_LUSDDebt - L_LUSDDebt(0)] )\n    *\n    * Where L_ETH(0) and L_LUSDDebt(0) are snapshots of L_ETH and L_LUSDDebt for the active Trove taken at the instant the stake was made\n    */\n    uint public L_ETH;\n    uint public L_LUSDDebt;\n\n    // Map addresses with active troves to their RewardSnapshot\n    mapping (address => RewardSnapshot) public rewardSnapshots;\n\n    // Object containing the ETH and LUSD snapshots for a given active trove\n    struct RewardSnapshot { uint ETH; uint LUSDDebt;}\n\n    // Array of all active trove addresses - used to to compute an approximate hint off-chain, for the sorted list insertion\n    address[] public TroveOwners;\n\n    // Error trackers for the trove redistribution calculation\n    uint public lastETHError_Redistribution;\n    uint public lastLUSDDebtError_Redistribution;\n\n    /* \n    * --- Variable container structs for liquidations ---\n    *\n    * These structs are used to hold, return and assign variables inside the liquidation functions,\n    * in order to avoid the error: \"CompilerError: Stack too deep\". \n    **/\n\n    struct LocalVariables_OuterLiquidationFunction {\n        uint price;\n        uint LUSDInStabPool;\n        bool recoveryModeAtStart;\n        uint liquidatedDebt;\n        uint liquidatedColl;\n    }\n\n    struct LocalVariables_InnerSingleLiquidateFunction {\n        uint collToLiquidate;\n        uint pendingDebtReward;\n        uint pendingCollReward;\n    }\n\n    struct LocalVariables_LiquidationSequence {\n        uint remainingLUSDInStabPool;\n        uint i;\n        uint ICR;\n        address user;\n        bool backToNormalMode;\n        uint entireSystemDebt;\n        uint entireSystemColl;\n    }\n\n    struct LiquidationValues {\n        uint entireTroveDebt;\n        uint entireTroveColl;\n        uint collGasCompensation;\n        uint LUSDGasCompensation;\n        uint debtToOffset;\n        uint collToSendToSP;\n        uint debtToRedistribute;\n        uint collToRedistribute;\n        address partialAddr;\n        uint partialNewDebt;\n        uint partialNewColl;\n        address partialUpperHint;\n        address partialLowerHint;\n    }\n\n    struct LiquidationTotals {\n        uint totalCollInSequence;\n        uint totalDebtInSequence;\n        uint totalCollGasCompensation;\n        uint totalLUSDGasCompensation;\n        uint totalDebtToOffset;\n        uint totalCollToSendToSP;\n        uint totalDebtToRedistribute;\n        uint totalCollToRedistribute;\n        address partialAddr;\n        uint partialNewDebt;\n        uint partialNewColl;\n        address partialUpperHint;\n        address partialLowerHint;\n    }\n\n    // --- Variable container structs for redemptions ---\n\n    struct RedemptionTotals {\n        uint totalLUSDToRedeem;\n        uint totalETHDrawn;\n        uint ETHFee;\n        uint ETHToSendToRedeemer;\n        uint decayedBaseRate;\n    }\n\n    struct SingleRedemptionValues {\n        uint LUSDLot;\n        uint ETHLot;\n    }\n\n    // --- Events ---\n\n    event Liquidation(uint _liquidatedDebt, uint _liquidatedColl, uint _collGasCompensation, uint _LUSDGasCompensation);\n    event Redemption(uint _attemptedLUSDAmount, uint _actualLUSDAmount, uint _ETHSent, uint _ETHFee);\n\n    enum TroveManagerOperation {\n        applyPendingRewards,\n        liquidateInNormalMode,\n        liquidateInRecoveryMode,\n        partiallyLiquidateInRecoveryMode,\n        redeemCollateral\n    }\n\n    event TroveCreated(address indexed _borrower, uint _arrayIndex);\n    event TroveUpdated(address indexed _borrower, uint _debt, uint _coll, uint _stake, TroveManagerOperation _operation);\n    event TroveLiquidated(address indexed _borrower, uint _debt, uint _coll, TroveManagerOperation _operation);\n\n    // --- Dependency setter ---\n\n    function setAddresses(\n        address _borrowerOperationsAddress,\n        address _activePoolAddress,\n        address _defaultPoolAddress,\n        address _stabilityPoolAddress,\n        address _collSurplusPoolAddress,\n        address _priceFeedAddress,\n        address _lusdTokenAddress,\n        address _sortedTrovesAddress,\n        address _lqtyStakingAddress\n    )\n        external\n        override\n        onlyOwner\n    {\n        borrowerOperationsAddress = _borrowerOperationsAddress;\n        activePool = IPool(_activePoolAddress);\n        defaultPool = IPool(_defaultPoolAddress);\n        stabilityPool = IStabilityPool(_stabilityPoolAddress);\n        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);\n        priceFeed = IPriceFeed(_priceFeedAddress);\n        lusdToken = ILUSDToken(_lusdTokenAddress);\n        sortedTroves = ISortedTroves(_sortedTrovesAddress);\n        lqtyStakingAddress = _lqtyStakingAddress;\n        lqtyStaking = ILQTYStaking(_lqtyStakingAddress);\n\n        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);\n        emit ActivePoolAddressChanged(_activePoolAddress);\n        emit DefaultPoolAddressChanged(_defaultPoolAddress);\n        emit StabilityPoolAddressChanged(_stabilityPoolAddress);\n        emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);\n        emit PriceFeedAddressChanged(_priceFeedAddress);\n        emit LUSDTokenAddressChanged(_lusdTokenAddress);\n        emit SortedTrovesAddressChanged(_sortedTrovesAddress);\n        emit LQTYStakingAddressChanged(_lqtyStakingAddress);\n\n        _renounceOwnership();\n    }\n\n    // --- Getters ---\n\n    function getTroveOwnersCount() external view override returns (uint) {\n        return TroveOwners.length;\n    }\n\n    function getTroveFromTroveOwnersArray(uint _index) external view override returns (address) {\n        return TroveOwners[_index];\n    }\n\n    // --- Trove Liquidation functions ---\n\n    // Single liquidation function. Closes the trove if its ICR is lower than the minimum collateral ratio. \n    function liquidate(address _borrower) external override {\n        _requireTroveisActive(_borrower);\n\n        address[] memory borrowers = new address[](1);\n        borrowers[0] = _borrower;\n        batchLiquidateTroves(borrowers);\n    }\n\n    // --- Inner single liquidation functions ---\n\n    // Liquidate one trove, in Normal Mode.\n    function _liquidateNormalMode(address _borrower, uint _LUSDInStabPool) internal returns (LiquidationValues memory V) {\n        LocalVariables_InnerSingleLiquidateFunction memory L;\n\n        (V.entireTroveDebt,\n        V.entireTroveColl,\n        L.pendingDebtReward,\n        L.pendingCollReward) = getEntireDebtAndColl(_borrower);\n\n        _movePendingTroveRewardsToActivePool(L.pendingDebtReward, L.pendingCollReward);\n        _removeStake(_borrower);\n\n        V.collGasCompensation = _getCollGasCompensation(V.entireTroveColl);\n        V.LUSDGasCompensation = LUSD_GAS_COMPENSATION;\n        uint collToLiquidate = V.entireTroveColl.sub(V.collGasCompensation);\n\n        (V.debtToOffset,\n        V.collToSendToSP,\n        V.debtToRedistribute,\n        V.collToRedistribute) = _getOffsetAndRedistributionVals(V.entireTroveDebt, collToLiquidate, _LUSDInStabPool);\n\n        _closeTrove(_borrower);\n        emit TroveLiquidated(_borrower, V.entireTroveDebt, V.entireTroveColl, TroveManagerOperation.liquidateInNormalMode);\n\n        return V;\n    }\n\n    // Liquidate one trove, in Recovery Mode.\n    function _liquidateRecoveryMode(address _borrower, uint _ICR, uint _LUSDInStabPool, uint _TCR) internal returns (LiquidationValues memory V) {\n        LocalVariables_InnerSingleLiquidateFunction memory L;\n        \n        if (TroveOwners.length <= 1) { return V; } // don't liquidate if last trove\n\n        (V.entireTroveDebt,\n        V.entireTroveColl,\n        L.pendingDebtReward,\n        L.pendingCollReward) = getEntireDebtAndColl(_borrower);\n\n        _movePendingTroveRewardsToActivePool(L.pendingDebtReward, L.pendingCollReward);\n\n        V.collGasCompensation = _getCollGasCompensation(V.entireTroveColl);\n        // In case of a partial liquidation, V.LUSDGasCompensation will be overwritten to zero, in the third branch below\n        V.LUSDGasCompensation = LUSD_GAS_COMPENSATION;\n        L.collToLiquidate = V.entireTroveColl.sub(V.collGasCompensation);\n\n        // If ICR <= 100%, purely redistribute the Trove across all active Troves\n        if (_ICR <= _100pct) {\n            _removeStake(_borrower);\n\n            V.debtToOffset = 0;\n            V.collToSendToSP = 0;\n            V.debtToRedistribute = V.entireTroveDebt;\n            V.collToRedistribute = L.collToLiquidate;\n\n            _closeTrove(_borrower);\n            emit TroveLiquidated(_borrower, V.entireTroveDebt, V.entireTroveColl, TroveManagerOperation.liquidateInRecoveryMode);\n\n        // If 100% < ICR < MCR, offset as much as possible, and redistribute the remainder\n        } else if ((_ICR > _100pct) && (_ICR < MCR)) {\n            _removeStake(_borrower);\n\n            (V.debtToOffset,\n            V.collToSendToSP,\n            V.debtToRedistribute,\n            V.collToRedistribute) = _getOffsetAndRedistributionVals(V.entireTroveDebt, L.collToLiquidate, _LUSDInStabPool);\n\n            _closeTrove(_borrower);\n            emit TroveLiquidated(_borrower, V.entireTroveDebt, V.entireTroveColl, TroveManagerOperation.liquidateInRecoveryMode);\n\n        /* \n        * If 110% <= ICR < current TCR (accounting for the preceding liquidations in the current sequence)\n        * and there is LUSD in the Stability Pool, only offset it as much as possible, with no redistribution.\n        */\n        } else if ((_ICR >= MCR) && (_ICR < _TCR)) {\n            assert(_LUSDInStabPool != 0);\n\n            _removeStake(_borrower);\n            \n            V = _getFullOrPartialOffsetVals(_borrower, V.entireTroveDebt, V.entireTroveColl, _LUSDInStabPool);\n\n            _closeTrove(_borrower);\n        }\n        else if (_ICR >= _TCR) {\n            LiquidationValues memory zeroVals;\n            return zeroVals;\n        }\n\n        return V;\n    }\n\n    /* In a full liquidation, returns the values for a trove's coll and debt to be offset, and coll and debt to be \n    * redistributed to active troves. \n    */\n    function _getOffsetAndRedistributionVals\n    (\n        uint _debt,\n        uint _coll,\n        uint _LUSDInStabPool\n    )\n        internal\n        pure\n        returns (uint debtToOffset, uint collToSendToSP, uint debtToRedistribute, uint collToRedistribute)\n    {\n        if (_LUSDInStabPool > 0) {\n        /* \n        * Offset as much debt & collateral as possible against the Stability Pool, and redistribute the remainder\n        * between all active troves.\n        *\n        *  If the trove's debt is larger than the deposited LUSD in the Stability Pool:\n        *\n        *  - Offset an amount of the trove's debt equal to the LUSD in the Stability Pool\n        *  - Send a fraction of the trove's collateral to the Stability Pool, equal to the fraction of its offset debt\n        *\n        */\n            debtToOffset = LiquityMath._min(_debt, _LUSDInStabPool);\n            collToSendToSP = _coll.mul(debtToOffset).div(_debt);\n            debtToRedistribute = _debt.sub(debtToOffset);\n            collToRedistribute = _coll.sub(collToSendToSP);\n        } else {\n            debtToOffset = 0;\n            collToSendToSP = 0;\n            debtToRedistribute = _debt;\n            collToRedistribute = _coll;\n        }\n    }\n\n    /*\n    *  If it is a full offset, get its offset coll/debt and ETH gas comp, and close the trove.\n    *\n    * If it is a partial liquidation, get its offset coll/debt and ETH gas comp, and its new coll/debt, and its re-insertion hints.\n    */\n    function _getFullOrPartialOffsetVals\n    (\n        address _borrower,\n        uint _entireTroveDebt,\n        uint _entireTroveColl,\n        uint _LUSDInStabPool\n    )\n        internal\n        returns (LiquidationValues memory V)\n    {\n        V.entireTroveDebt = _entireTroveDebt;\n        V.entireTroveColl = _entireTroveColl;\n\n        // When Stability Pool can fully absorb the trove's debt, perform a full offset\n        if (_entireTroveDebt <= _LUSDInStabPool) {\n            V.collGasCompensation = _getCollGasCompensation(_entireTroveColl);\n            V.LUSDGasCompensation = LUSD_GAS_COMPENSATION;\n\n            V.debtToOffset = _entireTroveDebt;\n            V.collToSendToSP = _entireTroveColl.sub(V.collGasCompensation);\n            V.debtToRedistribute = 0;\n            V.collToRedistribute = 0;\n\n            emit TroveLiquidated(_borrower, _entireTroveDebt, _entireTroveColl, TroveManagerOperation.liquidateInRecoveryMode);\n        }\n        /* \n        * When trove's debt is greater than the Stability Pool, perform a partial liquidation: offset as much as possible,\n        * and do not redistribute the remainder. The trove remains active, with a reduced collateral and debt.\n        *\n        * ETH gas compensation is based on and drawn from the collateral fraction that corresponds to the partial offset. \n        * LUSD gas compensation is left untouched. \n        *\n        * Since ETH gas comp is drawn purely from the *liquidated* portion, the trove is left with the same ICR as before the \n        * liquidation.\n        */\n        else if (_entireTroveDebt > _LUSDInStabPool) {\n            // Remaining debt in the trove is lower-bounded by the trove's gas compensation\n            V.partialNewDebt = LiquityMath._max(_entireTroveDebt.sub(_LUSDInStabPool), LUSD_GAS_COMPENSATION);\n          \n            V.debtToOffset = _entireTroveDebt.sub(V.partialNewDebt);\n\n            uint collFraction = _entireTroveColl.mul(V.debtToOffset).div(_entireTroveDebt);\n            V.collGasCompensation = _getCollGasCompensation(collFraction);\n          \n            V.LUSDGasCompensation = 0;  // LUSD gas compensation remains untouched\n\n            V.collToSendToSP = collFraction.sub(V.collGasCompensation);\n            V.collToRedistribute = 0;\n            V.debtToRedistribute = 0;\n\n            V.partialAddr = _borrower;\n            V.partialNewColl = _entireTroveColl.sub(collFraction);\n\n            // Get the partial trove's neighbours, so we can re-insert it later to the same position\n            V.partialUpperHint = sortedTroves.getPrev(_borrower);  \n            V.partialLowerHint = sortedTroves.getNext(_borrower);\n        }\n    }\n\n    /* \n    * Liquidate a sequence of troves. Closes a maximum number of n under-collateralized Troves,\n    * starting from the one with the lowest collateral ratio in the system, and moving upwards\n    */\n    function liquidateTroves(uint _n) external override {\n        LocalVariables_OuterLiquidationFunction memory L;\n\n        LiquidationTotals memory T;\n\n        L.price = priceFeed.getPrice();\n        L.LUSDInStabPool = stabilityPool.getTotalLUSDDeposits();\n        L.recoveryModeAtStart = checkRecoveryMode();\n\n        // Perform the appropriate liquidation sequence - tally the values, and obtain their totals\n        if (L.recoveryModeAtStart == true) {\n            T = _getTotalsFromLiquidateTrovesSequence_RecoveryMode(L.price, L.LUSDInStabPool, _n);\n        } else if (L.recoveryModeAtStart == false) {\n            T = _getTotalsFromLiquidateTrovesSequence_NormalMode(L.price, L.LUSDInStabPool, _n);\n        }\n\n        // Move liquidated ETH and LUSD to the appropriate pools\n        stabilityPool.offset(T.totalDebtToOffset, T.totalCollToSendToSP);\n        _redistributeDebtAndColl(T.totalDebtToRedistribute, T.totalCollToRedistribute);\n\n        // Update system snapshots and the final partially liquidated trove, if there is one\n        _updateSystemSnapshots_excludeCollRemainder(T.partialNewColl.add(T.totalCollGasCompensation));\n        _updatePartiallyLiquidatedTrove(T.partialAddr, T.partialNewDebt, T.partialNewColl, T.partialUpperHint, T. partialLowerHint, L.price);\n\n        L.liquidatedDebt = T.totalDebtInSequence.sub(T.partialNewDebt);\n        L.liquidatedColl = T.totalCollInSequence.sub(T.totalCollGasCompensation).sub(T.partialNewColl);\n        emit Liquidation(L.liquidatedDebt, L.liquidatedColl, T.totalCollGasCompensation, T.totalLUSDGasCompensation);\n\n        // Send gas compensation to caller\n        _sendGasCompensation(msg.sender, T.totalLUSDGasCompensation, T.totalCollGasCompensation);\n    }\n\n    /*\n    * This function is used when the liquidateTroves sequence starts during Recovery Mode. However, it\n    * handle the case where the system *leaves* Recovery Mode, part way through the liquidation sequence\n    */\n    function _getTotalsFromLiquidateTrovesSequence_RecoveryMode\n    (\n        uint _price,\n        uint _LUSDInStabPool,\n        uint _n\n    )\n        internal\n        returns(LiquidationTotals memory T)\n    {\n        LocalVariables_LiquidationSequence memory L;\n        LiquidationValues memory V;\n\n        L.remainingLUSDInStabPool = _LUSDInStabPool;\n        L.backToNormalMode = false;\n        L.entireSystemDebt = activePool.getLUSDDebt().add(defaultPool.getLUSDDebt());\n        L.entireSystemColl = activePool.getETH().add(defaultPool.getETH());\n\n        L.i = 0;\n        while (L.i < _n) {\n            L.user = sortedTroves.getLast();\n            L.ICR = getCurrentICR(L.user, _price);\n\n            if (L.backToNormalMode == false) {\n                // Break the loop if ICR is greater than MCR and Stability Pool is empty\n                if (L.ICR >= MCR && L.remainingLUSDInStabPool == 0) { break; }\n\n                uint TCR = LiquityMath._computeCR(L.entireSystemColl, L.entireSystemDebt, _price);\n        \n                V = _liquidateRecoveryMode(L.user, L.ICR, L.remainingLUSDInStabPool, TCR);\n\n                // Update aggregate trackers\n                L.remainingLUSDInStabPool = L.remainingLUSDInStabPool.sub(V.debtToOffset);\n                L.entireSystemDebt = L.entireSystemDebt.sub(V.debtToOffset);\n                L.entireSystemColl = L.entireSystemColl.sub(V.collToSendToSP);\n\n                // Add liquidation values to their respective running totals\n                T = _addLiquidationValuesToTotals(T, V);\n\n                // Break the loop if it was a partial liquidation\n                if (V.partialAddr != address(0)) {break;}\n\n                L.backToNormalMode = !_checkPotentialRecoveryMode(L.entireSystemColl, L.entireSystemDebt, _price);\n            }\n            else if (L.backToNormalMode == true && L.ICR < MCR) {\n                V = _liquidateNormalMode(L.user, L.remainingLUSDInStabPool);\n\n                L.remainingLUSDInStabPool = L.remainingLUSDInStabPool.sub(V.debtToOffset);\n\n                // Add liquidation values to their respective running totals\n                T = _addLiquidationValuesToTotals(T, V);\n\n            }  else break;  // break if the loop reaches a Trove with ICR >= MCR\n\n            // Break the loop if it reaches the first Trove in the sorted list\n            if (L.user == sortedTroves.getFirst()) { break; }\n\n            L.i++;\n        }\n    }\n\n    function _getTotalsFromLiquidateTrovesSequence_NormalMode\n    (\n        uint _price,\n        uint _LUSDInStabPool,\n        uint _n\n    )\n        internal\n        returns(LiquidationTotals memory T)\n    {\n        LocalVariables_LiquidationSequence memory L;\n        LiquidationValues memory V;\n\n        L.remainingLUSDInStabPool = _LUSDInStabPool;\n\n        L.i = 0;\n        while (L.i < _n) {\n            L.user = sortedTroves.getLast();\n            L.ICR = getCurrentICR(L.user, _price);\n\n            if (L.ICR < MCR) {\n                V = _liquidateNormalMode(L.user, L.remainingLUSDInStabPool);\n\n                L.remainingLUSDInStabPool = L.remainingLUSDInStabPool.sub(V.debtToOffset);\n\n                // Add liquidation values to their respective running totals\n                T = _addLiquidationValuesToTotals(T, V);\n\n            } else break;  // break if the loop reaches a Trove with ICR >= MCR\n\n            // Break the loop if it reaches the first Trove in the sorted list\n            if (L.user == sortedTroves.getFirst()) { break; }\n            L.i++;\n        }\n    }\n\n    /* \n    * Attempt to liquidate a custom list of troves provided by the caller. The liquidation sequence stops if\n    * a partial liquidation is performed, so it's up to the caller to order the troves in the _troveArray parameter.\n    */\n    function batchLiquidateTroves(address[] memory _troveArray) public override {\n        require(_troveArray.length != 0, \"TroveManager: Calldata address array must not be empty\");\n\n        LocalVariables_OuterLiquidationFunction memory L;\n        LiquidationTotals memory T;\n\n        L.price = priceFeed.getPrice();\n        L.LUSDInStabPool = stabilityPool.getTotalLUSDDeposits();\n        L.recoveryModeAtStart = checkRecoveryMode();\n\n        // Perform the appropriate liquidation sequence - tally values and obtain their totals.\n        if (L.recoveryModeAtStart == true) {\n           T = _getTotalFromBatchLiquidate_RecoveryMode(L.price, L.LUSDInStabPool, _troveArray);\n        } else if (L.recoveryModeAtStart == false) {\n            T = _getTotalsFromBatchLiquidate_NormalMode(L.price, L.LUSDInStabPool, _troveArray);\n        }\n\n        // Move liquidated ETH and LUSD to the appropriate pools\n        stabilityPool.offset(T.totalDebtToOffset, T.totalCollToSendToSP);\n        _redistributeDebtAndColl(T.totalDebtToRedistribute, T.totalCollToRedistribute);\n\n        // Update system snapshots and the final partially liquidated trove, if there is one\n        _updateSystemSnapshots_excludeCollRemainder(T.partialNewColl.add(T.totalCollGasCompensation));\n        _updatePartiallyLiquidatedTrove(T.partialAddr, T.partialNewDebt, T.partialNewColl, T.partialUpperHint, T. partialLowerHint, L.price);\n\n        L.liquidatedDebt = T.totalDebtInSequence.sub(T.partialNewDebt);\n        L.liquidatedColl = T.totalCollInSequence.sub(T.totalCollGasCompensation).sub(T.partialNewColl);\n        emit Liquidation(L.liquidatedDebt, L.liquidatedColl, T.totalCollGasCompensation, T.totalLUSDGasCompensation);\n\n        // Send gas compensation to caller\n        _sendGasCompensation(msg.sender, T.totalLUSDGasCompensation, T.totalCollGasCompensation);\n    }\n\n    /* \n    * This function is used when the batch liquidation sequence starts during Recovery Mode. However, it\n    * handle the case where the system *leaves* Recovery Mode, part way through the liquidation sequence\n    */\n    function _getTotalFromBatchLiquidate_RecoveryMode\n    (\n        uint _price,\n        uint _LUSDInStabPool,\n        address[] memory _troveArray)\n        internal\n        returns(LiquidationTotals memory T)\n    {\n        LocalVariables_LiquidationSequence memory L;\n        LiquidationValues memory V;\n\n        L.remainingLUSDInStabPool = _LUSDInStabPool;\n        L.backToNormalMode = false;\n        L.entireSystemDebt = activePool.getLUSDDebt().add(defaultPool.getLUSDDebt());\n        L.entireSystemColl = activePool.getETH().add(defaultPool.getETH());\n\n        L.i = 0;\n        for (L.i = 0; L.i < _troveArray.length; L.i++) {\n            L.user = _troveArray[L.i];\n            L.ICR = getCurrentICR(L.user, _price);\n\n            if (L.backToNormalMode == false) {\n\n                // Skip this trove if ICR is greater than MCR and Stability Pool is empty\n                if (L.ICR >= MCR && L.remainingLUSDInStabPool == 0) { continue; }\n\n                uint TCR = LiquityMath._computeCR(L.entireSystemColl, L.entireSystemDebt, _price);\n\n                V = _liquidateRecoveryMode(L.user, L.ICR, L.remainingLUSDInStabPool, TCR);\n\n                // Update aggregate trackers\n                L.remainingLUSDInStabPool = L.remainingLUSDInStabPool.sub(V.debtToOffset);\n                L.entireSystemDebt = L.entireSystemDebt.sub(V.debtToOffset);\n                L.entireSystemColl = L.entireSystemColl.sub(V.collToSendToSP);\n\n                // Add liquidation values to their respective running totals\n                T = _addLiquidationValuesToTotals(T, V);\n\n                // Break the loop if it was a partial liquidation\n                if (V.partialAddr != address(0)) { break; }\n\n                L.backToNormalMode = !_checkPotentialRecoveryMode(L.entireSystemColl, L.entireSystemDebt, _price);\n            }\n\n            else if (L.backToNormalMode == true && L.ICR < MCR) {\n                V = _liquidateNormalMode(L.user, L.remainingLUSDInStabPool);\n                L.remainingLUSDInStabPool = L.remainingLUSDInStabPool.sub(V.debtToOffset);\n\n                // Add liquidation values to their respective running totals\n                T = _addLiquidationValuesToTotals(T, V);\n            }\n        }\n    }\n\n    function _getTotalsFromBatchLiquidate_NormalMode\n    (\n        uint _price,\n        uint _LUSDInStabPool,\n        address[] memory _troveArray\n    )\n        internal\n        returns(LiquidationTotals memory T)\n    {\n        LocalVariables_LiquidationSequence memory L;\n        LiquidationValues memory V;\n\n        L.remainingLUSDInStabPool = _LUSDInStabPool;\n\n        for (L.i = 0; L.i < _troveArray.length; L.i++) {\n            L.user = _troveArray[L.i];\n            L.ICR = getCurrentICR(L.user, _price);\n\n            if (L.ICR < MCR) {\n                V = _liquidateNormalMode(L.user, L.remainingLUSDInStabPool);\n                L.remainingLUSDInStabPool = L.remainingLUSDInStabPool.sub(V.debtToOffset);\n\n                // Add liquidation values to their respective running totals\n                T = _addLiquidationValuesToTotals(T, V);\n            }\n        }\n    }\n\n    // --- Liquidation helper functions ---\n\n    function _addLiquidationValuesToTotals(LiquidationTotals memory T1, LiquidationValues memory V)\n    internal pure returns(LiquidationTotals memory T2) {\n\n        // Tally all the values with their respective running totals\n        T2.totalCollGasCompensation = T1.totalCollGasCompensation.add(V.collGasCompensation);\n        T2.totalLUSDGasCompensation = T1.totalLUSDGasCompensation.add(V.LUSDGasCompensation);\n        T2.totalDebtInSequence = T1.totalDebtInSequence.add(V.entireTroveDebt);\n        T2.totalCollInSequence = T1.totalCollInSequence.add(V.entireTroveColl);\n        T2.totalDebtToOffset = T1.totalDebtToOffset.add(V.debtToOffset);\n        T2.totalCollToSendToSP = T1.totalCollToSendToSP.add(V.collToSendToSP);\n        T2.totalDebtToRedistribute = T1.totalDebtToRedistribute.add(V.debtToRedistribute);\n        T2.totalCollToRedistribute = T1.totalCollToRedistribute.add(V.collToRedistribute);\n\n        // Assign the address of the partially liquidated trove, and its new debt and coll values\n        T2.partialAddr = V.partialAddr;\n        T2.partialNewDebt = V.partialNewDebt;\n        T2.partialNewColl = V.partialNewColl;\n        T2.partialUpperHint = V.partialUpperHint;\n        T2.partialLowerHint = V.partialLowerHint;\n\n        return T2;\n    }\n\n    // Update the properties of the partially liquidated trove, and insert it back to the list\n    function _updatePartiallyLiquidatedTrove\n    (\n        address _borrower, \n        uint _newDebt, \n        uint _newColl, \n        address _upperHint,\n        address _lowerHint,\n        uint _price\n    ) \n        internal \n    {\n        if ( _borrower == address(0)) { return; }\n\n        Troves[_borrower].debt = _newDebt;\n        Troves[_borrower].coll = _newColl;\n        Troves[_borrower].status = Status.active;\n\n        _updateTroveRewardSnapshots(_borrower);\n        _updateStakeAndTotalStakes(_borrower);\n\n        uint ICR = getCurrentICR(_borrower, _price);\n\n        /* \n        * Insert to sorted list and add to TroveOwners array. The partially liquidated trove has the same\n        * ICR as it did before the liquidation, so insertion is O(1): in principle, its ICR does not change.\n        * In practice, due to rounding error, its ICR can change slightly - so re-insert, with its previous neighbours\n        * as hints.\n        */\n        sortedTroves.insert(_borrower, ICR, _price, _upperHint, _lowerHint);\n        _addTroveOwnerToArray(_borrower);\n        emit TroveUpdated(_borrower, _newDebt, _newColl, Troves[_borrower].stake, TroveManagerOperation.partiallyLiquidateInRecoveryMode);\n    }\n\n    function _sendGasCompensation(address _liquidator, uint _LUSD, uint _ETH) internal {\n        if (_LUSD > 0) {\n            lusdToken.returnFromPool(GAS_POOL_ADDRESS, _liquidator, _LUSD);\n        }\n\n        if (_ETH > 0) {\n            activePool.sendETH(_liquidator, _ETH);\n        }\n    }\n\n    // Move a Trove's pending debt and collateral rewards from distributions, from the Default Pool to the Active Pool\n    function _movePendingTroveRewardsToActivePool(uint _LUSD, uint _ETH) internal {\n        defaultPool.decreaseLUSDDebt(_LUSD);\n        activePool.increaseLUSDDebt(_LUSD);\n        defaultPool.sendETH(address(activePool), _ETH);\n    }\n\n    // --- Redemption functions ---\n\n    // Redeem as much collateral as possible from _borrower's Trove in exchange for LUSD up to _maxLUSDamount\n    function _redeemCollateralFromTrove(\n        address _borrower,\n        uint _maxLUSDamount,\n        uint _price,\n        address _partialRedemptionHint,\n        uint _partialRedemptionHintICR\n    )\n        internal returns (SingleRedemptionValues memory V)\n    {\n        // Determine the remaining amount (lot) to be redeemed, capped by the entire debt of the Trove minus the gas compensation\n        V.LUSDLot = LiquityMath._min(_maxLUSDamount, Troves[_borrower].debt.sub(LUSD_GAS_COMPENSATION));\n\n        // Get the ETHLot of equivalent value in USD\n        V.ETHLot = V.LUSDLot.mul(1e18).div(_price);\n\n        // Decrease the debt and collateral of the current Trove according to the LUSD lot and corresponding ETH to send\n        uint newDebt = (Troves[_borrower].debt).sub(V.LUSDLot);\n        uint newColl = (Troves[_borrower].coll).sub(V.ETHLot);\n\n        if (newDebt == LUSD_GAS_COMPENSATION) {\n            // No debt left in the Trove (except for the gas compensation), therefore the trove gets closed\n            _removeStake(_borrower);\n            _closeTrove(_borrower);\n            _redeemCloseTrove(_borrower, LUSD_GAS_COMPENSATION, newColl);\n\n        } else {\n            uint newICR = LiquityMath._computeCR(newColl, newDebt, _price);\n\n            // Check if the provided hint is fresh. If not, we bail since trying to reinsert without a good hint will almost\n            // certainly result in running out of gas.\n            if (newICR != _partialRedemptionHintICR) {\n                V.LUSDLot = 0;\n                V.ETHLot = 0;\n                return V;\n            }\n\n            sortedTroves.reInsert(_borrower, newICR, _price, _partialRedemptionHint, _partialRedemptionHint);\n\n            Troves[_borrower].debt = newDebt;\n            Troves[_borrower].coll = newColl;\n            _updateStakeAndTotalStakes(_borrower);\n        }\n        emit TroveUpdated(\n            _borrower,\n            newDebt, newColl,\n            Troves[_borrower].stake,\n            TroveManagerOperation.redeemCollateral\n        );\n        return V;\n    }\n\n    /* \n    * Called when a full redemption occurs, and closes the trove.\n    * The redeemer swaps (debt - 10) LUSD for (debt - 10) worth of ETH, so the 10 LUSD gas compensation left corresponds to the remaining debt.\n    * In order to close the trove, the 10 LUSD gas compensation is burned, and 10 debt is removed from the active pool.\n    * The debt recorded on the trove's struct is zero'd elswhere, in _closeTrove.\n    * Any surplus ETH left in the trove, is sent to the Coll surplus pool, and can be later claimed by the borrower.\n    */ \n    function _redeemCloseTrove(address _borrower, uint _LUSD, uint _ETH) internal {\n        lusdToken.burn(GAS_POOL_ADDRESS, _LUSD);\n        // Update Active Pool LUSD, and send ETH to account\n        activePool.decreaseLUSDDebt(_LUSD);\n\n        // send ETH from Active Pool to CollSurplus Pool\n        collSurplusPool.accountSurplus(_borrower, _ETH);\n        activePool.sendETH(address(collSurplusPool), _ETH);\n    }\n\n    function _isValidFirstRedemptionHint(address _firstRedemptionHint, uint _price) internal view returns (bool) {\n        if (_firstRedemptionHint == address(0) ||\n            !sortedTroves.contains(_firstRedemptionHint) ||\n            getCurrentICR(_firstRedemptionHint, _price) < MCR\n        ) {\n            return false;\n        }\n\n        address nextTrove = sortedTroves.getNext(_firstRedemptionHint);\n        return nextTrove == address(0) || getCurrentICR(nextTrove, _price) < MCR;\n    }\n\n    /* Send _LUSDamount LUSD to the system and redeem the corresponding amount of collateral from as many Troves as are needed to fill the redemption\n    * request.  Applies pending rewards to a Trove before reducing its debt and coll.\n    *\n    * Note that if _amount is very large, this function can run out of gas, specially if traversed troves are small. This can be easily avoided by \n    * splitting the total _amount in appropriate chunks and calling the function multiple times.\n    * \n    * Param `_maxIterations` can also be provided, so the loop through Troves is capped (if its zero, it will be ignored).This makes it easier to \n    * avoid OOG for the frontend, as only knowing approximately the average cost of an iteration is enough, without needing to know the topology \n    * of the trove list. It also avoids the need to set the cap in stone in the contract, nor doing gas calculations, as both gas price and opcode \n    * costs can vary.\n    * \n    * All Troves that are redeemed from -- with the likely exception of the last one -- will end up with no debt left, therefore they will be closed.\n    * If the last Trove does have some remaining debt, it has a finite ICR, and the reinsertion could be anywhere in the list, therefore it requires a hint. \n    * A frontend should use getRedemptionHints() to calculate what the ICR of this Trove will be after redemption, and pass a hint for its position \n    * in the sortedTroves list along with the ICR value that the hint was found for.\n    * \n    * If another transaction modifies the list between calling getRedemptionHints() and passing the hints to redeemCollateral(), it\n    * is very likely that the last (partially) redeemed Trove would end up with a different ICR than what the hint is for. In this case the\n    * redemption will stop after the last completely redeemed Trove and the sender will keep the remaining LUSD amount, which they can attempt\n    * to redeem later.\n    */\n    function redeemCollateral(\n        uint _LUSDamount,\n        address _firstRedemptionHint,\n        address _partialRedemptionHint,\n        uint _partialRedemptionHintICR,\n        uint _maxIterations\n    )\n        external\n        override\n    {\n        uint activeDebt = activePool.getLUSDDebt();\n        uint defaultedDebt = defaultPool.getLUSDDebt();\n\n        RedemptionTotals memory T;\n\n        _requireAmountGreaterThanZero(_LUSDamount);\n        _requireLUSDBalanceCoversRedemption(msg.sender, _LUSDamount);\n\n        // Confirm redeemer's balance is less than total systemic debt\n        assert(lusdToken.balanceOf(msg.sender) <= (activeDebt.add(defaultedDebt)));\n\n        uint remainingLUSD = _LUSDamount;\n        uint price = priceFeed.getPrice();\n        address currentBorrower;\n\n        if (_isValidFirstRedemptionHint(_firstRedemptionHint, price)) {\n            currentBorrower = _firstRedemptionHint;\n        } else {\n            currentBorrower = sortedTroves.getLast();\n            // Find the first trove with ICR >= MCR\n            // SWC-104-Unchecked Call Return Value: L920\n            while (currentBorrower != address(0) && getCurrentICR(currentBorrower, price) < MCR) {\n                currentBorrower = sortedTroves.getPrev(currentBorrower);\n            }\n        }\n\n        // Loop through the Troves starting from the one with lowest collateral ratio until _amount of LUSD is exchanged for collateral\n        if (_maxIterations == 0) { _maxIterations = uint(-1); }\n        while (currentBorrower != address(0) && remainingLUSD > 0 && _maxIterations > 0) {\n            _maxIterations--;\n            // Save the address of the Trove preceding the current one, before potentially modifying the list\n            address nextUserToCheck = sortedTroves.getPrev(currentBorrower);\n\n            _applyPendingRewards(currentBorrower);\n            SingleRedemptionValues memory V = _redeemCollateralFromTrove(\n                currentBorrower,\n                remainingLUSD,\n                price,\n                _partialRedemptionHint,\n                _partialRedemptionHintICR\n            );\n\n            if (V.LUSDLot == 0) break; // Partial redemption hint got out-of-date, therefore we could not redeem from the last Trove\n\n            T.totalLUSDToRedeem  = T.totalLUSDToRedeem.add(V.LUSDLot);\n            T.totalETHDrawn = T.totalETHDrawn.add(V.ETHLot);\n\n            remainingLUSD = remainingLUSD.sub(V.LUSDLot);\n            currentBorrower = nextUserToCheck;\n        }\n\n        // Decay the baseRate due to time passed, and then increase it according to the size of this redemption\n        _updateBaseRateFromRedemption(T.totalETHDrawn, price);\n\n        // Calculate the ETH fee and send it to the LQTY staking contract\n        T.ETHFee = _getRedemptionFee(T.totalETHDrawn);\n        activePool.sendETH(lqtyStakingAddress, T.ETHFee);\n        lqtyStaking.increaseF_ETH(T.ETHFee);\n\n        T.ETHToSendToRedeemer = T.totalETHDrawn.sub(T.ETHFee);\n\n        // Burn the total LUSD that is cancelled with debt, and send the redeemed ETH to msg.sender\n        _activePoolRedeemCollateral(msg.sender, T.totalLUSDToRedeem, T.ETHToSendToRedeemer);\n\n        emit Redemption(_LUSDamount, T.totalLUSDToRedeem, T.totalETHDrawn, T.ETHFee);\n    }\n\n    // Burn the received LUSD, transfer the redeemed ETH to _redeemer and updates the Active Pool\n    function _activePoolRedeemCollateral(address _redeemer, uint _LUSD, uint _ETH) internal {\n        // Update Active Pool LUSD, and send ETH to account\n        lusdToken.burn(_redeemer, _LUSD);\n        activePool.decreaseLUSDDebt(_LUSD);\n\n        activePool.sendETH(_redeemer, _ETH);\n    }\n\n    // --- Helper functions ---\n\n\n    // Return the current collateral ratio (ICR) of a given Trove. Takes a trove's pending coll and debt rewards from redistributions into account.\n    function getCurrentICR(address _borrower, uint _price) public view override returns (uint) {\n        uint pendingETHReward = getPendingETHReward(_borrower);\n        uint pendingLUSDDebtReward = getPendingLUSDDebtReward(_borrower);\n\n        uint currentETH = Troves[_borrower].coll.add(pendingETHReward);\n        uint currentLUSDDebt = Troves[_borrower].debt.add(pendingLUSDDebtReward);\n\n        uint ICR = LiquityMath._computeCR(currentETH, currentLUSDDebt, _price);\n        return ICR;\n    }\n\n    function applyPendingRewards(address _borrower) external override {\n        _requireCallerIsBorrowerOperations();\n        return _applyPendingRewards(_borrower);\n    }\n\n    // Add the borrowers's coll and debt rewards earned from redistributions, to their Trove\n    function _applyPendingRewards(address _borrower) internal {\n        if (hasPendingRewards(_borrower)) {\n            _requireTroveisActive(_borrower);\n\n            // Compute pending rewards\n            uint pendingETHReward = getPendingETHReward(_borrower);\n            uint pendingLUSDDebtReward = getPendingLUSDDebtReward(_borrower);\n\n            // Apply pending rewards to trove's state\n            Troves[_borrower].coll = Troves[_borrower].coll.add(pendingETHReward);\n            Troves[_borrower].debt = Troves[_borrower].debt.add(pendingLUSDDebtReward);\n\n            _updateTroveRewardSnapshots(_borrower);\n\n            // Transfer from DefaultPool to ActivePool\n            _movePendingTroveRewardsToActivePool(pendingLUSDDebtReward, pendingETHReward);\n\n            emit TroveUpdated(\n                _borrower, \n                Troves[_borrower].debt, \n                Troves[_borrower].coll, \n                Troves[_borrower].stake, \n                TroveManagerOperation.applyPendingRewards\n            );\n        }\n    }\n\n    // Update borrower's snapshots of L_ETH and L_LUSDDebt to reflect the current values\n    function updateTroveRewardSnapshots(address _borrower) external override {\n        _requireCallerIsBorrowerOperations();\n       return _updateTroveRewardSnapshots(_borrower);\n    }\n\n    function _updateTroveRewardSnapshots(address _borrower) internal {\n        rewardSnapshots[_borrower].ETH = L_ETH;\n        rewardSnapshots[_borrower].LUSDDebt = L_LUSDDebt;\n    }\n\n    // Get the borrower's pending accumulated ETH reward, earned by their stake\n    function getPendingETHReward(address _borrower) public view override returns (uint) {\n        uint snapshotETH = rewardSnapshots[_borrower].ETH;\n        uint rewardPerUnitStaked = L_ETH.sub(snapshotETH);\n\n        if ( rewardPerUnitStaked == 0 ) { return 0; }\n\n        uint stake = Troves[_borrower].stake;\n\n        uint pendingETHReward = stake.mul(rewardPerUnitStaked).div(1e18);\n\n        return pendingETHReward;\n    }\n\n     // Get the borrower's pending accumulated LUSD reward, earned by their stake\n    function getPendingLUSDDebtReward(address _borrower) public view override returns (uint) {\n        uint snapshotLUSDDebt = rewardSnapshots[_borrower].LUSDDebt;\n        uint rewardPerUnitStaked = L_LUSDDebt.sub(snapshotLUSDDebt);\n\n        if ( rewardPerUnitStaked == 0 ) { return 0; }\n\n        uint stake =  Troves[_borrower].stake;\n\n        uint pendingLUSDDebtReward = stake.mul(rewardPerUnitStaked).div(1e18);\n\n        return pendingLUSDDebtReward;\n    }\n\n    function hasPendingRewards(address _borrower) public view override returns (bool) {\n        /* \n        * A Trove has pending rewards if its snapshot is less than the current rewards per-unit-staked sum:\n        * this indicates that rewards have occured since the snapshot was made, and the user therefore has\n        * pending rewards \n        */\n        return (rewardSnapshots[_borrower].ETH < L_ETH);\n    }\n\n    // Return the Troves entire debt and coll, including pending rewards from redistributions.\n    function getEntireDebtAndColl(\n        address _borrower\n    )\n        public\n        view\n        override\n        returns (uint debt, uint coll, uint pendingLUSDDebtReward, uint pendingETHReward)\n    {\n        debt = Troves[_borrower].debt;\n        coll = Troves[_borrower].coll;\n\n        pendingLUSDDebtReward = getPendingLUSDDebtReward(_borrower);\n        pendingETHReward = getPendingETHReward(_borrower);\n\n        debt = debt.add(pendingLUSDDebtReward);\n        coll = coll.add(pendingETHReward);\n    }\n\n    function removeStake(address _borrower) external override {\n        _requireCallerIsBorrowerOperations();\n        return _removeStake(_borrower);\n    }\n\n    // Remove borrower's stake from the totalStakes sum, and set their stake to 0\n    function _removeStake(address _borrower) internal {\n        uint stake = Troves[_borrower].stake;\n        totalStakes = totalStakes.sub(stake);\n        Troves[_borrower].stake = 0;\n    }\n\n    function updateStakeAndTotalStakes(address _borrower) external override returns (uint) {\n        _requireCallerIsBorrowerOperations();\n        return _updateStakeAndTotalStakes(_borrower);\n    }\n\n    // Update borrower's stake based on their latest collateral value\n    function _updateStakeAndTotalStakes(address _borrower) internal returns (uint) {\n        uint newStake = _computeNewStake(Troves[_borrower].coll);\n        uint oldStake = Troves[_borrower].stake;\n        Troves[_borrower].stake = newStake;\n        totalStakes = totalStakes.sub(oldStake).add(newStake);\n\n        return newStake;\n    }\n\n    // Calculate a new stake based on the snapshots of the totalStakes and totalCollateral taken at the last liquidation\n    function _computeNewStake(uint _coll) internal view returns (uint) {\n        uint stake;\n        if (totalCollateralSnapshot == 0) {\n            stake = _coll;\n        } else {\n            /*  \n            * The following assert() holds true because:\n            * - The system always contains >= 1 trove \n            * - When we close or liquidate a trove, we redistribute the pending rewards, so if all troves were closed/liquidated, \n            * rewards wouldve been emptied and totalCollateralSnapshot would be zero too.\n            */\n            assert(totalStakesSnapshot > 0);\n            stake = _coll.mul(totalStakesSnapshot).div(totalCollateralSnapshot);\n        }\n        return stake;\n    }\n\n    function _redistributeDebtAndColl(uint _debt, uint _coll) internal {\n        if (_debt == 0) { return; }\n\n        if (totalStakes > 0) {\n            /* \n            * Add distributed coll and debt rewards-per-unit-staked to the running totals.\n            * Division uses a \"feedback\" error correction, to keep the cumulative error in\n            * the  L_ETH and L_LUSDDebt state variables low. \n            */\n            uint ETHNumerator = _coll.mul(1e18).add(lastETHError_Redistribution);\n            uint LUSDDebtNumerator = _debt.mul(1e18).add(lastLUSDDebtError_Redistribution);\n\n            uint ETHRewardPerUnitStaked = ETHNumerator.div(totalStakes);\n            uint LUSDDebtRewardPerUnitStaked = LUSDDebtNumerator.div(totalStakes);\n\n            lastETHError_Redistribution = ETHNumerator.sub(ETHRewardPerUnitStaked.mul(totalStakes));\n            lastLUSDDebtError_Redistribution = LUSDDebtNumerator.sub(LUSDDebtRewardPerUnitStaked.mul(totalStakes));\n\n            L_ETH = L_ETH.add(ETHRewardPerUnitStaked);\n            L_LUSDDebt = L_LUSDDebt.add(LUSDDebtRewardPerUnitStaked);\n        }\n\n        // Transfer coll and debt from ActivePool to DefaultPool\n        activePool.decreaseLUSDDebt(_debt);\n        defaultPool.increaseLUSDDebt(_debt);\n        activePool.sendETH(address(defaultPool), _coll);\n    }\n\n    function closeTrove(address _borrower) external override {\n        _requireCallerIsBorrowerOperations();\n        return _closeTrove(_borrower);\n    }\n\n    function _closeTrove(address _borrower) internal {\n        uint TroveOwnersArrayLength = TroveOwners.length;\n        _requireMoreThanOneTroveInSystem(TroveOwnersArrayLength);\n\n        Troves[_borrower].status = Status.closed;\n        Troves[_borrower].coll = 0;\n        Troves[_borrower].debt = 0;\n\n        rewardSnapshots[_borrower].ETH = 0;\n        rewardSnapshots[_borrower].LUSDDebt = 0;\n\n        _removeTroveOwner(_borrower, TroveOwnersArrayLength);\n        sortedTroves.remove(_borrower);\n    }\n\n    /* \n    * Updates snapshots of system total stakes and total collateral, excluding a given collateral remainder from the calculation. \n    * Used in a liquidation sequence.\n    *\n    * The calculation excludes two portions of collateral that are in the ActivePool: \n    *\n    * 1) the total ETH gas compensation from the liquidation sequence\n    * 2) The remaining collateral in a partially liquidated trove (if one occurred)\n    *\n    * The ETH as compensation must be excluded as it is always sent out at the very end of the liquidation sequence.\n    *\n    * The partially liquidated trove's remaining collateral stays in the ActivePool, but it is excluded here so the system \n    * can take snapshots before the partially liquidated trove's stake is updated (based on these snapshots). This ensures\n    * the partial's new stake doesn't double-count its own remaining collateral.\n    *\n    */\n    function _updateSystemSnapshots_excludeCollRemainder(uint _collRemainder) internal {\n        totalStakesSnapshot = totalStakes;\n\n        uint activeColl = activePool.getETH();\n        uint liquidatedColl = defaultPool.getETH();\n        totalCollateralSnapshot = activeColl.sub(_collRemainder).add(liquidatedColl);\n    }\n\n    // Push the owner's address to the Trove owners list, and record the corresponding array index on the Trove struct\n    function addTroveOwnerToArray(address _borrower) external override returns (uint index) {\n        _requireCallerIsBorrowerOperations();\n        return _addTroveOwnerToArray(_borrower);\n    }\n\n    function _addTroveOwnerToArray(address _borrower) internal returns (uint128 index) {\n        require(TroveOwners.length < 2**128 - 1, \"TroveManager: TroveOwners array has maximum size of 2^128 - 1\");\n\n        // Push the Troveowner to the array\n        TroveOwners.push(_borrower);\n\n        // Record the index of the new Troveowner on their Trove struct\n        index = uint128(TroveOwners.length.sub(1));\n        Troves[_borrower].arrayIndex = index;\n\n        return index;\n    }\n\n    /* \n    * Remove a Trove owner from the TroveOwners array, not preserving array order. Removing owner 'B' does the following:\n    * [A B C D E] => [A E C D], and updates E's Trove struct to point to its new array index. \n    */\n    function _removeTroveOwner(address _borrower, uint TroveOwnersArrayLength) internal {\n        require(Troves[_borrower].status == Status.closed, \"TroveManager: Trove is still active\");\n\n        uint128 index = Troves[_borrower].arrayIndex;\n        uint length = TroveOwnersArrayLength;\n        uint idxLast = length.sub(1);\n\n        assert(index <= idxLast);\n\n        address addressToMove = TroveOwners[idxLast];\n\n        TroveOwners[index] = addressToMove;\n        Troves[addressToMove].arrayIndex = index;\n        TroveOwners.pop();\n    }\n\n    // --- Recovery Mode and TCR functions ---\n\n    function checkRecoveryMode() public view override returns (bool) {\n        uint TCR = getTCR();\n\n        if (TCR < CCR) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    // Check whether or not the system *would be* in Recovery Mode, given an ETH:USD price, and the entire system coll and debt.\n    function _checkPotentialRecoveryMode(\n        uint _entireSystemColl,\n        uint _entireSystemDebt,\n        uint _price\n    )\n        internal\n        pure\n    returns (bool)\n    {\n        uint TCR = LiquityMath._computeCR(_entireSystemColl, _entireSystemDebt, _price);\n        if (TCR < CCR) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n    // SWC-135-Code With No Effects: L1276-L1284\n    function getTCR() public view override returns (uint TCR) {\n        uint price = priceFeed.getPrice();\n        uint entireSystemColl = getEntireSystemColl();\n        uint entireSystemDebt = getEntireSystemDebt();\n\n        TCR = LiquityMath._computeCR(entireSystemColl, entireSystemDebt, price);\n\n        return TCR;\n    }\n    // SWC-135-Code With No Effects: L1286-L1291\n    function getEntireSystemColl() public view override returns (uint entireSystemColl) {\n        uint activeColl = activePool.getETH();\n        uint liquidatedColl = defaultPool.getETH();\n\n        return activeColl.add(liquidatedColl);\n    }\n\n    function getEntireSystemDebt() public view override returns (uint entireSystemDebt) {\n        uint activeDebt = activePool.getLUSDDebt();\n        uint closedDebt = defaultPool.getLUSDDebt();\n\n        return activeDebt.add(closedDebt);\n    }\n\n    // --- Redemption fee functions ---\n\n    /* \n    * This function has two impacts on the baseRate state variable:\n    * 1) decays the baseRate based on time passed since last redemption or LUSD borrowing operation.\n    * then,\n    * 2) increases the baseRate based on the amount redeemed, as a proportion of total supply\n    */\n    function _updateBaseRateFromRedemption(uint _ETHDrawn,  uint _price) internal returns (uint) {\n        uint decayedBaseRate = _calcDecayedBaseRate();\n\n        uint activeDebt = activePool.getLUSDDebt();\n        uint closedDebt = defaultPool.getLUSDDebt();\n        uint totalLUSDSupply = activeDebt.add(closedDebt);\n\n        /* Convert the drawn ETH back to LUSD at face value rate (1 LUSD:1 USD), in order to get\n        * the fraction of total supply that was redeemed at face value. */\n        uint redeemedLUSDFraction = _ETHDrawn.mul(_price).div(totalLUSDSupply);\n\n        uint newBaseRate = decayedBaseRate.add(redeemedLUSDFraction.div(BETA));\n\n        // Update the baseRate state variable\n        baseRate = newBaseRate < 1e18 ? newBaseRate : 1e18;  // cap baseRate at a maximum of 100%\n        assert(baseRate <= 1e18 && baseRate > 0); // Base rate is always non-zero after redemption\n\n        _updateLastFeeOpTime();\n\n        return baseRate;\n    }\n\n    function _getRedemptionFee(uint _ETHDrawn) internal view returns (uint) {\n       return baseRate.mul(_ETHDrawn).div(1e18);\n    }\n\n    // --- Borrowing fee functions ---\n\n    function getBorrowingFee(uint _LUSDDebt) external view override returns (uint) {\n        return _LUSDDebt.mul(baseRate).div(1e18);\n    }\n\n    // Updates the baseRate state variable based on time elapsed since the last redemption or LUSD borrowing operation.\n    function decayBaseRateFromBorrowing() external override {\n        _requireCallerIsBorrowerOperations();\n\n        baseRate = _calcDecayedBaseRate();\n        assert(baseRate <= 1e18);  // The baseRate can decay to 0\n\n        _updateLastFeeOpTime();\n    }\n\n    // --- Internal fee functions ---\n\n    // Update the last fee operation time only if time passed >= decay interval. This prevents base rate griefing.\n    function _updateLastFeeOpTime() internal {\n        uint timePassed = block.timestamp.sub(lastFeeOperationTime);\n\n        if (timePassed >= SECONDS_IN_ONE_MINUTE) {\n            lastFeeOperationTime = block.timestamp;\n        }\n    }\n\n    function _calcDecayedBaseRate() internal view returns (uint) {\n        uint minutesPassed = _minutesPassedSinceLastFeeOp();\n        uint decayFactor = LiquityMath._decPow(MINUTE_DECAY_FACTOR, minutesPassed);\n\n        return baseRate.mul(decayFactor).div(1e18);\n    }\n\n    function _minutesPassedSinceLastFeeOp() internal view returns (uint) {\n        return (block.timestamp.sub(lastFeeOperationTime)).div(SECONDS_IN_ONE_MINUTE);\n    }\n\n    // --- 'require' wrapper functions ---\n\n    function _requireCallerIsBorrowerOperations() internal view {\n        require(msg.sender == borrowerOperationsAddress, \"TroveManager: Caller is not the BorrowerOperations contract\");\n    }\n\n    function _requireTroveisActive(address _borrower) internal view {\n        require(Troves[_borrower].status == Status.active, \"TroveManager: Trove does not exist or is closed\");\n    }\n\n    function _requireLUSDBalanceCoversRedemption(address _redeemer, uint _amount) internal view {\n        require(lusdToken.balanceOf(_redeemer) >= _amount, \"TroveManager: Requested redemption amount must be <= user's LUSD token balance\");\n    }\n\n    function _requireMoreThanOneTroveInSystem(uint TroveOwnersArrayLength) internal view {\n        require (TroveOwnersArrayLength > 1 && sortedTroves.getSize() > 1, \"TroveManager: Only one trove in the system\");\n    }\n\n    function _requireAmountGreaterThanZero(uint _amount) internal pure {\n        require(_amount > 0, \"TroveManager: Amount must be greater than zero\");\n    }\n\n    // --- Trove property getters ---\n\n    function getTroveStatus(address _borrower) external view override returns (uint) {\n        return uint(Troves[_borrower].status);\n    }\n\n    function getTroveStake(address _borrower) external view override returns (uint) {\n        return Troves[_borrower].stake;\n    }\n\n    function getTroveDebt(address _borrower) external view override returns (uint) {\n        return Troves[_borrower].debt;\n    }\n\n    function getTroveColl(address _borrower) external view override returns (uint) {\n        return Troves[_borrower].coll;\n    }\n\n    // --- Trove property setters, called by BorrowerOperations ---\n\n    function setTroveStatus(address _borrower, uint _num) external override {\n        _requireCallerIsBorrowerOperations();\n        Troves[_borrower].status = Status(_num);\n    }\n\n    function increaseTroveColl(address _borrower, uint _collIncrease) external override returns (uint) {\n        _requireCallerIsBorrowerOperations();\n        uint newColl = Troves[_borrower].coll.add(_collIncrease);\n        Troves[_borrower].coll = newColl;\n        return newColl;\n    }\n\n    function decreaseTroveColl(address _borrower, uint _collDecrease) external override returns (uint) {\n        _requireCallerIsBorrowerOperations();\n        uint newColl = Troves[_borrower].coll.sub(_collDecrease);\n        Troves[_borrower].coll = newColl;\n        return newColl;\n    }\n\n    function increaseTroveDebt(address _borrower, uint _debtIncrease) external override returns (uint) {\n        _requireCallerIsBorrowerOperations();\n        uint newDebt = Troves[_borrower].debt.add(_debtIncrease);\n        Troves[_borrower].debt = newDebt;\n        return newDebt;\n    }\n\n    function decreaseTroveDebt(address _borrower, uint _debtDecrease) external override returns (uint) {\n        _requireCallerIsBorrowerOperations();\n        uint newDebt = Troves[_borrower].debt.sub(_debtDecrease);\n        Troves[_borrower].debt = newDebt;\n        return newDebt;\n    }\n}",
        "function": "decayBaseRateFromBorrowing()",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-Liquity/dev-f0df3efa5a5f05b205752184cfce107c5bd6e06c/packages/contracts/contracts/TroveManager.sol",
        "vulnerability": "Dependence on predictable environment variable (SWC 116)",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract TroveManager is LiquityBase, Ownable, ITroveManager {\n\n    // --- Connected contract declarations ---\n\n    address public borrowerOperationsAddress;\n\n    IPool public activePool;\n\n    IPool public defaultPool;\n\n    IStabilityPool public stabilityPool;\n\n    ICollSurplusPool collSurplusPool;\n\n    ILUSDToken public lusdToken;\n\n    IPriceFeed public priceFeed;\n\n    ILQTYStaking public lqtyStaking;\n    address public lqtyStakingAddress;\n\n    // A doubly linked list of Troves, sorted by their sorted by their collateral ratios\n    ISortedTroves public sortedTroves;\n\n    // --- Data structures ---\n\n    uint constant public SECONDS_IN_ONE_MINUTE = 60;\n    uint constant public MINUTE_DECAY_FACTOR = 999832508430720967;  // 18 digit decimal. Corresponds to an hourly decay factor of 0.99\n\n    /* \n    * BETA: 18 digit decimal. Parameter by which to divide the redeemed fraction, in order to calc the new base rate from a redemption. \n    * Corresponds to (1 / ALPHA) in the white paper. \n    */\n    uint constant public BETA = 2;\n\n    uint public baseRate;\n\n    // The timestamp of the latest fee operation (redemption or new LUSD issuance) \n    uint public lastFeeOperationTime;\n\n    enum Status { nonExistent, active, closed }\n\n    // Store the necessary data for a trove\n    struct Trove {\n        uint debt;\n        uint coll;\n        uint stake;\n        Status status;\n        uint128 arrayIndex;\n    }\n\n    mapping (address => Trove) public Troves;\n\n    uint public totalStakes;\n\n    // Snapshot of the value of totalStakes, taken immediately after the latest liquidation\n    uint public totalStakesSnapshot;\n\n    // Snapshot of the total collateral across the ActivePool and DefaultPool, immediately after the latest liquidation.\n    uint public totalCollateralSnapshot;\n\n    /*\n    * L_ETH and L_LUSDDebt track the sums of accumulated liquidation rewards per unit staked. During its lifetime, each stake earns:\n    *\n    * An ETH gain of ( stake * [L_ETH - L_ETH(0)] )\n    * A LUSDDebt increase  of ( stake * [L_LUSDDebt - L_LUSDDebt(0)] )\n    *\n    * Where L_ETH(0) and L_LUSDDebt(0) are snapshots of L_ETH and L_LUSDDebt for the active Trove taken at the instant the stake was made\n    */\n    uint public L_ETH;\n    uint public L_LUSDDebt;\n\n    // Map addresses with active troves to their RewardSnapshot\n    mapping (address => RewardSnapshot) public rewardSnapshots;\n\n    // Object containing the ETH and LUSD snapshots for a given active trove\n    struct RewardSnapshot { uint ETH; uint LUSDDebt;}\n\n    // Array of all active trove addresses - used to to compute an approximate hint off-chain, for the sorted list insertion\n    address[] public TroveOwners;\n\n    // Error trackers for the trove redistribution calculation\n    uint public lastETHError_Redistribution;\n    uint public lastLUSDDebtError_Redistribution;\n\n    /* \n    * --- Variable container structs for liquidations ---\n    *\n    * These structs are used to hold, return and assign variables inside the liquidation functions,\n    * in order to avoid the error: \"CompilerError: Stack too deep\". \n    **/\n\n    struct LocalVariables_OuterLiquidationFunction {\n        uint price;\n        uint LUSDInStabPool;\n        bool recoveryModeAtStart;\n        uint liquidatedDebt;\n        uint liquidatedColl;\n    }\n\n    struct LocalVariables_InnerSingleLiquidateFunction {\n        uint collToLiquidate;\n        uint pendingDebtReward;\n        uint pendingCollReward;\n    }\n\n    struct LocalVariables_LiquidationSequence {\n        uint remainingLUSDInStabPool;\n        uint i;\n        uint ICR;\n        address user;\n        bool backToNormalMode;\n        uint entireSystemDebt;\n        uint entireSystemColl;\n    }\n\n    struct LiquidationValues {\n        uint entireTroveDebt;\n        uint entireTroveColl;\n        uint collGasCompensation;\n        uint LUSDGasCompensation;\n        uint debtToOffset;\n        uint collToSendToSP;\n        uint debtToRedistribute;\n        uint collToRedistribute;\n        address partialAddr;\n        uint partialNewDebt;\n        uint partialNewColl;\n        address partialUpperHint;\n        address partialLowerHint;\n    }\n\n    struct LiquidationTotals {\n        uint totalCollInSequence;\n        uint totalDebtInSequence;\n        uint totalCollGasCompensation;\n        uint totalLUSDGasCompensation;\n        uint totalDebtToOffset;\n        uint totalCollToSendToSP;\n        uint totalDebtToRedistribute;\n        uint totalCollToRedistribute;\n        address partialAddr;\n        uint partialNewDebt;\n        uint partialNewColl;\n        address partialUpperHint;\n        address partialLowerHint;\n    }\n\n    // --- Variable container structs for redemptions ---\n\n    struct RedemptionTotals {\n        uint totalLUSDToRedeem;\n        uint totalETHDrawn;\n        uint ETHFee;\n        uint ETHToSendToRedeemer;\n        uint decayedBaseRate;\n    }\n\n    struct SingleRedemptionValues {\n        uint LUSDLot;\n        uint ETHLot;\n    }\n\n    // --- Events ---\n\n    event Liquidation(uint _liquidatedDebt, uint _liquidatedColl, uint _collGasCompensation, uint _LUSDGasCompensation);\n    event Redemption(uint _attemptedLUSDAmount, uint _actualLUSDAmount, uint _ETHSent, uint _ETHFee);\n\n    enum TroveManagerOperation {\n        applyPendingRewards,\n        liquidateInNormalMode,\n        liquidateInRecoveryMode,\n        partiallyLiquidateInRecoveryMode,\n        redeemCollateral\n    }\n\n    event TroveCreated(address indexed _borrower, uint _arrayIndex);\n    event TroveUpdated(address indexed _borrower, uint _debt, uint _coll, uint _stake, TroveManagerOperation _operation);\n    event TroveLiquidated(address indexed _borrower, uint _debt, uint _coll, TroveManagerOperation _operation);\n\n    // --- Dependency setter ---\n\n    function setAddresses(\n        address _borrowerOperationsAddress,\n        address _activePoolAddress,\n        address _defaultPoolAddress,\n        address _stabilityPoolAddress,\n        address _collSurplusPoolAddress,\n        address _priceFeedAddress,\n        address _lusdTokenAddress,\n        address _sortedTrovesAddress,\n        address _lqtyStakingAddress\n    )\n        external\n        override\n        onlyOwner\n    {\n        borrowerOperationsAddress = _borrowerOperationsAddress;\n        activePool = IPool(_activePoolAddress);\n        defaultPool = IPool(_defaultPoolAddress);\n        stabilityPool = IStabilityPool(_stabilityPoolAddress);\n        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);\n        priceFeed = IPriceFeed(_priceFeedAddress);\n        lusdToken = ILUSDToken(_lusdTokenAddress);\n        sortedTroves = ISortedTroves(_sortedTrovesAddress);\n        lqtyStakingAddress = _lqtyStakingAddress;\n        lqtyStaking = ILQTYStaking(_lqtyStakingAddress);\n\n        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);\n        emit ActivePoolAddressChanged(_activePoolAddress);\n        emit DefaultPoolAddressChanged(_defaultPoolAddress);\n        emit StabilityPoolAddressChanged(_stabilityPoolAddress);\n        emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);\n        emit PriceFeedAddressChanged(_priceFeedAddress);\n        emit LUSDTokenAddressChanged(_lusdTokenAddress);\n        emit SortedTrovesAddressChanged(_sortedTrovesAddress);\n        emit LQTYStakingAddressChanged(_lqtyStakingAddress);\n\n        _renounceOwnership();\n    }\n\n    // --- Getters ---\n\n    function getTroveOwnersCount() external view override returns (uint) {\n        return TroveOwners.length;\n    }\n\n    function getTroveFromTroveOwnersArray(uint _index) external view override returns (address) {\n        return TroveOwners[_index];\n    }\n\n    // --- Trove Liquidation functions ---\n\n    // Single liquidation function. Closes the trove if its ICR is lower than the minimum collateral ratio. \n    function liquidate(address _borrower) external override {\n        _requireTroveisActive(_borrower);\n\n        address[] memory borrowers = new address[](1);\n        borrowers[0] = _borrower;\n        batchLiquidateTroves(borrowers);\n    }\n\n    // --- Inner single liquidation functions ---\n\n    // Liquidate one trove, in Normal Mode.\n    function _liquidateNormalMode(address _borrower, uint _LUSDInStabPool) internal returns (LiquidationValues memory V) {\n        LocalVariables_InnerSingleLiquidateFunction memory L;\n\n        (V.entireTroveDebt,\n        V.entireTroveColl,\n        L.pendingDebtReward,\n        L.pendingCollReward) = getEntireDebtAndColl(_borrower);\n\n        _movePendingTroveRewardsToActivePool(L.pendingDebtReward, L.pendingCollReward);\n        _removeStake(_borrower);\n\n        V.collGasCompensation = _getCollGasCompensation(V.entireTroveColl);\n        V.LUSDGasCompensation = LUSD_GAS_COMPENSATION;\n        uint collToLiquidate = V.entireTroveColl.sub(V.collGasCompensation);\n\n        (V.debtToOffset,\n        V.collToSendToSP,\n        V.debtToRedistribute,\n        V.collToRedistribute) = _getOffsetAndRedistributionVals(V.entireTroveDebt, collToLiquidate, _LUSDInStabPool);\n\n        _closeTrove(_borrower);\n        emit TroveLiquidated(_borrower, V.entireTroveDebt, V.entireTroveColl, TroveManagerOperation.liquidateInNormalMode);\n\n        return V;\n    }\n\n    // Liquidate one trove, in Recovery Mode.\n    function _liquidateRecoveryMode(address _borrower, uint _ICR, uint _LUSDInStabPool, uint _TCR) internal returns (LiquidationValues memory V) {\n        LocalVariables_InnerSingleLiquidateFunction memory L;\n        \n        if (TroveOwners.length <= 1) { return V; } // don't liquidate if last trove\n\n        (V.entireTroveDebt,\n        V.entireTroveColl,\n        L.pendingDebtReward,\n        L.pendingCollReward) = getEntireDebtAndColl(_borrower);\n\n        _movePendingTroveRewardsToActivePool(L.pendingDebtReward, L.pendingCollReward);\n\n        V.collGasCompensation = _getCollGasCompensation(V.entireTroveColl);\n        // In case of a partial liquidation, V.LUSDGasCompensation will be overwritten to zero, in the third branch below\n        V.LUSDGasCompensation = LUSD_GAS_COMPENSATION;\n        L.collToLiquidate = V.entireTroveColl.sub(V.collGasCompensation);\n\n        // If ICR <= 100%, purely redistribute the Trove across all active Troves\n        if (_ICR <= _100pct) {\n            _removeStake(_borrower);\n\n            V.debtToOffset = 0;\n            V.collToSendToSP = 0;\n            V.debtToRedistribute = V.entireTroveDebt;\n            V.collToRedistribute = L.collToLiquidate;\n\n            _closeTrove(_borrower);\n            emit TroveLiquidated(_borrower, V.entireTroveDebt, V.entireTroveColl, TroveManagerOperation.liquidateInRecoveryMode);\n\n        // If 100% < ICR < MCR, offset as much as possible, and redistribute the remainder\n        } else if ((_ICR > _100pct) && (_ICR < MCR)) {\n            _removeStake(_borrower);\n\n            (V.debtToOffset,\n            V.collToSendToSP,\n            V.debtToRedistribute,\n            V.collToRedistribute) = _getOffsetAndRedistributionVals(V.entireTroveDebt, L.collToLiquidate, _LUSDInStabPool);\n\n            _closeTrove(_borrower);\n            emit TroveLiquidated(_borrower, V.entireTroveDebt, V.entireTroveColl, TroveManagerOperation.liquidateInRecoveryMode);\n\n        /* \n        * If 110% <= ICR < current TCR (accounting for the preceding liquidations in the current sequence)\n        * and there is LUSD in the Stability Pool, only offset it as much as possible, with no redistribution.\n        */\n        } else if ((_ICR >= MCR) && (_ICR < _TCR)) {\n            assert(_LUSDInStabPool != 0);\n\n            _removeStake(_borrower);\n            \n            V = _getFullOrPartialOffsetVals(_borrower, V.entireTroveDebt, V.entireTroveColl, _LUSDInStabPool);\n\n            _closeTrove(_borrower);\n        }\n        else if (_ICR >= _TCR) {\n            LiquidationValues memory zeroVals;\n            return zeroVals;\n        }\n\n        return V;\n    }\n\n    /* In a full liquidation, returns the values for a trove's coll and debt to be offset, and coll and debt to be \n    * redistributed to active troves. \n    */\n    function _getOffsetAndRedistributionVals\n    (\n        uint _debt,\n        uint _coll,\n        uint _LUSDInStabPool\n    )\n        internal\n        pure\n        returns (uint debtToOffset, uint collToSendToSP, uint debtToRedistribute, uint collToRedistribute)\n    {\n        if (_LUSDInStabPool > 0) {\n        /* \n        * Offset as much debt & collateral as possible against the Stability Pool, and redistribute the remainder\n        * between all active troves.\n        *\n        *  If the trove's debt is larger than the deposited LUSD in the Stability Pool:\n        *\n        *  - Offset an amount of the trove's debt equal to the LUSD in the Stability Pool\n        *  - Send a fraction of the trove's collateral to the Stability Pool, equal to the fraction of its offset debt\n        *\n        */\n            debtToOffset = LiquityMath._min(_debt, _LUSDInStabPool);\n            collToSendToSP = _coll.mul(debtToOffset).div(_debt);\n            debtToRedistribute = _debt.sub(debtToOffset);\n            collToRedistribute = _coll.sub(collToSendToSP);\n        } else {\n            debtToOffset = 0;\n            collToSendToSP = 0;\n            debtToRedistribute = _debt;\n            collToRedistribute = _coll;\n        }\n    }\n\n    /*\n    *  If it is a full offset, get its offset coll/debt and ETH gas comp, and close the trove.\n    *\n    * If it is a partial liquidation, get its offset coll/debt and ETH gas comp, and its new coll/debt, and its re-insertion hints.\n    */\n    function _getFullOrPartialOffsetVals\n    (\n        address _borrower,\n        uint _entireTroveDebt,\n        uint _entireTroveColl,\n        uint _LUSDInStabPool\n    )\n        internal\n        returns (LiquidationValues memory V)\n    {\n        V.entireTroveDebt = _entireTroveDebt;\n        V.entireTroveColl = _entireTroveColl;\n\n        // When Stability Pool can fully absorb the trove's debt, perform a full offset\n        if (_entireTroveDebt <= _LUSDInStabPool) {\n            V.collGasCompensation = _getCollGasCompensation(_entireTroveColl);\n            V.LUSDGasCompensation = LUSD_GAS_COMPENSATION;\n\n            V.debtToOffset = _entireTroveDebt;\n            V.collToSendToSP = _entireTroveColl.sub(V.collGasCompensation);\n            V.debtToRedistribute = 0;\n            V.collToRedistribute = 0;\n\n            emit TroveLiquidated(_borrower, _entireTroveDebt, _entireTroveColl, TroveManagerOperation.liquidateInRecoveryMode);\n        }\n        /* \n        * When trove's debt is greater than the Stability Pool, perform a partial liquidation: offset as much as possible,\n        * and do not redistribute the remainder. The trove remains active, with a reduced collateral and debt.\n        *\n        * ETH gas compensation is based on and drawn from the collateral fraction that corresponds to the partial offset. \n        * LUSD gas compensation is left untouched. \n        *\n        * Since ETH gas comp is drawn purely from the *liquidated* portion, the trove is left with the same ICR as before the \n        * liquidation.\n        */\n        else if (_entireTroveDebt > _LUSDInStabPool) {\n            // Remaining debt in the trove is lower-bounded by the trove's gas compensation\n            V.partialNewDebt = LiquityMath._max(_entireTroveDebt.sub(_LUSDInStabPool), LUSD_GAS_COMPENSATION);\n          \n            V.debtToOffset = _entireTroveDebt.sub(V.partialNewDebt);\n\n            uint collFraction = _entireTroveColl.mul(V.debtToOffset).div(_entireTroveDebt);\n            V.collGasCompensation = _getCollGasCompensation(collFraction);\n          \n            V.LUSDGasCompensation = 0;  // LUSD gas compensation remains untouched\n\n            V.collToSendToSP = collFraction.sub(V.collGasCompensation);\n            V.collToRedistribute = 0;\n            V.debtToRedistribute = 0;\n\n            V.partialAddr = _borrower;\n            V.partialNewColl = _entireTroveColl.sub(collFraction);\n\n            // Get the partial trove's neighbours, so we can re-insert it later to the same position\n            V.partialUpperHint = sortedTroves.getPrev(_borrower);  \n            V.partialLowerHint = sortedTroves.getNext(_borrower);\n        }\n    }\n\n    /* \n    * Liquidate a sequence of troves. Closes a maximum number of n under-collateralized Troves,\n    * starting from the one with the lowest collateral ratio in the system, and moving upwards\n    */\n    function liquidateTroves(uint _n) external override {\n        LocalVariables_OuterLiquidationFunction memory L;\n\n        LiquidationTotals memory T;\n\n        L.price = priceFeed.getPrice();\n        L.LUSDInStabPool = stabilityPool.getTotalLUSDDeposits();\n        L.recoveryModeAtStart = checkRecoveryMode();\n\n        // Perform the appropriate liquidation sequence - tally the values, and obtain their totals\n        if (L.recoveryModeAtStart == true) {\n            T = _getTotalsFromLiquidateTrovesSequence_RecoveryMode(L.price, L.LUSDInStabPool, _n);\n        } else if (L.recoveryModeAtStart == false) {\n            T = _getTotalsFromLiquidateTrovesSequence_NormalMode(L.price, L.LUSDInStabPool, _n);\n        }\n\n        // Move liquidated ETH and LUSD to the appropriate pools\n        stabilityPool.offset(T.totalDebtToOffset, T.totalCollToSendToSP);\n        _redistributeDebtAndColl(T.totalDebtToRedistribute, T.totalCollToRedistribute);\n\n        // Update system snapshots and the final partially liquidated trove, if there is one\n        _updateSystemSnapshots_excludeCollRemainder(T.partialNewColl.add(T.totalCollGasCompensation));\n        _updatePartiallyLiquidatedTrove(T.partialAddr, T.partialNewDebt, T.partialNewColl, T.partialUpperHint, T. partialLowerHint, L.price);\n\n        L.liquidatedDebt = T.totalDebtInSequence.sub(T.partialNewDebt);\n        L.liquidatedColl = T.totalCollInSequence.sub(T.totalCollGasCompensation).sub(T.partialNewColl);\n        emit Liquidation(L.liquidatedDebt, L.liquidatedColl, T.totalCollGasCompensation, T.totalLUSDGasCompensation);\n\n        // Send gas compensation to caller\n        _sendGasCompensation(msg.sender, T.totalLUSDGasCompensation, T.totalCollGasCompensation);\n    }\n\n    /*\n    * This function is used when the liquidateTroves sequence starts during Recovery Mode. However, it\n    * handle the case where the system *leaves* Recovery Mode, part way through the liquidation sequence\n    */\n    function _getTotalsFromLiquidateTrovesSequence_RecoveryMode\n    (\n        uint _price,\n        uint _LUSDInStabPool,\n        uint _n\n    )\n        internal\n        returns(LiquidationTotals memory T)\n    {\n        LocalVariables_LiquidationSequence memory L;\n        LiquidationValues memory V;\n\n        L.remainingLUSDInStabPool = _LUSDInStabPool;\n        L.backToNormalMode = false;\n        L.entireSystemDebt = activePool.getLUSDDebt().add(defaultPool.getLUSDDebt());\n        L.entireSystemColl = activePool.getETH().add(defaultPool.getETH());\n\n        L.i = 0;\n        while (L.i < _n) {\n            L.user = sortedTroves.getLast();\n            L.ICR = getCurrentICR(L.user, _price);\n\n            if (L.backToNormalMode == false) {\n                // Break the loop if ICR is greater than MCR and Stability Pool is empty\n                if (L.ICR >= MCR && L.remainingLUSDInStabPool == 0) { break; }\n\n                uint TCR = LiquityMath._computeCR(L.entireSystemColl, L.entireSystemDebt, _price);\n        \n                V = _liquidateRecoveryMode(L.user, L.ICR, L.remainingLUSDInStabPool, TCR);\n\n                // Update aggregate trackers\n                L.remainingLUSDInStabPool = L.remainingLUSDInStabPool.sub(V.debtToOffset);\n                L.entireSystemDebt = L.entireSystemDebt.sub(V.debtToOffset);\n                L.entireSystemColl = L.entireSystemColl.sub(V.collToSendToSP);\n\n                // Add liquidation values to their respective running totals\n                T = _addLiquidationValuesToTotals(T, V);\n\n                // Break the loop if it was a partial liquidation\n                if (V.partialAddr != address(0)) {break;}\n\n                L.backToNormalMode = !_checkPotentialRecoveryMode(L.entireSystemColl, L.entireSystemDebt, _price);\n            }\n            else if (L.backToNormalMode == true && L.ICR < MCR) {\n                V = _liquidateNormalMode(L.user, L.remainingLUSDInStabPool);\n\n                L.remainingLUSDInStabPool = L.remainingLUSDInStabPool.sub(V.debtToOffset);\n\n                // Add liquidation values to their respective running totals\n                T = _addLiquidationValuesToTotals(T, V);\n\n            }  else break;  // break if the loop reaches a Trove with ICR >= MCR\n\n            // Break the loop if it reaches the first Trove in the sorted list\n            if (L.user == sortedTroves.getFirst()) { break; }\n\n            L.i++;\n        }\n    }\n\n    function _getTotalsFromLiquidateTrovesSequence_NormalMode\n    (\n        uint _price,\n        uint _LUSDInStabPool,\n        uint _n\n    )\n        internal\n        returns(LiquidationTotals memory T)\n    {\n        LocalVariables_LiquidationSequence memory L;\n        LiquidationValues memory V;\n\n        L.remainingLUSDInStabPool = _LUSDInStabPool;\n\n        L.i = 0;\n        while (L.i < _n) {\n            L.user = sortedTroves.getLast();\n            L.ICR = getCurrentICR(L.user, _price);\n\n            if (L.ICR < MCR) {\n                V = _liquidateNormalMode(L.user, L.remainingLUSDInStabPool);\n\n                L.remainingLUSDInStabPool = L.remainingLUSDInStabPool.sub(V.debtToOffset);\n\n                // Add liquidation values to their respective running totals\n                T = _addLiquidationValuesToTotals(T, V);\n\n            } else break;  // break if the loop reaches a Trove with ICR >= MCR\n\n            // Break the loop if it reaches the first Trove in the sorted list\n            if (L.user == sortedTroves.getFirst()) { break; }\n            L.i++;\n        }\n    }\n\n    /* \n    * Attempt to liquidate a custom list of troves provided by the caller. The liquidation sequence stops if\n    * a partial liquidation is performed, so it's up to the caller to order the troves in the _troveArray parameter.\n    */\n    function batchLiquidateTroves(address[] memory _troveArray) public override {\n        require(_troveArray.length != 0, \"TroveManager: Calldata address array must not be empty\");\n\n        LocalVariables_OuterLiquidationFunction memory L;\n        LiquidationTotals memory T;\n\n        L.price = priceFeed.getPrice();\n        L.LUSDInStabPool = stabilityPool.getTotalLUSDDeposits();\n        L.recoveryModeAtStart = checkRecoveryMode();\n\n        // Perform the appropriate liquidation sequence - tally values and obtain their totals.\n        if (L.recoveryModeAtStart == true) {\n           T = _getTotalFromBatchLiquidate_RecoveryMode(L.price, L.LUSDInStabPool, _troveArray);\n        } else if (L.recoveryModeAtStart == false) {\n            T = _getTotalsFromBatchLiquidate_NormalMode(L.price, L.LUSDInStabPool, _troveArray);\n        }\n\n        // Move liquidated ETH and LUSD to the appropriate pools\n        stabilityPool.offset(T.totalDebtToOffset, T.totalCollToSendToSP);\n        _redistributeDebtAndColl(T.totalDebtToRedistribute, T.totalCollToRedistribute);\n\n        // Update system snapshots and the final partially liquidated trove, if there is one\n        _updateSystemSnapshots_excludeCollRemainder(T.partialNewColl.add(T.totalCollGasCompensation));\n        _updatePartiallyLiquidatedTrove(T.partialAddr, T.partialNewDebt, T.partialNewColl, T.partialUpperHint, T. partialLowerHint, L.price);\n\n        L.liquidatedDebt = T.totalDebtInSequence.sub(T.partialNewDebt);\n        L.liquidatedColl = T.totalCollInSequence.sub(T.totalCollGasCompensation).sub(T.partialNewColl);\n        emit Liquidation(L.liquidatedDebt, L.liquidatedColl, T.totalCollGasCompensation, T.totalLUSDGasCompensation);\n\n        // Send gas compensation to caller\n        _sendGasCompensation(msg.sender, T.totalLUSDGasCompensation, T.totalCollGasCompensation);\n    }\n\n    /* \n    * This function is used when the batch liquidation sequence starts during Recovery Mode. However, it\n    * handle the case where the system *leaves* Recovery Mode, part way through the liquidation sequence\n    */\n    function _getTotalFromBatchLiquidate_RecoveryMode\n    (\n        uint _price,\n        uint _LUSDInStabPool,\n        address[] memory _troveArray)\n        internal\n        returns(LiquidationTotals memory T)\n    {\n        LocalVariables_LiquidationSequence memory L;\n        LiquidationValues memory V;\n\n        L.remainingLUSDInStabPool = _LUSDInStabPool;\n        L.backToNormalMode = false;\n        L.entireSystemDebt = activePool.getLUSDDebt().add(defaultPool.getLUSDDebt());\n        L.entireSystemColl = activePool.getETH().add(defaultPool.getETH());\n\n        L.i = 0;\n        for (L.i = 0; L.i < _troveArray.length; L.i++) {\n            L.user = _troveArray[L.i];\n            L.ICR = getCurrentICR(L.user, _price);\n\n            if (L.backToNormalMode == false) {\n\n                // Skip this trove if ICR is greater than MCR and Stability Pool is empty\n                if (L.ICR >= MCR && L.remainingLUSDInStabPool == 0) { continue; }\n\n                uint TCR = LiquityMath._computeCR(L.entireSystemColl, L.entireSystemDebt, _price);\n\n                V = _liquidateRecoveryMode(L.user, L.ICR, L.remainingLUSDInStabPool, TCR);\n\n                // Update aggregate trackers\n                L.remainingLUSDInStabPool = L.remainingLUSDInStabPool.sub(V.debtToOffset);\n                L.entireSystemDebt = L.entireSystemDebt.sub(V.debtToOffset);\n                L.entireSystemColl = L.entireSystemColl.sub(V.collToSendToSP);\n\n                // Add liquidation values to their respective running totals\n                T = _addLiquidationValuesToTotals(T, V);\n\n                // Break the loop if it was a partial liquidation\n                if (V.partialAddr != address(0)) { break; }\n\n                L.backToNormalMode = !_checkPotentialRecoveryMode(L.entireSystemColl, L.entireSystemDebt, _price);\n            }\n\n            else if (L.backToNormalMode == true && L.ICR < MCR) {\n                V = _liquidateNormalMode(L.user, L.remainingLUSDInStabPool);\n                L.remainingLUSDInStabPool = L.remainingLUSDInStabPool.sub(V.debtToOffset);\n\n                // Add liquidation values to their respective running totals\n                T = _addLiquidationValuesToTotals(T, V);\n            }\n        }\n    }\n\n    function _getTotalsFromBatchLiquidate_NormalMode\n    (\n        uint _price,\n        uint _LUSDInStabPool,\n        address[] memory _troveArray\n    )\n        internal\n        returns(LiquidationTotals memory T)\n    {\n        LocalVariables_LiquidationSequence memory L;\n        LiquidationValues memory V;\n\n        L.remainingLUSDInStabPool = _LUSDInStabPool;\n\n        for (L.i = 0; L.i < _troveArray.length; L.i++) {\n            L.user = _troveArray[L.i];\n            L.ICR = getCurrentICR(L.user, _price);\n\n            if (L.ICR < MCR) {\n                V = _liquidateNormalMode(L.user, L.remainingLUSDInStabPool);\n                L.remainingLUSDInStabPool = L.remainingLUSDInStabPool.sub(V.debtToOffset);\n\n                // Add liquidation values to their respective running totals\n                T = _addLiquidationValuesToTotals(T, V);\n            }\n        }\n    }\n\n    // --- Liquidation helper functions ---\n\n    function _addLiquidationValuesToTotals(LiquidationTotals memory T1, LiquidationValues memory V)\n    internal pure returns(LiquidationTotals memory T2) {\n\n        // Tally all the values with their respective running totals\n        T2.totalCollGasCompensation = T1.totalCollGasCompensation.add(V.collGasCompensation);\n        T2.totalLUSDGasCompensation = T1.totalLUSDGasCompensation.add(V.LUSDGasCompensation);\n        T2.totalDebtInSequence = T1.totalDebtInSequence.add(V.entireTroveDebt);\n        T2.totalCollInSequence = T1.totalCollInSequence.add(V.entireTroveColl);\n        T2.totalDebtToOffset = T1.totalDebtToOffset.add(V.debtToOffset);\n        T2.totalCollToSendToSP = T1.totalCollToSendToSP.add(V.collToSendToSP);\n        T2.totalDebtToRedistribute = T1.totalDebtToRedistribute.add(V.debtToRedistribute);\n        T2.totalCollToRedistribute = T1.totalCollToRedistribute.add(V.collToRedistribute);\n\n        // Assign the address of the partially liquidated trove, and its new debt and coll values\n        T2.partialAddr = V.partialAddr;\n        T2.partialNewDebt = V.partialNewDebt;\n        T2.partialNewColl = V.partialNewColl;\n        T2.partialUpperHint = V.partialUpperHint;\n        T2.partialLowerHint = V.partialLowerHint;\n\n        return T2;\n    }\n\n    // Update the properties of the partially liquidated trove, and insert it back to the list\n    function _updatePartiallyLiquidatedTrove\n    (\n        address _borrower, \n        uint _newDebt, \n        uint _newColl, \n        address _upperHint,\n        address _lowerHint,\n        uint _price\n    ) \n        internal \n    {\n        if ( _borrower == address(0)) { return; }\n\n        Troves[_borrower].debt = _newDebt;\n        Troves[_borrower].coll = _newColl;\n        Troves[_borrower].status = Status.active;\n\n        _updateTroveRewardSnapshots(_borrower);\n        _updateStakeAndTotalStakes(_borrower);\n\n        uint ICR = getCurrentICR(_borrower, _price);\n\n        /* \n        * Insert to sorted list and add to TroveOwners array. The partially liquidated trove has the same\n        * ICR as it did before the liquidation, so insertion is O(1): in principle, its ICR does not change.\n        * In practice, due to rounding error, its ICR can change slightly - so re-insert, with its previous neighbours\n        * as hints.\n        */\n        sortedTroves.insert(_borrower, ICR, _price, _upperHint, _lowerHint);\n        _addTroveOwnerToArray(_borrower);\n        emit TroveUpdated(_borrower, _newDebt, _newColl, Troves[_borrower].stake, TroveManagerOperation.partiallyLiquidateInRecoveryMode);\n    }\n\n    function _sendGasCompensation(address _liquidator, uint _LUSD, uint _ETH) internal {\n        if (_LUSD > 0) {\n            lusdToken.returnFromPool(GAS_POOL_ADDRESS, _liquidator, _LUSD);\n        }\n\n        if (_ETH > 0) {\n            activePool.sendETH(_liquidator, _ETH);\n        }\n    }\n\n    // Move a Trove's pending debt and collateral rewards from distributions, from the Default Pool to the Active Pool\n    function _movePendingTroveRewardsToActivePool(uint _LUSD, uint _ETH) internal {\n        defaultPool.decreaseLUSDDebt(_LUSD);\n        activePool.increaseLUSDDebt(_LUSD);\n        defaultPool.sendETH(address(activePool), _ETH);\n    }\n\n    // --- Redemption functions ---\n\n    // Redeem as much collateral as possible from _borrower's Trove in exchange for LUSD up to _maxLUSDamount\n    function _redeemCollateralFromTrove(\n        address _borrower,\n        uint _maxLUSDamount,\n        uint _price,\n        address _partialRedemptionHint,\n        uint _partialRedemptionHintICR\n    )\n        internal returns (SingleRedemptionValues memory V)\n    {\n        // Determine the remaining amount (lot) to be redeemed, capped by the entire debt of the Trove minus the gas compensation\n        V.LUSDLot = LiquityMath._min(_maxLUSDamount, Troves[_borrower].debt.sub(LUSD_GAS_COMPENSATION));\n\n        // Get the ETHLot of equivalent value in USD\n        V.ETHLot = V.LUSDLot.mul(1e18).div(_price);\n\n        // Decrease the debt and collateral of the current Trove according to the LUSD lot and corresponding ETH to send\n        uint newDebt = (Troves[_borrower].debt).sub(V.LUSDLot);\n        uint newColl = (Troves[_borrower].coll).sub(V.ETHLot);\n\n        if (newDebt == LUSD_GAS_COMPENSATION) {\n            // No debt left in the Trove (except for the gas compensation), therefore the trove gets closed\n            _removeStake(_borrower);\n            _closeTrove(_borrower);\n            _redeemCloseTrove(_borrower, LUSD_GAS_COMPENSATION, newColl);\n\n        } else {\n            uint newICR = LiquityMath._computeCR(newColl, newDebt, _price);\n\n            // Check if the provided hint is fresh. If not, we bail since trying to reinsert without a good hint will almost\n            // certainly result in running out of gas.\n            if (newICR != _partialRedemptionHintICR) {\n                V.LUSDLot = 0;\n                V.ETHLot = 0;\n                return V;\n            }\n\n            sortedTroves.reInsert(_borrower, newICR, _price, _partialRedemptionHint, _partialRedemptionHint);\n\n            Troves[_borrower].debt = newDebt;\n            Troves[_borrower].coll = newColl;\n            _updateStakeAndTotalStakes(_borrower);\n        }\n        emit TroveUpdated(\n            _borrower,\n            newDebt, newColl,\n            Troves[_borrower].stake,\n            TroveManagerOperation.redeemCollateral\n        );\n        return V;\n    }\n\n    /* \n    * Called when a full redemption occurs, and closes the trove.\n    * The redeemer swaps (debt - 10) LUSD for (debt - 10) worth of ETH, so the 10 LUSD gas compensation left corresponds to the remaining debt.\n    * In order to close the trove, the 10 LUSD gas compensation is burned, and 10 debt is removed from the active pool.\n    * The debt recorded on the trove's struct is zero'd elswhere, in _closeTrove.\n    * Any surplus ETH left in the trove, is sent to the Coll surplus pool, and can be later claimed by the borrower.\n    */ \n    function _redeemCloseTrove(address _borrower, uint _LUSD, uint _ETH) internal {\n        lusdToken.burn(GAS_POOL_ADDRESS, _LUSD);\n        // Update Active Pool LUSD, and send ETH to account\n        activePool.decreaseLUSDDebt(_LUSD);\n\n        // send ETH from Active Pool to CollSurplus Pool\n        collSurplusPool.accountSurplus(_borrower, _ETH);\n        activePool.sendETH(address(collSurplusPool), _ETH);\n    }\n\n    function _isValidFirstRedemptionHint(address _firstRedemptionHint, uint _price) internal view returns (bool) {\n        if (_firstRedemptionHint == address(0) ||\n            !sortedTroves.contains(_firstRedemptionHint) ||\n            getCurrentICR(_firstRedemptionHint, _price) < MCR\n        ) {\n            return false;\n        }\n\n        address nextTrove = sortedTroves.getNext(_firstRedemptionHint);\n        return nextTrove == address(0) || getCurrentICR(nextTrove, _price) < MCR;\n    }\n\n    /* Send _LUSDamount LUSD to the system and redeem the corresponding amount of collateral from as many Troves as are needed to fill the redemption\n    * request.  Applies pending rewards to a Trove before reducing its debt and coll.\n    *\n    * Note that if _amount is very large, this function can run out of gas, specially if traversed troves are small. This can be easily avoided by \n    * splitting the total _amount in appropriate chunks and calling the function multiple times.\n    * \n    * Param `_maxIterations` can also be provided, so the loop through Troves is capped (if its zero, it will be ignored).This makes it easier to \n    * avoid OOG for the frontend, as only knowing approximately the average cost of an iteration is enough, without needing to know the topology \n    * of the trove list. It also avoids the need to set the cap in stone in the contract, nor doing gas calculations, as both gas price and opcode \n    * costs can vary.\n    * \n    * All Troves that are redeemed from -- with the likely exception of the last one -- will end up with no debt left, therefore they will be closed.\n    * If the last Trove does have some remaining debt, it has a finite ICR, and the reinsertion could be anywhere in the list, therefore it requires a hint. \n    * A frontend should use getRedemptionHints() to calculate what the ICR of this Trove will be after redemption, and pass a hint for its position \n    * in the sortedTroves list along with the ICR value that the hint was found for.\n    * \n    * If another transaction modifies the list between calling getRedemptionHints() and passing the hints to redeemCollateral(), it\n    * is very likely that the last (partially) redeemed Trove would end up with a different ICR than what the hint is for. In this case the\n    * redemption will stop after the last completely redeemed Trove and the sender will keep the remaining LUSD amount, which they can attempt\n    * to redeem later.\n    */\n    function redeemCollateral(\n        uint _LUSDamount,\n        address _firstRedemptionHint,\n        address _partialRedemptionHint,\n        uint _partialRedemptionHintICR,\n        uint _maxIterations\n    )\n        external\n        override\n    {\n        uint activeDebt = activePool.getLUSDDebt();\n        uint defaultedDebt = defaultPool.getLUSDDebt();\n\n        RedemptionTotals memory T;\n\n        _requireAmountGreaterThanZero(_LUSDamount);\n        _requireLUSDBalanceCoversRedemption(msg.sender, _LUSDamount);\n\n        // Confirm redeemer's balance is less than total systemic debt\n        assert(lusdToken.balanceOf(msg.sender) <= (activeDebt.add(defaultedDebt)));\n\n        uint remainingLUSD = _LUSDamount;\n        uint price = priceFeed.getPrice();\n        address currentBorrower;\n\n        if (_isValidFirstRedemptionHint(_firstRedemptionHint, price)) {\n            currentBorrower = _firstRedemptionHint;\n        } else {\n            currentBorrower = sortedTroves.getLast();\n            // Find the first trove with ICR >= MCR\n            // SWC-104-Unchecked Call Return Value: L920\n            while (currentBorrower != address(0) && getCurrentICR(currentBorrower, price) < MCR) {\n                currentBorrower = sortedTroves.getPrev(currentBorrower);\n            }\n        }\n\n        // Loop through the Troves starting from the one with lowest collateral ratio until _amount of LUSD is exchanged for collateral\n        if (_maxIterations == 0) { _maxIterations = uint(-1); }\n        while (currentBorrower != address(0) && remainingLUSD > 0 && _maxIterations > 0) {\n            _maxIterations--;\n            // Save the address of the Trove preceding the current one, before potentially modifying the list\n            address nextUserToCheck = sortedTroves.getPrev(currentBorrower);\n\n            _applyPendingRewards(currentBorrower);\n            SingleRedemptionValues memory V = _redeemCollateralFromTrove(\n                currentBorrower,\n                remainingLUSD,\n                price,\n                _partialRedemptionHint,\n                _partialRedemptionHintICR\n            );\n\n            if (V.LUSDLot == 0) break; // Partial redemption hint got out-of-date, therefore we could not redeem from the last Trove\n\n            T.totalLUSDToRedeem  = T.totalLUSDToRedeem.add(V.LUSDLot);\n            T.totalETHDrawn = T.totalETHDrawn.add(V.ETHLot);\n\n            remainingLUSD = remainingLUSD.sub(V.LUSDLot);\n            currentBorrower = nextUserToCheck;\n        }\n\n        // Decay the baseRate due to time passed, and then increase it according to the size of this redemption\n        _updateBaseRateFromRedemption(T.totalETHDrawn, price);\n\n        // Calculate the ETH fee and send it to the LQTY staking contract\n        T.ETHFee = _getRedemptionFee(T.totalETHDrawn);\n        activePool.sendETH(lqtyStakingAddress, T.ETHFee);\n        lqtyStaking.increaseF_ETH(T.ETHFee);\n\n        T.ETHToSendToRedeemer = T.totalETHDrawn.sub(T.ETHFee);\n\n        // Burn the total LUSD that is cancelled with debt, and send the redeemed ETH to msg.sender\n        _activePoolRedeemCollateral(msg.sender, T.totalLUSDToRedeem, T.ETHToSendToRedeemer);\n\n        emit Redemption(_LUSDamount, T.totalLUSDToRedeem, T.totalETHDrawn, T.ETHFee);\n    }\n\n    // Burn the received LUSD, transfer the redeemed ETH to _redeemer and updates the Active Pool\n    function _activePoolRedeemCollateral(address _redeemer, uint _LUSD, uint _ETH) internal {\n        // Update Active Pool LUSD, and send ETH to account\n        lusdToken.burn(_redeemer, _LUSD);\n        activePool.decreaseLUSDDebt(_LUSD);\n\n        activePool.sendETH(_redeemer, _ETH);\n    }\n\n    // --- Helper functions ---\n\n\n    // Return the current collateral ratio (ICR) of a given Trove. Takes a trove's pending coll and debt rewards from redistributions into account.\n    function getCurrentICR(address _borrower, uint _price) public view override returns (uint) {\n        uint pendingETHReward = getPendingETHReward(_borrower);\n        uint pendingLUSDDebtReward = getPendingLUSDDebtReward(_borrower);\n\n        uint currentETH = Troves[_borrower].coll.add(pendingETHReward);\n        uint currentLUSDDebt = Troves[_borrower].debt.add(pendingLUSDDebtReward);\n\n        uint ICR = LiquityMath._computeCR(currentETH, currentLUSDDebt, _price);\n        return ICR;\n    }\n\n    function applyPendingRewards(address _borrower) external override {\n        _requireCallerIsBorrowerOperations();\n        return _applyPendingRewards(_borrower);\n    }\n\n    // Add the borrowers's coll and debt rewards earned from redistributions, to their Trove\n    function _applyPendingRewards(address _borrower) internal {\n        if (hasPendingRewards(_borrower)) {\n            _requireTroveisActive(_borrower);\n\n            // Compute pending rewards\n            uint pendingETHReward = getPendingETHReward(_borrower);\n            uint pendingLUSDDebtReward = getPendingLUSDDebtReward(_borrower);\n\n            // Apply pending rewards to trove's state\n            Troves[_borrower].coll = Troves[_borrower].coll.add(pendingETHReward);\n            Troves[_borrower].debt = Troves[_borrower].debt.add(pendingLUSDDebtReward);\n\n            _updateTroveRewardSnapshots(_borrower);\n\n            // Transfer from DefaultPool to ActivePool\n            _movePendingTroveRewardsToActivePool(pendingLUSDDebtReward, pendingETHReward);\n\n            emit TroveUpdated(\n                _borrower, \n                Troves[_borrower].debt, \n                Troves[_borrower].coll, \n                Troves[_borrower].stake, \n                TroveManagerOperation.applyPendingRewards\n            );\n        }\n    }\n\n    // Update borrower's snapshots of L_ETH and L_LUSDDebt to reflect the current values\n    function updateTroveRewardSnapshots(address _borrower) external override {\n        _requireCallerIsBorrowerOperations();\n       return _updateTroveRewardSnapshots(_borrower);\n    }\n\n    function _updateTroveRewardSnapshots(address _borrower) internal {\n        rewardSnapshots[_borrower].ETH = L_ETH;\n        rewardSnapshots[_borrower].LUSDDebt = L_LUSDDebt;\n    }\n\n    // Get the borrower's pending accumulated ETH reward, earned by their stake\n    function getPendingETHReward(address _borrower) public view override returns (uint) {\n        uint snapshotETH = rewardSnapshots[_borrower].ETH;\n        uint rewardPerUnitStaked = L_ETH.sub(snapshotETH);\n\n        if ( rewardPerUnitStaked == 0 ) { return 0; }\n\n        uint stake = Troves[_borrower].stake;\n\n        uint pendingETHReward = stake.mul(rewardPerUnitStaked).div(1e18);\n\n        return pendingETHReward;\n    }\n\n     // Get the borrower's pending accumulated LUSD reward, earned by their stake\n    function getPendingLUSDDebtReward(address _borrower) public view override returns (uint) {\n        uint snapshotLUSDDebt = rewardSnapshots[_borrower].LUSDDebt;\n        uint rewardPerUnitStaked = L_LUSDDebt.sub(snapshotLUSDDebt);\n\n        if ( rewardPerUnitStaked == 0 ) { return 0; }\n\n        uint stake =  Troves[_borrower].stake;\n\n        uint pendingLUSDDebtReward = stake.mul(rewardPerUnitStaked).div(1e18);\n\n        return pendingLUSDDebtReward;\n    }\n\n    function hasPendingRewards(address _borrower) public view override returns (bool) {\n        /* \n        * A Trove has pending rewards if its snapshot is less than the current rewards per-unit-staked sum:\n        * this indicates that rewards have occured since the snapshot was made, and the user therefore has\n        * pending rewards \n        */\n        return (rewardSnapshots[_borrower].ETH < L_ETH);\n    }\n\n    // Return the Troves entire debt and coll, including pending rewards from redistributions.\n    function getEntireDebtAndColl(\n        address _borrower\n    )\n        public\n        view\n        override\n        returns (uint debt, uint coll, uint pendingLUSDDebtReward, uint pendingETHReward)\n    {\n        debt = Troves[_borrower].debt;\n        coll = Troves[_borrower].coll;\n\n        pendingLUSDDebtReward = getPendingLUSDDebtReward(_borrower);\n        pendingETHReward = getPendingETHReward(_borrower);\n\n        debt = debt.add(pendingLUSDDebtReward);\n        coll = coll.add(pendingETHReward);\n    }\n\n    function removeStake(address _borrower) external override {\n        _requireCallerIsBorrowerOperations();\n        return _removeStake(_borrower);\n    }\n\n    // Remove borrower's stake from the totalStakes sum, and set their stake to 0\n    function _removeStake(address _borrower) internal {\n        uint stake = Troves[_borrower].stake;\n        totalStakes = totalStakes.sub(stake);\n        Troves[_borrower].stake = 0;\n    }\n\n    function updateStakeAndTotalStakes(address _borrower) external override returns (uint) {\n        _requireCallerIsBorrowerOperations();\n        return _updateStakeAndTotalStakes(_borrower);\n    }\n\n    // Update borrower's stake based on their latest collateral value\n    function _updateStakeAndTotalStakes(address _borrower) internal returns (uint) {\n        uint newStake = _computeNewStake(Troves[_borrower].coll);\n        uint oldStake = Troves[_borrower].stake;\n        Troves[_borrower].stake = newStake;\n        totalStakes = totalStakes.sub(oldStake).add(newStake);\n\n        return newStake;\n    }\n\n    // Calculate a new stake based on the snapshots of the totalStakes and totalCollateral taken at the last liquidation\n    function _computeNewStake(uint _coll) internal view returns (uint) {\n        uint stake;\n        if (totalCollateralSnapshot == 0) {\n            stake = _coll;\n        } else {\n            /*  \n            * The following assert() holds true because:\n            * - The system always contains >= 1 trove \n            * - When we close or liquidate a trove, we redistribute the pending rewards, so if all troves were closed/liquidated, \n            * rewards wouldve been emptied and totalCollateralSnapshot would be zero too.\n            */\n            assert(totalStakesSnapshot > 0);\n            stake = _coll.mul(totalStakesSnapshot).div(totalCollateralSnapshot);\n        }\n        return stake;\n    }\n\n    function _redistributeDebtAndColl(uint _debt, uint _coll) internal {\n        if (_debt == 0) { return; }\n\n        if (totalStakes > 0) {\n            /* \n            * Add distributed coll and debt rewards-per-unit-staked to the running totals.\n            * Division uses a \"feedback\" error correction, to keep the cumulative error in\n            * the  L_ETH and L_LUSDDebt state variables low. \n            */\n            uint ETHNumerator = _coll.mul(1e18).add(lastETHError_Redistribution);\n            uint LUSDDebtNumerator = _debt.mul(1e18).add(lastLUSDDebtError_Redistribution);\n\n            uint ETHRewardPerUnitStaked = ETHNumerator.div(totalStakes);\n            uint LUSDDebtRewardPerUnitStaked = LUSDDebtNumerator.div(totalStakes);\n\n            lastETHError_Redistribution = ETHNumerator.sub(ETHRewardPerUnitStaked.mul(totalStakes));\n            lastLUSDDebtError_Redistribution = LUSDDebtNumerator.sub(LUSDDebtRewardPerUnitStaked.mul(totalStakes));\n\n            L_ETH = L_ETH.add(ETHRewardPerUnitStaked);\n            L_LUSDDebt = L_LUSDDebt.add(LUSDDebtRewardPerUnitStaked);\n        }\n\n        // Transfer coll and debt from ActivePool to DefaultPool\n        activePool.decreaseLUSDDebt(_debt);\n        defaultPool.increaseLUSDDebt(_debt);\n        activePool.sendETH(address(defaultPool), _coll);\n    }\n\n    function closeTrove(address _borrower) external override {\n        _requireCallerIsBorrowerOperations();\n        return _closeTrove(_borrower);\n    }\n\n    function _closeTrove(address _borrower) internal {\n        uint TroveOwnersArrayLength = TroveOwners.length;\n        _requireMoreThanOneTroveInSystem(TroveOwnersArrayLength);\n\n        Troves[_borrower].status = Status.closed;\n        Troves[_borrower].coll = 0;\n        Troves[_borrower].debt = 0;\n\n        rewardSnapshots[_borrower].ETH = 0;\n        rewardSnapshots[_borrower].LUSDDebt = 0;\n\n        _removeTroveOwner(_borrower, TroveOwnersArrayLength);\n        sortedTroves.remove(_borrower);\n    }\n\n    /* \n    * Updates snapshots of system total stakes and total collateral, excluding a given collateral remainder from the calculation. \n    * Used in a liquidation sequence.\n    *\n    * The calculation excludes two portions of collateral that are in the ActivePool: \n    *\n    * 1) the total ETH gas compensation from the liquidation sequence\n    * 2) The remaining collateral in a partially liquidated trove (if one occurred)\n    *\n    * The ETH as compensation must be excluded as it is always sent out at the very end of the liquidation sequence.\n    *\n    * The partially liquidated trove's remaining collateral stays in the ActivePool, but it is excluded here so the system \n    * can take snapshots before the partially liquidated trove's stake is updated (based on these snapshots). This ensures\n    * the partial's new stake doesn't double-count its own remaining collateral.\n    *\n    */\n    function _updateSystemSnapshots_excludeCollRemainder(uint _collRemainder) internal {\n        totalStakesSnapshot = totalStakes;\n\n        uint activeColl = activePool.getETH();\n        uint liquidatedColl = defaultPool.getETH();\n        totalCollateralSnapshot = activeColl.sub(_collRemainder).add(liquidatedColl);\n    }\n\n    // Push the owner's address to the Trove owners list, and record the corresponding array index on the Trove struct\n    function addTroveOwnerToArray(address _borrower) external override returns (uint index) {\n        _requireCallerIsBorrowerOperations();\n        return _addTroveOwnerToArray(_borrower);\n    }\n\n    function _addTroveOwnerToArray(address _borrower) internal returns (uint128 index) {\n        require(TroveOwners.length < 2**128 - 1, \"TroveManager: TroveOwners array has maximum size of 2^128 - 1\");\n\n        // Push the Troveowner to the array\n        TroveOwners.push(_borrower);\n\n        // Record the index of the new Troveowner on their Trove struct\n        index = uint128(TroveOwners.length.sub(1));\n        Troves[_borrower].arrayIndex = index;\n\n        return index;\n    }\n\n    /* \n    * Remove a Trove owner from the TroveOwners array, not preserving array order. Removing owner 'B' does the following:\n    * [A B C D E] => [A E C D], and updates E's Trove struct to point to its new array index. \n    */\n    function _removeTroveOwner(address _borrower, uint TroveOwnersArrayLength) internal {\n        require(Troves[_borrower].status == Status.closed, \"TroveManager: Trove is still active\");\n\n        uint128 index = Troves[_borrower].arrayIndex;\n        uint length = TroveOwnersArrayLength;\n        uint idxLast = length.sub(1);\n\n        assert(index <= idxLast);\n\n        address addressToMove = TroveOwners[idxLast];\n\n        TroveOwners[index] = addressToMove;\n        Troves[addressToMove].arrayIndex = index;\n        TroveOwners.pop();\n    }\n\n    // --- Recovery Mode and TCR functions ---\n\n    function checkRecoveryMode() public view override returns (bool) {\n        uint TCR = getTCR();\n\n        if (TCR < CCR) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    // Check whether or not the system *would be* in Recovery Mode, given an ETH:USD price, and the entire system coll and debt.\n    function _checkPotentialRecoveryMode(\n        uint _entireSystemColl,\n        uint _entireSystemDebt,\n        uint _price\n    )\n        internal\n        pure\n    returns (bool)\n    {\n        uint TCR = LiquityMath._computeCR(_entireSystemColl, _entireSystemDebt, _price);\n        if (TCR < CCR) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n    // SWC-135-Code With No Effects: L1276-L1284\n    function getTCR() public view override returns (uint TCR) {\n        uint price = priceFeed.getPrice();\n        uint entireSystemColl = getEntireSystemColl();\n        uint entireSystemDebt = getEntireSystemDebt();\n\n        TCR = LiquityMath._computeCR(entireSystemColl, entireSystemDebt, price);\n\n        return TCR;\n    }\n    // SWC-135-Code With No Effects: L1286-L1291\n    function getEntireSystemColl() public view override returns (uint entireSystemColl) {\n        uint activeColl = activePool.getETH();\n        uint liquidatedColl = defaultPool.getETH();\n\n        return activeColl.add(liquidatedColl);\n    }\n\n    function getEntireSystemDebt() public view override returns (uint entireSystemDebt) {\n        uint activeDebt = activePool.getLUSDDebt();\n        uint closedDebt = defaultPool.getLUSDDebt();\n\n        return activeDebt.add(closedDebt);\n    }\n\n    // --- Redemption fee functions ---\n\n    /* \n    * This function has two impacts on the baseRate state variable:\n    * 1) decays the baseRate based on time passed since last redemption or LUSD borrowing operation.\n    * then,\n    * 2) increases the baseRate based on the amount redeemed, as a proportion of total supply\n    */\n    function _updateBaseRateFromRedemption(uint _ETHDrawn,  uint _price) internal returns (uint) {\n        uint decayedBaseRate = _calcDecayedBaseRate();\n\n        uint activeDebt = activePool.getLUSDDebt();\n        uint closedDebt = defaultPool.getLUSDDebt();\n        uint totalLUSDSupply = activeDebt.add(closedDebt);\n\n        /* Convert the drawn ETH back to LUSD at face value rate (1 LUSD:1 USD), in order to get\n        * the fraction of total supply that was redeemed at face value. */\n        uint redeemedLUSDFraction = _ETHDrawn.mul(_price).div(totalLUSDSupply);\n\n        uint newBaseRate = decayedBaseRate.add(redeemedLUSDFraction.div(BETA));\n\n        // Update the baseRate state variable\n        baseRate = newBaseRate < 1e18 ? newBaseRate : 1e18;  // cap baseRate at a maximum of 100%\n        assert(baseRate <= 1e18 && baseRate > 0); // Base rate is always non-zero after redemption\n\n        _updateLastFeeOpTime();\n\n        return baseRate;\n    }\n\n    function _getRedemptionFee(uint _ETHDrawn) internal view returns (uint) {\n       return baseRate.mul(_ETHDrawn).div(1e18);\n    }\n\n    // --- Borrowing fee functions ---\n\n    function getBorrowingFee(uint _LUSDDebt) external view override returns (uint) {\n        return _LUSDDebt.mul(baseRate).div(1e18);\n    }\n\n    // Updates the baseRate state variable based on time elapsed since the last redemption or LUSD borrowing operation.\n    function decayBaseRateFromBorrowing() external override {\n        _requireCallerIsBorrowerOperations();\n\n        baseRate = _calcDecayedBaseRate();\n        assert(baseRate <= 1e18);  // The baseRate can decay to 0\n\n        _updateLastFeeOpTime();\n    }\n\n    // --- Internal fee functions ---\n\n    // Update the last fee operation time only if time passed >= decay interval. This prevents base rate griefing.\n    function _updateLastFeeOpTime() internal {\n        uint timePassed = block.timestamp.sub(lastFeeOperationTime);\n\n        if (timePassed >= SECONDS_IN_ONE_MINUTE) {\n            lastFeeOperationTime = block.timestamp;\n        }\n    }\n\n    function _calcDecayedBaseRate() internal view returns (uint) {\n        uint minutesPassed = _minutesPassedSinceLastFeeOp();\n        uint decayFactor = LiquityMath._decPow(MINUTE_DECAY_FACTOR, minutesPassed);\n\n        return baseRate.mul(decayFactor).div(1e18);\n    }\n\n    function _minutesPassedSinceLastFeeOp() internal view returns (uint) {\n        return (block.timestamp.sub(lastFeeOperationTime)).div(SECONDS_IN_ONE_MINUTE);\n    }\n\n    // --- 'require' wrapper functions ---\n\n    function _requireCallerIsBorrowerOperations() internal view {\n        require(msg.sender == borrowerOperationsAddress, \"TroveManager: Caller is not the BorrowerOperations contract\");\n    }\n\n    function _requireTroveisActive(address _borrower) internal view {\n        require(Troves[_borrower].status == Status.active, \"TroveManager: Trove does not exist or is closed\");\n    }\n\n    function _requireLUSDBalanceCoversRedemption(address _redeemer, uint _amount) internal view {\n        require(lusdToken.balanceOf(_redeemer) >= _amount, \"TroveManager: Requested redemption amount must be <= user's LUSD token balance\");\n    }\n\n    function _requireMoreThanOneTroveInSystem(uint TroveOwnersArrayLength) internal view {\n        require (TroveOwnersArrayLength > 1 && sortedTroves.getSize() > 1, \"TroveManager: Only one trove in the system\");\n    }\n\n    function _requireAmountGreaterThanZero(uint _amount) internal pure {\n        require(_amount > 0, \"TroveManager: Amount must be greater than zero\");\n    }\n\n    // --- Trove property getters ---\n\n    function getTroveStatus(address _borrower) external view override returns (uint) {\n        return uint(Troves[_borrower].status);\n    }\n\n    function getTroveStake(address _borrower) external view override returns (uint) {\n        return Troves[_borrower].stake;\n    }\n\n    function getTroveDebt(address _borrower) external view override returns (uint) {\n        return Troves[_borrower].debt;\n    }\n\n    function getTroveColl(address _borrower) external view override returns (uint) {\n        return Troves[_borrower].coll;\n    }\n\n    // --- Trove property setters, called by BorrowerOperations ---\n\n    function setTroveStatus(address _borrower, uint _num) external override {\n        _requireCallerIsBorrowerOperations();\n        Troves[_borrower].status = Status(_num);\n    }\n\n    function increaseTroveColl(address _borrower, uint _collIncrease) external override returns (uint) {\n        _requireCallerIsBorrowerOperations();\n        uint newColl = Troves[_borrower].coll.add(_collIncrease);\n        Troves[_borrower].coll = newColl;\n        return newColl;\n    }\n\n    function decreaseTroveColl(address _borrower, uint _collDecrease) external override returns (uint) {\n        _requireCallerIsBorrowerOperations();\n        uint newColl = Troves[_borrower].coll.sub(_collDecrease);\n        Troves[_borrower].coll = newColl;\n        return newColl;\n    }\n\n    function increaseTroveDebt(address _borrower, uint _debtIncrease) external override returns (uint) {\n        _requireCallerIsBorrowerOperations();\n        uint newDebt = Troves[_borrower].debt.add(_debtIncrease);\n        Troves[_borrower].debt = newDebt;\n        return newDebt;\n    }\n\n    function decreaseTroveDebt(address _borrower, uint _debtDecrease) external override returns (uint) {\n        _requireCallerIsBorrowerOperations();\n        uint newDebt = Troves[_borrower].debt.sub(_debtDecrease);\n        Troves[_borrower].debt = newDebt;\n        return newDebt;\n    }\n}",
        "function": "decayBaseRateFromBorrowing()",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-Liquity/dev-f0df3efa5a5f05b205752184cfce107c5bd6e06c/packages/contracts/contracts/TroveManager.sol",
        "vulnerability": "Dependence on predictable environment variable (SWC 116)",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract ACOToken is ERC20 {\n    using Address for address;\n    \n    /**\n     * @dev Struct to store the accounts that generated tokens with a collateral deposit.\n     */\n    struct TokenCollateralized {\n        /**\n         * @dev Current amount of tokens.\n         */\n        uint256 amount;\n        \n        /**\n         * @dev Index on the collateral owners array.\n         */\n        uint256 index;\n    }\n    \n    /**\n     * @dev Emitted when collateral is deposited on the contract.\n     * @param account Address of the collateral owner.\n     * @param amount Amount of collateral deposited.\n     */\n    event CollateralDeposit(address indexed account, uint256 amount);\n    \n    /**\n     * @dev Emitted when collateral is withdrawn from the contract.\n     * @param account Address of the account.\n     * @param recipient Address of the collateral destination.\n     * @param amount Amount of collateral withdrawn.\n     * @param fee The fee amount charged on the withdrawal.\n     */\n    event CollateralWithdraw(address indexed account, address indexed recipient, uint256 amount, uint256 fee);\n    \n    /**\n     * @dev Emitted when the collateral is used on an assignment.\n     * @param from Address of the account of the collateral owner.\n     * @param to Address of the account that exercises tokens to get the collateral.\n     * @param paidAmount Amount paid to the collateral owner.\n     * @param tokenAmount Amount of tokens used to exercise.\n     */\n    event Assigned(address indexed from, address indexed to, uint256 paidAmount, uint256 tokenAmount);\n\n    /**\n     * @dev The ERC20 token address for the underlying asset (0x0 for Ethereum). \n     */\n    address public underlying;\n    \n    /**\n     * @dev The ERC20 token address for the strike asset (0x0 for Ethereum). \n     */\n    address public strikeAsset;\n    \n    /**\n     * @dev Address of the fee destination charged on the exercise.\n     */\n    address payable public feeDestination;\n    \n    /**\n     * @dev True if the type is CALL, false for PUT.\n     */\n    bool public isCall;\n    \n    /**\n     * @dev The strike price for the token with the strike asset precision.\n     */\n    uint256 public strikePrice;\n    \n    /**\n     * @dev The UNIX time for the token expiration.\n     */\n    uint256 public expiryTime;\n    \n    /**\n     * @dev The total amount of collateral on the contract.\n     */\n    uint256 public totalCollateral;\n    \n    /**\n     * @dev The fee value. It is a percentage value (100000 is 100%).\n     */\n    uint256 public acoFee;\n    \n    /**\n     * @dev Symbol of the underlying asset.\n     */\n    string public underlyingSymbol;\n    \n    /**\n     * @dev Symbol of the strike asset.\n     */\n    string public strikeAssetSymbol;\n    \n    /**\n     * @dev Decimals for the underlying asset.\n     */\n    uint8 public underlyingDecimals;\n    \n    /**\n     * @dev Decimals for the strike asset.\n     */\n    uint8 public strikeAssetDecimals;\n    \n    /**\n     * @dev Underlying precision. (10 ^ underlyingDecimals)\n     */\n    uint256 internal underlyingPrecision;\n    \n    /**\n     * @dev Accounts that generated tokens with a collateral deposit.\n     */\n    mapping(address => TokenCollateralized) internal tokenData;\n    \n    /**\n     * @dev Array with all accounts with collateral deposited.\n     */\n    address[] internal _collateralOwners;\n    \n    /**\n     * @dev Internal data to control the reentrancy.\n     */\n    bool internal _notEntered;\n    \n    /**\n     * @dev Selector for ERC20 transfer function.\n     */\n    bytes4 internal _transferSelector;\n    \n    /**\n     * @dev Selector for ERC20 transfer from function.\n     */\n    bytes4 internal _transferFromSelector;\n    \n    /**\n     * @dev Modifier to check if the token is not expired.\n     * It is executed only while the token is not expired.\n     */\n    modifier notExpired() {\n        require(_notExpired(), \"ACOToken::Expired\");\n        _;\n    }\n    \n    /**\n     * @dev Modifier to prevents a contract from calling itself during the function execution.\n     */\n    modifier nonReentrant() {\n        require(_notEntered, \"ACOToken::Reentry\");\n        _notEntered = false;\n        _;\n        _notEntered = true;\n    }\n    \n    /**\n     * @dev Function to initialize the contract.\n     * It should be called when creating the token.\n     * It must be called only once. The `assert` is to guarantee that behavior.\n     * @param _underlying Address of the underlying asset (0x0 for Ethereum).\n     * @param _strikeAsset Address of the strike asset (0x0 for Ethereum).\n     * @param _isCall True if the type is CALL, false for PUT.\n     * @param _strikePrice The strike price with the strike asset precision.\n     * @param _expiryTime The UNIX time for the token expiration.\n     * @param _acoFee Value of the ACO fee. It is a percentage value (100000 is 100%).\n     * @param _feeDestination Address of the fee destination charged on the exercise.\n     */\n    function init(\n        address _underlying,\n        address _strikeAsset,\n        bool _isCall,\n        uint256 _strikePrice,\n        uint256 _expiryTime,\n        uint256 _acoFee,\n        address payable _feeDestination\n    ) public {\n        require(underlying == address(0) && strikeAsset == address(0) && strikePrice == 0, \"ACOToken::init: Already initialized\");\n        \n        require(_expiryTime > now, \"ACOToken::init: Invalid expiry\");\n        require(_strikePrice > 0, \"ACOToken::init: Invalid strike price\");\n        require(_underlying != _strikeAsset, \"ACOToken::init: Same assets\");\n        require(_acoFee <= 500, \"ACOToken::init: Invalid ACO fee\"); // Maximum is 0.5%\n        require(_isEther(_underlying) || _underlying.isContract(), \"ACOToken::init: Invalid underlying\");\n        require(_isEther(_strikeAsset) || _strikeAsset.isContract(), \"ACOToken::init: Invalid strike asset\");\n        \n        underlying = _underlying;\n        strikeAsset = _strikeAsset;\n        isCall = _isCall;\n        strikePrice = _strikePrice;\n        expiryTime = _expiryTime;\n        acoFee = _acoFee;\n        feeDestination = _feeDestination;\n        underlyingDecimals = _getAssetDecimals(_underlying);\n        strikeAssetDecimals = _getAssetDecimals(_strikeAsset);\n        underlyingSymbol = _getAssetSymbol(_underlying);\n        strikeAssetSymbol = _getAssetSymbol(_strikeAsset);\n        // SWC-101-Integer Overflow and Underflow: L207\n        underlyingPrecision = 10 ** uint256(underlyingDecimals);\n\n        _transferSelector = bytes4(keccak256(bytes(\"transfer(address,uint256)\")));\n        _transferFromSelector = bytes4(keccak256(bytes(\"transferFrom(address,address,uint256)\")));\n        _notEntered = true;\n    }\n    \n    /**\n     * @dev Function to guarantee that the contract will not receive ether directly.\n     */\n    receive() external payable {\n        revert();\n    }\n    \n    /**\n     * @dev Function to get the token name.\n     */\n    function name() public view override returns(string memory) {\n        return _name();\n    }\n    \n    /**\n     * @dev Function to get the token symbol, that it is equal to the name.\n     */\n    function symbol() public view override returns(string memory) {\n        return _name();\n    }\n    \n    /**\n     * @dev Function to get the token decimals, that it is equal to the underlying asset decimals.\n     */\n    function decimals() public view override returns(uint8) {\n        return underlyingDecimals;\n    }\n    \n    /**\n     * @dev Function to get the current amount of collateral for an account.\n     * @param account Address of the account.\n     * @return The current amount of collateral.\n     */\n    function currentCollateral(address account) public view returns(uint256) {\n        return getCollateralAmount(currentCollateralizedTokens(account));\n    }\n    \n    /**\n     * @dev Function to get the current amount of unassignable collateral for an account.\n     * NOTE: The function is valid when the token is NOT expired yet. \n     * After expiration, the unassignable collateral is equal to the account's collateral balance.\n     * @param account Address of the account.\n     * @return The respective amount of unassignable collateral.\n     */\n    function unassignableCollateral(address account) public view returns(uint256) {\n        return getCollateralAmount(unassignableTokens(account));\n    }\n    \n    /**\n     * @dev Function to get  the current amount of assignable collateral for an account.\n     * NOTE: The function is valid when the token is NOT expired yet. \n     * After expiration, the assignable collateral is zero.\n     * @param account Address of the account.\n     * @return The respective amount of assignable collateral.\n     */\n    function assignableCollateral(address account) public view returns(uint256) {\n        return getCollateralAmount(assignableTokens(account));\n    }\n    \n    /**\n     * @dev Function to get the current amount of collateralized tokens for an account.\n     * @param account Address of the account.\n     * @return The current amount of collateralized tokens.\n     */\n    function currentCollateralizedTokens(address account) public view returns(uint256) {\n        return tokenData[account].amount;\n    }\n    \n    /**\n     * @dev Function to get the current amount of unassignable tokens for an account.\n     * NOTE: The function is valid when the token is NOT expired yet. \n     * After expiration, the unassignable tokens is equal to the account's collateralized tokens.\n     * @param account Address of the account.\n     * @return The respective amount of unassignable tokens.\n     */\n    function unassignableTokens(address account) public view returns(uint256) {\n        if (balanceOf(account) > tokenData[account].amount) {\n            return tokenData[account].amount;\n        } else {\n            return balanceOf(account);\n        }\n    }\n    \n    /**\n     * @dev Function to get  the current amount of assignable tokens for an account.\n     * NOTE: The function is valid when the token is NOT expired yet. \n     * After expiration, the assignable tokens is zero.\n     * @param account Address of the account.\n     * @return The respective amount of assignable tokens.\n     */\n    function assignableTokens(address account) public view returns(uint256) {\n        return _getAssignableAmount(account);\n    }\n    \n    /**\n     * @dev Function to get the equivalent collateral amount for a token amount.\n     * @param tokenAmount Amount of tokens.\n     * @return The respective amount of collateral.\n     */\n    function getCollateralAmount(uint256 tokenAmount) public view returns(uint256) {\n        if (isCall) {\n            return tokenAmount;\n        } else if (tokenAmount > 0) {\n            return _getTokenStrikePriceRelation(tokenAmount);\n        } else {\n            return 0;\n        }\n    }\n    \n    /**\n     * @dev Function to get the equivalent token amount for a collateral amount.\n     * @param collateralAmount Amount of collateral.\n     * @return The respective amount of tokens.\n     */\n    function getTokenAmount(uint256 collateralAmount) public view returns(uint256) {\n        if (isCall) {\n            return collateralAmount;\n        } else if (collateralAmount > 0) {\n            return collateralAmount.mul(underlyingPrecision).div(strikePrice);\n        } else {\n            return 0;\n        }\n    }\n    \n    /**\n     * @dev Function to get the data for exercise of an amount of token.\n     * @param tokenAmount Amount of tokens.\n     * @return The asset and the respective amount that should be sent to get the collateral.\n     */\n    function getExerciseData(uint256 tokenAmount) public view returns(address, uint256) {\n        if (isCall) {\n            return (strikeAsset, _getTokenStrikePriceRelation(tokenAmount)); \n        } else {\n            return (underlying, tokenAmount);\n        }\n    }\n    \n    /**\n     * @dev Function to get the collateral to be received on an exercise and the respective fee.\n     * @param tokenAmount Amount of tokens.\n     * @return The collateral to be received and the respective fee.\n     */\n    function getCollateralOnExercise(uint256 tokenAmount) public view returns(uint256, uint256) {\n        uint256 collateralAmount = getCollateralAmount(tokenAmount);\n        uint256 fee = collateralAmount.mul(acoFee).div(100000);\n        collateralAmount = collateralAmount.sub(fee);\n        return (collateralAmount, fee);\n    }\n    \n    /**\n     * @dev Function to get the collateral asset.\n     * @return The address of the collateral asset.\n     */\n    function collateral() public view returns(address) {\n        if (isCall) {\n            return underlying;\n        } else {\n            return strikeAsset;\n        }\n    }\n    \n    /**\n     * @dev Function to mint tokens with Ether deposited as collateral.\n     * NOTE: The function only works when the token is NOT expired yet. \n     */\n    function mintPayable() external payable {\n        require(_isEther(collateral()), \"ACOToken::mintPayable: Invalid call\");\n       _mintToken(msg.sender, msg.value);\n    }\n    \n    /**\n     * @dev Function to mint tokens with Ether deposited as collateral to an informed account.\n     * However, the minted tokens are assigned to the transaction sender.\n     * NOTE: The function only works when the token is NOT expired yet. \n     * @param account Address of the account that will be the collateral owner.\n     */\n    function mintToPayable(address account) external payable {\n        require(_isEther(collateral()), \"ACOToken::mintToPayable: Invalid call\");\n       _mintToken(account, msg.value);\n    }\n    \n    /**\n     * @dev Function to mint tokens with ERC20 deposited as collateral.\n     * NOTE: The function only works when the token is NOT expired yet. \n     * @param collateralAmount Amount of collateral deposited.\n     */\n    function mint(uint256 collateralAmount) external {\n        address _collateral = collateral();\n        require(!_isEther(_collateral), \"ACOToken::mint: Invalid call\");\n        \n        _transferFromERC20(_collateral, msg.sender, address(this), collateralAmount);\n        _mintToken(msg.sender, collateralAmount);\n    }\n    \n    /**\n     * @dev Function to mint tokens with ERC20 deposited as collateral to an informed account.\n     * However, the minted tokens are assigned to the transaction sender.\n     * NOTE: The function only works when the token is NOT expired yet. \n     * @param account Address of the account that will be the collateral owner.\n     * @param collateralAmount Amount of collateral deposited.\n     */\n    function mintTo(address account, uint256 collateralAmount) external {\n        address _collateral = collateral();\n        require(!_isEther(_collateral), \"ACOToken::mintTo: Invalid call\");\n        \n        _transferFromERC20(_collateral, msg.sender, address(this), collateralAmount);\n        _mintToken(account, collateralAmount);\n    }\n    \n    /**\n     * @dev Function to burn tokens and get the collateral, not assigned, back.\n     * NOTE: The function only works when the token is NOT expired yet. \n     * @param tokenAmount Amount of tokens to be burned.\n     */\n    function burn(uint256 tokenAmount) external {\n        _burn(msg.sender, tokenAmount);\n    }\n    \n    /**\n     * @dev Function to burn tokens from a specific account and send the collateral to its address.\n     * The token allowance must be respected.\n     * The collateral is sent to the transaction sender.\n     * NOTE: The function only works when the token is NOT expired yet. \n     * @param account Address of the account.\n     * @param tokenAmount Amount of tokens to be burned.\n     */\n    // SWC-114-Transaction Order Dependence: L441-L443\n    function burnFrom(address account, uint256 tokenAmount) external {\n        _burn(account, tokenAmount);\n    }\n    \n    /**\n     * @dev Function to get the collateral, not assigned, back.\n     * NOTE: The function only works when the token IS expired. \n     */\n    function redeem() external {\n        _redeem(msg.sender);\n    }\n    \n    /**\n     * @dev Function to get the collateral from a specific account sent back to its address .\n     * The token allowance must be respected.\n     * The collateral is sent to the transaction sender.\n     * NOTE: The function only works when the token IS expired. \n     * @param account Address of the account.\n     */\n    function redeemFrom(address account) external {\n        require(tokenData[account].amount <= allowance(account, msg.sender), \"ACOToken::redeemFrom: No allowance\");\n        _redeem(account);\n    }\n    \n    /**\n     * @dev Function to exercise the tokens, paying to get the equivalent collateral.\n     * The paid amount is sent to the collateral owners that were assigned.\n     * NOTE: The function only works when the token is NOT expired. \n     * @param tokenAmount Amount of tokens.\n     */\n    function exercise(uint256 tokenAmount) external payable {\n        _exercise(msg.sender, tokenAmount);\n    }\n    \n    /**\n     * @dev Function to exercise the tokens from an account, paying to get the equivalent collateral.\n     * The token allowance must be respected.\n     * The paid amount is sent to the collateral owners that were assigned.\n     * The collateral is transferred to the transaction sender.\n     * NOTE: The function only works when the token is NOT expired. \n     * @param account Address of the account.\n     * @param tokenAmount Amount of tokens.\n     */\n    function exerciseFrom(address account, uint256 tokenAmount) external payable {\n        _exercise(account, tokenAmount);\n    }\n    \n    /**\n     * @dev Function to exercise the tokens, paying to get the equivalent collateral.\n     * The paid amount is sent to the collateral owners (on accounts list) that were assigned.\n     * NOTE: The function only works when the token is NOT expired. \n     * @param tokenAmount Amount of tokens.\n     * @param accounts The array of addresses to get collateral from.\n     */\n    function exerciseAccounts(uint256 tokenAmount, address[] calldata accounts) external payable {\n        _exerciseFromAccounts(msg.sender, tokenAmount, accounts);\n    }\n    \n    /**\n     * @dev Function to exercise the tokens from a specific account, paying to get the equivalent collateral sent to its address.\n     * The token allowance must be respected.\n     * The paid amount is sent to the collateral owners (on accounts list) that were assigned.\n     * The collateral is transferred to the transaction sender.\n     * NOTE: The function only works when the token is NOT expired. \n     * @param account Address of the account.\n     * @param tokenAmount Amount of tokens.\n     * @param accounts The array of addresses to get the deposited collateral.\n     */\n    function exerciseAccountsFrom(address account, uint256 tokenAmount, address[] calldata accounts) external payable {\n        _exerciseFromAccounts(account, tokenAmount, accounts);\n    }\n    \n    /**\n     * @dev Function to burn the tokens after expiration.\n     * It is an optional function to `clear` the account wallet from an expired and not functional token.\n     * NOTE: The function only works when the token IS expired. \n     */\n    function clear() external {\n        _clear(msg.sender);\n    }\n    \n    /**\n     * @dev Function to burn the tokens from an account after expiration.\n     * It is an optional function to `clear` the account wallet from an expired and not functional token.\n     * The token allowance must be respected.\n     * NOTE: The function only works when the token IS expired. \n     * @param account Address of the account.\n     */\n    function clearFrom(address account) external {\n        _clear(account);\n    }\n    \n    /**\n     * @dev Internal function to burn the tokens from an account after expiration.\n     * @param account Address of the account.\n     */\n    function _clear(address account) internal {\n        require(!_notExpired(), \"ACOToken::_clear: Token not expired yet\");\n        require(!_accountHasCollateral(account), \"ACOToken::_clear: Must call the redeem method\");\n        \n        _callBurn(account, balanceOf(account));\n    }\n    \n    /**\n     * @dev Internal function to redeem respective collateral from an account.\n     * @param account Address of the account.\n     * @param tokenAmount Amount of tokens.\n     */\n    function _redeemCollateral(address account, uint256 tokenAmount) internal {\n        require(_accountHasCollateral(account), \"ACOToken::_redeemCollateral: No collateral available\");\n        require(tokenAmount > 0, \"ACOToken::_redeemCollateral: Invalid token amount\");\n        \n        TokenCollateralized storage data = tokenData[account];\n        data.amount = data.amount.sub(tokenAmount);\n        \n        _removeCollateralDataIfNecessary(account);\n        \n        _transferCollateral(account, getCollateralAmount(tokenAmount), 0);\n    }\n    \n    /**\n     * @dev Internal function to mint tokens.\n     * The tokens are minted for the transaction sender.\n     * @param account Address of the account.\n     * @param collateralAmount Amount of collateral deposited.\n     */\n    function _mintToken(address account, uint256 collateralAmount) nonReentrant notExpired internal {\n        require(collateralAmount > 0, \"ACOToken::_mintToken: Invalid collateral amount\");\n        // SWC-128-DoS With Block Gas Limit: L570-L573\n        if (!_accountHasCollateral(account)) {\n            tokenData[account].index = _collateralOwners.length;\n            _collateralOwners.push(account);\n        }\n        \n        uint256 tokenAmount = getTokenAmount(collateralAmount);\n        tokenData[account].amount = tokenData[account].amount.add(tokenAmount);\n        \n        totalCollateral = totalCollateral.add(collateralAmount);\n        \n        emit CollateralDeposit(account, collateralAmount);\n        \n        super._mintAction(msg.sender, tokenAmount);\n    }\n    \n    /**\n     * @dev Internal function to transfer tokens. \n     * The token transfer only works when the token is NOT expired. \n     * @param sender Source of the tokens.\n     * @param recipient Destination address for the tokens.\n     * @param amount Amount of tokens.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) notExpired internal override {\n        super._transferAction(sender, recipient, amount);\n    }\n    \n    /**\n     * @dev Internal function to set the token permission from an account to another address. \n     * The token approval only works when the token is NOT expired. \n     * @param owner Address of the token owner.\n     * @param spender Address of the spender authorized.\n     * @param amount Amount of tokens authorized.\n     */\n    function _approve(address owner, address spender, uint256 amount) notExpired internal override {\n        super._approveAction(owner, spender, amount);\n    }\n    \n    /**\n     * @dev Internal function to transfer collateral. \n     * When there is a fee, the calculated fee is also transferred to the destination fee address.\n     * The collateral destination is always the transaction sender address.\n     * @param account Address of the account.\n     * @param collateralAmount Amount of collateral to be redeemed.\n     * @param fee Amount of fee charged.\n     */\n    function _transferCollateral(address account, uint256 collateralAmount, uint256 fee) internal {\n        \n        totalCollateral = totalCollateral.sub(collateralAmount.add(fee));\n        \n        address _collateral = collateral();\n        if (_isEther(_collateral)) {\n            payable(msg.sender).transfer(collateralAmount);\n            if (fee > 0) {\n                feeDestination.transfer(fee);   \n            }\n        } else {\n            _transferERC20(_collateral, msg.sender, collateralAmount);\n            if (fee > 0) {\n                _transferERC20(_collateral, feeDestination, fee);\n            }\n        }\n        \n        emit CollateralWithdraw(account, msg.sender, collateralAmount, fee);\n    }\n    \n    /**\n     * @dev Internal function to exercise the tokens from an account. \n     * @param account Address of the account that is exercising.\n     * @param tokenAmount Amount of tokens.\n     */\n    function _exercise(address account, uint256 tokenAmount) nonReentrant internal {\n        _validateAndBurn(account, tokenAmount);\n        _exerciseOwners(account, tokenAmount);\n        (uint256 collateralAmount, uint256 fee) = getCollateralOnExercise(tokenAmount);\n        _transferCollateral(account, collateralAmount, fee);\n    }\n    \n    /**\n     * @dev Internal function to exercise the tokens from an account. \n     * @param account Address of the account that is exercising.\n     * @param tokenAmount Amount of tokens.\n     * @param accounts The array of addresses to get the collateral from.\n     */\n    function _exerciseFromAccounts(address account, uint256 tokenAmount, address[] memory accounts) nonReentrant internal {\n        _validateAndBurn(account, tokenAmount);\n        _exerciseAccounts(account, tokenAmount, accounts);\n        (uint256 collateralAmount, uint256 fee) = getCollateralOnExercise(tokenAmount);\n        _transferCollateral(account, collateralAmount, fee);\n    }\n    \n    /**\n     * @dev Internal function to exercise the assignable tokens from the stored list of collateral owners. \n     * @param exerciseAccount Address of the account that is exercising.\n     * @param tokenAmount Amount of tokens.\n     */\n    function _exerciseOwners(address exerciseAccount, uint256 tokenAmount) internal {\n        uint256 start = _collateralOwners.length - 1;\n        for (uint256 i = start; i >= 0; --i) {\n            if (tokenAmount == 0) {\n                break;\n            }\n            tokenAmount = _exerciseAccount(_collateralOwners[i], tokenAmount, exerciseAccount);\n        }\n        require(tokenAmount == 0, \"ACOToken::_exerciseOwners: Invalid remaining amount\");\n    }\n    \n    /**\n     * @dev Internal function to exercise the assignable tokens from an accounts list. \n     * @param exerciseAccount Address of the account that is exercising.\n     * @param tokenAmount Amount of tokens.\n     * @param accounts The array of addresses to get the collateral from.\n     */\n    function _exerciseAccounts(address exerciseAccount, uint256 tokenAmount, address[] memory accounts) internal {\n        for (uint256 i = 0; i < accounts.length; ++i) {\n            if (tokenAmount == 0) {\n                break;\n            }\n            tokenAmount = _exerciseAccount(accounts[i], tokenAmount, exerciseAccount);\n        }\n        require(tokenAmount == 0, \"ACOToken::_exerciseAccounts: Invalid remaining amount\");\n    }\n    \n    /**\n     * @dev Internal function to exercise the assignable tokens from an account and transfer to its address the respective payment. \n     * @param account Address of the account.\n     * @param tokenAmount Amount of tokens.\n     * @param exerciseAccount Address of the account that is exercising.\n     * @return Remaining amount of tokens.\n     */\n    function _exerciseAccount(address account, uint256 tokenAmount, address exerciseAccount) internal returns(uint256) {\n        uint256 available = _getAssignableAmount(account);\n        if (available > 0) {\n            \n            TokenCollateralized storage data = tokenData[account];\n            uint256 valueToTransfer;\n            if (available < tokenAmount) {\n                valueToTransfer = available;\n                tokenAmount = tokenAmount.sub(available);\n            } else {\n                valueToTransfer = tokenAmount;\n                tokenAmount = 0;\n            }\n            \n            (address exerciseAsset, uint256 amount) = getExerciseData(valueToTransfer);\n\n            data.amount = data.amount.sub(valueToTransfer); \n            \n            _removeCollateralDataIfNecessary(account);\n            \n            if (_isEther(exerciseAsset)) {\n                payable(account).transfer(amount);\n            } else {\n                _transferERC20(exerciseAsset, account, amount);\n            }\n            emit Assigned(account, exerciseAccount, amount, valueToTransfer);\n        }\n        \n        return tokenAmount;\n    }\n    \n    /**\n     * @dev Internal function to validate the exercise operation and burn the respective tokens.\n     * @param account Address of the account that is exercising.\n     * @param tokenAmount Amount of tokens.\n     */\n    function _validateAndBurn(address account, uint256 tokenAmount) notExpired internal {\n        require(tokenAmount > 0, \"ACOToken::_validateAndBurn: Invalid token amount\");\n        \n        // Whether an account has deposited collateral it only can exercise the extra amount of unassignable tokens.\n        if (_accountHasCollateral(account)) {\n            // SWC-135-Code With No Effects: L741\n            require(balanceOf(account) > tokenData[account].amount, \"ACOToken::_validateAndBurn: Tokens compromised\");\n            require(tokenAmount <= balanceOf(account).sub(tokenData[account].amount), \"ACOToken::_validateAndBurn: Token amount not available\"); \n        }\n        \n        _callBurn(account, tokenAmount);\n        \n        (address exerciseAsset, uint256 expectedAmount) = getExerciseData(tokenAmount);\n\n        if (_isEther(exerciseAsset)) {\n            require(msg.value == expectedAmount, \"ACOToken::_validateAndBurn: Invalid ether amount\");\n        } else {\n            require(msg.value == 0, \"ACOToken::_validateAndBurn: No ether expected\");\n            _transferFromERC20(exerciseAsset, msg.sender, address(this), expectedAmount);\n        }\n    }\n    \n    /**\n     * @dev Internal function to calculate the token strike price relation.\n     * @param tokenAmount Amount of tokens.\n     * @return Calculated value with strike asset precision.\n     */\n    function _getTokenStrikePriceRelation(uint256 tokenAmount) internal view returns(uint256) {\n        return tokenAmount.mul(strikePrice).div(underlyingPrecision);\n    }\n    \n    /**\n     * @dev Internal function to get the collateral sent back from an account.\n     * Function to be called when the token IS expired.\n     * @param account Address of the account.\n     */\n    function _redeem(address account) nonReentrant internal {\n        require(!_notExpired(), \"ACOToken::_redeem: Token not expired yet\");\n        \n        _redeemCollateral(account, tokenData[account].amount);\n        super._burnAction(account, balanceOf(account));\n    }\n    \n    /**\n     * @dev Internal function to burn tokens from an account and get the collateral, not assigned, back.\n     * @param account Address of the account.\n     * @param tokenAmount Amount of tokens to be burned.\n     */\n    function _burn(address account, uint256 tokenAmount) nonReentrant notExpired internal {\n        _redeemCollateral(account, tokenAmount);\n        _callBurn(account, tokenAmount);\n    }\n    \n    /**\n     * @dev Internal function to burn tokens.\n     * @param account Address of the account.\n     * @param tokenAmount Amount of tokens to be burned.\n     */\n    function _callBurn(address account, uint256 tokenAmount) internal {\n        if (account == msg.sender) {\n            super._burnAction(account, tokenAmount);\n        } else {\n            super._burnFrom(account, tokenAmount);\n        }\n    }\n    \n    /**\n     * @dev Internal function to get the amount of assignable token from an account.\n     * @param account Address of the account.\n     * @return The assignable amount of tokens.\n     */\n    function _getAssignableAmount(address account) internal view returns(uint256) {\n        if (tokenData[account].amount > balanceOf(account)) {\n            return tokenData[account].amount.sub(balanceOf(account));\n        } else {\n            return 0;\n        }\n    }\n    \n    /**\n     * @dev Internal function to remove the token data with collateral if its total amount was assigned.\n     * @param account Address of account.\n     */\n    function _removeCollateralDataIfNecessary(address account) internal {\n        TokenCollateralized storage data = tokenData[account];\n        if (!_hasCollateral(data)) {\n            uint256 lastIndex = _collateralOwners.length - 1;\n            if (lastIndex != data.index) {\n                address last = _collateralOwners[lastIndex];\n                tokenData[last].index = data.index;\n                _collateralOwners[data.index] = last;\n            }\n            _collateralOwners.pop();\n            delete tokenData[account];\n        }\n    }\n    \n    /**\n     * @dev Internal function to get if the token is not expired.\n     * @return Whether the token is NOT expired.\n     */\n    function _notExpired() internal view returns(bool) {\n        return now <= expiryTime;\n    }\n    \n    /**\n     * @dev Internal function to get if an account has collateral deposited.\n     * @param account Address of the account.\n     * @return Whether the account has collateral deposited.\n     */\n    function _accountHasCollateral(address account) internal view returns(bool) {\n        return _hasCollateral(tokenData[account]);\n    }\n    \n    /**\n     * @dev Internal function to get if an account has collateral deposited.\n     * @param data Token data from an account.\n     * @return Whether the account has collateral deposited.\n     */    \n    function _hasCollateral(TokenCollateralized storage data) internal view returns(bool) {\n        return data.amount > 0;\n    }\n    \n    /**\n     * @dev Internal function to get if the address is for Ethereum (0x0).\n     * @param _address Address to be checked.\n     * @return Whether the address is for Ethereum.\n     */ \n    function _isEther(address _address) internal pure returns(bool) {\n        return _address == address(0);\n    } \n    \n    /**\n     * @dev Internal function to get the token name.\n     * The token name is assembled  with the token data:\n     * ACO UNDERLYING_SYMBOL-EXPIRYTIME-STRIKE_PRICE_STRIKE_ASSET_SYMBOL-TYPE\n     * @return The token name.\n     */\n    function _name() internal view returns(string memory) {\n        return string(abi.encodePacked(\n            \"ACO \",\n            underlyingSymbol,\n            \"-\",\n            _getFormattedStrikePrice(),\n            strikeAssetSymbol,\n            \"-\",\n            _getType(),\n            \"-\",\n            _getFormattedExpiryTime()\n        ));\n    }\n    \n    /**\n     * @dev Internal function to get the token type description.\n     * @return The token type description.\n     */\n    function _getType() internal view returns(string memory) {\n        if (isCall) {\n            return \"C\";\n        } else {\n            return \"P\";\n        }\n    }\n    \n    /**\n     * @dev Internal function to get the expiry time formatted.\n     * @return The expiry time formatted.\n     */\n    function _getFormattedExpiryTime() internal view returns(string memory) {\n        (uint256 year, uint256 month, uint256 day, uint256 hour, uint256 minute,) = BokkyPooBahsDateTimeLibrary.timestampToDateTime(expiryTime); \n        return string(abi.encodePacked(\n            _getNumberWithTwoCaracters(day),\n            _getMonthFormatted(month),\n            _getYearFormatted(year),\n            \"-\",\n            _getNumberWithTwoCaracters(hour),\n            _getNumberWithTwoCaracters(minute),\n            \"UTC\"\n            )); \n    }\n    \n    /**\n     * @dev Internal function to get the year formatted with 2 characters.\n     * @return The year formatted.\n     */\n    function _getYearFormatted(uint256 year) internal pure returns(string memory) {\n        bytes memory yearBytes = bytes(Strings.toString(year));\n        bytes memory result = new bytes(2);\n        uint256 startIndex = yearBytes.length - 2;\n        for (uint256 i = startIndex; i < yearBytes.length; i++) {\n            result[i - startIndex] = yearBytes[i];\n        }\n        return string(result);\n    }\n    \n    /**\n     * @dev Internal function to get the month abbreviation.\n     * @return The month abbreviation.\n     */\n    function _getMonthFormatted(uint256 month) internal pure returns(string memory) {\n        if (month == 1) {\n            return \"JAN\";\n        } else if (month == 2) {\n            return \"FEB\";\n        } else if (month == 3) {\n            return \"MAR\";\n        } else if (month == 4) {\n            return \"APR\";\n        } else if (month == 5) {\n            return \"MAY\";\n        } else if (month == 6) {\n            return \"JUN\";\n        } else if (month == 7) {\n            return \"JUL\";\n        } else if (month == 8) {\n            return \"AUG\";\n        } else if (month == 9) {\n            return \"SEP\";\n        } else if (month == 10) {\n            return \"OCT\";\n        } else if (month == 11) {\n            return \"NOV\";\n        } else if (month == 12) {\n            return \"DEC\";\n        } else {\n            return \"INVALID\";\n        }\n    }\n    \n    /**\n     * @dev Internal function to get the number with 2 characters.\n     * @return The 2 characters for the number.\n     */\n    function _getNumberWithTwoCaracters(uint256 number) internal pure returns(string memory) {\n        string memory _string = Strings.toString(number);\n        if (number < 10) {\n            return string(abi.encodePacked(\"0\", _string));\n        } else {\n            return _string;\n        }\n    }\n    \n    /**\n     * @dev Internal function to get the strike price formatted.\n     * @return The strike price formatted.\n     */\n    function _getFormattedStrikePrice() internal view returns(string memory) {\n        uint256 digits;\n        uint256 count;\n        int256 representativeAt = -1;\n        uint256 addPointAt = 0;\n        uint256 temp = strikePrice;\n        uint256 number = strikePrice;\n        while (temp != 0) {\n            if (representativeAt == -1 && (temp % 10 != 0 || count == uint256(strikeAssetDecimals))) {\n                representativeAt = int256(digits);\n                number = temp;\n            }\n            if (representativeAt >= 0) {\n                if (count == uint256(strikeAssetDecimals)) {\n                    addPointAt = digits;\n                }\n                digits++;\n            }\n            temp /= 10;\n            count++;\n        }\n        if (count <= uint256(strikeAssetDecimals)) {\n            digits = digits + 2 + uint256(strikeAssetDecimals) - count;\n            addPointAt = digits - 2;\n        } else if (addPointAt > 0) {\n            digits++;\n        }\n        bytes memory buffer = new bytes(digits);\n        uint256 index = digits - 1;\n        temp = number;\n        for (uint256 i = 0; i < digits; ++i) {\n            if (i > 0 && i == addPointAt) {\n                buffer[index--] = byte(\".\");\n            } else if (number == 0) {\n                buffer[index--] = byte(\"0\");\n            } else {\n                // SWC-135-Code With No Effects: L1018\n                if (representativeAt <= int256(i)) {\n                    buffer[index--] = byte(uint8(48 + number % 10));\n                }\n                number /= 10;\n            }\n        }\n        return string(buffer);\n    }\n    \n    /**\n     * @dev Internal function to the asset decimals.\n     * @param asset Address of the asset.\n     * @return The asset decimals.\n     */\n    function _getAssetDecimals(address asset) internal view returns(uint8) {\n        if (_isEther(asset)) {\n            return uint8(18);\n        } else {\n            (bool success, bytes memory returndata) = asset.staticcall(abi.encodeWithSignature(\"decimals()\"));\n            require(success, \"ACOToken::_getAssetDecimals: Invalid asset decimals\");\n            return abi.decode(returndata, (uint8));\n        }\n    }\n    \n    /**\n     * @dev Internal function to the asset symbol.\n     * @param asset Address of the asset.\n     * @return The asset symbol.\n     */\n    function _getAssetSymbol(address asset) internal view returns(string memory) {\n        if (_isEther(asset)) {\n            return \"ETH\";\n        } else {\n            (bool success, bytes memory returndata) = asset.staticcall(abi.encodeWithSignature(\"symbol()\"));\n            require(success, \"ACOToken::_getAssetSymbol: Invalid asset symbol\");\n            return abi.decode(returndata, (string));\n        }\n    }\n    \n    /**\n     * @dev Internal function to transfer ERC20 tokens.\n     * @param token Address of the token.\n     * @param recipient Address of the transfer destination.\n     * @param amount Amount to transfer.\n     */\n     function _transferERC20(address token, address recipient, uint256 amount) internal {\n        (bool success, bytes memory returndata) = token.call(abi.encodeWithSelector(_transferSelector, recipient, amount));\n        require(success && (returndata.length == 0 || abi.decode(returndata, (bool))), \"ACOToken::_transferERC20\");\n    }\n    \n    /**\n     * @dev Internal function to call transferFrom on ERC20 tokens.\n     * @param token Address of the token.\n     * @param sender Address of the sender.\n     * @param recipient Address of the transfer destination.\n     * @param amount Amount to transfer.\n     */\n     function _transferFromERC20(address token, address sender, address recipient, uint256 amount) internal {\n        (bool success, bytes memory returndata) = token.call(abi.encodeWithSelector(_transferFromSelector, sender, recipient, amount));\n        require(success && (returndata.length == 0 || abi.decode(returndata, (bool))), \"ACOToken::_transferFromERC20\");\n    }\n}",
        "function": "init(address,address,bool,uint256,uint256,uint256,address)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/openzeppelin-ACO_Protocol/aco-36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/core/ACOToken.sol",
        "vulnerability": "Dependence on predictable environment variable (SWC 116)",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract ACOToken is ERC20 {\n    using Address for address;\n    \n    /**\n     * @dev Struct to store the accounts that generated tokens with a collateral deposit.\n     */\n    struct TokenCollateralized {\n        /**\n         * @dev Current amount of tokens.\n         */\n        uint256 amount;\n        \n        /**\n         * @dev Index on the collateral owners array.\n         */\n        uint256 index;\n    }\n    \n    /**\n     * @dev Emitted when collateral is deposited on the contract.\n     * @param account Address of the collateral owner.\n     * @param amount Amount of collateral deposited.\n     */\n    event CollateralDeposit(address indexed account, uint256 amount);\n    \n    /**\n     * @dev Emitted when collateral is withdrawn from the contract.\n     * @param account Address of the account.\n     * @param recipient Address of the collateral destination.\n     * @param amount Amount of collateral withdrawn.\n     * @param fee The fee amount charged on the withdrawal.\n     */\n    event CollateralWithdraw(address indexed account, address indexed recipient, uint256 amount, uint256 fee);\n    \n    /**\n     * @dev Emitted when the collateral is used on an assignment.\n     * @param from Address of the account of the collateral owner.\n     * @param to Address of the account that exercises tokens to get the collateral.\n     * @param paidAmount Amount paid to the collateral owner.\n     * @param tokenAmount Amount of tokens used to exercise.\n     */\n    event Assigned(address indexed from, address indexed to, uint256 paidAmount, uint256 tokenAmount);\n\n    /**\n     * @dev The ERC20 token address for the underlying asset (0x0 for Ethereum). \n     */\n    address public underlying;\n    \n    /**\n     * @dev The ERC20 token address for the strike asset (0x0 for Ethereum). \n     */\n    address public strikeAsset;\n    \n    /**\n     * @dev Address of the fee destination charged on the exercise.\n     */\n    address payable public feeDestination;\n    \n    /**\n     * @dev True if the type is CALL, false for PUT.\n     */\n    bool public isCall;\n    \n    /**\n     * @dev The strike price for the token with the strike asset precision.\n     */\n    uint256 public strikePrice;\n    \n    /**\n     * @dev The UNIX time for the token expiration.\n     */\n    uint256 public expiryTime;\n    \n    /**\n     * @dev The total amount of collateral on the contract.\n     */\n    uint256 public totalCollateral;\n    \n    /**\n     * @dev The fee value. It is a percentage value (100000 is 100%).\n     */\n    uint256 public acoFee;\n    \n    /**\n     * @dev Symbol of the underlying asset.\n     */\n    string public underlyingSymbol;\n    \n    /**\n     * @dev Symbol of the strike asset.\n     */\n    string public strikeAssetSymbol;\n    \n    /**\n     * @dev Decimals for the underlying asset.\n     */\n    uint8 public underlyingDecimals;\n    \n    /**\n     * @dev Decimals for the strike asset.\n     */\n    uint8 public strikeAssetDecimals;\n    \n    /**\n     * @dev Underlying precision. (10 ^ underlyingDecimals)\n     */\n    uint256 internal underlyingPrecision;\n    \n    /**\n     * @dev Accounts that generated tokens with a collateral deposit.\n     */\n    mapping(address => TokenCollateralized) internal tokenData;\n    \n    /**\n     * @dev Array with all accounts with collateral deposited.\n     */\n    address[] internal _collateralOwners;\n    \n    /**\n     * @dev Internal data to control the reentrancy.\n     */\n    bool internal _notEntered;\n    \n    /**\n     * @dev Selector for ERC20 transfer function.\n     */\n    bytes4 internal _transferSelector;\n    \n    /**\n     * @dev Selector for ERC20 transfer from function.\n     */\n    bytes4 internal _transferFromSelector;\n    \n    /**\n     * @dev Modifier to check if the token is not expired.\n     * It is executed only while the token is not expired.\n     */\n    modifier notExpired() {\n        require(_notExpired(), \"ACOToken::Expired\");\n        _;\n    }\n    \n    /**\n     * @dev Modifier to prevents a contract from calling itself during the function execution.\n     */\n    modifier nonReentrant() {\n        require(_notEntered, \"ACOToken::Reentry\");\n        _notEntered = false;\n        _;\n        _notEntered = true;\n    }\n    \n    /**\n     * @dev Function to initialize the contract.\n     * It should be called when creating the token.\n     * It must be called only once. The `assert` is to guarantee that behavior.\n     * @param _underlying Address of the underlying asset (0x0 for Ethereum).\n     * @param _strikeAsset Address of the strike asset (0x0 for Ethereum).\n     * @param _isCall True if the type is CALL, false for PUT.\n     * @param _strikePrice The strike price with the strike asset precision.\n     * @param _expiryTime The UNIX time for the token expiration.\n     * @param _acoFee Value of the ACO fee. It is a percentage value (100000 is 100%).\n     * @param _feeDestination Address of the fee destination charged on the exercise.\n     */\n    function init(\n        address _underlying,\n        address _strikeAsset,\n        bool _isCall,\n        uint256 _strikePrice,\n        uint256 _expiryTime,\n        uint256 _acoFee,\n        address payable _feeDestination\n    ) public {\n        require(underlying == address(0) && strikeAsset == address(0) && strikePrice == 0, \"ACOToken::init: Already initialized\");\n        \n        require(_expiryTime > now, \"ACOToken::init: Invalid expiry\");\n        require(_strikePrice > 0, \"ACOToken::init: Invalid strike price\");\n        require(_underlying != _strikeAsset, \"ACOToken::init: Same assets\");\n        require(_acoFee <= 500, \"ACOToken::init: Invalid ACO fee\"); // Maximum is 0.5%\n        require(_isEther(_underlying) || _underlying.isContract(), \"ACOToken::init: Invalid underlying\");\n        require(_isEther(_strikeAsset) || _strikeAsset.isContract(), \"ACOToken::init: Invalid strike asset\");\n        \n        underlying = _underlying;\n        strikeAsset = _strikeAsset;\n        isCall = _isCall;\n        strikePrice = _strikePrice;\n        expiryTime = _expiryTime;\n        acoFee = _acoFee;\n        feeDestination = _feeDestination;\n        underlyingDecimals = _getAssetDecimals(_underlying);\n        strikeAssetDecimals = _getAssetDecimals(_strikeAsset);\n        underlyingSymbol = _getAssetSymbol(_underlying);\n        strikeAssetSymbol = _getAssetSymbol(_strikeAsset);\n        // SWC-101-Integer Overflow and Underflow: L207\n        underlyingPrecision = 10 ** uint256(underlyingDecimals);\n\n        _transferSelector = bytes4(keccak256(bytes(\"transfer(address,uint256)\")));\n        _transferFromSelector = bytes4(keccak256(bytes(\"transferFrom(address,address,uint256)\")));\n        _notEntered = true;\n    }\n    \n    /**\n     * @dev Function to guarantee that the contract will not receive ether directly.\n     */\n    receive() external payable {\n        revert();\n    }\n    \n    /**\n     * @dev Function to get the token name.\n     */\n    function name() public view override returns(string memory) {\n        return _name();\n    }\n    \n    /**\n     * @dev Function to get the token symbol, that it is equal to the name.\n     */\n    function symbol() public view override returns(string memory) {\n        return _name();\n    }\n    \n    /**\n     * @dev Function to get the token decimals, that it is equal to the underlying asset decimals.\n     */\n    function decimals() public view override returns(uint8) {\n        return underlyingDecimals;\n    }\n    \n    /**\n     * @dev Function to get the current amount of collateral for an account.\n     * @param account Address of the account.\n     * @return The current amount of collateral.\n     */\n    function currentCollateral(address account) public view returns(uint256) {\n        return getCollateralAmount(currentCollateralizedTokens(account));\n    }\n    \n    /**\n     * @dev Function to get the current amount of unassignable collateral for an account.\n     * NOTE: The function is valid when the token is NOT expired yet. \n     * After expiration, the unassignable collateral is equal to the account's collateral balance.\n     * @param account Address of the account.\n     * @return The respective amount of unassignable collateral.\n     */\n    function unassignableCollateral(address account) public view returns(uint256) {\n        return getCollateralAmount(unassignableTokens(account));\n    }\n    \n    /**\n     * @dev Function to get  the current amount of assignable collateral for an account.\n     * NOTE: The function is valid when the token is NOT expired yet. \n     * After expiration, the assignable collateral is zero.\n     * @param account Address of the account.\n     * @return The respective amount of assignable collateral.\n     */\n    function assignableCollateral(address account) public view returns(uint256) {\n        return getCollateralAmount(assignableTokens(account));\n    }\n    \n    /**\n     * @dev Function to get the current amount of collateralized tokens for an account.\n     * @param account Address of the account.\n     * @return The current amount of collateralized tokens.\n     */\n    function currentCollateralizedTokens(address account) public view returns(uint256) {\n        return tokenData[account].amount;\n    }\n    \n    /**\n     * @dev Function to get the current amount of unassignable tokens for an account.\n     * NOTE: The function is valid when the token is NOT expired yet. \n     * After expiration, the unassignable tokens is equal to the account's collateralized tokens.\n     * @param account Address of the account.\n     * @return The respective amount of unassignable tokens.\n     */\n    function unassignableTokens(address account) public view returns(uint256) {\n        if (balanceOf(account) > tokenData[account].amount) {\n            return tokenData[account].amount;\n        } else {\n            return balanceOf(account);\n        }\n    }\n    \n    /**\n     * @dev Function to get  the current amount of assignable tokens for an account.\n     * NOTE: The function is valid when the token is NOT expired yet. \n     * After expiration, the assignable tokens is zero.\n     * @param account Address of the account.\n     * @return The respective amount of assignable tokens.\n     */\n    function assignableTokens(address account) public view returns(uint256) {\n        return _getAssignableAmount(account);\n    }\n    \n    /**\n     * @dev Function to get the equivalent collateral amount for a token amount.\n     * @param tokenAmount Amount of tokens.\n     * @return The respective amount of collateral.\n     */\n    function getCollateralAmount(uint256 tokenAmount) public view returns(uint256) {\n        if (isCall) {\n            return tokenAmount;\n        } else if (tokenAmount > 0) {\n            return _getTokenStrikePriceRelation(tokenAmount);\n        } else {\n            return 0;\n        }\n    }\n    \n    /**\n     * @dev Function to get the equivalent token amount for a collateral amount.\n     * @param collateralAmount Amount of collateral.\n     * @return The respective amount of tokens.\n     */\n    function getTokenAmount(uint256 collateralAmount) public view returns(uint256) {\n        if (isCall) {\n            return collateralAmount;\n        } else if (collateralAmount > 0) {\n            return collateralAmount.mul(underlyingPrecision).div(strikePrice);\n        } else {\n            return 0;\n        }\n    }\n    \n    /**\n     * @dev Function to get the data for exercise of an amount of token.\n     * @param tokenAmount Amount of tokens.\n     * @return The asset and the respective amount that should be sent to get the collateral.\n     */\n    function getExerciseData(uint256 tokenAmount) public view returns(address, uint256) {\n        if (isCall) {\n            return (strikeAsset, _getTokenStrikePriceRelation(tokenAmount)); \n        } else {\n            return (underlying, tokenAmount);\n        }\n    }\n    \n    /**\n     * @dev Function to get the collateral to be received on an exercise and the respective fee.\n     * @param tokenAmount Amount of tokens.\n     * @return The collateral to be received and the respective fee.\n     */\n    function getCollateralOnExercise(uint256 tokenAmount) public view returns(uint256, uint256) {\n        uint256 collateralAmount = getCollateralAmount(tokenAmount);\n        uint256 fee = collateralAmount.mul(acoFee).div(100000);\n        collateralAmount = collateralAmount.sub(fee);\n        return (collateralAmount, fee);\n    }\n    \n    /**\n     * @dev Function to get the collateral asset.\n     * @return The address of the collateral asset.\n     */\n    function collateral() public view returns(address) {\n        if (isCall) {\n            return underlying;\n        } else {\n            return strikeAsset;\n        }\n    }\n    \n    /**\n     * @dev Function to mint tokens with Ether deposited as collateral.\n     * NOTE: The function only works when the token is NOT expired yet. \n     */\n    function mintPayable() external payable {\n        require(_isEther(collateral()), \"ACOToken::mintPayable: Invalid call\");\n       _mintToken(msg.sender, msg.value);\n    }\n    \n    /**\n     * @dev Function to mint tokens with Ether deposited as collateral to an informed account.\n     * However, the minted tokens are assigned to the transaction sender.\n     * NOTE: The function only works when the token is NOT expired yet. \n     * @param account Address of the account that will be the collateral owner.\n     */\n    function mintToPayable(address account) external payable {\n        require(_isEther(collateral()), \"ACOToken::mintToPayable: Invalid call\");\n       _mintToken(account, msg.value);\n    }\n    \n    /**\n     * @dev Function to mint tokens with ERC20 deposited as collateral.\n     * NOTE: The function only works when the token is NOT expired yet. \n     * @param collateralAmount Amount of collateral deposited.\n     */\n    function mint(uint256 collateralAmount) external {\n        address _collateral = collateral();\n        require(!_isEther(_collateral), \"ACOToken::mint: Invalid call\");\n        \n        _transferFromERC20(_collateral, msg.sender, address(this), collateralAmount);\n        _mintToken(msg.sender, collateralAmount);\n    }\n    \n    /**\n     * @dev Function to mint tokens with ERC20 deposited as collateral to an informed account.\n     * However, the minted tokens are assigned to the transaction sender.\n     * NOTE: The function only works when the token is NOT expired yet. \n     * @param account Address of the account that will be the collateral owner.\n     * @param collateralAmount Amount of collateral deposited.\n     */\n    function mintTo(address account, uint256 collateralAmount) external {\n        address _collateral = collateral();\n        require(!_isEther(_collateral), \"ACOToken::mintTo: Invalid call\");\n        \n        _transferFromERC20(_collateral, msg.sender, address(this), collateralAmount);\n        _mintToken(account, collateralAmount);\n    }\n    \n    /**\n     * @dev Function to burn tokens and get the collateral, not assigned, back.\n     * NOTE: The function only works when the token is NOT expired yet. \n     * @param tokenAmount Amount of tokens to be burned.\n     */\n    function burn(uint256 tokenAmount) external {\n        _burn(msg.sender, tokenAmount);\n    }\n    \n    /**\n     * @dev Function to burn tokens from a specific account and send the collateral to its address.\n     * The token allowance must be respected.\n     * The collateral is sent to the transaction sender.\n     * NOTE: The function only works when the token is NOT expired yet. \n     * @param account Address of the account.\n     * @param tokenAmount Amount of tokens to be burned.\n     */\n    // SWC-114-Transaction Order Dependence: L441-L443\n    function burnFrom(address account, uint256 tokenAmount) external {\n        _burn(account, tokenAmount);\n    }\n    \n    /**\n     * @dev Function to get the collateral, not assigned, back.\n     * NOTE: The function only works when the token IS expired. \n     */\n    function redeem() external {\n        _redeem(msg.sender);\n    }\n    \n    /**\n     * @dev Function to get the collateral from a specific account sent back to its address .\n     * The token allowance must be respected.\n     * The collateral is sent to the transaction sender.\n     * NOTE: The function only works when the token IS expired. \n     * @param account Address of the account.\n     */\n    function redeemFrom(address account) external {\n        require(tokenData[account].amount <= allowance(account, msg.sender), \"ACOToken::redeemFrom: No allowance\");\n        _redeem(account);\n    }\n    \n    /**\n     * @dev Function to exercise the tokens, paying to get the equivalent collateral.\n     * The paid amount is sent to the collateral owners that were assigned.\n     * NOTE: The function only works when the token is NOT expired. \n     * @param tokenAmount Amount of tokens.\n     */\n    function exercise(uint256 tokenAmount) external payable {\n        _exercise(msg.sender, tokenAmount);\n    }\n    \n    /**\n     * @dev Function to exercise the tokens from an account, paying to get the equivalent collateral.\n     * The token allowance must be respected.\n     * The paid amount is sent to the collateral owners that were assigned.\n     * The collateral is transferred to the transaction sender.\n     * NOTE: The function only works when the token is NOT expired. \n     * @param account Address of the account.\n     * @param tokenAmount Amount of tokens.\n     */\n    function exerciseFrom(address account, uint256 tokenAmount) external payable {\n        _exercise(account, tokenAmount);\n    }\n    \n    /**\n     * @dev Function to exercise the tokens, paying to get the equivalent collateral.\n     * The paid amount is sent to the collateral owners (on accounts list) that were assigned.\n     * NOTE: The function only works when the token is NOT expired. \n     * @param tokenAmount Amount of tokens.\n     * @param accounts The array of addresses to get collateral from.\n     */\n    function exerciseAccounts(uint256 tokenAmount, address[] calldata accounts) external payable {\n        _exerciseFromAccounts(msg.sender, tokenAmount, accounts);\n    }\n    \n    /**\n     * @dev Function to exercise the tokens from a specific account, paying to get the equivalent collateral sent to its address.\n     * The token allowance must be respected.\n     * The paid amount is sent to the collateral owners (on accounts list) that were assigned.\n     * The collateral is transferred to the transaction sender.\n     * NOTE: The function only works when the token is NOT expired. \n     * @param account Address of the account.\n     * @param tokenAmount Amount of tokens.\n     * @param accounts The array of addresses to get the deposited collateral.\n     */\n    function exerciseAccountsFrom(address account, uint256 tokenAmount, address[] calldata accounts) external payable {\n        _exerciseFromAccounts(account, tokenAmount, accounts);\n    }\n    \n    /**\n     * @dev Function to burn the tokens after expiration.\n     * It is an optional function to `clear` the account wallet from an expired and not functional token.\n     * NOTE: The function only works when the token IS expired. \n     */\n    function clear() external {\n        _clear(msg.sender);\n    }\n    \n    /**\n     * @dev Function to burn the tokens from an account after expiration.\n     * It is an optional function to `clear` the account wallet from an expired and not functional token.\n     * The token allowance must be respected.\n     * NOTE: The function only works when the token IS expired. \n     * @param account Address of the account.\n     */\n    function clearFrom(address account) external {\n        _clear(account);\n    }\n    \n    /**\n     * @dev Internal function to burn the tokens from an account after expiration.\n     * @param account Address of the account.\n     */\n    function _clear(address account) internal {\n        require(!_notExpired(), \"ACOToken::_clear: Token not expired yet\");\n        require(!_accountHasCollateral(account), \"ACOToken::_clear: Must call the redeem method\");\n        \n        _callBurn(account, balanceOf(account));\n    }\n    \n    /**\n     * @dev Internal function to redeem respective collateral from an account.\n     * @param account Address of the account.\n     * @param tokenAmount Amount of tokens.\n     */\n    function _redeemCollateral(address account, uint256 tokenAmount) internal {\n        require(_accountHasCollateral(account), \"ACOToken::_redeemCollateral: No collateral available\");\n        require(tokenAmount > 0, \"ACOToken::_redeemCollateral: Invalid token amount\");\n        \n        TokenCollateralized storage data = tokenData[account];\n        data.amount = data.amount.sub(tokenAmount);\n        \n        _removeCollateralDataIfNecessary(account);\n        \n        _transferCollateral(account, getCollateralAmount(tokenAmount), 0);\n    }\n    \n    /**\n     * @dev Internal function to mint tokens.\n     * The tokens are minted for the transaction sender.\n     * @param account Address of the account.\n     * @param collateralAmount Amount of collateral deposited.\n     */\n    function _mintToken(address account, uint256 collateralAmount) nonReentrant notExpired internal {\n        require(collateralAmount > 0, \"ACOToken::_mintToken: Invalid collateral amount\");\n        // SWC-128-DoS With Block Gas Limit: L570-L573\n        if (!_accountHasCollateral(account)) {\n            tokenData[account].index = _collateralOwners.length;\n            _collateralOwners.push(account);\n        }\n        \n        uint256 tokenAmount = getTokenAmount(collateralAmount);\n        tokenData[account].amount = tokenData[account].amount.add(tokenAmount);\n        \n        totalCollateral = totalCollateral.add(collateralAmount);\n        \n        emit CollateralDeposit(account, collateralAmount);\n        \n        super._mintAction(msg.sender, tokenAmount);\n    }\n    \n    /**\n     * @dev Internal function to transfer tokens. \n     * The token transfer only works when the token is NOT expired. \n     * @param sender Source of the tokens.\n     * @param recipient Destination address for the tokens.\n     * @param amount Amount of tokens.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) notExpired internal override {\n        super._transferAction(sender, recipient, amount);\n    }\n    \n    /**\n     * @dev Internal function to set the token permission from an account to another address. \n     * The token approval only works when the token is NOT expired. \n     * @param owner Address of the token owner.\n     * @param spender Address of the spender authorized.\n     * @param amount Amount of tokens authorized.\n     */\n    function _approve(address owner, address spender, uint256 amount) notExpired internal override {\n        super._approveAction(owner, spender, amount);\n    }\n    \n    /**\n     * @dev Internal function to transfer collateral. \n     * When there is a fee, the calculated fee is also transferred to the destination fee address.\n     * The collateral destination is always the transaction sender address.\n     * @param account Address of the account.\n     * @param collateralAmount Amount of collateral to be redeemed.\n     * @param fee Amount of fee charged.\n     */\n    function _transferCollateral(address account, uint256 collateralAmount, uint256 fee) internal {\n        \n        totalCollateral = totalCollateral.sub(collateralAmount.add(fee));\n        \n        address _collateral = collateral();\n        if (_isEther(_collateral)) {\n            payable(msg.sender).transfer(collateralAmount);\n            if (fee > 0) {\n                feeDestination.transfer(fee);   \n            }\n        } else {\n            _transferERC20(_collateral, msg.sender, collateralAmount);\n            if (fee > 0) {\n                _transferERC20(_collateral, feeDestination, fee);\n            }\n        }\n        \n        emit CollateralWithdraw(account, msg.sender, collateralAmount, fee);\n    }\n    \n    /**\n     * @dev Internal function to exercise the tokens from an account. \n     * @param account Address of the account that is exercising.\n     * @param tokenAmount Amount of tokens.\n     */\n    function _exercise(address account, uint256 tokenAmount) nonReentrant internal {\n        _validateAndBurn(account, tokenAmount);\n        _exerciseOwners(account, tokenAmount);\n        (uint256 collateralAmount, uint256 fee) = getCollateralOnExercise(tokenAmount);\n        _transferCollateral(account, collateralAmount, fee);\n    }\n    \n    /**\n     * @dev Internal function to exercise the tokens from an account. \n     * @param account Address of the account that is exercising.\n     * @param tokenAmount Amount of tokens.\n     * @param accounts The array of addresses to get the collateral from.\n     */\n    function _exerciseFromAccounts(address account, uint256 tokenAmount, address[] memory accounts) nonReentrant internal {\n        _validateAndBurn(account, tokenAmount);\n        _exerciseAccounts(account, tokenAmount, accounts);\n        (uint256 collateralAmount, uint256 fee) = getCollateralOnExercise(tokenAmount);\n        _transferCollateral(account, collateralAmount, fee);\n    }\n    \n    /**\n     * @dev Internal function to exercise the assignable tokens from the stored list of collateral owners. \n     * @param exerciseAccount Address of the account that is exercising.\n     * @param tokenAmount Amount of tokens.\n     */\n    function _exerciseOwners(address exerciseAccount, uint256 tokenAmount) internal {\n        uint256 start = _collateralOwners.length - 1;\n        for (uint256 i = start; i >= 0; --i) {\n            if (tokenAmount == 0) {\n                break;\n            }\n            tokenAmount = _exerciseAccount(_collateralOwners[i], tokenAmount, exerciseAccount);\n        }\n        require(tokenAmount == 0, \"ACOToken::_exerciseOwners: Invalid remaining amount\");\n    }\n    \n    /**\n     * @dev Internal function to exercise the assignable tokens from an accounts list. \n     * @param exerciseAccount Address of the account that is exercising.\n     * @param tokenAmount Amount of tokens.\n     * @param accounts The array of addresses to get the collateral from.\n     */\n    function _exerciseAccounts(address exerciseAccount, uint256 tokenAmount, address[] memory accounts) internal {\n        for (uint256 i = 0; i < accounts.length; ++i) {\n            if (tokenAmount == 0) {\n                break;\n            }\n            tokenAmount = _exerciseAccount(accounts[i], tokenAmount, exerciseAccount);\n        }\n        require(tokenAmount == 0, \"ACOToken::_exerciseAccounts: Invalid remaining amount\");\n    }\n    \n    /**\n     * @dev Internal function to exercise the assignable tokens from an account and transfer to its address the respective payment. \n     * @param account Address of the account.\n     * @param tokenAmount Amount of tokens.\n     * @param exerciseAccount Address of the account that is exercising.\n     * @return Remaining amount of tokens.\n     */\n    function _exerciseAccount(address account, uint256 tokenAmount, address exerciseAccount) internal returns(uint256) {\n        uint256 available = _getAssignableAmount(account);\n        if (available > 0) {\n            \n            TokenCollateralized storage data = tokenData[account];\n            uint256 valueToTransfer;\n            if (available < tokenAmount) {\n                valueToTransfer = available;\n                tokenAmount = tokenAmount.sub(available);\n            } else {\n                valueToTransfer = tokenAmount;\n                tokenAmount = 0;\n            }\n            \n            (address exerciseAsset, uint256 amount) = getExerciseData(valueToTransfer);\n\n            data.amount = data.amount.sub(valueToTransfer); \n            \n            _removeCollateralDataIfNecessary(account);\n            \n            if (_isEther(exerciseAsset)) {\n                payable(account).transfer(amount);\n            } else {\n                _transferERC20(exerciseAsset, account, amount);\n            }\n            emit Assigned(account, exerciseAccount, amount, valueToTransfer);\n        }\n        \n        return tokenAmount;\n    }\n    \n    /**\n     * @dev Internal function to validate the exercise operation and burn the respective tokens.\n     * @param account Address of the account that is exercising.\n     * @param tokenAmount Amount of tokens.\n     */\n    function _validateAndBurn(address account, uint256 tokenAmount) notExpired internal {\n        require(tokenAmount > 0, \"ACOToken::_validateAndBurn: Invalid token amount\");\n        \n        // Whether an account has deposited collateral it only can exercise the extra amount of unassignable tokens.\n        if (_accountHasCollateral(account)) {\n            // SWC-135-Code With No Effects: L741\n            require(balanceOf(account) > tokenData[account].amount, \"ACOToken::_validateAndBurn: Tokens compromised\");\n            require(tokenAmount <= balanceOf(account).sub(tokenData[account].amount), \"ACOToken::_validateAndBurn: Token amount not available\"); \n        }\n        \n        _callBurn(account, tokenAmount);\n        \n        (address exerciseAsset, uint256 expectedAmount) = getExerciseData(tokenAmount);\n\n        if (_isEther(exerciseAsset)) {\n            require(msg.value == expectedAmount, \"ACOToken::_validateAndBurn: Invalid ether amount\");\n        } else {\n            require(msg.value == 0, \"ACOToken::_validateAndBurn: No ether expected\");\n            _transferFromERC20(exerciseAsset, msg.sender, address(this), expectedAmount);\n        }\n    }\n    \n    /**\n     * @dev Internal function to calculate the token strike price relation.\n     * @param tokenAmount Amount of tokens.\n     * @return Calculated value with strike asset precision.\n     */\n    function _getTokenStrikePriceRelation(uint256 tokenAmount) internal view returns(uint256) {\n        return tokenAmount.mul(strikePrice).div(underlyingPrecision);\n    }\n    \n    /**\n     * @dev Internal function to get the collateral sent back from an account.\n     * Function to be called when the token IS expired.\n     * @param account Address of the account.\n     */\n    function _redeem(address account) nonReentrant internal {\n        require(!_notExpired(), \"ACOToken::_redeem: Token not expired yet\");\n        \n        _redeemCollateral(account, tokenData[account].amount);\n        super._burnAction(account, balanceOf(account));\n    }\n    \n    /**\n     * @dev Internal function to burn tokens from an account and get the collateral, not assigned, back.\n     * @param account Address of the account.\n     * @param tokenAmount Amount of tokens to be burned.\n     */\n    function _burn(address account, uint256 tokenAmount) nonReentrant notExpired internal {\n        _redeemCollateral(account, tokenAmount);\n        _callBurn(account, tokenAmount);\n    }\n    \n    /**\n     * @dev Internal function to burn tokens.\n     * @param account Address of the account.\n     * @param tokenAmount Amount of tokens to be burned.\n     */\n    function _callBurn(address account, uint256 tokenAmount) internal {\n        if (account == msg.sender) {\n            super._burnAction(account, tokenAmount);\n        } else {\n            super._burnFrom(account, tokenAmount);\n        }\n    }\n    \n    /**\n     * @dev Internal function to get the amount of assignable token from an account.\n     * @param account Address of the account.\n     * @return The assignable amount of tokens.\n     */\n    function _getAssignableAmount(address account) internal view returns(uint256) {\n        if (tokenData[account].amount > balanceOf(account)) {\n            return tokenData[account].amount.sub(balanceOf(account));\n        } else {\n            return 0;\n        }\n    }\n    \n    /**\n     * @dev Internal function to remove the token data with collateral if its total amount was assigned.\n     * @param account Address of account.\n     */\n    function _removeCollateralDataIfNecessary(address account) internal {\n        TokenCollateralized storage data = tokenData[account];\n        if (!_hasCollateral(data)) {\n            uint256 lastIndex = _collateralOwners.length - 1;\n            if (lastIndex != data.index) {\n                address last = _collateralOwners[lastIndex];\n                tokenData[last].index = data.index;\n                _collateralOwners[data.index] = last;\n            }\n            _collateralOwners.pop();\n            delete tokenData[account];\n        }\n    }\n    \n    /**\n     * @dev Internal function to get if the token is not expired.\n     * @return Whether the token is NOT expired.\n     */\n    function _notExpired() internal view returns(bool) {\n        return now <= expiryTime;\n    }\n    \n    /**\n     * @dev Internal function to get if an account has collateral deposited.\n     * @param account Address of the account.\n     * @return Whether the account has collateral deposited.\n     */\n    function _accountHasCollateral(address account) internal view returns(bool) {\n        return _hasCollateral(tokenData[account]);\n    }\n    \n    /**\n     * @dev Internal function to get if an account has collateral deposited.\n     * @param data Token data from an account.\n     * @return Whether the account has collateral deposited.\n     */    \n    function _hasCollateral(TokenCollateralized storage data) internal view returns(bool) {\n        return data.amount > 0;\n    }\n    \n    /**\n     * @dev Internal function to get if the address is for Ethereum (0x0).\n     * @param _address Address to be checked.\n     * @return Whether the address is for Ethereum.\n     */ \n    function _isEther(address _address) internal pure returns(bool) {\n        return _address == address(0);\n    } \n    \n    /**\n     * @dev Internal function to get the token name.\n     * The token name is assembled  with the token data:\n     * ACO UNDERLYING_SYMBOL-EXPIRYTIME-STRIKE_PRICE_STRIKE_ASSET_SYMBOL-TYPE\n     * @return The token name.\n     */\n    function _name() internal view returns(string memory) {\n        return string(abi.encodePacked(\n            \"ACO \",\n            underlyingSymbol,\n            \"-\",\n            _getFormattedStrikePrice(),\n            strikeAssetSymbol,\n            \"-\",\n            _getType(),\n            \"-\",\n            _getFormattedExpiryTime()\n        ));\n    }\n    \n    /**\n     * @dev Internal function to get the token type description.\n     * @return The token type description.\n     */\n    function _getType() internal view returns(string memory) {\n        if (isCall) {\n            return \"C\";\n        } else {\n            return \"P\";\n        }\n    }\n    \n    /**\n     * @dev Internal function to get the expiry time formatted.\n     * @return The expiry time formatted.\n     */\n    function _getFormattedExpiryTime() internal view returns(string memory) {\n        (uint256 year, uint256 month, uint256 day, uint256 hour, uint256 minute,) = BokkyPooBahsDateTimeLibrary.timestampToDateTime(expiryTime); \n        return string(abi.encodePacked(\n            _getNumberWithTwoCaracters(day),\n            _getMonthFormatted(month),\n            _getYearFormatted(year),\n            \"-\",\n            _getNumberWithTwoCaracters(hour),\n            _getNumberWithTwoCaracters(minute),\n            \"UTC\"\n            )); \n    }\n    \n    /**\n     * @dev Internal function to get the year formatted with 2 characters.\n     * @return The year formatted.\n     */\n    function _getYearFormatted(uint256 year) internal pure returns(string memory) {\n        bytes memory yearBytes = bytes(Strings.toString(year));\n        bytes memory result = new bytes(2);\n        uint256 startIndex = yearBytes.length - 2;\n        for (uint256 i = startIndex; i < yearBytes.length; i++) {\n            result[i - startIndex] = yearBytes[i];\n        }\n        return string(result);\n    }\n    \n    /**\n     * @dev Internal function to get the month abbreviation.\n     * @return The month abbreviation.\n     */\n    function _getMonthFormatted(uint256 month) internal pure returns(string memory) {\n        if (month == 1) {\n            return \"JAN\";\n        } else if (month == 2) {\n            return \"FEB\";\n        } else if (month == 3) {\n            return \"MAR\";\n        } else if (month == 4) {\n            return \"APR\";\n        } else if (month == 5) {\n            return \"MAY\";\n        } else if (month == 6) {\n            return \"JUN\";\n        } else if (month == 7) {\n            return \"JUL\";\n        } else if (month == 8) {\n            return \"AUG\";\n        } else if (month == 9) {\n            return \"SEP\";\n        } else if (month == 10) {\n            return \"OCT\";\n        } else if (month == 11) {\n            return \"NOV\";\n        } else if (month == 12) {\n            return \"DEC\";\n        } else {\n            return \"INVALID\";\n        }\n    }\n    \n    /**\n     * @dev Internal function to get the number with 2 characters.\n     * @return The 2 characters for the number.\n     */\n    function _getNumberWithTwoCaracters(uint256 number) internal pure returns(string memory) {\n        string memory _string = Strings.toString(number);\n        if (number < 10) {\n            return string(abi.encodePacked(\"0\", _string));\n        } else {\n            return _string;\n        }\n    }\n    \n    /**\n     * @dev Internal function to get the strike price formatted.\n     * @return The strike price formatted.\n     */\n    function _getFormattedStrikePrice() internal view returns(string memory) {\n        uint256 digits;\n        uint256 count;\n        int256 representativeAt = -1;\n        uint256 addPointAt = 0;\n        uint256 temp = strikePrice;\n        uint256 number = strikePrice;\n        while (temp != 0) {\n            if (representativeAt == -1 && (temp % 10 != 0 || count == uint256(strikeAssetDecimals))) {\n                representativeAt = int256(digits);\n                number = temp;\n            }\n            if (representativeAt >= 0) {\n                if (count == uint256(strikeAssetDecimals)) {\n                    addPointAt = digits;\n                }\n                digits++;\n            }\n            temp /= 10;\n            count++;\n        }\n        if (count <= uint256(strikeAssetDecimals)) {\n            digits = digits + 2 + uint256(strikeAssetDecimals) - count;\n            addPointAt = digits - 2;\n        } else if (addPointAt > 0) {\n            digits++;\n        }\n        bytes memory buffer = new bytes(digits);\n        uint256 index = digits - 1;\n        temp = number;\n        for (uint256 i = 0; i < digits; ++i) {\n            if (i > 0 && i == addPointAt) {\n                buffer[index--] = byte(\".\");\n            } else if (number == 0) {\n                buffer[index--] = byte(\"0\");\n            } else {\n                // SWC-135-Code With No Effects: L1018\n                if (representativeAt <= int256(i)) {\n                    buffer[index--] = byte(uint8(48 + number % 10));\n                }\n                number /= 10;\n            }\n        }\n        return string(buffer);\n    }\n    \n    /**\n     * @dev Internal function to the asset decimals.\n     * @param asset Address of the asset.\n     * @return The asset decimals.\n     */\n    function _getAssetDecimals(address asset) internal view returns(uint8) {\n        if (_isEther(asset)) {\n            return uint8(18);\n        } else {\n            (bool success, bytes memory returndata) = asset.staticcall(abi.encodeWithSignature(\"decimals()\"));\n            require(success, \"ACOToken::_getAssetDecimals: Invalid asset decimals\");\n            return abi.decode(returndata, (uint8));\n        }\n    }\n    \n    /**\n     * @dev Internal function to the asset symbol.\n     * @param asset Address of the asset.\n     * @return The asset symbol.\n     */\n    function _getAssetSymbol(address asset) internal view returns(string memory) {\n        if (_isEther(asset)) {\n            return \"ETH\";\n        } else {\n            (bool success, bytes memory returndata) = asset.staticcall(abi.encodeWithSignature(\"symbol()\"));\n            require(success, \"ACOToken::_getAssetSymbol: Invalid asset symbol\");\n            return abi.decode(returndata, (string));\n        }\n    }\n    \n    /**\n     * @dev Internal function to transfer ERC20 tokens.\n     * @param token Address of the token.\n     * @param recipient Address of the transfer destination.\n     * @param amount Amount to transfer.\n     */\n     function _transferERC20(address token, address recipient, uint256 amount) internal {\n        (bool success, bytes memory returndata) = token.call(abi.encodeWithSelector(_transferSelector, recipient, amount));\n        require(success && (returndata.length == 0 || abi.decode(returndata, (bool))), \"ACOToken::_transferERC20\");\n    }\n    \n    /**\n     * @dev Internal function to call transferFrom on ERC20 tokens.\n     * @param token Address of the token.\n     * @param sender Address of the sender.\n     * @param recipient Address of the transfer destination.\n     * @param amount Amount to transfer.\n     */\n     function _transferFromERC20(address token, address sender, address recipient, uint256 amount) internal {\n        (bool success, bytes memory returndata) = token.call(abi.encodeWithSelector(_transferFromSelector, sender, recipient, amount));\n        require(success && (returndata.length == 0 || abi.decode(returndata, (bool))), \"ACOToken::_transferFromERC20\");\n    }\n}",
        "function": "approve(address,uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/openzeppelin-ACO_Protocol/aco-36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/core/ACOToken.sol",
        "vulnerability": "Dependence on predictable environment variable (SWC 116)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract ACOToken is ERC20 {\n    using Address for address;\n    \n    /**\n     * @dev Struct to store the accounts that generated tokens with a collateral deposit.\n     */\n    struct TokenCollateralized {\n        /**\n         * @dev Current amount of tokens.\n         */\n        uint256 amount;\n        \n        /**\n         * @dev Index on the collateral owners array.\n         */\n        uint256 index;\n    }\n    \n    /**\n     * @dev Emitted when collateral is deposited on the contract.\n     * @param account Address of the collateral owner.\n     * @param amount Amount of collateral deposited.\n     */\n    event CollateralDeposit(address indexed account, uint256 amount);\n    \n    /**\n     * @dev Emitted when collateral is withdrawn from the contract.\n     * @param account Address of the account.\n     * @param recipient Address of the collateral destination.\n     * @param amount Amount of collateral withdrawn.\n     * @param fee The fee amount charged on the withdrawal.\n     */\n    event CollateralWithdraw(address indexed account, address indexed recipient, uint256 amount, uint256 fee);\n    \n    /**\n     * @dev Emitted when the collateral is used on an assignment.\n     * @param from Address of the account of the collateral owner.\n     * @param to Address of the account that exercises tokens to get the collateral.\n     * @param paidAmount Amount paid to the collateral owner.\n     * @param tokenAmount Amount of tokens used to exercise.\n     */\n    event Assigned(address indexed from, address indexed to, uint256 paidAmount, uint256 tokenAmount);\n\n    /**\n     * @dev The ERC20 token address for the underlying asset (0x0 for Ethereum). \n     */\n    address public underlying;\n    \n    /**\n     * @dev The ERC20 token address for the strike asset (0x0 for Ethereum). \n     */\n    address public strikeAsset;\n    \n    /**\n     * @dev Address of the fee destination charged on the exercise.\n     */\n    address payable public feeDestination;\n    \n    /**\n     * @dev True if the type is CALL, false for PUT.\n     */\n    bool public isCall;\n    \n    /**\n     * @dev The strike price for the token with the strike asset precision.\n     */\n    uint256 public strikePrice;\n    \n    /**\n     * @dev The UNIX time for the token expiration.\n     */\n    uint256 public expiryTime;\n    \n    /**\n     * @dev The total amount of collateral on the contract.\n     */\n    uint256 public totalCollateral;\n    \n    /**\n     * @dev The fee value. It is a percentage value (100000 is 100%).\n     */\n    uint256 public acoFee;\n    \n    /**\n     * @dev Symbol of the underlying asset.\n     */\n    string public underlyingSymbol;\n    \n    /**\n     * @dev Symbol of the strike asset.\n     */\n    string public strikeAssetSymbol;\n    \n    /**\n     * @dev Decimals for the underlying asset.\n     */\n    uint8 public underlyingDecimals;\n    \n    /**\n     * @dev Decimals for the strike asset.\n     */\n    uint8 public strikeAssetDecimals;\n    \n    /**\n     * @dev Underlying precision. (10 ^ underlyingDecimals)\n     */\n    uint256 internal underlyingPrecision;\n    \n    /**\n     * @dev Accounts that generated tokens with a collateral deposit.\n     */\n    mapping(address => TokenCollateralized) internal tokenData;\n    \n    /**\n     * @dev Array with all accounts with collateral deposited.\n     */\n    address[] internal _collateralOwners;\n    \n    /**\n     * @dev Internal data to control the reentrancy.\n     */\n    bool internal _notEntered;\n    \n    /**\n     * @dev Selector for ERC20 transfer function.\n     */\n    bytes4 internal _transferSelector;\n    \n    /**\n     * @dev Selector for ERC20 transfer from function.\n     */\n    bytes4 internal _transferFromSelector;\n    \n    /**\n     * @dev Modifier to check if the token is not expired.\n     * It is executed only while the token is not expired.\n     */\n    modifier notExpired() {\n        require(_notExpired(), \"ACOToken::Expired\");\n        _;\n    }\n    \n    /**\n     * @dev Modifier to prevents a contract from calling itself during the function execution.\n     */\n    modifier nonReentrant() {\n        require(_notEntered, \"ACOToken::Reentry\");\n        _notEntered = false;\n        _;\n        _notEntered = true;\n    }\n    \n    /**\n     * @dev Function to initialize the contract.\n     * It should be called when creating the token.\n     * It must be called only once. The `assert` is to guarantee that behavior.\n     * @param _underlying Address of the underlying asset (0x0 for Ethereum).\n     * @param _strikeAsset Address of the strike asset (0x0 for Ethereum).\n     * @param _isCall True if the type is CALL, false for PUT.\n     * @param _strikePrice The strike price with the strike asset precision.\n     * @param _expiryTime The UNIX time for the token expiration.\n     * @param _acoFee Value of the ACO fee. It is a percentage value (100000 is 100%).\n     * @param _feeDestination Address of the fee destination charged on the exercise.\n     */\n    function init(\n        address _underlying,\n        address _strikeAsset,\n        bool _isCall,\n        uint256 _strikePrice,\n        uint256 _expiryTime,\n        uint256 _acoFee,\n        address payable _feeDestination\n    ) public {\n        require(underlying == address(0) && strikeAsset == address(0) && strikePrice == 0, \"ACOToken::init: Already initialized\");\n        \n        require(_expiryTime > now, \"ACOToken::init: Invalid expiry\");\n        require(_strikePrice > 0, \"ACOToken::init: Invalid strike price\");\n        require(_underlying != _strikeAsset, \"ACOToken::init: Same assets\");\n        require(_acoFee <= 500, \"ACOToken::init: Invalid ACO fee\"); // Maximum is 0.5%\n        require(_isEther(_underlying) || _underlying.isContract(), \"ACOToken::init: Invalid underlying\");\n        require(_isEther(_strikeAsset) || _strikeAsset.isContract(), \"ACOToken::init: Invalid strike asset\");\n        \n        underlying = _underlying;\n        strikeAsset = _strikeAsset;\n        isCall = _isCall;\n        strikePrice = _strikePrice;\n        expiryTime = _expiryTime;\n        acoFee = _acoFee;\n        feeDestination = _feeDestination;\n        underlyingDecimals = _getAssetDecimals(_underlying);\n        strikeAssetDecimals = _getAssetDecimals(_strikeAsset);\n        underlyingSymbol = _getAssetSymbol(_underlying);\n        strikeAssetSymbol = _getAssetSymbol(_strikeAsset);\n        // SWC-101-Integer Overflow and Underflow: L207\n        underlyingPrecision = 10 ** uint256(underlyingDecimals);\n\n        _transferSelector = bytes4(keccak256(bytes(\"transfer(address,uint256)\")));\n        _transferFromSelector = bytes4(keccak256(bytes(\"transferFrom(address,address,uint256)\")));\n        _notEntered = true;\n    }\n    \n    /**\n     * @dev Function to guarantee that the contract will not receive ether directly.\n     */\n    receive() external payable {\n        revert();\n    }\n    \n    /**\n     * @dev Function to get the token name.\n     */\n    function name() public view override returns(string memory) {\n        return _name();\n    }\n    \n    /**\n     * @dev Function to get the token symbol, that it is equal to the name.\n     */\n    function symbol() public view override returns(string memory) {\n        return _name();\n    }\n    \n    /**\n     * @dev Function to get the token decimals, that it is equal to the underlying asset decimals.\n     */\n    function decimals() public view override returns(uint8) {\n        return underlyingDecimals;\n    }\n    \n    /**\n     * @dev Function to get the current amount of collateral for an account.\n     * @param account Address of the account.\n     * @return The current amount of collateral.\n     */\n    function currentCollateral(address account) public view returns(uint256) {\n        return getCollateralAmount(currentCollateralizedTokens(account));\n    }\n    \n    /**\n     * @dev Function to get the current amount of unassignable collateral for an account.\n     * NOTE: The function is valid when the token is NOT expired yet. \n     * After expiration, the unassignable collateral is equal to the account's collateral balance.\n     * @param account Address of the account.\n     * @return The respective amount of unassignable collateral.\n     */\n    function unassignableCollateral(address account) public view returns(uint256) {\n        return getCollateralAmount(unassignableTokens(account));\n    }\n    \n    /**\n     * @dev Function to get  the current amount of assignable collateral for an account.\n     * NOTE: The function is valid when the token is NOT expired yet. \n     * After expiration, the assignable collateral is zero.\n     * @param account Address of the account.\n     * @return The respective amount of assignable collateral.\n     */\n    function assignableCollateral(address account) public view returns(uint256) {\n        return getCollateralAmount(assignableTokens(account));\n    }\n    \n    /**\n     * @dev Function to get the current amount of collateralized tokens for an account.\n     * @param account Address of the account.\n     * @return The current amount of collateralized tokens.\n     */\n    function currentCollateralizedTokens(address account) public view returns(uint256) {\n        return tokenData[account].amount;\n    }\n    \n    /**\n     * @dev Function to get the current amount of unassignable tokens for an account.\n     * NOTE: The function is valid when the token is NOT expired yet. \n     * After expiration, the unassignable tokens is equal to the account's collateralized tokens.\n     * @param account Address of the account.\n     * @return The respective amount of unassignable tokens.\n     */\n    function unassignableTokens(address account) public view returns(uint256) {\n        if (balanceOf(account) > tokenData[account].amount) {\n            return tokenData[account].amount;\n        } else {\n            return balanceOf(account);\n        }\n    }\n    \n    /**\n     * @dev Function to get  the current amount of assignable tokens for an account.\n     * NOTE: The function is valid when the token is NOT expired yet. \n     * After expiration, the assignable tokens is zero.\n     * @param account Address of the account.\n     * @return The respective amount of assignable tokens.\n     */\n    function assignableTokens(address account) public view returns(uint256) {\n        return _getAssignableAmount(account);\n    }\n    \n    /**\n     * @dev Function to get the equivalent collateral amount for a token amount.\n     * @param tokenAmount Amount of tokens.\n     * @return The respective amount of collateral.\n     */\n    function getCollateralAmount(uint256 tokenAmount) public view returns(uint256) {\n        if (isCall) {\n            return tokenAmount;\n        } else if (tokenAmount > 0) {\n            return _getTokenStrikePriceRelation(tokenAmount);\n        } else {\n            return 0;\n        }\n    }\n    \n    /**\n     * @dev Function to get the equivalent token amount for a collateral amount.\n     * @param collateralAmount Amount of collateral.\n     * @return The respective amount of tokens.\n     */\n    function getTokenAmount(uint256 collateralAmount) public view returns(uint256) {\n        if (isCall) {\n            return collateralAmount;\n        } else if (collateralAmount > 0) {\n            return collateralAmount.mul(underlyingPrecision).div(strikePrice);\n        } else {\n            return 0;\n        }\n    }\n    \n    /**\n     * @dev Function to get the data for exercise of an amount of token.\n     * @param tokenAmount Amount of tokens.\n     * @return The asset and the respective amount that should be sent to get the collateral.\n     */\n    function getExerciseData(uint256 tokenAmount) public view returns(address, uint256) {\n        if (isCall) {\n            return (strikeAsset, _getTokenStrikePriceRelation(tokenAmount)); \n        } else {\n            return (underlying, tokenAmount);\n        }\n    }\n    \n    /**\n     * @dev Function to get the collateral to be received on an exercise and the respective fee.\n     * @param tokenAmount Amount of tokens.\n     * @return The collateral to be received and the respective fee.\n     */\n    function getCollateralOnExercise(uint256 tokenAmount) public view returns(uint256, uint256) {\n        uint256 collateralAmount = getCollateralAmount(tokenAmount);\n        uint256 fee = collateralAmount.mul(acoFee).div(100000);\n        collateralAmount = collateralAmount.sub(fee);\n        return (collateralAmount, fee);\n    }\n    \n    /**\n     * @dev Function to get the collateral asset.\n     * @return The address of the collateral asset.\n     */\n    function collateral() public view returns(address) {\n        if (isCall) {\n            return underlying;\n        } else {\n            return strikeAsset;\n        }\n    }\n    \n    /**\n     * @dev Function to mint tokens with Ether deposited as collateral.\n     * NOTE: The function only works when the token is NOT expired yet. \n     */\n    function mintPayable() external payable {\n        require(_isEther(collateral()), \"ACOToken::mintPayable: Invalid call\");\n       _mintToken(msg.sender, msg.value);\n    }\n    \n    /**\n     * @dev Function to mint tokens with Ether deposited as collateral to an informed account.\n     * However, the minted tokens are assigned to the transaction sender.\n     * NOTE: The function only works when the token is NOT expired yet. \n     * @param account Address of the account that will be the collateral owner.\n     */\n    function mintToPayable(address account) external payable {\n        require(_isEther(collateral()), \"ACOToken::mintToPayable: Invalid call\");\n       _mintToken(account, msg.value);\n    }\n    \n    /**\n     * @dev Function to mint tokens with ERC20 deposited as collateral.\n     * NOTE: The function only works when the token is NOT expired yet. \n     * @param collateralAmount Amount of collateral deposited.\n     */\n    function mint(uint256 collateralAmount) external {\n        address _collateral = collateral();\n        require(!_isEther(_collateral), \"ACOToken::mint: Invalid call\");\n        \n        _transferFromERC20(_collateral, msg.sender, address(this), collateralAmount);\n        _mintToken(msg.sender, collateralAmount);\n    }\n    \n    /**\n     * @dev Function to mint tokens with ERC20 deposited as collateral to an informed account.\n     * However, the minted tokens are assigned to the transaction sender.\n     * NOTE: The function only works when the token is NOT expired yet. \n     * @param account Address of the account that will be the collateral owner.\n     * @param collateralAmount Amount of collateral deposited.\n     */\n    function mintTo(address account, uint256 collateralAmount) external {\n        address _collateral = collateral();\n        require(!_isEther(_collateral), \"ACOToken::mintTo: Invalid call\");\n        \n        _transferFromERC20(_collateral, msg.sender, address(this), collateralAmount);\n        _mintToken(account, collateralAmount);\n    }\n    \n    /**\n     * @dev Function to burn tokens and get the collateral, not assigned, back.\n     * NOTE: The function only works when the token is NOT expired yet. \n     * @param tokenAmount Amount of tokens to be burned.\n     */\n    function burn(uint256 tokenAmount) external {\n        _burn(msg.sender, tokenAmount);\n    }\n    \n    /**\n     * @dev Function to burn tokens from a specific account and send the collateral to its address.\n     * The token allowance must be respected.\n     * The collateral is sent to the transaction sender.\n     * NOTE: The function only works when the token is NOT expired yet. \n     * @param account Address of the account.\n     * @param tokenAmount Amount of tokens to be burned.\n     */\n    // SWC-114-Transaction Order Dependence: L441-L443\n    function burnFrom(address account, uint256 tokenAmount) external {\n        _burn(account, tokenAmount);\n    }\n    \n    /**\n     * @dev Function to get the collateral, not assigned, back.\n     * NOTE: The function only works when the token IS expired. \n     */\n    function redeem() external {\n        _redeem(msg.sender);\n    }\n    \n    /**\n     * @dev Function to get the collateral from a specific account sent back to its address .\n     * The token allowance must be respected.\n     * The collateral is sent to the transaction sender.\n     * NOTE: The function only works when the token IS expired. \n     * @param account Address of the account.\n     */\n    function redeemFrom(address account) external {\n        require(tokenData[account].amount <= allowance(account, msg.sender), \"ACOToken::redeemFrom: No allowance\");\n        _redeem(account);\n    }\n    \n    /**\n     * @dev Function to exercise the tokens, paying to get the equivalent collateral.\n     * The paid amount is sent to the collateral owners that were assigned.\n     * NOTE: The function only works when the token is NOT expired. \n     * @param tokenAmount Amount of tokens.\n     */\n    function exercise(uint256 tokenAmount) external payable {\n        _exercise(msg.sender, tokenAmount);\n    }\n    \n    /**\n     * @dev Function to exercise the tokens from an account, paying to get the equivalent collateral.\n     * The token allowance must be respected.\n     * The paid amount is sent to the collateral owners that were assigned.\n     * The collateral is transferred to the transaction sender.\n     * NOTE: The function only works when the token is NOT expired. \n     * @param account Address of the account.\n     * @param tokenAmount Amount of tokens.\n     */\n    function exerciseFrom(address account, uint256 tokenAmount) external payable {\n        _exercise(account, tokenAmount);\n    }\n    \n    /**\n     * @dev Function to exercise the tokens, paying to get the equivalent collateral.\n     * The paid amount is sent to the collateral owners (on accounts list) that were assigned.\n     * NOTE: The function only works when the token is NOT expired. \n     * @param tokenAmount Amount of tokens.\n     * @param accounts The array of addresses to get collateral from.\n     */\n    function exerciseAccounts(uint256 tokenAmount, address[] calldata accounts) external payable {\n        _exerciseFromAccounts(msg.sender, tokenAmount, accounts);\n    }\n    \n    /**\n     * @dev Function to exercise the tokens from a specific account, paying to get the equivalent collateral sent to its address.\n     * The token allowance must be respected.\n     * The paid amount is sent to the collateral owners (on accounts list) that were assigned.\n     * The collateral is transferred to the transaction sender.\n     * NOTE: The function only works when the token is NOT expired. \n     * @param account Address of the account.\n     * @param tokenAmount Amount of tokens.\n     * @param accounts The array of addresses to get the deposited collateral.\n     */\n    function exerciseAccountsFrom(address account, uint256 tokenAmount, address[] calldata accounts) external payable {\n        _exerciseFromAccounts(account, tokenAmount, accounts);\n    }\n    \n    /**\n     * @dev Function to burn the tokens after expiration.\n     * It is an optional function to `clear` the account wallet from an expired and not functional token.\n     * NOTE: The function only works when the token IS expired. \n     */\n    function clear() external {\n        _clear(msg.sender);\n    }\n    \n    /**\n     * @dev Function to burn the tokens from an account after expiration.\n     * It is an optional function to `clear` the account wallet from an expired and not functional token.\n     * The token allowance must be respected.\n     * NOTE: The function only works when the token IS expired. \n     * @param account Address of the account.\n     */\n    function clearFrom(address account) external {\n        _clear(account);\n    }\n    \n    /**\n     * @dev Internal function to burn the tokens from an account after expiration.\n     * @param account Address of the account.\n     */\n    function _clear(address account) internal {\n        require(!_notExpired(), \"ACOToken::_clear: Token not expired yet\");\n        require(!_accountHasCollateral(account), \"ACOToken::_clear: Must call the redeem method\");\n        \n        _callBurn(account, balanceOf(account));\n    }\n    \n    /**\n     * @dev Internal function to redeem respective collateral from an account.\n     * @param account Address of the account.\n     * @param tokenAmount Amount of tokens.\n     */\n    function _redeemCollateral(address account, uint256 tokenAmount) internal {\n        require(_accountHasCollateral(account), \"ACOToken::_redeemCollateral: No collateral available\");\n        require(tokenAmount > 0, \"ACOToken::_redeemCollateral: Invalid token amount\");\n        \n        TokenCollateralized storage data = tokenData[account];\n        data.amount = data.amount.sub(tokenAmount);\n        \n        _removeCollateralDataIfNecessary(account);\n        \n        _transferCollateral(account, getCollateralAmount(tokenAmount), 0);\n    }\n    \n    /**\n     * @dev Internal function to mint tokens.\n     * The tokens are minted for the transaction sender.\n     * @param account Address of the account.\n     * @param collateralAmount Amount of collateral deposited.\n     */\n    function _mintToken(address account, uint256 collateralAmount) nonReentrant notExpired internal {\n        require(collateralAmount > 0, \"ACOToken::_mintToken: Invalid collateral amount\");\n        // SWC-128-DoS With Block Gas Limit: L570-L573\n        if (!_accountHasCollateral(account)) {\n            tokenData[account].index = _collateralOwners.length;\n            _collateralOwners.push(account);\n        }\n        \n        uint256 tokenAmount = getTokenAmount(collateralAmount);\n        tokenData[account].amount = tokenData[account].amount.add(tokenAmount);\n        \n        totalCollateral = totalCollateral.add(collateralAmount);\n        \n        emit CollateralDeposit(account, collateralAmount);\n        \n        super._mintAction(msg.sender, tokenAmount);\n    }\n    \n    /**\n     * @dev Internal function to transfer tokens. \n     * The token transfer only works when the token is NOT expired. \n     * @param sender Source of the tokens.\n     * @param recipient Destination address for the tokens.\n     * @param amount Amount of tokens.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) notExpired internal override {\n        super._transferAction(sender, recipient, amount);\n    }\n    \n    /**\n     * @dev Internal function to set the token permission from an account to another address. \n     * The token approval only works when the token is NOT expired. \n     * @param owner Address of the token owner.\n     * @param spender Address of the spender authorized.\n     * @param amount Amount of tokens authorized.\n     */\n    function _approve(address owner, address spender, uint256 amount) notExpired internal override {\n        super._approveAction(owner, spender, amount);\n    }\n    \n    /**\n     * @dev Internal function to transfer collateral. \n     * When there is a fee, the calculated fee is also transferred to the destination fee address.\n     * The collateral destination is always the transaction sender address.\n     * @param account Address of the account.\n     * @param collateralAmount Amount of collateral to be redeemed.\n     * @param fee Amount of fee charged.\n     */\n    function _transferCollateral(address account, uint256 collateralAmount, uint256 fee) internal {\n        \n        totalCollateral = totalCollateral.sub(collateralAmount.add(fee));\n        \n        address _collateral = collateral();\n        if (_isEther(_collateral)) {\n            payable(msg.sender).transfer(collateralAmount);\n            if (fee > 0) {\n                feeDestination.transfer(fee);   \n            }\n        } else {\n            _transferERC20(_collateral, msg.sender, collateralAmount);\n            if (fee > 0) {\n                _transferERC20(_collateral, feeDestination, fee);\n            }\n        }\n        \n        emit CollateralWithdraw(account, msg.sender, collateralAmount, fee);\n    }\n    \n    /**\n     * @dev Internal function to exercise the tokens from an account. \n     * @param account Address of the account that is exercising.\n     * @param tokenAmount Amount of tokens.\n     */\n    function _exercise(address account, uint256 tokenAmount) nonReentrant internal {\n        _validateAndBurn(account, tokenAmount);\n        _exerciseOwners(account, tokenAmount);\n        (uint256 collateralAmount, uint256 fee) = getCollateralOnExercise(tokenAmount);\n        _transferCollateral(account, collateralAmount, fee);\n    }\n    \n    /**\n     * @dev Internal function to exercise the tokens from an account. \n     * @param account Address of the account that is exercising.\n     * @param tokenAmount Amount of tokens.\n     * @param accounts The array of addresses to get the collateral from.\n     */\n    function _exerciseFromAccounts(address account, uint256 tokenAmount, address[] memory accounts) nonReentrant internal {\n        _validateAndBurn(account, tokenAmount);\n        _exerciseAccounts(account, tokenAmount, accounts);\n        (uint256 collateralAmount, uint256 fee) = getCollateralOnExercise(tokenAmount);\n        _transferCollateral(account, collateralAmount, fee);\n    }\n    \n    /**\n     * @dev Internal function to exercise the assignable tokens from the stored list of collateral owners. \n     * @param exerciseAccount Address of the account that is exercising.\n     * @param tokenAmount Amount of tokens.\n     */\n    function _exerciseOwners(address exerciseAccount, uint256 tokenAmount) internal {\n        uint256 start = _collateralOwners.length - 1;\n        for (uint256 i = start; i >= 0; --i) {\n            if (tokenAmount == 0) {\n                break;\n            }\n            tokenAmount = _exerciseAccount(_collateralOwners[i], tokenAmount, exerciseAccount);\n        }\n        require(tokenAmount == 0, \"ACOToken::_exerciseOwners: Invalid remaining amount\");\n    }\n    \n    /**\n     * @dev Internal function to exercise the assignable tokens from an accounts list. \n     * @param exerciseAccount Address of the account that is exercising.\n     * @param tokenAmount Amount of tokens.\n     * @param accounts The array of addresses to get the collateral from.\n     */\n    function _exerciseAccounts(address exerciseAccount, uint256 tokenAmount, address[] memory accounts) internal {\n        for (uint256 i = 0; i < accounts.length; ++i) {\n            if (tokenAmount == 0) {\n                break;\n            }\n            tokenAmount = _exerciseAccount(accounts[i], tokenAmount, exerciseAccount);\n        }\n        require(tokenAmount == 0, \"ACOToken::_exerciseAccounts: Invalid remaining amount\");\n    }\n    \n    /**\n     * @dev Internal function to exercise the assignable tokens from an account and transfer to its address the respective payment. \n     * @param account Address of the account.\n     * @param tokenAmount Amount of tokens.\n     * @param exerciseAccount Address of the account that is exercising.\n     * @return Remaining amount of tokens.\n     */\n    function _exerciseAccount(address account, uint256 tokenAmount, address exerciseAccount) internal returns(uint256) {\n        uint256 available = _getAssignableAmount(account);\n        if (available > 0) {\n            \n            TokenCollateralized storage data = tokenData[account];\n            uint256 valueToTransfer;\n            if (available < tokenAmount) {\n                valueToTransfer = available;\n                tokenAmount = tokenAmount.sub(available);\n            } else {\n                valueToTransfer = tokenAmount;\n                tokenAmount = 0;\n            }\n            \n            (address exerciseAsset, uint256 amount) = getExerciseData(valueToTransfer);\n\n            data.amount = data.amount.sub(valueToTransfer); \n            \n            _removeCollateralDataIfNecessary(account);\n            \n            if (_isEther(exerciseAsset)) {\n                payable(account).transfer(amount);\n            } else {\n                _transferERC20(exerciseAsset, account, amount);\n            }\n            emit Assigned(account, exerciseAccount, amount, valueToTransfer);\n        }\n        \n        return tokenAmount;\n    }\n    \n    /**\n     * @dev Internal function to validate the exercise operation and burn the respective tokens.\n     * @param account Address of the account that is exercising.\n     * @param tokenAmount Amount of tokens.\n     */\n    function _validateAndBurn(address account, uint256 tokenAmount) notExpired internal {\n        require(tokenAmount > 0, \"ACOToken::_validateAndBurn: Invalid token amount\");\n        \n        // Whether an account has deposited collateral it only can exercise the extra amount of unassignable tokens.\n        if (_accountHasCollateral(account)) {\n            // SWC-135-Code With No Effects: L741\n            require(balanceOf(account) > tokenData[account].amount, \"ACOToken::_validateAndBurn: Tokens compromised\");\n            require(tokenAmount <= balanceOf(account).sub(tokenData[account].amount), \"ACOToken::_validateAndBurn: Token amount not available\"); \n        }\n        \n        _callBurn(account, tokenAmount);\n        \n        (address exerciseAsset, uint256 expectedAmount) = getExerciseData(tokenAmount);\n\n        if (_isEther(exerciseAsset)) {\n            require(msg.value == expectedAmount, \"ACOToken::_validateAndBurn: Invalid ether amount\");\n        } else {\n            require(msg.value == 0, \"ACOToken::_validateAndBurn: No ether expected\");\n            _transferFromERC20(exerciseAsset, msg.sender, address(this), expectedAmount);\n        }\n    }\n    \n    /**\n     * @dev Internal function to calculate the token strike price relation.\n     * @param tokenAmount Amount of tokens.\n     * @return Calculated value with strike asset precision.\n     */\n    function _getTokenStrikePriceRelation(uint256 tokenAmount) internal view returns(uint256) {\n        return tokenAmount.mul(strikePrice).div(underlyingPrecision);\n    }\n    \n    /**\n     * @dev Internal function to get the collateral sent back from an account.\n     * Function to be called when the token IS expired.\n     * @param account Address of the account.\n     */\n    function _redeem(address account) nonReentrant internal {\n        require(!_notExpired(), \"ACOToken::_redeem: Token not expired yet\");\n        \n        _redeemCollateral(account, tokenData[account].amount);\n        super._burnAction(account, balanceOf(account));\n    }\n    \n    /**\n     * @dev Internal function to burn tokens from an account and get the collateral, not assigned, back.\n     * @param account Address of the account.\n     * @param tokenAmount Amount of tokens to be burned.\n     */\n    function _burn(address account, uint256 tokenAmount) nonReentrant notExpired internal {\n        _redeemCollateral(account, tokenAmount);\n        _callBurn(account, tokenAmount);\n    }\n    \n    /**\n     * @dev Internal function to burn tokens.\n     * @param account Address of the account.\n     * @param tokenAmount Amount of tokens to be burned.\n     */\n    function _callBurn(address account, uint256 tokenAmount) internal {\n        if (account == msg.sender) {\n            super._burnAction(account, tokenAmount);\n        } else {\n            super._burnFrom(account, tokenAmount);\n        }\n    }\n    \n    /**\n     * @dev Internal function to get the amount of assignable token from an account.\n     * @param account Address of the account.\n     * @return The assignable amount of tokens.\n     */\n    function _getAssignableAmount(address account) internal view returns(uint256) {\n        if (tokenData[account].amount > balanceOf(account)) {\n            return tokenData[account].amount.sub(balanceOf(account));\n        } else {\n            return 0;\n        }\n    }\n    \n    /**\n     * @dev Internal function to remove the token data with collateral if its total amount was assigned.\n     * @param account Address of account.\n     */\n    function _removeCollateralDataIfNecessary(address account) internal {\n        TokenCollateralized storage data = tokenData[account];\n        if (!_hasCollateral(data)) {\n            uint256 lastIndex = _collateralOwners.length - 1;\n            if (lastIndex != data.index) {\n                address last = _collateralOwners[lastIndex];\n                tokenData[last].index = data.index;\n                _collateralOwners[data.index] = last;\n            }\n            _collateralOwners.pop();\n            delete tokenData[account];\n        }\n    }\n    \n    /**\n     * @dev Internal function to get if the token is not expired.\n     * @return Whether the token is NOT expired.\n     */\n    function _notExpired() internal view returns(bool) {\n        return now <= expiryTime;\n    }\n    \n    /**\n     * @dev Internal function to get if an account has collateral deposited.\n     * @param account Address of the account.\n     * @return Whether the account has collateral deposited.\n     */\n    function _accountHasCollateral(address account) internal view returns(bool) {\n        return _hasCollateral(tokenData[account]);\n    }\n    \n    /**\n     * @dev Internal function to get if an account has collateral deposited.\n     * @param data Token data from an account.\n     * @return Whether the account has collateral deposited.\n     */    \n    function _hasCollateral(TokenCollateralized storage data) internal view returns(bool) {\n        return data.amount > 0;\n    }\n    \n    /**\n     * @dev Internal function to get if the address is for Ethereum (0x0).\n     * @param _address Address to be checked.\n     * @return Whether the address is for Ethereum.\n     */ \n    function _isEther(address _address) internal pure returns(bool) {\n        return _address == address(0);\n    } \n    \n    /**\n     * @dev Internal function to get the token name.\n     * The token name is assembled  with the token data:\n     * ACO UNDERLYING_SYMBOL-EXPIRYTIME-STRIKE_PRICE_STRIKE_ASSET_SYMBOL-TYPE\n     * @return The token name.\n     */\n    function _name() internal view returns(string memory) {\n        return string(abi.encodePacked(\n            \"ACO \",\n            underlyingSymbol,\n            \"-\",\n            _getFormattedStrikePrice(),\n            strikeAssetSymbol,\n            \"-\",\n            _getType(),\n            \"-\",\n            _getFormattedExpiryTime()\n        ));\n    }\n    \n    /**\n     * @dev Internal function to get the token type description.\n     * @return The token type description.\n     */\n    function _getType() internal view returns(string memory) {\n        if (isCall) {\n            return \"C\";\n        } else {\n            return \"P\";\n        }\n    }\n    \n    /**\n     * @dev Internal function to get the expiry time formatted.\n     * @return The expiry time formatted.\n     */\n    function _getFormattedExpiryTime() internal view returns(string memory) {\n        (uint256 year, uint256 month, uint256 day, uint256 hour, uint256 minute,) = BokkyPooBahsDateTimeLibrary.timestampToDateTime(expiryTime); \n        return string(abi.encodePacked(\n            _getNumberWithTwoCaracters(day),\n            _getMonthFormatted(month),\n            _getYearFormatted(year),\n            \"-\",\n            _getNumberWithTwoCaracters(hour),\n            _getNumberWithTwoCaracters(minute),\n            \"UTC\"\n            )); \n    }\n    \n    /**\n     * @dev Internal function to get the year formatted with 2 characters.\n     * @return The year formatted.\n     */\n    function _getYearFormatted(uint256 year) internal pure returns(string memory) {\n        bytes memory yearBytes = bytes(Strings.toString(year));\n        bytes memory result = new bytes(2);\n        uint256 startIndex = yearBytes.length - 2;\n        for (uint256 i = startIndex; i < yearBytes.length; i++) {\n            result[i - startIndex] = yearBytes[i];\n        }\n        return string(result);\n    }\n    \n    /**\n     * @dev Internal function to get the month abbreviation.\n     * @return The month abbreviation.\n     */\n    function _getMonthFormatted(uint256 month) internal pure returns(string memory) {\n        if (month == 1) {\n            return \"JAN\";\n        } else if (month == 2) {\n            return \"FEB\";\n        } else if (month == 3) {\n            return \"MAR\";\n        } else if (month == 4) {\n            return \"APR\";\n        } else if (month == 5) {\n            return \"MAY\";\n        } else if (month == 6) {\n            return \"JUN\";\n        } else if (month == 7) {\n            return \"JUL\";\n        } else if (month == 8) {\n            return \"AUG\";\n        } else if (month == 9) {\n            return \"SEP\";\n        } else if (month == 10) {\n            return \"OCT\";\n        } else if (month == 11) {\n            return \"NOV\";\n        } else if (month == 12) {\n            return \"DEC\";\n        } else {\n            return \"INVALID\";\n        }\n    }\n    \n    /**\n     * @dev Internal function to get the number with 2 characters.\n     * @return The 2 characters for the number.\n     */\n    function _getNumberWithTwoCaracters(uint256 number) internal pure returns(string memory) {\n        string memory _string = Strings.toString(number);\n        if (number < 10) {\n            return string(abi.encodePacked(\"0\", _string));\n        } else {\n            return _string;\n        }\n    }\n    \n    /**\n     * @dev Internal function to get the strike price formatted.\n     * @return The strike price formatted.\n     */\n    function _getFormattedStrikePrice() internal view returns(string memory) {\n        uint256 digits;\n        uint256 count;\n        int256 representativeAt = -1;\n        uint256 addPointAt = 0;\n        uint256 temp = strikePrice;\n        uint256 number = strikePrice;\n        while (temp != 0) {\n            if (representativeAt == -1 && (temp % 10 != 0 || count == uint256(strikeAssetDecimals))) {\n                representativeAt = int256(digits);\n                number = temp;\n            }\n            if (representativeAt >= 0) {\n                if (count == uint256(strikeAssetDecimals)) {\n                    addPointAt = digits;\n                }\n                digits++;\n            }\n            temp /= 10;\n            count++;\n        }\n        if (count <= uint256(strikeAssetDecimals)) {\n            digits = digits + 2 + uint256(strikeAssetDecimals) - count;\n            addPointAt = digits - 2;\n        } else if (addPointAt > 0) {\n            digits++;\n        }\n        bytes memory buffer = new bytes(digits);\n        uint256 index = digits - 1;\n        temp = number;\n        for (uint256 i = 0; i < digits; ++i) {\n            if (i > 0 && i == addPointAt) {\n                buffer[index--] = byte(\".\");\n            } else if (number == 0) {\n                buffer[index--] = byte(\"0\");\n            } else {\n                // SWC-135-Code With No Effects: L1018\n                if (representativeAt <= int256(i)) {\n                    buffer[index--] = byte(uint8(48 + number % 10));\n                }\n                number /= 10;\n            }\n        }\n        return string(buffer);\n    }\n    \n    /**\n     * @dev Internal function to the asset decimals.\n     * @param asset Address of the asset.\n     * @return The asset decimals.\n     */\n    function _getAssetDecimals(address asset) internal view returns(uint8) {\n        if (_isEther(asset)) {\n            return uint8(18);\n        } else {\n            (bool success, bytes memory returndata) = asset.staticcall(abi.encodeWithSignature(\"decimals()\"));\n            require(success, \"ACOToken::_getAssetDecimals: Invalid asset decimals\");\n            return abi.decode(returndata, (uint8));\n        }\n    }\n    \n    /**\n     * @dev Internal function to the asset symbol.\n     * @param asset Address of the asset.\n     * @return The asset symbol.\n     */\n    function _getAssetSymbol(address asset) internal view returns(string memory) {\n        if (_isEther(asset)) {\n            return \"ETH\";\n        } else {\n            (bool success, bytes memory returndata) = asset.staticcall(abi.encodeWithSignature(\"symbol()\"));\n            require(success, \"ACOToken::_getAssetSymbol: Invalid asset symbol\");\n            return abi.decode(returndata, (string));\n        }\n    }\n    \n    /**\n     * @dev Internal function to transfer ERC20 tokens.\n     * @param token Address of the token.\n     * @param recipient Address of the transfer destination.\n     * @param amount Amount to transfer.\n     */\n     function _transferERC20(address token, address recipient, uint256 amount) internal {\n        (bool success, bytes memory returndata) = token.call(abi.encodeWithSelector(_transferSelector, recipient, amount));\n        require(success && (returndata.length == 0 || abi.decode(returndata, (bool))), \"ACOToken::_transferERC20\");\n    }\n    \n    /**\n     * @dev Internal function to call transferFrom on ERC20 tokens.\n     * @param token Address of the token.\n     * @param sender Address of the sender.\n     * @param recipient Address of the transfer destination.\n     * @param amount Amount to transfer.\n     */\n     function _transferFromERC20(address token, address sender, address recipient, uint256 amount) internal {\n        (bool success, bytes memory returndata) = token.call(abi.encodeWithSelector(_transferFromSelector, sender, recipient, amount));\n        require(success && (returndata.length == 0 || abi.decode(returndata, (bool))), \"ACOToken::_transferFromERC20\");\n    }\n}",
        "function": "transfer(address,uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/openzeppelin-ACO_Protocol/aco-36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/core/ACOToken.sol",
        "vulnerability": "Dependence on predictable environment variable (SWC 116)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract ACOToken is ERC20 {\n    using Address for address;\n    \n    /**\n     * @dev Struct to store the accounts that generated tokens with a collateral deposit.\n     */\n    struct TokenCollateralized {\n        /**\n         * @dev Current amount of tokens.\n         */\n        uint256 amount;\n        \n        /**\n         * @dev Index on the collateral owners array.\n         */\n        uint256 index;\n    }\n    \n    /**\n     * @dev Emitted when collateral is deposited on the contract.\n     * @param account Address of the collateral owner.\n     * @param amount Amount of collateral deposited.\n     */\n    event CollateralDeposit(address indexed account, uint256 amount);\n    \n    /**\n     * @dev Emitted when collateral is withdrawn from the contract.\n     * @param account Address of the account.\n     * @param recipient Address of the collateral destination.\n     * @param amount Amount of collateral withdrawn.\n     * @param fee The fee amount charged on the withdrawal.\n     */\n    event CollateralWithdraw(address indexed account, address indexed recipient, uint256 amount, uint256 fee);\n    \n    /**\n     * @dev Emitted when the collateral is used on an assignment.\n     * @param from Address of the account of the collateral owner.\n     * @param to Address of the account that exercises tokens to get the collateral.\n     * @param paidAmount Amount paid to the collateral owner.\n     * @param tokenAmount Amount of tokens used to exercise.\n     */\n    event Assigned(address indexed from, address indexed to, uint256 paidAmount, uint256 tokenAmount);\n\n    /**\n     * @dev The ERC20 token address for the underlying asset (0x0 for Ethereum). \n     */\n    address public underlying;\n    \n    /**\n     * @dev The ERC20 token address for the strike asset (0x0 for Ethereum). \n     */\n    address public strikeAsset;\n    \n    /**\n     * @dev Address of the fee destination charged on the exercise.\n     */\n    address payable public feeDestination;\n    \n    /**\n     * @dev True if the type is CALL, false for PUT.\n     */\n    bool public isCall;\n    \n    /**\n     * @dev The strike price for the token with the strike asset precision.\n     */\n    uint256 public strikePrice;\n    \n    /**\n     * @dev The UNIX time for the token expiration.\n     */\n    uint256 public expiryTime;\n    \n    /**\n     * @dev The total amount of collateral on the contract.\n     */\n    uint256 public totalCollateral;\n    \n    /**\n     * @dev The fee value. It is a percentage value (100000 is 100%).\n     */\n    uint256 public acoFee;\n    \n    /**\n     * @dev Symbol of the underlying asset.\n     */\n    string public underlyingSymbol;\n    \n    /**\n     * @dev Symbol of the strike asset.\n     */\n    string public strikeAssetSymbol;\n    \n    /**\n     * @dev Decimals for the underlying asset.\n     */\n    uint8 public underlyingDecimals;\n    \n    /**\n     * @dev Decimals for the strike asset.\n     */\n    uint8 public strikeAssetDecimals;\n    \n    /**\n     * @dev Underlying precision. (10 ^ underlyingDecimals)\n     */\n    uint256 internal underlyingPrecision;\n    \n    /**\n     * @dev Accounts that generated tokens with a collateral deposit.\n     */\n    mapping(address => TokenCollateralized) internal tokenData;\n    \n    /**\n     * @dev Array with all accounts with collateral deposited.\n     */\n    address[] internal _collateralOwners;\n    \n    /**\n     * @dev Internal data to control the reentrancy.\n     */\n    bool internal _notEntered;\n    \n    /**\n     * @dev Selector for ERC20 transfer function.\n     */\n    bytes4 internal _transferSelector;\n    \n    /**\n     * @dev Selector for ERC20 transfer from function.\n     */\n    bytes4 internal _transferFromSelector;\n    \n    /**\n     * @dev Modifier to check if the token is not expired.\n     * It is executed only while the token is not expired.\n     */\n    modifier notExpired() {\n        require(_notExpired(), \"ACOToken::Expired\");\n        _;\n    }\n    \n    /**\n     * @dev Modifier to prevents a contract from calling itself during the function execution.\n     */\n    modifier nonReentrant() {\n        require(_notEntered, \"ACOToken::Reentry\");\n        _notEntered = false;\n        _;\n        _notEntered = true;\n    }\n    \n    /**\n     * @dev Function to initialize the contract.\n     * It should be called when creating the token.\n     * It must be called only once. The `assert` is to guarantee that behavior.\n     * @param _underlying Address of the underlying asset (0x0 for Ethereum).\n     * @param _strikeAsset Address of the strike asset (0x0 for Ethereum).\n     * @param _isCall True if the type is CALL, false for PUT.\n     * @param _strikePrice The strike price with the strike asset precision.\n     * @param _expiryTime The UNIX time for the token expiration.\n     * @param _acoFee Value of the ACO fee. It is a percentage value (100000 is 100%).\n     * @param _feeDestination Address of the fee destination charged on the exercise.\n     */\n    function init(\n        address _underlying,\n        address _strikeAsset,\n        bool _isCall,\n        uint256 _strikePrice,\n        uint256 _expiryTime,\n        uint256 _acoFee,\n        address payable _feeDestination\n    ) public {\n        require(underlying == address(0) && strikeAsset == address(0) && strikePrice == 0, \"ACOToken::init: Already initialized\");\n        \n        require(_expiryTime > now, \"ACOToken::init: Invalid expiry\");\n        require(_strikePrice > 0, \"ACOToken::init: Invalid strike price\");\n        require(_underlying != _strikeAsset, \"ACOToken::init: Same assets\");\n        require(_acoFee <= 500, \"ACOToken::init: Invalid ACO fee\"); // Maximum is 0.5%\n        require(_isEther(_underlying) || _underlying.isContract(), \"ACOToken::init: Invalid underlying\");\n        require(_isEther(_strikeAsset) || _strikeAsset.isContract(), \"ACOToken::init: Invalid strike asset\");\n        \n        underlying = _underlying;\n        strikeAsset = _strikeAsset;\n        isCall = _isCall;\n        strikePrice = _strikePrice;\n        expiryTime = _expiryTime;\n        acoFee = _acoFee;\n        feeDestination = _feeDestination;\n        underlyingDecimals = _getAssetDecimals(_underlying);\n        strikeAssetDecimals = _getAssetDecimals(_strikeAsset);\n        underlyingSymbol = _getAssetSymbol(_underlying);\n        strikeAssetSymbol = _getAssetSymbol(_strikeAsset);\n        // SWC-101-Integer Overflow and Underflow: L207\n        underlyingPrecision = 10 ** uint256(underlyingDecimals);\n\n        _transferSelector = bytes4(keccak256(bytes(\"transfer(address,uint256)\")));\n        _transferFromSelector = bytes4(keccak256(bytes(\"transferFrom(address,address,uint256)\")));\n        _notEntered = true;\n    }\n    \n    /**\n     * @dev Function to guarantee that the contract will not receive ether directly.\n     */\n    receive() external payable {\n        revert();\n    }\n    \n    /**\n     * @dev Function to get the token name.\n     */\n    function name() public view override returns(string memory) {\n        return _name();\n    }\n    \n    /**\n     * @dev Function to get the token symbol, that it is equal to the name.\n     */\n    function symbol() public view override returns(string memory) {\n        return _name();\n    }\n    \n    /**\n     * @dev Function to get the token decimals, that it is equal to the underlying asset decimals.\n     */\n    function decimals() public view override returns(uint8) {\n        return underlyingDecimals;\n    }\n    \n    /**\n     * @dev Function to get the current amount of collateral for an account.\n     * @param account Address of the account.\n     * @return The current amount of collateral.\n     */\n    function currentCollateral(address account) public view returns(uint256) {\n        return getCollateralAmount(currentCollateralizedTokens(account));\n    }\n    \n    /**\n     * @dev Function to get the current amount of unassignable collateral for an account.\n     * NOTE: The function is valid when the token is NOT expired yet. \n     * After expiration, the unassignable collateral is equal to the account's collateral balance.\n     * @param account Address of the account.\n     * @return The respective amount of unassignable collateral.\n     */\n    function unassignableCollateral(address account) public view returns(uint256) {\n        return getCollateralAmount(unassignableTokens(account));\n    }\n    \n    /**\n     * @dev Function to get  the current amount of assignable collateral for an account.\n     * NOTE: The function is valid when the token is NOT expired yet. \n     * After expiration, the assignable collateral is zero.\n     * @param account Address of the account.\n     * @return The respective amount of assignable collateral.\n     */\n    function assignableCollateral(address account) public view returns(uint256) {\n        return getCollateralAmount(assignableTokens(account));\n    }\n    \n    /**\n     * @dev Function to get the current amount of collateralized tokens for an account.\n     * @param account Address of the account.\n     * @return The current amount of collateralized tokens.\n     */\n    function currentCollateralizedTokens(address account) public view returns(uint256) {\n        return tokenData[account].amount;\n    }\n    \n    /**\n     * @dev Function to get the current amount of unassignable tokens for an account.\n     * NOTE: The function is valid when the token is NOT expired yet. \n     * After expiration, the unassignable tokens is equal to the account's collateralized tokens.\n     * @param account Address of the account.\n     * @return The respective amount of unassignable tokens.\n     */\n    function unassignableTokens(address account) public view returns(uint256) {\n        if (balanceOf(account) > tokenData[account].amount) {\n            return tokenData[account].amount;\n        } else {\n            return balanceOf(account);\n        }\n    }\n    \n    /**\n     * @dev Function to get  the current amount of assignable tokens for an account.\n     * NOTE: The function is valid when the token is NOT expired yet. \n     * After expiration, the assignable tokens is zero.\n     * @param account Address of the account.\n     * @return The respective amount of assignable tokens.\n     */\n    function assignableTokens(address account) public view returns(uint256) {\n        return _getAssignableAmount(account);\n    }\n    \n    /**\n     * @dev Function to get the equivalent collateral amount for a token amount.\n     * @param tokenAmount Amount of tokens.\n     * @return The respective amount of collateral.\n     */\n    function getCollateralAmount(uint256 tokenAmount) public view returns(uint256) {\n        if (isCall) {\n            return tokenAmount;\n        } else if (tokenAmount > 0) {\n            return _getTokenStrikePriceRelation(tokenAmount);\n        } else {\n            return 0;\n        }\n    }\n    \n    /**\n     * @dev Function to get the equivalent token amount for a collateral amount.\n     * @param collateralAmount Amount of collateral.\n     * @return The respective amount of tokens.\n     */\n    function getTokenAmount(uint256 collateralAmount) public view returns(uint256) {\n        if (isCall) {\n            return collateralAmount;\n        } else if (collateralAmount > 0) {\n            return collateralAmount.mul(underlyingPrecision).div(strikePrice);\n        } else {\n            return 0;\n        }\n    }\n    \n    /**\n     * @dev Function to get the data for exercise of an amount of token.\n     * @param tokenAmount Amount of tokens.\n     * @return The asset and the respective amount that should be sent to get the collateral.\n     */\n    function getExerciseData(uint256 tokenAmount) public view returns(address, uint256) {\n        if (isCall) {\n            return (strikeAsset, _getTokenStrikePriceRelation(tokenAmount)); \n        } else {\n            return (underlying, tokenAmount);\n        }\n    }\n    \n    /**\n     * @dev Function to get the collateral to be received on an exercise and the respective fee.\n     * @param tokenAmount Amount of tokens.\n     * @return The collateral to be received and the respective fee.\n     */\n    function getCollateralOnExercise(uint256 tokenAmount) public view returns(uint256, uint256) {\n        uint256 collateralAmount = getCollateralAmount(tokenAmount);\n        uint256 fee = collateralAmount.mul(acoFee).div(100000);\n        collateralAmount = collateralAmount.sub(fee);\n        return (collateralAmount, fee);\n    }\n    \n    /**\n     * @dev Function to get the collateral asset.\n     * @return The address of the collateral asset.\n     */\n    function collateral() public view returns(address) {\n        if (isCall) {\n            return underlying;\n        } else {\n            return strikeAsset;\n        }\n    }\n    \n    /**\n     * @dev Function to mint tokens with Ether deposited as collateral.\n     * NOTE: The function only works when the token is NOT expired yet. \n     */\n    function mintPayable() external payable {\n        require(_isEther(collateral()), \"ACOToken::mintPayable: Invalid call\");\n       _mintToken(msg.sender, msg.value);\n    }\n    \n    /**\n     * @dev Function to mint tokens with Ether deposited as collateral to an informed account.\n     * However, the minted tokens are assigned to the transaction sender.\n     * NOTE: The function only works when the token is NOT expired yet. \n     * @param account Address of the account that will be the collateral owner.\n     */\n    function mintToPayable(address account) external payable {\n        require(_isEther(collateral()), \"ACOToken::mintToPayable: Invalid call\");\n       _mintToken(account, msg.value);\n    }\n    \n    /**\n     * @dev Function to mint tokens with ERC20 deposited as collateral.\n     * NOTE: The function only works when the token is NOT expired yet. \n     * @param collateralAmount Amount of collateral deposited.\n     */\n    function mint(uint256 collateralAmount) external {\n        address _collateral = collateral();\n        require(!_isEther(_collateral), \"ACOToken::mint: Invalid call\");\n        \n        _transferFromERC20(_collateral, msg.sender, address(this), collateralAmount);\n        _mintToken(msg.sender, collateralAmount);\n    }\n    \n    /**\n     * @dev Function to mint tokens with ERC20 deposited as collateral to an informed account.\n     * However, the minted tokens are assigned to the transaction sender.\n     * NOTE: The function only works when the token is NOT expired yet. \n     * @param account Address of the account that will be the collateral owner.\n     * @param collateralAmount Amount of collateral deposited.\n     */\n    function mintTo(address account, uint256 collateralAmount) external {\n        address _collateral = collateral();\n        require(!_isEther(_collateral), \"ACOToken::mintTo: Invalid call\");\n        \n        _transferFromERC20(_collateral, msg.sender, address(this), collateralAmount);\n        _mintToken(account, collateralAmount);\n    }\n    \n    /**\n     * @dev Function to burn tokens and get the collateral, not assigned, back.\n     * NOTE: The function only works when the token is NOT expired yet. \n     * @param tokenAmount Amount of tokens to be burned.\n     */\n    function burn(uint256 tokenAmount) external {\n        _burn(msg.sender, tokenAmount);\n    }\n    \n    /**\n     * @dev Function to burn tokens from a specific account and send the collateral to its address.\n     * The token allowance must be respected.\n     * The collateral is sent to the transaction sender.\n     * NOTE: The function only works when the token is NOT expired yet. \n     * @param account Address of the account.\n     * @param tokenAmount Amount of tokens to be burned.\n     */\n    // SWC-114-Transaction Order Dependence: L441-L443\n    function burnFrom(address account, uint256 tokenAmount) external {\n        _burn(account, tokenAmount);\n    }\n    \n    /**\n     * @dev Function to get the collateral, not assigned, back.\n     * NOTE: The function only works when the token IS expired. \n     */\n    function redeem() external {\n        _redeem(msg.sender);\n    }\n    \n    /**\n     * @dev Function to get the collateral from a specific account sent back to its address .\n     * The token allowance must be respected.\n     * The collateral is sent to the transaction sender.\n     * NOTE: The function only works when the token IS expired. \n     * @param account Address of the account.\n     */\n    function redeemFrom(address account) external {\n        require(tokenData[account].amount <= allowance(account, msg.sender), \"ACOToken::redeemFrom: No allowance\");\n        _redeem(account);\n    }\n    \n    /**\n     * @dev Function to exercise the tokens, paying to get the equivalent collateral.\n     * The paid amount is sent to the collateral owners that were assigned.\n     * NOTE: The function only works when the token is NOT expired. \n     * @param tokenAmount Amount of tokens.\n     */\n    function exercise(uint256 tokenAmount) external payable {\n        _exercise(msg.sender, tokenAmount);\n    }\n    \n    /**\n     * @dev Function to exercise the tokens from an account, paying to get the equivalent collateral.\n     * The token allowance must be respected.\n     * The paid amount is sent to the collateral owners that were assigned.\n     * The collateral is transferred to the transaction sender.\n     * NOTE: The function only works when the token is NOT expired. \n     * @param account Address of the account.\n     * @param tokenAmount Amount of tokens.\n     */\n    function exerciseFrom(address account, uint256 tokenAmount) external payable {\n        _exercise(account, tokenAmount);\n    }\n    \n    /**\n     * @dev Function to exercise the tokens, paying to get the equivalent collateral.\n     * The paid amount is sent to the collateral owners (on accounts list) that were assigned.\n     * NOTE: The function only works when the token is NOT expired. \n     * @param tokenAmount Amount of tokens.\n     * @param accounts The array of addresses to get collateral from.\n     */\n    function exerciseAccounts(uint256 tokenAmount, address[] calldata accounts) external payable {\n        _exerciseFromAccounts(msg.sender, tokenAmount, accounts);\n    }\n    \n    /**\n     * @dev Function to exercise the tokens from a specific account, paying to get the equivalent collateral sent to its address.\n     * The token allowance must be respected.\n     * The paid amount is sent to the collateral owners (on accounts list) that were assigned.\n     * The collateral is transferred to the transaction sender.\n     * NOTE: The function only works when the token is NOT expired. \n     * @param account Address of the account.\n     * @param tokenAmount Amount of tokens.\n     * @param accounts The array of addresses to get the deposited collateral.\n     */\n    function exerciseAccountsFrom(address account, uint256 tokenAmount, address[] calldata accounts) external payable {\n        _exerciseFromAccounts(account, tokenAmount, accounts);\n    }\n    \n    /**\n     * @dev Function to burn the tokens after expiration.\n     * It is an optional function to `clear` the account wallet from an expired and not functional token.\n     * NOTE: The function only works when the token IS expired. \n     */\n    function clear() external {\n        _clear(msg.sender);\n    }\n    \n    /**\n     * @dev Function to burn the tokens from an account after expiration.\n     * It is an optional function to `clear` the account wallet from an expired and not functional token.\n     * The token allowance must be respected.\n     * NOTE: The function only works when the token IS expired. \n     * @param account Address of the account.\n     */\n    function clearFrom(address account) external {\n        _clear(account);\n    }\n    \n    /**\n     * @dev Internal function to burn the tokens from an account after expiration.\n     * @param account Address of the account.\n     */\n    function _clear(address account) internal {\n        require(!_notExpired(), \"ACOToken::_clear: Token not expired yet\");\n        require(!_accountHasCollateral(account), \"ACOToken::_clear: Must call the redeem method\");\n        \n        _callBurn(account, balanceOf(account));\n    }\n    \n    /**\n     * @dev Internal function to redeem respective collateral from an account.\n     * @param account Address of the account.\n     * @param tokenAmount Amount of tokens.\n     */\n    function _redeemCollateral(address account, uint256 tokenAmount) internal {\n        require(_accountHasCollateral(account), \"ACOToken::_redeemCollateral: No collateral available\");\n        require(tokenAmount > 0, \"ACOToken::_redeemCollateral: Invalid token amount\");\n        \n        TokenCollateralized storage data = tokenData[account];\n        data.amount = data.amount.sub(tokenAmount);\n        \n        _removeCollateralDataIfNecessary(account);\n        \n        _transferCollateral(account, getCollateralAmount(tokenAmount), 0);\n    }\n    \n    /**\n     * @dev Internal function to mint tokens.\n     * The tokens are minted for the transaction sender.\n     * @param account Address of the account.\n     * @param collateralAmount Amount of collateral deposited.\n     */\n    function _mintToken(address account, uint256 collateralAmount) nonReentrant notExpired internal {\n        require(collateralAmount > 0, \"ACOToken::_mintToken: Invalid collateral amount\");\n        // SWC-128-DoS With Block Gas Limit: L570-L573\n        if (!_accountHasCollateral(account)) {\n            tokenData[account].index = _collateralOwners.length;\n            _collateralOwners.push(account);\n        }\n        \n        uint256 tokenAmount = getTokenAmount(collateralAmount);\n        tokenData[account].amount = tokenData[account].amount.add(tokenAmount);\n        \n        totalCollateral = totalCollateral.add(collateralAmount);\n        \n        emit CollateralDeposit(account, collateralAmount);\n        \n        super._mintAction(msg.sender, tokenAmount);\n    }\n    \n    /**\n     * @dev Internal function to transfer tokens. \n     * The token transfer only works when the token is NOT expired. \n     * @param sender Source of the tokens.\n     * @param recipient Destination address for the tokens.\n     * @param amount Amount of tokens.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) notExpired internal override {\n        super._transferAction(sender, recipient, amount);\n    }\n    \n    /**\n     * @dev Internal function to set the token permission from an account to another address. \n     * The token approval only works when the token is NOT expired. \n     * @param owner Address of the token owner.\n     * @param spender Address of the spender authorized.\n     * @param amount Amount of tokens authorized.\n     */\n    function _approve(address owner, address spender, uint256 amount) notExpired internal override {\n        super._approveAction(owner, spender, amount);\n    }\n    \n    /**\n     * @dev Internal function to transfer collateral. \n     * When there is a fee, the calculated fee is also transferred to the destination fee address.\n     * The collateral destination is always the transaction sender address.\n     * @param account Address of the account.\n     * @param collateralAmount Amount of collateral to be redeemed.\n     * @param fee Amount of fee charged.\n     */\n    function _transferCollateral(address account, uint256 collateralAmount, uint256 fee) internal {\n        \n        totalCollateral = totalCollateral.sub(collateralAmount.add(fee));\n        \n        address _collateral = collateral();\n        if (_isEther(_collateral)) {\n            payable(msg.sender).transfer(collateralAmount);\n            if (fee > 0) {\n                feeDestination.transfer(fee);   \n            }\n        } else {\n            _transferERC20(_collateral, msg.sender, collateralAmount);\n            if (fee > 0) {\n                _transferERC20(_collateral, feeDestination, fee);\n            }\n        }\n        \n        emit CollateralWithdraw(account, msg.sender, collateralAmount, fee);\n    }\n    \n    /**\n     * @dev Internal function to exercise the tokens from an account. \n     * @param account Address of the account that is exercising.\n     * @param tokenAmount Amount of tokens.\n     */\n    function _exercise(address account, uint256 tokenAmount) nonReentrant internal {\n        _validateAndBurn(account, tokenAmount);\n        _exerciseOwners(account, tokenAmount);\n        (uint256 collateralAmount, uint256 fee) = getCollateralOnExercise(tokenAmount);\n        _transferCollateral(account, collateralAmount, fee);\n    }\n    \n    /**\n     * @dev Internal function to exercise the tokens from an account. \n     * @param account Address of the account that is exercising.\n     * @param tokenAmount Amount of tokens.\n     * @param accounts The array of addresses to get the collateral from.\n     */\n    function _exerciseFromAccounts(address account, uint256 tokenAmount, address[] memory accounts) nonReentrant internal {\n        _validateAndBurn(account, tokenAmount);\n        _exerciseAccounts(account, tokenAmount, accounts);\n        (uint256 collateralAmount, uint256 fee) = getCollateralOnExercise(tokenAmount);\n        _transferCollateral(account, collateralAmount, fee);\n    }\n    \n    /**\n     * @dev Internal function to exercise the assignable tokens from the stored list of collateral owners. \n     * @param exerciseAccount Address of the account that is exercising.\n     * @param tokenAmount Amount of tokens.\n     */\n    function _exerciseOwners(address exerciseAccount, uint256 tokenAmount) internal {\n        uint256 start = _collateralOwners.length - 1;\n        for (uint256 i = start; i >= 0; --i) {\n            if (tokenAmount == 0) {\n                break;\n            }\n            tokenAmount = _exerciseAccount(_collateralOwners[i], tokenAmount, exerciseAccount);\n        }\n        require(tokenAmount == 0, \"ACOToken::_exerciseOwners: Invalid remaining amount\");\n    }\n    \n    /**\n     * @dev Internal function to exercise the assignable tokens from an accounts list. \n     * @param exerciseAccount Address of the account that is exercising.\n     * @param tokenAmount Amount of tokens.\n     * @param accounts The array of addresses to get the collateral from.\n     */\n    function _exerciseAccounts(address exerciseAccount, uint256 tokenAmount, address[] memory accounts) internal {\n        for (uint256 i = 0; i < accounts.length; ++i) {\n            if (tokenAmount == 0) {\n                break;\n            }\n            tokenAmount = _exerciseAccount(accounts[i], tokenAmount, exerciseAccount);\n        }\n        require(tokenAmount == 0, \"ACOToken::_exerciseAccounts: Invalid remaining amount\");\n    }\n    \n    /**\n     * @dev Internal function to exercise the assignable tokens from an account and transfer to its address the respective payment. \n     * @param account Address of the account.\n     * @param tokenAmount Amount of tokens.\n     * @param exerciseAccount Address of the account that is exercising.\n     * @return Remaining amount of tokens.\n     */\n    function _exerciseAccount(address account, uint256 tokenAmount, address exerciseAccount) internal returns(uint256) {\n        uint256 available = _getAssignableAmount(account);\n        if (available > 0) {\n            \n            TokenCollateralized storage data = tokenData[account];\n            uint256 valueToTransfer;\n            if (available < tokenAmount) {\n                valueToTransfer = available;\n                tokenAmount = tokenAmount.sub(available);\n            } else {\n                valueToTransfer = tokenAmount;\n                tokenAmount = 0;\n            }\n            \n            (address exerciseAsset, uint256 amount) = getExerciseData(valueToTransfer);\n\n            data.amount = data.amount.sub(valueToTransfer); \n            \n            _removeCollateralDataIfNecessary(account);\n            \n            if (_isEther(exerciseAsset)) {\n                payable(account).transfer(amount);\n            } else {\n                _transferERC20(exerciseAsset, account, amount);\n            }\n            emit Assigned(account, exerciseAccount, amount, valueToTransfer);\n        }\n        \n        return tokenAmount;\n    }\n    \n    /**\n     * @dev Internal function to validate the exercise operation and burn the respective tokens.\n     * @param account Address of the account that is exercising.\n     * @param tokenAmount Amount of tokens.\n     */\n    function _validateAndBurn(address account, uint256 tokenAmount) notExpired internal {\n        require(tokenAmount > 0, \"ACOToken::_validateAndBurn: Invalid token amount\");\n        \n        // Whether an account has deposited collateral it only can exercise the extra amount of unassignable tokens.\n        if (_accountHasCollateral(account)) {\n            // SWC-135-Code With No Effects: L741\n            require(balanceOf(account) > tokenData[account].amount, \"ACOToken::_validateAndBurn: Tokens compromised\");\n            require(tokenAmount <= balanceOf(account).sub(tokenData[account].amount), \"ACOToken::_validateAndBurn: Token amount not available\"); \n        }\n        \n        _callBurn(account, tokenAmount);\n        \n        (address exerciseAsset, uint256 expectedAmount) = getExerciseData(tokenAmount);\n\n        if (_isEther(exerciseAsset)) {\n            require(msg.value == expectedAmount, \"ACOToken::_validateAndBurn: Invalid ether amount\");\n        } else {\n            require(msg.value == 0, \"ACOToken::_validateAndBurn: No ether expected\");\n            _transferFromERC20(exerciseAsset, msg.sender, address(this), expectedAmount);\n        }\n    }\n    \n    /**\n     * @dev Internal function to calculate the token strike price relation.\n     * @param tokenAmount Amount of tokens.\n     * @return Calculated value with strike asset precision.\n     */\n    function _getTokenStrikePriceRelation(uint256 tokenAmount) internal view returns(uint256) {\n        return tokenAmount.mul(strikePrice).div(underlyingPrecision);\n    }\n    \n    /**\n     * @dev Internal function to get the collateral sent back from an account.\n     * Function to be called when the token IS expired.\n     * @param account Address of the account.\n     */\n    function _redeem(address account) nonReentrant internal {\n        require(!_notExpired(), \"ACOToken::_redeem: Token not expired yet\");\n        \n        _redeemCollateral(account, tokenData[account].amount);\n        super._burnAction(account, balanceOf(account));\n    }\n    \n    /**\n     * @dev Internal function to burn tokens from an account and get the collateral, not assigned, back.\n     * @param account Address of the account.\n     * @param tokenAmount Amount of tokens to be burned.\n     */\n    function _burn(address account, uint256 tokenAmount) nonReentrant notExpired internal {\n        _redeemCollateral(account, tokenAmount);\n        _callBurn(account, tokenAmount);\n    }\n    \n    /**\n     * @dev Internal function to burn tokens.\n     * @param account Address of the account.\n     * @param tokenAmount Amount of tokens to be burned.\n     */\n    function _callBurn(address account, uint256 tokenAmount) internal {\n        if (account == msg.sender) {\n            super._burnAction(account, tokenAmount);\n        } else {\n            super._burnFrom(account, tokenAmount);\n        }\n    }\n    \n    /**\n     * @dev Internal function to get the amount of assignable token from an account.\n     * @param account Address of the account.\n     * @return The assignable amount of tokens.\n     */\n    function _getAssignableAmount(address account) internal view returns(uint256) {\n        if (tokenData[account].amount > balanceOf(account)) {\n            return tokenData[account].amount.sub(balanceOf(account));\n        } else {\n            return 0;\n        }\n    }\n    \n    /**\n     * @dev Internal function to remove the token data with collateral if its total amount was assigned.\n     * @param account Address of account.\n     */\n    function _removeCollateralDataIfNecessary(address account) internal {\n        TokenCollateralized storage data = tokenData[account];\n        if (!_hasCollateral(data)) {\n            uint256 lastIndex = _collateralOwners.length - 1;\n            if (lastIndex != data.index) {\n                address last = _collateralOwners[lastIndex];\n                tokenData[last].index = data.index;\n                _collateralOwners[data.index] = last;\n            }\n            _collateralOwners.pop();\n            delete tokenData[account];\n        }\n    }\n    \n    /**\n     * @dev Internal function to get if the token is not expired.\n     * @return Whether the token is NOT expired.\n     */\n    function _notExpired() internal view returns(bool) {\n        return now <= expiryTime;\n    }\n    \n    /**\n     * @dev Internal function to get if an account has collateral deposited.\n     * @param account Address of the account.\n     * @return Whether the account has collateral deposited.\n     */\n    function _accountHasCollateral(address account) internal view returns(bool) {\n        return _hasCollateral(tokenData[account]);\n    }\n    \n    /**\n     * @dev Internal function to get if an account has collateral deposited.\n     * @param data Token data from an account.\n     * @return Whether the account has collateral deposited.\n     */    \n    function _hasCollateral(TokenCollateralized storage data) internal view returns(bool) {\n        return data.amount > 0;\n    }\n    \n    /**\n     * @dev Internal function to get if the address is for Ethereum (0x0).\n     * @param _address Address to be checked.\n     * @return Whether the address is for Ethereum.\n     */ \n    function _isEther(address _address) internal pure returns(bool) {\n        return _address == address(0);\n    } \n    \n    /**\n     * @dev Internal function to get the token name.\n     * The token name is assembled  with the token data:\n     * ACO UNDERLYING_SYMBOL-EXPIRYTIME-STRIKE_PRICE_STRIKE_ASSET_SYMBOL-TYPE\n     * @return The token name.\n     */\n    function _name() internal view returns(string memory) {\n        return string(abi.encodePacked(\n            \"ACO \",\n            underlyingSymbol,\n            \"-\",\n            _getFormattedStrikePrice(),\n            strikeAssetSymbol,\n            \"-\",\n            _getType(),\n            \"-\",\n            _getFormattedExpiryTime()\n        ));\n    }\n    \n    /**\n     * @dev Internal function to get the token type description.\n     * @return The token type description.\n     */\n    function _getType() internal view returns(string memory) {\n        if (isCall) {\n            return \"C\";\n        } else {\n            return \"P\";\n        }\n    }\n    \n    /**\n     * @dev Internal function to get the expiry time formatted.\n     * @return The expiry time formatted.\n     */\n    function _getFormattedExpiryTime() internal view returns(string memory) {\n        (uint256 year, uint256 month, uint256 day, uint256 hour, uint256 minute,) = BokkyPooBahsDateTimeLibrary.timestampToDateTime(expiryTime); \n        return string(abi.encodePacked(\n            _getNumberWithTwoCaracters(day),\n            _getMonthFormatted(month),\n            _getYearFormatted(year),\n            \"-\",\n            _getNumberWithTwoCaracters(hour),\n            _getNumberWithTwoCaracters(minute),\n            \"UTC\"\n            )); \n    }\n    \n    /**\n     * @dev Internal function to get the year formatted with 2 characters.\n     * @return The year formatted.\n     */\n    function _getYearFormatted(uint256 year) internal pure returns(string memory) {\n        bytes memory yearBytes = bytes(Strings.toString(year));\n        bytes memory result = new bytes(2);\n        uint256 startIndex = yearBytes.length - 2;\n        for (uint256 i = startIndex; i < yearBytes.length; i++) {\n            result[i - startIndex] = yearBytes[i];\n        }\n        return string(result);\n    }\n    \n    /**\n     * @dev Internal function to get the month abbreviation.\n     * @return The month abbreviation.\n     */\n    function _getMonthFormatted(uint256 month) internal pure returns(string memory) {\n        if (month == 1) {\n            return \"JAN\";\n        } else if (month == 2) {\n            return \"FEB\";\n        } else if (month == 3) {\n            return \"MAR\";\n        } else if (month == 4) {\n            return \"APR\";\n        } else if (month == 5) {\n            return \"MAY\";\n        } else if (month == 6) {\n            return \"JUN\";\n        } else if (month == 7) {\n            return \"JUL\";\n        } else if (month == 8) {\n            return \"AUG\";\n        } else if (month == 9) {\n            return \"SEP\";\n        } else if (month == 10) {\n            return \"OCT\";\n        } else if (month == 11) {\n            return \"NOV\";\n        } else if (month == 12) {\n            return \"DEC\";\n        } else {\n            return \"INVALID\";\n        }\n    }\n    \n    /**\n     * @dev Internal function to get the number with 2 characters.\n     * @return The 2 characters for the number.\n     */\n    function _getNumberWithTwoCaracters(uint256 number) internal pure returns(string memory) {\n        string memory _string = Strings.toString(number);\n        if (number < 10) {\n            return string(abi.encodePacked(\"0\", _string));\n        } else {\n            return _string;\n        }\n    }\n    \n    /**\n     * @dev Internal function to get the strike price formatted.\n     * @return The strike price formatted.\n     */\n    function _getFormattedStrikePrice() internal view returns(string memory) {\n        uint256 digits;\n        uint256 count;\n        int256 representativeAt = -1;\n        uint256 addPointAt = 0;\n        uint256 temp = strikePrice;\n        uint256 number = strikePrice;\n        while (temp != 0) {\n            if (representativeAt == -1 && (temp % 10 != 0 || count == uint256(strikeAssetDecimals))) {\n                representativeAt = int256(digits);\n                number = temp;\n            }\n            if (representativeAt >= 0) {\n                if (count == uint256(strikeAssetDecimals)) {\n                    addPointAt = digits;\n                }\n                digits++;\n            }\n            temp /= 10;\n            count++;\n        }\n        if (count <= uint256(strikeAssetDecimals)) {\n            digits = digits + 2 + uint256(strikeAssetDecimals) - count;\n            addPointAt = digits - 2;\n        } else if (addPointAt > 0) {\n            digits++;\n        }\n        bytes memory buffer = new bytes(digits);\n        uint256 index = digits - 1;\n        temp = number;\n        for (uint256 i = 0; i < digits; ++i) {\n            if (i > 0 && i == addPointAt) {\n                buffer[index--] = byte(\".\");\n            } else if (number == 0) {\n                buffer[index--] = byte(\"0\");\n            } else {\n                // SWC-135-Code With No Effects: L1018\n                if (representativeAt <= int256(i)) {\n                    buffer[index--] = byte(uint8(48 + number % 10));\n                }\n                number /= 10;\n            }\n        }\n        return string(buffer);\n    }\n    \n    /**\n     * @dev Internal function to the asset decimals.\n     * @param asset Address of the asset.\n     * @return The asset decimals.\n     */\n    function _getAssetDecimals(address asset) internal view returns(uint8) {\n        if (_isEther(asset)) {\n            return uint8(18);\n        } else {\n            (bool success, bytes memory returndata) = asset.staticcall(abi.encodeWithSignature(\"decimals()\"));\n            require(success, \"ACOToken::_getAssetDecimals: Invalid asset decimals\");\n            return abi.decode(returndata, (uint8));\n        }\n    }\n    \n    /**\n     * @dev Internal function to the asset symbol.\n     * @param asset Address of the asset.\n     * @return The asset symbol.\n     */\n    function _getAssetSymbol(address asset) internal view returns(string memory) {\n        if (_isEther(asset)) {\n            return \"ETH\";\n        } else {\n            (bool success, bytes memory returndata) = asset.staticcall(abi.encodeWithSignature(\"symbol()\"));\n            require(success, \"ACOToken::_getAssetSymbol: Invalid asset symbol\");\n            return abi.decode(returndata, (string));\n        }\n    }\n    \n    /**\n     * @dev Internal function to transfer ERC20 tokens.\n     * @param token Address of the token.\n     * @param recipient Address of the transfer destination.\n     * @param amount Amount to transfer.\n     */\n     function _transferERC20(address token, address recipient, uint256 amount) internal {\n        (bool success, bytes memory returndata) = token.call(abi.encodeWithSelector(_transferSelector, recipient, amount));\n        require(success && (returndata.length == 0 || abi.decode(returndata, (bool))), \"ACOToken::_transferERC20\");\n    }\n    \n    /**\n     * @dev Internal function to call transferFrom on ERC20 tokens.\n     * @param token Address of the token.\n     * @param sender Address of the sender.\n     * @param recipient Address of the transfer destination.\n     * @param amount Amount to transfer.\n     */\n     function _transferFromERC20(address token, address sender, address recipient, uint256 amount) internal {\n        (bool success, bytes memory returndata) = token.call(abi.encodeWithSelector(_transferFromSelector, sender, recipient, amount));\n        require(success && (returndata.length == 0 || abi.decode(returndata, (bool))), \"ACOToken::_transferFromERC20\");\n    }\n}",
        "function": "clear()",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/openzeppelin-ACO_Protocol/aco-36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/core/ACOToken.sol",
        "vulnerability": "Dependence on predictable environment variable (SWC 116)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract Treasury {\n    // the governance address\n    address _governance;\n\n    // A constant which represents ether\n    address internal constant _ETH_CONSTANT =\n        address(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);\n\n    \n    modifier onlyGovernance() {\n        require(msg.sender == _governance, \"!governance\");\n        _;\n    }\n\n    \n    \n    constructor(address __governance) {\n        _governance = __governance;\n    }\n\n    \n    \n    \n    \n    \n    function sendFunds(\n        address _token,\n        uint256 _amount,\n        address _recipient\n    ) external onlyGovernance {\n        if (_token == _ETH_CONSTANT) {\n            payable(_recipient).transfer(_amount);\n        } else {\n            // onlyGovernance should protect from reentrancy\n            IERC20(_token).transfer(_recipient, _amount);\n        }\n    }\n\n    \n    \n    \n    \n    function approve(\n        address _token,\n        address _spender,\n        uint256 _amount\n    ) external onlyGovernance {\n        IERC20(_token).approve(_spender, _amount);\n    }\n\n    \n    \n    \n    // SWC-104-Unchecked Call Return Value: L73\n    function genericCall(address _target, bytes calldata _callData)\n        external\n        onlyGovernance\n    {\n        _target.call(_callData);\n    }\n\n    fallback() external payable {}\n}",
        "function": "genericCall(address,bytes)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Runtime_Vrification-Element_Finance_Governance_Security_Audit_Report/council-3d751c959b42573c78ccd0bccbc80424bf6d9a90/contracts/features/Treasury.sol",
        "vulnerability": "External Call To User-Supplied Address (SWC 107)",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract Treasury {\n    // the governance address\n    address _governance;\n\n    // A constant which represents ether\n    address internal constant _ETH_CONSTANT =\n        address(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);\n\n    \n    modifier onlyGovernance() {\n        require(msg.sender == _governance, \"!governance\");\n        _;\n    }\n\n    \n    \n    constructor(address __governance) {\n        _governance = __governance;\n    }\n\n    \n    \n    \n    \n    \n    function sendFunds(\n        address _token,\n        uint256 _amount,\n        address _recipient\n    ) external onlyGovernance {\n        if (_token == _ETH_CONSTANT) {\n            payable(_recipient).transfer(_amount);\n        } else {\n            // onlyGovernance should protect from reentrancy\n            IERC20(_token).transfer(_recipient, _amount);\n        }\n    }\n\n    \n    \n    \n    \n    function approve(\n        address _token,\n        address _spender,\n        uint256 _amount\n    ) external onlyGovernance {\n        IERC20(_token).approve(_spender, _amount);\n    }\n\n    \n    \n    \n    // SWC-104-Unchecked Call Return Value: L73\n    function genericCall(address _target, bytes calldata _callData)\n        external\n        onlyGovernance\n    {\n        _target.call(_callData);\n    }\n\n    fallback() external payable {}\n}",
        "function": "genericCall(address,bytes)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Runtime_Vrification-Element_Finance_Governance_Security_Audit_Report/council-3d751c959b42573c78ccd0bccbc80424bf6d9a90/contracts/features/Treasury.sol",
        "vulnerability": "Unchecked return value from external call. (SWC 104)",
        "check": "TP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract Treasury {\n    // the governance address\n    address _governance;\n\n    // A constant which represents ether\n    address internal constant _ETH_CONSTANT =\n        address(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);\n\n    \n    modifier onlyGovernance() {\n        require(msg.sender == _governance, \"!governance\");\n        _;\n    }\n\n    \n    \n    constructor(address __governance) {\n        _governance = __governance;\n    }\n\n    \n    \n    \n    \n    \n    function sendFunds(\n        address _token,\n        uint256 _amount,\n        address _recipient\n    ) external onlyGovernance {\n        if (_token == _ETH_CONSTANT) {\n            payable(_recipient).transfer(_amount);\n        } else {\n            // onlyGovernance should protect from reentrancy\n            IERC20(_token).transfer(_recipient, _amount);\n        }\n    }\n\n    \n    \n    \n    \n    function approve(\n        address _token,\n        address _spender,\n        uint256 _amount\n    ) external onlyGovernance {\n        IERC20(_token).approve(_spender, _amount);\n    }\n\n    \n    \n    \n    // SWC-104-Unchecked Call Return Value: L73\n    function genericCall(address _target, bytes calldata _callData)\n        external\n        onlyGovernance\n    {\n        _target.call(_callData);\n    }\n\n    fallback() external payable {}\n}",
        "function": "sendFunds(address,uint256,address)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Runtime_Vrification-Element_Finance_Governance_Security_Audit_Report/council-3d751c959b42573c78ccd0bccbc80424bf6d9a90/contracts/features/Treasury.sol",
        "vulnerability": "External Call To User-Supplied Address (SWC 107)",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract Treasury {\n    // the governance address\n    address _governance;\n\n    // A constant which represents ether\n    address internal constant _ETH_CONSTANT =\n        address(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);\n\n    \n    modifier onlyGovernance() {\n        require(msg.sender == _governance, \"!governance\");\n        _;\n    }\n\n    \n    \n    constructor(address __governance) {\n        _governance = __governance;\n    }\n\n    \n    \n    \n    \n    \n    function sendFunds(\n        address _token,\n        uint256 _amount,\n        address _recipient\n    ) external onlyGovernance {\n        if (_token == _ETH_CONSTANT) {\n            payable(_recipient).transfer(_amount);\n        } else {\n            // onlyGovernance should protect from reentrancy\n            IERC20(_token).transfer(_recipient, _amount);\n        }\n    }\n\n    \n    \n    \n    \n    function approve(\n        address _token,\n        address _spender,\n        uint256 _amount\n    ) external onlyGovernance {\n        IERC20(_token).approve(_spender, _amount);\n    }\n\n    \n    \n    \n    // SWC-104-Unchecked Call Return Value: L73\n    function genericCall(address _target, bytes calldata _callData)\n        external\n        onlyGovernance\n    {\n        _target.call(_callData);\n    }\n\n    fallback() external payable {}\n}",
        "function": "approve(address,address,uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Runtime_Vrification-Element_Finance_Governance_Security_Audit_Report/council-3d751c959b42573c78ccd0bccbc80424bf6d9a90/contracts/features/Treasury.sol",
        "vulnerability": "External Call To User-Supplied Address (SWC 107)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract ProjectKudos {\n    \n    // votes limit for judge\n    uint KUDOS_LIMIT_JUDGE = 1000;\n\n    // votes limit for regular user\n    uint KUDOS_LIMIT_USER  = 10;\n\n    // enumerates reasons \n    // which additional votes can be granted for\n    enum GrantReason {\n        Facebook,\n        Twitter, \n        Fake\n    }\n//    SWC-135-Code With No Effects:L20-24,281-303,313-320\n    // keeps project votes data\n    struct ProjectInfo {\n        mapping(address => uint) kudosByUser;\n        uint kudosTotal;\n    }\n\n    // keeps user votes data\n    struct UserInfo {\n        uint kudosLimit;\n        uint kudosGiven;\n        bool isJudge;\n        mapping(uint => bool) grant;\n    }\n\n    // keeps links between user's votes \n    // and projects he voted for\n    struct UserIndex {\n        bytes32[] projects;\n        uint[] kudos;\n        mapping(bytes32 => uint) kudosIdx;\n    }\n    \n    // keeps time frames for vote period \n    struct VotePeriod {\n        uint start;\n        uint end;\n    }\n    \n    // contract creator's address\n    address owner;\n    \n    // vote period\n    VotePeriod votePeriod;\n\n    // user votes mapping\n    mapping(address => UserInfo) users;\n\n    // user index, \n    // helps to get votes given by one user for every project\n    mapping(address => UserIndex) usersIndex;\n\n    // project votes mapping\n    mapping(bytes32 => ProjectInfo) projects;\n    \n    // emitted when vote is done\n    event Vote(\n        // address of voter\n        address indexed voter,\n        // sha3 of project code\n        bytes32 indexed projectCode,\n        // votes given\n        uint indexed count\n    );\n    \n    /**\n     * @dev Contract's constructor.\n     * Stores contract's owner and sets up vote period\n     */\n    function ProjectKudos() {\n        \n        owner = msg.sender;\n        \n        votePeriod = VotePeriod(\n            1479996000,     // GMT: 24-Nov-2016 14:00, Voting starts, 1st week passed\n            1482415200      // GMT: 22-Dec-2016 14:00, Voting ends, Hackathon ends\n        );\n    }\n\n    /**\n     * @dev Registers voter to the event.\n     * Executable only by contract's owner.\n     *\n     * @param userAddres address of the user to register\n     * @param isJudge should be true if user is judge, false otherwise\n     */\n    function register(address userAddres, bool isJudge) onlyOwner {\n                            \n        UserInfo user = users[userAddres];\n\n        if (user.kudosLimit > 0) throw;\n\n        if (isJudge)\n            user.kudosLimit = KUDOS_LIMIT_JUDGE;\n        else \n            user.kudosLimit = KUDOS_LIMIT_USER;\n        \n        user.isJudge = isJudge;\n        \n        users[userAddres] = user;\n    }\n    \n    /**\n     *  @dev Gives votes to the project.\n     *  Can only be executed within vote period.\n     *  User signed the Tx becomes votes giver.\n     *\n     *  @param projectCode code of the project, must be less than or equal to 32 bytes\n     *  @param kudos - votes to be given\n     */\n    function giveKudos(string projectCode, uint kudos) duringVote {\n        \n        UserInfo giver = users[msg.sender];\n\n        if (giver.kudosGiven + kudos > giver.kudosLimit) throw;\n        \n        bytes32 code = strToBytes(projectCode);\n        ProjectInfo project = projects[code];\n\n        giver.kudosGiven += kudos;\n        project.kudosTotal += kudos;\n        project.kudosByUser[msg.sender] += kudos;\n\n        // save index of user voting history\n        updateUsersIndex(code, project.kudosByUser[msg.sender]);\n        \n        Vote(msg.sender, sha3(projectCode), kudos);\n    }\n\n    /**\n     * @dev Grants extra kudos for identity proof.\n     *\n     * @param userToGrant address of user to grant additional \n     * votes for social proof\n     * \n     * @param reason granting reason, \n     * possible reasons are listed in GrantReason enum\n     */         \n    function grantKudos(address userToGrant, uint reason) onlyOwner {\n    \n        UserInfo user = users[userToGrant];\n    \n        GrantReason grantReason = grantUintToReason(reason);\n        \n        if (grantReason != GrantReason.Facebook &&\n            grantReason != GrantReason.Twitter) throw;\n    \n        // if user is judge his identity is known\n        // not reasonble to grant more kudos for social \n        // proof.\n        if (user.isJudge) throw;\n        \n        // if not granted for that reason yet\n        if (user.grant[reason]) throw;\n        \n        // grant 100 votes\n        user.kudosLimit += 100;\n        \n        // mark reason \n        user.grant[reason] = true;\n    }\n    \n    \n    // ********************* //\n    // *   Constant Calls  * //\n    // ********************* //\n    \n    /**\n     * @dev Returns total votes given to the project\n     * \n     * @param projectCode project's code\n     * \n     * @return number of give votes\n     */\n    function getProjectKudos(string projectCode) constant returns(uint) {\n        bytes32 code = strToBytes(projectCode);\n        ProjectInfo project = projects[code];\n        return project.kudosTotal;\n    }\n\n    /**\n     * @dev Returns an array of votes given to the project\n     * corresponding to array of users passed in function call\n     * \n     * @param projectCode project's code\n     * @param users array of user addresses\n     * \n     * @return array of votes given by passed users\n     */\n    function getProjectKudosByUsers(string projectCode, address[] users) constant returns(uint[]) {\n        bytes32 code = strToBytes(projectCode);\n        ProjectInfo project = projects[code];\n        mapping(address => uint) kudosByUser = project.kudosByUser;\n        uint[] memory userKudos = new uint[](users.length);\n        for (uint i = 0; i < users.length; i++) {\n            userKudos[i] = kudosByUser[users[i]];    \n       }\n       \n       return userKudos;\n    }\n\n    /**\n     * @dev Returns votes given by speicified user \n     * to the list of projects ever voted by that user\n     * \n     * @param giver user's address\n     * @return projects array of project codes represented by bytes32 array\n     * @return kudos array of votes given by user, \n     *         index of vote corresponds to index of project from projects array\n     */\n    function getKudosPerProject(address giver) constant returns (bytes32[] projects, uint[] kudos) {\n        UserIndex idx = usersIndex[giver];\n        projects = idx.projects;\n        kudos = idx.kudos;\n    }\n\n    /**\n     * @dev Returns votes allowed to be given by user\n     * \n     * @param addr user's address\n     * @return number of votes left\n     */\n    function getKudosLeft(address addr) constant returns(uint) {\n        UserInfo user = users[addr];\n        return user.kudosLimit - user.kudosGiven;\n    }\n\n    /**\n     * @dev Returns votes given by user\n     * \n     * @param addr user's address\n     * @return number of votes given\n     */\n    function getKudosGiven(address addr) constant returns(uint) {\n        UserInfo user = users[addr];\n        return user.kudosGiven;\n    }\n\n   \n    // ********************* //\n    // *   Private Calls   * //\n    // ********************* //\n    \n    /**\n     * @dev Private function. Updates users index\n     * \n     * @param code project code represented by bytes32 array\n     * @param kudos votes total given to the project by sender\n     */\n    function updateUsersIndex(bytes32 code, uint kudos) private {\n        \n        UserIndex idx = usersIndex[msg.sender];\n        uint i = idx.kudosIdx[code];\n        \n        // add new entry to index\n        if (i == 0) {\n            i = idx.projects.length + 1;\n            idx.projects.length += 1;\n            idx.kudos.length += 1;\n            idx.projects[i - 1] = code;\n            idx.kudosIdx[code] = i;\n        }\n\n        idx.kudos[i - 1] = kudos;\n    }\n    \n    /**\n     * @dev Translates GrantReason code to GrantReason\n     * \n     * @param reason the code of the reason\n     * @return GrantReason corresponding to the code\n     */\n    function grantUintToReason(uint reason) private returns (GrantReason result) {\n        if (reason == 0)  return GrantReason.Facebook;\n        if (reason == 1)  return GrantReason.Twitter;\n        return GrantReason.Fake;\n    }\n    \n    /**\n     * @dev Translates GrantReason to its code\n     * \n     * @param reason GrantReason instance\n     * @return corresponding reason code\n     */\n    function grantReasonToUint(GrantReason reason) private returns (uint result) {\n        if (reason == GrantReason.Facebook) return 0;\n        if (reason == GrantReason.Twitter)  return 1;\n        return 3;\n    }\n    \n    /**\n     * @dev Low level function.\n     * Converts string to bytes32 array.\n     * Throws if string length is more than 32 bytes\n     * \n     * @param str string\n     * @return bytes32 representation of str\n     */\n    function strToBytes(string str) private returns (bytes32 ret) {\n        \n        if (bytes(str).length > 32) throw;\n        \n        assembly {\n            ret := mload(add(str, 32))\n        }\n    } \n\n    \n    // ********************* //\n    // *     Modifiers     * //\n    // ********************* //\n//    SWC-135-Code With No Effects:L330-334\n    /**\n     * @dev Throws if called not during the vote period\n     */\n    modifier duringVote() {\n        if (now < votePeriod.start) throw;\n        if (now >= votePeriod.end) throw;\n        _;\n    }\n//    SWC-116-Block values as a proxy for time:L331,332\n    /**\n     * @dev Throws if called not by contract's owner\n     */\n    modifier onlyOwner() { \n        if (msg.sender != owner) throw;\n        _;\n    }\n}",
        "function": "giveKudos(string,uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/openzeppelin-EtherCamp_ProjectKudos_public_code/virtual-accelerator-6665fdd4b71088443a74d1ed9fda52c6a8c8b975/ProjectKudos.sol",
        "vulnerability": "Dependence on predictable environment variable (SWC 116)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract ProjectKudos {\n    \n    // votes limit for judge\n    uint KUDOS_LIMIT_JUDGE = 1000;\n\n    // votes limit for regular user\n    uint KUDOS_LIMIT_USER  = 10;\n\n    // enumerates reasons \n    // which additional votes can be granted for\n    enum GrantReason {\n        Facebook,\n        Twitter, \n        Fake\n    }\n//    SWC-135-Code With No Effects:L20-24,281-303,313-320\n    // keeps project votes data\n    struct ProjectInfo {\n        mapping(address => uint) kudosByUser;\n        uint kudosTotal;\n    }\n\n    // keeps user votes data\n    struct UserInfo {\n        uint kudosLimit;\n        uint kudosGiven;\n        bool isJudge;\n        mapping(uint => bool) grant;\n    }\n\n    // keeps links between user's votes \n    // and projects he voted for\n    struct UserIndex {\n        bytes32[] projects;\n        uint[] kudos;\n        mapping(bytes32 => uint) kudosIdx;\n    }\n    \n    // keeps time frames for vote period \n    struct VotePeriod {\n        uint start;\n        uint end;\n    }\n    \n    // contract creator's address\n    address owner;\n    \n    // vote period\n    VotePeriod votePeriod;\n\n    // user votes mapping\n    mapping(address => UserInfo) users;\n\n    // user index, \n    // helps to get votes given by one user for every project\n    mapping(address => UserIndex) usersIndex;\n\n    // project votes mapping\n    mapping(bytes32 => ProjectInfo) projects;\n    \n    // emitted when vote is done\n    event Vote(\n        // address of voter\n        address indexed voter,\n        // sha3 of project code\n        bytes32 indexed projectCode,\n        // votes given\n        uint indexed count\n    );\n    \n    /**\n     * @dev Contract's constructor.\n     * Stores contract's owner and sets up vote period\n     */\n    function ProjectKudos() {\n        \n        owner = msg.sender;\n        \n        votePeriod = VotePeriod(\n            1479996000,     // GMT: 24-Nov-2016 14:00, Voting starts, 1st week passed\n            1482415200      // GMT: 22-Dec-2016 14:00, Voting ends, Hackathon ends\n        );\n    }\n\n    /**\n     * @dev Registers voter to the event.\n     * Executable only by contract's owner.\n     *\n     * @param userAddres address of the user to register\n     * @param isJudge should be true if user is judge, false otherwise\n     */\n    function register(address userAddres, bool isJudge) onlyOwner {\n                            \n        UserInfo user = users[userAddres];\n\n        if (user.kudosLimit > 0) throw;\n\n        if (isJudge)\n            user.kudosLimit = KUDOS_LIMIT_JUDGE;\n        else \n            user.kudosLimit = KUDOS_LIMIT_USER;\n        \n        user.isJudge = isJudge;\n        \n        users[userAddres] = user;\n    }\n    \n    /**\n     *  @dev Gives votes to the project.\n     *  Can only be executed within vote period.\n     *  User signed the Tx becomes votes giver.\n     *\n     *  @param projectCode code of the project, must be less than or equal to 32 bytes\n     *  @param kudos - votes to be given\n     */\n    function giveKudos(string projectCode, uint kudos) duringVote {\n        \n        UserInfo giver = users[msg.sender];\n\n        if (giver.kudosGiven + kudos > giver.kudosLimit) throw;\n        \n        bytes32 code = strToBytes(projectCode);\n        ProjectInfo project = projects[code];\n\n        giver.kudosGiven += kudos;\n        project.kudosTotal += kudos;\n        project.kudosByUser[msg.sender] += kudos;\n\n        // save index of user voting history\n        updateUsersIndex(code, project.kudosByUser[msg.sender]);\n        \n        Vote(msg.sender, sha3(projectCode), kudos);\n    }\n\n    /**\n     * @dev Grants extra kudos for identity proof.\n     *\n     * @param userToGrant address of user to grant additional \n     * votes for social proof\n     * \n     * @param reason granting reason, \n     * possible reasons are listed in GrantReason enum\n     */         \n    function grantKudos(address userToGrant, uint reason) onlyOwner {\n    \n        UserInfo user = users[userToGrant];\n    \n        GrantReason grantReason = grantUintToReason(reason);\n        \n        if (grantReason != GrantReason.Facebook &&\n            grantReason != GrantReason.Twitter) throw;\n    \n        // if user is judge his identity is known\n        // not reasonble to grant more kudos for social \n        // proof.\n        if (user.isJudge) throw;\n        \n        // if not granted for that reason yet\n        if (user.grant[reason]) throw;\n        \n        // grant 100 votes\n        user.kudosLimit += 100;\n        \n        // mark reason \n        user.grant[reason] = true;\n    }\n    \n    \n    // ********************* //\n    // *   Constant Calls  * //\n    // ********************* //\n    \n    /**\n     * @dev Returns total votes given to the project\n     * \n     * @param projectCode project's code\n     * \n     * @return number of give votes\n     */\n    function getProjectKudos(string projectCode) constant returns(uint) {\n        bytes32 code = strToBytes(projectCode);\n        ProjectInfo project = projects[code];\n        return project.kudosTotal;\n    }\n\n    /**\n     * @dev Returns an array of votes given to the project\n     * corresponding to array of users passed in function call\n     * \n     * @param projectCode project's code\n     * @param users array of user addresses\n     * \n     * @return array of votes given by passed users\n     */\n    function getProjectKudosByUsers(string projectCode, address[] users) constant returns(uint[]) {\n        bytes32 code = strToBytes(projectCode);\n        ProjectInfo project = projects[code];\n        mapping(address => uint) kudosByUser = project.kudosByUser;\n        uint[] memory userKudos = new uint[](users.length);\n        for (uint i = 0; i < users.length; i++) {\n            userKudos[i] = kudosByUser[users[i]];    \n       }\n       \n       return userKudos;\n    }\n\n    /**\n     * @dev Returns votes given by speicified user \n     * to the list of projects ever voted by that user\n     * \n     * @param giver user's address\n     * @return projects array of project codes represented by bytes32 array\n     * @return kudos array of votes given by user, \n     *         index of vote corresponds to index of project from projects array\n     */\n    function getKudosPerProject(address giver) constant returns (bytes32[] projects, uint[] kudos) {\n        UserIndex idx = usersIndex[giver];\n        projects = idx.projects;\n        kudos = idx.kudos;\n    }\n\n    /**\n     * @dev Returns votes allowed to be given by user\n     * \n     * @param addr user's address\n     * @return number of votes left\n     */\n    function getKudosLeft(address addr) constant returns(uint) {\n        UserInfo user = users[addr];\n        return user.kudosLimit - user.kudosGiven;\n    }\n\n    /**\n     * @dev Returns votes given by user\n     * \n     * @param addr user's address\n     * @return number of votes given\n     */\n    function getKudosGiven(address addr) constant returns(uint) {\n        UserInfo user = users[addr];\n        return user.kudosGiven;\n    }\n\n   \n    // ********************* //\n    // *   Private Calls   * //\n    // ********************* //\n    \n    /**\n     * @dev Private function. Updates users index\n     * \n     * @param code project code represented by bytes32 array\n     * @param kudos votes total given to the project by sender\n     */\n    function updateUsersIndex(bytes32 code, uint kudos) private {\n        \n        UserIndex idx = usersIndex[msg.sender];\n        uint i = idx.kudosIdx[code];\n        \n        // add new entry to index\n        if (i == 0) {\n            i = idx.projects.length + 1;\n            idx.projects.length += 1;\n            idx.kudos.length += 1;\n            idx.projects[i - 1] = code;\n            idx.kudosIdx[code] = i;\n        }\n\n        idx.kudos[i - 1] = kudos;\n    }\n    \n    /**\n     * @dev Translates GrantReason code to GrantReason\n     * \n     * @param reason the code of the reason\n     * @return GrantReason corresponding to the code\n     */\n    function grantUintToReason(uint reason) private returns (GrantReason result) {\n        if (reason == 0)  return GrantReason.Facebook;\n        if (reason == 1)  return GrantReason.Twitter;\n        return GrantReason.Fake;\n    }\n    \n    /**\n     * @dev Translates GrantReason to its code\n     * \n     * @param reason GrantReason instance\n     * @return corresponding reason code\n     */\n    function grantReasonToUint(GrantReason reason) private returns (uint result) {\n        if (reason == GrantReason.Facebook) return 0;\n        if (reason == GrantReason.Twitter)  return 1;\n        return 3;\n    }\n    \n    /**\n     * @dev Low level function.\n     * Converts string to bytes32 array.\n     * Throws if string length is more than 32 bytes\n     * \n     * @param str string\n     * @return bytes32 representation of str\n     */\n    function strToBytes(string str) private returns (bytes32 ret) {\n        \n        if (bytes(str).length > 32) throw;\n        \n        assembly {\n            ret := mload(add(str, 32))\n        }\n    } \n\n    \n    // ********************* //\n    // *     Modifiers     * //\n    // ********************* //\n//    SWC-135-Code With No Effects:L330-334\n    /**\n     * @dev Throws if called not during the vote period\n     */\n    modifier duringVote() {\n        if (now < votePeriod.start) throw;\n        if (now >= votePeriod.end) throw;\n        _;\n    }\n//    SWC-116-Block values as a proxy for time:L331,332\n    /**\n     * @dev Throws if called not by contract's owner\n     */\n    modifier onlyOwner() { \n        if (msg.sender != owner) throw;\n        _;\n    }\n}",
        "function": "giveKudos(string,uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/openzeppelin-EtherCamp_ProjectKudos_public_code/virtual-accelerator-6665fdd4b71088443a74d1ed9fda52c6a8c8b975/ProjectKudos.sol",
        "vulnerability": "Dependence on predictable environment variable (SWC 116)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract StabilityPool is LiquityBase, Ownable, CheckContract, IStabilityPool {\n    using LiquitySafeMath128 for uint128;\n\n    IBorrowerOperations public borrowerOperations;\n\n    ITroveManager public troveManager;\n\n    ILUSDToken public lusdToken;\n\n    // Needed to check if there are pending liquidations\n    ISortedTroves public sortedTroves;\n\n    ICommunityIssuance public communityIssuance;\n\n    uint256 internal ETH;  // deposited ether tracker\n\n    // Tracker for LUSD held in the pool. Changes when users deposit/withdraw, and when Trove debt is offset.\n    uint256 internal totalLUSDDeposits;\n\n   // --- Data structures ---\n\n    struct FrontEnd {\n        uint kickbackRate;\n        bool registered;\n    }\n\n    struct Deposit {\n        uint initialValue;\n        address frontEndTag;\n    }\n\n    struct Snapshots {\n        uint S;\n        uint P;\n        uint G;\n        uint128 scale;\n        uint128 epoch;\n    }\n\n    mapping (address => Deposit) public deposits;  // depositor address -> Deposit struct\n    mapping (address => Snapshots) public depositSnapshots;  // depositor address -> snapshots struct\n\n    mapping (address => FrontEnd) public frontEnds;  // front end address -> FrontEnd struct\n    mapping (address => uint) public frontEndStakes; // front end address -> last recorded total deposits, tagged with that front end\n    mapping (address => Snapshots) public frontEndSnapshots; // front end address -> snapshots struct\n\n    /*  Product 'P': Running product by which to multiply an initial deposit, in order to find the current compounded deposit,\n    * after a series of liquidations have occurred, each of which cancel some LUSD debt with the deposit.\n    *\n    * During its lifetime, a deposit's value evolves from d_t to d_t * P / P_t , where P_t\n    * is the snapshot of P taken at the instant the deposit was made. 18-digit decimal.\n    */\n    uint public P = DECIMAL_PRECISION;\n\n    // Each time the scale of P shifts by 1e18, the scale is incremented by 1\n    uint128 public currentScale;\n\n    // With each offset that fully empties the Pool, the epoch is incremented by 1\n    uint128 public currentEpoch;\n\n    /* ETH Gain sum 'S': During its lifetime, each deposit d_t earns an ETH gain of ( d_t * [S - S_t] )/P_t, where S_t\n    * is the depositor's snapshot of S taken at the time t when the deposit was made.\n    *\n    * The 'S' sums are stored in a nested mapping (epoch => scale => sum):\n    *\n    * - The inner mapping records the sum S at different scales\n    * - The outer mapping records the (scale => sum) mappings, for different epochs.\n    */\n    mapping (uint => mapping(uint => uint)) public epochToScaleToSum;\n\n    /*\n    * Similarly, the sum 'G' is used to calculate LQTY gains. During it's lifetime, each deposit d_t earns a LQTY gain of\n    *  ( d_t * [G - G_t] )/P_t, where G_t is the depositor's snapshot of G taken at time t when  the deposit was made.\n    *\n    *  LQTY reward events occur are triggered by depositor operations (new deposit, topup, withdrawal), and liquidations.\n    *  In each case, the LQTY reward is issued (i.e. G is updated), before other state changes are made.\n    */\n    mapping (uint => mapping(uint => uint)) public epochToScaleToG;\n\n    // Error tracker for the error correction in the LQTY issuance calculation\n    uint public lastLQTYError;\n    // Error trackers for the error correction in the offset calculation\n    uint public lastETHError_Offset;\n    uint public lastLUSDLossError_Offset;\n\n    // --- Contract setters ---\n\n    function setAddresses(\n        address _borrowerOperationsAddress,\n        address _troveManagerAddress,\n        address _activePoolAddress,\n        address _lusdTokenAddress,\n        address _sortedTrovesAddress,\n        address _priceFeedAddress,\n        address _communityIssuanceAddress\n    )\n        external\n        override\n        onlyOwner\n    {\n        checkContract(_borrowerOperationsAddress);\n        checkContract(_troveManagerAddress);\n        checkContract(_activePoolAddress);\n        checkContract(_lusdTokenAddress);\n        checkContract(_sortedTrovesAddress);\n        checkContract(_priceFeedAddress);\n        checkContract(_communityIssuanceAddress);\n\n        borrowerOperations = IBorrowerOperations(_borrowerOperationsAddress);\n        troveManager = ITroveManager(_troveManagerAddress);\n        activePool = IActivePool(_activePoolAddress);\n        lusdToken = ILUSDToken(_lusdTokenAddress);\n        sortedTroves = ISortedTroves(_sortedTrovesAddress);\n        priceFeed = IPriceFeed(_priceFeedAddress);\n        communityIssuance = ICommunityIssuance(_communityIssuanceAddress);\n\n        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);\n        emit TroveManagerAddressChanged(_troveManagerAddress);\n        emit ActivePoolAddressChanged(_activePoolAddress);\n        emit LUSDTokenAddressChanged(_lusdTokenAddress);\n        emit SortedTrovesAddressChanged(_sortedTrovesAddress);\n        emit PriceFeedAddressChanged(_priceFeedAddress);\n        emit CommunityIssuanceAddressChanged(_communityIssuanceAddress);\n\n        _renounceOwnership();\n    }\n\n    // --- Getters for public variables. Required by IPool interface ---\n\n    function getETH() external view override returns (uint) {\n        return ETH;\n    }\n\n    function getTotalLUSDDeposits() external view override returns (uint) {\n        return totalLUSDDeposits;\n    }\n\n    // --- External Depositor Functions ---\n\n    /*  provideToSP():\n    *\n    * - Triggers a LQTY issuance, based on time passed since the last. The LQTY issuance is shared between *all* depositors and front ends\n    * - Tags the deposit with the provided front end tag param, if it's a new deposit\n    * - Sends depositor's accumulated gains (LQTY, ETH) to depositor\n    * - Sends the tagged front end's accumulated LQTY gains to the tagged front end\n    * - Increases deposit and tagged front end's stake, and takes new snapshots for each.\n    */\n    function provideToSP(uint _amount, address _frontEndTag) external override {\n        _requireFrontEndIsRegisteredOrZero(_frontEndTag);\n        _requireFrontEndNotRegistered(msg.sender);\n        _requireNonZeroAmount(_amount);\n\n        uint initialDeposit = deposits[msg.sender].initialValue;\n\n        _triggerLQTYIssuance();\n\n        if (initialDeposit == 0) {_setFrontEndTag(msg.sender, _frontEndTag);}\n        uint depositorETHGain = getDepositorETHGain(msg.sender);\n        uint compoundedLUSDDeposit = getCompoundedLUSDDeposit(msg.sender);\n        uint LUSDLoss = initialDeposit.sub(compoundedLUSDDeposit); // Needed only for event log\n\n        // First pay out any LQTY gains\n        address frontEnd = deposits[msg.sender].frontEndTag;\n        _payOutLQTYGains(msg.sender, frontEnd);\n\n        // Update front end stake\n        uint compoundedFrontEndStake = getCompoundedFrontEndStake(frontEnd);\n        uint newFrontEndStake = compoundedFrontEndStake.add(_amount);\n        _updateFrontEndStakeAndSnapshots(frontEnd, newFrontEndStake);\n        emit FrontEndStakeChanged(frontEnd, newFrontEndStake, msg.sender);\n\n        _sendLUSDtoStabilityPool(msg.sender, _amount);\n\n        uint newDeposit = compoundedLUSDDeposit.add(_amount);\n        _updateDepositAndSnapshots(msg.sender, newDeposit);\n        emit UserDepositChanged(msg.sender, newDeposit);\n\n        emit ETHGainWithdrawn(msg.sender, depositorETHGain, LUSDLoss); // LUSD Loss required for event log\n\n        _sendETHGainToDepositor(depositorETHGain);\n     }\n\n    /*  withdrawFromSP():\n    *\n    * - Triggers a LQTY issuance, based on time passed since the last. The LQTY issuance is shared between *all* depositors and front ends\n    * - Removes the deposit's front end tag if it is a full withdrawal\n    * - Sends all depositor's accumulated gains (LQTY, ETH) to depositor\n    * - Sends the tagged front end's accumulated LQTY gains to the tagged front end\n    * - Decreases deposit and tagged front end's stake, and takes new snapshots for each.\n    *\n    * If _amount > userDeposit, the user withdraws all of their compounded deposit.\n    */\n    function withdrawFromSP(uint _amount) external override {\n        if (_amount !=0) {_requireNoUnderCollateralizedTroves();}\n        uint initialDeposit = deposits[msg.sender].initialValue;\n        _requireUserHasDeposit(initialDeposit);\n\n        _triggerLQTYIssuance();\n\n        uint depositorETHGain = getDepositorETHGain(msg.sender);\n\n        uint compoundedLUSDDeposit = getCompoundedLUSDDeposit(msg.sender);\n        uint LUSDtoWithdraw = LiquityMath._min(_amount, compoundedLUSDDeposit);\n        uint LUSDLoss = initialDeposit.sub(compoundedLUSDDeposit); // Needed only for event log\n\n        // First pay out any LQTY gains\n        address frontEnd = deposits[msg.sender].frontEndTag;\n        _payOutLQTYGains(msg.sender, frontEnd);\n\n        // Update front end stake\n        uint compoundedFrontEndStake = getCompoundedFrontEndStake(frontEnd);\n        uint newFrontEndStake = compoundedFrontEndStake.sub(LUSDtoWithdraw);\n        _updateFrontEndStakeAndSnapshots(frontEnd, newFrontEndStake);\n        emit FrontEndStakeChanged(frontEnd, newFrontEndStake, msg.sender);\n\n        _sendLUSDToDepositor(msg.sender, LUSDtoWithdraw);\n\n        // Update deposit\n        uint newDeposit = compoundedLUSDDeposit.sub(LUSDtoWithdraw);\n        _updateDepositAndSnapshots(msg.sender, newDeposit);\n        emit UserDepositChanged(msg.sender, newDeposit);\n\n        emit ETHGainWithdrawn(msg.sender, depositorETHGain, LUSDLoss);  // LUSD Loss required for event log\n\n        _sendETHGainToDepositor(depositorETHGain);\n    }\n\n    /* withdrawETHGainToTrove:\n    * - Triggers a LQTY issuance, based on time passed since the last. The LQTY issuance is shared between *all* depositors and front ends\n    * - Sends all depositor's LQTY gain to  depositor\n    * - Sends all tagged front end's LQTY gain to the tagged front end\n    * - Transfers the depositor's entire ETH gain from the Stability Pool to the caller's trove\n    * - Leaves their compounded deposit in the Stability Pool\n    * - Updates snapshots for deposit and tagged front end stake */\n    function withdrawETHGainToTrove(address _upperHint, address _lowerHint) external override {\n        uint initialDeposit = deposits[msg.sender].initialValue;\n        _requireUserHasDeposit(initialDeposit);\n        _requireUserHasTrove(msg.sender);\n        _requireUserHasETHGain(msg.sender);\n\n        _triggerLQTYIssuance();\n\n        uint depositorETHGain = getDepositorETHGain(msg.sender);\n\n        uint compoundedLUSDDeposit = getCompoundedLUSDDeposit(msg.sender);\n        uint LUSDLoss = initialDeposit.sub(compoundedLUSDDeposit); // Needed only for event log\n\n        // First pay out any LQTY gains\n        address frontEnd = deposits[msg.sender].frontEndTag;\n        _payOutLQTYGains(msg.sender, frontEnd);\n\n        // Update front end stake\n        uint compoundedFrontEndStake = getCompoundedFrontEndStake(frontEnd);\n        uint newFrontEndStake = compoundedFrontEndStake;\n        _updateFrontEndStakeAndSnapshots(frontEnd, newFrontEndStake);\n        emit FrontEndStakeChanged(frontEnd, newFrontEndStake, msg.sender);\n\n        _updateDepositAndSnapshots(msg.sender, compoundedLUSDDeposit);\n\n        /* Emit events before transferring ETH gain to Trove.\n         This lets the event log make more sense (i.e. so it appears that first the ETH gain is withdrawn\n        and then it is deposited into the Trove, not the other way around). */\n        emit ETHGainWithdrawn(msg.sender, depositorETHGain, LUSDLoss);\n        emit UserDepositChanged(msg.sender, compoundedLUSDDeposit);\n\n        ETH = ETH.sub(depositorETHGain);\n        emit ETHBalanceUpdated(ETH);\n        emit EtherSent(msg.sender, depositorETHGain);\n\n        borrowerOperations.moveETHGainToTrove{ value: depositorETHGain }(msg.sender, _upperHint, _lowerHint);\n    }\n\n    // --- LQTY issuance functions ---\n\n    function _triggerLQTYIssuance() internal {\n        uint LQTYIssuance = communityIssuance.issueLQTY();\n       _updateG(LQTYIssuance);\n    }\n\n    function _updateG(uint _LQTYIssuance) internal {\n        uint totalLUSD = totalLUSDDeposits; // cached to save an SLOAD\n\n        /*\n        * When total deposits is 0, G is not updated. In this case, the LQTY issued can not be obtained by later\n        * depositors - it is missed out on, and remains in the balanceof the CommunityIssuance contract.\n        *\n        */\n        if (totalLUSD == 0 || _LQTYIssuance == 0) {return;}\n\n        uint LQTYPerUnitStaked;\n        LQTYPerUnitStaked =_computeLQTYPerUnitStaked(_LQTYIssuance, totalLUSD);\n\n        uint marginalLQTYGain = LQTYPerUnitStaked.mul(P);\n        epochToScaleToG[currentEpoch][currentScale] = epochToScaleToG[currentEpoch][currentScale].add(marginalLQTYGain);\n    }\n\n    function _computeLQTYPerUnitStaked(uint _LQTYIssuance, uint _totalLUSDDeposits) internal returns (uint) {\n        /*  \n        * Calculate the LQTY-per-unit staked.  Division uses a \"feedback\" error correction, to keep the \n        * cumulative error low in the running total G:\n        *\n        * 1) Form a numerator which compensates for the floor division error that occurred the last time this \n        * function was called.  \n        * 2) Calculate \"per-unit-staked\" ratio.\n        * 3) Multiply the ratio back by its denominator, to reveal the current floor division error.\n        * 4) Store this error for use in the next correction when this function is called.\n        * 5) Note: static analysis tools complain about this \"division before multiplication\", however, it is intended.\n        */\n        uint LQTYNumerator = _LQTYIssuance.mul(DECIMAL_PRECISION).add(lastLQTYError);\n\n        uint LQTYPerUnitStaked = LQTYNumerator.div(_totalLUSDDeposits);\n        lastLQTYError = LQTYNumerator.sub(LQTYPerUnitStaked.mul(_totalLUSDDeposits));\n\n        return LQTYPerUnitStaked;\n    }\n\n    // --- Liquidation functions ---\n\n    /*\n    * Cancel out the specified debt against the LUSD contained in the Stability Pool (as far as possible)\n    * and transfers the Trove's ETH collateral from ActivePool to StabilityPool.\n    * Only called by liquidation functions in the TroveManager.\n    */\n    function offset(uint _debtToOffset, uint _collToAdd) external override {\n        _requireCallerIsTroveManager();\n        uint totalLUSD = totalLUSDDeposits; // cached to save an SLOAD\n        if (totalLUSD == 0 || _debtToOffset == 0) { return; }\n\n        _triggerLQTYIssuance();\n\n        (uint ETHGainPerUnitStaked,\n            uint LUSDLossPerUnitStaked) = _computeRewardsPerUnitStaked(_collToAdd, _debtToOffset, totalLUSD);\n\n        _updateRewardSumAndProduct(ETHGainPerUnitStaked, LUSDLossPerUnitStaked);  // updates S and P\n\n        _moveOffsetCollAndDebt(_collToAdd, _debtToOffset);\n    }\n\n    // --- Offset helper functions ---\n\n    function _computeRewardsPerUnitStaked(\n        uint _collToAdd,\n        uint _debtToOffset,\n        uint _totalLUSDDeposits\n    )\n        internal\n        returns (uint ETHGainPerUnitStaked, uint LUSDLossPerUnitStaked)\n    {\n        /*\n        * Compute the LUSD and ETH rewards. Uses a \"feedback\" error correction, to keep\n        * the cumulative error in the P and S state variables low:\n        *\n        * 1) Form numerators which compensate for the floor division errors that occurred the last time this \n        * function was called.  \n        * 2) Calculate \"per-unit-staked\" ratios.\n        * 3) Multiply each ratio back by its denominator, to reveal the current floor division error.\n        * 4) Store these errors for use in the next correction when this function is called.\n        * 5) Note: static analysis tools complain about this \"division before multiplication\", however, it is intended.\n        */\n        uint LUSDLossNumerator = _debtToOffset.mul(DECIMAL_PRECISION).sub(lastLUSDLossError_Offset);\n        uint ETHNumerator = _collToAdd.mul(DECIMAL_PRECISION).add(lastETHError_Offset);\n\n\n        if (_debtToOffset >= _totalLUSDDeposits) {\n            LUSDLossPerUnitStaked = DECIMAL_PRECISION;\n            lastLUSDLossError_Offset = 0;\n        } else {\n            /*\n            * Add 1 to make error in quotient positive. We want \"slightly too much\" LUSD loss,\n            * which ensures the error in any given compoundedLUSDDeposit favors the Stability Pool.\n            */\n            LUSDLossPerUnitStaked = (LUSDLossNumerator.div(_totalLUSDDeposits)).add(1);\n            // SWC-101-Integer Overflow and Underflow: L504\n            lastLUSDLossError_Offset = (LUSDLossPerUnitStaked.mul(_totalLUSDDeposits)).sub(LUSDLossNumerator);\n        }\n\n        ETHGainPerUnitStaked = ETHNumerator.div(_totalLUSDDeposits);\n        lastETHError_Offset = ETHNumerator.sub(ETHGainPerUnitStaked.mul(_totalLUSDDeposits));\n\n        return (ETHGainPerUnitStaked, LUSDLossPerUnitStaked);\n    }\n\n    // Update the Stability Pool reward sum S and product P\n    function _updateRewardSumAndProduct(uint _ETHGainPerUnitStaked, uint _LUSDLossPerUnitStaked) internal {\n        uint currentP = P;\n        uint newP;\n\n        assert(_LUSDLossPerUnitStaked <= DECIMAL_PRECISION);\n        /*\n        * The newProductFactor is the factor by which to change all deposits, due to the depletion of Stability Pool LUSD in the liquidation.\n        * We make the product factor 0 if there was a pool-emptying. Otherwise, it is (1 - LUSDLossPerUnitStaked)\n        */\n        uint newProductFactor = _LUSDLossPerUnitStaked >= DECIMAL_PRECISION ? 0 : uint(DECIMAL_PRECISION).sub(_LUSDLossPerUnitStaked);\n\n        uint128 currentScaleCached = currentScale;\n        uint128 currentEpochCached = currentEpoch;\n        uint currentS = epochToScaleToSum[currentEpochCached][currentScaleCached];\n\n        /*\n        * Calculate the new S first, before we update P.\n        * The ETH gain for any given depositor from a liquidation depends on the value of their deposit\n        * (and the value of totalDeposits) prior to the Stability being depleted by the debt in the liquidation.\n        *\n        * Since S corresponds to ETH gain, and P to deposit loss, we update S first.\n        */\n        uint marginalETHGain = _ETHGainPerUnitStaked.mul(currentP);\n        uint newS = currentS.add(marginalETHGain);\n        epochToScaleToSum[currentEpochCached][currentScaleCached] = newS;\n        emit S_Updated(newS);\n\n        // If the Stability Pool was emptied, increment the epoch, and reset the scale and product P\n        if (newProductFactor == 0) {\n            currentEpoch = currentEpochCached.add(1);\n            currentScale = 0;\n            newP = DECIMAL_PRECISION;\n\n        // If multiplying P by a non-zero product factor would round P to zero, increment the scale\n        } else if (currentP.mul(newProductFactor) < DECIMAL_PRECISION) {\n            newP = currentP.mul(newProductFactor);\n            currentScale = currentScaleCached.add(1);\n        } else {\n            newP = currentP.mul(newProductFactor).div(DECIMAL_PRECISION);\n        }\n\n        P = newP;\n        emit P_Updated(newP);\n    }\n\n    function _moveOffsetCollAndDebt(uint _collToAdd, uint _debtToOffset) internal {\n        // Cancel the liquidated LUSD debt with the LUSD in the stability pool\n        activePool.decreaseLUSDDebt(_debtToOffset);\n        _decreaseLUSD(_debtToOffset);\n\n        // Burn the debt that was successfully offset\n        lusdToken.burn(address(this), _debtToOffset);\n\n        activePool.sendETH(address(this), _collToAdd);\n    }\n\n    function _decreaseLUSD(uint _amount) internal {\n        uint newTotalLUSDDeposits = totalLUSDDeposits.sub(_amount);\n        totalLUSDDeposits = newTotalLUSDDeposits;\n        emit LUSDBalanceUpdated(newTotalLUSDDeposits);\n    }\n\n    // --- Reward calculator functions for depositor and front end ---\n\n    /* Calculates the ETH gain earned by the deposit since its last snapshots were taken.\n    * Given by the formula:  E = d0 * (S - S(0))/P(0)\n    * where S(0) and P(0) are the depositor's snapshots of the sum S and product P, respectively.\n    * d0 is the last recorded deposit value.\n    */\n    function getDepositorETHGain(address _depositor) public view override returns (uint) {\n        uint initialDeposit = deposits[_depositor].initialValue;\n\n        if (initialDeposit == 0) { return 0; }\n\n        Snapshots memory snapshots = depositSnapshots[_depositor];\n\n        uint ETHGain = _getETHGainFromSnapshots(initialDeposit, snapshots);\n        return ETHGain;\n    }\n\n    function _getETHGainFromSnapshots(uint initialDeposit, Snapshots memory snapshots) internal view returns (uint) {\n        /*\n        * Grab the sum 'S' from the epoch at which the stake was made. The ETH gain may span up to one scale change.\n        * If it does, the second portion of the ETH gain is scaled by 1e18.\n        * If the gain spans no scale change, the second portion will be 0.\n        */\n        uint128 epochSnapshot = snapshots.epoch;\n        uint128 scaleSnapshot = snapshots.scale;\n        uint S_Snapshot = snapshots.S;\n        uint P_Snapshot = snapshots.P;\n\n        uint firstPortion = epochToScaleToSum[epochSnapshot][scaleSnapshot].sub(S_Snapshot);\n        uint secondPortion = epochToScaleToSum[epochSnapshot][scaleSnapshot.add(1)].div(DECIMAL_PRECISION);\n\n        uint ETHGain = initialDeposit.mul(firstPortion.add(secondPortion)).div(P_Snapshot).div(DECIMAL_PRECISION);\n\n        return ETHGain;\n    }\n\n    /*\n    * Calculate the LQTY gain earned by a deposit since its last snapshots were taken.\n    * Given by the formula:  LQTY = d0 * (G - G(0))/P(0)\n    * where G(0) and P(0) are the depositor's snapshots of the sum G and product P, respectively.\n    * d0 is the last recorded deposit value.\n    */\n    function getDepositorLQTYGain(address _depositor) public view override returns (uint) {\n        uint initialDeposit = deposits[_depositor].initialValue;\n        if (initialDeposit == 0) {return 0;}\n\n        address frontEndTag = deposits[_depositor].frontEndTag;\n\n        /*\n        * If not tagged with a front end, the depositor gets a 100% cut of what their deposit earned.\n        * Otherwise, their cut of the deposit's earnings is equal to the kickbackRate, set by the front end through\n        * which they made their deposit.\n        */\n        uint kickbackRate = frontEndTag == address(0) ? DECIMAL_PRECISION : frontEnds[frontEndTag].kickbackRate;\n\n        Snapshots memory snapshots = depositSnapshots[_depositor];\n\n        uint LQTYGain = kickbackRate.mul(_getLQTYGainFromSnapshots(initialDeposit, snapshots)).div(DECIMAL_PRECISION);\n\n        return LQTYGain;\n    }\n\n    /*\n    * Return the LQTY gain earned by the front end. Given by the formula:  E = D0 * (G - G(0))/P(0)\n    * where G(0) and P(0) are the depositor's snapshots of the sum G and product P, respectively.\n    *\n    * D0 is the last recorded value of the front end's total tagged deposits.\n    */\n    function getFrontEndLQTYGain(address _frontEnd) public view override returns (uint) {\n        uint frontEndStake = frontEndStakes[_frontEnd];\n        if (frontEndStake == 0) { return 0; }\n\n        uint kickbackRate = frontEnds[_frontEnd].kickbackRate;\n        uint frontEndShare = uint(DECIMAL_PRECISION).sub(kickbackRate);\n\n        Snapshots memory snapshots = frontEndSnapshots[_frontEnd];\n\n        uint LQTYGain = frontEndShare.mul(_getLQTYGainFromSnapshots(frontEndStake, snapshots)).div(DECIMAL_PRECISION);\n        return LQTYGain;\n    }\n\n    function _getLQTYGainFromSnapshots(uint initialStake, Snapshots memory snapshots) internal view returns (uint) {\n       /*\n        * Grab the sum 'G' from the epoch at which the stake was made. The LQTY gain may span up to one scale change.\n        * If it does, the second portion of the LQTY gain is scaled by 1e18.\n        * If the gain spans no scale change, the second portion will be 0.\n        */\n        uint128 epochSnapshot = snapshots.epoch;\n        uint128 scaleSnapshot = snapshots.scale;\n        uint G_Snapshot = snapshots.G;\n        uint P_Snapshot = snapshots.P;\n\n        uint firstPortion = epochToScaleToG[epochSnapshot][scaleSnapshot].sub(G_Snapshot);\n        uint secondPortion = epochToScaleToG[epochSnapshot][scaleSnapshot.add(1)].div(DECIMAL_PRECISION);\n\n        uint LQTYGain = initialStake.mul(firstPortion.add(secondPortion)).div(P_Snapshot).div(DECIMAL_PRECISION);\n\n        return LQTYGain;\n    }\n\n    // --- Compounded deposit and compounded front end stake ---\n\n    /*\n    * Return the user's compounded deposit. Given by the formula:  d = d0 * P/P(0)\n    * where P(0) is the depositor's snapshot of the product P, taken when they last updated their deposit.\n    */\n    function getCompoundedLUSDDeposit(address _depositor) public view override returns (uint) {\n        uint initialDeposit = deposits[_depositor].initialValue;\n        if (initialDeposit == 0) { return 0; }\n\n        Snapshots memory snapshots = depositSnapshots[_depositor];\n\n        uint compoundedDeposit = _getCompoundedStakeFromSnapshots(initialDeposit, snapshots);\n        return compoundedDeposit;\n    }\n\n    /*\n    * Return the front end's compounded stake. Given by the formula:  D = D0 * P/P(0)\n    * where P(0) is the depositor's snapshot of the product P, taken at the last time\n    * when one of the front end's tagged deposits updated their deposit.\n    *\n    * The front end's compounded stake is equal to the sum of its depositors' compounded deposits.\n    */\n    function getCompoundedFrontEndStake(address _frontEnd) public view override returns (uint) {\n        uint frontEndStake = frontEndStakes[_frontEnd];\n        if (frontEndStake == 0) { return 0; }\n\n        Snapshots memory snapshots = frontEndSnapshots[_frontEnd];\n\n        uint compoundedFrontEndStake = _getCompoundedStakeFromSnapshots(frontEndStake, snapshots);\n        return compoundedFrontEndStake;\n    }\n\n    // Internal function, used to calculcate compounded deposits and compounded front end stakes.\n    function _getCompoundedStakeFromSnapshots(\n        uint initialStake,\n        Snapshots memory snapshots\n    )\n        internal\n        view\n        returns (uint)\n    {\n        uint snapshot_P = snapshots.P;\n        uint128 scaleSnapshot = snapshots.scale;\n        uint128 epochSnapshot = snapshots.epoch;\n\n        // If stake was made before a pool-emptying event, then it has been fully cancelled with debt -- so, return 0\n        if (epochSnapshot < currentEpoch) { return 0; }\n\n        uint compoundedStake;\n        uint128 scaleDiff = currentScale.sub(scaleSnapshot);\n\n        /* Compute the compounded stake. If a scale change in P was made during the stake's lifetime,\n        * account for it. If more than one scale change was made, then the stake has decreased by a factor of\n        * at least 1e-18 -- so return 0.\n        */\n        if (scaleDiff == 0) {\n            compoundedStake = initialStake.mul(P).div(snapshot_P);\n        } else if (scaleDiff == 1) {\n            compoundedStake = initialStake.mul(P).div(snapshot_P).div(DECIMAL_PRECISION);\n        } else {\n            compoundedStake = 0;\n        }\n\n        /*\n        * If compounded deposit is less than a billionth of the initial deposit, return 0.\n        *\n        * NOTE: originally, this line was in place to stop rounding errors making the deposit too large. However, the error\n        * corrections should ensure the error in P \"favors the Pool\", i.e. any given compounded deposit should slightly less\n        * than it's theoretical value.\n        *\n        * Thus it's unclear whether this line is still really needed.\n        */\n        if (compoundedStake < initialStake.div(1e9)) {return 0;}\n\n        return compoundedStake;\n    }\n\n    // --- Sender functions for LUSD deposit, ETH gains and LQTY gains ---\n\n    // Transfer the LUSD tokens from the user to the Stability Pool's address, and update its recorded LUSD\n    function _sendLUSDtoStabilityPool(address _address, uint _amount) internal {\n        lusdToken.sendToPool(_address, address(this), _amount);\n        uint newTotalLUSDDeposits = totalLUSDDeposits.add(_amount);\n        totalLUSDDeposits = newTotalLUSDDeposits;\n        emit LUSDBalanceUpdated(newTotalLUSDDeposits);\n    }\n\n    function _sendETHGainToDepositor(uint _amount) internal {\n        if (_amount == 0) {return;}\n        uint newETH = ETH.sub(_amount);\n        ETH = newETH;\n        emit ETHBalanceUpdated(newETH);\n        emit EtherSent(msg.sender, _amount);\n\n        (bool success, ) = msg.sender.call{ value: _amount }(\"\");\n        require(success, \"StabilityPool: sending ETH failed\");\n    }\n\n    // Send LUSD to user and decrease LUSD in Pool\n    function _sendLUSDToDepositor(address _depositor, uint LUSDWithdrawal) internal {\n        if (LUSDWithdrawal == 0) {return;}\n\n        lusdToken.returnFromPool(address(this), _depositor, LUSDWithdrawal);\n        _decreaseLUSD(LUSDWithdrawal);\n    }\n\n    // --- External Front End functions ---\n\n    // Front end makes a one-time selection of kickback rate upon registering\n    function registerFrontEnd(uint _kickbackRate) external override {\n        _requireFrontEndNotRegistered(msg.sender);\n        _requireUserHasNoDeposit(msg.sender);\n        _requireValidKickbackRate(_kickbackRate);\n\n        frontEnds[msg.sender].kickbackRate = _kickbackRate;\n        frontEnds[msg.sender].registered = true;\n\n        emit FrontEndRegistered(msg.sender, _kickbackRate);\n    }\n\n    // --- Stability Pool Deposit Functionality ---\n\n    function _setFrontEndTag(address _depositor, address _frontEndTag) internal {\n        deposits[_depositor].frontEndTag = _frontEndTag;\n    }\n\n\n    function _updateDepositAndSnapshots(address _depositor, uint _newValue) internal {\n        deposits[_depositor].initialValue = _newValue;\n\n        if (_newValue == 0) {\n            delete deposits[_depositor].frontEndTag;\n            delete depositSnapshots[_depositor];\n            emit DepositSnapshotUpdated(_depositor, 0, 0, 0);\n            return;\n        }\n        uint128 currentScaleCached = currentScale;\n        uint128 currentEpochCached = currentEpoch;\n        uint currentP = P;\n\n        // Get S and G for the current epoch and current scale\n        uint currentS = epochToScaleToSum[currentEpochCached][currentScaleCached];\n        uint currentG = epochToScaleToG[currentEpochCached][currentScaleCached];\n\n        // Record new snapshots of the latest running product P, sum S, and sum G, for the depositor\n        depositSnapshots[_depositor].P = currentP;\n        depositSnapshots[_depositor].S = currentS;\n        depositSnapshots[_depositor].G = currentG;\n        depositSnapshots[_depositor].scale = currentScaleCached;\n        depositSnapshots[_depositor].epoch = currentEpochCached;\n\n        emit DepositSnapshotUpdated(_depositor, currentP, currentS, currentG);\n    }\n\n    function _updateFrontEndStakeAndSnapshots(address _frontEnd, uint _newValue) internal {\n        frontEndStakes[_frontEnd] = _newValue;\n\n        if (_newValue == 0) {\n            delete frontEndSnapshots[_frontEnd];\n            emit FrontEndSnapshotUpdated(_frontEnd, 0, 0);\n            return;\n        }\n\n        uint128 currentScaleCached = currentScale;\n        uint128 currentEpochCached = currentEpoch;\n        uint currentP = P;\n\n        // Get G for the current epoch and current scale\n        uint currentG = epochToScaleToG[currentEpochCached][currentScaleCached];\n\n        // Record new snapshots of the latest running product P and sum G for the front end\n        frontEndSnapshots[_frontEnd].P = currentP;\n        frontEndSnapshots[_frontEnd].G = currentG;\n        frontEndSnapshots[_frontEnd].scale = currentScaleCached;\n        frontEndSnapshots[_frontEnd].epoch = currentEpochCached;\n\n        emit FrontEndSnapshotUpdated(_frontEnd, currentP, currentG);\n    }\n\n    function _payOutLQTYGains(address _depositor, address _frontEnd) internal {\n        // Pay out front end's LQTY gain\n        if (_frontEnd != address(0)) {\n            uint frontEndLQTYGain = getFrontEndLQTYGain(_frontEnd);\n            communityIssuance.sendLQTY(_frontEnd, frontEndLQTYGain);\n            emit LQTYPaidToFrontEnd(_frontEnd, frontEndLQTYGain);\n        }\n\n        // Pay out depositor's LQTY gain\n        uint depositorLQTYGain = getDepositorLQTYGain(_depositor);\n        communityIssuance.sendLQTY(_depositor, depositorLQTYGain);\n        emit LQTYPaidToDepositor(_depositor, depositorLQTYGain);\n    }\n\n    // --- 'require' functions ---\n\n    function _requireCallerIsActivePool() internal view {\n        require( msg.sender == address(activePool), \"StabilityPool: Caller is not ActivePool\");\n    }\n\n    function _requireCallerIsTroveManager() internal view {\n        require(msg.sender == address(troveManager), \"StabilityPool: Caller is not TroveManager\");\n    }\n\n    function _requireNoUnderCollateralizedTroves() internal {\n        uint price = priceFeed.fetchPrice();\n        address lowestTrove = sortedTroves.getLast();\n        uint ICR = troveManager.getCurrentICR(lowestTrove, price);\n        require(ICR >= MCR, \"StabilityPool: Cannot withdraw while there are troves with ICR < MCR\");\n    }\n\n    function _requireUserHasDeposit(uint _initialDeposit) internal pure {\n        require(_initialDeposit > 0, 'StabilityPool: User must have a non-zero deposit');\n    }\n\n     function _requireUserHasNoDeposit(address _address) internal view {\n        uint initialDeposit = deposits[_address].initialValue;\n        require(initialDeposit == 0, 'StabilityPool: User must have no deposit');\n    }\n\n    function _requireNonZeroAmount(uint _amount) internal pure {\n        require(_amount > 0, 'StabilityPool: Amount must be non-zero');\n    }\n\n    function _requireUserHasTrove(address _depositor) internal view {\n        require(troveManager.getTroveStatus(_depositor) == 1, \"StabilityPool: caller must have an active trove to withdraw ETHGain to\");\n    }\n\n    function _requireUserHasETHGain(address _depositor) internal view {\n        uint ETHGain = getDepositorETHGain(_depositor);\n        require(ETHGain > 0, \"StabilityPool: caller must have non-zero ETH Gain\");\n    }\n\n    function _requireFrontEndNotRegistered(address _address) internal view {\n        require(!frontEnds[_address].registered, \"StabilityPool: must not already be a registered front end\");\n    }\n\n     function _requireFrontEndIsRegisteredOrZero(address _address) internal view {\n        require(frontEnds[_address].registered || _address == address(0),\n            \"StabilityPool: Tag must be a registered front end, or the zero address\");\n    }\n\n    function  _requireValidKickbackRate(uint _kickbackRate) internal pure {\n        require (_kickbackRate <= DECIMAL_PRECISION, \"StabilityPool: Kickback rate must be in range [0,1]\");\n    }\n\n    // --- Fallback function ---\n\n    receive() external payable {\n        _requireCallerIsActivePool();\n        ETH = ETH.add(msg.value);\n    }\n}",
        "function": "getEntireSystemDebt()",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-LiquityProtocolandStabilityPoolFinalReport/dev-8cec3fda04b8c71994dc14858386bf6a161164fc/packages/contracts/contracts/StabilityPool.sol",
        "vulnerability": "Multiple Calls in a Single Transaction (SWC 113)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract StabilityPool is LiquityBase, Ownable, CheckContract, IStabilityPool {\n    using LiquitySafeMath128 for uint128;\n\n    IBorrowerOperations public borrowerOperations;\n\n    ITroveManager public troveManager;\n\n    ILUSDToken public lusdToken;\n\n    // Needed to check if there are pending liquidations\n    ISortedTroves public sortedTroves;\n\n    ICommunityIssuance public communityIssuance;\n\n    uint256 internal ETH;  // deposited ether tracker\n\n    // Tracker for LUSD held in the pool. Changes when users deposit/withdraw, and when Trove debt is offset.\n    uint256 internal totalLUSDDeposits;\n\n   // --- Data structures ---\n\n    struct FrontEnd {\n        uint kickbackRate;\n        bool registered;\n    }\n\n    struct Deposit {\n        uint initialValue;\n        address frontEndTag;\n    }\n\n    struct Snapshots {\n        uint S;\n        uint P;\n        uint G;\n        uint128 scale;\n        uint128 epoch;\n    }\n\n    mapping (address => Deposit) public deposits;  // depositor address -> Deposit struct\n    mapping (address => Snapshots) public depositSnapshots;  // depositor address -> snapshots struct\n\n    mapping (address => FrontEnd) public frontEnds;  // front end address -> FrontEnd struct\n    mapping (address => uint) public frontEndStakes; // front end address -> last recorded total deposits, tagged with that front end\n    mapping (address => Snapshots) public frontEndSnapshots; // front end address -> snapshots struct\n\n    /*  Product 'P': Running product by which to multiply an initial deposit, in order to find the current compounded deposit,\n    * after a series of liquidations have occurred, each of which cancel some LUSD debt with the deposit.\n    *\n    * During its lifetime, a deposit's value evolves from d_t to d_t * P / P_t , where P_t\n    * is the snapshot of P taken at the instant the deposit was made. 18-digit decimal.\n    */\n    uint public P = DECIMAL_PRECISION;\n\n    // Each time the scale of P shifts by 1e18, the scale is incremented by 1\n    uint128 public currentScale;\n\n    // With each offset that fully empties the Pool, the epoch is incremented by 1\n    uint128 public currentEpoch;\n\n    /* ETH Gain sum 'S': During its lifetime, each deposit d_t earns an ETH gain of ( d_t * [S - S_t] )/P_t, where S_t\n    * is the depositor's snapshot of S taken at the time t when the deposit was made.\n    *\n    * The 'S' sums are stored in a nested mapping (epoch => scale => sum):\n    *\n    * - The inner mapping records the sum S at different scales\n    * - The outer mapping records the (scale => sum) mappings, for different epochs.\n    */\n    mapping (uint => mapping(uint => uint)) public epochToScaleToSum;\n\n    /*\n    * Similarly, the sum 'G' is used to calculate LQTY gains. During it's lifetime, each deposit d_t earns a LQTY gain of\n    *  ( d_t * [G - G_t] )/P_t, where G_t is the depositor's snapshot of G taken at time t when  the deposit was made.\n    *\n    *  LQTY reward events occur are triggered by depositor operations (new deposit, topup, withdrawal), and liquidations.\n    *  In each case, the LQTY reward is issued (i.e. G is updated), before other state changes are made.\n    */\n    mapping (uint => mapping(uint => uint)) public epochToScaleToG;\n\n    // Error tracker for the error correction in the LQTY issuance calculation\n    uint public lastLQTYError;\n    // Error trackers for the error correction in the offset calculation\n    uint public lastETHError_Offset;\n    uint public lastLUSDLossError_Offset;\n\n    // --- Contract setters ---\n\n    function setAddresses(\n        address _borrowerOperationsAddress,\n        address _troveManagerAddress,\n        address _activePoolAddress,\n        address _lusdTokenAddress,\n        address _sortedTrovesAddress,\n        address _priceFeedAddress,\n        address _communityIssuanceAddress\n    )\n        external\n        override\n        onlyOwner\n    {\n        checkContract(_borrowerOperationsAddress);\n        checkContract(_troveManagerAddress);\n        checkContract(_activePoolAddress);\n        checkContract(_lusdTokenAddress);\n        checkContract(_sortedTrovesAddress);\n        checkContract(_priceFeedAddress);\n        checkContract(_communityIssuanceAddress);\n\n        borrowerOperations = IBorrowerOperations(_borrowerOperationsAddress);\n        troveManager = ITroveManager(_troveManagerAddress);\n        activePool = IActivePool(_activePoolAddress);\n        lusdToken = ILUSDToken(_lusdTokenAddress);\n        sortedTroves = ISortedTroves(_sortedTrovesAddress);\n        priceFeed = IPriceFeed(_priceFeedAddress);\n        communityIssuance = ICommunityIssuance(_communityIssuanceAddress);\n\n        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);\n        emit TroveManagerAddressChanged(_troveManagerAddress);\n        emit ActivePoolAddressChanged(_activePoolAddress);\n        emit LUSDTokenAddressChanged(_lusdTokenAddress);\n        emit SortedTrovesAddressChanged(_sortedTrovesAddress);\n        emit PriceFeedAddressChanged(_priceFeedAddress);\n        emit CommunityIssuanceAddressChanged(_communityIssuanceAddress);\n\n        _renounceOwnership();\n    }\n\n    // --- Getters for public variables. Required by IPool interface ---\n\n    function getETH() external view override returns (uint) {\n        return ETH;\n    }\n\n    function getTotalLUSDDeposits() external view override returns (uint) {\n        return totalLUSDDeposits;\n    }\n\n    // --- External Depositor Functions ---\n\n    /*  provideToSP():\n    *\n    * - Triggers a LQTY issuance, based on time passed since the last. The LQTY issuance is shared between *all* depositors and front ends\n    * - Tags the deposit with the provided front end tag param, if it's a new deposit\n    * - Sends depositor's accumulated gains (LQTY, ETH) to depositor\n    * - Sends the tagged front end's accumulated LQTY gains to the tagged front end\n    * - Increases deposit and tagged front end's stake, and takes new snapshots for each.\n    */\n    function provideToSP(uint _amount, address _frontEndTag) external override {\n        _requireFrontEndIsRegisteredOrZero(_frontEndTag);\n        _requireFrontEndNotRegistered(msg.sender);\n        _requireNonZeroAmount(_amount);\n\n        uint initialDeposit = deposits[msg.sender].initialValue;\n\n        _triggerLQTYIssuance();\n\n        if (initialDeposit == 0) {_setFrontEndTag(msg.sender, _frontEndTag);}\n        uint depositorETHGain = getDepositorETHGain(msg.sender);\n        uint compoundedLUSDDeposit = getCompoundedLUSDDeposit(msg.sender);\n        uint LUSDLoss = initialDeposit.sub(compoundedLUSDDeposit); // Needed only for event log\n\n        // First pay out any LQTY gains\n        address frontEnd = deposits[msg.sender].frontEndTag;\n        _payOutLQTYGains(msg.sender, frontEnd);\n\n        // Update front end stake\n        uint compoundedFrontEndStake = getCompoundedFrontEndStake(frontEnd);\n        uint newFrontEndStake = compoundedFrontEndStake.add(_amount);\n        _updateFrontEndStakeAndSnapshots(frontEnd, newFrontEndStake);\n        emit FrontEndStakeChanged(frontEnd, newFrontEndStake, msg.sender);\n\n        _sendLUSDtoStabilityPool(msg.sender, _amount);\n\n        uint newDeposit = compoundedLUSDDeposit.add(_amount);\n        _updateDepositAndSnapshots(msg.sender, newDeposit);\n        emit UserDepositChanged(msg.sender, newDeposit);\n\n        emit ETHGainWithdrawn(msg.sender, depositorETHGain, LUSDLoss); // LUSD Loss required for event log\n\n        _sendETHGainToDepositor(depositorETHGain);\n     }\n\n    /*  withdrawFromSP():\n    *\n    * - Triggers a LQTY issuance, based on time passed since the last. The LQTY issuance is shared between *all* depositors and front ends\n    * - Removes the deposit's front end tag if it is a full withdrawal\n    * - Sends all depositor's accumulated gains (LQTY, ETH) to depositor\n    * - Sends the tagged front end's accumulated LQTY gains to the tagged front end\n    * - Decreases deposit and tagged front end's stake, and takes new snapshots for each.\n    *\n    * If _amount > userDeposit, the user withdraws all of their compounded deposit.\n    */\n    function withdrawFromSP(uint _amount) external override {\n        if (_amount !=0) {_requireNoUnderCollateralizedTroves();}\n        uint initialDeposit = deposits[msg.sender].initialValue;\n        _requireUserHasDeposit(initialDeposit);\n\n        _triggerLQTYIssuance();\n\n        uint depositorETHGain = getDepositorETHGain(msg.sender);\n\n        uint compoundedLUSDDeposit = getCompoundedLUSDDeposit(msg.sender);\n        uint LUSDtoWithdraw = LiquityMath._min(_amount, compoundedLUSDDeposit);\n        uint LUSDLoss = initialDeposit.sub(compoundedLUSDDeposit); // Needed only for event log\n\n        // First pay out any LQTY gains\n        address frontEnd = deposits[msg.sender].frontEndTag;\n        _payOutLQTYGains(msg.sender, frontEnd);\n\n        // Update front end stake\n        uint compoundedFrontEndStake = getCompoundedFrontEndStake(frontEnd);\n        uint newFrontEndStake = compoundedFrontEndStake.sub(LUSDtoWithdraw);\n        _updateFrontEndStakeAndSnapshots(frontEnd, newFrontEndStake);\n        emit FrontEndStakeChanged(frontEnd, newFrontEndStake, msg.sender);\n\n        _sendLUSDToDepositor(msg.sender, LUSDtoWithdraw);\n\n        // Update deposit\n        uint newDeposit = compoundedLUSDDeposit.sub(LUSDtoWithdraw);\n        _updateDepositAndSnapshots(msg.sender, newDeposit);\n        emit UserDepositChanged(msg.sender, newDeposit);\n\n        emit ETHGainWithdrawn(msg.sender, depositorETHGain, LUSDLoss);  // LUSD Loss required for event log\n\n        _sendETHGainToDepositor(depositorETHGain);\n    }\n\n    /* withdrawETHGainToTrove:\n    * - Triggers a LQTY issuance, based on time passed since the last. The LQTY issuance is shared between *all* depositors and front ends\n    * - Sends all depositor's LQTY gain to  depositor\n    * - Sends all tagged front end's LQTY gain to the tagged front end\n    * - Transfers the depositor's entire ETH gain from the Stability Pool to the caller's trove\n    * - Leaves their compounded deposit in the Stability Pool\n    * - Updates snapshots for deposit and tagged front end stake */\n    function withdrawETHGainToTrove(address _upperHint, address _lowerHint) external override {\n        uint initialDeposit = deposits[msg.sender].initialValue;\n        _requireUserHasDeposit(initialDeposit);\n        _requireUserHasTrove(msg.sender);\n        _requireUserHasETHGain(msg.sender);\n\n        _triggerLQTYIssuance();\n\n        uint depositorETHGain = getDepositorETHGain(msg.sender);\n\n        uint compoundedLUSDDeposit = getCompoundedLUSDDeposit(msg.sender);\n        uint LUSDLoss = initialDeposit.sub(compoundedLUSDDeposit); // Needed only for event log\n\n        // First pay out any LQTY gains\n        address frontEnd = deposits[msg.sender].frontEndTag;\n        _payOutLQTYGains(msg.sender, frontEnd);\n\n        // Update front end stake\n        uint compoundedFrontEndStake = getCompoundedFrontEndStake(frontEnd);\n        uint newFrontEndStake = compoundedFrontEndStake;\n        _updateFrontEndStakeAndSnapshots(frontEnd, newFrontEndStake);\n        emit FrontEndStakeChanged(frontEnd, newFrontEndStake, msg.sender);\n\n        _updateDepositAndSnapshots(msg.sender, compoundedLUSDDeposit);\n\n        /* Emit events before transferring ETH gain to Trove.\n         This lets the event log make more sense (i.e. so it appears that first the ETH gain is withdrawn\n        and then it is deposited into the Trove, not the other way around). */\n        emit ETHGainWithdrawn(msg.sender, depositorETHGain, LUSDLoss);\n        emit UserDepositChanged(msg.sender, compoundedLUSDDeposit);\n\n        ETH = ETH.sub(depositorETHGain);\n        emit ETHBalanceUpdated(ETH);\n        emit EtherSent(msg.sender, depositorETHGain);\n\n        borrowerOperations.moveETHGainToTrove{ value: depositorETHGain }(msg.sender, _upperHint, _lowerHint);\n    }\n\n    // --- LQTY issuance functions ---\n\n    function _triggerLQTYIssuance() internal {\n        uint LQTYIssuance = communityIssuance.issueLQTY();\n       _updateG(LQTYIssuance);\n    }\n\n    function _updateG(uint _LQTYIssuance) internal {\n        uint totalLUSD = totalLUSDDeposits; // cached to save an SLOAD\n\n        /*\n        * When total deposits is 0, G is not updated. In this case, the LQTY issued can not be obtained by later\n        * depositors - it is missed out on, and remains in the balanceof the CommunityIssuance contract.\n        *\n        */\n        if (totalLUSD == 0 || _LQTYIssuance == 0) {return;}\n\n        uint LQTYPerUnitStaked;\n        LQTYPerUnitStaked =_computeLQTYPerUnitStaked(_LQTYIssuance, totalLUSD);\n\n        uint marginalLQTYGain = LQTYPerUnitStaked.mul(P);\n        epochToScaleToG[currentEpoch][currentScale] = epochToScaleToG[currentEpoch][currentScale].add(marginalLQTYGain);\n    }\n\n    function _computeLQTYPerUnitStaked(uint _LQTYIssuance, uint _totalLUSDDeposits) internal returns (uint) {\n        /*  \n        * Calculate the LQTY-per-unit staked.  Division uses a \"feedback\" error correction, to keep the \n        * cumulative error low in the running total G:\n        *\n        * 1) Form a numerator which compensates for the floor division error that occurred the last time this \n        * function was called.  \n        * 2) Calculate \"per-unit-staked\" ratio.\n        * 3) Multiply the ratio back by its denominator, to reveal the current floor division error.\n        * 4) Store this error for use in the next correction when this function is called.\n        * 5) Note: static analysis tools complain about this \"division before multiplication\", however, it is intended.\n        */\n        uint LQTYNumerator = _LQTYIssuance.mul(DECIMAL_PRECISION).add(lastLQTYError);\n\n        uint LQTYPerUnitStaked = LQTYNumerator.div(_totalLUSDDeposits);\n        lastLQTYError = LQTYNumerator.sub(LQTYPerUnitStaked.mul(_totalLUSDDeposits));\n\n        return LQTYPerUnitStaked;\n    }\n\n    // --- Liquidation functions ---\n\n    /*\n    * Cancel out the specified debt against the LUSD contained in the Stability Pool (as far as possible)\n    * and transfers the Trove's ETH collateral from ActivePool to StabilityPool.\n    * Only called by liquidation functions in the TroveManager.\n    */\n    function offset(uint _debtToOffset, uint _collToAdd) external override {\n        _requireCallerIsTroveManager();\n        uint totalLUSD = totalLUSDDeposits; // cached to save an SLOAD\n        if (totalLUSD == 0 || _debtToOffset == 0) { return; }\n\n        _triggerLQTYIssuance();\n\n        (uint ETHGainPerUnitStaked,\n            uint LUSDLossPerUnitStaked) = _computeRewardsPerUnitStaked(_collToAdd, _debtToOffset, totalLUSD);\n\n        _updateRewardSumAndProduct(ETHGainPerUnitStaked, LUSDLossPerUnitStaked);  // updates S and P\n\n        _moveOffsetCollAndDebt(_collToAdd, _debtToOffset);\n    }\n\n    // --- Offset helper functions ---\n\n    function _computeRewardsPerUnitStaked(\n        uint _collToAdd,\n        uint _debtToOffset,\n        uint _totalLUSDDeposits\n    )\n        internal\n        returns (uint ETHGainPerUnitStaked, uint LUSDLossPerUnitStaked)\n    {\n        /*\n        * Compute the LUSD and ETH rewards. Uses a \"feedback\" error correction, to keep\n        * the cumulative error in the P and S state variables low:\n        *\n        * 1) Form numerators which compensate for the floor division errors that occurred the last time this \n        * function was called.  \n        * 2) Calculate \"per-unit-staked\" ratios.\n        * 3) Multiply each ratio back by its denominator, to reveal the current floor division error.\n        * 4) Store these errors for use in the next correction when this function is called.\n        * 5) Note: static analysis tools complain about this \"division before multiplication\", however, it is intended.\n        */\n        uint LUSDLossNumerator = _debtToOffset.mul(DECIMAL_PRECISION).sub(lastLUSDLossError_Offset);\n        uint ETHNumerator = _collToAdd.mul(DECIMAL_PRECISION).add(lastETHError_Offset);\n\n\n        if (_debtToOffset >= _totalLUSDDeposits) {\n            LUSDLossPerUnitStaked = DECIMAL_PRECISION;\n            lastLUSDLossError_Offset = 0;\n        } else {\n            /*\n            * Add 1 to make error in quotient positive. We want \"slightly too much\" LUSD loss,\n            * which ensures the error in any given compoundedLUSDDeposit favors the Stability Pool.\n            */\n            LUSDLossPerUnitStaked = (LUSDLossNumerator.div(_totalLUSDDeposits)).add(1);\n            // SWC-101-Integer Overflow and Underflow: L504\n            lastLUSDLossError_Offset = (LUSDLossPerUnitStaked.mul(_totalLUSDDeposits)).sub(LUSDLossNumerator);\n        }\n\n        ETHGainPerUnitStaked = ETHNumerator.div(_totalLUSDDeposits);\n        lastETHError_Offset = ETHNumerator.sub(ETHGainPerUnitStaked.mul(_totalLUSDDeposits));\n\n        return (ETHGainPerUnitStaked, LUSDLossPerUnitStaked);\n    }\n\n    // Update the Stability Pool reward sum S and product P\n    function _updateRewardSumAndProduct(uint _ETHGainPerUnitStaked, uint _LUSDLossPerUnitStaked) internal {\n        uint currentP = P;\n        uint newP;\n\n        assert(_LUSDLossPerUnitStaked <= DECIMAL_PRECISION);\n        /*\n        * The newProductFactor is the factor by which to change all deposits, due to the depletion of Stability Pool LUSD in the liquidation.\n        * We make the product factor 0 if there was a pool-emptying. Otherwise, it is (1 - LUSDLossPerUnitStaked)\n        */\n        uint newProductFactor = _LUSDLossPerUnitStaked >= DECIMAL_PRECISION ? 0 : uint(DECIMAL_PRECISION).sub(_LUSDLossPerUnitStaked);\n\n        uint128 currentScaleCached = currentScale;\n        uint128 currentEpochCached = currentEpoch;\n        uint currentS = epochToScaleToSum[currentEpochCached][currentScaleCached];\n\n        /*\n        * Calculate the new S first, before we update P.\n        * The ETH gain for any given depositor from a liquidation depends on the value of their deposit\n        * (and the value of totalDeposits) prior to the Stability being depleted by the debt in the liquidation.\n        *\n        * Since S corresponds to ETH gain, and P to deposit loss, we update S first.\n        */\n        uint marginalETHGain = _ETHGainPerUnitStaked.mul(currentP);\n        uint newS = currentS.add(marginalETHGain);\n        epochToScaleToSum[currentEpochCached][currentScaleCached] = newS;\n        emit S_Updated(newS);\n\n        // If the Stability Pool was emptied, increment the epoch, and reset the scale and product P\n        if (newProductFactor == 0) {\n            currentEpoch = currentEpochCached.add(1);\n            currentScale = 0;\n            newP = DECIMAL_PRECISION;\n\n        // If multiplying P by a non-zero product factor would round P to zero, increment the scale\n        } else if (currentP.mul(newProductFactor) < DECIMAL_PRECISION) {\n            newP = currentP.mul(newProductFactor);\n            currentScale = currentScaleCached.add(1);\n        } else {\n            newP = currentP.mul(newProductFactor).div(DECIMAL_PRECISION);\n        }\n\n        P = newP;\n        emit P_Updated(newP);\n    }\n\n    function _moveOffsetCollAndDebt(uint _collToAdd, uint _debtToOffset) internal {\n        // Cancel the liquidated LUSD debt with the LUSD in the stability pool\n        activePool.decreaseLUSDDebt(_debtToOffset);\n        _decreaseLUSD(_debtToOffset);\n\n        // Burn the debt that was successfully offset\n        lusdToken.burn(address(this), _debtToOffset);\n\n        activePool.sendETH(address(this), _collToAdd);\n    }\n\n    function _decreaseLUSD(uint _amount) internal {\n        uint newTotalLUSDDeposits = totalLUSDDeposits.sub(_amount);\n        totalLUSDDeposits = newTotalLUSDDeposits;\n        emit LUSDBalanceUpdated(newTotalLUSDDeposits);\n    }\n\n    // --- Reward calculator functions for depositor and front end ---\n\n    /* Calculates the ETH gain earned by the deposit since its last snapshots were taken.\n    * Given by the formula:  E = d0 * (S - S(0))/P(0)\n    * where S(0) and P(0) are the depositor's snapshots of the sum S and product P, respectively.\n    * d0 is the last recorded deposit value.\n    */\n    function getDepositorETHGain(address _depositor) public view override returns (uint) {\n        uint initialDeposit = deposits[_depositor].initialValue;\n\n        if (initialDeposit == 0) { return 0; }\n\n        Snapshots memory snapshots = depositSnapshots[_depositor];\n\n        uint ETHGain = _getETHGainFromSnapshots(initialDeposit, snapshots);\n        return ETHGain;\n    }\n\n    function _getETHGainFromSnapshots(uint initialDeposit, Snapshots memory snapshots) internal view returns (uint) {\n        /*\n        * Grab the sum 'S' from the epoch at which the stake was made. The ETH gain may span up to one scale change.\n        * If it does, the second portion of the ETH gain is scaled by 1e18.\n        * If the gain spans no scale change, the second portion will be 0.\n        */\n        uint128 epochSnapshot = snapshots.epoch;\n        uint128 scaleSnapshot = snapshots.scale;\n        uint S_Snapshot = snapshots.S;\n        uint P_Snapshot = snapshots.P;\n\n        uint firstPortion = epochToScaleToSum[epochSnapshot][scaleSnapshot].sub(S_Snapshot);\n        uint secondPortion = epochToScaleToSum[epochSnapshot][scaleSnapshot.add(1)].div(DECIMAL_PRECISION);\n\n        uint ETHGain = initialDeposit.mul(firstPortion.add(secondPortion)).div(P_Snapshot).div(DECIMAL_PRECISION);\n\n        return ETHGain;\n    }\n\n    /*\n    * Calculate the LQTY gain earned by a deposit since its last snapshots were taken.\n    * Given by the formula:  LQTY = d0 * (G - G(0))/P(0)\n    * where G(0) and P(0) are the depositor's snapshots of the sum G and product P, respectively.\n    * d0 is the last recorded deposit value.\n    */\n    function getDepositorLQTYGain(address _depositor) public view override returns (uint) {\n        uint initialDeposit = deposits[_depositor].initialValue;\n        if (initialDeposit == 0) {return 0;}\n\n        address frontEndTag = deposits[_depositor].frontEndTag;\n\n        /*\n        * If not tagged with a front end, the depositor gets a 100% cut of what their deposit earned.\n        * Otherwise, their cut of the deposit's earnings is equal to the kickbackRate, set by the front end through\n        * which they made their deposit.\n        */\n        uint kickbackRate = frontEndTag == address(0) ? DECIMAL_PRECISION : frontEnds[frontEndTag].kickbackRate;\n\n        Snapshots memory snapshots = depositSnapshots[_depositor];\n\n        uint LQTYGain = kickbackRate.mul(_getLQTYGainFromSnapshots(initialDeposit, snapshots)).div(DECIMAL_PRECISION);\n\n        return LQTYGain;\n    }\n\n    /*\n    * Return the LQTY gain earned by the front end. Given by the formula:  E = D0 * (G - G(0))/P(0)\n    * where G(0) and P(0) are the depositor's snapshots of the sum G and product P, respectively.\n    *\n    * D0 is the last recorded value of the front end's total tagged deposits.\n    */\n    function getFrontEndLQTYGain(address _frontEnd) public view override returns (uint) {\n        uint frontEndStake = frontEndStakes[_frontEnd];\n        if (frontEndStake == 0) { return 0; }\n\n        uint kickbackRate = frontEnds[_frontEnd].kickbackRate;\n        uint frontEndShare = uint(DECIMAL_PRECISION).sub(kickbackRate);\n\n        Snapshots memory snapshots = frontEndSnapshots[_frontEnd];\n\n        uint LQTYGain = frontEndShare.mul(_getLQTYGainFromSnapshots(frontEndStake, snapshots)).div(DECIMAL_PRECISION);\n        return LQTYGain;\n    }\n\n    function _getLQTYGainFromSnapshots(uint initialStake, Snapshots memory snapshots) internal view returns (uint) {\n       /*\n        * Grab the sum 'G' from the epoch at which the stake was made. The LQTY gain may span up to one scale change.\n        * If it does, the second portion of the LQTY gain is scaled by 1e18.\n        * If the gain spans no scale change, the second portion will be 0.\n        */\n        uint128 epochSnapshot = snapshots.epoch;\n        uint128 scaleSnapshot = snapshots.scale;\n        uint G_Snapshot = snapshots.G;\n        uint P_Snapshot = snapshots.P;\n\n        uint firstPortion = epochToScaleToG[epochSnapshot][scaleSnapshot].sub(G_Snapshot);\n        uint secondPortion = epochToScaleToG[epochSnapshot][scaleSnapshot.add(1)].div(DECIMAL_PRECISION);\n\n        uint LQTYGain = initialStake.mul(firstPortion.add(secondPortion)).div(P_Snapshot).div(DECIMAL_PRECISION);\n\n        return LQTYGain;\n    }\n\n    // --- Compounded deposit and compounded front end stake ---\n\n    /*\n    * Return the user's compounded deposit. Given by the formula:  d = d0 * P/P(0)\n    * where P(0) is the depositor's snapshot of the product P, taken when they last updated their deposit.\n    */\n    function getCompoundedLUSDDeposit(address _depositor) public view override returns (uint) {\n        uint initialDeposit = deposits[_depositor].initialValue;\n        if (initialDeposit == 0) { return 0; }\n\n        Snapshots memory snapshots = depositSnapshots[_depositor];\n\n        uint compoundedDeposit = _getCompoundedStakeFromSnapshots(initialDeposit, snapshots);\n        return compoundedDeposit;\n    }\n\n    /*\n    * Return the front end's compounded stake. Given by the formula:  D = D0 * P/P(0)\n    * where P(0) is the depositor's snapshot of the product P, taken at the last time\n    * when one of the front end's tagged deposits updated their deposit.\n    *\n    * The front end's compounded stake is equal to the sum of its depositors' compounded deposits.\n    */\n    function getCompoundedFrontEndStake(address _frontEnd) public view override returns (uint) {\n        uint frontEndStake = frontEndStakes[_frontEnd];\n        if (frontEndStake == 0) { return 0; }\n\n        Snapshots memory snapshots = frontEndSnapshots[_frontEnd];\n\n        uint compoundedFrontEndStake = _getCompoundedStakeFromSnapshots(frontEndStake, snapshots);\n        return compoundedFrontEndStake;\n    }\n\n    // Internal function, used to calculcate compounded deposits and compounded front end stakes.\n    function _getCompoundedStakeFromSnapshots(\n        uint initialStake,\n        Snapshots memory snapshots\n    )\n        internal\n        view\n        returns (uint)\n    {\n        uint snapshot_P = snapshots.P;\n        uint128 scaleSnapshot = snapshots.scale;\n        uint128 epochSnapshot = snapshots.epoch;\n\n        // If stake was made before a pool-emptying event, then it has been fully cancelled with debt -- so, return 0\n        if (epochSnapshot < currentEpoch) { return 0; }\n\n        uint compoundedStake;\n        uint128 scaleDiff = currentScale.sub(scaleSnapshot);\n\n        /* Compute the compounded stake. If a scale change in P was made during the stake's lifetime,\n        * account for it. If more than one scale change was made, then the stake has decreased by a factor of\n        * at least 1e-18 -- so return 0.\n        */\n        if (scaleDiff == 0) {\n            compoundedStake = initialStake.mul(P).div(snapshot_P);\n        } else if (scaleDiff == 1) {\n            compoundedStake = initialStake.mul(P).div(snapshot_P).div(DECIMAL_PRECISION);\n        } else {\n            compoundedStake = 0;\n        }\n\n        /*\n        * If compounded deposit is less than a billionth of the initial deposit, return 0.\n        *\n        * NOTE: originally, this line was in place to stop rounding errors making the deposit too large. However, the error\n        * corrections should ensure the error in P \"favors the Pool\", i.e. any given compounded deposit should slightly less\n        * than it's theoretical value.\n        *\n        * Thus it's unclear whether this line is still really needed.\n        */\n        if (compoundedStake < initialStake.div(1e9)) {return 0;}\n\n        return compoundedStake;\n    }\n\n    // --- Sender functions for LUSD deposit, ETH gains and LQTY gains ---\n\n    // Transfer the LUSD tokens from the user to the Stability Pool's address, and update its recorded LUSD\n    function _sendLUSDtoStabilityPool(address _address, uint _amount) internal {\n        lusdToken.sendToPool(_address, address(this), _amount);\n        uint newTotalLUSDDeposits = totalLUSDDeposits.add(_amount);\n        totalLUSDDeposits = newTotalLUSDDeposits;\n        emit LUSDBalanceUpdated(newTotalLUSDDeposits);\n    }\n\n    function _sendETHGainToDepositor(uint _amount) internal {\n        if (_amount == 0) {return;}\n        uint newETH = ETH.sub(_amount);\n        ETH = newETH;\n        emit ETHBalanceUpdated(newETH);\n        emit EtherSent(msg.sender, _amount);\n\n        (bool success, ) = msg.sender.call{ value: _amount }(\"\");\n        require(success, \"StabilityPool: sending ETH failed\");\n    }\n\n    // Send LUSD to user and decrease LUSD in Pool\n    function _sendLUSDToDepositor(address _depositor, uint LUSDWithdrawal) internal {\n        if (LUSDWithdrawal == 0) {return;}\n\n        lusdToken.returnFromPool(address(this), _depositor, LUSDWithdrawal);\n        _decreaseLUSD(LUSDWithdrawal);\n    }\n\n    // --- External Front End functions ---\n\n    // Front end makes a one-time selection of kickback rate upon registering\n    function registerFrontEnd(uint _kickbackRate) external override {\n        _requireFrontEndNotRegistered(msg.sender);\n        _requireUserHasNoDeposit(msg.sender);\n        _requireValidKickbackRate(_kickbackRate);\n\n        frontEnds[msg.sender].kickbackRate = _kickbackRate;\n        frontEnds[msg.sender].registered = true;\n\n        emit FrontEndRegistered(msg.sender, _kickbackRate);\n    }\n\n    // --- Stability Pool Deposit Functionality ---\n\n    function _setFrontEndTag(address _depositor, address _frontEndTag) internal {\n        deposits[_depositor].frontEndTag = _frontEndTag;\n    }\n\n\n    function _updateDepositAndSnapshots(address _depositor, uint _newValue) internal {\n        deposits[_depositor].initialValue = _newValue;\n\n        if (_newValue == 0) {\n            delete deposits[_depositor].frontEndTag;\n            delete depositSnapshots[_depositor];\n            emit DepositSnapshotUpdated(_depositor, 0, 0, 0);\n            return;\n        }\n        uint128 currentScaleCached = currentScale;\n        uint128 currentEpochCached = currentEpoch;\n        uint currentP = P;\n\n        // Get S and G for the current epoch and current scale\n        uint currentS = epochToScaleToSum[currentEpochCached][currentScaleCached];\n        uint currentG = epochToScaleToG[currentEpochCached][currentScaleCached];\n\n        // Record new snapshots of the latest running product P, sum S, and sum G, for the depositor\n        depositSnapshots[_depositor].P = currentP;\n        depositSnapshots[_depositor].S = currentS;\n        depositSnapshots[_depositor].G = currentG;\n        depositSnapshots[_depositor].scale = currentScaleCached;\n        depositSnapshots[_depositor].epoch = currentEpochCached;\n\n        emit DepositSnapshotUpdated(_depositor, currentP, currentS, currentG);\n    }\n\n    function _updateFrontEndStakeAndSnapshots(address _frontEnd, uint _newValue) internal {\n        frontEndStakes[_frontEnd] = _newValue;\n\n        if (_newValue == 0) {\n            delete frontEndSnapshots[_frontEnd];\n            emit FrontEndSnapshotUpdated(_frontEnd, 0, 0);\n            return;\n        }\n\n        uint128 currentScaleCached = currentScale;\n        uint128 currentEpochCached = currentEpoch;\n        uint currentP = P;\n\n        // Get G for the current epoch and current scale\n        uint currentG = epochToScaleToG[currentEpochCached][currentScaleCached];\n\n        // Record new snapshots of the latest running product P and sum G for the front end\n        frontEndSnapshots[_frontEnd].P = currentP;\n        frontEndSnapshots[_frontEnd].G = currentG;\n        frontEndSnapshots[_frontEnd].scale = currentScaleCached;\n        frontEndSnapshots[_frontEnd].epoch = currentEpochCached;\n\n        emit FrontEndSnapshotUpdated(_frontEnd, currentP, currentG);\n    }\n\n    function _payOutLQTYGains(address _depositor, address _frontEnd) internal {\n        // Pay out front end's LQTY gain\n        if (_frontEnd != address(0)) {\n            uint frontEndLQTYGain = getFrontEndLQTYGain(_frontEnd);\n            communityIssuance.sendLQTY(_frontEnd, frontEndLQTYGain);\n            emit LQTYPaidToFrontEnd(_frontEnd, frontEndLQTYGain);\n        }\n\n        // Pay out depositor's LQTY gain\n        uint depositorLQTYGain = getDepositorLQTYGain(_depositor);\n        communityIssuance.sendLQTY(_depositor, depositorLQTYGain);\n        emit LQTYPaidToDepositor(_depositor, depositorLQTYGain);\n    }\n\n    // --- 'require' functions ---\n\n    function _requireCallerIsActivePool() internal view {\n        require( msg.sender == address(activePool), \"StabilityPool: Caller is not ActivePool\");\n    }\n\n    function _requireCallerIsTroveManager() internal view {\n        require(msg.sender == address(troveManager), \"StabilityPool: Caller is not TroveManager\");\n    }\n\n    function _requireNoUnderCollateralizedTroves() internal {\n        uint price = priceFeed.fetchPrice();\n        address lowestTrove = sortedTroves.getLast();\n        uint ICR = troveManager.getCurrentICR(lowestTrove, price);\n        require(ICR >= MCR, \"StabilityPool: Cannot withdraw while there are troves with ICR < MCR\");\n    }\n\n    function _requireUserHasDeposit(uint _initialDeposit) internal pure {\n        require(_initialDeposit > 0, 'StabilityPool: User must have a non-zero deposit');\n    }\n\n     function _requireUserHasNoDeposit(address _address) internal view {\n        uint initialDeposit = deposits[_address].initialValue;\n        require(initialDeposit == 0, 'StabilityPool: User must have no deposit');\n    }\n\n    function _requireNonZeroAmount(uint _amount) internal pure {\n        require(_amount > 0, 'StabilityPool: Amount must be non-zero');\n    }\n\n    function _requireUserHasTrove(address _depositor) internal view {\n        require(troveManager.getTroveStatus(_depositor) == 1, \"StabilityPool: caller must have an active trove to withdraw ETHGain to\");\n    }\n\n    function _requireUserHasETHGain(address _depositor) internal view {\n        uint ETHGain = getDepositorETHGain(_depositor);\n        require(ETHGain > 0, \"StabilityPool: caller must have non-zero ETH Gain\");\n    }\n\n    function _requireFrontEndNotRegistered(address _address) internal view {\n        require(!frontEnds[_address].registered, \"StabilityPool: must not already be a registered front end\");\n    }\n\n     function _requireFrontEndIsRegisteredOrZero(address _address) internal view {\n        require(frontEnds[_address].registered || _address == address(0),\n            \"StabilityPool: Tag must be a registered front end, or the zero address\");\n    }\n\n    function  _requireValidKickbackRate(uint _kickbackRate) internal pure {\n        require (_kickbackRate <= DECIMAL_PRECISION, \"StabilityPool: Kickback rate must be in range [0,1]\");\n    }\n\n    // --- Fallback function ---\n\n    receive() external payable {\n        _requireCallerIsActivePool();\n        ETH = ETH.add(msg.value);\n    }\n}",
        "function": "getEntireSystemColl()",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-LiquityProtocolandStabilityPoolFinalReport/dev-8cec3fda04b8c71994dc14858386bf6a161164fc/packages/contracts/contracts/StabilityPool.sol",
        "vulnerability": "Multiple Calls in a Single Transaction (SWC 113)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract BlockhashRegistry {\n\n    \n    event LogBlockhashAdded(uint indexed blockNr, bytes32 indexed bhash);\n\n    \n    mapping(uint => bytes32) public blockhashMapping;\n\n    \n    \n    constructor() public {\n        snapshot();\n    }\n\n    \n    \n    \n    \n    function searchForAvailableBlock(uint _startNumber, uint _numBlocks) external view returns (uint) {\n\n        for (uint i = _startNumber; i <= (_numBlocks + _startNumber); i++) {\n            if (blockhashMapping[i] != 0x0) {\n                return i;\n            }\n        }\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    function recreateBlockheaders(uint _blockNumber, bytes[] memory _blockheaders) public {\n\n        bytes32 currentBlockhash = blockhashMapping[_blockNumber];\n        require(currentBlockhash != 0x0, \"parentBlock is not available\");\n\n        bytes32 calculatedHash = reCalculateBlockheaders(_blockheaders, currentBlockhash);\n        require(calculatedHash != 0x0, \"invalid headers\");\n\n        \n        assert(_blockNumber > _blockheaders.length);\n        uint bnr = _blockNumber - _blockheaders.length;\n        blockhashMapping[bnr] = calculatedHash;\n        emit LogBlockhashAdded(bnr, calculatedHash);\n    }\n\n    \n    \n    \n    function saveBlockNumber(uint _blockNumber) public {\n\n        bytes32 bHash = blockhash(_blockNumber);\n\n        require(bHash != 0x0, \"block not available\");\n\n        blockhashMapping[_blockNumber] = bHash;\n        emit LogBlockhashAdded(_blockNumber, bHash);\n    }\n\n    \n    function snapshot() public {\n        \n        saveBlockNumber(block.number-1);\n    }\n\n    \n    \n    \n    function getParentAndBlockhash(bytes memory _blockheader) public pure returns (bytes32 parentHash, bytes32 bhash) {\n\n        \n        uint8 first = uint8(_blockheader[0]);\n\n        \n        \n        \n        require(first > 0xf7, \"invalid offset\");\n        uint8 offset = first - 0xf7 + 2;\n\n        \n        // solium-disable-next-line security/no-inline-assembly\n        assembly { // solhint-disable-line no-inline-assembly\n            // mstore to get the memory pointer of the blockheader to 0x20\n            mstore(0x20, _blockheader)\n\n            // we load the pointer we just stored\n            // then we add 0x20 (32 bytes) to get to the start of the blockheader\n            // then we add the offset we calculated\n            // and load it to the parentHash variable\n            parentHash :=mload(\n                add(\n                    add(\n                        mload(0x20), 0x20\n                    ), offset)\n            )\n        }\n        bhash = keccak256(_blockheader);\n    }\n\n    \n    \n    \n    \n    \n    function reCalculateBlockheaders(bytes[] memory _blockheaders, bytes32 _bHash) public pure returns (bytes32 bhash) {\n\n        bytes32 currentBlockhash = _bHash;\n        bytes32 calcParent = 0x0;\n        bytes32 calcBlockhash = 0x0;\n\n        \n        for (uint i = 0; i < _blockheaders.length; i++) {\n            (calcParent, calcBlockhash) = getParentAndBlockhash(_blockheaders[i]);\n            if (calcBlockhash != currentBlockhash) {\n                return 0x0;\n            }\n            currentBlockhash = calcParent;\n        }\n\n        return currentBlockhash;\n    }\n}",
        "function": "constructor",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/consensys-Slockit_Incubed3/in3-contracts-e25c758a115aef0c0640bc446027259aa7cb1a52/contracts/NodeRegistry.sol",
        "vulnerability": "Dependence on predictable environment variable (SWC 120)",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract CDEXStakingPool is ReentrancyGuard, Pausable {\n    using SafeMath for uint256;\n\n    // STATE VARIABLES\n    CDEXTokenContract public CDEXToken;\n    CDEXRankingContract public CDEXRanking;\n    uint256 public periodFinish = 0;\n    uint256 public rewardRate = 0;\n    uint256 public rewardsDuration = 0;\n    uint256 public lastUpdateTime;\n    uint256 public rewardPerTokenStored;\n    \n    \n    uint256 public loyaltyTier1 = 100000000 * 1e8;\n    uint256 public loyaltyTier2 = 10000000 * 1e8;\n    uint256 public loyaltyTier3 = 1000000 * 1e8;\n    \n    \n    uint256 public loyaltyTier1Bonus = 125;\n    uint256 public loyaltyTier2Bonus = 100;\n    uint256 public loyaltyTier3Bonus = 50;\n    uint256 public loyaltyBonusTotal = 275;\n    uint256 public depositedLoyaltyBonus;\n\n    mapping(address => uint256) public userRewardPerTokenPaid;\n    mapping(address => uint256) public rewards;\n    uint256 public depositedRewardTokens;\n\n    uint256 private _totalSupply;\n    mapping(address => uint256) private _balances;\n\n    uint256 public totalMembers;\n\n    \n    \n    \n    \n    \n    function CDEXStakingPool(\n        address _owner,\n        address _CDEXTokenContractAddress,\n        address _rankingContractAddress\n    ) public Owned(_owner) {\n        CDEXToken = CDEXTokenContract(_CDEXTokenContractAddress);\n        CDEXRanking = CDEXRankingContract(_rankingContractAddress);\n    }\n\n    \n    \n    \n    \n    function totalSupply() external view returns (uint256) {\n        return _totalSupply;\n    }\n\n    \n    \n    \n    function balanceOf(address account) external view returns (uint256) {\n        return _balances[account];\n    }\n\n    \n    \n    \n    function lastTimeRewardApplicable() public view returns (uint256) {\n        return min(block.timestamp, periodFinish);\n    }\n\n    \n    function rewardPerToken() public view returns (uint256) {\n        if (_totalSupply == 0) {\n            return rewardPerTokenStored;\n        }\n        return\n            rewardPerTokenStored.add(\n                lastTimeRewardApplicable()\n                    .sub(lastUpdateTime)\n                    .mul(rewardRate)\n                    .mul(1e8)\n                    .div(_totalSupply)\n            );\n    }\n\n    \n    \n    function earned(address account) public view returns (uint256) {\n        return\n            _balances[account]\n                .mul(rewardPerToken().sub(userRewardPerTokenPaid[account]))\n                .div(1e8)\n                .add(rewards[account]);\n    }\n\n    \n    function getRewardForDuration() external view returns (uint256) {\n        return rewardRate.mul(rewardsDuration);\n    }\n\n    \n    \n    \n    function min(uint256 a, uint256 b) public pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    \n    \n    function getLoyaltyTiers() external view returns(uint256 tier1, uint256 tier2, uint256 tier3)\n    {\n        return(loyaltyTier1, loyaltyTier2, loyaltyTier3);\n    }\n\n    \n    \n    \n    function getLoyaltyTiersBonus() external view returns(uint256 tier1Bonus, uint256 tier2Bonus, uint256 tier3Bonus)\n    {\n        return(loyaltyTier1Bonus, loyaltyTier2Bonus, loyaltyTier3Bonus);\n    }\n\n    // PUBLIC FUNCTIONS\n\n    \n    \n    // SWC-104-Unchecked Call Return Value: L362 - L391\n    function stake(uint256 amount)\n        external\n        nonReentrant\n        notPaused\n        updateReward(msg.sender)\n    {\n        require(amount > 0);\n        \n        _totalSupply = _totalSupply.add(amount);\n        \n        if(_balances[msg.sender] == 0) {\n            \n            totalMembers += 1;\n            \n            CDEXRanking.insert(amount, msg.sender);\n        } else {\n            \n            CDEXRanking.remove(_balances[msg.sender], msg.sender);\n            \n            CDEXRanking.insert(_balances[msg.sender].add(amount), msg.sender);\n        }\n        \n        _balances[msg.sender] = _balances[msg.sender].add(amount);\n        \n        \n        CDEXToken.transferFrom(msg.sender, address(this), amount);\n        \n        emit Staked(msg.sender, amount);\n    }\n\n    \n    \n    // SWC-104-Unchecked Call Return Value: L395 - L420\n    function withdraw(uint256 amount)\n        public\n        nonReentrant\n        updateReward(msg.sender)\n    {\n        require(amount > 0);\n        \n        _totalSupply = _totalSupply.sub(amount);\n        \n        CDEXRanking.remove(_balances[msg.sender], msg.sender);\n        \n        _balances[msg.sender] = _balances[msg.sender].sub(amount);\n        \n        if(_balances[msg.sender] == 0) {\n            totalMembers -= 1;\n        } else {\n            \n            CDEXRanking.insert(_balances[msg.sender], msg.sender);\n        }\n        \n        // SWC-104-Unchecked Call Return Value: L415\n        CDEXToken.transfer(msg.sender, amount);\n        \n        emit Withdrawn(msg.sender, amount);\n    }\n    \n    \n    // SWC-104-Unchecked Call Return Value: L424 - L456\n    function getReward() \n        public \n        nonReentrant \n        updateReward(msg.sender) \n    {\n        uint256 reward = rewards[msg.sender];\n        uint256 loyaltyBonus;\n        \n        if (reward > 0 && depositedRewardTokens >= reward) {\n            \n            rewards[msg.sender] = 0;\n            \n            depositedRewardTokens = depositedRewardTokens.sub(reward);\n            \n            if (_balances[msg.sender] >= loyaltyTier1) {\n                loyaltyBonus = reward.mul(loyaltyTier1Bonus).div(10000);\n            } else if (_balances[msg.sender] >= loyaltyTier2) {\n                loyaltyBonus = reward.mul(loyaltyTier2Bonus).div(10000);\n            } else if (_balances[msg.sender] >= loyaltyTier3) {\n                loyaltyBonus = reward.mul(loyaltyTier3Bonus).div(10000);\n            }\n            \n            depositedLoyaltyBonus = depositedLoyaltyBonus.sub(loyaltyBonus);\n            \n            CDEXToken.transfer(msg.sender, reward.add(loyaltyBonus));\n            \n            emit RewardPaid(msg.sender, reward);\n            \n            if(loyaltyBonus > 0) {\n                emit LoyaltyBonusPaid(msg.sender, loyaltyBonus);\n            }\n        }\n    }\n\n    \n    function exit() external {\n        withdraw(_balances[msg.sender]);\n        getReward();\n    }\n    \n    // RESTRICTED FUNCTIONS\n    \n    \n    \n    \n    function setTokenContract(address _contractAddress) public onlyOwner {\n        CDEXToken = CDEXTokenContract(_contractAddress);\n    }\n    \n    \n    \n    \n    function setRankingContract(address _contractAddress) public onlyOwner {\n        CDEXRanking = CDEXRankingContract(_contractAddress);\n    }\n    \n    \n    \n    \n    \n    \n    \n    // SWC-104-Unchecked Call Return Value: L486 - L498\n    function depositTokens(uint256 amount) public onlyOwner {\n        \n        amount = amount.mul(1e8);\n        \n        depositedLoyaltyBonus = depositedLoyaltyBonus.add(amount.mul(loyaltyBonusTotal).div(10000));\n        \n        depositedRewardTokens = depositedRewardTokens.add(amount);\n        \n        CDEXToken.transferFrom(owner, address(this), amount);\n        \n        emit RewardsDeposited(owner, address(this), amount);\n    }\n\n    \n    \n    \n    \n    function notifyRewardAmount(uint256 reward)\n        public\n        onlyOwner\n        updateReward(address(0))\n    {\n        \n        reward = reward.mul(1e8);\n        \n        \n        require(reward <= depositedRewardTokens.sub(reward.mul(loyaltyBonusTotal).div(10000)));\n        \n        \n        if (block.timestamp >= periodFinish) {\n            rewardRate = reward.div(rewardsDuration);\n        } else {\n            uint256 remaining = periodFinish.sub(block.timestamp);\n            uint256 leftover = remaining.mul(rewardRate);\n            rewardRate = reward.add(leftover).div(rewardsDuration);\n        }\n        \n        \n        \n        \n        require(rewardRate <= depositedRewardTokens.div(rewardsDuration));\n        \n        lastUpdateTime = block.timestamp;\n        \n        periodFinish = block.timestamp.add(rewardsDuration);\n        \n        emit RewardAdded(reward);\n    }\n\n    \n    \n    \n    function setRewardsDuration(uint256 _rewardsDuration) external onlyOwner {\n        \n        require(block.timestamp > periodFinish);\n        \n        rewardsDuration = _rewardsDuration;\n        \n        emit RewardsDurationUpdated(rewardsDuration);\n    }\n\n    \n    \n    \n    \n    function setLoyaltyTiers(\n        uint256 _loyaltyTier1, \n        uint256 _loyaltyTier2, \n        uint256 _loyaltyTier3\n    ) external onlyOwner \n    {\n        \n        loyaltyTier1 = _loyaltyTier1.mul(1e8);\n        loyaltyTier2 = _loyaltyTier2.mul(1e8);\n        loyaltyTier3 = _loyaltyTier3.mul(1e8);\n        \n        emit LoyaltyTiersUpdated(loyaltyTier1, loyaltyTier2, loyaltyTier3);\n    }\n\n    \n    \n    \n    \n    \n    \n    function setLoyaltyTiersBonus(\n        uint256 _loyaltyTier1Bonus, \n        uint256 _loyaltyTier2Bonus, \n        uint256 _loyaltyTier3Bonus\n    ) external onlyOwner \n    {\n        \n        \n        require(_loyaltyTier1Bonus.add(_loyaltyTier2Bonus).add(_loyaltyTier3Bonus) < 10000);\n        \n        loyaltyTier1Bonus = _loyaltyTier1Bonus;\n        loyaltyTier2Bonus = _loyaltyTier2Bonus;\n        loyaltyTier3Bonus = _loyaltyTier3Bonus;\n        \n        loyaltyBonusTotal = loyaltyTier1Bonus.add(loyaltyTier2Bonus).add(loyaltyTier3Bonus);\n        \n        emit LoyaltyTiersBonussUpdated(loyaltyTier1Bonus, loyaltyTier2Bonus, loyaltyTier3Bonus);\n    }\n\n    // MODIFIERS\n    \n    \n    \n    modifier updateReward(address account) {\n        rewardPerTokenStored = rewardPerToken();\n        lastUpdateTime = lastTimeRewardApplicable();\n        if (account != address(0)) {\n            rewards[account] = earned(account);\n            userRewardPerTokenPaid[account] = rewardPerTokenStored;\n        }\n        _;\n    }\n\n    // EVENTS\n\n    event RewardAdded(uint256 reward);\n    event Staked(address indexed user, uint256 amount);\n    event Withdrawn(address indexed user, uint256 amount);\n    event RewardPaid(address indexed user, uint256 reward);\n    event LoyaltyBonusPaid(address indexed user, uint256 loyaltyBonus);\n    event RewardsDurationUpdated(uint256 newDuration);\n    // SWC-135-Code With No Effects: L615\n    event Recovered(address token, uint256 amount);\n    event RewardsDeposited(address sender, address receiver, uint256 reward);\n    event LoyaltyTiersUpdated(uint256 loyaltyTier1, uint256 loyaltyTier2, uint256 loyaltyTier3);\n    event LoyaltyTiersBonussUpdated(uint256 loyaltyTier1Bonus, uint256 loyaltyTier2Bonus, uint256 loyaltyTier3Bonus);\n}",
        "function": "notifyRewardAmount(uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Hacken-Codex on Althash/Codex-Rewards-Platform-d364d0ef9258dd468f8202a352c58724d6b65638/contracts/CDEX_rewards.sol",
        "vulnerability": "Dependence on predictable environment variable (SWC 116)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract CDEXStakingPool is ReentrancyGuard, Pausable {\n    using SafeMath for uint256;\n\n    // STATE VARIABLES\n    CDEXTokenContract public CDEXToken;\n    CDEXRankingContract public CDEXRanking;\n    uint256 public periodFinish = 0;\n    uint256 public rewardRate = 0;\n    uint256 public rewardsDuration = 0;\n    uint256 public lastUpdateTime;\n    uint256 public rewardPerTokenStored;\n    \n    \n    uint256 public loyaltyTier1 = 100000000 * 1e8;\n    uint256 public loyaltyTier2 = 10000000 * 1e8;\n    uint256 public loyaltyTier3 = 1000000 * 1e8;\n    \n    \n    uint256 public loyaltyTier1Bonus = 125;\n    uint256 public loyaltyTier2Bonus = 100;\n    uint256 public loyaltyTier3Bonus = 50;\n    uint256 public loyaltyBonusTotal = 275;\n    uint256 public depositedLoyaltyBonus;\n\n    mapping(address => uint256) public userRewardPerTokenPaid;\n    mapping(address => uint256) public rewards;\n    uint256 public depositedRewardTokens;\n\n    uint256 private _totalSupply;\n    mapping(address => uint256) private _balances;\n\n    uint256 public totalMembers;\n\n    \n    \n    \n    \n    \n    function CDEXStakingPool(\n        address _owner,\n        address _CDEXTokenContractAddress,\n        address _rankingContractAddress\n    ) public Owned(_owner) {\n        CDEXToken = CDEXTokenContract(_CDEXTokenContractAddress);\n        CDEXRanking = CDEXRankingContract(_rankingContractAddress);\n    }\n\n    \n    \n    \n    \n    function totalSupply() external view returns (uint256) {\n        return _totalSupply;\n    }\n\n    \n    \n    \n    function balanceOf(address account) external view returns (uint256) {\n        return _balances[account];\n    }\n\n    \n    \n    \n    function lastTimeRewardApplicable() public view returns (uint256) {\n        return min(block.timestamp, periodFinish);\n    }\n\n    \n    function rewardPerToken() public view returns (uint256) {\n        if (_totalSupply == 0) {\n            return rewardPerTokenStored;\n        }\n        return\n            rewardPerTokenStored.add(\n                lastTimeRewardApplicable()\n                    .sub(lastUpdateTime)\n                    .mul(rewardRate)\n                    .mul(1e8)\n                    .div(_totalSupply)\n            );\n    }\n\n    \n    \n    function earned(address account) public view returns (uint256) {\n        return\n            _balances[account]\n                .mul(rewardPerToken().sub(userRewardPerTokenPaid[account]))\n                .div(1e8)\n                .add(rewards[account]);\n    }\n\n    \n    function getRewardForDuration() external view returns (uint256) {\n        return rewardRate.mul(rewardsDuration);\n    }\n\n    \n    \n    \n    function min(uint256 a, uint256 b) public pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    \n    \n    function getLoyaltyTiers() external view returns(uint256 tier1, uint256 tier2, uint256 tier3)\n    {\n        return(loyaltyTier1, loyaltyTier2, loyaltyTier3);\n    }\n\n    \n    \n    \n    function getLoyaltyTiersBonus() external view returns(uint256 tier1Bonus, uint256 tier2Bonus, uint256 tier3Bonus)\n    {\n        return(loyaltyTier1Bonus, loyaltyTier2Bonus, loyaltyTier3Bonus);\n    }\n\n    // PUBLIC FUNCTIONS\n\n    \n    \n    // SWC-104-Unchecked Call Return Value: L362 - L391\n    function stake(uint256 amount)\n        external\n        nonReentrant\n        notPaused\n        updateReward(msg.sender)\n    {\n        require(amount > 0);\n        \n        _totalSupply = _totalSupply.add(amount);\n        \n        if(_balances[msg.sender] == 0) {\n            \n            totalMembers += 1;\n            \n            CDEXRanking.insert(amount, msg.sender);\n        } else {\n            \n            CDEXRanking.remove(_balances[msg.sender], msg.sender);\n            \n            CDEXRanking.insert(_balances[msg.sender].add(amount), msg.sender);\n        }\n        \n        _balances[msg.sender] = _balances[msg.sender].add(amount);\n        \n        \n        CDEXToken.transferFrom(msg.sender, address(this), amount);\n        \n        emit Staked(msg.sender, amount);\n    }\n\n    \n    \n    // SWC-104-Unchecked Call Return Value: L395 - L420\n    function withdraw(uint256 amount)\n        public\n        nonReentrant\n        updateReward(msg.sender)\n    {\n        require(amount > 0);\n        \n        _totalSupply = _totalSupply.sub(amount);\n        \n        CDEXRanking.remove(_balances[msg.sender], msg.sender);\n        \n        _balances[msg.sender] = _balances[msg.sender].sub(amount);\n        \n        if(_balances[msg.sender] == 0) {\n            totalMembers -= 1;\n        } else {\n            \n            CDEXRanking.insert(_balances[msg.sender], msg.sender);\n        }\n        \n        // SWC-104-Unchecked Call Return Value: L415\n        CDEXToken.transfer(msg.sender, amount);\n        \n        emit Withdrawn(msg.sender, amount);\n    }\n    \n    \n    // SWC-104-Unchecked Call Return Value: L424 - L456\n    function getReward() \n        public \n        nonReentrant \n        updateReward(msg.sender) \n    {\n        uint256 reward = rewards[msg.sender];\n        uint256 loyaltyBonus;\n        \n        if (reward > 0 && depositedRewardTokens >= reward) {\n            \n            rewards[msg.sender] = 0;\n            \n            depositedRewardTokens = depositedRewardTokens.sub(reward);\n            \n            if (_balances[msg.sender] >= loyaltyTier1) {\n                loyaltyBonus = reward.mul(loyaltyTier1Bonus).div(10000);\n            } else if (_balances[msg.sender] >= loyaltyTier2) {\n                loyaltyBonus = reward.mul(loyaltyTier2Bonus).div(10000);\n            } else if (_balances[msg.sender] >= loyaltyTier3) {\n                loyaltyBonus = reward.mul(loyaltyTier3Bonus).div(10000);\n            }\n            \n            depositedLoyaltyBonus = depositedLoyaltyBonus.sub(loyaltyBonus);\n            \n            CDEXToken.transfer(msg.sender, reward.add(loyaltyBonus));\n            \n            emit RewardPaid(msg.sender, reward);\n            \n            if(loyaltyBonus > 0) {\n                emit LoyaltyBonusPaid(msg.sender, loyaltyBonus);\n            }\n        }\n    }\n\n    \n    function exit() external {\n        withdraw(_balances[msg.sender]);\n        getReward();\n    }\n    \n    // RESTRICTED FUNCTIONS\n    \n    \n    \n    \n    function setTokenContract(address _contractAddress) public onlyOwner {\n        CDEXToken = CDEXTokenContract(_contractAddress);\n    }\n    \n    \n    \n    \n    function setRankingContract(address _contractAddress) public onlyOwner {\n        CDEXRanking = CDEXRankingContract(_contractAddress);\n    }\n    \n    \n    \n    \n    \n    \n    \n    // SWC-104-Unchecked Call Return Value: L486 - L498\n    function depositTokens(uint256 amount) public onlyOwner {\n        \n        amount = amount.mul(1e8);\n        \n        depositedLoyaltyBonus = depositedLoyaltyBonus.add(amount.mul(loyaltyBonusTotal).div(10000));\n        \n        depositedRewardTokens = depositedRewardTokens.add(amount);\n        \n        CDEXToken.transferFrom(owner, address(this), amount);\n        \n        emit RewardsDeposited(owner, address(this), amount);\n    }\n\n    \n    \n    \n    \n    function notifyRewardAmount(uint256 reward)\n        public\n        onlyOwner\n        updateReward(address(0))\n    {\n        \n        reward = reward.mul(1e8);\n        \n        \n        require(reward <= depositedRewardTokens.sub(reward.mul(loyaltyBonusTotal).div(10000)));\n        \n        \n        if (block.timestamp >= periodFinish) {\n            rewardRate = reward.div(rewardsDuration);\n        } else {\n            uint256 remaining = periodFinish.sub(block.timestamp);\n            uint256 leftover = remaining.mul(rewardRate);\n            rewardRate = reward.add(leftover).div(rewardsDuration);\n        }\n        \n        \n        \n        \n        require(rewardRate <= depositedRewardTokens.div(rewardsDuration));\n        \n        lastUpdateTime = block.timestamp;\n        \n        periodFinish = block.timestamp.add(rewardsDuration);\n        \n        emit RewardAdded(reward);\n    }\n\n    \n    \n    \n    function setRewardsDuration(uint256 _rewardsDuration) external onlyOwner {\n        \n        require(block.timestamp > periodFinish);\n        \n        rewardsDuration = _rewardsDuration;\n        \n        emit RewardsDurationUpdated(rewardsDuration);\n    }\n\n    \n    \n    \n    \n    function setLoyaltyTiers(\n        uint256 _loyaltyTier1, \n        uint256 _loyaltyTier2, \n        uint256 _loyaltyTier3\n    ) external onlyOwner \n    {\n        \n        loyaltyTier1 = _loyaltyTier1.mul(1e8);\n        loyaltyTier2 = _loyaltyTier2.mul(1e8);\n        loyaltyTier3 = _loyaltyTier3.mul(1e8);\n        \n        emit LoyaltyTiersUpdated(loyaltyTier1, loyaltyTier2, loyaltyTier3);\n    }\n\n    \n    \n    \n    \n    \n    \n    function setLoyaltyTiersBonus(\n        uint256 _loyaltyTier1Bonus, \n        uint256 _loyaltyTier2Bonus, \n        uint256 _loyaltyTier3Bonus\n    ) external onlyOwner \n    {\n        \n        \n        require(_loyaltyTier1Bonus.add(_loyaltyTier2Bonus).add(_loyaltyTier3Bonus) < 10000);\n        \n        loyaltyTier1Bonus = _loyaltyTier1Bonus;\n        loyaltyTier2Bonus = _loyaltyTier2Bonus;\n        loyaltyTier3Bonus = _loyaltyTier3Bonus;\n        \n        loyaltyBonusTotal = loyaltyTier1Bonus.add(loyaltyTier2Bonus).add(loyaltyTier3Bonus);\n        \n        emit LoyaltyTiersBonussUpdated(loyaltyTier1Bonus, loyaltyTier2Bonus, loyaltyTier3Bonus);\n    }\n\n    // MODIFIERS\n    \n    \n    \n    modifier updateReward(address account) {\n        rewardPerTokenStored = rewardPerToken();\n        lastUpdateTime = lastTimeRewardApplicable();\n        if (account != address(0)) {\n            rewards[account] = earned(account);\n            userRewardPerTokenPaid[account] = rewardPerTokenStored;\n        }\n        _;\n    }\n\n    // EVENTS\n\n    event RewardAdded(uint256 reward);\n    event Staked(address indexed user, uint256 amount);\n    event Withdrawn(address indexed user, uint256 amount);\n    event RewardPaid(address indexed user, uint256 reward);\n    event LoyaltyBonusPaid(address indexed user, uint256 loyaltyBonus);\n    event RewardsDurationUpdated(uint256 newDuration);\n    // SWC-135-Code With No Effects: L615\n    event Recovered(address token, uint256 amount);\n    event RewardsDeposited(address sender, address receiver, uint256 reward);\n    event LoyaltyTiersUpdated(uint256 loyaltyTier1, uint256 loyaltyTier2, uint256 loyaltyTier3);\n    event LoyaltyTiersBonussUpdated(uint256 loyaltyTier1Bonus, uint256 loyaltyTier2Bonus, uint256 loyaltyTier3Bonus);\n}",
        "function": "withdraw(uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Hacken-Codex on Althash/Codex-Rewards-Platform-d364d0ef9258dd468f8202a352c58724d6b65638/contracts/CDEX_rewards.sol",
        "vulnerability": "Dependence on predictable environment variable (SWC 116)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract CDEXStakingPool is ReentrancyGuard, Pausable {\n    using SafeMath for uint256;\n\n    // STATE VARIABLES\n    CDEXTokenContract public CDEXToken;\n    CDEXRankingContract public CDEXRanking;\n    uint256 public periodFinish = 0;\n    uint256 public rewardRate = 0;\n    uint256 public rewardsDuration = 0;\n    uint256 public lastUpdateTime;\n    uint256 public rewardPerTokenStored;\n    \n    \n    uint256 public loyaltyTier1 = 100000000 * 1e8;\n    uint256 public loyaltyTier2 = 10000000 * 1e8;\n    uint256 public loyaltyTier3 = 1000000 * 1e8;\n    \n    \n    uint256 public loyaltyTier1Bonus = 125;\n    uint256 public loyaltyTier2Bonus = 100;\n    uint256 public loyaltyTier3Bonus = 50;\n    uint256 public loyaltyBonusTotal = 275;\n    uint256 public depositedLoyaltyBonus;\n\n    mapping(address => uint256) public userRewardPerTokenPaid;\n    mapping(address => uint256) public rewards;\n    uint256 public depositedRewardTokens;\n\n    uint256 private _totalSupply;\n    mapping(address => uint256) private _balances;\n\n    uint256 public totalMembers;\n\n    \n    \n    \n    \n    \n    function CDEXStakingPool(\n        address _owner,\n        address _CDEXTokenContractAddress,\n        address _rankingContractAddress\n    ) public Owned(_owner) {\n        CDEXToken = CDEXTokenContract(_CDEXTokenContractAddress);\n        CDEXRanking = CDEXRankingContract(_rankingContractAddress);\n    }\n\n    \n    \n    \n    \n    function totalSupply() external view returns (uint256) {\n        return _totalSupply;\n    }\n\n    \n    \n    \n    function balanceOf(address account) external view returns (uint256) {\n        return _balances[account];\n    }\n\n    \n    \n    \n    function lastTimeRewardApplicable() public view returns (uint256) {\n        return min(block.timestamp, periodFinish);\n    }\n\n    \n    function rewardPerToken() public view returns (uint256) {\n        if (_totalSupply == 0) {\n            return rewardPerTokenStored;\n        }\n        return\n            rewardPerTokenStored.add(\n                lastTimeRewardApplicable()\n                    .sub(lastUpdateTime)\n                    .mul(rewardRate)\n                    .mul(1e8)\n                    .div(_totalSupply)\n            );\n    }\n\n    \n    \n    function earned(address account) public view returns (uint256) {\n        return\n            _balances[account]\n                .mul(rewardPerToken().sub(userRewardPerTokenPaid[account]))\n                .div(1e8)\n                .add(rewards[account]);\n    }\n\n    \n    function getRewardForDuration() external view returns (uint256) {\n        return rewardRate.mul(rewardsDuration);\n    }\n\n    \n    \n    \n    function min(uint256 a, uint256 b) public pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    \n    \n    function getLoyaltyTiers() external view returns(uint256 tier1, uint256 tier2, uint256 tier3)\n    {\n        return(loyaltyTier1, loyaltyTier2, loyaltyTier3);\n    }\n\n    \n    \n    \n    function getLoyaltyTiersBonus() external view returns(uint256 tier1Bonus, uint256 tier2Bonus, uint256 tier3Bonus)\n    {\n        return(loyaltyTier1Bonus, loyaltyTier2Bonus, loyaltyTier3Bonus);\n    }\n\n    // PUBLIC FUNCTIONS\n\n    \n    \n    // SWC-104-Unchecked Call Return Value: L362 - L391\n    function stake(uint256 amount)\n        external\n        nonReentrant\n        notPaused\n        updateReward(msg.sender)\n    {\n        require(amount > 0);\n        \n        _totalSupply = _totalSupply.add(amount);\n        \n        if(_balances[msg.sender] == 0) {\n            \n            totalMembers += 1;\n            \n            CDEXRanking.insert(amount, msg.sender);\n        } else {\n            \n            CDEXRanking.remove(_balances[msg.sender], msg.sender);\n            \n            CDEXRanking.insert(_balances[msg.sender].add(amount), msg.sender);\n        }\n        \n        _balances[msg.sender] = _balances[msg.sender].add(amount);\n        \n        \n        CDEXToken.transferFrom(msg.sender, address(this), amount);\n        \n        emit Staked(msg.sender, amount);\n    }\n\n    \n    \n    // SWC-104-Unchecked Call Return Value: L395 - L420\n    function withdraw(uint256 amount)\n        public\n        nonReentrant\n        updateReward(msg.sender)\n    {\n        require(amount > 0);\n        \n        _totalSupply = _totalSupply.sub(amount);\n        \n        CDEXRanking.remove(_balances[msg.sender], msg.sender);\n        \n        _balances[msg.sender] = _balances[msg.sender].sub(amount);\n        \n        if(_balances[msg.sender] == 0) {\n            totalMembers -= 1;\n        } else {\n            \n            CDEXRanking.insert(_balances[msg.sender], msg.sender);\n        }\n        \n        // SWC-104-Unchecked Call Return Value: L415\n        CDEXToken.transfer(msg.sender, amount);\n        \n        emit Withdrawn(msg.sender, amount);\n    }\n    \n    \n    // SWC-104-Unchecked Call Return Value: L424 - L456\n    function getReward() \n        public \n        nonReentrant \n        updateReward(msg.sender) \n    {\n        uint256 reward = rewards[msg.sender];\n        uint256 loyaltyBonus;\n        \n        if (reward > 0 && depositedRewardTokens >= reward) {\n            \n            rewards[msg.sender] = 0;\n            \n            depositedRewardTokens = depositedRewardTokens.sub(reward);\n            \n            if (_balances[msg.sender] >= loyaltyTier1) {\n                loyaltyBonus = reward.mul(loyaltyTier1Bonus).div(10000);\n            } else if (_balances[msg.sender] >= loyaltyTier2) {\n                loyaltyBonus = reward.mul(loyaltyTier2Bonus).div(10000);\n            } else if (_balances[msg.sender] >= loyaltyTier3) {\n                loyaltyBonus = reward.mul(loyaltyTier3Bonus).div(10000);\n            }\n            \n            depositedLoyaltyBonus = depositedLoyaltyBonus.sub(loyaltyBonus);\n            \n            CDEXToken.transfer(msg.sender, reward.add(loyaltyBonus));\n            \n            emit RewardPaid(msg.sender, reward);\n            \n            if(loyaltyBonus > 0) {\n                emit LoyaltyBonusPaid(msg.sender, loyaltyBonus);\n            }\n        }\n    }\n\n    \n    function exit() external {\n        withdraw(_balances[msg.sender]);\n        getReward();\n    }\n    \n    // RESTRICTED FUNCTIONS\n    \n    \n    \n    \n    function setTokenContract(address _contractAddress) public onlyOwner {\n        CDEXToken = CDEXTokenContract(_contractAddress);\n    }\n    \n    \n    \n    \n    function setRankingContract(address _contractAddress) public onlyOwner {\n        CDEXRanking = CDEXRankingContract(_contractAddress);\n    }\n    \n    \n    \n    \n    \n    \n    \n    // SWC-104-Unchecked Call Return Value: L486 - L498\n    function depositTokens(uint256 amount) public onlyOwner {\n        \n        amount = amount.mul(1e8);\n        \n        depositedLoyaltyBonus = depositedLoyaltyBonus.add(amount.mul(loyaltyBonusTotal).div(10000));\n        \n        depositedRewardTokens = depositedRewardTokens.add(amount);\n        \n        CDEXToken.transferFrom(owner, address(this), amount);\n        \n        emit RewardsDeposited(owner, address(this), amount);\n    }\n\n    \n    \n    \n    \n    function notifyRewardAmount(uint256 reward)\n        public\n        onlyOwner\n        updateReward(address(0))\n    {\n        \n        reward = reward.mul(1e8);\n        \n        \n        require(reward <= depositedRewardTokens.sub(reward.mul(loyaltyBonusTotal).div(10000)));\n        \n        \n        if (block.timestamp >= periodFinish) {\n            rewardRate = reward.div(rewardsDuration);\n        } else {\n            uint256 remaining = periodFinish.sub(block.timestamp);\n            uint256 leftover = remaining.mul(rewardRate);\n            rewardRate = reward.add(leftover).div(rewardsDuration);\n        }\n        \n        \n        \n        \n        require(rewardRate <= depositedRewardTokens.div(rewardsDuration));\n        \n        lastUpdateTime = block.timestamp;\n        \n        periodFinish = block.timestamp.add(rewardsDuration);\n        \n        emit RewardAdded(reward);\n    }\n\n    \n    \n    \n    function setRewardsDuration(uint256 _rewardsDuration) external onlyOwner {\n        \n        require(block.timestamp > periodFinish);\n        \n        rewardsDuration = _rewardsDuration;\n        \n        emit RewardsDurationUpdated(rewardsDuration);\n    }\n\n    \n    \n    \n    \n    function setLoyaltyTiers(\n        uint256 _loyaltyTier1, \n        uint256 _loyaltyTier2, \n        uint256 _loyaltyTier3\n    ) external onlyOwner \n    {\n        \n        loyaltyTier1 = _loyaltyTier1.mul(1e8);\n        loyaltyTier2 = _loyaltyTier2.mul(1e8);\n        loyaltyTier3 = _loyaltyTier3.mul(1e8);\n        \n        emit LoyaltyTiersUpdated(loyaltyTier1, loyaltyTier2, loyaltyTier3);\n    }\n\n    \n    \n    \n    \n    \n    \n    function setLoyaltyTiersBonus(\n        uint256 _loyaltyTier1Bonus, \n        uint256 _loyaltyTier2Bonus, \n        uint256 _loyaltyTier3Bonus\n    ) external onlyOwner \n    {\n        \n        \n        require(_loyaltyTier1Bonus.add(_loyaltyTier2Bonus).add(_loyaltyTier3Bonus) < 10000);\n        \n        loyaltyTier1Bonus = _loyaltyTier1Bonus;\n        loyaltyTier2Bonus = _loyaltyTier2Bonus;\n        loyaltyTier3Bonus = _loyaltyTier3Bonus;\n        \n        loyaltyBonusTotal = loyaltyTier1Bonus.add(loyaltyTier2Bonus).add(loyaltyTier3Bonus);\n        \n        emit LoyaltyTiersBonussUpdated(loyaltyTier1Bonus, loyaltyTier2Bonus, loyaltyTier3Bonus);\n    }\n\n    // MODIFIERS\n    \n    \n    \n    modifier updateReward(address account) {\n        rewardPerTokenStored = rewardPerToken();\n        lastUpdateTime = lastTimeRewardApplicable();\n        if (account != address(0)) {\n            rewards[account] = earned(account);\n            userRewardPerTokenPaid[account] = rewardPerTokenStored;\n        }\n        _;\n    }\n\n    // EVENTS\n\n    event RewardAdded(uint256 reward);\n    event Staked(address indexed user, uint256 amount);\n    event Withdrawn(address indexed user, uint256 amount);\n    event RewardPaid(address indexed user, uint256 reward);\n    event LoyaltyBonusPaid(address indexed user, uint256 loyaltyBonus);\n    event RewardsDurationUpdated(uint256 newDuration);\n    // SWC-135-Code With No Effects: L615\n    event Recovered(address token, uint256 amount);\n    event RewardsDeposited(address sender, address receiver, uint256 reward);\n    event LoyaltyTiersUpdated(uint256 loyaltyTier1, uint256 loyaltyTier2, uint256 loyaltyTier3);\n    event LoyaltyTiersBonussUpdated(uint256 loyaltyTier1Bonus, uint256 loyaltyTier2Bonus, uint256 loyaltyTier3Bonus);\n}",
        "function": "stake(uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Hacken-Codex on Althash/Codex-Rewards-Platform-d364d0ef9258dd468f8202a352c58724d6b65638/contracts/CDEX_rewards.sol",
        "vulnerability": "External Call To User-Supplied Address (SWC 107)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract CDEXStakingPool is ReentrancyGuard, Pausable {\n    using SafeMath for uint256;\n\n    // STATE VARIABLES\n    CDEXTokenContract public CDEXToken;\n    CDEXRankingContract public CDEXRanking;\n    uint256 public periodFinish = 0;\n    uint256 public rewardRate = 0;\n    uint256 public rewardsDuration = 0;\n    uint256 public lastUpdateTime;\n    uint256 public rewardPerTokenStored;\n    \n    \n    uint256 public loyaltyTier1 = 100000000 * 1e8;\n    uint256 public loyaltyTier2 = 10000000 * 1e8;\n    uint256 public loyaltyTier3 = 1000000 * 1e8;\n    \n    \n    uint256 public loyaltyTier1Bonus = 125;\n    uint256 public loyaltyTier2Bonus = 100;\n    uint256 public loyaltyTier3Bonus = 50;\n    uint256 public loyaltyBonusTotal = 275;\n    uint256 public depositedLoyaltyBonus;\n\n    mapping(address => uint256) public userRewardPerTokenPaid;\n    mapping(address => uint256) public rewards;\n    uint256 public depositedRewardTokens;\n\n    uint256 private _totalSupply;\n    mapping(address => uint256) private _balances;\n\n    uint256 public totalMembers;\n\n    \n    \n    \n    \n    \n    function CDEXStakingPool(\n        address _owner,\n        address _CDEXTokenContractAddress,\n        address _rankingContractAddress\n    ) public Owned(_owner) {\n        CDEXToken = CDEXTokenContract(_CDEXTokenContractAddress);\n        CDEXRanking = CDEXRankingContract(_rankingContractAddress);\n    }\n\n    \n    \n    \n    \n    function totalSupply() external view returns (uint256) {\n        return _totalSupply;\n    }\n\n    \n    \n    \n    function balanceOf(address account) external view returns (uint256) {\n        return _balances[account];\n    }\n\n    \n    \n    \n    function lastTimeRewardApplicable() public view returns (uint256) {\n        return min(block.timestamp, periodFinish);\n    }\n\n    \n    function rewardPerToken() public view returns (uint256) {\n        if (_totalSupply == 0) {\n            return rewardPerTokenStored;\n        }\n        return\n            rewardPerTokenStored.add(\n                lastTimeRewardApplicable()\n                    .sub(lastUpdateTime)\n                    .mul(rewardRate)\n                    .mul(1e8)\n                    .div(_totalSupply)\n            );\n    }\n\n    \n    \n    function earned(address account) public view returns (uint256) {\n        return\n            _balances[account]\n                .mul(rewardPerToken().sub(userRewardPerTokenPaid[account]))\n                .div(1e8)\n                .add(rewards[account]);\n    }\n\n    \n    function getRewardForDuration() external view returns (uint256) {\n        return rewardRate.mul(rewardsDuration);\n    }\n\n    \n    \n    \n    function min(uint256 a, uint256 b) public pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    \n    \n    function getLoyaltyTiers() external view returns(uint256 tier1, uint256 tier2, uint256 tier3)\n    {\n        return(loyaltyTier1, loyaltyTier2, loyaltyTier3);\n    }\n\n    \n    \n    \n    function getLoyaltyTiersBonus() external view returns(uint256 tier1Bonus, uint256 tier2Bonus, uint256 tier3Bonus)\n    {\n        return(loyaltyTier1Bonus, loyaltyTier2Bonus, loyaltyTier3Bonus);\n    }\n\n    // PUBLIC FUNCTIONS\n\n    \n    \n    // SWC-104-Unchecked Call Return Value: L362 - L391\n    function stake(uint256 amount)\n        external\n        nonReentrant\n        notPaused\n        updateReward(msg.sender)\n    {\n        require(amount > 0);\n        \n        _totalSupply = _totalSupply.add(amount);\n        \n        if(_balances[msg.sender] == 0) {\n            \n            totalMembers += 1;\n            \n            CDEXRanking.insert(amount, msg.sender);\n        } else {\n            \n            CDEXRanking.remove(_balances[msg.sender], msg.sender);\n            \n            CDEXRanking.insert(_balances[msg.sender].add(amount), msg.sender);\n        }\n        \n        _balances[msg.sender] = _balances[msg.sender].add(amount);\n        \n        \n        CDEXToken.transferFrom(msg.sender, address(this), amount);\n        \n        emit Staked(msg.sender, amount);\n    }\n\n    \n    \n    // SWC-104-Unchecked Call Return Value: L395 - L420\n    function withdraw(uint256 amount)\n        public\n        nonReentrant\n        updateReward(msg.sender)\n    {\n        require(amount > 0);\n        \n        _totalSupply = _totalSupply.sub(amount);\n        \n        CDEXRanking.remove(_balances[msg.sender], msg.sender);\n        \n        _balances[msg.sender] = _balances[msg.sender].sub(amount);\n        \n        if(_balances[msg.sender] == 0) {\n            totalMembers -= 1;\n        } else {\n            \n            CDEXRanking.insert(_balances[msg.sender], msg.sender);\n        }\n        \n        // SWC-104-Unchecked Call Return Value: L415\n        CDEXToken.transfer(msg.sender, amount);\n        \n        emit Withdrawn(msg.sender, amount);\n    }\n    \n    \n    // SWC-104-Unchecked Call Return Value: L424 - L456\n    function getReward() \n        public \n        nonReentrant \n        updateReward(msg.sender) \n    {\n        uint256 reward = rewards[msg.sender];\n        uint256 loyaltyBonus;\n        \n        if (reward > 0 && depositedRewardTokens >= reward) {\n            \n            rewards[msg.sender] = 0;\n            \n            depositedRewardTokens = depositedRewardTokens.sub(reward);\n            \n            if (_balances[msg.sender] >= loyaltyTier1) {\n                loyaltyBonus = reward.mul(loyaltyTier1Bonus).div(10000);\n            } else if (_balances[msg.sender] >= loyaltyTier2) {\n                loyaltyBonus = reward.mul(loyaltyTier2Bonus).div(10000);\n            } else if (_balances[msg.sender] >= loyaltyTier3) {\n                loyaltyBonus = reward.mul(loyaltyTier3Bonus).div(10000);\n            }\n            \n            depositedLoyaltyBonus = depositedLoyaltyBonus.sub(loyaltyBonus);\n            \n            CDEXToken.transfer(msg.sender, reward.add(loyaltyBonus));\n            \n            emit RewardPaid(msg.sender, reward);\n            \n            if(loyaltyBonus > 0) {\n                emit LoyaltyBonusPaid(msg.sender, loyaltyBonus);\n            }\n        }\n    }\n\n    \n    function exit() external {\n        withdraw(_balances[msg.sender]);\n        getReward();\n    }\n    \n    // RESTRICTED FUNCTIONS\n    \n    \n    \n    \n    function setTokenContract(address _contractAddress) public onlyOwner {\n        CDEXToken = CDEXTokenContract(_contractAddress);\n    }\n    \n    \n    \n    \n    function setRankingContract(address _contractAddress) public onlyOwner {\n        CDEXRanking = CDEXRankingContract(_contractAddress);\n    }\n    \n    \n    \n    \n    \n    \n    \n    // SWC-104-Unchecked Call Return Value: L486 - L498\n    function depositTokens(uint256 amount) public onlyOwner {\n        \n        amount = amount.mul(1e8);\n        \n        depositedLoyaltyBonus = depositedLoyaltyBonus.add(amount.mul(loyaltyBonusTotal).div(10000));\n        \n        depositedRewardTokens = depositedRewardTokens.add(amount);\n        \n        CDEXToken.transferFrom(owner, address(this), amount);\n        \n        emit RewardsDeposited(owner, address(this), amount);\n    }\n\n    \n    \n    \n    \n    function notifyRewardAmount(uint256 reward)\n        public\n        onlyOwner\n        updateReward(address(0))\n    {\n        \n        reward = reward.mul(1e8);\n        \n        \n        require(reward <= depositedRewardTokens.sub(reward.mul(loyaltyBonusTotal).div(10000)));\n        \n        \n        if (block.timestamp >= periodFinish) {\n            rewardRate = reward.div(rewardsDuration);\n        } else {\n            uint256 remaining = periodFinish.sub(block.timestamp);\n            uint256 leftover = remaining.mul(rewardRate);\n            rewardRate = reward.add(leftover).div(rewardsDuration);\n        }\n        \n        \n        \n        \n        require(rewardRate <= depositedRewardTokens.div(rewardsDuration));\n        \n        lastUpdateTime = block.timestamp;\n        \n        periodFinish = block.timestamp.add(rewardsDuration);\n        \n        emit RewardAdded(reward);\n    }\n\n    \n    \n    \n    function setRewardsDuration(uint256 _rewardsDuration) external onlyOwner {\n        \n        require(block.timestamp > periodFinish);\n        \n        rewardsDuration = _rewardsDuration;\n        \n        emit RewardsDurationUpdated(rewardsDuration);\n    }\n\n    \n    \n    \n    \n    function setLoyaltyTiers(\n        uint256 _loyaltyTier1, \n        uint256 _loyaltyTier2, \n        uint256 _loyaltyTier3\n    ) external onlyOwner \n    {\n        \n        loyaltyTier1 = _loyaltyTier1.mul(1e8);\n        loyaltyTier2 = _loyaltyTier2.mul(1e8);\n        loyaltyTier3 = _loyaltyTier3.mul(1e8);\n        \n        emit LoyaltyTiersUpdated(loyaltyTier1, loyaltyTier2, loyaltyTier3);\n    }\n\n    \n    \n    \n    \n    \n    \n    function setLoyaltyTiersBonus(\n        uint256 _loyaltyTier1Bonus, \n        uint256 _loyaltyTier2Bonus, \n        uint256 _loyaltyTier3Bonus\n    ) external onlyOwner \n    {\n        \n        \n        require(_loyaltyTier1Bonus.add(_loyaltyTier2Bonus).add(_loyaltyTier3Bonus) < 10000);\n        \n        loyaltyTier1Bonus = _loyaltyTier1Bonus;\n        loyaltyTier2Bonus = _loyaltyTier2Bonus;\n        loyaltyTier3Bonus = _loyaltyTier3Bonus;\n        \n        loyaltyBonusTotal = loyaltyTier1Bonus.add(loyaltyTier2Bonus).add(loyaltyTier3Bonus);\n        \n        emit LoyaltyTiersBonussUpdated(loyaltyTier1Bonus, loyaltyTier2Bonus, loyaltyTier3Bonus);\n    }\n\n    // MODIFIERS\n    \n    \n    \n    modifier updateReward(address account) {\n        rewardPerTokenStored = rewardPerToken();\n        lastUpdateTime = lastTimeRewardApplicable();\n        if (account != address(0)) {\n            rewards[account] = earned(account);\n            userRewardPerTokenPaid[account] = rewardPerTokenStored;\n        }\n        _;\n    }\n\n    // EVENTS\n\n    event RewardAdded(uint256 reward);\n    event Staked(address indexed user, uint256 amount);\n    event Withdrawn(address indexed user, uint256 amount);\n    event RewardPaid(address indexed user, uint256 reward);\n    event LoyaltyBonusPaid(address indexed user, uint256 loyaltyBonus);\n    event RewardsDurationUpdated(uint256 newDuration);\n    // SWC-135-Code With No Effects: L615\n    event Recovered(address token, uint256 amount);\n    event RewardsDeposited(address sender, address receiver, uint256 reward);\n    event LoyaltyTiersUpdated(uint256 loyaltyTier1, uint256 loyaltyTier2, uint256 loyaltyTier3);\n    event LoyaltyTiersBonussUpdated(uint256 loyaltyTier1Bonus, uint256 loyaltyTier2Bonus, uint256 loyaltyTier3Bonus);\n}",
        "function": "stake(uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Hacken-Codex on Althash/Codex-Rewards-Platform-d364d0ef9258dd468f8202a352c58724d6b65638/contracts/CDEX_rewards.sol",
        "vulnerability": "State access after external call (SWC 107)",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract CDEXStakingPool is ReentrancyGuard, Pausable {\n    using SafeMath for uint256;\n\n    // STATE VARIABLES\n    CDEXTokenContract public CDEXToken;\n    CDEXRankingContract public CDEXRanking;\n    uint256 public periodFinish = 0;\n    uint256 public rewardRate = 0;\n    uint256 public rewardsDuration = 0;\n    uint256 public lastUpdateTime;\n    uint256 public rewardPerTokenStored;\n    \n    \n    uint256 public loyaltyTier1 = 100000000 * 1e8;\n    uint256 public loyaltyTier2 = 10000000 * 1e8;\n    uint256 public loyaltyTier3 = 1000000 * 1e8;\n    \n    \n    uint256 public loyaltyTier1Bonus = 125;\n    uint256 public loyaltyTier2Bonus = 100;\n    uint256 public loyaltyTier3Bonus = 50;\n    uint256 public loyaltyBonusTotal = 275;\n    uint256 public depositedLoyaltyBonus;\n\n    mapping(address => uint256) public userRewardPerTokenPaid;\n    mapping(address => uint256) public rewards;\n    uint256 public depositedRewardTokens;\n\n    uint256 private _totalSupply;\n    mapping(address => uint256) private _balances;\n\n    uint256 public totalMembers;\n\n    \n    \n    \n    \n    \n    function CDEXStakingPool(\n        address _owner,\n        address _CDEXTokenContractAddress,\n        address _rankingContractAddress\n    ) public Owned(_owner) {\n        CDEXToken = CDEXTokenContract(_CDEXTokenContractAddress);\n        CDEXRanking = CDEXRankingContract(_rankingContractAddress);\n    }\n\n    \n    \n    \n    \n    function totalSupply() external view returns (uint256) {\n        return _totalSupply;\n    }\n\n    \n    \n    \n    function balanceOf(address account) external view returns (uint256) {\n        return _balances[account];\n    }\n\n    \n    \n    \n    function lastTimeRewardApplicable() public view returns (uint256) {\n        return min(block.timestamp, periodFinish);\n    }\n\n    \n    function rewardPerToken() public view returns (uint256) {\n        if (_totalSupply == 0) {\n            return rewardPerTokenStored;\n        }\n        return\n            rewardPerTokenStored.add(\n                lastTimeRewardApplicable()\n                    .sub(lastUpdateTime)\n                    .mul(rewardRate)\n                    .mul(1e8)\n                    .div(_totalSupply)\n            );\n    }\n\n    \n    \n    function earned(address account) public view returns (uint256) {\n        return\n            _balances[account]\n                .mul(rewardPerToken().sub(userRewardPerTokenPaid[account]))\n                .div(1e8)\n                .add(rewards[account]);\n    }\n\n    \n    function getRewardForDuration() external view returns (uint256) {\n        return rewardRate.mul(rewardsDuration);\n    }\n\n    \n    \n    \n    function min(uint256 a, uint256 b) public pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    \n    \n    function getLoyaltyTiers() external view returns(uint256 tier1, uint256 tier2, uint256 tier3)\n    {\n        return(loyaltyTier1, loyaltyTier2, loyaltyTier3);\n    }\n\n    \n    \n    \n    function getLoyaltyTiersBonus() external view returns(uint256 tier1Bonus, uint256 tier2Bonus, uint256 tier3Bonus)\n    {\n        return(loyaltyTier1Bonus, loyaltyTier2Bonus, loyaltyTier3Bonus);\n    }\n\n    // PUBLIC FUNCTIONS\n\n    \n    \n    // SWC-104-Unchecked Call Return Value: L362 - L391\n    function stake(uint256 amount)\n        external\n        nonReentrant\n        notPaused\n        updateReward(msg.sender)\n    {\n        require(amount > 0);\n        \n        _totalSupply = _totalSupply.add(amount);\n        \n        if(_balances[msg.sender] == 0) {\n            \n            totalMembers += 1;\n            \n            CDEXRanking.insert(amount, msg.sender);\n        } else {\n            \n            CDEXRanking.remove(_balances[msg.sender], msg.sender);\n            \n            CDEXRanking.insert(_balances[msg.sender].add(amount), msg.sender);\n        }\n        \n        _balances[msg.sender] = _balances[msg.sender].add(amount);\n        \n        \n        CDEXToken.transferFrom(msg.sender, address(this), amount);\n        \n        emit Staked(msg.sender, amount);\n    }\n\n    \n    \n    // SWC-104-Unchecked Call Return Value: L395 - L420\n    function withdraw(uint256 amount)\n        public\n        nonReentrant\n        updateReward(msg.sender)\n    {\n        require(amount > 0);\n        \n        _totalSupply = _totalSupply.sub(amount);\n        \n        CDEXRanking.remove(_balances[msg.sender], msg.sender);\n        \n        _balances[msg.sender] = _balances[msg.sender].sub(amount);\n        \n        if(_balances[msg.sender] == 0) {\n            totalMembers -= 1;\n        } else {\n            \n            CDEXRanking.insert(_balances[msg.sender], msg.sender);\n        }\n        \n        // SWC-104-Unchecked Call Return Value: L415\n        CDEXToken.transfer(msg.sender, amount);\n        \n        emit Withdrawn(msg.sender, amount);\n    }\n    \n    \n    // SWC-104-Unchecked Call Return Value: L424 - L456\n    function getReward() \n        public \n        nonReentrant \n        updateReward(msg.sender) \n    {\n        uint256 reward = rewards[msg.sender];\n        uint256 loyaltyBonus;\n        \n        if (reward > 0 && depositedRewardTokens >= reward) {\n            \n            rewards[msg.sender] = 0;\n            \n            depositedRewardTokens = depositedRewardTokens.sub(reward);\n            \n            if (_balances[msg.sender] >= loyaltyTier1) {\n                loyaltyBonus = reward.mul(loyaltyTier1Bonus).div(10000);\n            } else if (_balances[msg.sender] >= loyaltyTier2) {\n                loyaltyBonus = reward.mul(loyaltyTier2Bonus).div(10000);\n            } else if (_balances[msg.sender] >= loyaltyTier3) {\n                loyaltyBonus = reward.mul(loyaltyTier3Bonus).div(10000);\n            }\n            \n            depositedLoyaltyBonus = depositedLoyaltyBonus.sub(loyaltyBonus);\n            \n            CDEXToken.transfer(msg.sender, reward.add(loyaltyBonus));\n            \n            emit RewardPaid(msg.sender, reward);\n            \n            if(loyaltyBonus > 0) {\n                emit LoyaltyBonusPaid(msg.sender, loyaltyBonus);\n            }\n        }\n    }\n\n    \n    function exit() external {\n        withdraw(_balances[msg.sender]);\n        getReward();\n    }\n    \n    // RESTRICTED FUNCTIONS\n    \n    \n    \n    \n    function setTokenContract(address _contractAddress) public onlyOwner {\n        CDEXToken = CDEXTokenContract(_contractAddress);\n    }\n    \n    \n    \n    \n    function setRankingContract(address _contractAddress) public onlyOwner {\n        CDEXRanking = CDEXRankingContract(_contractAddress);\n    }\n    \n    \n    \n    \n    \n    \n    \n    // SWC-104-Unchecked Call Return Value: L486 - L498\n    function depositTokens(uint256 amount) public onlyOwner {\n        \n        amount = amount.mul(1e8);\n        \n        depositedLoyaltyBonus = depositedLoyaltyBonus.add(amount.mul(loyaltyBonusTotal).div(10000));\n        \n        depositedRewardTokens = depositedRewardTokens.add(amount);\n        \n        CDEXToken.transferFrom(owner, address(this), amount);\n        \n        emit RewardsDeposited(owner, address(this), amount);\n    }\n\n    \n    \n    \n    \n    function notifyRewardAmount(uint256 reward)\n        public\n        onlyOwner\n        updateReward(address(0))\n    {\n        \n        reward = reward.mul(1e8);\n        \n        \n        require(reward <= depositedRewardTokens.sub(reward.mul(loyaltyBonusTotal).div(10000)));\n        \n        \n        if (block.timestamp >= periodFinish) {\n            rewardRate = reward.div(rewardsDuration);\n        } else {\n            uint256 remaining = periodFinish.sub(block.timestamp);\n            uint256 leftover = remaining.mul(rewardRate);\n            rewardRate = reward.add(leftover).div(rewardsDuration);\n        }\n        \n        \n        \n        \n        require(rewardRate <= depositedRewardTokens.div(rewardsDuration));\n        \n        lastUpdateTime = block.timestamp;\n        \n        periodFinish = block.timestamp.add(rewardsDuration);\n        \n        emit RewardAdded(reward);\n    }\n\n    \n    \n    \n    function setRewardsDuration(uint256 _rewardsDuration) external onlyOwner {\n        \n        require(block.timestamp > periodFinish);\n        \n        rewardsDuration = _rewardsDuration;\n        \n        emit RewardsDurationUpdated(rewardsDuration);\n    }\n\n    \n    \n    \n    \n    function setLoyaltyTiers(\n        uint256 _loyaltyTier1, \n        uint256 _loyaltyTier2, \n        uint256 _loyaltyTier3\n    ) external onlyOwner \n    {\n        \n        loyaltyTier1 = _loyaltyTier1.mul(1e8);\n        loyaltyTier2 = _loyaltyTier2.mul(1e8);\n        loyaltyTier3 = _loyaltyTier3.mul(1e8);\n        \n        emit LoyaltyTiersUpdated(loyaltyTier1, loyaltyTier2, loyaltyTier3);\n    }\n\n    \n    \n    \n    \n    \n    \n    function setLoyaltyTiersBonus(\n        uint256 _loyaltyTier1Bonus, \n        uint256 _loyaltyTier2Bonus, \n        uint256 _loyaltyTier3Bonus\n    ) external onlyOwner \n    {\n        \n        \n        require(_loyaltyTier1Bonus.add(_loyaltyTier2Bonus).add(_loyaltyTier3Bonus) < 10000);\n        \n        loyaltyTier1Bonus = _loyaltyTier1Bonus;\n        loyaltyTier2Bonus = _loyaltyTier2Bonus;\n        loyaltyTier3Bonus = _loyaltyTier3Bonus;\n        \n        loyaltyBonusTotal = loyaltyTier1Bonus.add(loyaltyTier2Bonus).add(loyaltyTier3Bonus);\n        \n        emit LoyaltyTiersBonussUpdated(loyaltyTier1Bonus, loyaltyTier2Bonus, loyaltyTier3Bonus);\n    }\n\n    // MODIFIERS\n    \n    \n    \n    modifier updateReward(address account) {\n        rewardPerTokenStored = rewardPerToken();\n        lastUpdateTime = lastTimeRewardApplicable();\n        if (account != address(0)) {\n            rewards[account] = earned(account);\n            userRewardPerTokenPaid[account] = rewardPerTokenStored;\n        }\n        _;\n    }\n\n    // EVENTS\n\n    event RewardAdded(uint256 reward);\n    event Staked(address indexed user, uint256 amount);\n    event Withdrawn(address indexed user, uint256 amount);\n    event RewardPaid(address indexed user, uint256 reward);\n    event LoyaltyBonusPaid(address indexed user, uint256 loyaltyBonus);\n    event RewardsDurationUpdated(uint256 newDuration);\n    // SWC-135-Code With No Effects: L615\n    event Recovered(address token, uint256 amount);\n    event RewardsDeposited(address sender, address receiver, uint256 reward);\n    event LoyaltyTiersUpdated(uint256 loyaltyTier1, uint256 loyaltyTier2, uint256 loyaltyTier3);\n    event LoyaltyTiersBonussUpdated(uint256 loyaltyTier1Bonus, uint256 loyaltyTier2Bonus, uint256 loyaltyTier3Bonus);\n}",
        "function": "stake(uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Hacken-Codex on Althash/Codex-Rewards-Platform-d364d0ef9258dd468f8202a352c58724d6b65638/contracts/CDEX_rewards.sol",
        "vulnerability": "State access after external call (SWC 107)",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract CDEXStakingPool is ReentrancyGuard, Pausable {\n    using SafeMath for uint256;\n\n    // STATE VARIABLES\n    CDEXTokenContract public CDEXToken;\n    CDEXRankingContract public CDEXRanking;\n    uint256 public periodFinish = 0;\n    uint256 public rewardRate = 0;\n    uint256 public rewardsDuration = 0;\n    uint256 public lastUpdateTime;\n    uint256 public rewardPerTokenStored;\n    \n    \n    uint256 public loyaltyTier1 = 100000000 * 1e8;\n    uint256 public loyaltyTier2 = 10000000 * 1e8;\n    uint256 public loyaltyTier3 = 1000000 * 1e8;\n    \n    \n    uint256 public loyaltyTier1Bonus = 125;\n    uint256 public loyaltyTier2Bonus = 100;\n    uint256 public loyaltyTier3Bonus = 50;\n    uint256 public loyaltyBonusTotal = 275;\n    uint256 public depositedLoyaltyBonus;\n\n    mapping(address => uint256) public userRewardPerTokenPaid;\n    mapping(address => uint256) public rewards;\n    uint256 public depositedRewardTokens;\n\n    uint256 private _totalSupply;\n    mapping(address => uint256) private _balances;\n\n    uint256 public totalMembers;\n\n    \n    \n    \n    \n    \n    function CDEXStakingPool(\n        address _owner,\n        address _CDEXTokenContractAddress,\n        address _rankingContractAddress\n    ) public Owned(_owner) {\n        CDEXToken = CDEXTokenContract(_CDEXTokenContractAddress);\n        CDEXRanking = CDEXRankingContract(_rankingContractAddress);\n    }\n\n    \n    \n    \n    \n    function totalSupply() external view returns (uint256) {\n        return _totalSupply;\n    }\n\n    \n    \n    \n    function balanceOf(address account) external view returns (uint256) {\n        return _balances[account];\n    }\n\n    \n    \n    \n    function lastTimeRewardApplicable() public view returns (uint256) {\n        return min(block.timestamp, periodFinish);\n    }\n\n    \n    function rewardPerToken() public view returns (uint256) {\n        if (_totalSupply == 0) {\n            return rewardPerTokenStored;\n        }\n        return\n            rewardPerTokenStored.add(\n                lastTimeRewardApplicable()\n                    .sub(lastUpdateTime)\n                    .mul(rewardRate)\n                    .mul(1e8)\n                    .div(_totalSupply)\n            );\n    }\n\n    \n    \n    function earned(address account) public view returns (uint256) {\n        return\n            _balances[account]\n                .mul(rewardPerToken().sub(userRewardPerTokenPaid[account]))\n                .div(1e8)\n                .add(rewards[account]);\n    }\n\n    \n    function getRewardForDuration() external view returns (uint256) {\n        return rewardRate.mul(rewardsDuration);\n    }\n\n    \n    \n    \n    function min(uint256 a, uint256 b) public pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    \n    \n    function getLoyaltyTiers() external view returns(uint256 tier1, uint256 tier2, uint256 tier3)\n    {\n        return(loyaltyTier1, loyaltyTier2, loyaltyTier3);\n    }\n\n    \n    \n    \n    function getLoyaltyTiersBonus() external view returns(uint256 tier1Bonus, uint256 tier2Bonus, uint256 tier3Bonus)\n    {\n        return(loyaltyTier1Bonus, loyaltyTier2Bonus, loyaltyTier3Bonus);\n    }\n\n    // PUBLIC FUNCTIONS\n\n    \n    \n    // SWC-104-Unchecked Call Return Value: L362 - L391\n    function stake(uint256 amount)\n        external\n        nonReentrant\n        notPaused\n        updateReward(msg.sender)\n    {\n        require(amount > 0);\n        \n        _totalSupply = _totalSupply.add(amount);\n        \n        if(_balances[msg.sender] == 0) {\n            \n            totalMembers += 1;\n            \n            CDEXRanking.insert(amount, msg.sender);\n        } else {\n            \n            CDEXRanking.remove(_balances[msg.sender], msg.sender);\n            \n            CDEXRanking.insert(_balances[msg.sender].add(amount), msg.sender);\n        }\n        \n        _balances[msg.sender] = _balances[msg.sender].add(amount);\n        \n        \n        CDEXToken.transferFrom(msg.sender, address(this), amount);\n        \n        emit Staked(msg.sender, amount);\n    }\n\n    \n    \n    // SWC-104-Unchecked Call Return Value: L395 - L420\n    function withdraw(uint256 amount)\n        public\n        nonReentrant\n        updateReward(msg.sender)\n    {\n        require(amount > 0);\n        \n        _totalSupply = _totalSupply.sub(amount);\n        \n        CDEXRanking.remove(_balances[msg.sender], msg.sender);\n        \n        _balances[msg.sender] = _balances[msg.sender].sub(amount);\n        \n        if(_balances[msg.sender] == 0) {\n            totalMembers -= 1;\n        } else {\n            \n            CDEXRanking.insert(_balances[msg.sender], msg.sender);\n        }\n        \n        // SWC-104-Unchecked Call Return Value: L415\n        CDEXToken.transfer(msg.sender, amount);\n        \n        emit Withdrawn(msg.sender, amount);\n    }\n    \n    \n    // SWC-104-Unchecked Call Return Value: L424 - L456\n    function getReward() \n        public \n        nonReentrant \n        updateReward(msg.sender) \n    {\n        uint256 reward = rewards[msg.sender];\n        uint256 loyaltyBonus;\n        \n        if (reward > 0 && depositedRewardTokens >= reward) {\n            \n            rewards[msg.sender] = 0;\n            \n            depositedRewardTokens = depositedRewardTokens.sub(reward);\n            \n            if (_balances[msg.sender] >= loyaltyTier1) {\n                loyaltyBonus = reward.mul(loyaltyTier1Bonus).div(10000);\n            } else if (_balances[msg.sender] >= loyaltyTier2) {\n                loyaltyBonus = reward.mul(loyaltyTier2Bonus).div(10000);\n            } else if (_balances[msg.sender] >= loyaltyTier3) {\n                loyaltyBonus = reward.mul(loyaltyTier3Bonus).div(10000);\n            }\n            \n            depositedLoyaltyBonus = depositedLoyaltyBonus.sub(loyaltyBonus);\n            \n            CDEXToken.transfer(msg.sender, reward.add(loyaltyBonus));\n            \n            emit RewardPaid(msg.sender, reward);\n            \n            if(loyaltyBonus > 0) {\n                emit LoyaltyBonusPaid(msg.sender, loyaltyBonus);\n            }\n        }\n    }\n\n    \n    function exit() external {\n        withdraw(_balances[msg.sender]);\n        getReward();\n    }\n    \n    // RESTRICTED FUNCTIONS\n    \n    \n    \n    \n    function setTokenContract(address _contractAddress) public onlyOwner {\n        CDEXToken = CDEXTokenContract(_contractAddress);\n    }\n    \n    \n    \n    \n    function setRankingContract(address _contractAddress) public onlyOwner {\n        CDEXRanking = CDEXRankingContract(_contractAddress);\n    }\n    \n    \n    \n    \n    \n    \n    \n    // SWC-104-Unchecked Call Return Value: L486 - L498\n    function depositTokens(uint256 amount) public onlyOwner {\n        \n        amount = amount.mul(1e8);\n        \n        depositedLoyaltyBonus = depositedLoyaltyBonus.add(amount.mul(loyaltyBonusTotal).div(10000));\n        \n        depositedRewardTokens = depositedRewardTokens.add(amount);\n        \n        CDEXToken.transferFrom(owner, address(this), amount);\n        \n        emit RewardsDeposited(owner, address(this), amount);\n    }\n\n    \n    \n    \n    \n    function notifyRewardAmount(uint256 reward)\n        public\n        onlyOwner\n        updateReward(address(0))\n    {\n        \n        reward = reward.mul(1e8);\n        \n        \n        require(reward <= depositedRewardTokens.sub(reward.mul(loyaltyBonusTotal).div(10000)));\n        \n        \n        if (block.timestamp >= periodFinish) {\n            rewardRate = reward.div(rewardsDuration);\n        } else {\n            uint256 remaining = periodFinish.sub(block.timestamp);\n            uint256 leftover = remaining.mul(rewardRate);\n            rewardRate = reward.add(leftover).div(rewardsDuration);\n        }\n        \n        \n        \n        \n        require(rewardRate <= depositedRewardTokens.div(rewardsDuration));\n        \n        lastUpdateTime = block.timestamp;\n        \n        periodFinish = block.timestamp.add(rewardsDuration);\n        \n        emit RewardAdded(reward);\n    }\n\n    \n    \n    \n    function setRewardsDuration(uint256 _rewardsDuration) external onlyOwner {\n        \n        require(block.timestamp > periodFinish);\n        \n        rewardsDuration = _rewardsDuration;\n        \n        emit RewardsDurationUpdated(rewardsDuration);\n    }\n\n    \n    \n    \n    \n    function setLoyaltyTiers(\n        uint256 _loyaltyTier1, \n        uint256 _loyaltyTier2, \n        uint256 _loyaltyTier3\n    ) external onlyOwner \n    {\n        \n        loyaltyTier1 = _loyaltyTier1.mul(1e8);\n        loyaltyTier2 = _loyaltyTier2.mul(1e8);\n        loyaltyTier3 = _loyaltyTier3.mul(1e8);\n        \n        emit LoyaltyTiersUpdated(loyaltyTier1, loyaltyTier2, loyaltyTier3);\n    }\n\n    \n    \n    \n    \n    \n    \n    function setLoyaltyTiersBonus(\n        uint256 _loyaltyTier1Bonus, \n        uint256 _loyaltyTier2Bonus, \n        uint256 _loyaltyTier3Bonus\n    ) external onlyOwner \n    {\n        \n        \n        require(_loyaltyTier1Bonus.add(_loyaltyTier2Bonus).add(_loyaltyTier3Bonus) < 10000);\n        \n        loyaltyTier1Bonus = _loyaltyTier1Bonus;\n        loyaltyTier2Bonus = _loyaltyTier2Bonus;\n        loyaltyTier3Bonus = _loyaltyTier3Bonus;\n        \n        loyaltyBonusTotal = loyaltyTier1Bonus.add(loyaltyTier2Bonus).add(loyaltyTier3Bonus);\n        \n        emit LoyaltyTiersBonussUpdated(loyaltyTier1Bonus, loyaltyTier2Bonus, loyaltyTier3Bonus);\n    }\n\n    // MODIFIERS\n    \n    \n    \n    modifier updateReward(address account) {\n        rewardPerTokenStored = rewardPerToken();\n        lastUpdateTime = lastTimeRewardApplicable();\n        if (account != address(0)) {\n            rewards[account] = earned(account);\n            userRewardPerTokenPaid[account] = rewardPerTokenStored;\n        }\n        _;\n    }\n\n    // EVENTS\n\n    event RewardAdded(uint256 reward);\n    event Staked(address indexed user, uint256 amount);\n    event Withdrawn(address indexed user, uint256 amount);\n    event RewardPaid(address indexed user, uint256 reward);\n    event LoyaltyBonusPaid(address indexed user, uint256 loyaltyBonus);\n    event RewardsDurationUpdated(uint256 newDuration);\n    // SWC-135-Code With No Effects: L615\n    event Recovered(address token, uint256 amount);\n    event RewardsDeposited(address sender, address receiver, uint256 reward);\n    event LoyaltyTiersUpdated(uint256 loyaltyTier1, uint256 loyaltyTier2, uint256 loyaltyTier3);\n    event LoyaltyTiersBonussUpdated(uint256 loyaltyTier1Bonus, uint256 loyaltyTier2Bonus, uint256 loyaltyTier3Bonus);\n}",
        "function": "stake(uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Hacken-Codex on Althash/Codex-Rewards-Platform-d364d0ef9258dd468f8202a352c58724d6b65638/contracts/CDEX_rewards.sol",
        "vulnerability": "State access after external call (SWC 107)",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract CDEXStakingPool is ReentrancyGuard, Pausable {\n    using SafeMath for uint256;\n\n    // STATE VARIABLES\n    CDEXTokenContract public CDEXToken;\n    CDEXRankingContract public CDEXRanking;\n    uint256 public periodFinish = 0;\n    uint256 public rewardRate = 0;\n    uint256 public rewardsDuration = 0;\n    uint256 public lastUpdateTime;\n    uint256 public rewardPerTokenStored;\n    \n    \n    uint256 public loyaltyTier1 = 100000000 * 1e8;\n    uint256 public loyaltyTier2 = 10000000 * 1e8;\n    uint256 public loyaltyTier3 = 1000000 * 1e8;\n    \n    \n    uint256 public loyaltyTier1Bonus = 125;\n    uint256 public loyaltyTier2Bonus = 100;\n    uint256 public loyaltyTier3Bonus = 50;\n    uint256 public loyaltyBonusTotal = 275;\n    uint256 public depositedLoyaltyBonus;\n\n    mapping(address => uint256) public userRewardPerTokenPaid;\n    mapping(address => uint256) public rewards;\n    uint256 public depositedRewardTokens;\n\n    uint256 private _totalSupply;\n    mapping(address => uint256) private _balances;\n\n    uint256 public totalMembers;\n\n    \n    \n    \n    \n    \n    function CDEXStakingPool(\n        address _owner,\n        address _CDEXTokenContractAddress,\n        address _rankingContractAddress\n    ) public Owned(_owner) {\n        CDEXToken = CDEXTokenContract(_CDEXTokenContractAddress);\n        CDEXRanking = CDEXRankingContract(_rankingContractAddress);\n    }\n\n    \n    \n    \n    \n    function totalSupply() external view returns (uint256) {\n        return _totalSupply;\n    }\n\n    \n    \n    \n    function balanceOf(address account) external view returns (uint256) {\n        return _balances[account];\n    }\n\n    \n    \n    \n    function lastTimeRewardApplicable() public view returns (uint256) {\n        return min(block.timestamp, periodFinish);\n    }\n\n    \n    function rewardPerToken() public view returns (uint256) {\n        if (_totalSupply == 0) {\n            return rewardPerTokenStored;\n        }\n        return\n            rewardPerTokenStored.add(\n                lastTimeRewardApplicable()\n                    .sub(lastUpdateTime)\n                    .mul(rewardRate)\n                    .mul(1e8)\n                    .div(_totalSupply)\n            );\n    }\n\n    \n    \n    function earned(address account) public view returns (uint256) {\n        return\n            _balances[account]\n                .mul(rewardPerToken().sub(userRewardPerTokenPaid[account]))\n                .div(1e8)\n                .add(rewards[account]);\n    }\n\n    \n    function getRewardForDuration() external view returns (uint256) {\n        return rewardRate.mul(rewardsDuration);\n    }\n\n    \n    \n    \n    function min(uint256 a, uint256 b) public pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    \n    \n    function getLoyaltyTiers() external view returns(uint256 tier1, uint256 tier2, uint256 tier3)\n    {\n        return(loyaltyTier1, loyaltyTier2, loyaltyTier3);\n    }\n\n    \n    \n    \n    function getLoyaltyTiersBonus() external view returns(uint256 tier1Bonus, uint256 tier2Bonus, uint256 tier3Bonus)\n    {\n        return(loyaltyTier1Bonus, loyaltyTier2Bonus, loyaltyTier3Bonus);\n    }\n\n    // PUBLIC FUNCTIONS\n\n    \n    \n    // SWC-104-Unchecked Call Return Value: L362 - L391\n    function stake(uint256 amount)\n        external\n        nonReentrant\n        notPaused\n        updateReward(msg.sender)\n    {\n        require(amount > 0);\n        \n        _totalSupply = _totalSupply.add(amount);\n        \n        if(_balances[msg.sender] == 0) {\n            \n            totalMembers += 1;\n            \n            CDEXRanking.insert(amount, msg.sender);\n        } else {\n            \n            CDEXRanking.remove(_balances[msg.sender], msg.sender);\n            \n            CDEXRanking.insert(_balances[msg.sender].add(amount), msg.sender);\n        }\n        \n        _balances[msg.sender] = _balances[msg.sender].add(amount);\n        \n        \n        CDEXToken.transferFrom(msg.sender, address(this), amount);\n        \n        emit Staked(msg.sender, amount);\n    }\n\n    \n    \n    // SWC-104-Unchecked Call Return Value: L395 - L420\n    function withdraw(uint256 amount)\n        public\n        nonReentrant\n        updateReward(msg.sender)\n    {\n        require(amount > 0);\n        \n        _totalSupply = _totalSupply.sub(amount);\n        \n        CDEXRanking.remove(_balances[msg.sender], msg.sender);\n        \n        _balances[msg.sender] = _balances[msg.sender].sub(amount);\n        \n        if(_balances[msg.sender] == 0) {\n            totalMembers -= 1;\n        } else {\n            \n            CDEXRanking.insert(_balances[msg.sender], msg.sender);\n        }\n        \n        // SWC-104-Unchecked Call Return Value: L415\n        CDEXToken.transfer(msg.sender, amount);\n        \n        emit Withdrawn(msg.sender, amount);\n    }\n    \n    \n    // SWC-104-Unchecked Call Return Value: L424 - L456\n    function getReward() \n        public \n        nonReentrant \n        updateReward(msg.sender) \n    {\n        uint256 reward = rewards[msg.sender];\n        uint256 loyaltyBonus;\n        \n        if (reward > 0 && depositedRewardTokens >= reward) {\n            \n            rewards[msg.sender] = 0;\n            \n            depositedRewardTokens = depositedRewardTokens.sub(reward);\n            \n            if (_balances[msg.sender] >= loyaltyTier1) {\n                loyaltyBonus = reward.mul(loyaltyTier1Bonus).div(10000);\n            } else if (_balances[msg.sender] >= loyaltyTier2) {\n                loyaltyBonus = reward.mul(loyaltyTier2Bonus).div(10000);\n            } else if (_balances[msg.sender] >= loyaltyTier3) {\n                loyaltyBonus = reward.mul(loyaltyTier3Bonus).div(10000);\n            }\n            \n            depositedLoyaltyBonus = depositedLoyaltyBonus.sub(loyaltyBonus);\n            \n            CDEXToken.transfer(msg.sender, reward.add(loyaltyBonus));\n            \n            emit RewardPaid(msg.sender, reward);\n            \n            if(loyaltyBonus > 0) {\n                emit LoyaltyBonusPaid(msg.sender, loyaltyBonus);\n            }\n        }\n    }\n\n    \n    function exit() external {\n        withdraw(_balances[msg.sender]);\n        getReward();\n    }\n    \n    // RESTRICTED FUNCTIONS\n    \n    \n    \n    \n    function setTokenContract(address _contractAddress) public onlyOwner {\n        CDEXToken = CDEXTokenContract(_contractAddress);\n    }\n    \n    \n    \n    \n    function setRankingContract(address _contractAddress) public onlyOwner {\n        CDEXRanking = CDEXRankingContract(_contractAddress);\n    }\n    \n    \n    \n    \n    \n    \n    \n    // SWC-104-Unchecked Call Return Value: L486 - L498\n    function depositTokens(uint256 amount) public onlyOwner {\n        \n        amount = amount.mul(1e8);\n        \n        depositedLoyaltyBonus = depositedLoyaltyBonus.add(amount.mul(loyaltyBonusTotal).div(10000));\n        \n        depositedRewardTokens = depositedRewardTokens.add(amount);\n        \n        CDEXToken.transferFrom(owner, address(this), amount);\n        \n        emit RewardsDeposited(owner, address(this), amount);\n    }\n\n    \n    \n    \n    \n    function notifyRewardAmount(uint256 reward)\n        public\n        onlyOwner\n        updateReward(address(0))\n    {\n        \n        reward = reward.mul(1e8);\n        \n        \n        require(reward <= depositedRewardTokens.sub(reward.mul(loyaltyBonusTotal).div(10000)));\n        \n        \n        if (block.timestamp >= periodFinish) {\n            rewardRate = reward.div(rewardsDuration);\n        } else {\n            uint256 remaining = periodFinish.sub(block.timestamp);\n            uint256 leftover = remaining.mul(rewardRate);\n            rewardRate = reward.add(leftover).div(rewardsDuration);\n        }\n        \n        \n        \n        \n        require(rewardRate <= depositedRewardTokens.div(rewardsDuration));\n        \n        lastUpdateTime = block.timestamp;\n        \n        periodFinish = block.timestamp.add(rewardsDuration);\n        \n        emit RewardAdded(reward);\n    }\n\n    \n    \n    \n    function setRewardsDuration(uint256 _rewardsDuration) external onlyOwner {\n        \n        require(block.timestamp > periodFinish);\n        \n        rewardsDuration = _rewardsDuration;\n        \n        emit RewardsDurationUpdated(rewardsDuration);\n    }\n\n    \n    \n    \n    \n    function setLoyaltyTiers(\n        uint256 _loyaltyTier1, \n        uint256 _loyaltyTier2, \n        uint256 _loyaltyTier3\n    ) external onlyOwner \n    {\n        \n        loyaltyTier1 = _loyaltyTier1.mul(1e8);\n        loyaltyTier2 = _loyaltyTier2.mul(1e8);\n        loyaltyTier3 = _loyaltyTier3.mul(1e8);\n        \n        emit LoyaltyTiersUpdated(loyaltyTier1, loyaltyTier2, loyaltyTier3);\n    }\n\n    \n    \n    \n    \n    \n    \n    function setLoyaltyTiersBonus(\n        uint256 _loyaltyTier1Bonus, \n        uint256 _loyaltyTier2Bonus, \n        uint256 _loyaltyTier3Bonus\n    ) external onlyOwner \n    {\n        \n        \n        require(_loyaltyTier1Bonus.add(_loyaltyTier2Bonus).add(_loyaltyTier3Bonus) < 10000);\n        \n        loyaltyTier1Bonus = _loyaltyTier1Bonus;\n        loyaltyTier2Bonus = _loyaltyTier2Bonus;\n        loyaltyTier3Bonus = _loyaltyTier3Bonus;\n        \n        loyaltyBonusTotal = loyaltyTier1Bonus.add(loyaltyTier2Bonus).add(loyaltyTier3Bonus);\n        \n        emit LoyaltyTiersBonussUpdated(loyaltyTier1Bonus, loyaltyTier2Bonus, loyaltyTier3Bonus);\n    }\n\n    // MODIFIERS\n    \n    \n    \n    modifier updateReward(address account) {\n        rewardPerTokenStored = rewardPerToken();\n        lastUpdateTime = lastTimeRewardApplicable();\n        if (account != address(0)) {\n            rewards[account] = earned(account);\n            userRewardPerTokenPaid[account] = rewardPerTokenStored;\n        }\n        _;\n    }\n\n    // EVENTS\n\n    event RewardAdded(uint256 reward);\n    event Staked(address indexed user, uint256 amount);\n    event Withdrawn(address indexed user, uint256 amount);\n    event RewardPaid(address indexed user, uint256 reward);\n    event LoyaltyBonusPaid(address indexed user, uint256 loyaltyBonus);\n    event RewardsDurationUpdated(uint256 newDuration);\n    // SWC-135-Code With No Effects: L615\n    event Recovered(address token, uint256 amount);\n    event RewardsDeposited(address sender, address receiver, uint256 reward);\n    event LoyaltyTiersUpdated(uint256 loyaltyTier1, uint256 loyaltyTier2, uint256 loyaltyTier3);\n    event LoyaltyTiersBonussUpdated(uint256 loyaltyTier1Bonus, uint256 loyaltyTier2Bonus, uint256 loyaltyTier3Bonus);\n}",
        "function": "stake(uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Hacken-Codex on Althash/Codex-Rewards-Platform-d364d0ef9258dd468f8202a352c58724d6b65638/contracts/CDEX_rewards.sol",
        "vulnerability": "External Call To User-Supplied Address (SWC 107)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract CDEXStakingPool is ReentrancyGuard, Pausable {\n    using SafeMath for uint256;\n\n    // STATE VARIABLES\n    CDEXTokenContract public CDEXToken;\n    CDEXRankingContract public CDEXRanking;\n    uint256 public periodFinish = 0;\n    uint256 public rewardRate = 0;\n    uint256 public rewardsDuration = 0;\n    uint256 public lastUpdateTime;\n    uint256 public rewardPerTokenStored;\n    \n    \n    uint256 public loyaltyTier1 = 100000000 * 1e8;\n    uint256 public loyaltyTier2 = 10000000 * 1e8;\n    uint256 public loyaltyTier3 = 1000000 * 1e8;\n    \n    \n    uint256 public loyaltyTier1Bonus = 125;\n    uint256 public loyaltyTier2Bonus = 100;\n    uint256 public loyaltyTier3Bonus = 50;\n    uint256 public loyaltyBonusTotal = 275;\n    uint256 public depositedLoyaltyBonus;\n\n    mapping(address => uint256) public userRewardPerTokenPaid;\n    mapping(address => uint256) public rewards;\n    uint256 public depositedRewardTokens;\n\n    uint256 private _totalSupply;\n    mapping(address => uint256) private _balances;\n\n    uint256 public totalMembers;\n\n    \n    \n    \n    \n    \n    function CDEXStakingPool(\n        address _owner,\n        address _CDEXTokenContractAddress,\n        address _rankingContractAddress\n    ) public Owned(_owner) {\n        CDEXToken = CDEXTokenContract(_CDEXTokenContractAddress);\n        CDEXRanking = CDEXRankingContract(_rankingContractAddress);\n    }\n\n    \n    \n    \n    \n    function totalSupply() external view returns (uint256) {\n        return _totalSupply;\n    }\n\n    \n    \n    \n    function balanceOf(address account) external view returns (uint256) {\n        return _balances[account];\n    }\n\n    \n    \n    \n    function lastTimeRewardApplicable() public view returns (uint256) {\n        return min(block.timestamp, periodFinish);\n    }\n\n    \n    function rewardPerToken() public view returns (uint256) {\n        if (_totalSupply == 0) {\n            return rewardPerTokenStored;\n        }\n        return\n            rewardPerTokenStored.add(\n                lastTimeRewardApplicable()\n                    .sub(lastUpdateTime)\n                    .mul(rewardRate)\n                    .mul(1e8)\n                    .div(_totalSupply)\n            );\n    }\n\n    \n    \n    function earned(address account) public view returns (uint256) {\n        return\n            _balances[account]\n                .mul(rewardPerToken().sub(userRewardPerTokenPaid[account]))\n                .div(1e8)\n                .add(rewards[account]);\n    }\n\n    \n    function getRewardForDuration() external view returns (uint256) {\n        return rewardRate.mul(rewardsDuration);\n    }\n\n    \n    \n    \n    function min(uint256 a, uint256 b) public pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    \n    \n    function getLoyaltyTiers() external view returns(uint256 tier1, uint256 tier2, uint256 tier3)\n    {\n        return(loyaltyTier1, loyaltyTier2, loyaltyTier3);\n    }\n\n    \n    \n    \n    function getLoyaltyTiersBonus() external view returns(uint256 tier1Bonus, uint256 tier2Bonus, uint256 tier3Bonus)\n    {\n        return(loyaltyTier1Bonus, loyaltyTier2Bonus, loyaltyTier3Bonus);\n    }\n\n    // PUBLIC FUNCTIONS\n\n    \n    \n    // SWC-104-Unchecked Call Return Value: L362 - L391\n    function stake(uint256 amount)\n        external\n        nonReentrant\n        notPaused\n        updateReward(msg.sender)\n    {\n        require(amount > 0);\n        \n        _totalSupply = _totalSupply.add(amount);\n        \n        if(_balances[msg.sender] == 0) {\n            \n            totalMembers += 1;\n            \n            CDEXRanking.insert(amount, msg.sender);\n        } else {\n            \n            CDEXRanking.remove(_balances[msg.sender], msg.sender);\n            \n            CDEXRanking.insert(_balances[msg.sender].add(amount), msg.sender);\n        }\n        \n        _balances[msg.sender] = _balances[msg.sender].add(amount);\n        \n        \n        CDEXToken.transferFrom(msg.sender, address(this), amount);\n        \n        emit Staked(msg.sender, amount);\n    }\n\n    \n    \n    // SWC-104-Unchecked Call Return Value: L395 - L420\n    function withdraw(uint256 amount)\n        public\n        nonReentrant\n        updateReward(msg.sender)\n    {\n        require(amount > 0);\n        \n        _totalSupply = _totalSupply.sub(amount);\n        \n        CDEXRanking.remove(_balances[msg.sender], msg.sender);\n        \n        _balances[msg.sender] = _balances[msg.sender].sub(amount);\n        \n        if(_balances[msg.sender] == 0) {\n            totalMembers -= 1;\n        } else {\n            \n            CDEXRanking.insert(_balances[msg.sender], msg.sender);\n        }\n        \n        // SWC-104-Unchecked Call Return Value: L415\n        CDEXToken.transfer(msg.sender, amount);\n        \n        emit Withdrawn(msg.sender, amount);\n    }\n    \n    \n    // SWC-104-Unchecked Call Return Value: L424 - L456\n    function getReward() \n        public \n        nonReentrant \n        updateReward(msg.sender) \n    {\n        uint256 reward = rewards[msg.sender];\n        uint256 loyaltyBonus;\n        \n        if (reward > 0 && depositedRewardTokens >= reward) {\n            \n            rewards[msg.sender] = 0;\n            \n            depositedRewardTokens = depositedRewardTokens.sub(reward);\n            \n            if (_balances[msg.sender] >= loyaltyTier1) {\n                loyaltyBonus = reward.mul(loyaltyTier1Bonus).div(10000);\n            } else if (_balances[msg.sender] >= loyaltyTier2) {\n                loyaltyBonus = reward.mul(loyaltyTier2Bonus).div(10000);\n            } else if (_balances[msg.sender] >= loyaltyTier3) {\n                loyaltyBonus = reward.mul(loyaltyTier3Bonus).div(10000);\n            }\n            \n            depositedLoyaltyBonus = depositedLoyaltyBonus.sub(loyaltyBonus);\n            \n            CDEXToken.transfer(msg.sender, reward.add(loyaltyBonus));\n            \n            emit RewardPaid(msg.sender, reward);\n            \n            if(loyaltyBonus > 0) {\n                emit LoyaltyBonusPaid(msg.sender, loyaltyBonus);\n            }\n        }\n    }\n\n    \n    function exit() external {\n        withdraw(_balances[msg.sender]);\n        getReward();\n    }\n    \n    // RESTRICTED FUNCTIONS\n    \n    \n    \n    \n    function setTokenContract(address _contractAddress) public onlyOwner {\n        CDEXToken = CDEXTokenContract(_contractAddress);\n    }\n    \n    \n    \n    \n    function setRankingContract(address _contractAddress) public onlyOwner {\n        CDEXRanking = CDEXRankingContract(_contractAddress);\n    }\n    \n    \n    \n    \n    \n    \n    \n    // SWC-104-Unchecked Call Return Value: L486 - L498\n    function depositTokens(uint256 amount) public onlyOwner {\n        \n        amount = amount.mul(1e8);\n        \n        depositedLoyaltyBonus = depositedLoyaltyBonus.add(amount.mul(loyaltyBonusTotal).div(10000));\n        \n        depositedRewardTokens = depositedRewardTokens.add(amount);\n        \n        CDEXToken.transferFrom(owner, address(this), amount);\n        \n        emit RewardsDeposited(owner, address(this), amount);\n    }\n\n    \n    \n    \n    \n    function notifyRewardAmount(uint256 reward)\n        public\n        onlyOwner\n        updateReward(address(0))\n    {\n        \n        reward = reward.mul(1e8);\n        \n        \n        require(reward <= depositedRewardTokens.sub(reward.mul(loyaltyBonusTotal).div(10000)));\n        \n        \n        if (block.timestamp >= periodFinish) {\n            rewardRate = reward.div(rewardsDuration);\n        } else {\n            uint256 remaining = periodFinish.sub(block.timestamp);\n            uint256 leftover = remaining.mul(rewardRate);\n            rewardRate = reward.add(leftover).div(rewardsDuration);\n        }\n        \n        \n        \n        \n        require(rewardRate <= depositedRewardTokens.div(rewardsDuration));\n        \n        lastUpdateTime = block.timestamp;\n        \n        periodFinish = block.timestamp.add(rewardsDuration);\n        \n        emit RewardAdded(reward);\n    }\n\n    \n    \n    \n    function setRewardsDuration(uint256 _rewardsDuration) external onlyOwner {\n        \n        require(block.timestamp > periodFinish);\n        \n        rewardsDuration = _rewardsDuration;\n        \n        emit RewardsDurationUpdated(rewardsDuration);\n    }\n\n    \n    \n    \n    \n    function setLoyaltyTiers(\n        uint256 _loyaltyTier1, \n        uint256 _loyaltyTier2, \n        uint256 _loyaltyTier3\n    ) external onlyOwner \n    {\n        \n        loyaltyTier1 = _loyaltyTier1.mul(1e8);\n        loyaltyTier2 = _loyaltyTier2.mul(1e8);\n        loyaltyTier3 = _loyaltyTier3.mul(1e8);\n        \n        emit LoyaltyTiersUpdated(loyaltyTier1, loyaltyTier2, loyaltyTier3);\n    }\n\n    \n    \n    \n    \n    \n    \n    function setLoyaltyTiersBonus(\n        uint256 _loyaltyTier1Bonus, \n        uint256 _loyaltyTier2Bonus, \n        uint256 _loyaltyTier3Bonus\n    ) external onlyOwner \n    {\n        \n        \n        require(_loyaltyTier1Bonus.add(_loyaltyTier2Bonus).add(_loyaltyTier3Bonus) < 10000);\n        \n        loyaltyTier1Bonus = _loyaltyTier1Bonus;\n        loyaltyTier2Bonus = _loyaltyTier2Bonus;\n        loyaltyTier3Bonus = _loyaltyTier3Bonus;\n        \n        loyaltyBonusTotal = loyaltyTier1Bonus.add(loyaltyTier2Bonus).add(loyaltyTier3Bonus);\n        \n        emit LoyaltyTiersBonussUpdated(loyaltyTier1Bonus, loyaltyTier2Bonus, loyaltyTier3Bonus);\n    }\n\n    // MODIFIERS\n    \n    \n    \n    modifier updateReward(address account) {\n        rewardPerTokenStored = rewardPerToken();\n        lastUpdateTime = lastTimeRewardApplicable();\n        if (account != address(0)) {\n            rewards[account] = earned(account);\n            userRewardPerTokenPaid[account] = rewardPerTokenStored;\n        }\n        _;\n    }\n\n    // EVENTS\n\n    event RewardAdded(uint256 reward);\n    event Staked(address indexed user, uint256 amount);\n    event Withdrawn(address indexed user, uint256 amount);\n    event RewardPaid(address indexed user, uint256 reward);\n    event LoyaltyBonusPaid(address indexed user, uint256 loyaltyBonus);\n    event RewardsDurationUpdated(uint256 newDuration);\n    // SWC-135-Code With No Effects: L615\n    event Recovered(address token, uint256 amount);\n    event RewardsDeposited(address sender, address receiver, uint256 reward);\n    event LoyaltyTiersUpdated(uint256 loyaltyTier1, uint256 loyaltyTier2, uint256 loyaltyTier3);\n    event LoyaltyTiersBonussUpdated(uint256 loyaltyTier1Bonus, uint256 loyaltyTier2Bonus, uint256 loyaltyTier3Bonus);\n}",
        "function": "stake(uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Hacken-Codex on Althash/Codex-Rewards-Platform-d364d0ef9258dd468f8202a352c58724d6b65638/contracts/CDEX_rewards.sol",
        "vulnerability": "Multiple Calls in a Single Transaction (SWC 113)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract CDEXStakingPool is ReentrancyGuard, Pausable {\n    using SafeMath for uint256;\n\n    // STATE VARIABLES\n    CDEXTokenContract public CDEXToken;\n    CDEXRankingContract public CDEXRanking;\n    uint256 public periodFinish = 0;\n    uint256 public rewardRate = 0;\n    uint256 public rewardsDuration = 0;\n    uint256 public lastUpdateTime;\n    uint256 public rewardPerTokenStored;\n    \n    \n    uint256 public loyaltyTier1 = 100000000 * 1e8;\n    uint256 public loyaltyTier2 = 10000000 * 1e8;\n    uint256 public loyaltyTier3 = 1000000 * 1e8;\n    \n    \n    uint256 public loyaltyTier1Bonus = 125;\n    uint256 public loyaltyTier2Bonus = 100;\n    uint256 public loyaltyTier3Bonus = 50;\n    uint256 public loyaltyBonusTotal = 275;\n    uint256 public depositedLoyaltyBonus;\n\n    mapping(address => uint256) public userRewardPerTokenPaid;\n    mapping(address => uint256) public rewards;\n    uint256 public depositedRewardTokens;\n\n    uint256 private _totalSupply;\n    mapping(address => uint256) private _balances;\n\n    uint256 public totalMembers;\n\n    \n    \n    \n    \n    \n    function CDEXStakingPool(\n        address _owner,\n        address _CDEXTokenContractAddress,\n        address _rankingContractAddress\n    ) public Owned(_owner) {\n        CDEXToken = CDEXTokenContract(_CDEXTokenContractAddress);\n        CDEXRanking = CDEXRankingContract(_rankingContractAddress);\n    }\n\n    \n    \n    \n    \n    function totalSupply() external view returns (uint256) {\n        return _totalSupply;\n    }\n\n    \n    \n    \n    function balanceOf(address account) external view returns (uint256) {\n        return _balances[account];\n    }\n\n    \n    \n    \n    function lastTimeRewardApplicable() public view returns (uint256) {\n        return min(block.timestamp, periodFinish);\n    }\n\n    \n    function rewardPerToken() public view returns (uint256) {\n        if (_totalSupply == 0) {\n            return rewardPerTokenStored;\n        }\n        return\n            rewardPerTokenStored.add(\n                lastTimeRewardApplicable()\n                    .sub(lastUpdateTime)\n                    .mul(rewardRate)\n                    .mul(1e8)\n                    .div(_totalSupply)\n            );\n    }\n\n    \n    \n    function earned(address account) public view returns (uint256) {\n        return\n            _balances[account]\n                .mul(rewardPerToken().sub(userRewardPerTokenPaid[account]))\n                .div(1e8)\n                .add(rewards[account]);\n    }\n\n    \n    function getRewardForDuration() external view returns (uint256) {\n        return rewardRate.mul(rewardsDuration);\n    }\n\n    \n    \n    \n    function min(uint256 a, uint256 b) public pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    \n    \n    function getLoyaltyTiers() external view returns(uint256 tier1, uint256 tier2, uint256 tier3)\n    {\n        return(loyaltyTier1, loyaltyTier2, loyaltyTier3);\n    }\n\n    \n    \n    \n    function getLoyaltyTiersBonus() external view returns(uint256 tier1Bonus, uint256 tier2Bonus, uint256 tier3Bonus)\n    {\n        return(loyaltyTier1Bonus, loyaltyTier2Bonus, loyaltyTier3Bonus);\n    }\n\n    // PUBLIC FUNCTIONS\n\n    \n    \n    // SWC-104-Unchecked Call Return Value: L362 - L391\n    function stake(uint256 amount)\n        external\n        nonReentrant\n        notPaused\n        updateReward(msg.sender)\n    {\n        require(amount > 0);\n        \n        _totalSupply = _totalSupply.add(amount);\n        \n        if(_balances[msg.sender] == 0) {\n            \n            totalMembers += 1;\n            \n            CDEXRanking.insert(amount, msg.sender);\n        } else {\n            \n            CDEXRanking.remove(_balances[msg.sender], msg.sender);\n            \n            CDEXRanking.insert(_balances[msg.sender].add(amount), msg.sender);\n        }\n        \n        _balances[msg.sender] = _balances[msg.sender].add(amount);\n        \n        \n        CDEXToken.transferFrom(msg.sender, address(this), amount);\n        \n        emit Staked(msg.sender, amount);\n    }\n\n    \n    \n    // SWC-104-Unchecked Call Return Value: L395 - L420\n    function withdraw(uint256 amount)\n        public\n        nonReentrant\n        updateReward(msg.sender)\n    {\n        require(amount > 0);\n        \n        _totalSupply = _totalSupply.sub(amount);\n        \n        CDEXRanking.remove(_balances[msg.sender], msg.sender);\n        \n        _balances[msg.sender] = _balances[msg.sender].sub(amount);\n        \n        if(_balances[msg.sender] == 0) {\n            totalMembers -= 1;\n        } else {\n            \n            CDEXRanking.insert(_balances[msg.sender], msg.sender);\n        }\n        \n        // SWC-104-Unchecked Call Return Value: L415\n        CDEXToken.transfer(msg.sender, amount);\n        \n        emit Withdrawn(msg.sender, amount);\n    }\n    \n    \n    // SWC-104-Unchecked Call Return Value: L424 - L456\n    function getReward() \n        public \n        nonReentrant \n        updateReward(msg.sender) \n    {\n        uint256 reward = rewards[msg.sender];\n        uint256 loyaltyBonus;\n        \n        if (reward > 0 && depositedRewardTokens >= reward) {\n            \n            rewards[msg.sender] = 0;\n            \n            depositedRewardTokens = depositedRewardTokens.sub(reward);\n            \n            if (_balances[msg.sender] >= loyaltyTier1) {\n                loyaltyBonus = reward.mul(loyaltyTier1Bonus).div(10000);\n            } else if (_balances[msg.sender] >= loyaltyTier2) {\n                loyaltyBonus = reward.mul(loyaltyTier2Bonus).div(10000);\n            } else if (_balances[msg.sender] >= loyaltyTier3) {\n                loyaltyBonus = reward.mul(loyaltyTier3Bonus).div(10000);\n            }\n            \n            depositedLoyaltyBonus = depositedLoyaltyBonus.sub(loyaltyBonus);\n            \n            CDEXToken.transfer(msg.sender, reward.add(loyaltyBonus));\n            \n            emit RewardPaid(msg.sender, reward);\n            \n            if(loyaltyBonus > 0) {\n                emit LoyaltyBonusPaid(msg.sender, loyaltyBonus);\n            }\n        }\n    }\n\n    \n    function exit() external {\n        withdraw(_balances[msg.sender]);\n        getReward();\n    }\n    \n    // RESTRICTED FUNCTIONS\n    \n    \n    \n    \n    function setTokenContract(address _contractAddress) public onlyOwner {\n        CDEXToken = CDEXTokenContract(_contractAddress);\n    }\n    \n    \n    \n    \n    function setRankingContract(address _contractAddress) public onlyOwner {\n        CDEXRanking = CDEXRankingContract(_contractAddress);\n    }\n    \n    \n    \n    \n    \n    \n    \n    // SWC-104-Unchecked Call Return Value: L486 - L498\n    function depositTokens(uint256 amount) public onlyOwner {\n        \n        amount = amount.mul(1e8);\n        \n        depositedLoyaltyBonus = depositedLoyaltyBonus.add(amount.mul(loyaltyBonusTotal).div(10000));\n        \n        depositedRewardTokens = depositedRewardTokens.add(amount);\n        \n        CDEXToken.transferFrom(owner, address(this), amount);\n        \n        emit RewardsDeposited(owner, address(this), amount);\n    }\n\n    \n    \n    \n    \n    function notifyRewardAmount(uint256 reward)\n        public\n        onlyOwner\n        updateReward(address(0))\n    {\n        \n        reward = reward.mul(1e8);\n        \n        \n        require(reward <= depositedRewardTokens.sub(reward.mul(loyaltyBonusTotal).div(10000)));\n        \n        \n        if (block.timestamp >= periodFinish) {\n            rewardRate = reward.div(rewardsDuration);\n        } else {\n            uint256 remaining = periodFinish.sub(block.timestamp);\n            uint256 leftover = remaining.mul(rewardRate);\n            rewardRate = reward.add(leftover).div(rewardsDuration);\n        }\n        \n        \n        \n        \n        require(rewardRate <= depositedRewardTokens.div(rewardsDuration));\n        \n        lastUpdateTime = block.timestamp;\n        \n        periodFinish = block.timestamp.add(rewardsDuration);\n        \n        emit RewardAdded(reward);\n    }\n\n    \n    \n    \n    function setRewardsDuration(uint256 _rewardsDuration) external onlyOwner {\n        \n        require(block.timestamp > periodFinish);\n        \n        rewardsDuration = _rewardsDuration;\n        \n        emit RewardsDurationUpdated(rewardsDuration);\n    }\n\n    \n    \n    \n    \n    function setLoyaltyTiers(\n        uint256 _loyaltyTier1, \n        uint256 _loyaltyTier2, \n        uint256 _loyaltyTier3\n    ) external onlyOwner \n    {\n        \n        loyaltyTier1 = _loyaltyTier1.mul(1e8);\n        loyaltyTier2 = _loyaltyTier2.mul(1e8);\n        loyaltyTier3 = _loyaltyTier3.mul(1e8);\n        \n        emit LoyaltyTiersUpdated(loyaltyTier1, loyaltyTier2, loyaltyTier3);\n    }\n\n    \n    \n    \n    \n    \n    \n    function setLoyaltyTiersBonus(\n        uint256 _loyaltyTier1Bonus, \n        uint256 _loyaltyTier2Bonus, \n        uint256 _loyaltyTier3Bonus\n    ) external onlyOwner \n    {\n        \n        \n        require(_loyaltyTier1Bonus.add(_loyaltyTier2Bonus).add(_loyaltyTier3Bonus) < 10000);\n        \n        loyaltyTier1Bonus = _loyaltyTier1Bonus;\n        loyaltyTier2Bonus = _loyaltyTier2Bonus;\n        loyaltyTier3Bonus = _loyaltyTier3Bonus;\n        \n        loyaltyBonusTotal = loyaltyTier1Bonus.add(loyaltyTier2Bonus).add(loyaltyTier3Bonus);\n        \n        emit LoyaltyTiersBonussUpdated(loyaltyTier1Bonus, loyaltyTier2Bonus, loyaltyTier3Bonus);\n    }\n\n    // MODIFIERS\n    \n    \n    \n    modifier updateReward(address account) {\n        rewardPerTokenStored = rewardPerToken();\n        lastUpdateTime = lastTimeRewardApplicable();\n        if (account != address(0)) {\n            rewards[account] = earned(account);\n            userRewardPerTokenPaid[account] = rewardPerTokenStored;\n        }\n        _;\n    }\n\n    // EVENTS\n\n    event RewardAdded(uint256 reward);\n    event Staked(address indexed user, uint256 amount);\n    event Withdrawn(address indexed user, uint256 amount);\n    event RewardPaid(address indexed user, uint256 reward);\n    event LoyaltyBonusPaid(address indexed user, uint256 loyaltyBonus);\n    event RewardsDurationUpdated(uint256 newDuration);\n    // SWC-135-Code With No Effects: L615\n    event Recovered(address token, uint256 amount);\n    event RewardsDeposited(address sender, address receiver, uint256 reward);\n    event LoyaltyTiersUpdated(uint256 loyaltyTier1, uint256 loyaltyTier2, uint256 loyaltyTier3);\n    event LoyaltyTiersBonussUpdated(uint256 loyaltyTier1Bonus, uint256 loyaltyTier2Bonus, uint256 loyaltyTier3Bonus);\n}",
        "function": "stake(uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Hacken-Codex on Althash/Codex-Rewards-Platform-d364d0ef9258dd468f8202a352c58724d6b65638/contracts/CDEX_rewards.sol",
        "vulnerability": "State access after external call (SWC 107)",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract CDEXStakingPool is ReentrancyGuard, Pausable {\n    using SafeMath for uint256;\n\n    // STATE VARIABLES\n    CDEXTokenContract public CDEXToken;\n    CDEXRankingContract public CDEXRanking;\n    uint256 public periodFinish = 0;\n    uint256 public rewardRate = 0;\n    uint256 public rewardsDuration = 0;\n    uint256 public lastUpdateTime;\n    uint256 public rewardPerTokenStored;\n    \n    \n    uint256 public loyaltyTier1 = 100000000 * 1e8;\n    uint256 public loyaltyTier2 = 10000000 * 1e8;\n    uint256 public loyaltyTier3 = 1000000 * 1e8;\n    \n    \n    uint256 public loyaltyTier1Bonus = 125;\n    uint256 public loyaltyTier2Bonus = 100;\n    uint256 public loyaltyTier3Bonus = 50;\n    uint256 public loyaltyBonusTotal = 275;\n    uint256 public depositedLoyaltyBonus;\n\n    mapping(address => uint256) public userRewardPerTokenPaid;\n    mapping(address => uint256) public rewards;\n    uint256 public depositedRewardTokens;\n\n    uint256 private _totalSupply;\n    mapping(address => uint256) private _balances;\n\n    uint256 public totalMembers;\n\n    \n    \n    \n    \n    \n    function CDEXStakingPool(\n        address _owner,\n        address _CDEXTokenContractAddress,\n        address _rankingContractAddress\n    ) public Owned(_owner) {\n        CDEXToken = CDEXTokenContract(_CDEXTokenContractAddress);\n        CDEXRanking = CDEXRankingContract(_rankingContractAddress);\n    }\n\n    \n    \n    \n    \n    function totalSupply() external view returns (uint256) {\n        return _totalSupply;\n    }\n\n    \n    \n    \n    function balanceOf(address account) external view returns (uint256) {\n        return _balances[account];\n    }\n\n    \n    \n    \n    function lastTimeRewardApplicable() public view returns (uint256) {\n        return min(block.timestamp, periodFinish);\n    }\n\n    \n    function rewardPerToken() public view returns (uint256) {\n        if (_totalSupply == 0) {\n            return rewardPerTokenStored;\n        }\n        return\n            rewardPerTokenStored.add(\n                lastTimeRewardApplicable()\n                    .sub(lastUpdateTime)\n                    .mul(rewardRate)\n                    .mul(1e8)\n                    .div(_totalSupply)\n            );\n    }\n\n    \n    \n    function earned(address account) public view returns (uint256) {\n        return\n            _balances[account]\n                .mul(rewardPerToken().sub(userRewardPerTokenPaid[account]))\n                .div(1e8)\n                .add(rewards[account]);\n    }\n\n    \n    function getRewardForDuration() external view returns (uint256) {\n        return rewardRate.mul(rewardsDuration);\n    }\n\n    \n    \n    \n    function min(uint256 a, uint256 b) public pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    \n    \n    function getLoyaltyTiers() external view returns(uint256 tier1, uint256 tier2, uint256 tier3)\n    {\n        return(loyaltyTier1, loyaltyTier2, loyaltyTier3);\n    }\n\n    \n    \n    \n    function getLoyaltyTiersBonus() external view returns(uint256 tier1Bonus, uint256 tier2Bonus, uint256 tier3Bonus)\n    {\n        return(loyaltyTier1Bonus, loyaltyTier2Bonus, loyaltyTier3Bonus);\n    }\n\n    // PUBLIC FUNCTIONS\n\n    \n    \n    // SWC-104-Unchecked Call Return Value: L362 - L391\n    function stake(uint256 amount)\n        external\n        nonReentrant\n        notPaused\n        updateReward(msg.sender)\n    {\n        require(amount > 0);\n        \n        _totalSupply = _totalSupply.add(amount);\n        \n        if(_balances[msg.sender] == 0) {\n            \n            totalMembers += 1;\n            \n            CDEXRanking.insert(amount, msg.sender);\n        } else {\n            \n            CDEXRanking.remove(_balances[msg.sender], msg.sender);\n            \n            CDEXRanking.insert(_balances[msg.sender].add(amount), msg.sender);\n        }\n        \n        _balances[msg.sender] = _balances[msg.sender].add(amount);\n        \n        \n        CDEXToken.transferFrom(msg.sender, address(this), amount);\n        \n        emit Staked(msg.sender, amount);\n    }\n\n    \n    \n    // SWC-104-Unchecked Call Return Value: L395 - L420\n    function withdraw(uint256 amount)\n        public\n        nonReentrant\n        updateReward(msg.sender)\n    {\n        require(amount > 0);\n        \n        _totalSupply = _totalSupply.sub(amount);\n        \n        CDEXRanking.remove(_balances[msg.sender], msg.sender);\n        \n        _balances[msg.sender] = _balances[msg.sender].sub(amount);\n        \n        if(_balances[msg.sender] == 0) {\n            totalMembers -= 1;\n        } else {\n            \n            CDEXRanking.insert(_balances[msg.sender], msg.sender);\n        }\n        \n        // SWC-104-Unchecked Call Return Value: L415\n        CDEXToken.transfer(msg.sender, amount);\n        \n        emit Withdrawn(msg.sender, amount);\n    }\n    \n    \n    // SWC-104-Unchecked Call Return Value: L424 - L456\n    function getReward() \n        public \n        nonReentrant \n        updateReward(msg.sender) \n    {\n        uint256 reward = rewards[msg.sender];\n        uint256 loyaltyBonus;\n        \n        if (reward > 0 && depositedRewardTokens >= reward) {\n            \n            rewards[msg.sender] = 0;\n            \n            depositedRewardTokens = depositedRewardTokens.sub(reward);\n            \n            if (_balances[msg.sender] >= loyaltyTier1) {\n                loyaltyBonus = reward.mul(loyaltyTier1Bonus).div(10000);\n            } else if (_balances[msg.sender] >= loyaltyTier2) {\n                loyaltyBonus = reward.mul(loyaltyTier2Bonus).div(10000);\n            } else if (_balances[msg.sender] >= loyaltyTier3) {\n                loyaltyBonus = reward.mul(loyaltyTier3Bonus).div(10000);\n            }\n            \n            depositedLoyaltyBonus = depositedLoyaltyBonus.sub(loyaltyBonus);\n            \n            CDEXToken.transfer(msg.sender, reward.add(loyaltyBonus));\n            \n            emit RewardPaid(msg.sender, reward);\n            \n            if(loyaltyBonus > 0) {\n                emit LoyaltyBonusPaid(msg.sender, loyaltyBonus);\n            }\n        }\n    }\n\n    \n    function exit() external {\n        withdraw(_balances[msg.sender]);\n        getReward();\n    }\n    \n    // RESTRICTED FUNCTIONS\n    \n    \n    \n    \n    function setTokenContract(address _contractAddress) public onlyOwner {\n        CDEXToken = CDEXTokenContract(_contractAddress);\n    }\n    \n    \n    \n    \n    function setRankingContract(address _contractAddress) public onlyOwner {\n        CDEXRanking = CDEXRankingContract(_contractAddress);\n    }\n    \n    \n    \n    \n    \n    \n    \n    // SWC-104-Unchecked Call Return Value: L486 - L498\n    function depositTokens(uint256 amount) public onlyOwner {\n        \n        amount = amount.mul(1e8);\n        \n        depositedLoyaltyBonus = depositedLoyaltyBonus.add(amount.mul(loyaltyBonusTotal).div(10000));\n        \n        depositedRewardTokens = depositedRewardTokens.add(amount);\n        \n        CDEXToken.transferFrom(owner, address(this), amount);\n        \n        emit RewardsDeposited(owner, address(this), amount);\n    }\n\n    \n    \n    \n    \n    function notifyRewardAmount(uint256 reward)\n        public\n        onlyOwner\n        updateReward(address(0))\n    {\n        \n        reward = reward.mul(1e8);\n        \n        \n        require(reward <= depositedRewardTokens.sub(reward.mul(loyaltyBonusTotal).div(10000)));\n        \n        \n        if (block.timestamp >= periodFinish) {\n            rewardRate = reward.div(rewardsDuration);\n        } else {\n            uint256 remaining = periodFinish.sub(block.timestamp);\n            uint256 leftover = remaining.mul(rewardRate);\n            rewardRate = reward.add(leftover).div(rewardsDuration);\n        }\n        \n        \n        \n        \n        require(rewardRate <= depositedRewardTokens.div(rewardsDuration));\n        \n        lastUpdateTime = block.timestamp;\n        \n        periodFinish = block.timestamp.add(rewardsDuration);\n        \n        emit RewardAdded(reward);\n    }\n\n    \n    \n    \n    function setRewardsDuration(uint256 _rewardsDuration) external onlyOwner {\n        \n        require(block.timestamp > periodFinish);\n        \n        rewardsDuration = _rewardsDuration;\n        \n        emit RewardsDurationUpdated(rewardsDuration);\n    }\n\n    \n    \n    \n    \n    function setLoyaltyTiers(\n        uint256 _loyaltyTier1, \n        uint256 _loyaltyTier2, \n        uint256 _loyaltyTier3\n    ) external onlyOwner \n    {\n        \n        loyaltyTier1 = _loyaltyTier1.mul(1e8);\n        loyaltyTier2 = _loyaltyTier2.mul(1e8);\n        loyaltyTier3 = _loyaltyTier3.mul(1e8);\n        \n        emit LoyaltyTiersUpdated(loyaltyTier1, loyaltyTier2, loyaltyTier3);\n    }\n\n    \n    \n    \n    \n    \n    \n    function setLoyaltyTiersBonus(\n        uint256 _loyaltyTier1Bonus, \n        uint256 _loyaltyTier2Bonus, \n        uint256 _loyaltyTier3Bonus\n    ) external onlyOwner \n    {\n        \n        \n        require(_loyaltyTier1Bonus.add(_loyaltyTier2Bonus).add(_loyaltyTier3Bonus) < 10000);\n        \n        loyaltyTier1Bonus = _loyaltyTier1Bonus;\n        loyaltyTier2Bonus = _loyaltyTier2Bonus;\n        loyaltyTier3Bonus = _loyaltyTier3Bonus;\n        \n        loyaltyBonusTotal = loyaltyTier1Bonus.add(loyaltyTier2Bonus).add(loyaltyTier3Bonus);\n        \n        emit LoyaltyTiersBonussUpdated(loyaltyTier1Bonus, loyaltyTier2Bonus, loyaltyTier3Bonus);\n    }\n\n    // MODIFIERS\n    \n    \n    \n    modifier updateReward(address account) {\n        rewardPerTokenStored = rewardPerToken();\n        lastUpdateTime = lastTimeRewardApplicable();\n        if (account != address(0)) {\n            rewards[account] = earned(account);\n            userRewardPerTokenPaid[account] = rewardPerTokenStored;\n        }\n        _;\n    }\n\n    // EVENTS\n\n    event RewardAdded(uint256 reward);\n    event Staked(address indexed user, uint256 amount);\n    event Withdrawn(address indexed user, uint256 amount);\n    event RewardPaid(address indexed user, uint256 reward);\n    event LoyaltyBonusPaid(address indexed user, uint256 loyaltyBonus);\n    event RewardsDurationUpdated(uint256 newDuration);\n    // SWC-135-Code With No Effects: L615\n    event Recovered(address token, uint256 amount);\n    event RewardsDeposited(address sender, address receiver, uint256 reward);\n    event LoyaltyTiersUpdated(uint256 loyaltyTier1, uint256 loyaltyTier2, uint256 loyaltyTier3);\n    event LoyaltyTiersBonussUpdated(uint256 loyaltyTier1Bonus, uint256 loyaltyTier2Bonus, uint256 loyaltyTier3Bonus);\n}",
        "function": "stake(uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Hacken-Codex on Althash/Codex-Rewards-Platform-d364d0ef9258dd468f8202a352c58724d6b65638/contracts/CDEX_rewards.sol",
        "vulnerability": "State access after external call (SWC 107)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract CDEXStakingPool is ReentrancyGuard, Pausable {\n    using SafeMath for uint256;\n\n    // STATE VARIABLES\n    CDEXTokenContract public CDEXToken;\n    CDEXRankingContract public CDEXRanking;\n    uint256 public periodFinish = 0;\n    uint256 public rewardRate = 0;\n    uint256 public rewardsDuration = 0;\n    uint256 public lastUpdateTime;\n    uint256 public rewardPerTokenStored;\n    \n    \n    uint256 public loyaltyTier1 = 100000000 * 1e8;\n    uint256 public loyaltyTier2 = 10000000 * 1e8;\n    uint256 public loyaltyTier3 = 1000000 * 1e8;\n    \n    \n    uint256 public loyaltyTier1Bonus = 125;\n    uint256 public loyaltyTier2Bonus = 100;\n    uint256 public loyaltyTier3Bonus = 50;\n    uint256 public loyaltyBonusTotal = 275;\n    uint256 public depositedLoyaltyBonus;\n\n    mapping(address => uint256) public userRewardPerTokenPaid;\n    mapping(address => uint256) public rewards;\n    uint256 public depositedRewardTokens;\n\n    uint256 private _totalSupply;\n    mapping(address => uint256) private _balances;\n\n    uint256 public totalMembers;\n\n    \n    \n    \n    \n    \n    function CDEXStakingPool(\n        address _owner,\n        address _CDEXTokenContractAddress,\n        address _rankingContractAddress\n    ) public Owned(_owner) {\n        CDEXToken = CDEXTokenContract(_CDEXTokenContractAddress);\n        CDEXRanking = CDEXRankingContract(_rankingContractAddress);\n    }\n\n    \n    \n    \n    \n    function totalSupply() external view returns (uint256) {\n        return _totalSupply;\n    }\n\n    \n    \n    \n    function balanceOf(address account) external view returns (uint256) {\n        return _balances[account];\n    }\n\n    \n    \n    \n    function lastTimeRewardApplicable() public view returns (uint256) {\n        return min(block.timestamp, periodFinish);\n    }\n\n    \n    function rewardPerToken() public view returns (uint256) {\n        if (_totalSupply == 0) {\n            return rewardPerTokenStored;\n        }\n        return\n            rewardPerTokenStored.add(\n                lastTimeRewardApplicable()\n                    .sub(lastUpdateTime)\n                    .mul(rewardRate)\n                    .mul(1e8)\n                    .div(_totalSupply)\n            );\n    }\n\n    \n    \n    function earned(address account) public view returns (uint256) {\n        return\n            _balances[account]\n                .mul(rewardPerToken().sub(userRewardPerTokenPaid[account]))\n                .div(1e8)\n                .add(rewards[account]);\n    }\n\n    \n    function getRewardForDuration() external view returns (uint256) {\n        return rewardRate.mul(rewardsDuration);\n    }\n\n    \n    \n    \n    function min(uint256 a, uint256 b) public pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    \n    \n    function getLoyaltyTiers() external view returns(uint256 tier1, uint256 tier2, uint256 tier3)\n    {\n        return(loyaltyTier1, loyaltyTier2, loyaltyTier3);\n    }\n\n    \n    \n    \n    function getLoyaltyTiersBonus() external view returns(uint256 tier1Bonus, uint256 tier2Bonus, uint256 tier3Bonus)\n    {\n        return(loyaltyTier1Bonus, loyaltyTier2Bonus, loyaltyTier3Bonus);\n    }\n\n    // PUBLIC FUNCTIONS\n\n    \n    \n    // SWC-104-Unchecked Call Return Value: L362 - L391\n    function stake(uint256 amount)\n        external\n        nonReentrant\n        notPaused\n        updateReward(msg.sender)\n    {\n        require(amount > 0);\n        \n        _totalSupply = _totalSupply.add(amount);\n        \n        if(_balances[msg.sender] == 0) {\n            \n            totalMembers += 1;\n            \n            CDEXRanking.insert(amount, msg.sender);\n        } else {\n            \n            CDEXRanking.remove(_balances[msg.sender], msg.sender);\n            \n            CDEXRanking.insert(_balances[msg.sender].add(amount), msg.sender);\n        }\n        \n        _balances[msg.sender] = _balances[msg.sender].add(amount);\n        \n        \n        CDEXToken.transferFrom(msg.sender, address(this), amount);\n        \n        emit Staked(msg.sender, amount);\n    }\n\n    \n    \n    // SWC-104-Unchecked Call Return Value: L395 - L420\n    function withdraw(uint256 amount)\n        public\n        nonReentrant\n        updateReward(msg.sender)\n    {\n        require(amount > 0);\n        \n        _totalSupply = _totalSupply.sub(amount);\n        \n        CDEXRanking.remove(_balances[msg.sender], msg.sender);\n        \n        _balances[msg.sender] = _balances[msg.sender].sub(amount);\n        \n        if(_balances[msg.sender] == 0) {\n            totalMembers -= 1;\n        } else {\n            \n            CDEXRanking.insert(_balances[msg.sender], msg.sender);\n        }\n        \n        // SWC-104-Unchecked Call Return Value: L415\n        CDEXToken.transfer(msg.sender, amount);\n        \n        emit Withdrawn(msg.sender, amount);\n    }\n    \n    \n    // SWC-104-Unchecked Call Return Value: L424 - L456\n    function getReward() \n        public \n        nonReentrant \n        updateReward(msg.sender) \n    {\n        uint256 reward = rewards[msg.sender];\n        uint256 loyaltyBonus;\n        \n        if (reward > 0 && depositedRewardTokens >= reward) {\n            \n            rewards[msg.sender] = 0;\n            \n            depositedRewardTokens = depositedRewardTokens.sub(reward);\n            \n            if (_balances[msg.sender] >= loyaltyTier1) {\n                loyaltyBonus = reward.mul(loyaltyTier1Bonus).div(10000);\n            } else if (_balances[msg.sender] >= loyaltyTier2) {\n                loyaltyBonus = reward.mul(loyaltyTier2Bonus).div(10000);\n            } else if (_balances[msg.sender] >= loyaltyTier3) {\n                loyaltyBonus = reward.mul(loyaltyTier3Bonus).div(10000);\n            }\n            \n            depositedLoyaltyBonus = depositedLoyaltyBonus.sub(loyaltyBonus);\n            \n            CDEXToken.transfer(msg.sender, reward.add(loyaltyBonus));\n            \n            emit RewardPaid(msg.sender, reward);\n            \n            if(loyaltyBonus > 0) {\n                emit LoyaltyBonusPaid(msg.sender, loyaltyBonus);\n            }\n        }\n    }\n\n    \n    function exit() external {\n        withdraw(_balances[msg.sender]);\n        getReward();\n    }\n    \n    // RESTRICTED FUNCTIONS\n    \n    \n    \n    \n    function setTokenContract(address _contractAddress) public onlyOwner {\n        CDEXToken = CDEXTokenContract(_contractAddress);\n    }\n    \n    \n    \n    \n    function setRankingContract(address _contractAddress) public onlyOwner {\n        CDEXRanking = CDEXRankingContract(_contractAddress);\n    }\n    \n    \n    \n    \n    \n    \n    \n    // SWC-104-Unchecked Call Return Value: L486 - L498\n    function depositTokens(uint256 amount) public onlyOwner {\n        \n        amount = amount.mul(1e8);\n        \n        depositedLoyaltyBonus = depositedLoyaltyBonus.add(amount.mul(loyaltyBonusTotal).div(10000));\n        \n        depositedRewardTokens = depositedRewardTokens.add(amount);\n        \n        CDEXToken.transferFrom(owner, address(this), amount);\n        \n        emit RewardsDeposited(owner, address(this), amount);\n    }\n\n    \n    \n    \n    \n    function notifyRewardAmount(uint256 reward)\n        public\n        onlyOwner\n        updateReward(address(0))\n    {\n        \n        reward = reward.mul(1e8);\n        \n        \n        require(reward <= depositedRewardTokens.sub(reward.mul(loyaltyBonusTotal).div(10000)));\n        \n        \n        if (block.timestamp >= periodFinish) {\n            rewardRate = reward.div(rewardsDuration);\n        } else {\n            uint256 remaining = periodFinish.sub(block.timestamp);\n            uint256 leftover = remaining.mul(rewardRate);\n            rewardRate = reward.add(leftover).div(rewardsDuration);\n        }\n        \n        \n        \n        \n        require(rewardRate <= depositedRewardTokens.div(rewardsDuration));\n        \n        lastUpdateTime = block.timestamp;\n        \n        periodFinish = block.timestamp.add(rewardsDuration);\n        \n        emit RewardAdded(reward);\n    }\n\n    \n    \n    \n    function setRewardsDuration(uint256 _rewardsDuration) external onlyOwner {\n        \n        require(block.timestamp > periodFinish);\n        \n        rewardsDuration = _rewardsDuration;\n        \n        emit RewardsDurationUpdated(rewardsDuration);\n    }\n\n    \n    \n    \n    \n    function setLoyaltyTiers(\n        uint256 _loyaltyTier1, \n        uint256 _loyaltyTier2, \n        uint256 _loyaltyTier3\n    ) external onlyOwner \n    {\n        \n        loyaltyTier1 = _loyaltyTier1.mul(1e8);\n        loyaltyTier2 = _loyaltyTier2.mul(1e8);\n        loyaltyTier3 = _loyaltyTier3.mul(1e8);\n        \n        emit LoyaltyTiersUpdated(loyaltyTier1, loyaltyTier2, loyaltyTier3);\n    }\n\n    \n    \n    \n    \n    \n    \n    function setLoyaltyTiersBonus(\n        uint256 _loyaltyTier1Bonus, \n        uint256 _loyaltyTier2Bonus, \n        uint256 _loyaltyTier3Bonus\n    ) external onlyOwner \n    {\n        \n        \n        require(_loyaltyTier1Bonus.add(_loyaltyTier2Bonus).add(_loyaltyTier3Bonus) < 10000);\n        \n        loyaltyTier1Bonus = _loyaltyTier1Bonus;\n        loyaltyTier2Bonus = _loyaltyTier2Bonus;\n        loyaltyTier3Bonus = _loyaltyTier3Bonus;\n        \n        loyaltyBonusTotal = loyaltyTier1Bonus.add(loyaltyTier2Bonus).add(loyaltyTier3Bonus);\n        \n        emit LoyaltyTiersBonussUpdated(loyaltyTier1Bonus, loyaltyTier2Bonus, loyaltyTier3Bonus);\n    }\n\n    // MODIFIERS\n    \n    \n    \n    modifier updateReward(address account) {\n        rewardPerTokenStored = rewardPerToken();\n        lastUpdateTime = lastTimeRewardApplicable();\n        if (account != address(0)) {\n            rewards[account] = earned(account);\n            userRewardPerTokenPaid[account] = rewardPerTokenStored;\n        }\n        _;\n    }\n\n    // EVENTS\n\n    event RewardAdded(uint256 reward);\n    event Staked(address indexed user, uint256 amount);\n    event Withdrawn(address indexed user, uint256 amount);\n    event RewardPaid(address indexed user, uint256 reward);\n    event LoyaltyBonusPaid(address indexed user, uint256 loyaltyBonus);\n    event RewardsDurationUpdated(uint256 newDuration);\n    // SWC-135-Code With No Effects: L615\n    event Recovered(address token, uint256 amount);\n    event RewardsDeposited(address sender, address receiver, uint256 reward);\n    event LoyaltyTiersUpdated(uint256 loyaltyTier1, uint256 loyaltyTier2, uint256 loyaltyTier3);\n    event LoyaltyTiersBonussUpdated(uint256 loyaltyTier1Bonus, uint256 loyaltyTier2Bonus, uint256 loyaltyTier3Bonus);\n}",
        "function": "setRewardsDuration(uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Hacken-Codex on Althash/Codex-Rewards-Platform-d364d0ef9258dd468f8202a352c58724d6b65638/contracts/CDEX_rewards.sol",
        "vulnerability": "Dependence on predictable environment variable (SWC 116)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract CDEXStakingPool is ReentrancyGuard, Pausable {\n    using SafeMath for uint256;\n\n    // STATE VARIABLES\n    CDEXTokenContract public CDEXToken;\n    CDEXRankingContract public CDEXRanking;\n    uint256 public periodFinish = 0;\n    uint256 public rewardRate = 0;\n    uint256 public rewardsDuration = 0;\n    uint256 public lastUpdateTime;\n    uint256 public rewardPerTokenStored;\n    \n    \n    uint256 public loyaltyTier1 = 100000000 * 1e8;\n    uint256 public loyaltyTier2 = 10000000 * 1e8;\n    uint256 public loyaltyTier3 = 1000000 * 1e8;\n    \n    \n    uint256 public loyaltyTier1Bonus = 125;\n    uint256 public loyaltyTier2Bonus = 100;\n    uint256 public loyaltyTier3Bonus = 50;\n    uint256 public loyaltyBonusTotal = 275;\n    uint256 public depositedLoyaltyBonus;\n\n    mapping(address => uint256) public userRewardPerTokenPaid;\n    mapping(address => uint256) public rewards;\n    uint256 public depositedRewardTokens;\n\n    uint256 private _totalSupply;\n    mapping(address => uint256) private _balances;\n\n    uint256 public totalMembers;\n\n    \n    \n    \n    \n    \n    function CDEXStakingPool(\n        address _owner,\n        address _CDEXTokenContractAddress,\n        address _rankingContractAddress\n    ) public Owned(_owner) {\n        CDEXToken = CDEXTokenContract(_CDEXTokenContractAddress);\n        CDEXRanking = CDEXRankingContract(_rankingContractAddress);\n    }\n\n    \n    \n    \n    \n    function totalSupply() external view returns (uint256) {\n        return _totalSupply;\n    }\n\n    \n    \n    \n    function balanceOf(address account) external view returns (uint256) {\n        return _balances[account];\n    }\n\n    \n    \n    \n    function lastTimeRewardApplicable() public view returns (uint256) {\n        return min(block.timestamp, periodFinish);\n    }\n\n    \n    function rewardPerToken() public view returns (uint256) {\n        if (_totalSupply == 0) {\n            return rewardPerTokenStored;\n        }\n        return\n            rewardPerTokenStored.add(\n                lastTimeRewardApplicable()\n                    .sub(lastUpdateTime)\n                    .mul(rewardRate)\n                    .mul(1e8)\n                    .div(_totalSupply)\n            );\n    }\n\n    \n    \n    function earned(address account) public view returns (uint256) {\n        return\n            _balances[account]\n                .mul(rewardPerToken().sub(userRewardPerTokenPaid[account]))\n                .div(1e8)\n                .add(rewards[account]);\n    }\n\n    \n    function getRewardForDuration() external view returns (uint256) {\n        return rewardRate.mul(rewardsDuration);\n    }\n\n    \n    \n    \n    function min(uint256 a, uint256 b) public pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    \n    \n    function getLoyaltyTiers() external view returns(uint256 tier1, uint256 tier2, uint256 tier3)\n    {\n        return(loyaltyTier1, loyaltyTier2, loyaltyTier3);\n    }\n\n    \n    \n    \n    function getLoyaltyTiersBonus() external view returns(uint256 tier1Bonus, uint256 tier2Bonus, uint256 tier3Bonus)\n    {\n        return(loyaltyTier1Bonus, loyaltyTier2Bonus, loyaltyTier3Bonus);\n    }\n\n    // PUBLIC FUNCTIONS\n\n    \n    \n    // SWC-104-Unchecked Call Return Value: L362 - L391\n    function stake(uint256 amount)\n        external\n        nonReentrant\n        notPaused\n        updateReward(msg.sender)\n    {\n        require(amount > 0);\n        \n        _totalSupply = _totalSupply.add(amount);\n        \n        if(_balances[msg.sender] == 0) {\n            \n            totalMembers += 1;\n            \n            CDEXRanking.insert(amount, msg.sender);\n        } else {\n            \n            CDEXRanking.remove(_balances[msg.sender], msg.sender);\n            \n            CDEXRanking.insert(_balances[msg.sender].add(amount), msg.sender);\n        }\n        \n        _balances[msg.sender] = _balances[msg.sender].add(amount);\n        \n        \n        CDEXToken.transferFrom(msg.sender, address(this), amount);\n        \n        emit Staked(msg.sender, amount);\n    }\n\n    \n    \n    // SWC-104-Unchecked Call Return Value: L395 - L420\n    function withdraw(uint256 amount)\n        public\n        nonReentrant\n        updateReward(msg.sender)\n    {\n        require(amount > 0);\n        \n        _totalSupply = _totalSupply.sub(amount);\n        \n        CDEXRanking.remove(_balances[msg.sender], msg.sender);\n        \n        _balances[msg.sender] = _balances[msg.sender].sub(amount);\n        \n        if(_balances[msg.sender] == 0) {\n            totalMembers -= 1;\n        } else {\n            \n            CDEXRanking.insert(_balances[msg.sender], msg.sender);\n        }\n        \n        // SWC-104-Unchecked Call Return Value: L415\n        CDEXToken.transfer(msg.sender, amount);\n        \n        emit Withdrawn(msg.sender, amount);\n    }\n    \n    \n    // SWC-104-Unchecked Call Return Value: L424 - L456\n    function getReward() \n        public \n        nonReentrant \n        updateReward(msg.sender) \n    {\n        uint256 reward = rewards[msg.sender];\n        uint256 loyaltyBonus;\n        \n        if (reward > 0 && depositedRewardTokens >= reward) {\n            \n            rewards[msg.sender] = 0;\n            \n            depositedRewardTokens = depositedRewardTokens.sub(reward);\n            \n            if (_balances[msg.sender] >= loyaltyTier1) {\n                loyaltyBonus = reward.mul(loyaltyTier1Bonus).div(10000);\n            } else if (_balances[msg.sender] >= loyaltyTier2) {\n                loyaltyBonus = reward.mul(loyaltyTier2Bonus).div(10000);\n            } else if (_balances[msg.sender] >= loyaltyTier3) {\n                loyaltyBonus = reward.mul(loyaltyTier3Bonus).div(10000);\n            }\n            \n            depositedLoyaltyBonus = depositedLoyaltyBonus.sub(loyaltyBonus);\n            \n            CDEXToken.transfer(msg.sender, reward.add(loyaltyBonus));\n            \n            emit RewardPaid(msg.sender, reward);\n            \n            if(loyaltyBonus > 0) {\n                emit LoyaltyBonusPaid(msg.sender, loyaltyBonus);\n            }\n        }\n    }\n\n    \n    function exit() external {\n        withdraw(_balances[msg.sender]);\n        getReward();\n    }\n    \n    // RESTRICTED FUNCTIONS\n    \n    \n    \n    \n    function setTokenContract(address _contractAddress) public onlyOwner {\n        CDEXToken = CDEXTokenContract(_contractAddress);\n    }\n    \n    \n    \n    \n    function setRankingContract(address _contractAddress) public onlyOwner {\n        CDEXRanking = CDEXRankingContract(_contractAddress);\n    }\n    \n    \n    \n    \n    \n    \n    \n    // SWC-104-Unchecked Call Return Value: L486 - L498\n    function depositTokens(uint256 amount) public onlyOwner {\n        \n        amount = amount.mul(1e8);\n        \n        depositedLoyaltyBonus = depositedLoyaltyBonus.add(amount.mul(loyaltyBonusTotal).div(10000));\n        \n        depositedRewardTokens = depositedRewardTokens.add(amount);\n        \n        CDEXToken.transferFrom(owner, address(this), amount);\n        \n        emit RewardsDeposited(owner, address(this), amount);\n    }\n\n    \n    \n    \n    \n    function notifyRewardAmount(uint256 reward)\n        public\n        onlyOwner\n        updateReward(address(0))\n    {\n        \n        reward = reward.mul(1e8);\n        \n        \n        require(reward <= depositedRewardTokens.sub(reward.mul(loyaltyBonusTotal).div(10000)));\n        \n        \n        if (block.timestamp >= periodFinish) {\n            rewardRate = reward.div(rewardsDuration);\n        } else {\n            uint256 remaining = periodFinish.sub(block.timestamp);\n            uint256 leftover = remaining.mul(rewardRate);\n            rewardRate = reward.add(leftover).div(rewardsDuration);\n        }\n        \n        \n        \n        \n        require(rewardRate <= depositedRewardTokens.div(rewardsDuration));\n        \n        lastUpdateTime = block.timestamp;\n        \n        periodFinish = block.timestamp.add(rewardsDuration);\n        \n        emit RewardAdded(reward);\n    }\n\n    \n    \n    \n    function setRewardsDuration(uint256 _rewardsDuration) external onlyOwner {\n        \n        require(block.timestamp > periodFinish);\n        \n        rewardsDuration = _rewardsDuration;\n        \n        emit RewardsDurationUpdated(rewardsDuration);\n    }\n\n    \n    \n    \n    \n    function setLoyaltyTiers(\n        uint256 _loyaltyTier1, \n        uint256 _loyaltyTier2, \n        uint256 _loyaltyTier3\n    ) external onlyOwner \n    {\n        \n        loyaltyTier1 = _loyaltyTier1.mul(1e8);\n        loyaltyTier2 = _loyaltyTier2.mul(1e8);\n        loyaltyTier3 = _loyaltyTier3.mul(1e8);\n        \n        emit LoyaltyTiersUpdated(loyaltyTier1, loyaltyTier2, loyaltyTier3);\n    }\n\n    \n    \n    \n    \n    \n    \n    function setLoyaltyTiersBonus(\n        uint256 _loyaltyTier1Bonus, \n        uint256 _loyaltyTier2Bonus, \n        uint256 _loyaltyTier3Bonus\n    ) external onlyOwner \n    {\n        \n        \n        require(_loyaltyTier1Bonus.add(_loyaltyTier2Bonus).add(_loyaltyTier3Bonus) < 10000);\n        \n        loyaltyTier1Bonus = _loyaltyTier1Bonus;\n        loyaltyTier2Bonus = _loyaltyTier2Bonus;\n        loyaltyTier3Bonus = _loyaltyTier3Bonus;\n        \n        loyaltyBonusTotal = loyaltyTier1Bonus.add(loyaltyTier2Bonus).add(loyaltyTier3Bonus);\n        \n        emit LoyaltyTiersBonussUpdated(loyaltyTier1Bonus, loyaltyTier2Bonus, loyaltyTier3Bonus);\n    }\n\n    // MODIFIERS\n    \n    \n    \n    modifier updateReward(address account) {\n        rewardPerTokenStored = rewardPerToken();\n        lastUpdateTime = lastTimeRewardApplicable();\n        if (account != address(0)) {\n            rewards[account] = earned(account);\n            userRewardPerTokenPaid[account] = rewardPerTokenStored;\n        }\n        _;\n    }\n\n    // EVENTS\n\n    event RewardAdded(uint256 reward);\n    event Staked(address indexed user, uint256 amount);\n    event Withdrawn(address indexed user, uint256 amount);\n    event RewardPaid(address indexed user, uint256 reward);\n    event LoyaltyBonusPaid(address indexed user, uint256 loyaltyBonus);\n    event RewardsDurationUpdated(uint256 newDuration);\n    // SWC-135-Code With No Effects: L615\n    event Recovered(address token, uint256 amount);\n    event RewardsDeposited(address sender, address receiver, uint256 reward);\n    event LoyaltyTiersUpdated(uint256 loyaltyTier1, uint256 loyaltyTier2, uint256 loyaltyTier3);\n    event LoyaltyTiersBonussUpdated(uint256 loyaltyTier1Bonus, uint256 loyaltyTier2Bonus, uint256 loyaltyTier3Bonus);\n}",
        "function": "depositTokens(uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Hacken-Codex on Althash/Codex-Rewards-Platform-d364d0ef9258dd468f8202a352c58724d6b65638/contracts/CDEX_rewards.sol",
        "vulnerability": "External Call To User-Supplied Address (SWC 107)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract CDEXStakingPool is ReentrancyGuard, Pausable {\n    using SafeMath for uint256;\n\n    // STATE VARIABLES\n    CDEXTokenContract public CDEXToken;\n    CDEXRankingContract public CDEXRanking;\n    uint256 public periodFinish = 0;\n    uint256 public rewardRate = 0;\n    uint256 public rewardsDuration = 0;\n    uint256 public lastUpdateTime;\n    uint256 public rewardPerTokenStored;\n    \n    \n    uint256 public loyaltyTier1 = 100000000 * 1e8;\n    uint256 public loyaltyTier2 = 10000000 * 1e8;\n    uint256 public loyaltyTier3 = 1000000 * 1e8;\n    \n    \n    uint256 public loyaltyTier1Bonus = 125;\n    uint256 public loyaltyTier2Bonus = 100;\n    uint256 public loyaltyTier3Bonus = 50;\n    uint256 public loyaltyBonusTotal = 275;\n    uint256 public depositedLoyaltyBonus;\n\n    mapping(address => uint256) public userRewardPerTokenPaid;\n    mapping(address => uint256) public rewards;\n    uint256 public depositedRewardTokens;\n\n    uint256 private _totalSupply;\n    mapping(address => uint256) private _balances;\n\n    uint256 public totalMembers;\n\n    \n    \n    \n    \n    \n    function CDEXStakingPool(\n        address _owner,\n        address _CDEXTokenContractAddress,\n        address _rankingContractAddress\n    ) public Owned(_owner) {\n        CDEXToken = CDEXTokenContract(_CDEXTokenContractAddress);\n        CDEXRanking = CDEXRankingContract(_rankingContractAddress);\n    }\n\n    \n    \n    \n    \n    function totalSupply() external view returns (uint256) {\n        return _totalSupply;\n    }\n\n    \n    \n    \n    function balanceOf(address account) external view returns (uint256) {\n        return _balances[account];\n    }\n\n    \n    \n    \n    function lastTimeRewardApplicable() public view returns (uint256) {\n        return min(block.timestamp, periodFinish);\n    }\n\n    \n    function rewardPerToken() public view returns (uint256) {\n        if (_totalSupply == 0) {\n            return rewardPerTokenStored;\n        }\n        return\n            rewardPerTokenStored.add(\n                lastTimeRewardApplicable()\n                    .sub(lastUpdateTime)\n                    .mul(rewardRate)\n                    .mul(1e8)\n                    .div(_totalSupply)\n            );\n    }\n\n    \n    \n    function earned(address account) public view returns (uint256) {\n        return\n            _balances[account]\n                .mul(rewardPerToken().sub(userRewardPerTokenPaid[account]))\n                .div(1e8)\n                .add(rewards[account]);\n    }\n\n    \n    function getRewardForDuration() external view returns (uint256) {\n        return rewardRate.mul(rewardsDuration);\n    }\n\n    \n    \n    \n    function min(uint256 a, uint256 b) public pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    \n    \n    function getLoyaltyTiers() external view returns(uint256 tier1, uint256 tier2, uint256 tier3)\n    {\n        return(loyaltyTier1, loyaltyTier2, loyaltyTier3);\n    }\n\n    \n    \n    \n    function getLoyaltyTiersBonus() external view returns(uint256 tier1Bonus, uint256 tier2Bonus, uint256 tier3Bonus)\n    {\n        return(loyaltyTier1Bonus, loyaltyTier2Bonus, loyaltyTier3Bonus);\n    }\n\n    // PUBLIC FUNCTIONS\n\n    \n    \n    // SWC-104-Unchecked Call Return Value: L362 - L391\n    function stake(uint256 amount)\n        external\n        nonReentrant\n        notPaused\n        updateReward(msg.sender)\n    {\n        require(amount > 0);\n        \n        _totalSupply = _totalSupply.add(amount);\n        \n        if(_balances[msg.sender] == 0) {\n            \n            totalMembers += 1;\n            \n            CDEXRanking.insert(amount, msg.sender);\n        } else {\n            \n            CDEXRanking.remove(_balances[msg.sender], msg.sender);\n            \n            CDEXRanking.insert(_balances[msg.sender].add(amount), msg.sender);\n        }\n        \n        _balances[msg.sender] = _balances[msg.sender].add(amount);\n        \n        \n        CDEXToken.transferFrom(msg.sender, address(this), amount);\n        \n        emit Staked(msg.sender, amount);\n    }\n\n    \n    \n    // SWC-104-Unchecked Call Return Value: L395 - L420\n    function withdraw(uint256 amount)\n        public\n        nonReentrant\n        updateReward(msg.sender)\n    {\n        require(amount > 0);\n        \n        _totalSupply = _totalSupply.sub(amount);\n        \n        CDEXRanking.remove(_balances[msg.sender], msg.sender);\n        \n        _balances[msg.sender] = _balances[msg.sender].sub(amount);\n        \n        if(_balances[msg.sender] == 0) {\n            totalMembers -= 1;\n        } else {\n            \n            CDEXRanking.insert(_balances[msg.sender], msg.sender);\n        }\n        \n        // SWC-104-Unchecked Call Return Value: L415\n        CDEXToken.transfer(msg.sender, amount);\n        \n        emit Withdrawn(msg.sender, amount);\n    }\n    \n    \n    // SWC-104-Unchecked Call Return Value: L424 - L456\n    function getReward() \n        public \n        nonReentrant \n        updateReward(msg.sender) \n    {\n        uint256 reward = rewards[msg.sender];\n        uint256 loyaltyBonus;\n        \n        if (reward > 0 && depositedRewardTokens >= reward) {\n            \n            rewards[msg.sender] = 0;\n            \n            depositedRewardTokens = depositedRewardTokens.sub(reward);\n            \n            if (_balances[msg.sender] >= loyaltyTier1) {\n                loyaltyBonus = reward.mul(loyaltyTier1Bonus).div(10000);\n            } else if (_balances[msg.sender] >= loyaltyTier2) {\n                loyaltyBonus = reward.mul(loyaltyTier2Bonus).div(10000);\n            } else if (_balances[msg.sender] >= loyaltyTier3) {\n                loyaltyBonus = reward.mul(loyaltyTier3Bonus).div(10000);\n            }\n            \n            depositedLoyaltyBonus = depositedLoyaltyBonus.sub(loyaltyBonus);\n            \n            CDEXToken.transfer(msg.sender, reward.add(loyaltyBonus));\n            \n            emit RewardPaid(msg.sender, reward);\n            \n            if(loyaltyBonus > 0) {\n                emit LoyaltyBonusPaid(msg.sender, loyaltyBonus);\n            }\n        }\n    }\n\n    \n    function exit() external {\n        withdraw(_balances[msg.sender]);\n        getReward();\n    }\n    \n    // RESTRICTED FUNCTIONS\n    \n    \n    \n    \n    function setTokenContract(address _contractAddress) public onlyOwner {\n        CDEXToken = CDEXTokenContract(_contractAddress);\n    }\n    \n    \n    \n    \n    function setRankingContract(address _contractAddress) public onlyOwner {\n        CDEXRanking = CDEXRankingContract(_contractAddress);\n    }\n    \n    \n    \n    \n    \n    \n    \n    // SWC-104-Unchecked Call Return Value: L486 - L498\n    function depositTokens(uint256 amount) public onlyOwner {\n        \n        amount = amount.mul(1e8);\n        \n        depositedLoyaltyBonus = depositedLoyaltyBonus.add(amount.mul(loyaltyBonusTotal).div(10000));\n        \n        depositedRewardTokens = depositedRewardTokens.add(amount);\n        \n        CDEXToken.transferFrom(owner, address(this), amount);\n        \n        emit RewardsDeposited(owner, address(this), amount);\n    }\n\n    \n    \n    \n    \n    function notifyRewardAmount(uint256 reward)\n        public\n        onlyOwner\n        updateReward(address(0))\n    {\n        \n        reward = reward.mul(1e8);\n        \n        \n        require(reward <= depositedRewardTokens.sub(reward.mul(loyaltyBonusTotal).div(10000)));\n        \n        \n        if (block.timestamp >= periodFinish) {\n            rewardRate = reward.div(rewardsDuration);\n        } else {\n            uint256 remaining = periodFinish.sub(block.timestamp);\n            uint256 leftover = remaining.mul(rewardRate);\n            rewardRate = reward.add(leftover).div(rewardsDuration);\n        }\n        \n        \n        \n        \n        require(rewardRate <= depositedRewardTokens.div(rewardsDuration));\n        \n        lastUpdateTime = block.timestamp;\n        \n        periodFinish = block.timestamp.add(rewardsDuration);\n        \n        emit RewardAdded(reward);\n    }\n\n    \n    \n    \n    function setRewardsDuration(uint256 _rewardsDuration) external onlyOwner {\n        \n        require(block.timestamp > periodFinish);\n        \n        rewardsDuration = _rewardsDuration;\n        \n        emit RewardsDurationUpdated(rewardsDuration);\n    }\n\n    \n    \n    \n    \n    function setLoyaltyTiers(\n        uint256 _loyaltyTier1, \n        uint256 _loyaltyTier2, \n        uint256 _loyaltyTier3\n    ) external onlyOwner \n    {\n        \n        loyaltyTier1 = _loyaltyTier1.mul(1e8);\n        loyaltyTier2 = _loyaltyTier2.mul(1e8);\n        loyaltyTier3 = _loyaltyTier3.mul(1e8);\n        \n        emit LoyaltyTiersUpdated(loyaltyTier1, loyaltyTier2, loyaltyTier3);\n    }\n\n    \n    \n    \n    \n    \n    \n    function setLoyaltyTiersBonus(\n        uint256 _loyaltyTier1Bonus, \n        uint256 _loyaltyTier2Bonus, \n        uint256 _loyaltyTier3Bonus\n    ) external onlyOwner \n    {\n        \n        \n        require(_loyaltyTier1Bonus.add(_loyaltyTier2Bonus).add(_loyaltyTier3Bonus) < 10000);\n        \n        loyaltyTier1Bonus = _loyaltyTier1Bonus;\n        loyaltyTier2Bonus = _loyaltyTier2Bonus;\n        loyaltyTier3Bonus = _loyaltyTier3Bonus;\n        \n        loyaltyBonusTotal = loyaltyTier1Bonus.add(loyaltyTier2Bonus).add(loyaltyTier3Bonus);\n        \n        emit LoyaltyTiersBonussUpdated(loyaltyTier1Bonus, loyaltyTier2Bonus, loyaltyTier3Bonus);\n    }\n\n    // MODIFIERS\n    \n    \n    \n    modifier updateReward(address account) {\n        rewardPerTokenStored = rewardPerToken();\n        lastUpdateTime = lastTimeRewardApplicable();\n        if (account != address(0)) {\n            rewards[account] = earned(account);\n            userRewardPerTokenPaid[account] = rewardPerTokenStored;\n        }\n        _;\n    }\n\n    // EVENTS\n\n    event RewardAdded(uint256 reward);\n    event Staked(address indexed user, uint256 amount);\n    event Withdrawn(address indexed user, uint256 amount);\n    event RewardPaid(address indexed user, uint256 reward);\n    event LoyaltyBonusPaid(address indexed user, uint256 loyaltyBonus);\n    event RewardsDurationUpdated(uint256 newDuration);\n    // SWC-135-Code With No Effects: L615\n    event Recovered(address token, uint256 amount);\n    event RewardsDeposited(address sender, address receiver, uint256 reward);\n    event LoyaltyTiersUpdated(uint256 loyaltyTier1, uint256 loyaltyTier2, uint256 loyaltyTier3);\n    event LoyaltyTiersBonussUpdated(uint256 loyaltyTier1Bonus, uint256 loyaltyTier2Bonus, uint256 loyaltyTier3Bonus);\n}",
        "function": "depositTokens(uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Hacken-Codex on Althash/Codex-Rewards-Platform-d364d0ef9258dd468f8202a352c58724d6b65638/contracts/CDEX_rewards.sol",
        "vulnerability": "State access after external call (SWC 107)",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract XSwap is DSAuth {\n\tusing DSMath for uint256;\n\n\tuint256 constant internal OFFSET = 10 ** 18;\n\t//Mainnet\n\t// address private chai = 0x06AF07097C9Eeb7fD685c692751D5C66dB49c215;\n\t// address private dai  = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n\n\t//Rinkeby\n\taddress private chai = 0x8a5C1BD4D75e168a4f65eB902c289400B90FD980;\n\taddress private dai  = 0xA3A59273494BB5B8F0a8FAcf21B3f666A47d6140;\n\n\tbool private actived;\n\taddress public lendFMe;\n\tbool public isOpen;\n\tmapping(address => mapping(address => uint256)) public prices; // 1 tokenA = ? tokenB\n\tmapping(address => mapping(address => uint256)) public fee;   // fee from tokenA to tokenB\n\tmapping(address => bool) public supportLending;\n\tmapping(address => uint256) public decimals;\n\n\tconstructor() public {\n\t}\n\n\tfunction active(address _lendFMe) public {\n\t\trequire(actived == false, \"already actived.\");\n\t\towner = msg.sender;\n\t\tisOpen = true;\n\t\tlendFMe = _lendFMe;\n\t\tactived = true;\n\t}\n\n\t// trade _inputAmount of _input token to get _output token\n\tfunction trade(address _input, address _output, uint256 _inputAmount) public returns (bool) {\n\t\treturn trade(_input, _output, _inputAmount, msg.sender);\n\t}\n\n\tfunction trade(address _input, address _output, uint256 _inputAmount, address _receiver) public returns (bool) {\n\t\trequire(isOpen, \"not open\");\n\t\trequire(prices[_input][_output] != 0, \"invalid token address\");\n\t\trequire(decimals[_input] != 0, \"input decimal not setteled\");\n\t\trequire(decimals[_output] != 0, \"output decimal not setteled\");\n\n\t\tNonStandardIERC20Token(_input).transferFrom(msg.sender, address(this), _inputAmount);\n\t\tif(supportLending[_input]) {\n\t\t\tif (_input == dai) {\n\t\t\t\tIChai(chai).join(address(this), _inputAmount);\n\t\t\t\tILendFMe(lendFMe).supply(chai, IERC20Token(chai).balanceOf(address(this)));\n\t\t\t}\n\t\t\telse\n\t\t\t\tILendFMe(lendFMe).supply(_input, _inputAmount);\n\t\t}\n\t\tuint256 _tokenAmount = normalizeToken(_input, _inputAmount).mul(prices[_input][_output]).div(OFFSET);\n\t\tuint256 _fee = _tokenAmount.mul(fee[_input][_output]).div(OFFSET);\n\t\tuint256 _amountToUser = _tokenAmount.sub(_fee);\n\n\t\tif(supportLending[_output]) {\n\t\t\tif (_output == dai) {\n\t\t\t\tILendFMe(lendFMe).withdraw(chai, _amountToUser); //assume chai / dai >= 1;\n\t\t\t\tIChai(chai).draw(address(this), _amountToUser);\n\t\t\t}\n\t\t\telse\n\t\t\t\tILendFMe(lendFMe).withdraw(_output, denormalizedToken(_output, _amountToUser));\n\t\t}\n\t\tNonStandardIERC20Token(_output).transfer(_receiver, denormalizedToken(_output, _amountToUser));\n\t\treturn true;\n\t}\n\n\tfunction getTokenLiquidation(address _token) public view returns (uint256) {\n\t\tuint256 balanceInDefi = ILendFMe(lendFMe).getSupplyBalance(address(this), _token);\n\t\treturn balanceInDefi.add(NonStandardIERC20Token(_token).balanceOf(address(this)));\n\t}\n\n\tfunction setLendFMe(address _lendFMe) public auth returns (bool) {\n\t\tlendFMe = _lendFMe;\n\t\treturn true;\n\t}\n\n\tfunction enableLending(address _token) public auth returns (bool) {\n\t\trequire(!supportLending[_token], \"the token is already supported lending\");\n\t\tsupportLending[_token] = true;\n\n\t\tif (_token == dai) {\n\t\t\tIERC20Token(_token).approve(chai, uint256(-1));\n\t\t\tIERC20Token(chai).approve(lendFMe, uint256(-1));\n\t\t}\n\t\telse {\n\t\t\tNonStandardIERC20Token(_token).approve(lendFMe, uint256(-1));\n\t\t}\n\n\t\tuint256 _balance = NonStandardIERC20Token(_token).balanceOf(address(this));\n\t\tif(_balance > 0) {\n\t\t\tif (_token == dai) {\n\t\t\t\tIChai(chai).join(address(this), _balance);\n\t\t\t\tILendFMe(lendFMe).supply(chai, IERC20Token(chai).balanceOf(address(this)));\n\t\t\t}\n\t\t\telse\n\t\t\t\tILendFMe(lendFMe).supply(_token, _balance);\n\t\t}\n\t\treturn true;\n\t}\n\n\tfunction disableLending(address _token) public auth returns (bool) {\n\t\trequire(supportLending[_token], \"the token doesnt support lending\");\n\t\tsupportLending[_token] = false;\n\n\t\tif (_token == dai) {\n\t\t\tILendFMe(lendFMe).withdraw(chai, uint256(-1));\n\t\t\tIChai(chai).exit(address(this), IERC20Token(chai).balanceOf(address(this)));\n\t\t}\n\t\telse\n\t\t\tILendFMe(lendFMe).withdraw(_token, uint256(-1));\n\n\t\treturn true;\n\t}\n\n\t// create new pairs\n\tfunction createPair(address _input, address _output, uint256 _priceInOut, uint256 _priceOutIn, uint256 _fee) external auth returns (bool) {\n\t\tsetPrices(_input, _output, _priceInOut, _priceOutIn);\n\t\tsetFee(_input, _output, _fee);\n\t\treturn true;\n\t}\n\n\tfunction setPrices(address _input, address _output, uint256 _priceInOut, uint256 _priceOutIn) public auth returns (bool) {\n\t\tsetPrices(_input, _output, _priceInOut);\n\t\tsetPrices(_output, _input, _priceOutIn);\n\t\treturn true;\n\t}\n\t//SWC-101-Integer Overflow and Underflow: L152\n\tfunction setPrices(address _input, address _output, uint256 _price) public auth returns (bool) {\n\t\tprices[_input][_output] = _price;\n\t\treturn true;\n\t}\n\n\tfunction setFee(address _input, address _output, uint256 _fee) public auth returns (bool) {\n\t\tfee[_input][_output] = _fee;\n\t\tfee[_output][_input] = _fee;\n\t\treturn true;\n\t}\n\n\tfunction setTokenDecimals(address _token, uint256 _decimals) public auth returns (bool){\n\t\trequire(_decimals <= 18, \"not supported decimal\");\n\t\tdecimals[_token] = _decimals;\n\t\treturn true;\n\t}\n\n\tfunction emergencyStop(bool _open) external auth returns (bool) {\n\t\tisOpen = _open;\n\t\treturn true;\n\t}\n\n\tfunction transferOut(address _token, address _receiver, uint256 _amount) external auth returns (bool) {\n\t\tif(supportLending[_token]) {\n\t\t\tif (_token == dai) {\n\t\t\t\tILendFMe(lendFMe).withdraw(chai, _amount);\n\t\t\t\tIChai(chai).draw(address(this), _amount);\n\t\t\t}\n\t\t\telse\n\t\t\t\tILendFMe(lendFMe).withdraw(_token, _amount);\n\t\t}\n\t\tuint256 _balance = NonStandardIERC20Token(_token).balanceOf(address(this));\n\t\tif(_balance >= _amount) {\n\t\t\tNonStandardIERC20Token(_token).transfer(_receiver, _amount);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tfunction transferOutALL(address _token, address _receiver) external auth returns (bool) {\n\t\tif(supportLending[_token]) {\n\t\t\tif (_token == dai) {\n\t\t\t\tILendFMe(lendFMe).withdraw(chai, uint256(-1));\n\t\t\t\tIChai(chai).exit(address(this), IERC20Token(chai).balanceOf(address(this)));\n\t\t\t}\n\t\t\telse\n\t\t\t\tILendFMe(lendFMe).withdraw(_token, uint256(-1));\n\t\t}\n\t\tuint256 _balance = NonStandardIERC20Token(_token).balanceOf(address(this));\n\t\tif(_balance > 0) {\n\t\t\tNonStandardIERC20Token(_token).transfer(_receiver, _balance);\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tfunction transferIn(address _token, uint256 _amount) external auth returns (bool) {\n\t\tNonStandardIERC20Token(_token).transferFrom(msg.sender, address(this), _amount);\n\t\tif(supportLending[_token]) {\n\t\t\tif (_token == dai) {\n\t\t\t\tIChai(chai).join(address(this), NonStandardIERC20Token(dai).balanceOf(address(this)));\n\t\t\t\tILendFMe(lendFMe).supply(chai, IERC20Token(chai).balanceOf(address(this)));\n\t\t\t}\n\t\t\telse\n\t\t\t\tILendFMe(lendFMe).supply(_token, NonStandardIERC20Token(_token).balanceOf(address(this)));\n\t\t}\n\t    return true;\n\t}\n\n\tfunction normalizeToken(address _token, uint256 _amount) internal view returns (uint256) {\n\t\tuint256 n = 18;\n\t\treturn _amount.mul((10 ** (n.sub(decimals[_token]))));\n\t}\n\n\tfunction denormalizedToken(address _token, uint256 _amount) internal view returns (uint256) {\n\t\tuint256 n = 18;\n\t\treturn _amount.div((10 ** (n.sub(decimals[_token]))));\n\t}\n}",
        "function": "transferOut(address,address,uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/PeckShield-XSwap/xswap-326a3246b327cd2b8481fd8c22fe8d864e43b0da/contracts/XSwap.sol",
        "vulnerability": "External Call To User-Supplied Address (SWC 107)",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract XSwap is DSAuth {\n\tusing DSMath for uint256;\n\n\tuint256 constant internal OFFSET = 10 ** 18;\n\t//Mainnet\n\t// address private chai = 0x06AF07097C9Eeb7fD685c692751D5C66dB49c215;\n\t// address private dai  = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n\n\t//Rinkeby\n\taddress private chai = 0x8a5C1BD4D75e168a4f65eB902c289400B90FD980;\n\taddress private dai  = 0xA3A59273494BB5B8F0a8FAcf21B3f666A47d6140;\n\n\tbool private actived;\n\taddress public lendFMe;\n\tbool public isOpen;\n\tmapping(address => mapping(address => uint256)) public prices; // 1 tokenA = ? tokenB\n\tmapping(address => mapping(address => uint256)) public fee;   // fee from tokenA to tokenB\n\tmapping(address => bool) public supportLending;\n\tmapping(address => uint256) public decimals;\n\n\tconstructor() public {\n\t}\n\n\tfunction active(address _lendFMe) public {\n\t\trequire(actived == false, \"already actived.\");\n\t\towner = msg.sender;\n\t\tisOpen = true;\n\t\tlendFMe = _lendFMe;\n\t\tactived = true;\n\t}\n\n\t// trade _inputAmount of _input token to get _output token\n\tfunction trade(address _input, address _output, uint256 _inputAmount) public returns (bool) {\n\t\treturn trade(_input, _output, _inputAmount, msg.sender);\n\t}\n\n\tfunction trade(address _input, address _output, uint256 _inputAmount, address _receiver) public returns (bool) {\n\t\trequire(isOpen, \"not open\");\n\t\trequire(prices[_input][_output] != 0, \"invalid token address\");\n\t\trequire(decimals[_input] != 0, \"input decimal not setteled\");\n\t\trequire(decimals[_output] != 0, \"output decimal not setteled\");\n\n\t\tNonStandardIERC20Token(_input).transferFrom(msg.sender, address(this), _inputAmount);\n\t\tif(supportLending[_input]) {\n\t\t\tif (_input == dai) {\n\t\t\t\tIChai(chai).join(address(this), _inputAmount);\n\t\t\t\tILendFMe(lendFMe).supply(chai, IERC20Token(chai).balanceOf(address(this)));\n\t\t\t}\n\t\t\telse\n\t\t\t\tILendFMe(lendFMe).supply(_input, _inputAmount);\n\t\t}\n\t\tuint256 _tokenAmount = normalizeToken(_input, _inputAmount).mul(prices[_input][_output]).div(OFFSET);\n\t\tuint256 _fee = _tokenAmount.mul(fee[_input][_output]).div(OFFSET);\n\t\tuint256 _amountToUser = _tokenAmount.sub(_fee);\n\n\t\tif(supportLending[_output]) {\n\t\t\tif (_output == dai) {\n\t\t\t\tILendFMe(lendFMe).withdraw(chai, _amountToUser); //assume chai / dai >= 1;\n\t\t\t\tIChai(chai).draw(address(this), _amountToUser);\n\t\t\t}\n\t\t\telse\n\t\t\t\tILendFMe(lendFMe).withdraw(_output, denormalizedToken(_output, _amountToUser));\n\t\t}\n\t\tNonStandardIERC20Token(_output).transfer(_receiver, denormalizedToken(_output, _amountToUser));\n\t\treturn true;\n\t}\n\n\tfunction getTokenLiquidation(address _token) public view returns (uint256) {\n\t\tuint256 balanceInDefi = ILendFMe(lendFMe).getSupplyBalance(address(this), _token);\n\t\treturn balanceInDefi.add(NonStandardIERC20Token(_token).balanceOf(address(this)));\n\t}\n\n\tfunction setLendFMe(address _lendFMe) public auth returns (bool) {\n\t\tlendFMe = _lendFMe;\n\t\treturn true;\n\t}\n\n\tfunction enableLending(address _token) public auth returns (bool) {\n\t\trequire(!supportLending[_token], \"the token is already supported lending\");\n\t\tsupportLending[_token] = true;\n\n\t\tif (_token == dai) {\n\t\t\tIERC20Token(_token).approve(chai, uint256(-1));\n\t\t\tIERC20Token(chai).approve(lendFMe, uint256(-1));\n\t\t}\n\t\telse {\n\t\t\tNonStandardIERC20Token(_token).approve(lendFMe, uint256(-1));\n\t\t}\n\n\t\tuint256 _balance = NonStandardIERC20Token(_token).balanceOf(address(this));\n\t\tif(_balance > 0) {\n\t\t\tif (_token == dai) {\n\t\t\t\tIChai(chai).join(address(this), _balance);\n\t\t\t\tILendFMe(lendFMe).supply(chai, IERC20Token(chai).balanceOf(address(this)));\n\t\t\t}\n\t\t\telse\n\t\t\t\tILendFMe(lendFMe).supply(_token, _balance);\n\t\t}\n\t\treturn true;\n\t}\n\n\tfunction disableLending(address _token) public auth returns (bool) {\n\t\trequire(supportLending[_token], \"the token doesnt support lending\");\n\t\tsupportLending[_token] = false;\n\n\t\tif (_token == dai) {\n\t\t\tILendFMe(lendFMe).withdraw(chai, uint256(-1));\n\t\t\tIChai(chai).exit(address(this), IERC20Token(chai).balanceOf(address(this)));\n\t\t}\n\t\telse\n\t\t\tILendFMe(lendFMe).withdraw(_token, uint256(-1));\n\n\t\treturn true;\n\t}\n\n\t// create new pairs\n\tfunction createPair(address _input, address _output, uint256 _priceInOut, uint256 _priceOutIn, uint256 _fee) external auth returns (bool) {\n\t\tsetPrices(_input, _output, _priceInOut, _priceOutIn);\n\t\tsetFee(_input, _output, _fee);\n\t\treturn true;\n\t}\n\n\tfunction setPrices(address _input, address _output, uint256 _priceInOut, uint256 _priceOutIn) public auth returns (bool) {\n\t\tsetPrices(_input, _output, _priceInOut);\n\t\tsetPrices(_output, _input, _priceOutIn);\n\t\treturn true;\n\t}\n\t//SWC-101-Integer Overflow and Underflow: L152\n\tfunction setPrices(address _input, address _output, uint256 _price) public auth returns (bool) {\n\t\tprices[_input][_output] = _price;\n\t\treturn true;\n\t}\n\n\tfunction setFee(address _input, address _output, uint256 _fee) public auth returns (bool) {\n\t\tfee[_input][_output] = _fee;\n\t\tfee[_output][_input] = _fee;\n\t\treturn true;\n\t}\n\n\tfunction setTokenDecimals(address _token, uint256 _decimals) public auth returns (bool){\n\t\trequire(_decimals <= 18, \"not supported decimal\");\n\t\tdecimals[_token] = _decimals;\n\t\treturn true;\n\t}\n\n\tfunction emergencyStop(bool _open) external auth returns (bool) {\n\t\tisOpen = _open;\n\t\treturn true;\n\t}\n\n\tfunction transferOut(address _token, address _receiver, uint256 _amount) external auth returns (bool) {\n\t\tif(supportLending[_token]) {\n\t\t\tif (_token == dai) {\n\t\t\t\tILendFMe(lendFMe).withdraw(chai, _amount);\n\t\t\t\tIChai(chai).draw(address(this), _amount);\n\t\t\t}\n\t\t\telse\n\t\t\t\tILendFMe(lendFMe).withdraw(_token, _amount);\n\t\t}\n\t\tuint256 _balance = NonStandardIERC20Token(_token).balanceOf(address(this));\n\t\tif(_balance >= _amount) {\n\t\t\tNonStandardIERC20Token(_token).transfer(_receiver, _amount);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tfunction transferOutALL(address _token, address _receiver) external auth returns (bool) {\n\t\tif(supportLending[_token]) {\n\t\t\tif (_token == dai) {\n\t\t\t\tILendFMe(lendFMe).withdraw(chai, uint256(-1));\n\t\t\t\tIChai(chai).exit(address(this), IERC20Token(chai).balanceOf(address(this)));\n\t\t\t}\n\t\t\telse\n\t\t\t\tILendFMe(lendFMe).withdraw(_token, uint256(-1));\n\t\t}\n\t\tuint256 _balance = NonStandardIERC20Token(_token).balanceOf(address(this));\n\t\tif(_balance > 0) {\n\t\t\tNonStandardIERC20Token(_token).transfer(_receiver, _balance);\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tfunction transferIn(address _token, uint256 _amount) external auth returns (bool) {\n\t\tNonStandardIERC20Token(_token).transferFrom(msg.sender, address(this), _amount);\n\t\tif(supportLending[_token]) {\n\t\t\tif (_token == dai) {\n\t\t\t\tIChai(chai).join(address(this), NonStandardIERC20Token(dai).balanceOf(address(this)));\n\t\t\t\tILendFMe(lendFMe).supply(chai, IERC20Token(chai).balanceOf(address(this)));\n\t\t\t}\n\t\t\telse\n\t\t\t\tILendFMe(lendFMe).supply(_token, NonStandardIERC20Token(_token).balanceOf(address(this)));\n\t\t}\n\t    return true;\n\t}\n\n\tfunction normalizeToken(address _token, uint256 _amount) internal view returns (uint256) {\n\t\tuint256 n = 18;\n\t\treturn _amount.mul((10 ** (n.sub(decimals[_token]))));\n\t}\n\n\tfunction denormalizedToken(address _token, uint256 _amount) internal view returns (uint256) {\n\t\tuint256 n = 18;\n\t\treturn _amount.div((10 ** (n.sub(decimals[_token]))));\n\t}\n}",
        "function": "transferOut(address,address,uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/PeckShield-XSwap/xswap-326a3246b327cd2b8481fd8c22fe8d864e43b0da/contracts/XSwap.sol",
        "vulnerability": "Multiple Calls in a Single Transaction (SWC 113)",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract XSwap is DSAuth {\n\tusing DSMath for uint256;\n\n\tuint256 constant internal OFFSET = 10 ** 18;\n\t//Mainnet\n\t// address private chai = 0x06AF07097C9Eeb7fD685c692751D5C66dB49c215;\n\t// address private dai  = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n\n\t//Rinkeby\n\taddress private chai = 0x8a5C1BD4D75e168a4f65eB902c289400B90FD980;\n\taddress private dai  = 0xA3A59273494BB5B8F0a8FAcf21B3f666A47d6140;\n\n\tbool private actived;\n\taddress public lendFMe;\n\tbool public isOpen;\n\tmapping(address => mapping(address => uint256)) public prices; // 1 tokenA = ? tokenB\n\tmapping(address => mapping(address => uint256)) public fee;   // fee from tokenA to tokenB\n\tmapping(address => bool) public supportLending;\n\tmapping(address => uint256) public decimals;\n\n\tconstructor() public {\n\t}\n\n\tfunction active(address _lendFMe) public {\n\t\trequire(actived == false, \"already actived.\");\n\t\towner = msg.sender;\n\t\tisOpen = true;\n\t\tlendFMe = _lendFMe;\n\t\tactived = true;\n\t}\n\n\t// trade _inputAmount of _input token to get _output token\n\tfunction trade(address _input, address _output, uint256 _inputAmount) public returns (bool) {\n\t\treturn trade(_input, _output, _inputAmount, msg.sender);\n\t}\n\n\tfunction trade(address _input, address _output, uint256 _inputAmount, address _receiver) public returns (bool) {\n\t\trequire(isOpen, \"not open\");\n\t\trequire(prices[_input][_output] != 0, \"invalid token address\");\n\t\trequire(decimals[_input] != 0, \"input decimal not setteled\");\n\t\trequire(decimals[_output] != 0, \"output decimal not setteled\");\n\n\t\tNonStandardIERC20Token(_input).transferFrom(msg.sender, address(this), _inputAmount);\n\t\tif(supportLending[_input]) {\n\t\t\tif (_input == dai) {\n\t\t\t\tIChai(chai).join(address(this), _inputAmount);\n\t\t\t\tILendFMe(lendFMe).supply(chai, IERC20Token(chai).balanceOf(address(this)));\n\t\t\t}\n\t\t\telse\n\t\t\t\tILendFMe(lendFMe).supply(_input, _inputAmount);\n\t\t}\n\t\tuint256 _tokenAmount = normalizeToken(_input, _inputAmount).mul(prices[_input][_output]).div(OFFSET);\n\t\tuint256 _fee = _tokenAmount.mul(fee[_input][_output]).div(OFFSET);\n\t\tuint256 _amountToUser = _tokenAmount.sub(_fee);\n\n\t\tif(supportLending[_output]) {\n\t\t\tif (_output == dai) {\n\t\t\t\tILendFMe(lendFMe).withdraw(chai, _amountToUser); //assume chai / dai >= 1;\n\t\t\t\tIChai(chai).draw(address(this), _amountToUser);\n\t\t\t}\n\t\t\telse\n\t\t\t\tILendFMe(lendFMe).withdraw(_output, denormalizedToken(_output, _amountToUser));\n\t\t}\n\t\tNonStandardIERC20Token(_output).transfer(_receiver, denormalizedToken(_output, _amountToUser));\n\t\treturn true;\n\t}\n\n\tfunction getTokenLiquidation(address _token) public view returns (uint256) {\n\t\tuint256 balanceInDefi = ILendFMe(lendFMe).getSupplyBalance(address(this), _token);\n\t\treturn balanceInDefi.add(NonStandardIERC20Token(_token).balanceOf(address(this)));\n\t}\n\n\tfunction setLendFMe(address _lendFMe) public auth returns (bool) {\n\t\tlendFMe = _lendFMe;\n\t\treturn true;\n\t}\n\n\tfunction enableLending(address _token) public auth returns (bool) {\n\t\trequire(!supportLending[_token], \"the token is already supported lending\");\n\t\tsupportLending[_token] = true;\n\n\t\tif (_token == dai) {\n\t\t\tIERC20Token(_token).approve(chai, uint256(-1));\n\t\t\tIERC20Token(chai).approve(lendFMe, uint256(-1));\n\t\t}\n\t\telse {\n\t\t\tNonStandardIERC20Token(_token).approve(lendFMe, uint256(-1));\n\t\t}\n\n\t\tuint256 _balance = NonStandardIERC20Token(_token).balanceOf(address(this));\n\t\tif(_balance > 0) {\n\t\t\tif (_token == dai) {\n\t\t\t\tIChai(chai).join(address(this), _balance);\n\t\t\t\tILendFMe(lendFMe).supply(chai, IERC20Token(chai).balanceOf(address(this)));\n\t\t\t}\n\t\t\telse\n\t\t\t\tILendFMe(lendFMe).supply(_token, _balance);\n\t\t}\n\t\treturn true;\n\t}\n\n\tfunction disableLending(address _token) public auth returns (bool) {\n\t\trequire(supportLending[_token], \"the token doesnt support lending\");\n\t\tsupportLending[_token] = false;\n\n\t\tif (_token == dai) {\n\t\t\tILendFMe(lendFMe).withdraw(chai, uint256(-1));\n\t\t\tIChai(chai).exit(address(this), IERC20Token(chai).balanceOf(address(this)));\n\t\t}\n\t\telse\n\t\t\tILendFMe(lendFMe).withdraw(_token, uint256(-1));\n\n\t\treturn true;\n\t}\n\n\t// create new pairs\n\tfunction createPair(address _input, address _output, uint256 _priceInOut, uint256 _priceOutIn, uint256 _fee) external auth returns (bool) {\n\t\tsetPrices(_input, _output, _priceInOut, _priceOutIn);\n\t\tsetFee(_input, _output, _fee);\n\t\treturn true;\n\t}\n\n\tfunction setPrices(address _input, address _output, uint256 _priceInOut, uint256 _priceOutIn) public auth returns (bool) {\n\t\tsetPrices(_input, _output, _priceInOut);\n\t\tsetPrices(_output, _input, _priceOutIn);\n\t\treturn true;\n\t}\n\t//SWC-101-Integer Overflow and Underflow: L152\n\tfunction setPrices(address _input, address _output, uint256 _price) public auth returns (bool) {\n\t\tprices[_input][_output] = _price;\n\t\treturn true;\n\t}\n\n\tfunction setFee(address _input, address _output, uint256 _fee) public auth returns (bool) {\n\t\tfee[_input][_output] = _fee;\n\t\tfee[_output][_input] = _fee;\n\t\treturn true;\n\t}\n\n\tfunction setTokenDecimals(address _token, uint256 _decimals) public auth returns (bool){\n\t\trequire(_decimals <= 18, \"not supported decimal\");\n\t\tdecimals[_token] = _decimals;\n\t\treturn true;\n\t}\n\n\tfunction emergencyStop(bool _open) external auth returns (bool) {\n\t\tisOpen = _open;\n\t\treturn true;\n\t}\n\n\tfunction transferOut(address _token, address _receiver, uint256 _amount) external auth returns (bool) {\n\t\tif(supportLending[_token]) {\n\t\t\tif (_token == dai) {\n\t\t\t\tILendFMe(lendFMe).withdraw(chai, _amount);\n\t\t\t\tIChai(chai).draw(address(this), _amount);\n\t\t\t}\n\t\t\telse\n\t\t\t\tILendFMe(lendFMe).withdraw(_token, _amount);\n\t\t}\n\t\tuint256 _balance = NonStandardIERC20Token(_token).balanceOf(address(this));\n\t\tif(_balance >= _amount) {\n\t\t\tNonStandardIERC20Token(_token).transfer(_receiver, _amount);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tfunction transferOutALL(address _token, address _receiver) external auth returns (bool) {\n\t\tif(supportLending[_token]) {\n\t\t\tif (_token == dai) {\n\t\t\t\tILendFMe(lendFMe).withdraw(chai, uint256(-1));\n\t\t\t\tIChai(chai).exit(address(this), IERC20Token(chai).balanceOf(address(this)));\n\t\t\t}\n\t\t\telse\n\t\t\t\tILendFMe(lendFMe).withdraw(_token, uint256(-1));\n\t\t}\n\t\tuint256 _balance = NonStandardIERC20Token(_token).balanceOf(address(this));\n\t\tif(_balance > 0) {\n\t\t\tNonStandardIERC20Token(_token).transfer(_receiver, _balance);\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tfunction transferIn(address _token, uint256 _amount) external auth returns (bool) {\n\t\tNonStandardIERC20Token(_token).transferFrom(msg.sender, address(this), _amount);\n\t\tif(supportLending[_token]) {\n\t\t\tif (_token == dai) {\n\t\t\t\tIChai(chai).join(address(this), NonStandardIERC20Token(dai).balanceOf(address(this)));\n\t\t\t\tILendFMe(lendFMe).supply(chai, IERC20Token(chai).balanceOf(address(this)));\n\t\t\t}\n\t\t\telse\n\t\t\t\tILendFMe(lendFMe).supply(_token, NonStandardIERC20Token(_token).balanceOf(address(this)));\n\t\t}\n\t    return true;\n\t}\n\n\tfunction normalizeToken(address _token, uint256 _amount) internal view returns (uint256) {\n\t\tuint256 n = 18;\n\t\treturn _amount.mul((10 ** (n.sub(decimals[_token]))));\n\t}\n\n\tfunction denormalizedToken(address _token, uint256 _amount) internal view returns (uint256) {\n\t\tuint256 n = 18;\n\t\treturn _amount.div((10 ** (n.sub(decimals[_token]))));\n\t}\n}",
        "function": "transferOutALL(address,address)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/PeckShield-XSwap/xswap-326a3246b327cd2b8481fd8c22fe8d864e43b0da/contracts/XSwap.sol",
        "vulnerability": "External Call To User-Supplied Address (SWC 107)",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract XSwap is DSAuth {\n\tusing DSMath for uint256;\n\n\tuint256 constant internal OFFSET = 10 ** 18;\n\t//Mainnet\n\t// address private chai = 0x06AF07097C9Eeb7fD685c692751D5C66dB49c215;\n\t// address private dai  = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n\n\t//Rinkeby\n\taddress private chai = 0x8a5C1BD4D75e168a4f65eB902c289400B90FD980;\n\taddress private dai  = 0xA3A59273494BB5B8F0a8FAcf21B3f666A47d6140;\n\n\tbool private actived;\n\taddress public lendFMe;\n\tbool public isOpen;\n\tmapping(address => mapping(address => uint256)) public prices; // 1 tokenA = ? tokenB\n\tmapping(address => mapping(address => uint256)) public fee;   // fee from tokenA to tokenB\n\tmapping(address => bool) public supportLending;\n\tmapping(address => uint256) public decimals;\n\n\tconstructor() public {\n\t}\n\n\tfunction active(address _lendFMe) public {\n\t\trequire(actived == false, \"already actived.\");\n\t\towner = msg.sender;\n\t\tisOpen = true;\n\t\tlendFMe = _lendFMe;\n\t\tactived = true;\n\t}\n\n\t// trade _inputAmount of _input token to get _output token\n\tfunction trade(address _input, address _output, uint256 _inputAmount) public returns (bool) {\n\t\treturn trade(_input, _output, _inputAmount, msg.sender);\n\t}\n\n\tfunction trade(address _input, address _output, uint256 _inputAmount, address _receiver) public returns (bool) {\n\t\trequire(isOpen, \"not open\");\n\t\trequire(prices[_input][_output] != 0, \"invalid token address\");\n\t\trequire(decimals[_input] != 0, \"input decimal not setteled\");\n\t\trequire(decimals[_output] != 0, \"output decimal not setteled\");\n\n\t\tNonStandardIERC20Token(_input).transferFrom(msg.sender, address(this), _inputAmount);\n\t\tif(supportLending[_input]) {\n\t\t\tif (_input == dai) {\n\t\t\t\tIChai(chai).join(address(this), _inputAmount);\n\t\t\t\tILendFMe(lendFMe).supply(chai, IERC20Token(chai).balanceOf(address(this)));\n\t\t\t}\n\t\t\telse\n\t\t\t\tILendFMe(lendFMe).supply(_input, _inputAmount);\n\t\t}\n\t\tuint256 _tokenAmount = normalizeToken(_input, _inputAmount).mul(prices[_input][_output]).div(OFFSET);\n\t\tuint256 _fee = _tokenAmount.mul(fee[_input][_output]).div(OFFSET);\n\t\tuint256 _amountToUser = _tokenAmount.sub(_fee);\n\n\t\tif(supportLending[_output]) {\n\t\t\tif (_output == dai) {\n\t\t\t\tILendFMe(lendFMe).withdraw(chai, _amountToUser); //assume chai / dai >= 1;\n\t\t\t\tIChai(chai).draw(address(this), _amountToUser);\n\t\t\t}\n\t\t\telse\n\t\t\t\tILendFMe(lendFMe).withdraw(_output, denormalizedToken(_output, _amountToUser));\n\t\t}\n\t\tNonStandardIERC20Token(_output).transfer(_receiver, denormalizedToken(_output, _amountToUser));\n\t\treturn true;\n\t}\n\n\tfunction getTokenLiquidation(address _token) public view returns (uint256) {\n\t\tuint256 balanceInDefi = ILendFMe(lendFMe).getSupplyBalance(address(this), _token);\n\t\treturn balanceInDefi.add(NonStandardIERC20Token(_token).balanceOf(address(this)));\n\t}\n\n\tfunction setLendFMe(address _lendFMe) public auth returns (bool) {\n\t\tlendFMe = _lendFMe;\n\t\treturn true;\n\t}\n\n\tfunction enableLending(address _token) public auth returns (bool) {\n\t\trequire(!supportLending[_token], \"the token is already supported lending\");\n\t\tsupportLending[_token] = true;\n\n\t\tif (_token == dai) {\n\t\t\tIERC20Token(_token).approve(chai, uint256(-1));\n\t\t\tIERC20Token(chai).approve(lendFMe, uint256(-1));\n\t\t}\n\t\telse {\n\t\t\tNonStandardIERC20Token(_token).approve(lendFMe, uint256(-1));\n\t\t}\n\n\t\tuint256 _balance = NonStandardIERC20Token(_token).balanceOf(address(this));\n\t\tif(_balance > 0) {\n\t\t\tif (_token == dai) {\n\t\t\t\tIChai(chai).join(address(this), _balance);\n\t\t\t\tILendFMe(lendFMe).supply(chai, IERC20Token(chai).balanceOf(address(this)));\n\t\t\t}\n\t\t\telse\n\t\t\t\tILendFMe(lendFMe).supply(_token, _balance);\n\t\t}\n\t\treturn true;\n\t}\n\n\tfunction disableLending(address _token) public auth returns (bool) {\n\t\trequire(supportLending[_token], \"the token doesnt support lending\");\n\t\tsupportLending[_token] = false;\n\n\t\tif (_token == dai) {\n\t\t\tILendFMe(lendFMe).withdraw(chai, uint256(-1));\n\t\t\tIChai(chai).exit(address(this), IERC20Token(chai).balanceOf(address(this)));\n\t\t}\n\t\telse\n\t\t\tILendFMe(lendFMe).withdraw(_token, uint256(-1));\n\n\t\treturn true;\n\t}\n\n\t// create new pairs\n\tfunction createPair(address _input, address _output, uint256 _priceInOut, uint256 _priceOutIn, uint256 _fee) external auth returns (bool) {\n\t\tsetPrices(_input, _output, _priceInOut, _priceOutIn);\n\t\tsetFee(_input, _output, _fee);\n\t\treturn true;\n\t}\n\n\tfunction setPrices(address _input, address _output, uint256 _priceInOut, uint256 _priceOutIn) public auth returns (bool) {\n\t\tsetPrices(_input, _output, _priceInOut);\n\t\tsetPrices(_output, _input, _priceOutIn);\n\t\treturn true;\n\t}\n\t//SWC-101-Integer Overflow and Underflow: L152\n\tfunction setPrices(address _input, address _output, uint256 _price) public auth returns (bool) {\n\t\tprices[_input][_output] = _price;\n\t\treturn true;\n\t}\n\n\tfunction setFee(address _input, address _output, uint256 _fee) public auth returns (bool) {\n\t\tfee[_input][_output] = _fee;\n\t\tfee[_output][_input] = _fee;\n\t\treturn true;\n\t}\n\n\tfunction setTokenDecimals(address _token, uint256 _decimals) public auth returns (bool){\n\t\trequire(_decimals <= 18, \"not supported decimal\");\n\t\tdecimals[_token] = _decimals;\n\t\treturn true;\n\t}\n\n\tfunction emergencyStop(bool _open) external auth returns (bool) {\n\t\tisOpen = _open;\n\t\treturn true;\n\t}\n\n\tfunction transferOut(address _token, address _receiver, uint256 _amount) external auth returns (bool) {\n\t\tif(supportLending[_token]) {\n\t\t\tif (_token == dai) {\n\t\t\t\tILendFMe(lendFMe).withdraw(chai, _amount);\n\t\t\t\tIChai(chai).draw(address(this), _amount);\n\t\t\t}\n\t\t\telse\n\t\t\t\tILendFMe(lendFMe).withdraw(_token, _amount);\n\t\t}\n\t\tuint256 _balance = NonStandardIERC20Token(_token).balanceOf(address(this));\n\t\tif(_balance >= _amount) {\n\t\t\tNonStandardIERC20Token(_token).transfer(_receiver, _amount);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tfunction transferOutALL(address _token, address _receiver) external auth returns (bool) {\n\t\tif(supportLending[_token]) {\n\t\t\tif (_token == dai) {\n\t\t\t\tILendFMe(lendFMe).withdraw(chai, uint256(-1));\n\t\t\t\tIChai(chai).exit(address(this), IERC20Token(chai).balanceOf(address(this)));\n\t\t\t}\n\t\t\telse\n\t\t\t\tILendFMe(lendFMe).withdraw(_token, uint256(-1));\n\t\t}\n\t\tuint256 _balance = NonStandardIERC20Token(_token).balanceOf(address(this));\n\t\tif(_balance > 0) {\n\t\t\tNonStandardIERC20Token(_token).transfer(_receiver, _balance);\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tfunction transferIn(address _token, uint256 _amount) external auth returns (bool) {\n\t\tNonStandardIERC20Token(_token).transferFrom(msg.sender, address(this), _amount);\n\t\tif(supportLending[_token]) {\n\t\t\tif (_token == dai) {\n\t\t\t\tIChai(chai).join(address(this), NonStandardIERC20Token(dai).balanceOf(address(this)));\n\t\t\t\tILendFMe(lendFMe).supply(chai, IERC20Token(chai).balanceOf(address(this)));\n\t\t\t}\n\t\t\telse\n\t\t\t\tILendFMe(lendFMe).supply(_token, NonStandardIERC20Token(_token).balanceOf(address(this)));\n\t\t}\n\t    return true;\n\t}\n\n\tfunction normalizeToken(address _token, uint256 _amount) internal view returns (uint256) {\n\t\tuint256 n = 18;\n\t\treturn _amount.mul((10 ** (n.sub(decimals[_token]))));\n\t}\n\n\tfunction denormalizedToken(address _token, uint256 _amount) internal view returns (uint256) {\n\t\tuint256 n = 18;\n\t\treturn _amount.div((10 ** (n.sub(decimals[_token]))));\n\t}\n}",
        "function": "transferOutALL(address,address)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/PeckShield-XSwap/xswap-326a3246b327cd2b8481fd8c22fe8d864e43b0da/contracts/XSwap.sol",
        "vulnerability": "Multiple Calls in a Single Transaction (SWC 113)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract XSwap is DSAuth {\n\tusing DSMath for uint256;\n\n\tuint256 constant internal OFFSET = 10 ** 18;\n\t//Mainnet\n\t// address private chai = 0x06AF07097C9Eeb7fD685c692751D5C66dB49c215;\n\t// address private dai  = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n\n\t//Rinkeby\n\taddress private chai = 0x8a5C1BD4D75e168a4f65eB902c289400B90FD980;\n\taddress private dai  = 0xA3A59273494BB5B8F0a8FAcf21B3f666A47d6140;\n\n\tbool private actived;\n\taddress public lendFMe;\n\tbool public isOpen;\n\tmapping(address => mapping(address => uint256)) public prices; // 1 tokenA = ? tokenB\n\tmapping(address => mapping(address => uint256)) public fee;   // fee from tokenA to tokenB\n\tmapping(address => bool) public supportLending;\n\tmapping(address => uint256) public decimals;\n\n\tconstructor() public {\n\t}\n\n\tfunction active(address _lendFMe) public {\n\t\trequire(actived == false, \"already actived.\");\n\t\towner = msg.sender;\n\t\tisOpen = true;\n\t\tlendFMe = _lendFMe;\n\t\tactived = true;\n\t}\n\n\t// trade _inputAmount of _input token to get _output token\n\tfunction trade(address _input, address _output, uint256 _inputAmount) public returns (bool) {\n\t\treturn trade(_input, _output, _inputAmount, msg.sender);\n\t}\n\n\tfunction trade(address _input, address _output, uint256 _inputAmount, address _receiver) public returns (bool) {\n\t\trequire(isOpen, \"not open\");\n\t\trequire(prices[_input][_output] != 0, \"invalid token address\");\n\t\trequire(decimals[_input] != 0, \"input decimal not setteled\");\n\t\trequire(decimals[_output] != 0, \"output decimal not setteled\");\n\n\t\tNonStandardIERC20Token(_input).transferFrom(msg.sender, address(this), _inputAmount);\n\t\tif(supportLending[_input]) {\n\t\t\tif (_input == dai) {\n\t\t\t\tIChai(chai).join(address(this), _inputAmount);\n\t\t\t\tILendFMe(lendFMe).supply(chai, IERC20Token(chai).balanceOf(address(this)));\n\t\t\t}\n\t\t\telse\n\t\t\t\tILendFMe(lendFMe).supply(_input, _inputAmount);\n\t\t}\n\t\tuint256 _tokenAmount = normalizeToken(_input, _inputAmount).mul(prices[_input][_output]).div(OFFSET);\n\t\tuint256 _fee = _tokenAmount.mul(fee[_input][_output]).div(OFFSET);\n\t\tuint256 _amountToUser = _tokenAmount.sub(_fee);\n\n\t\tif(supportLending[_output]) {\n\t\t\tif (_output == dai) {\n\t\t\t\tILendFMe(lendFMe).withdraw(chai, _amountToUser); //assume chai / dai >= 1;\n\t\t\t\tIChai(chai).draw(address(this), _amountToUser);\n\t\t\t}\n\t\t\telse\n\t\t\t\tILendFMe(lendFMe).withdraw(_output, denormalizedToken(_output, _amountToUser));\n\t\t}\n\t\tNonStandardIERC20Token(_output).transfer(_receiver, denormalizedToken(_output, _amountToUser));\n\t\treturn true;\n\t}\n\n\tfunction getTokenLiquidation(address _token) public view returns (uint256) {\n\t\tuint256 balanceInDefi = ILendFMe(lendFMe).getSupplyBalance(address(this), _token);\n\t\treturn balanceInDefi.add(NonStandardIERC20Token(_token).balanceOf(address(this)));\n\t}\n\n\tfunction setLendFMe(address _lendFMe) public auth returns (bool) {\n\t\tlendFMe = _lendFMe;\n\t\treturn true;\n\t}\n\n\tfunction enableLending(address _token) public auth returns (bool) {\n\t\trequire(!supportLending[_token], \"the token is already supported lending\");\n\t\tsupportLending[_token] = true;\n\n\t\tif (_token == dai) {\n\t\t\tIERC20Token(_token).approve(chai, uint256(-1));\n\t\t\tIERC20Token(chai).approve(lendFMe, uint256(-1));\n\t\t}\n\t\telse {\n\t\t\tNonStandardIERC20Token(_token).approve(lendFMe, uint256(-1));\n\t\t}\n\n\t\tuint256 _balance = NonStandardIERC20Token(_token).balanceOf(address(this));\n\t\tif(_balance > 0) {\n\t\t\tif (_token == dai) {\n\t\t\t\tIChai(chai).join(address(this), _balance);\n\t\t\t\tILendFMe(lendFMe).supply(chai, IERC20Token(chai).balanceOf(address(this)));\n\t\t\t}\n\t\t\telse\n\t\t\t\tILendFMe(lendFMe).supply(_token, _balance);\n\t\t}\n\t\treturn true;\n\t}\n\n\tfunction disableLending(address _token) public auth returns (bool) {\n\t\trequire(supportLending[_token], \"the token doesnt support lending\");\n\t\tsupportLending[_token] = false;\n\n\t\tif (_token == dai) {\n\t\t\tILendFMe(lendFMe).withdraw(chai, uint256(-1));\n\t\t\tIChai(chai).exit(address(this), IERC20Token(chai).balanceOf(address(this)));\n\t\t}\n\t\telse\n\t\t\tILendFMe(lendFMe).withdraw(_token, uint256(-1));\n\n\t\treturn true;\n\t}\n\n\t// create new pairs\n\tfunction createPair(address _input, address _output, uint256 _priceInOut, uint256 _priceOutIn, uint256 _fee) external auth returns (bool) {\n\t\tsetPrices(_input, _output, _priceInOut, _priceOutIn);\n\t\tsetFee(_input, _output, _fee);\n\t\treturn true;\n\t}\n\n\tfunction setPrices(address _input, address _output, uint256 _priceInOut, uint256 _priceOutIn) public auth returns (bool) {\n\t\tsetPrices(_input, _output, _priceInOut);\n\t\tsetPrices(_output, _input, _priceOutIn);\n\t\treturn true;\n\t}\n\t//SWC-101-Integer Overflow and Underflow: L152\n\tfunction setPrices(address _input, address _output, uint256 _price) public auth returns (bool) {\n\t\tprices[_input][_output] = _price;\n\t\treturn true;\n\t}\n\n\tfunction setFee(address _input, address _output, uint256 _fee) public auth returns (bool) {\n\t\tfee[_input][_output] = _fee;\n\t\tfee[_output][_input] = _fee;\n\t\treturn true;\n\t}\n\n\tfunction setTokenDecimals(address _token, uint256 _decimals) public auth returns (bool){\n\t\trequire(_decimals <= 18, \"not supported decimal\");\n\t\tdecimals[_token] = _decimals;\n\t\treturn true;\n\t}\n\n\tfunction emergencyStop(bool _open) external auth returns (bool) {\n\t\tisOpen = _open;\n\t\treturn true;\n\t}\n\n\tfunction transferOut(address _token, address _receiver, uint256 _amount) external auth returns (bool) {\n\t\tif(supportLending[_token]) {\n\t\t\tif (_token == dai) {\n\t\t\t\tILendFMe(lendFMe).withdraw(chai, _amount);\n\t\t\t\tIChai(chai).draw(address(this), _amount);\n\t\t\t}\n\t\t\telse\n\t\t\t\tILendFMe(lendFMe).withdraw(_token, _amount);\n\t\t}\n\t\tuint256 _balance = NonStandardIERC20Token(_token).balanceOf(address(this));\n\t\tif(_balance >= _amount) {\n\t\t\tNonStandardIERC20Token(_token).transfer(_receiver, _amount);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tfunction transferOutALL(address _token, address _receiver) external auth returns (bool) {\n\t\tif(supportLending[_token]) {\n\t\t\tif (_token == dai) {\n\t\t\t\tILendFMe(lendFMe).withdraw(chai, uint256(-1));\n\t\t\t\tIChai(chai).exit(address(this), IERC20Token(chai).balanceOf(address(this)));\n\t\t\t}\n\t\t\telse\n\t\t\t\tILendFMe(lendFMe).withdraw(_token, uint256(-1));\n\t\t}\n\t\tuint256 _balance = NonStandardIERC20Token(_token).balanceOf(address(this));\n\t\tif(_balance > 0) {\n\t\t\tNonStandardIERC20Token(_token).transfer(_receiver, _balance);\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tfunction transferIn(address _token, uint256 _amount) external auth returns (bool) {\n\t\tNonStandardIERC20Token(_token).transferFrom(msg.sender, address(this), _amount);\n\t\tif(supportLending[_token]) {\n\t\t\tif (_token == dai) {\n\t\t\t\tIChai(chai).join(address(this), NonStandardIERC20Token(dai).balanceOf(address(this)));\n\t\t\t\tILendFMe(lendFMe).supply(chai, IERC20Token(chai).balanceOf(address(this)));\n\t\t\t}\n\t\t\telse\n\t\t\t\tILendFMe(lendFMe).supply(_token, NonStandardIERC20Token(_token).balanceOf(address(this)));\n\t\t}\n\t    return true;\n\t}\n\n\tfunction normalizeToken(address _token, uint256 _amount) internal view returns (uint256) {\n\t\tuint256 n = 18;\n\t\treturn _amount.mul((10 ** (n.sub(decimals[_token]))));\n\t}\n\n\tfunction denormalizedToken(address _token, uint256 _amount) internal view returns (uint256) {\n\t\tuint256 n = 18;\n\t\treturn _amount.div((10 ** (n.sub(decimals[_token]))));\n\t}\n}",
        "function": "enableLending(address)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/PeckShield-XSwap/xswap-326a3246b327cd2b8481fd8c22fe8d864e43b0da/contracts/XSwap.sol",
        "vulnerability": "State access after external call (SWC 107)",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract XSwap is DSAuth {\n\tusing DSMath for uint256;\n\n\tuint256 constant internal OFFSET = 10 ** 18;\n\t//Mainnet\n\t// address private chai = 0x06AF07097C9Eeb7fD685c692751D5C66dB49c215;\n\t// address private dai  = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n\n\t//Rinkeby\n\taddress private chai = 0x8a5C1BD4D75e168a4f65eB902c289400B90FD980;\n\taddress private dai  = 0xA3A59273494BB5B8F0a8FAcf21B3f666A47d6140;\n\n\tbool private actived;\n\taddress public lendFMe;\n\tbool public isOpen;\n\tmapping(address => mapping(address => uint256)) public prices; // 1 tokenA = ? tokenB\n\tmapping(address => mapping(address => uint256)) public fee;   // fee from tokenA to tokenB\n\tmapping(address => bool) public supportLending;\n\tmapping(address => uint256) public decimals;\n\n\tconstructor() public {\n\t}\n\n\tfunction active(address _lendFMe) public {\n\t\trequire(actived == false, \"already actived.\");\n\t\towner = msg.sender;\n\t\tisOpen = true;\n\t\tlendFMe = _lendFMe;\n\t\tactived = true;\n\t}\n\n\t// trade _inputAmount of _input token to get _output token\n\tfunction trade(address _input, address _output, uint256 _inputAmount) public returns (bool) {\n\t\treturn trade(_input, _output, _inputAmount, msg.sender);\n\t}\n\n\tfunction trade(address _input, address _output, uint256 _inputAmount, address _receiver) public returns (bool) {\n\t\trequire(isOpen, \"not open\");\n\t\trequire(prices[_input][_output] != 0, \"invalid token address\");\n\t\trequire(decimals[_input] != 0, \"input decimal not setteled\");\n\t\trequire(decimals[_output] != 0, \"output decimal not setteled\");\n\n\t\tNonStandardIERC20Token(_input).transferFrom(msg.sender, address(this), _inputAmount);\n\t\tif(supportLending[_input]) {\n\t\t\tif (_input == dai) {\n\t\t\t\tIChai(chai).join(address(this), _inputAmount);\n\t\t\t\tILendFMe(lendFMe).supply(chai, IERC20Token(chai).balanceOf(address(this)));\n\t\t\t}\n\t\t\telse\n\t\t\t\tILendFMe(lendFMe).supply(_input, _inputAmount);\n\t\t}\n\t\tuint256 _tokenAmount = normalizeToken(_input, _inputAmount).mul(prices[_input][_output]).div(OFFSET);\n\t\tuint256 _fee = _tokenAmount.mul(fee[_input][_output]).div(OFFSET);\n\t\tuint256 _amountToUser = _tokenAmount.sub(_fee);\n\n\t\tif(supportLending[_output]) {\n\t\t\tif (_output == dai) {\n\t\t\t\tILendFMe(lendFMe).withdraw(chai, _amountToUser); //assume chai / dai >= 1;\n\t\t\t\tIChai(chai).draw(address(this), _amountToUser);\n\t\t\t}\n\t\t\telse\n\t\t\t\tILendFMe(lendFMe).withdraw(_output, denormalizedToken(_output, _amountToUser));\n\t\t}\n\t\tNonStandardIERC20Token(_output).transfer(_receiver, denormalizedToken(_output, _amountToUser));\n\t\treturn true;\n\t}\n\n\tfunction getTokenLiquidation(address _token) public view returns (uint256) {\n\t\tuint256 balanceInDefi = ILendFMe(lendFMe).getSupplyBalance(address(this), _token);\n\t\treturn balanceInDefi.add(NonStandardIERC20Token(_token).balanceOf(address(this)));\n\t}\n\n\tfunction setLendFMe(address _lendFMe) public auth returns (bool) {\n\t\tlendFMe = _lendFMe;\n\t\treturn true;\n\t}\n\n\tfunction enableLending(address _token) public auth returns (bool) {\n\t\trequire(!supportLending[_token], \"the token is already supported lending\");\n\t\tsupportLending[_token] = true;\n\n\t\tif (_token == dai) {\n\t\t\tIERC20Token(_token).approve(chai, uint256(-1));\n\t\t\tIERC20Token(chai).approve(lendFMe, uint256(-1));\n\t\t}\n\t\telse {\n\t\t\tNonStandardIERC20Token(_token).approve(lendFMe, uint256(-1));\n\t\t}\n\n\t\tuint256 _balance = NonStandardIERC20Token(_token).balanceOf(address(this));\n\t\tif(_balance > 0) {\n\t\t\tif (_token == dai) {\n\t\t\t\tIChai(chai).join(address(this), _balance);\n\t\t\t\tILendFMe(lendFMe).supply(chai, IERC20Token(chai).balanceOf(address(this)));\n\t\t\t}\n\t\t\telse\n\t\t\t\tILendFMe(lendFMe).supply(_token, _balance);\n\t\t}\n\t\treturn true;\n\t}\n\n\tfunction disableLending(address _token) public auth returns (bool) {\n\t\trequire(supportLending[_token], \"the token doesnt support lending\");\n\t\tsupportLending[_token] = false;\n\n\t\tif (_token == dai) {\n\t\t\tILendFMe(lendFMe).withdraw(chai, uint256(-1));\n\t\t\tIChai(chai).exit(address(this), IERC20Token(chai).balanceOf(address(this)));\n\t\t}\n\t\telse\n\t\t\tILendFMe(lendFMe).withdraw(_token, uint256(-1));\n\n\t\treturn true;\n\t}\n\n\t// create new pairs\n\tfunction createPair(address _input, address _output, uint256 _priceInOut, uint256 _priceOutIn, uint256 _fee) external auth returns (bool) {\n\t\tsetPrices(_input, _output, _priceInOut, _priceOutIn);\n\t\tsetFee(_input, _output, _fee);\n\t\treturn true;\n\t}\n\n\tfunction setPrices(address _input, address _output, uint256 _priceInOut, uint256 _priceOutIn) public auth returns (bool) {\n\t\tsetPrices(_input, _output, _priceInOut);\n\t\tsetPrices(_output, _input, _priceOutIn);\n\t\treturn true;\n\t}\n\t//SWC-101-Integer Overflow and Underflow: L152\n\tfunction setPrices(address _input, address _output, uint256 _price) public auth returns (bool) {\n\t\tprices[_input][_output] = _price;\n\t\treturn true;\n\t}\n\n\tfunction setFee(address _input, address _output, uint256 _fee) public auth returns (bool) {\n\t\tfee[_input][_output] = _fee;\n\t\tfee[_output][_input] = _fee;\n\t\treturn true;\n\t}\n\n\tfunction setTokenDecimals(address _token, uint256 _decimals) public auth returns (bool){\n\t\trequire(_decimals <= 18, \"not supported decimal\");\n\t\tdecimals[_token] = _decimals;\n\t\treturn true;\n\t}\n\n\tfunction emergencyStop(bool _open) external auth returns (bool) {\n\t\tisOpen = _open;\n\t\treturn true;\n\t}\n\n\tfunction transferOut(address _token, address _receiver, uint256 _amount) external auth returns (bool) {\n\t\tif(supportLending[_token]) {\n\t\t\tif (_token == dai) {\n\t\t\t\tILendFMe(lendFMe).withdraw(chai, _amount);\n\t\t\t\tIChai(chai).draw(address(this), _amount);\n\t\t\t}\n\t\t\telse\n\t\t\t\tILendFMe(lendFMe).withdraw(_token, _amount);\n\t\t}\n\t\tuint256 _balance = NonStandardIERC20Token(_token).balanceOf(address(this));\n\t\tif(_balance >= _amount) {\n\t\t\tNonStandardIERC20Token(_token).transfer(_receiver, _amount);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tfunction transferOutALL(address _token, address _receiver) external auth returns (bool) {\n\t\tif(supportLending[_token]) {\n\t\t\tif (_token == dai) {\n\t\t\t\tILendFMe(lendFMe).withdraw(chai, uint256(-1));\n\t\t\t\tIChai(chai).exit(address(this), IERC20Token(chai).balanceOf(address(this)));\n\t\t\t}\n\t\t\telse\n\t\t\t\tILendFMe(lendFMe).withdraw(_token, uint256(-1));\n\t\t}\n\t\tuint256 _balance = NonStandardIERC20Token(_token).balanceOf(address(this));\n\t\tif(_balance > 0) {\n\t\t\tNonStandardIERC20Token(_token).transfer(_receiver, _balance);\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tfunction transferIn(address _token, uint256 _amount) external auth returns (bool) {\n\t\tNonStandardIERC20Token(_token).transferFrom(msg.sender, address(this), _amount);\n\t\tif(supportLending[_token]) {\n\t\t\tif (_token == dai) {\n\t\t\t\tIChai(chai).join(address(this), NonStandardIERC20Token(dai).balanceOf(address(this)));\n\t\t\t\tILendFMe(lendFMe).supply(chai, IERC20Token(chai).balanceOf(address(this)));\n\t\t\t}\n\t\t\telse\n\t\t\t\tILendFMe(lendFMe).supply(_token, NonStandardIERC20Token(_token).balanceOf(address(this)));\n\t\t}\n\t    return true;\n\t}\n\n\tfunction normalizeToken(address _token, uint256 _amount) internal view returns (uint256) {\n\t\tuint256 n = 18;\n\t\treturn _amount.mul((10 ** (n.sub(decimals[_token]))));\n\t}\n\n\tfunction denormalizedToken(address _token, uint256 _amount) internal view returns (uint256) {\n\t\tuint256 n = 18;\n\t\treturn _amount.div((10 ** (n.sub(decimals[_token]))));\n\t}\n}",
        "function": "enableLending(address)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/PeckShield-XSwap/xswap-326a3246b327cd2b8481fd8c22fe8d864e43b0da/contracts/XSwap.sol",
        "vulnerability": "State access after external call (SWC 107)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract XSwap is DSAuth {\n\tusing DSMath for uint256;\n\n\tuint256 constant internal OFFSET = 10 ** 18;\n\t//Mainnet\n\t// address private chai = 0x06AF07097C9Eeb7fD685c692751D5C66dB49c215;\n\t// address private dai  = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n\n\t//Rinkeby\n\taddress private chai = 0x8a5C1BD4D75e168a4f65eB902c289400B90FD980;\n\taddress private dai  = 0xA3A59273494BB5B8F0a8FAcf21B3f666A47d6140;\n\n\tbool private actived;\n\taddress public lendFMe;\n\tbool public isOpen;\n\tmapping(address => mapping(address => uint256)) public prices; // 1 tokenA = ? tokenB\n\tmapping(address => mapping(address => uint256)) public fee;   // fee from tokenA to tokenB\n\tmapping(address => bool) public supportLending;\n\tmapping(address => uint256) public decimals;\n\n\tconstructor() public {\n\t}\n\n\tfunction active(address _lendFMe) public {\n\t\trequire(actived == false, \"already actived.\");\n\t\towner = msg.sender;\n\t\tisOpen = true;\n\t\tlendFMe = _lendFMe;\n\t\tactived = true;\n\t}\n\n\t// trade _inputAmount of _input token to get _output token\n\tfunction trade(address _input, address _output, uint256 _inputAmount) public returns (bool) {\n\t\treturn trade(_input, _output, _inputAmount, msg.sender);\n\t}\n\n\tfunction trade(address _input, address _output, uint256 _inputAmount, address _receiver) public returns (bool) {\n\t\trequire(isOpen, \"not open\");\n\t\trequire(prices[_input][_output] != 0, \"invalid token address\");\n\t\trequire(decimals[_input] != 0, \"input decimal not setteled\");\n\t\trequire(decimals[_output] != 0, \"output decimal not setteled\");\n\n\t\tNonStandardIERC20Token(_input).transferFrom(msg.sender, address(this), _inputAmount);\n\t\tif(supportLending[_input]) {\n\t\t\tif (_input == dai) {\n\t\t\t\tIChai(chai).join(address(this), _inputAmount);\n\t\t\t\tILendFMe(lendFMe).supply(chai, IERC20Token(chai).balanceOf(address(this)));\n\t\t\t}\n\t\t\telse\n\t\t\t\tILendFMe(lendFMe).supply(_input, _inputAmount);\n\t\t}\n\t\tuint256 _tokenAmount = normalizeToken(_input, _inputAmount).mul(prices[_input][_output]).div(OFFSET);\n\t\tuint256 _fee = _tokenAmount.mul(fee[_input][_output]).div(OFFSET);\n\t\tuint256 _amountToUser = _tokenAmount.sub(_fee);\n\n\t\tif(supportLending[_output]) {\n\t\t\tif (_output == dai) {\n\t\t\t\tILendFMe(lendFMe).withdraw(chai, _amountToUser); //assume chai / dai >= 1;\n\t\t\t\tIChai(chai).draw(address(this), _amountToUser);\n\t\t\t}\n\t\t\telse\n\t\t\t\tILendFMe(lendFMe).withdraw(_output, denormalizedToken(_output, _amountToUser));\n\t\t}\n\t\tNonStandardIERC20Token(_output).transfer(_receiver, denormalizedToken(_output, _amountToUser));\n\t\treturn true;\n\t}\n\n\tfunction getTokenLiquidation(address _token) public view returns (uint256) {\n\t\tuint256 balanceInDefi = ILendFMe(lendFMe).getSupplyBalance(address(this), _token);\n\t\treturn balanceInDefi.add(NonStandardIERC20Token(_token).balanceOf(address(this)));\n\t}\n\n\tfunction setLendFMe(address _lendFMe) public auth returns (bool) {\n\t\tlendFMe = _lendFMe;\n\t\treturn true;\n\t}\n\n\tfunction enableLending(address _token) public auth returns (bool) {\n\t\trequire(!supportLending[_token], \"the token is already supported lending\");\n\t\tsupportLending[_token] = true;\n\n\t\tif (_token == dai) {\n\t\t\tIERC20Token(_token).approve(chai, uint256(-1));\n\t\t\tIERC20Token(chai).approve(lendFMe, uint256(-1));\n\t\t}\n\t\telse {\n\t\t\tNonStandardIERC20Token(_token).approve(lendFMe, uint256(-1));\n\t\t}\n\n\t\tuint256 _balance = NonStandardIERC20Token(_token).balanceOf(address(this));\n\t\tif(_balance > 0) {\n\t\t\tif (_token == dai) {\n\t\t\t\tIChai(chai).join(address(this), _balance);\n\t\t\t\tILendFMe(lendFMe).supply(chai, IERC20Token(chai).balanceOf(address(this)));\n\t\t\t}\n\t\t\telse\n\t\t\t\tILendFMe(lendFMe).supply(_token, _balance);\n\t\t}\n\t\treturn true;\n\t}\n\n\tfunction disableLending(address _token) public auth returns (bool) {\n\t\trequire(supportLending[_token], \"the token doesnt support lending\");\n\t\tsupportLending[_token] = false;\n\n\t\tif (_token == dai) {\n\t\t\tILendFMe(lendFMe).withdraw(chai, uint256(-1));\n\t\t\tIChai(chai).exit(address(this), IERC20Token(chai).balanceOf(address(this)));\n\t\t}\n\t\telse\n\t\t\tILendFMe(lendFMe).withdraw(_token, uint256(-1));\n\n\t\treturn true;\n\t}\n\n\t// create new pairs\n\tfunction createPair(address _input, address _output, uint256 _priceInOut, uint256 _priceOutIn, uint256 _fee) external auth returns (bool) {\n\t\tsetPrices(_input, _output, _priceInOut, _priceOutIn);\n\t\tsetFee(_input, _output, _fee);\n\t\treturn true;\n\t}\n\n\tfunction setPrices(address _input, address _output, uint256 _priceInOut, uint256 _priceOutIn) public auth returns (bool) {\n\t\tsetPrices(_input, _output, _priceInOut);\n\t\tsetPrices(_output, _input, _priceOutIn);\n\t\treturn true;\n\t}\n\t//SWC-101-Integer Overflow and Underflow: L152\n\tfunction setPrices(address _input, address _output, uint256 _price) public auth returns (bool) {\n\t\tprices[_input][_output] = _price;\n\t\treturn true;\n\t}\n\n\tfunction setFee(address _input, address _output, uint256 _fee) public auth returns (bool) {\n\t\tfee[_input][_output] = _fee;\n\t\tfee[_output][_input] = _fee;\n\t\treturn true;\n\t}\n\n\tfunction setTokenDecimals(address _token, uint256 _decimals) public auth returns (bool){\n\t\trequire(_decimals <= 18, \"not supported decimal\");\n\t\tdecimals[_token] = _decimals;\n\t\treturn true;\n\t}\n\n\tfunction emergencyStop(bool _open) external auth returns (bool) {\n\t\tisOpen = _open;\n\t\treturn true;\n\t}\n\n\tfunction transferOut(address _token, address _receiver, uint256 _amount) external auth returns (bool) {\n\t\tif(supportLending[_token]) {\n\t\t\tif (_token == dai) {\n\t\t\t\tILendFMe(lendFMe).withdraw(chai, _amount);\n\t\t\t\tIChai(chai).draw(address(this), _amount);\n\t\t\t}\n\t\t\telse\n\t\t\t\tILendFMe(lendFMe).withdraw(_token, _amount);\n\t\t}\n\t\tuint256 _balance = NonStandardIERC20Token(_token).balanceOf(address(this));\n\t\tif(_balance >= _amount) {\n\t\t\tNonStandardIERC20Token(_token).transfer(_receiver, _amount);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tfunction transferOutALL(address _token, address _receiver) external auth returns (bool) {\n\t\tif(supportLending[_token]) {\n\t\t\tif (_token == dai) {\n\t\t\t\tILendFMe(lendFMe).withdraw(chai, uint256(-1));\n\t\t\t\tIChai(chai).exit(address(this), IERC20Token(chai).balanceOf(address(this)));\n\t\t\t}\n\t\t\telse\n\t\t\t\tILendFMe(lendFMe).withdraw(_token, uint256(-1));\n\t\t}\n\t\tuint256 _balance = NonStandardIERC20Token(_token).balanceOf(address(this));\n\t\tif(_balance > 0) {\n\t\t\tNonStandardIERC20Token(_token).transfer(_receiver, _balance);\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tfunction transferIn(address _token, uint256 _amount) external auth returns (bool) {\n\t\tNonStandardIERC20Token(_token).transferFrom(msg.sender, address(this), _amount);\n\t\tif(supportLending[_token]) {\n\t\t\tif (_token == dai) {\n\t\t\t\tIChai(chai).join(address(this), NonStandardIERC20Token(dai).balanceOf(address(this)));\n\t\t\t\tILendFMe(lendFMe).supply(chai, IERC20Token(chai).balanceOf(address(this)));\n\t\t\t}\n\t\t\telse\n\t\t\t\tILendFMe(lendFMe).supply(_token, NonStandardIERC20Token(_token).balanceOf(address(this)));\n\t\t}\n\t    return true;\n\t}\n\n\tfunction normalizeToken(address _token, uint256 _amount) internal view returns (uint256) {\n\t\tuint256 n = 18;\n\t\treturn _amount.mul((10 ** (n.sub(decimals[_token]))));\n\t}\n\n\tfunction denormalizedToken(address _token, uint256 _amount) internal view returns (uint256) {\n\t\tuint256 n = 18;\n\t\treturn _amount.div((10 ** (n.sub(decimals[_token]))));\n\t}\n}",
        "function": "enableLending(address)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/PeckShield-XSwap/xswap-326a3246b327cd2b8481fd8c22fe8d864e43b0da/contracts/XSwap.sol",
        "vulnerability": "Multiple Calls in a Single Transaction (SWC 113)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract XSwap is DSAuth {\n\tusing DSMath for uint256;\n\n\tuint256 constant internal OFFSET = 10 ** 18;\n\t//Mainnet\n\t// address private chai = 0x06AF07097C9Eeb7fD685c692751D5C66dB49c215;\n\t// address private dai  = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n\n\t//Rinkeby\n\taddress private chai = 0x8a5C1BD4D75e168a4f65eB902c289400B90FD980;\n\taddress private dai  = 0xA3A59273494BB5B8F0a8FAcf21B3f666A47d6140;\n\n\tbool private actived;\n\taddress public lendFMe;\n\tbool public isOpen;\n\tmapping(address => mapping(address => uint256)) public prices; // 1 tokenA = ? tokenB\n\tmapping(address => mapping(address => uint256)) public fee;   // fee from tokenA to tokenB\n\tmapping(address => bool) public supportLending;\n\tmapping(address => uint256) public decimals;\n\n\tconstructor() public {\n\t}\n\n\tfunction active(address _lendFMe) public {\n\t\trequire(actived == false, \"already actived.\");\n\t\towner = msg.sender;\n\t\tisOpen = true;\n\t\tlendFMe = _lendFMe;\n\t\tactived = true;\n\t}\n\n\t// trade _inputAmount of _input token to get _output token\n\tfunction trade(address _input, address _output, uint256 _inputAmount) public returns (bool) {\n\t\treturn trade(_input, _output, _inputAmount, msg.sender);\n\t}\n\n\tfunction trade(address _input, address _output, uint256 _inputAmount, address _receiver) public returns (bool) {\n\t\trequire(isOpen, \"not open\");\n\t\trequire(prices[_input][_output] != 0, \"invalid token address\");\n\t\trequire(decimals[_input] != 0, \"input decimal not setteled\");\n\t\trequire(decimals[_output] != 0, \"output decimal not setteled\");\n\n\t\tNonStandardIERC20Token(_input).transferFrom(msg.sender, address(this), _inputAmount);\n\t\tif(supportLending[_input]) {\n\t\t\tif (_input == dai) {\n\t\t\t\tIChai(chai).join(address(this), _inputAmount);\n\t\t\t\tILendFMe(lendFMe).supply(chai, IERC20Token(chai).balanceOf(address(this)));\n\t\t\t}\n\t\t\telse\n\t\t\t\tILendFMe(lendFMe).supply(_input, _inputAmount);\n\t\t}\n\t\tuint256 _tokenAmount = normalizeToken(_input, _inputAmount).mul(prices[_input][_output]).div(OFFSET);\n\t\tuint256 _fee = _tokenAmount.mul(fee[_input][_output]).div(OFFSET);\n\t\tuint256 _amountToUser = _tokenAmount.sub(_fee);\n\n\t\tif(supportLending[_output]) {\n\t\t\tif (_output == dai) {\n\t\t\t\tILendFMe(lendFMe).withdraw(chai, _amountToUser); //assume chai / dai >= 1;\n\t\t\t\tIChai(chai).draw(address(this), _amountToUser);\n\t\t\t}\n\t\t\telse\n\t\t\t\tILendFMe(lendFMe).withdraw(_output, denormalizedToken(_output, _amountToUser));\n\t\t}\n\t\tNonStandardIERC20Token(_output).transfer(_receiver, denormalizedToken(_output, _amountToUser));\n\t\treturn true;\n\t}\n\n\tfunction getTokenLiquidation(address _token) public view returns (uint256) {\n\t\tuint256 balanceInDefi = ILendFMe(lendFMe).getSupplyBalance(address(this), _token);\n\t\treturn balanceInDefi.add(NonStandardIERC20Token(_token).balanceOf(address(this)));\n\t}\n\n\tfunction setLendFMe(address _lendFMe) public auth returns (bool) {\n\t\tlendFMe = _lendFMe;\n\t\treturn true;\n\t}\n\n\tfunction enableLending(address _token) public auth returns (bool) {\n\t\trequire(!supportLending[_token], \"the token is already supported lending\");\n\t\tsupportLending[_token] = true;\n\n\t\tif (_token == dai) {\n\t\t\tIERC20Token(_token).approve(chai, uint256(-1));\n\t\t\tIERC20Token(chai).approve(lendFMe, uint256(-1));\n\t\t}\n\t\telse {\n\t\t\tNonStandardIERC20Token(_token).approve(lendFMe, uint256(-1));\n\t\t}\n\n\t\tuint256 _balance = NonStandardIERC20Token(_token).balanceOf(address(this));\n\t\tif(_balance > 0) {\n\t\t\tif (_token == dai) {\n\t\t\t\tIChai(chai).join(address(this), _balance);\n\t\t\t\tILendFMe(lendFMe).supply(chai, IERC20Token(chai).balanceOf(address(this)));\n\t\t\t}\n\t\t\telse\n\t\t\t\tILendFMe(lendFMe).supply(_token, _balance);\n\t\t}\n\t\treturn true;\n\t}\n\n\tfunction disableLending(address _token) public auth returns (bool) {\n\t\trequire(supportLending[_token], \"the token doesnt support lending\");\n\t\tsupportLending[_token] = false;\n\n\t\tif (_token == dai) {\n\t\t\tILendFMe(lendFMe).withdraw(chai, uint256(-1));\n\t\t\tIChai(chai).exit(address(this), IERC20Token(chai).balanceOf(address(this)));\n\t\t}\n\t\telse\n\t\t\tILendFMe(lendFMe).withdraw(_token, uint256(-1));\n\n\t\treturn true;\n\t}\n\n\t// create new pairs\n\tfunction createPair(address _input, address _output, uint256 _priceInOut, uint256 _priceOutIn, uint256 _fee) external auth returns (bool) {\n\t\tsetPrices(_input, _output, _priceInOut, _priceOutIn);\n\t\tsetFee(_input, _output, _fee);\n\t\treturn true;\n\t}\n\n\tfunction setPrices(address _input, address _output, uint256 _priceInOut, uint256 _priceOutIn) public auth returns (bool) {\n\t\tsetPrices(_input, _output, _priceInOut);\n\t\tsetPrices(_output, _input, _priceOutIn);\n\t\treturn true;\n\t}\n\t//SWC-101-Integer Overflow and Underflow: L152\n\tfunction setPrices(address _input, address _output, uint256 _price) public auth returns (bool) {\n\t\tprices[_input][_output] = _price;\n\t\treturn true;\n\t}\n\n\tfunction setFee(address _input, address _output, uint256 _fee) public auth returns (bool) {\n\t\tfee[_input][_output] = _fee;\n\t\tfee[_output][_input] = _fee;\n\t\treturn true;\n\t}\n\n\tfunction setTokenDecimals(address _token, uint256 _decimals) public auth returns (bool){\n\t\trequire(_decimals <= 18, \"not supported decimal\");\n\t\tdecimals[_token] = _decimals;\n\t\treturn true;\n\t}\n\n\tfunction emergencyStop(bool _open) external auth returns (bool) {\n\t\tisOpen = _open;\n\t\treturn true;\n\t}\n\n\tfunction transferOut(address _token, address _receiver, uint256 _amount) external auth returns (bool) {\n\t\tif(supportLending[_token]) {\n\t\t\tif (_token == dai) {\n\t\t\t\tILendFMe(lendFMe).withdraw(chai, _amount);\n\t\t\t\tIChai(chai).draw(address(this), _amount);\n\t\t\t}\n\t\t\telse\n\t\t\t\tILendFMe(lendFMe).withdraw(_token, _amount);\n\t\t}\n\t\tuint256 _balance = NonStandardIERC20Token(_token).balanceOf(address(this));\n\t\tif(_balance >= _amount) {\n\t\t\tNonStandardIERC20Token(_token).transfer(_receiver, _amount);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tfunction transferOutALL(address _token, address _receiver) external auth returns (bool) {\n\t\tif(supportLending[_token]) {\n\t\t\tif (_token == dai) {\n\t\t\t\tILendFMe(lendFMe).withdraw(chai, uint256(-1));\n\t\t\t\tIChai(chai).exit(address(this), IERC20Token(chai).balanceOf(address(this)));\n\t\t\t}\n\t\t\telse\n\t\t\t\tILendFMe(lendFMe).withdraw(_token, uint256(-1));\n\t\t}\n\t\tuint256 _balance = NonStandardIERC20Token(_token).balanceOf(address(this));\n\t\tif(_balance > 0) {\n\t\t\tNonStandardIERC20Token(_token).transfer(_receiver, _balance);\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tfunction transferIn(address _token, uint256 _amount) external auth returns (bool) {\n\t\tNonStandardIERC20Token(_token).transferFrom(msg.sender, address(this), _amount);\n\t\tif(supportLending[_token]) {\n\t\t\tif (_token == dai) {\n\t\t\t\tIChai(chai).join(address(this), NonStandardIERC20Token(dai).balanceOf(address(this)));\n\t\t\t\tILendFMe(lendFMe).supply(chai, IERC20Token(chai).balanceOf(address(this)));\n\t\t\t}\n\t\t\telse\n\t\t\t\tILendFMe(lendFMe).supply(_token, NonStandardIERC20Token(_token).balanceOf(address(this)));\n\t\t}\n\t    return true;\n\t}\n\n\tfunction normalizeToken(address _token, uint256 _amount) internal view returns (uint256) {\n\t\tuint256 n = 18;\n\t\treturn _amount.mul((10 ** (n.sub(decimals[_token]))));\n\t}\n\n\tfunction denormalizedToken(address _token, uint256 _amount) internal view returns (uint256) {\n\t\tuint256 n = 18;\n\t\treturn _amount.div((10 ** (n.sub(decimals[_token]))));\n\t}\n}",
        "function": "enableLending(address)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/PeckShield-XSwap/xswap-326a3246b327cd2b8481fd8c22fe8d864e43b0da/contracts/XSwap.sol",
        "vulnerability": "State access after external call (SWC 107)",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract XSwap is DSAuth {\n\tusing DSMath for uint256;\n\n\tuint256 constant internal OFFSET = 10 ** 18;\n\t//Mainnet\n\t// address private chai = 0x06AF07097C9Eeb7fD685c692751D5C66dB49c215;\n\t// address private dai  = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n\n\t//Rinkeby\n\taddress private chai = 0x8a5C1BD4D75e168a4f65eB902c289400B90FD980;\n\taddress private dai  = 0xA3A59273494BB5B8F0a8FAcf21B3f666A47d6140;\n\n\tbool private actived;\n\taddress public lendFMe;\n\tbool public isOpen;\n\tmapping(address => mapping(address => uint256)) public prices; // 1 tokenA = ? tokenB\n\tmapping(address => mapping(address => uint256)) public fee;   // fee from tokenA to tokenB\n\tmapping(address => bool) public supportLending;\n\tmapping(address => uint256) public decimals;\n\n\tconstructor() public {\n\t}\n\n\tfunction active(address _lendFMe) public {\n\t\trequire(actived == false, \"already actived.\");\n\t\towner = msg.sender;\n\t\tisOpen = true;\n\t\tlendFMe = _lendFMe;\n\t\tactived = true;\n\t}\n\n\t// trade _inputAmount of _input token to get _output token\n\tfunction trade(address _input, address _output, uint256 _inputAmount) public returns (bool) {\n\t\treturn trade(_input, _output, _inputAmount, msg.sender);\n\t}\n\n\tfunction trade(address _input, address _output, uint256 _inputAmount, address _receiver) public returns (bool) {\n\t\trequire(isOpen, \"not open\");\n\t\trequire(prices[_input][_output] != 0, \"invalid token address\");\n\t\trequire(decimals[_input] != 0, \"input decimal not setteled\");\n\t\trequire(decimals[_output] != 0, \"output decimal not setteled\");\n\n\t\tNonStandardIERC20Token(_input).transferFrom(msg.sender, address(this), _inputAmount);\n\t\tif(supportLending[_input]) {\n\t\t\tif (_input == dai) {\n\t\t\t\tIChai(chai).join(address(this), _inputAmount);\n\t\t\t\tILendFMe(lendFMe).supply(chai, IERC20Token(chai).balanceOf(address(this)));\n\t\t\t}\n\t\t\telse\n\t\t\t\tILendFMe(lendFMe).supply(_input, _inputAmount);\n\t\t}\n\t\tuint256 _tokenAmount = normalizeToken(_input, _inputAmount).mul(prices[_input][_output]).div(OFFSET);\n\t\tuint256 _fee = _tokenAmount.mul(fee[_input][_output]).div(OFFSET);\n\t\tuint256 _amountToUser = _tokenAmount.sub(_fee);\n\n\t\tif(supportLending[_output]) {\n\t\t\tif (_output == dai) {\n\t\t\t\tILendFMe(lendFMe).withdraw(chai, _amountToUser); //assume chai / dai >= 1;\n\t\t\t\tIChai(chai).draw(address(this), _amountToUser);\n\t\t\t}\n\t\t\telse\n\t\t\t\tILendFMe(lendFMe).withdraw(_output, denormalizedToken(_output, _amountToUser));\n\t\t}\n\t\tNonStandardIERC20Token(_output).transfer(_receiver, denormalizedToken(_output, _amountToUser));\n\t\treturn true;\n\t}\n\n\tfunction getTokenLiquidation(address _token) public view returns (uint256) {\n\t\tuint256 balanceInDefi = ILendFMe(lendFMe).getSupplyBalance(address(this), _token);\n\t\treturn balanceInDefi.add(NonStandardIERC20Token(_token).balanceOf(address(this)));\n\t}\n\n\tfunction setLendFMe(address _lendFMe) public auth returns (bool) {\n\t\tlendFMe = _lendFMe;\n\t\treturn true;\n\t}\n\n\tfunction enableLending(address _token) public auth returns (bool) {\n\t\trequire(!supportLending[_token], \"the token is already supported lending\");\n\t\tsupportLending[_token] = true;\n\n\t\tif (_token == dai) {\n\t\t\tIERC20Token(_token).approve(chai, uint256(-1));\n\t\t\tIERC20Token(chai).approve(lendFMe, uint256(-1));\n\t\t}\n\t\telse {\n\t\t\tNonStandardIERC20Token(_token).approve(lendFMe, uint256(-1));\n\t\t}\n\n\t\tuint256 _balance = NonStandardIERC20Token(_token).balanceOf(address(this));\n\t\tif(_balance > 0) {\n\t\t\tif (_token == dai) {\n\t\t\t\tIChai(chai).join(address(this), _balance);\n\t\t\t\tILendFMe(lendFMe).supply(chai, IERC20Token(chai).balanceOf(address(this)));\n\t\t\t}\n\t\t\telse\n\t\t\t\tILendFMe(lendFMe).supply(_token, _balance);\n\t\t}\n\t\treturn true;\n\t}\n\n\tfunction disableLending(address _token) public auth returns (bool) {\n\t\trequire(supportLending[_token], \"the token doesnt support lending\");\n\t\tsupportLending[_token] = false;\n\n\t\tif (_token == dai) {\n\t\t\tILendFMe(lendFMe).withdraw(chai, uint256(-1));\n\t\t\tIChai(chai).exit(address(this), IERC20Token(chai).balanceOf(address(this)));\n\t\t}\n\t\telse\n\t\t\tILendFMe(lendFMe).withdraw(_token, uint256(-1));\n\n\t\treturn true;\n\t}\n\n\t// create new pairs\n\tfunction createPair(address _input, address _output, uint256 _priceInOut, uint256 _priceOutIn, uint256 _fee) external auth returns (bool) {\n\t\tsetPrices(_input, _output, _priceInOut, _priceOutIn);\n\t\tsetFee(_input, _output, _fee);\n\t\treturn true;\n\t}\n\n\tfunction setPrices(address _input, address _output, uint256 _priceInOut, uint256 _priceOutIn) public auth returns (bool) {\n\t\tsetPrices(_input, _output, _priceInOut);\n\t\tsetPrices(_output, _input, _priceOutIn);\n\t\treturn true;\n\t}\n\t//SWC-101-Integer Overflow and Underflow: L152\n\tfunction setPrices(address _input, address _output, uint256 _price) public auth returns (bool) {\n\t\tprices[_input][_output] = _price;\n\t\treturn true;\n\t}\n\n\tfunction setFee(address _input, address _output, uint256 _fee) public auth returns (bool) {\n\t\tfee[_input][_output] = _fee;\n\t\tfee[_output][_input] = _fee;\n\t\treturn true;\n\t}\n\n\tfunction setTokenDecimals(address _token, uint256 _decimals) public auth returns (bool){\n\t\trequire(_decimals <= 18, \"not supported decimal\");\n\t\tdecimals[_token] = _decimals;\n\t\treturn true;\n\t}\n\n\tfunction emergencyStop(bool _open) external auth returns (bool) {\n\t\tisOpen = _open;\n\t\treturn true;\n\t}\n\n\tfunction transferOut(address _token, address _receiver, uint256 _amount) external auth returns (bool) {\n\t\tif(supportLending[_token]) {\n\t\t\tif (_token == dai) {\n\t\t\t\tILendFMe(lendFMe).withdraw(chai, _amount);\n\t\t\t\tIChai(chai).draw(address(this), _amount);\n\t\t\t}\n\t\t\telse\n\t\t\t\tILendFMe(lendFMe).withdraw(_token, _amount);\n\t\t}\n\t\tuint256 _balance = NonStandardIERC20Token(_token).balanceOf(address(this));\n\t\tif(_balance >= _amount) {\n\t\t\tNonStandardIERC20Token(_token).transfer(_receiver, _amount);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tfunction transferOutALL(address _token, address _receiver) external auth returns (bool) {\n\t\tif(supportLending[_token]) {\n\t\t\tif (_token == dai) {\n\t\t\t\tILendFMe(lendFMe).withdraw(chai, uint256(-1));\n\t\t\t\tIChai(chai).exit(address(this), IERC20Token(chai).balanceOf(address(this)));\n\t\t\t}\n\t\t\telse\n\t\t\t\tILendFMe(lendFMe).withdraw(_token, uint256(-1));\n\t\t}\n\t\tuint256 _balance = NonStandardIERC20Token(_token).balanceOf(address(this));\n\t\tif(_balance > 0) {\n\t\t\tNonStandardIERC20Token(_token).transfer(_receiver, _balance);\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tfunction transferIn(address _token, uint256 _amount) external auth returns (bool) {\n\t\tNonStandardIERC20Token(_token).transferFrom(msg.sender, address(this), _amount);\n\t\tif(supportLending[_token]) {\n\t\t\tif (_token == dai) {\n\t\t\t\tIChai(chai).join(address(this), NonStandardIERC20Token(dai).balanceOf(address(this)));\n\t\t\t\tILendFMe(lendFMe).supply(chai, IERC20Token(chai).balanceOf(address(this)));\n\t\t\t}\n\t\t\telse\n\t\t\t\tILendFMe(lendFMe).supply(_token, NonStandardIERC20Token(_token).balanceOf(address(this)));\n\t\t}\n\t    return true;\n\t}\n\n\tfunction normalizeToken(address _token, uint256 _amount) internal view returns (uint256) {\n\t\tuint256 n = 18;\n\t\treturn _amount.mul((10 ** (n.sub(decimals[_token]))));\n\t}\n\n\tfunction denormalizedToken(address _token, uint256 _amount) internal view returns (uint256) {\n\t\tuint256 n = 18;\n\t\treturn _amount.div((10 ** (n.sub(decimals[_token]))));\n\t}\n}",
        "function": "enableLending(address)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/PeckShield-XSwap/xswap-326a3246b327cd2b8481fd8c22fe8d864e43b0da/contracts/XSwap.sol",
        "vulnerability": "External Call To User-Supplied Address (SWC 107)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract XSwap is DSAuth {\n\tusing DSMath for uint256;\n\n\tuint256 constant internal OFFSET = 10 ** 18;\n\t//Mainnet\n\t// address private chai = 0x06AF07097C9Eeb7fD685c692751D5C66dB49c215;\n\t// address private dai  = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n\n\t//Rinkeby\n\taddress private chai = 0x8a5C1BD4D75e168a4f65eB902c289400B90FD980;\n\taddress private dai  = 0xA3A59273494BB5B8F0a8FAcf21B3f666A47d6140;\n\n\tbool private actived;\n\taddress public lendFMe;\n\tbool public isOpen;\n\tmapping(address => mapping(address => uint256)) public prices; // 1 tokenA = ? tokenB\n\tmapping(address => mapping(address => uint256)) public fee;   // fee from tokenA to tokenB\n\tmapping(address => bool) public supportLending;\n\tmapping(address => uint256) public decimals;\n\n\tconstructor() public {\n\t}\n\n\tfunction active(address _lendFMe) public {\n\t\trequire(actived == false, \"already actived.\");\n\t\towner = msg.sender;\n\t\tisOpen = true;\n\t\tlendFMe = _lendFMe;\n\t\tactived = true;\n\t}\n\n\t// trade _inputAmount of _input token to get _output token\n\tfunction trade(address _input, address _output, uint256 _inputAmount) public returns (bool) {\n\t\treturn trade(_input, _output, _inputAmount, msg.sender);\n\t}\n\n\tfunction trade(address _input, address _output, uint256 _inputAmount, address _receiver) public returns (bool) {\n\t\trequire(isOpen, \"not open\");\n\t\trequire(prices[_input][_output] != 0, \"invalid token address\");\n\t\trequire(decimals[_input] != 0, \"input decimal not setteled\");\n\t\trequire(decimals[_output] != 0, \"output decimal not setteled\");\n\n\t\tNonStandardIERC20Token(_input).transferFrom(msg.sender, address(this), _inputAmount);\n\t\tif(supportLending[_input]) {\n\t\t\tif (_input == dai) {\n\t\t\t\tIChai(chai).join(address(this), _inputAmount);\n\t\t\t\tILendFMe(lendFMe).supply(chai, IERC20Token(chai).balanceOf(address(this)));\n\t\t\t}\n\t\t\telse\n\t\t\t\tILendFMe(lendFMe).supply(_input, _inputAmount);\n\t\t}\n\t\tuint256 _tokenAmount = normalizeToken(_input, _inputAmount).mul(prices[_input][_output]).div(OFFSET);\n\t\tuint256 _fee = _tokenAmount.mul(fee[_input][_output]).div(OFFSET);\n\t\tuint256 _amountToUser = _tokenAmount.sub(_fee);\n\n\t\tif(supportLending[_output]) {\n\t\t\tif (_output == dai) {\n\t\t\t\tILendFMe(lendFMe).withdraw(chai, _amountToUser); //assume chai / dai >= 1;\n\t\t\t\tIChai(chai).draw(address(this), _amountToUser);\n\t\t\t}\n\t\t\telse\n\t\t\t\tILendFMe(lendFMe).withdraw(_output, denormalizedToken(_output, _amountToUser));\n\t\t}\n\t\tNonStandardIERC20Token(_output).transfer(_receiver, denormalizedToken(_output, _amountToUser));\n\t\treturn true;\n\t}\n\n\tfunction getTokenLiquidation(address _token) public view returns (uint256) {\n\t\tuint256 balanceInDefi = ILendFMe(lendFMe).getSupplyBalance(address(this), _token);\n\t\treturn balanceInDefi.add(NonStandardIERC20Token(_token).balanceOf(address(this)));\n\t}\n\n\tfunction setLendFMe(address _lendFMe) public auth returns (bool) {\n\t\tlendFMe = _lendFMe;\n\t\treturn true;\n\t}\n\n\tfunction enableLending(address _token) public auth returns (bool) {\n\t\trequire(!supportLending[_token], \"the token is already supported lending\");\n\t\tsupportLending[_token] = true;\n\n\t\tif (_token == dai) {\n\t\t\tIERC20Token(_token).approve(chai, uint256(-1));\n\t\t\tIERC20Token(chai).approve(lendFMe, uint256(-1));\n\t\t}\n\t\telse {\n\t\t\tNonStandardIERC20Token(_token).approve(lendFMe, uint256(-1));\n\t\t}\n\n\t\tuint256 _balance = NonStandardIERC20Token(_token).balanceOf(address(this));\n\t\tif(_balance > 0) {\n\t\t\tif (_token == dai) {\n\t\t\t\tIChai(chai).join(address(this), _balance);\n\t\t\t\tILendFMe(lendFMe).supply(chai, IERC20Token(chai).balanceOf(address(this)));\n\t\t\t}\n\t\t\telse\n\t\t\t\tILendFMe(lendFMe).supply(_token, _balance);\n\t\t}\n\t\treturn true;\n\t}\n\n\tfunction disableLending(address _token) public auth returns (bool) {\n\t\trequire(supportLending[_token], \"the token doesnt support lending\");\n\t\tsupportLending[_token] = false;\n\n\t\tif (_token == dai) {\n\t\t\tILendFMe(lendFMe).withdraw(chai, uint256(-1));\n\t\t\tIChai(chai).exit(address(this), IERC20Token(chai).balanceOf(address(this)));\n\t\t}\n\t\telse\n\t\t\tILendFMe(lendFMe).withdraw(_token, uint256(-1));\n\n\t\treturn true;\n\t}\n\n\t// create new pairs\n\tfunction createPair(address _input, address _output, uint256 _priceInOut, uint256 _priceOutIn, uint256 _fee) external auth returns (bool) {\n\t\tsetPrices(_input, _output, _priceInOut, _priceOutIn);\n\t\tsetFee(_input, _output, _fee);\n\t\treturn true;\n\t}\n\n\tfunction setPrices(address _input, address _output, uint256 _priceInOut, uint256 _priceOutIn) public auth returns (bool) {\n\t\tsetPrices(_input, _output, _priceInOut);\n\t\tsetPrices(_output, _input, _priceOutIn);\n\t\treturn true;\n\t}\n\t//SWC-101-Integer Overflow and Underflow: L152\n\tfunction setPrices(address _input, address _output, uint256 _price) public auth returns (bool) {\n\t\tprices[_input][_output] = _price;\n\t\treturn true;\n\t}\n\n\tfunction setFee(address _input, address _output, uint256 _fee) public auth returns (bool) {\n\t\tfee[_input][_output] = _fee;\n\t\tfee[_output][_input] = _fee;\n\t\treturn true;\n\t}\n\n\tfunction setTokenDecimals(address _token, uint256 _decimals) public auth returns (bool){\n\t\trequire(_decimals <= 18, \"not supported decimal\");\n\t\tdecimals[_token] = _decimals;\n\t\treturn true;\n\t}\n\n\tfunction emergencyStop(bool _open) external auth returns (bool) {\n\t\tisOpen = _open;\n\t\treturn true;\n\t}\n\n\tfunction transferOut(address _token, address _receiver, uint256 _amount) external auth returns (bool) {\n\t\tif(supportLending[_token]) {\n\t\t\tif (_token == dai) {\n\t\t\t\tILendFMe(lendFMe).withdraw(chai, _amount);\n\t\t\t\tIChai(chai).draw(address(this), _amount);\n\t\t\t}\n\t\t\telse\n\t\t\t\tILendFMe(lendFMe).withdraw(_token, _amount);\n\t\t}\n\t\tuint256 _balance = NonStandardIERC20Token(_token).balanceOf(address(this));\n\t\tif(_balance >= _amount) {\n\t\t\tNonStandardIERC20Token(_token).transfer(_receiver, _amount);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tfunction transferOutALL(address _token, address _receiver) external auth returns (bool) {\n\t\tif(supportLending[_token]) {\n\t\t\tif (_token == dai) {\n\t\t\t\tILendFMe(lendFMe).withdraw(chai, uint256(-1));\n\t\t\t\tIChai(chai).exit(address(this), IERC20Token(chai).balanceOf(address(this)));\n\t\t\t}\n\t\t\telse\n\t\t\t\tILendFMe(lendFMe).withdraw(_token, uint256(-1));\n\t\t}\n\t\tuint256 _balance = NonStandardIERC20Token(_token).balanceOf(address(this));\n\t\tif(_balance > 0) {\n\t\t\tNonStandardIERC20Token(_token).transfer(_receiver, _balance);\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tfunction transferIn(address _token, uint256 _amount) external auth returns (bool) {\n\t\tNonStandardIERC20Token(_token).transferFrom(msg.sender, address(this), _amount);\n\t\tif(supportLending[_token]) {\n\t\t\tif (_token == dai) {\n\t\t\t\tIChai(chai).join(address(this), NonStandardIERC20Token(dai).balanceOf(address(this)));\n\t\t\t\tILendFMe(lendFMe).supply(chai, IERC20Token(chai).balanceOf(address(this)));\n\t\t\t}\n\t\t\telse\n\t\t\t\tILendFMe(lendFMe).supply(_token, NonStandardIERC20Token(_token).balanceOf(address(this)));\n\t\t}\n\t    return true;\n\t}\n\n\tfunction normalizeToken(address _token, uint256 _amount) internal view returns (uint256) {\n\t\tuint256 n = 18;\n\t\treturn _amount.mul((10 ** (n.sub(decimals[_token]))));\n\t}\n\n\tfunction denormalizedToken(address _token, uint256 _amount) internal view returns (uint256) {\n\t\tuint256 n = 18;\n\t\treturn _amount.div((10 ** (n.sub(decimals[_token]))));\n\t}\n}",
        "function": "enableLending(address)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/PeckShield-XSwap/xswap-326a3246b327cd2b8481fd8c22fe8d864e43b0da/contracts/XSwap.sol",
        "vulnerability": "Multiple Calls in a Single Transaction (SWC 113)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract XSwap is DSAuth {\n\tusing DSMath for uint256;\n\n\tuint256 constant internal OFFSET = 10 ** 18;\n\t//Mainnet\n\t// address private chai = 0x06AF07097C9Eeb7fD685c692751D5C66dB49c215;\n\t// address private dai  = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n\n\t//Rinkeby\n\taddress private chai = 0x8a5C1BD4D75e168a4f65eB902c289400B90FD980;\n\taddress private dai  = 0xA3A59273494BB5B8F0a8FAcf21B3f666A47d6140;\n\n\tbool private actived;\n\taddress public lendFMe;\n\tbool public isOpen;\n\tmapping(address => mapping(address => uint256)) public prices; // 1 tokenA = ? tokenB\n\tmapping(address => mapping(address => uint256)) public fee;   // fee from tokenA to tokenB\n\tmapping(address => bool) public supportLending;\n\tmapping(address => uint256) public decimals;\n\n\tconstructor() public {\n\t}\n\n\tfunction active(address _lendFMe) public {\n\t\trequire(actived == false, \"already actived.\");\n\t\towner = msg.sender;\n\t\tisOpen = true;\n\t\tlendFMe = _lendFMe;\n\t\tactived = true;\n\t}\n\n\t// trade _inputAmount of _input token to get _output token\n\tfunction trade(address _input, address _output, uint256 _inputAmount) public returns (bool) {\n\t\treturn trade(_input, _output, _inputAmount, msg.sender);\n\t}\n\n\tfunction trade(address _input, address _output, uint256 _inputAmount, address _receiver) public returns (bool) {\n\t\trequire(isOpen, \"not open\");\n\t\trequire(prices[_input][_output] != 0, \"invalid token address\");\n\t\trequire(decimals[_input] != 0, \"input decimal not setteled\");\n\t\trequire(decimals[_output] != 0, \"output decimal not setteled\");\n\n\t\tNonStandardIERC20Token(_input).transferFrom(msg.sender, address(this), _inputAmount);\n\t\tif(supportLending[_input]) {\n\t\t\tif (_input == dai) {\n\t\t\t\tIChai(chai).join(address(this), _inputAmount);\n\t\t\t\tILendFMe(lendFMe).supply(chai, IERC20Token(chai).balanceOf(address(this)));\n\t\t\t}\n\t\t\telse\n\t\t\t\tILendFMe(lendFMe).supply(_input, _inputAmount);\n\t\t}\n\t\tuint256 _tokenAmount = normalizeToken(_input, _inputAmount).mul(prices[_input][_output]).div(OFFSET);\n\t\tuint256 _fee = _tokenAmount.mul(fee[_input][_output]).div(OFFSET);\n\t\tuint256 _amountToUser = _tokenAmount.sub(_fee);\n\n\t\tif(supportLending[_output]) {\n\t\t\tif (_output == dai) {\n\t\t\t\tILendFMe(lendFMe).withdraw(chai, _amountToUser); //assume chai / dai >= 1;\n\t\t\t\tIChai(chai).draw(address(this), _amountToUser);\n\t\t\t}\n\t\t\telse\n\t\t\t\tILendFMe(lendFMe).withdraw(_output, denormalizedToken(_output, _amountToUser));\n\t\t}\n\t\tNonStandardIERC20Token(_output).transfer(_receiver, denormalizedToken(_output, _amountToUser));\n\t\treturn true;\n\t}\n\n\tfunction getTokenLiquidation(address _token) public view returns (uint256) {\n\t\tuint256 balanceInDefi = ILendFMe(lendFMe).getSupplyBalance(address(this), _token);\n\t\treturn balanceInDefi.add(NonStandardIERC20Token(_token).balanceOf(address(this)));\n\t}\n\n\tfunction setLendFMe(address _lendFMe) public auth returns (bool) {\n\t\tlendFMe = _lendFMe;\n\t\treturn true;\n\t}\n\n\tfunction enableLending(address _token) public auth returns (bool) {\n\t\trequire(!supportLending[_token], \"the token is already supported lending\");\n\t\tsupportLending[_token] = true;\n\n\t\tif (_token == dai) {\n\t\t\tIERC20Token(_token).approve(chai, uint256(-1));\n\t\t\tIERC20Token(chai).approve(lendFMe, uint256(-1));\n\t\t}\n\t\telse {\n\t\t\tNonStandardIERC20Token(_token).approve(lendFMe, uint256(-1));\n\t\t}\n\n\t\tuint256 _balance = NonStandardIERC20Token(_token).balanceOf(address(this));\n\t\tif(_balance > 0) {\n\t\t\tif (_token == dai) {\n\t\t\t\tIChai(chai).join(address(this), _balance);\n\t\t\t\tILendFMe(lendFMe).supply(chai, IERC20Token(chai).balanceOf(address(this)));\n\t\t\t}\n\t\t\telse\n\t\t\t\tILendFMe(lendFMe).supply(_token, _balance);\n\t\t}\n\t\treturn true;\n\t}\n\n\tfunction disableLending(address _token) public auth returns (bool) {\n\t\trequire(supportLending[_token], \"the token doesnt support lending\");\n\t\tsupportLending[_token] = false;\n\n\t\tif (_token == dai) {\n\t\t\tILendFMe(lendFMe).withdraw(chai, uint256(-1));\n\t\t\tIChai(chai).exit(address(this), IERC20Token(chai).balanceOf(address(this)));\n\t\t}\n\t\telse\n\t\t\tILendFMe(lendFMe).withdraw(_token, uint256(-1));\n\n\t\treturn true;\n\t}\n\n\t// create new pairs\n\tfunction createPair(address _input, address _output, uint256 _priceInOut, uint256 _priceOutIn, uint256 _fee) external auth returns (bool) {\n\t\tsetPrices(_input, _output, _priceInOut, _priceOutIn);\n\t\tsetFee(_input, _output, _fee);\n\t\treturn true;\n\t}\n\n\tfunction setPrices(address _input, address _output, uint256 _priceInOut, uint256 _priceOutIn) public auth returns (bool) {\n\t\tsetPrices(_input, _output, _priceInOut);\n\t\tsetPrices(_output, _input, _priceOutIn);\n\t\treturn true;\n\t}\n\t//SWC-101-Integer Overflow and Underflow: L152\n\tfunction setPrices(address _input, address _output, uint256 _price) public auth returns (bool) {\n\t\tprices[_input][_output] = _price;\n\t\treturn true;\n\t}\n\n\tfunction setFee(address _input, address _output, uint256 _fee) public auth returns (bool) {\n\t\tfee[_input][_output] = _fee;\n\t\tfee[_output][_input] = _fee;\n\t\treturn true;\n\t}\n\n\tfunction setTokenDecimals(address _token, uint256 _decimals) public auth returns (bool){\n\t\trequire(_decimals <= 18, \"not supported decimal\");\n\t\tdecimals[_token] = _decimals;\n\t\treturn true;\n\t}\n\n\tfunction emergencyStop(bool _open) external auth returns (bool) {\n\t\tisOpen = _open;\n\t\treturn true;\n\t}\n\n\tfunction transferOut(address _token, address _receiver, uint256 _amount) external auth returns (bool) {\n\t\tif(supportLending[_token]) {\n\t\t\tif (_token == dai) {\n\t\t\t\tILendFMe(lendFMe).withdraw(chai, _amount);\n\t\t\t\tIChai(chai).draw(address(this), _amount);\n\t\t\t}\n\t\t\telse\n\t\t\t\tILendFMe(lendFMe).withdraw(_token, _amount);\n\t\t}\n\t\tuint256 _balance = NonStandardIERC20Token(_token).balanceOf(address(this));\n\t\tif(_balance >= _amount) {\n\t\t\tNonStandardIERC20Token(_token).transfer(_receiver, _amount);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tfunction transferOutALL(address _token, address _receiver) external auth returns (bool) {\n\t\tif(supportLending[_token]) {\n\t\t\tif (_token == dai) {\n\t\t\t\tILendFMe(lendFMe).withdraw(chai, uint256(-1));\n\t\t\t\tIChai(chai).exit(address(this), IERC20Token(chai).balanceOf(address(this)));\n\t\t\t}\n\t\t\telse\n\t\t\t\tILendFMe(lendFMe).withdraw(_token, uint256(-1));\n\t\t}\n\t\tuint256 _balance = NonStandardIERC20Token(_token).balanceOf(address(this));\n\t\tif(_balance > 0) {\n\t\t\tNonStandardIERC20Token(_token).transfer(_receiver, _balance);\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tfunction transferIn(address _token, uint256 _amount) external auth returns (bool) {\n\t\tNonStandardIERC20Token(_token).transferFrom(msg.sender, address(this), _amount);\n\t\tif(supportLending[_token]) {\n\t\t\tif (_token == dai) {\n\t\t\t\tIChai(chai).join(address(this), NonStandardIERC20Token(dai).balanceOf(address(this)));\n\t\t\t\tILendFMe(lendFMe).supply(chai, IERC20Token(chai).balanceOf(address(this)));\n\t\t\t}\n\t\t\telse\n\t\t\t\tILendFMe(lendFMe).supply(_token, NonStandardIERC20Token(_token).balanceOf(address(this)));\n\t\t}\n\t    return true;\n\t}\n\n\tfunction normalizeToken(address _token, uint256 _amount) internal view returns (uint256) {\n\t\tuint256 n = 18;\n\t\treturn _amount.mul((10 ** (n.sub(decimals[_token]))));\n\t}\n\n\tfunction denormalizedToken(address _token, uint256 _amount) internal view returns (uint256) {\n\t\tuint256 n = 18;\n\t\treturn _amount.div((10 ** (n.sub(decimals[_token]))));\n\t}\n}",
        "function": "enableLending(address)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/PeckShield-XSwap/xswap-326a3246b327cd2b8481fd8c22fe8d864e43b0da/contracts/XSwap.sol",
        "vulnerability": "State access after external call (SWC 107)",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract XSwap is DSAuth {\n\tusing DSMath for uint256;\n\n\tuint256 constant internal OFFSET = 10 ** 18;\n\t//Mainnet\n\t// address private chai = 0x06AF07097C9Eeb7fD685c692751D5C66dB49c215;\n\t// address private dai  = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n\n\t//Rinkeby\n\taddress private chai = 0x8a5C1BD4D75e168a4f65eB902c289400B90FD980;\n\taddress private dai  = 0xA3A59273494BB5B8F0a8FAcf21B3f666A47d6140;\n\n\tbool private actived;\n\taddress public lendFMe;\n\tbool public isOpen;\n\tmapping(address => mapping(address => uint256)) public prices; // 1 tokenA = ? tokenB\n\tmapping(address => mapping(address => uint256)) public fee;   // fee from tokenA to tokenB\n\tmapping(address => bool) public supportLending;\n\tmapping(address => uint256) public decimals;\n\n\tconstructor() public {\n\t}\n\n\tfunction active(address _lendFMe) public {\n\t\trequire(actived == false, \"already actived.\");\n\t\towner = msg.sender;\n\t\tisOpen = true;\n\t\tlendFMe = _lendFMe;\n\t\tactived = true;\n\t}\n\n\t// trade _inputAmount of _input token to get _output token\n\tfunction trade(address _input, address _output, uint256 _inputAmount) public returns (bool) {\n\t\treturn trade(_input, _output, _inputAmount, msg.sender);\n\t}\n\n\tfunction trade(address _input, address _output, uint256 _inputAmount, address _receiver) public returns (bool) {\n\t\trequire(isOpen, \"not open\");\n\t\trequire(prices[_input][_output] != 0, \"invalid token address\");\n\t\trequire(decimals[_input] != 0, \"input decimal not setteled\");\n\t\trequire(decimals[_output] != 0, \"output decimal not setteled\");\n\n\t\tNonStandardIERC20Token(_input).transferFrom(msg.sender, address(this), _inputAmount);\n\t\tif(supportLending[_input]) {\n\t\t\tif (_input == dai) {\n\t\t\t\tIChai(chai).join(address(this), _inputAmount);\n\t\t\t\tILendFMe(lendFMe).supply(chai, IERC20Token(chai).balanceOf(address(this)));\n\t\t\t}\n\t\t\telse\n\t\t\t\tILendFMe(lendFMe).supply(_input, _inputAmount);\n\t\t}\n\t\tuint256 _tokenAmount = normalizeToken(_input, _inputAmount).mul(prices[_input][_output]).div(OFFSET);\n\t\tuint256 _fee = _tokenAmount.mul(fee[_input][_output]).div(OFFSET);\n\t\tuint256 _amountToUser = _tokenAmount.sub(_fee);\n\n\t\tif(supportLending[_output]) {\n\t\t\tif (_output == dai) {\n\t\t\t\tILendFMe(lendFMe).withdraw(chai, _amountToUser); //assume chai / dai >= 1;\n\t\t\t\tIChai(chai).draw(address(this), _amountToUser);\n\t\t\t}\n\t\t\telse\n\t\t\t\tILendFMe(lendFMe).withdraw(_output, denormalizedToken(_output, _amountToUser));\n\t\t}\n\t\tNonStandardIERC20Token(_output).transfer(_receiver, denormalizedToken(_output, _amountToUser));\n\t\treturn true;\n\t}\n\n\tfunction getTokenLiquidation(address _token) public view returns (uint256) {\n\t\tuint256 balanceInDefi = ILendFMe(lendFMe).getSupplyBalance(address(this), _token);\n\t\treturn balanceInDefi.add(NonStandardIERC20Token(_token).balanceOf(address(this)));\n\t}\n\n\tfunction setLendFMe(address _lendFMe) public auth returns (bool) {\n\t\tlendFMe = _lendFMe;\n\t\treturn true;\n\t}\n\n\tfunction enableLending(address _token) public auth returns (bool) {\n\t\trequire(!supportLending[_token], \"the token is already supported lending\");\n\t\tsupportLending[_token] = true;\n\n\t\tif (_token == dai) {\n\t\t\tIERC20Token(_token).approve(chai, uint256(-1));\n\t\t\tIERC20Token(chai).approve(lendFMe, uint256(-1));\n\t\t}\n\t\telse {\n\t\t\tNonStandardIERC20Token(_token).approve(lendFMe, uint256(-1));\n\t\t}\n\n\t\tuint256 _balance = NonStandardIERC20Token(_token).balanceOf(address(this));\n\t\tif(_balance > 0) {\n\t\t\tif (_token == dai) {\n\t\t\t\tIChai(chai).join(address(this), _balance);\n\t\t\t\tILendFMe(lendFMe).supply(chai, IERC20Token(chai).balanceOf(address(this)));\n\t\t\t}\n\t\t\telse\n\t\t\t\tILendFMe(lendFMe).supply(_token, _balance);\n\t\t}\n\t\treturn true;\n\t}\n\n\tfunction disableLending(address _token) public auth returns (bool) {\n\t\trequire(supportLending[_token], \"the token doesnt support lending\");\n\t\tsupportLending[_token] = false;\n\n\t\tif (_token == dai) {\n\t\t\tILendFMe(lendFMe).withdraw(chai, uint256(-1));\n\t\t\tIChai(chai).exit(address(this), IERC20Token(chai).balanceOf(address(this)));\n\t\t}\n\t\telse\n\t\t\tILendFMe(lendFMe).withdraw(_token, uint256(-1));\n\n\t\treturn true;\n\t}\n\n\t// create new pairs\n\tfunction createPair(address _input, address _output, uint256 _priceInOut, uint256 _priceOutIn, uint256 _fee) external auth returns (bool) {\n\t\tsetPrices(_input, _output, _priceInOut, _priceOutIn);\n\t\tsetFee(_input, _output, _fee);\n\t\treturn true;\n\t}\n\n\tfunction setPrices(address _input, address _output, uint256 _priceInOut, uint256 _priceOutIn) public auth returns (bool) {\n\t\tsetPrices(_input, _output, _priceInOut);\n\t\tsetPrices(_output, _input, _priceOutIn);\n\t\treturn true;\n\t}\n\t//SWC-101-Integer Overflow and Underflow: L152\n\tfunction setPrices(address _input, address _output, uint256 _price) public auth returns (bool) {\n\t\tprices[_input][_output] = _price;\n\t\treturn true;\n\t}\n\n\tfunction setFee(address _input, address _output, uint256 _fee) public auth returns (bool) {\n\t\tfee[_input][_output] = _fee;\n\t\tfee[_output][_input] = _fee;\n\t\treturn true;\n\t}\n\n\tfunction setTokenDecimals(address _token, uint256 _decimals) public auth returns (bool){\n\t\trequire(_decimals <= 18, \"not supported decimal\");\n\t\tdecimals[_token] = _decimals;\n\t\treturn true;\n\t}\n\n\tfunction emergencyStop(bool _open) external auth returns (bool) {\n\t\tisOpen = _open;\n\t\treturn true;\n\t}\n\n\tfunction transferOut(address _token, address _receiver, uint256 _amount) external auth returns (bool) {\n\t\tif(supportLending[_token]) {\n\t\t\tif (_token == dai) {\n\t\t\t\tILendFMe(lendFMe).withdraw(chai, _amount);\n\t\t\t\tIChai(chai).draw(address(this), _amount);\n\t\t\t}\n\t\t\telse\n\t\t\t\tILendFMe(lendFMe).withdraw(_token, _amount);\n\t\t}\n\t\tuint256 _balance = NonStandardIERC20Token(_token).balanceOf(address(this));\n\t\tif(_balance >= _amount) {\n\t\t\tNonStandardIERC20Token(_token).transfer(_receiver, _amount);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tfunction transferOutALL(address _token, address _receiver) external auth returns (bool) {\n\t\tif(supportLending[_token]) {\n\t\t\tif (_token == dai) {\n\t\t\t\tILendFMe(lendFMe).withdraw(chai, uint256(-1));\n\t\t\t\tIChai(chai).exit(address(this), IERC20Token(chai).balanceOf(address(this)));\n\t\t\t}\n\t\t\telse\n\t\t\t\tILendFMe(lendFMe).withdraw(_token, uint256(-1));\n\t\t}\n\t\tuint256 _balance = NonStandardIERC20Token(_token).balanceOf(address(this));\n\t\tif(_balance > 0) {\n\t\t\tNonStandardIERC20Token(_token).transfer(_receiver, _balance);\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tfunction transferIn(address _token, uint256 _amount) external auth returns (bool) {\n\t\tNonStandardIERC20Token(_token).transferFrom(msg.sender, address(this), _amount);\n\t\tif(supportLending[_token]) {\n\t\t\tif (_token == dai) {\n\t\t\t\tIChai(chai).join(address(this), NonStandardIERC20Token(dai).balanceOf(address(this)));\n\t\t\t\tILendFMe(lendFMe).supply(chai, IERC20Token(chai).balanceOf(address(this)));\n\t\t\t}\n\t\t\telse\n\t\t\t\tILendFMe(lendFMe).supply(_token, NonStandardIERC20Token(_token).balanceOf(address(this)));\n\t\t}\n\t    return true;\n\t}\n\n\tfunction normalizeToken(address _token, uint256 _amount) internal view returns (uint256) {\n\t\tuint256 n = 18;\n\t\treturn _amount.mul((10 ** (n.sub(decimals[_token]))));\n\t}\n\n\tfunction denormalizedToken(address _token, uint256 _amount) internal view returns (uint256) {\n\t\tuint256 n = 18;\n\t\treturn _amount.div((10 ** (n.sub(decimals[_token]))));\n\t}\n}",
        "function": "enableLending(address)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/PeckShield-XSwap/xswap-326a3246b327cd2b8481fd8c22fe8d864e43b0da/contracts/XSwap.sol",
        "vulnerability": "State access after external call (SWC 107)",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract XSwap is DSAuth {\n\tusing DSMath for uint256;\n\n\tuint256 constant internal OFFSET = 10 ** 18;\n\t//Mainnet\n\t// address private chai = 0x06AF07097C9Eeb7fD685c692751D5C66dB49c215;\n\t// address private dai  = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n\n\t//Rinkeby\n\taddress private chai = 0x8a5C1BD4D75e168a4f65eB902c289400B90FD980;\n\taddress private dai  = 0xA3A59273494BB5B8F0a8FAcf21B3f666A47d6140;\n\n\tbool private actived;\n\taddress public lendFMe;\n\tbool public isOpen;\n\tmapping(address => mapping(address => uint256)) public prices; // 1 tokenA = ? tokenB\n\tmapping(address => mapping(address => uint256)) public fee;   // fee from tokenA to tokenB\n\tmapping(address => bool) public supportLending;\n\tmapping(address => uint256) public decimals;\n\n\tconstructor() public {\n\t}\n\n\tfunction active(address _lendFMe) public {\n\t\trequire(actived == false, \"already actived.\");\n\t\towner = msg.sender;\n\t\tisOpen = true;\n\t\tlendFMe = _lendFMe;\n\t\tactived = true;\n\t}\n\n\t// trade _inputAmount of _input token to get _output token\n\tfunction trade(address _input, address _output, uint256 _inputAmount) public returns (bool) {\n\t\treturn trade(_input, _output, _inputAmount, msg.sender);\n\t}\n\n\tfunction trade(address _input, address _output, uint256 _inputAmount, address _receiver) public returns (bool) {\n\t\trequire(isOpen, \"not open\");\n\t\trequire(prices[_input][_output] != 0, \"invalid token address\");\n\t\trequire(decimals[_input] != 0, \"input decimal not setteled\");\n\t\trequire(decimals[_output] != 0, \"output decimal not setteled\");\n\n\t\tNonStandardIERC20Token(_input).transferFrom(msg.sender, address(this), _inputAmount);\n\t\tif(supportLending[_input]) {\n\t\t\tif (_input == dai) {\n\t\t\t\tIChai(chai).join(address(this), _inputAmount);\n\t\t\t\tILendFMe(lendFMe).supply(chai, IERC20Token(chai).balanceOf(address(this)));\n\t\t\t}\n\t\t\telse\n\t\t\t\tILendFMe(lendFMe).supply(_input, _inputAmount);\n\t\t}\n\t\tuint256 _tokenAmount = normalizeToken(_input, _inputAmount).mul(prices[_input][_output]).div(OFFSET);\n\t\tuint256 _fee = _tokenAmount.mul(fee[_input][_output]).div(OFFSET);\n\t\tuint256 _amountToUser = _tokenAmount.sub(_fee);\n\n\t\tif(supportLending[_output]) {\n\t\t\tif (_output == dai) {\n\t\t\t\tILendFMe(lendFMe).withdraw(chai, _amountToUser); //assume chai / dai >= 1;\n\t\t\t\tIChai(chai).draw(address(this), _amountToUser);\n\t\t\t}\n\t\t\telse\n\t\t\t\tILendFMe(lendFMe).withdraw(_output, denormalizedToken(_output, _amountToUser));\n\t\t}\n\t\tNonStandardIERC20Token(_output).transfer(_receiver, denormalizedToken(_output, _amountToUser));\n\t\treturn true;\n\t}\n\n\tfunction getTokenLiquidation(address _token) public view returns (uint256) {\n\t\tuint256 balanceInDefi = ILendFMe(lendFMe).getSupplyBalance(address(this), _token);\n\t\treturn balanceInDefi.add(NonStandardIERC20Token(_token).balanceOf(address(this)));\n\t}\n\n\tfunction setLendFMe(address _lendFMe) public auth returns (bool) {\n\t\tlendFMe = _lendFMe;\n\t\treturn true;\n\t}\n\n\tfunction enableLending(address _token) public auth returns (bool) {\n\t\trequire(!supportLending[_token], \"the token is already supported lending\");\n\t\tsupportLending[_token] = true;\n\n\t\tif (_token == dai) {\n\t\t\tIERC20Token(_token).approve(chai, uint256(-1));\n\t\t\tIERC20Token(chai).approve(lendFMe, uint256(-1));\n\t\t}\n\t\telse {\n\t\t\tNonStandardIERC20Token(_token).approve(lendFMe, uint256(-1));\n\t\t}\n\n\t\tuint256 _balance = NonStandardIERC20Token(_token).balanceOf(address(this));\n\t\tif(_balance > 0) {\n\t\t\tif (_token == dai) {\n\t\t\t\tIChai(chai).join(address(this), _balance);\n\t\t\t\tILendFMe(lendFMe).supply(chai, IERC20Token(chai).balanceOf(address(this)));\n\t\t\t}\n\t\t\telse\n\t\t\t\tILendFMe(lendFMe).supply(_token, _balance);\n\t\t}\n\t\treturn true;\n\t}\n\n\tfunction disableLending(address _token) public auth returns (bool) {\n\t\trequire(supportLending[_token], \"the token doesnt support lending\");\n\t\tsupportLending[_token] = false;\n\n\t\tif (_token == dai) {\n\t\t\tILendFMe(lendFMe).withdraw(chai, uint256(-1));\n\t\t\tIChai(chai).exit(address(this), IERC20Token(chai).balanceOf(address(this)));\n\t\t}\n\t\telse\n\t\t\tILendFMe(lendFMe).withdraw(_token, uint256(-1));\n\n\t\treturn true;\n\t}\n\n\t// create new pairs\n\tfunction createPair(address _input, address _output, uint256 _priceInOut, uint256 _priceOutIn, uint256 _fee) external auth returns (bool) {\n\t\tsetPrices(_input, _output, _priceInOut, _priceOutIn);\n\t\tsetFee(_input, _output, _fee);\n\t\treturn true;\n\t}\n\n\tfunction setPrices(address _input, address _output, uint256 _priceInOut, uint256 _priceOutIn) public auth returns (bool) {\n\t\tsetPrices(_input, _output, _priceInOut);\n\t\tsetPrices(_output, _input, _priceOutIn);\n\t\treturn true;\n\t}\n\t//SWC-101-Integer Overflow and Underflow: L152\n\tfunction setPrices(address _input, address _output, uint256 _price) public auth returns (bool) {\n\t\tprices[_input][_output] = _price;\n\t\treturn true;\n\t}\n\n\tfunction setFee(address _input, address _output, uint256 _fee) public auth returns (bool) {\n\t\tfee[_input][_output] = _fee;\n\t\tfee[_output][_input] = _fee;\n\t\treturn true;\n\t}\n\n\tfunction setTokenDecimals(address _token, uint256 _decimals) public auth returns (bool){\n\t\trequire(_decimals <= 18, \"not supported decimal\");\n\t\tdecimals[_token] = _decimals;\n\t\treturn true;\n\t}\n\n\tfunction emergencyStop(bool _open) external auth returns (bool) {\n\t\tisOpen = _open;\n\t\treturn true;\n\t}\n\n\tfunction transferOut(address _token, address _receiver, uint256 _amount) external auth returns (bool) {\n\t\tif(supportLending[_token]) {\n\t\t\tif (_token == dai) {\n\t\t\t\tILendFMe(lendFMe).withdraw(chai, _amount);\n\t\t\t\tIChai(chai).draw(address(this), _amount);\n\t\t\t}\n\t\t\telse\n\t\t\t\tILendFMe(lendFMe).withdraw(_token, _amount);\n\t\t}\n\t\tuint256 _balance = NonStandardIERC20Token(_token).balanceOf(address(this));\n\t\tif(_balance >= _amount) {\n\t\t\tNonStandardIERC20Token(_token).transfer(_receiver, _amount);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tfunction transferOutALL(address _token, address _receiver) external auth returns (bool) {\n\t\tif(supportLending[_token]) {\n\t\t\tif (_token == dai) {\n\t\t\t\tILendFMe(lendFMe).withdraw(chai, uint256(-1));\n\t\t\t\tIChai(chai).exit(address(this), IERC20Token(chai).balanceOf(address(this)));\n\t\t\t}\n\t\t\telse\n\t\t\t\tILendFMe(lendFMe).withdraw(_token, uint256(-1));\n\t\t}\n\t\tuint256 _balance = NonStandardIERC20Token(_token).balanceOf(address(this));\n\t\tif(_balance > 0) {\n\t\t\tNonStandardIERC20Token(_token).transfer(_receiver, _balance);\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tfunction transferIn(address _token, uint256 _amount) external auth returns (bool) {\n\t\tNonStandardIERC20Token(_token).transferFrom(msg.sender, address(this), _amount);\n\t\tif(supportLending[_token]) {\n\t\t\tif (_token == dai) {\n\t\t\t\tIChai(chai).join(address(this), NonStandardIERC20Token(dai).balanceOf(address(this)));\n\t\t\t\tILendFMe(lendFMe).supply(chai, IERC20Token(chai).balanceOf(address(this)));\n\t\t\t}\n\t\t\telse\n\t\t\t\tILendFMe(lendFMe).supply(_token, NonStandardIERC20Token(_token).balanceOf(address(this)));\n\t\t}\n\t    return true;\n\t}\n\n\tfunction normalizeToken(address _token, uint256 _amount) internal view returns (uint256) {\n\t\tuint256 n = 18;\n\t\treturn _amount.mul((10 ** (n.sub(decimals[_token]))));\n\t}\n\n\tfunction denormalizedToken(address _token, uint256 _amount) internal view returns (uint256) {\n\t\tuint256 n = 18;\n\t\treturn _amount.div((10 ** (n.sub(decimals[_token]))));\n\t}\n}",
        "function": "enableLending(address)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/PeckShield-XSwap/xswap-326a3246b327cd2b8481fd8c22fe8d864e43b0da/contracts/XSwap.sol",
        "vulnerability": "State access after external call (SWC 107)",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract XSwap is DSAuth {\n\tusing DSMath for uint256;\n\n\tuint256 constant internal OFFSET = 10 ** 18;\n\t//Mainnet\n\t// address private chai = 0x06AF07097C9Eeb7fD685c692751D5C66dB49c215;\n\t// address private dai  = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n\n\t//Rinkeby\n\taddress private chai = 0x8a5C1BD4D75e168a4f65eB902c289400B90FD980;\n\taddress private dai  = 0xA3A59273494BB5B8F0a8FAcf21B3f666A47d6140;\n\n\tbool private actived;\n\taddress public lendFMe;\n\tbool public isOpen;\n\tmapping(address => mapping(address => uint256)) public prices; // 1 tokenA = ? tokenB\n\tmapping(address => mapping(address => uint256)) public fee;   // fee from tokenA to tokenB\n\tmapping(address => bool) public supportLending;\n\tmapping(address => uint256) public decimals;\n\n\tconstructor() public {\n\t}\n\n\tfunction active(address _lendFMe) public {\n\t\trequire(actived == false, \"already actived.\");\n\t\towner = msg.sender;\n\t\tisOpen = true;\n\t\tlendFMe = _lendFMe;\n\t\tactived = true;\n\t}\n\n\t// trade _inputAmount of _input token to get _output token\n\tfunction trade(address _input, address _output, uint256 _inputAmount) public returns (bool) {\n\t\treturn trade(_input, _output, _inputAmount, msg.sender);\n\t}\n\n\tfunction trade(address _input, address _output, uint256 _inputAmount, address _receiver) public returns (bool) {\n\t\trequire(isOpen, \"not open\");\n\t\trequire(prices[_input][_output] != 0, \"invalid token address\");\n\t\trequire(decimals[_input] != 0, \"input decimal not setteled\");\n\t\trequire(decimals[_output] != 0, \"output decimal not setteled\");\n\n\t\tNonStandardIERC20Token(_input).transferFrom(msg.sender, address(this), _inputAmount);\n\t\tif(supportLending[_input]) {\n\t\t\tif (_input == dai) {\n\t\t\t\tIChai(chai).join(address(this), _inputAmount);\n\t\t\t\tILendFMe(lendFMe).supply(chai, IERC20Token(chai).balanceOf(address(this)));\n\t\t\t}\n\t\t\telse\n\t\t\t\tILendFMe(lendFMe).supply(_input, _inputAmount);\n\t\t}\n\t\tuint256 _tokenAmount = normalizeToken(_input, _inputAmount).mul(prices[_input][_output]).div(OFFSET);\n\t\tuint256 _fee = _tokenAmount.mul(fee[_input][_output]).div(OFFSET);\n\t\tuint256 _amountToUser = _tokenAmount.sub(_fee);\n\n\t\tif(supportLending[_output]) {\n\t\t\tif (_output == dai) {\n\t\t\t\tILendFMe(lendFMe).withdraw(chai, _amountToUser); //assume chai / dai >= 1;\n\t\t\t\tIChai(chai).draw(address(this), _amountToUser);\n\t\t\t}\n\t\t\telse\n\t\t\t\tILendFMe(lendFMe).withdraw(_output, denormalizedToken(_output, _amountToUser));\n\t\t}\n\t\tNonStandardIERC20Token(_output).transfer(_receiver, denormalizedToken(_output, _amountToUser));\n\t\treturn true;\n\t}\n\n\tfunction getTokenLiquidation(address _token) public view returns (uint256) {\n\t\tuint256 balanceInDefi = ILendFMe(lendFMe).getSupplyBalance(address(this), _token);\n\t\treturn balanceInDefi.add(NonStandardIERC20Token(_token).balanceOf(address(this)));\n\t}\n\n\tfunction setLendFMe(address _lendFMe) public auth returns (bool) {\n\t\tlendFMe = _lendFMe;\n\t\treturn true;\n\t}\n\n\tfunction enableLending(address _token) public auth returns (bool) {\n\t\trequire(!supportLending[_token], \"the token is already supported lending\");\n\t\tsupportLending[_token] = true;\n\n\t\tif (_token == dai) {\n\t\t\tIERC20Token(_token).approve(chai, uint256(-1));\n\t\t\tIERC20Token(chai).approve(lendFMe, uint256(-1));\n\t\t}\n\t\telse {\n\t\t\tNonStandardIERC20Token(_token).approve(lendFMe, uint256(-1));\n\t\t}\n\n\t\tuint256 _balance = NonStandardIERC20Token(_token).balanceOf(address(this));\n\t\tif(_balance > 0) {\n\t\t\tif (_token == dai) {\n\t\t\t\tIChai(chai).join(address(this), _balance);\n\t\t\t\tILendFMe(lendFMe).supply(chai, IERC20Token(chai).balanceOf(address(this)));\n\t\t\t}\n\t\t\telse\n\t\t\t\tILendFMe(lendFMe).supply(_token, _balance);\n\t\t}\n\t\treturn true;\n\t}\n\n\tfunction disableLending(address _token) public auth returns (bool) {\n\t\trequire(supportLending[_token], \"the token doesnt support lending\");\n\t\tsupportLending[_token] = false;\n\n\t\tif (_token == dai) {\n\t\t\tILendFMe(lendFMe).withdraw(chai, uint256(-1));\n\t\t\tIChai(chai).exit(address(this), IERC20Token(chai).balanceOf(address(this)));\n\t\t}\n\t\telse\n\t\t\tILendFMe(lendFMe).withdraw(_token, uint256(-1));\n\n\t\treturn true;\n\t}\n\n\t// create new pairs\n\tfunction createPair(address _input, address _output, uint256 _priceInOut, uint256 _priceOutIn, uint256 _fee) external auth returns (bool) {\n\t\tsetPrices(_input, _output, _priceInOut, _priceOutIn);\n\t\tsetFee(_input, _output, _fee);\n\t\treturn true;\n\t}\n\n\tfunction setPrices(address _input, address _output, uint256 _priceInOut, uint256 _priceOutIn) public auth returns (bool) {\n\t\tsetPrices(_input, _output, _priceInOut);\n\t\tsetPrices(_output, _input, _priceOutIn);\n\t\treturn true;\n\t}\n\t//SWC-101-Integer Overflow and Underflow: L152\n\tfunction setPrices(address _input, address _output, uint256 _price) public auth returns (bool) {\n\t\tprices[_input][_output] = _price;\n\t\treturn true;\n\t}\n\n\tfunction setFee(address _input, address _output, uint256 _fee) public auth returns (bool) {\n\t\tfee[_input][_output] = _fee;\n\t\tfee[_output][_input] = _fee;\n\t\treturn true;\n\t}\n\n\tfunction setTokenDecimals(address _token, uint256 _decimals) public auth returns (bool){\n\t\trequire(_decimals <= 18, \"not supported decimal\");\n\t\tdecimals[_token] = _decimals;\n\t\treturn true;\n\t}\n\n\tfunction emergencyStop(bool _open) external auth returns (bool) {\n\t\tisOpen = _open;\n\t\treturn true;\n\t}\n\n\tfunction transferOut(address _token, address _receiver, uint256 _amount) external auth returns (bool) {\n\t\tif(supportLending[_token]) {\n\t\t\tif (_token == dai) {\n\t\t\t\tILendFMe(lendFMe).withdraw(chai, _amount);\n\t\t\t\tIChai(chai).draw(address(this), _amount);\n\t\t\t}\n\t\t\telse\n\t\t\t\tILendFMe(lendFMe).withdraw(_token, _amount);\n\t\t}\n\t\tuint256 _balance = NonStandardIERC20Token(_token).balanceOf(address(this));\n\t\tif(_balance >= _amount) {\n\t\t\tNonStandardIERC20Token(_token).transfer(_receiver, _amount);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tfunction transferOutALL(address _token, address _receiver) external auth returns (bool) {\n\t\tif(supportLending[_token]) {\n\t\t\tif (_token == dai) {\n\t\t\t\tILendFMe(lendFMe).withdraw(chai, uint256(-1));\n\t\t\t\tIChai(chai).exit(address(this), IERC20Token(chai).balanceOf(address(this)));\n\t\t\t}\n\t\t\telse\n\t\t\t\tILendFMe(lendFMe).withdraw(_token, uint256(-1));\n\t\t}\n\t\tuint256 _balance = NonStandardIERC20Token(_token).balanceOf(address(this));\n\t\tif(_balance > 0) {\n\t\t\tNonStandardIERC20Token(_token).transfer(_receiver, _balance);\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tfunction transferIn(address _token, uint256 _amount) external auth returns (bool) {\n\t\tNonStandardIERC20Token(_token).transferFrom(msg.sender, address(this), _amount);\n\t\tif(supportLending[_token]) {\n\t\t\tif (_token == dai) {\n\t\t\t\tIChai(chai).join(address(this), NonStandardIERC20Token(dai).balanceOf(address(this)));\n\t\t\t\tILendFMe(lendFMe).supply(chai, IERC20Token(chai).balanceOf(address(this)));\n\t\t\t}\n\t\t\telse\n\t\t\t\tILendFMe(lendFMe).supply(_token, NonStandardIERC20Token(_token).balanceOf(address(this)));\n\t\t}\n\t    return true;\n\t}\n\n\tfunction normalizeToken(address _token, uint256 _amount) internal view returns (uint256) {\n\t\tuint256 n = 18;\n\t\treturn _amount.mul((10 ** (n.sub(decimals[_token]))));\n\t}\n\n\tfunction denormalizedToken(address _token, uint256 _amount) internal view returns (uint256) {\n\t\tuint256 n = 18;\n\t\treturn _amount.div((10 ** (n.sub(decimals[_token]))));\n\t}\n}",
        "function": "enableLending(address)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/PeckShield-XSwap/xswap-326a3246b327cd2b8481fd8c22fe8d864e43b0da/contracts/XSwap.sol",
        "vulnerability": "State access after external call (SWC 107)",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract XSwap is DSAuth {\n\tusing DSMath for uint256;\n\n\tuint256 constant internal OFFSET = 10 ** 18;\n\t//Mainnet\n\t// address private chai = 0x06AF07097C9Eeb7fD685c692751D5C66dB49c215;\n\t// address private dai  = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n\n\t//Rinkeby\n\taddress private chai = 0x8a5C1BD4D75e168a4f65eB902c289400B90FD980;\n\taddress private dai  = 0xA3A59273494BB5B8F0a8FAcf21B3f666A47d6140;\n\n\tbool private actived;\n\taddress public lendFMe;\n\tbool public isOpen;\n\tmapping(address => mapping(address => uint256)) public prices; // 1 tokenA = ? tokenB\n\tmapping(address => mapping(address => uint256)) public fee;   // fee from tokenA to tokenB\n\tmapping(address => bool) public supportLending;\n\tmapping(address => uint256) public decimals;\n\n\tconstructor() public {\n\t}\n\n\tfunction active(address _lendFMe) public {\n\t\trequire(actived == false, \"already actived.\");\n\t\towner = msg.sender;\n\t\tisOpen = true;\n\t\tlendFMe = _lendFMe;\n\t\tactived = true;\n\t}\n\n\t// trade _inputAmount of _input token to get _output token\n\tfunction trade(address _input, address _output, uint256 _inputAmount) public returns (bool) {\n\t\treturn trade(_input, _output, _inputAmount, msg.sender);\n\t}\n\n\tfunction trade(address _input, address _output, uint256 _inputAmount, address _receiver) public returns (bool) {\n\t\trequire(isOpen, \"not open\");\n\t\trequire(prices[_input][_output] != 0, \"invalid token address\");\n\t\trequire(decimals[_input] != 0, \"input decimal not setteled\");\n\t\trequire(decimals[_output] != 0, \"output decimal not setteled\");\n\n\t\tNonStandardIERC20Token(_input).transferFrom(msg.sender, address(this), _inputAmount);\n\t\tif(supportLending[_input]) {\n\t\t\tif (_input == dai) {\n\t\t\t\tIChai(chai).join(address(this), _inputAmount);\n\t\t\t\tILendFMe(lendFMe).supply(chai, IERC20Token(chai).balanceOf(address(this)));\n\t\t\t}\n\t\t\telse\n\t\t\t\tILendFMe(lendFMe).supply(_input, _inputAmount);\n\t\t}\n\t\tuint256 _tokenAmount = normalizeToken(_input, _inputAmount).mul(prices[_input][_output]).div(OFFSET);\n\t\tuint256 _fee = _tokenAmount.mul(fee[_input][_output]).div(OFFSET);\n\t\tuint256 _amountToUser = _tokenAmount.sub(_fee);\n\n\t\tif(supportLending[_output]) {\n\t\t\tif (_output == dai) {\n\t\t\t\tILendFMe(lendFMe).withdraw(chai, _amountToUser); //assume chai / dai >= 1;\n\t\t\t\tIChai(chai).draw(address(this), _amountToUser);\n\t\t\t}\n\t\t\telse\n\t\t\t\tILendFMe(lendFMe).withdraw(_output, denormalizedToken(_output, _amountToUser));\n\t\t}\n\t\tNonStandardIERC20Token(_output).transfer(_receiver, denormalizedToken(_output, _amountToUser));\n\t\treturn true;\n\t}\n\n\tfunction getTokenLiquidation(address _token) public view returns (uint256) {\n\t\tuint256 balanceInDefi = ILendFMe(lendFMe).getSupplyBalance(address(this), _token);\n\t\treturn balanceInDefi.add(NonStandardIERC20Token(_token).balanceOf(address(this)));\n\t}\n\n\tfunction setLendFMe(address _lendFMe) public auth returns (bool) {\n\t\tlendFMe = _lendFMe;\n\t\treturn true;\n\t}\n\n\tfunction enableLending(address _token) public auth returns (bool) {\n\t\trequire(!supportLending[_token], \"the token is already supported lending\");\n\t\tsupportLending[_token] = true;\n\n\t\tif (_token == dai) {\n\t\t\tIERC20Token(_token).approve(chai, uint256(-1));\n\t\t\tIERC20Token(chai).approve(lendFMe, uint256(-1));\n\t\t}\n\t\telse {\n\t\t\tNonStandardIERC20Token(_token).approve(lendFMe, uint256(-1));\n\t\t}\n\n\t\tuint256 _balance = NonStandardIERC20Token(_token).balanceOf(address(this));\n\t\tif(_balance > 0) {\n\t\t\tif (_token == dai) {\n\t\t\t\tIChai(chai).join(address(this), _balance);\n\t\t\t\tILendFMe(lendFMe).supply(chai, IERC20Token(chai).balanceOf(address(this)));\n\t\t\t}\n\t\t\telse\n\t\t\t\tILendFMe(lendFMe).supply(_token, _balance);\n\t\t}\n\t\treturn true;\n\t}\n\n\tfunction disableLending(address _token) public auth returns (bool) {\n\t\trequire(supportLending[_token], \"the token doesnt support lending\");\n\t\tsupportLending[_token] = false;\n\n\t\tif (_token == dai) {\n\t\t\tILendFMe(lendFMe).withdraw(chai, uint256(-1));\n\t\t\tIChai(chai).exit(address(this), IERC20Token(chai).balanceOf(address(this)));\n\t\t}\n\t\telse\n\t\t\tILendFMe(lendFMe).withdraw(_token, uint256(-1));\n\n\t\treturn true;\n\t}\n\n\t// create new pairs\n\tfunction createPair(address _input, address _output, uint256 _priceInOut, uint256 _priceOutIn, uint256 _fee) external auth returns (bool) {\n\t\tsetPrices(_input, _output, _priceInOut, _priceOutIn);\n\t\tsetFee(_input, _output, _fee);\n\t\treturn true;\n\t}\n\n\tfunction setPrices(address _input, address _output, uint256 _priceInOut, uint256 _priceOutIn) public auth returns (bool) {\n\t\tsetPrices(_input, _output, _priceInOut);\n\t\tsetPrices(_output, _input, _priceOutIn);\n\t\treturn true;\n\t}\n\t//SWC-101-Integer Overflow and Underflow: L152\n\tfunction setPrices(address _input, address _output, uint256 _price) public auth returns (bool) {\n\t\tprices[_input][_output] = _price;\n\t\treturn true;\n\t}\n\n\tfunction setFee(address _input, address _output, uint256 _fee) public auth returns (bool) {\n\t\tfee[_input][_output] = _fee;\n\t\tfee[_output][_input] = _fee;\n\t\treturn true;\n\t}\n\n\tfunction setTokenDecimals(address _token, uint256 _decimals) public auth returns (bool){\n\t\trequire(_decimals <= 18, \"not supported decimal\");\n\t\tdecimals[_token] = _decimals;\n\t\treturn true;\n\t}\n\n\tfunction emergencyStop(bool _open) external auth returns (bool) {\n\t\tisOpen = _open;\n\t\treturn true;\n\t}\n\n\tfunction transferOut(address _token, address _receiver, uint256 _amount) external auth returns (bool) {\n\t\tif(supportLending[_token]) {\n\t\t\tif (_token == dai) {\n\t\t\t\tILendFMe(lendFMe).withdraw(chai, _amount);\n\t\t\t\tIChai(chai).draw(address(this), _amount);\n\t\t\t}\n\t\t\telse\n\t\t\t\tILendFMe(lendFMe).withdraw(_token, _amount);\n\t\t}\n\t\tuint256 _balance = NonStandardIERC20Token(_token).balanceOf(address(this));\n\t\tif(_balance >= _amount) {\n\t\t\tNonStandardIERC20Token(_token).transfer(_receiver, _amount);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tfunction transferOutALL(address _token, address _receiver) external auth returns (bool) {\n\t\tif(supportLending[_token]) {\n\t\t\tif (_token == dai) {\n\t\t\t\tILendFMe(lendFMe).withdraw(chai, uint256(-1));\n\t\t\t\tIChai(chai).exit(address(this), IERC20Token(chai).balanceOf(address(this)));\n\t\t\t}\n\t\t\telse\n\t\t\t\tILendFMe(lendFMe).withdraw(_token, uint256(-1));\n\t\t}\n\t\tuint256 _balance = NonStandardIERC20Token(_token).balanceOf(address(this));\n\t\tif(_balance > 0) {\n\t\t\tNonStandardIERC20Token(_token).transfer(_receiver, _balance);\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tfunction transferIn(address _token, uint256 _amount) external auth returns (bool) {\n\t\tNonStandardIERC20Token(_token).transferFrom(msg.sender, address(this), _amount);\n\t\tif(supportLending[_token]) {\n\t\t\tif (_token == dai) {\n\t\t\t\tIChai(chai).join(address(this), NonStandardIERC20Token(dai).balanceOf(address(this)));\n\t\t\t\tILendFMe(lendFMe).supply(chai, IERC20Token(chai).balanceOf(address(this)));\n\t\t\t}\n\t\t\telse\n\t\t\t\tILendFMe(lendFMe).supply(_token, NonStandardIERC20Token(_token).balanceOf(address(this)));\n\t\t}\n\t    return true;\n\t}\n\n\tfunction normalizeToken(address _token, uint256 _amount) internal view returns (uint256) {\n\t\tuint256 n = 18;\n\t\treturn _amount.mul((10 ** (n.sub(decimals[_token]))));\n\t}\n\n\tfunction denormalizedToken(address _token, uint256 _amount) internal view returns (uint256) {\n\t\tuint256 n = 18;\n\t\treturn _amount.div((10 ** (n.sub(decimals[_token]))));\n\t}\n}",
        "function": "enableLending(address)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/PeckShield-XSwap/xswap-326a3246b327cd2b8481fd8c22fe8d864e43b0da/contracts/XSwap.sol",
        "vulnerability": "State access after external call (SWC 107)",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract XSwap is DSAuth {\n\tusing DSMath for uint256;\n\n\tuint256 constant internal OFFSET = 10 ** 18;\n\t//Mainnet\n\t// address private chai = 0x06AF07097C9Eeb7fD685c692751D5C66dB49c215;\n\t// address private dai  = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n\n\t//Rinkeby\n\taddress private chai = 0x8a5C1BD4D75e168a4f65eB902c289400B90FD980;\n\taddress private dai  = 0xA3A59273494BB5B8F0a8FAcf21B3f666A47d6140;\n\n\tbool private actived;\n\taddress public lendFMe;\n\tbool public isOpen;\n\tmapping(address => mapping(address => uint256)) public prices; // 1 tokenA = ? tokenB\n\tmapping(address => mapping(address => uint256)) public fee;   // fee from tokenA to tokenB\n\tmapping(address => bool) public supportLending;\n\tmapping(address => uint256) public decimals;\n\n\tconstructor() public {\n\t}\n\n\tfunction active(address _lendFMe) public {\n\t\trequire(actived == false, \"already actived.\");\n\t\towner = msg.sender;\n\t\tisOpen = true;\n\t\tlendFMe = _lendFMe;\n\t\tactived = true;\n\t}\n\n\t// trade _inputAmount of _input token to get _output token\n\tfunction trade(address _input, address _output, uint256 _inputAmount) public returns (bool) {\n\t\treturn trade(_input, _output, _inputAmount, msg.sender);\n\t}\n\n\tfunction trade(address _input, address _output, uint256 _inputAmount, address _receiver) public returns (bool) {\n\t\trequire(isOpen, \"not open\");\n\t\trequire(prices[_input][_output] != 0, \"invalid token address\");\n\t\trequire(decimals[_input] != 0, \"input decimal not setteled\");\n\t\trequire(decimals[_output] != 0, \"output decimal not setteled\");\n\n\t\tNonStandardIERC20Token(_input).transferFrom(msg.sender, address(this), _inputAmount);\n\t\tif(supportLending[_input]) {\n\t\t\tif (_input == dai) {\n\t\t\t\tIChai(chai).join(address(this), _inputAmount);\n\t\t\t\tILendFMe(lendFMe).supply(chai, IERC20Token(chai).balanceOf(address(this)));\n\t\t\t}\n\t\t\telse\n\t\t\t\tILendFMe(lendFMe).supply(_input, _inputAmount);\n\t\t}\n\t\tuint256 _tokenAmount = normalizeToken(_input, _inputAmount).mul(prices[_input][_output]).div(OFFSET);\n\t\tuint256 _fee = _tokenAmount.mul(fee[_input][_output]).div(OFFSET);\n\t\tuint256 _amountToUser = _tokenAmount.sub(_fee);\n\n\t\tif(supportLending[_output]) {\n\t\t\tif (_output == dai) {\n\t\t\t\tILendFMe(lendFMe).withdraw(chai, _amountToUser); //assume chai / dai >= 1;\n\t\t\t\tIChai(chai).draw(address(this), _amountToUser);\n\t\t\t}\n\t\t\telse\n\t\t\t\tILendFMe(lendFMe).withdraw(_output, denormalizedToken(_output, _amountToUser));\n\t\t}\n\t\tNonStandardIERC20Token(_output).transfer(_receiver, denormalizedToken(_output, _amountToUser));\n\t\treturn true;\n\t}\n\n\tfunction getTokenLiquidation(address _token) public view returns (uint256) {\n\t\tuint256 balanceInDefi = ILendFMe(lendFMe).getSupplyBalance(address(this), _token);\n\t\treturn balanceInDefi.add(NonStandardIERC20Token(_token).balanceOf(address(this)));\n\t}\n\n\tfunction setLendFMe(address _lendFMe) public auth returns (bool) {\n\t\tlendFMe = _lendFMe;\n\t\treturn true;\n\t}\n\n\tfunction enableLending(address _token) public auth returns (bool) {\n\t\trequire(!supportLending[_token], \"the token is already supported lending\");\n\t\tsupportLending[_token] = true;\n\n\t\tif (_token == dai) {\n\t\t\tIERC20Token(_token).approve(chai, uint256(-1));\n\t\t\tIERC20Token(chai).approve(lendFMe, uint256(-1));\n\t\t}\n\t\telse {\n\t\t\tNonStandardIERC20Token(_token).approve(lendFMe, uint256(-1));\n\t\t}\n\n\t\tuint256 _balance = NonStandardIERC20Token(_token).balanceOf(address(this));\n\t\tif(_balance > 0) {\n\t\t\tif (_token == dai) {\n\t\t\t\tIChai(chai).join(address(this), _balance);\n\t\t\t\tILendFMe(lendFMe).supply(chai, IERC20Token(chai).balanceOf(address(this)));\n\t\t\t}\n\t\t\telse\n\t\t\t\tILendFMe(lendFMe).supply(_token, _balance);\n\t\t}\n\t\treturn true;\n\t}\n\n\tfunction disableLending(address _token) public auth returns (bool) {\n\t\trequire(supportLending[_token], \"the token doesnt support lending\");\n\t\tsupportLending[_token] = false;\n\n\t\tif (_token == dai) {\n\t\t\tILendFMe(lendFMe).withdraw(chai, uint256(-1));\n\t\t\tIChai(chai).exit(address(this), IERC20Token(chai).balanceOf(address(this)));\n\t\t}\n\t\telse\n\t\t\tILendFMe(lendFMe).withdraw(_token, uint256(-1));\n\n\t\treturn true;\n\t}\n\n\t// create new pairs\n\tfunction createPair(address _input, address _output, uint256 _priceInOut, uint256 _priceOutIn, uint256 _fee) external auth returns (bool) {\n\t\tsetPrices(_input, _output, _priceInOut, _priceOutIn);\n\t\tsetFee(_input, _output, _fee);\n\t\treturn true;\n\t}\n\n\tfunction setPrices(address _input, address _output, uint256 _priceInOut, uint256 _priceOutIn) public auth returns (bool) {\n\t\tsetPrices(_input, _output, _priceInOut);\n\t\tsetPrices(_output, _input, _priceOutIn);\n\t\treturn true;\n\t}\n\t//SWC-101-Integer Overflow and Underflow: L152\n\tfunction setPrices(address _input, address _output, uint256 _price) public auth returns (bool) {\n\t\tprices[_input][_output] = _price;\n\t\treturn true;\n\t}\n\n\tfunction setFee(address _input, address _output, uint256 _fee) public auth returns (bool) {\n\t\tfee[_input][_output] = _fee;\n\t\tfee[_output][_input] = _fee;\n\t\treturn true;\n\t}\n\n\tfunction setTokenDecimals(address _token, uint256 _decimals) public auth returns (bool){\n\t\trequire(_decimals <= 18, \"not supported decimal\");\n\t\tdecimals[_token] = _decimals;\n\t\treturn true;\n\t}\n\n\tfunction emergencyStop(bool _open) external auth returns (bool) {\n\t\tisOpen = _open;\n\t\treturn true;\n\t}\n\n\tfunction transferOut(address _token, address _receiver, uint256 _amount) external auth returns (bool) {\n\t\tif(supportLending[_token]) {\n\t\t\tif (_token == dai) {\n\t\t\t\tILendFMe(lendFMe).withdraw(chai, _amount);\n\t\t\t\tIChai(chai).draw(address(this), _amount);\n\t\t\t}\n\t\t\telse\n\t\t\t\tILendFMe(lendFMe).withdraw(_token, _amount);\n\t\t}\n\t\tuint256 _balance = NonStandardIERC20Token(_token).balanceOf(address(this));\n\t\tif(_balance >= _amount) {\n\t\t\tNonStandardIERC20Token(_token).transfer(_receiver, _amount);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tfunction transferOutALL(address _token, address _receiver) external auth returns (bool) {\n\t\tif(supportLending[_token]) {\n\t\t\tif (_token == dai) {\n\t\t\t\tILendFMe(lendFMe).withdraw(chai, uint256(-1));\n\t\t\t\tIChai(chai).exit(address(this), IERC20Token(chai).balanceOf(address(this)));\n\t\t\t}\n\t\t\telse\n\t\t\t\tILendFMe(lendFMe).withdraw(_token, uint256(-1));\n\t\t}\n\t\tuint256 _balance = NonStandardIERC20Token(_token).balanceOf(address(this));\n\t\tif(_balance > 0) {\n\t\t\tNonStandardIERC20Token(_token).transfer(_receiver, _balance);\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tfunction transferIn(address _token, uint256 _amount) external auth returns (bool) {\n\t\tNonStandardIERC20Token(_token).transferFrom(msg.sender, address(this), _amount);\n\t\tif(supportLending[_token]) {\n\t\t\tif (_token == dai) {\n\t\t\t\tIChai(chai).join(address(this), NonStandardIERC20Token(dai).balanceOf(address(this)));\n\t\t\t\tILendFMe(lendFMe).supply(chai, IERC20Token(chai).balanceOf(address(this)));\n\t\t\t}\n\t\t\telse\n\t\t\t\tILendFMe(lendFMe).supply(_token, NonStandardIERC20Token(_token).balanceOf(address(this)));\n\t\t}\n\t    return true;\n\t}\n\n\tfunction normalizeToken(address _token, uint256 _amount) internal view returns (uint256) {\n\t\tuint256 n = 18;\n\t\treturn _amount.mul((10 ** (n.sub(decimals[_token]))));\n\t}\n\n\tfunction denormalizedToken(address _token, uint256 _amount) internal view returns (uint256) {\n\t\tuint256 n = 18;\n\t\treturn _amount.div((10 ** (n.sub(decimals[_token]))));\n\t}\n}",
        "function": "enableLending(address)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/PeckShield-XSwap/xswap-326a3246b327cd2b8481fd8c22fe8d864e43b0da/contracts/XSwap.sol",
        "vulnerability": "State access after external call (SWC 107)",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract XSwap is DSAuth {\n\tusing DSMath for uint256;\n\n\tuint256 constant internal OFFSET = 10 ** 18;\n\t//Mainnet\n\t// address private chai = 0x06AF07097C9Eeb7fD685c692751D5C66dB49c215;\n\t// address private dai  = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n\n\t//Rinkeby\n\taddress private chai = 0x8a5C1BD4D75e168a4f65eB902c289400B90FD980;\n\taddress private dai  = 0xA3A59273494BB5B8F0a8FAcf21B3f666A47d6140;\n\n\tbool private actived;\n\taddress public lendFMe;\n\tbool public isOpen;\n\tmapping(address => mapping(address => uint256)) public prices; // 1 tokenA = ? tokenB\n\tmapping(address => mapping(address => uint256)) public fee;   // fee from tokenA to tokenB\n\tmapping(address => bool) public supportLending;\n\tmapping(address => uint256) public decimals;\n\n\tconstructor() public {\n\t}\n\n\tfunction active(address _lendFMe) public {\n\t\trequire(actived == false, \"already actived.\");\n\t\towner = msg.sender;\n\t\tisOpen = true;\n\t\tlendFMe = _lendFMe;\n\t\tactived = true;\n\t}\n\n\t// trade _inputAmount of _input token to get _output token\n\tfunction trade(address _input, address _output, uint256 _inputAmount) public returns (bool) {\n\t\treturn trade(_input, _output, _inputAmount, msg.sender);\n\t}\n\n\tfunction trade(address _input, address _output, uint256 _inputAmount, address _receiver) public returns (bool) {\n\t\trequire(isOpen, \"not open\");\n\t\trequire(prices[_input][_output] != 0, \"invalid token address\");\n\t\trequire(decimals[_input] != 0, \"input decimal not setteled\");\n\t\trequire(decimals[_output] != 0, \"output decimal not setteled\");\n\n\t\tNonStandardIERC20Token(_input).transferFrom(msg.sender, address(this), _inputAmount);\n\t\tif(supportLending[_input]) {\n\t\t\tif (_input == dai) {\n\t\t\t\tIChai(chai).join(address(this), _inputAmount);\n\t\t\t\tILendFMe(lendFMe).supply(chai, IERC20Token(chai).balanceOf(address(this)));\n\t\t\t}\n\t\t\telse\n\t\t\t\tILendFMe(lendFMe).supply(_input, _inputAmount);\n\t\t}\n\t\tuint256 _tokenAmount = normalizeToken(_input, _inputAmount).mul(prices[_input][_output]).div(OFFSET);\n\t\tuint256 _fee = _tokenAmount.mul(fee[_input][_output]).div(OFFSET);\n\t\tuint256 _amountToUser = _tokenAmount.sub(_fee);\n\n\t\tif(supportLending[_output]) {\n\t\t\tif (_output == dai) {\n\t\t\t\tILendFMe(lendFMe).withdraw(chai, _amountToUser); //assume chai / dai >= 1;\n\t\t\t\tIChai(chai).draw(address(this), _amountToUser);\n\t\t\t}\n\t\t\telse\n\t\t\t\tILendFMe(lendFMe).withdraw(_output, denormalizedToken(_output, _amountToUser));\n\t\t}\n\t\tNonStandardIERC20Token(_output).transfer(_receiver, denormalizedToken(_output, _amountToUser));\n\t\treturn true;\n\t}\n\n\tfunction getTokenLiquidation(address _token) public view returns (uint256) {\n\t\tuint256 balanceInDefi = ILendFMe(lendFMe).getSupplyBalance(address(this), _token);\n\t\treturn balanceInDefi.add(NonStandardIERC20Token(_token).balanceOf(address(this)));\n\t}\n\n\tfunction setLendFMe(address _lendFMe) public auth returns (bool) {\n\t\tlendFMe = _lendFMe;\n\t\treturn true;\n\t}\n\n\tfunction enableLending(address _token) public auth returns (bool) {\n\t\trequire(!supportLending[_token], \"the token is already supported lending\");\n\t\tsupportLending[_token] = true;\n\n\t\tif (_token == dai) {\n\t\t\tIERC20Token(_token).approve(chai, uint256(-1));\n\t\t\tIERC20Token(chai).approve(lendFMe, uint256(-1));\n\t\t}\n\t\telse {\n\t\t\tNonStandardIERC20Token(_token).approve(lendFMe, uint256(-1));\n\t\t}\n\n\t\tuint256 _balance = NonStandardIERC20Token(_token).balanceOf(address(this));\n\t\tif(_balance > 0) {\n\t\t\tif (_token == dai) {\n\t\t\t\tIChai(chai).join(address(this), _balance);\n\t\t\t\tILendFMe(lendFMe).supply(chai, IERC20Token(chai).balanceOf(address(this)));\n\t\t\t}\n\t\t\telse\n\t\t\t\tILendFMe(lendFMe).supply(_token, _balance);\n\t\t}\n\t\treturn true;\n\t}\n\n\tfunction disableLending(address _token) public auth returns (bool) {\n\t\trequire(supportLending[_token], \"the token doesnt support lending\");\n\t\tsupportLending[_token] = false;\n\n\t\tif (_token == dai) {\n\t\t\tILendFMe(lendFMe).withdraw(chai, uint256(-1));\n\t\t\tIChai(chai).exit(address(this), IERC20Token(chai).balanceOf(address(this)));\n\t\t}\n\t\telse\n\t\t\tILendFMe(lendFMe).withdraw(_token, uint256(-1));\n\n\t\treturn true;\n\t}\n\n\t// create new pairs\n\tfunction createPair(address _input, address _output, uint256 _priceInOut, uint256 _priceOutIn, uint256 _fee) external auth returns (bool) {\n\t\tsetPrices(_input, _output, _priceInOut, _priceOutIn);\n\t\tsetFee(_input, _output, _fee);\n\t\treturn true;\n\t}\n\n\tfunction setPrices(address _input, address _output, uint256 _priceInOut, uint256 _priceOutIn) public auth returns (bool) {\n\t\tsetPrices(_input, _output, _priceInOut);\n\t\tsetPrices(_output, _input, _priceOutIn);\n\t\treturn true;\n\t}\n\t//SWC-101-Integer Overflow and Underflow: L152\n\tfunction setPrices(address _input, address _output, uint256 _price) public auth returns (bool) {\n\t\tprices[_input][_output] = _price;\n\t\treturn true;\n\t}\n\n\tfunction setFee(address _input, address _output, uint256 _fee) public auth returns (bool) {\n\t\tfee[_input][_output] = _fee;\n\t\tfee[_output][_input] = _fee;\n\t\treturn true;\n\t}\n\n\tfunction setTokenDecimals(address _token, uint256 _decimals) public auth returns (bool){\n\t\trequire(_decimals <= 18, \"not supported decimal\");\n\t\tdecimals[_token] = _decimals;\n\t\treturn true;\n\t}\n\n\tfunction emergencyStop(bool _open) external auth returns (bool) {\n\t\tisOpen = _open;\n\t\treturn true;\n\t}\n\n\tfunction transferOut(address _token, address _receiver, uint256 _amount) external auth returns (bool) {\n\t\tif(supportLending[_token]) {\n\t\t\tif (_token == dai) {\n\t\t\t\tILendFMe(lendFMe).withdraw(chai, _amount);\n\t\t\t\tIChai(chai).draw(address(this), _amount);\n\t\t\t}\n\t\t\telse\n\t\t\t\tILendFMe(lendFMe).withdraw(_token, _amount);\n\t\t}\n\t\tuint256 _balance = NonStandardIERC20Token(_token).balanceOf(address(this));\n\t\tif(_balance >= _amount) {\n\t\t\tNonStandardIERC20Token(_token).transfer(_receiver, _amount);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tfunction transferOutALL(address _token, address _receiver) external auth returns (bool) {\n\t\tif(supportLending[_token]) {\n\t\t\tif (_token == dai) {\n\t\t\t\tILendFMe(lendFMe).withdraw(chai, uint256(-1));\n\t\t\t\tIChai(chai).exit(address(this), IERC20Token(chai).balanceOf(address(this)));\n\t\t\t}\n\t\t\telse\n\t\t\t\tILendFMe(lendFMe).withdraw(_token, uint256(-1));\n\t\t}\n\t\tuint256 _balance = NonStandardIERC20Token(_token).balanceOf(address(this));\n\t\tif(_balance > 0) {\n\t\t\tNonStandardIERC20Token(_token).transfer(_receiver, _balance);\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tfunction transferIn(address _token, uint256 _amount) external auth returns (bool) {\n\t\tNonStandardIERC20Token(_token).transferFrom(msg.sender, address(this), _amount);\n\t\tif(supportLending[_token]) {\n\t\t\tif (_token == dai) {\n\t\t\t\tIChai(chai).join(address(this), NonStandardIERC20Token(dai).balanceOf(address(this)));\n\t\t\t\tILendFMe(lendFMe).supply(chai, IERC20Token(chai).balanceOf(address(this)));\n\t\t\t}\n\t\t\telse\n\t\t\t\tILendFMe(lendFMe).supply(_token, NonStandardIERC20Token(_token).balanceOf(address(this)));\n\t\t}\n\t    return true;\n\t}\n\n\tfunction normalizeToken(address _token, uint256 _amount) internal view returns (uint256) {\n\t\tuint256 n = 18;\n\t\treturn _amount.mul((10 ** (n.sub(decimals[_token]))));\n\t}\n\n\tfunction denormalizedToken(address _token, uint256 _amount) internal view returns (uint256) {\n\t\tuint256 n = 18;\n\t\treturn _amount.div((10 ** (n.sub(decimals[_token]))));\n\t}\n}",
        "function": "enableLending(address)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/PeckShield-XSwap/xswap-326a3246b327cd2b8481fd8c22fe8d864e43b0da/contracts/XSwap.sol",
        "vulnerability": "State access after external call (SWC 107)",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract XSwap is DSAuth {\n\tusing DSMath for uint256;\n\n\tuint256 constant internal OFFSET = 10 ** 18;\n\t//Mainnet\n\t// address private chai = 0x06AF07097C9Eeb7fD685c692751D5C66dB49c215;\n\t// address private dai  = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n\n\t//Rinkeby\n\taddress private chai = 0x8a5C1BD4D75e168a4f65eB902c289400B90FD980;\n\taddress private dai  = 0xA3A59273494BB5B8F0a8FAcf21B3f666A47d6140;\n\n\tbool private actived;\n\taddress public lendFMe;\n\tbool public isOpen;\n\tmapping(address => mapping(address => uint256)) public prices; // 1 tokenA = ? tokenB\n\tmapping(address => mapping(address => uint256)) public fee;   // fee from tokenA to tokenB\n\tmapping(address => bool) public supportLending;\n\tmapping(address => uint256) public decimals;\n\n\tconstructor() public {\n\t}\n\n\tfunction active(address _lendFMe) public {\n\t\trequire(actived == false, \"already actived.\");\n\t\towner = msg.sender;\n\t\tisOpen = true;\n\t\tlendFMe = _lendFMe;\n\t\tactived = true;\n\t}\n\n\t// trade _inputAmount of _input token to get _output token\n\tfunction trade(address _input, address _output, uint256 _inputAmount) public returns (bool) {\n\t\treturn trade(_input, _output, _inputAmount, msg.sender);\n\t}\n\n\tfunction trade(address _input, address _output, uint256 _inputAmount, address _receiver) public returns (bool) {\n\t\trequire(isOpen, \"not open\");\n\t\trequire(prices[_input][_output] != 0, \"invalid token address\");\n\t\trequire(decimals[_input] != 0, \"input decimal not setteled\");\n\t\trequire(decimals[_output] != 0, \"output decimal not setteled\");\n\n\t\tNonStandardIERC20Token(_input).transferFrom(msg.sender, address(this), _inputAmount);\n\t\tif(supportLending[_input]) {\n\t\t\tif (_input == dai) {\n\t\t\t\tIChai(chai).join(address(this), _inputAmount);\n\t\t\t\tILendFMe(lendFMe).supply(chai, IERC20Token(chai).balanceOf(address(this)));\n\t\t\t}\n\t\t\telse\n\t\t\t\tILendFMe(lendFMe).supply(_input, _inputAmount);\n\t\t}\n\t\tuint256 _tokenAmount = normalizeToken(_input, _inputAmount).mul(prices[_input][_output]).div(OFFSET);\n\t\tuint256 _fee = _tokenAmount.mul(fee[_input][_output]).div(OFFSET);\n\t\tuint256 _amountToUser = _tokenAmount.sub(_fee);\n\n\t\tif(supportLending[_output]) {\n\t\t\tif (_output == dai) {\n\t\t\t\tILendFMe(lendFMe).withdraw(chai, _amountToUser); //assume chai / dai >= 1;\n\t\t\t\tIChai(chai).draw(address(this), _amountToUser);\n\t\t\t}\n\t\t\telse\n\t\t\t\tILendFMe(lendFMe).withdraw(_output, denormalizedToken(_output, _amountToUser));\n\t\t}\n\t\tNonStandardIERC20Token(_output).transfer(_receiver, denormalizedToken(_output, _amountToUser));\n\t\treturn true;\n\t}\n\n\tfunction getTokenLiquidation(address _token) public view returns (uint256) {\n\t\tuint256 balanceInDefi = ILendFMe(lendFMe).getSupplyBalance(address(this), _token);\n\t\treturn balanceInDefi.add(NonStandardIERC20Token(_token).balanceOf(address(this)));\n\t}\n\n\tfunction setLendFMe(address _lendFMe) public auth returns (bool) {\n\t\tlendFMe = _lendFMe;\n\t\treturn true;\n\t}\n\n\tfunction enableLending(address _token) public auth returns (bool) {\n\t\trequire(!supportLending[_token], \"the token is already supported lending\");\n\t\tsupportLending[_token] = true;\n\n\t\tif (_token == dai) {\n\t\t\tIERC20Token(_token).approve(chai, uint256(-1));\n\t\t\tIERC20Token(chai).approve(lendFMe, uint256(-1));\n\t\t}\n\t\telse {\n\t\t\tNonStandardIERC20Token(_token).approve(lendFMe, uint256(-1));\n\t\t}\n\n\t\tuint256 _balance = NonStandardIERC20Token(_token).balanceOf(address(this));\n\t\tif(_balance > 0) {\n\t\t\tif (_token == dai) {\n\t\t\t\tIChai(chai).join(address(this), _balance);\n\t\t\t\tILendFMe(lendFMe).supply(chai, IERC20Token(chai).balanceOf(address(this)));\n\t\t\t}\n\t\t\telse\n\t\t\t\tILendFMe(lendFMe).supply(_token, _balance);\n\t\t}\n\t\treturn true;\n\t}\n\n\tfunction disableLending(address _token) public auth returns (bool) {\n\t\trequire(supportLending[_token], \"the token doesnt support lending\");\n\t\tsupportLending[_token] = false;\n\n\t\tif (_token == dai) {\n\t\t\tILendFMe(lendFMe).withdraw(chai, uint256(-1));\n\t\t\tIChai(chai).exit(address(this), IERC20Token(chai).balanceOf(address(this)));\n\t\t}\n\t\telse\n\t\t\tILendFMe(lendFMe).withdraw(_token, uint256(-1));\n\n\t\treturn true;\n\t}\n\n\t// create new pairs\n\tfunction createPair(address _input, address _output, uint256 _priceInOut, uint256 _priceOutIn, uint256 _fee) external auth returns (bool) {\n\t\tsetPrices(_input, _output, _priceInOut, _priceOutIn);\n\t\tsetFee(_input, _output, _fee);\n\t\treturn true;\n\t}\n\n\tfunction setPrices(address _input, address _output, uint256 _priceInOut, uint256 _priceOutIn) public auth returns (bool) {\n\t\tsetPrices(_input, _output, _priceInOut);\n\t\tsetPrices(_output, _input, _priceOutIn);\n\t\treturn true;\n\t}\n\t//SWC-101-Integer Overflow and Underflow: L152\n\tfunction setPrices(address _input, address _output, uint256 _price) public auth returns (bool) {\n\t\tprices[_input][_output] = _price;\n\t\treturn true;\n\t}\n\n\tfunction setFee(address _input, address _output, uint256 _fee) public auth returns (bool) {\n\t\tfee[_input][_output] = _fee;\n\t\tfee[_output][_input] = _fee;\n\t\treturn true;\n\t}\n\n\tfunction setTokenDecimals(address _token, uint256 _decimals) public auth returns (bool){\n\t\trequire(_decimals <= 18, \"not supported decimal\");\n\t\tdecimals[_token] = _decimals;\n\t\treturn true;\n\t}\n\n\tfunction emergencyStop(bool _open) external auth returns (bool) {\n\t\tisOpen = _open;\n\t\treturn true;\n\t}\n\n\tfunction transferOut(address _token, address _receiver, uint256 _amount) external auth returns (bool) {\n\t\tif(supportLending[_token]) {\n\t\t\tif (_token == dai) {\n\t\t\t\tILendFMe(lendFMe).withdraw(chai, _amount);\n\t\t\t\tIChai(chai).draw(address(this), _amount);\n\t\t\t}\n\t\t\telse\n\t\t\t\tILendFMe(lendFMe).withdraw(_token, _amount);\n\t\t}\n\t\tuint256 _balance = NonStandardIERC20Token(_token).balanceOf(address(this));\n\t\tif(_balance >= _amount) {\n\t\t\tNonStandardIERC20Token(_token).transfer(_receiver, _amount);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tfunction transferOutALL(address _token, address _receiver) external auth returns (bool) {\n\t\tif(supportLending[_token]) {\n\t\t\tif (_token == dai) {\n\t\t\t\tILendFMe(lendFMe).withdraw(chai, uint256(-1));\n\t\t\t\tIChai(chai).exit(address(this), IERC20Token(chai).balanceOf(address(this)));\n\t\t\t}\n\t\t\telse\n\t\t\t\tILendFMe(lendFMe).withdraw(_token, uint256(-1));\n\t\t}\n\t\tuint256 _balance = NonStandardIERC20Token(_token).balanceOf(address(this));\n\t\tif(_balance > 0) {\n\t\t\tNonStandardIERC20Token(_token).transfer(_receiver, _balance);\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tfunction transferIn(address _token, uint256 _amount) external auth returns (bool) {\n\t\tNonStandardIERC20Token(_token).transferFrom(msg.sender, address(this), _amount);\n\t\tif(supportLending[_token]) {\n\t\t\tif (_token == dai) {\n\t\t\t\tIChai(chai).join(address(this), NonStandardIERC20Token(dai).balanceOf(address(this)));\n\t\t\t\tILendFMe(lendFMe).supply(chai, IERC20Token(chai).balanceOf(address(this)));\n\t\t\t}\n\t\t\telse\n\t\t\t\tILendFMe(lendFMe).supply(_token, NonStandardIERC20Token(_token).balanceOf(address(this)));\n\t\t}\n\t    return true;\n\t}\n\n\tfunction normalizeToken(address _token, uint256 _amount) internal view returns (uint256) {\n\t\tuint256 n = 18;\n\t\treturn _amount.mul((10 ** (n.sub(decimals[_token]))));\n\t}\n\n\tfunction denormalizedToken(address _token, uint256 _amount) internal view returns (uint256) {\n\t\tuint256 n = 18;\n\t\treturn _amount.div((10 ** (n.sub(decimals[_token]))));\n\t}\n}",
        "function": "enableLending(address)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/PeckShield-XSwap/xswap-326a3246b327cd2b8481fd8c22fe8d864e43b0da/contracts/XSwap.sol",
        "vulnerability": "State access after external call (SWC 107)",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract XSwap is DSAuth {\n\tusing DSMath for uint256;\n\n\tuint256 constant internal OFFSET = 10 ** 18;\n\t//Mainnet\n\t// address private chai = 0x06AF07097C9Eeb7fD685c692751D5C66dB49c215;\n\t// address private dai  = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n\n\t//Rinkeby\n\taddress private chai = 0x8a5C1BD4D75e168a4f65eB902c289400B90FD980;\n\taddress private dai  = 0xA3A59273494BB5B8F0a8FAcf21B3f666A47d6140;\n\n\tbool private actived;\n\taddress public lendFMe;\n\tbool public isOpen;\n\tmapping(address => mapping(address => uint256)) public prices; // 1 tokenA = ? tokenB\n\tmapping(address => mapping(address => uint256)) public fee;   // fee from tokenA to tokenB\n\tmapping(address => bool) public supportLending;\n\tmapping(address => uint256) public decimals;\n\n\tconstructor() public {\n\t}\n\n\tfunction active(address _lendFMe) public {\n\t\trequire(actived == false, \"already actived.\");\n\t\towner = msg.sender;\n\t\tisOpen = true;\n\t\tlendFMe = _lendFMe;\n\t\tactived = true;\n\t}\n\n\t// trade _inputAmount of _input token to get _output token\n\tfunction trade(address _input, address _output, uint256 _inputAmount) public returns (bool) {\n\t\treturn trade(_input, _output, _inputAmount, msg.sender);\n\t}\n\n\tfunction trade(address _input, address _output, uint256 _inputAmount, address _receiver) public returns (bool) {\n\t\trequire(isOpen, \"not open\");\n\t\trequire(prices[_input][_output] != 0, \"invalid token address\");\n\t\trequire(decimals[_input] != 0, \"input decimal not setteled\");\n\t\trequire(decimals[_output] != 0, \"output decimal not setteled\");\n\n\t\tNonStandardIERC20Token(_input).transferFrom(msg.sender, address(this), _inputAmount);\n\t\tif(supportLending[_input]) {\n\t\t\tif (_input == dai) {\n\t\t\t\tIChai(chai).join(address(this), _inputAmount);\n\t\t\t\tILendFMe(lendFMe).supply(chai, IERC20Token(chai).balanceOf(address(this)));\n\t\t\t}\n\t\t\telse\n\t\t\t\tILendFMe(lendFMe).supply(_input, _inputAmount);\n\t\t}\n\t\tuint256 _tokenAmount = normalizeToken(_input, _inputAmount).mul(prices[_input][_output]).div(OFFSET);\n\t\tuint256 _fee = _tokenAmount.mul(fee[_input][_output]).div(OFFSET);\n\t\tuint256 _amountToUser = _tokenAmount.sub(_fee);\n\n\t\tif(supportLending[_output]) {\n\t\t\tif (_output == dai) {\n\t\t\t\tILendFMe(lendFMe).withdraw(chai, _amountToUser); //assume chai / dai >= 1;\n\t\t\t\tIChai(chai).draw(address(this), _amountToUser);\n\t\t\t}\n\t\t\telse\n\t\t\t\tILendFMe(lendFMe).withdraw(_output, denormalizedToken(_output, _amountToUser));\n\t\t}\n\t\tNonStandardIERC20Token(_output).transfer(_receiver, denormalizedToken(_output, _amountToUser));\n\t\treturn true;\n\t}\n\n\tfunction getTokenLiquidation(address _token) public view returns (uint256) {\n\t\tuint256 balanceInDefi = ILendFMe(lendFMe).getSupplyBalance(address(this), _token);\n\t\treturn balanceInDefi.add(NonStandardIERC20Token(_token).balanceOf(address(this)));\n\t}\n\n\tfunction setLendFMe(address _lendFMe) public auth returns (bool) {\n\t\tlendFMe = _lendFMe;\n\t\treturn true;\n\t}\n\n\tfunction enableLending(address _token) public auth returns (bool) {\n\t\trequire(!supportLending[_token], \"the token is already supported lending\");\n\t\tsupportLending[_token] = true;\n\n\t\tif (_token == dai) {\n\t\t\tIERC20Token(_token).approve(chai, uint256(-1));\n\t\t\tIERC20Token(chai).approve(lendFMe, uint256(-1));\n\t\t}\n\t\telse {\n\t\t\tNonStandardIERC20Token(_token).approve(lendFMe, uint256(-1));\n\t\t}\n\n\t\tuint256 _balance = NonStandardIERC20Token(_token).balanceOf(address(this));\n\t\tif(_balance > 0) {\n\t\t\tif (_token == dai) {\n\t\t\t\tIChai(chai).join(address(this), _balance);\n\t\t\t\tILendFMe(lendFMe).supply(chai, IERC20Token(chai).balanceOf(address(this)));\n\t\t\t}\n\t\t\telse\n\t\t\t\tILendFMe(lendFMe).supply(_token, _balance);\n\t\t}\n\t\treturn true;\n\t}\n\n\tfunction disableLending(address _token) public auth returns (bool) {\n\t\trequire(supportLending[_token], \"the token doesnt support lending\");\n\t\tsupportLending[_token] = false;\n\n\t\tif (_token == dai) {\n\t\t\tILendFMe(lendFMe).withdraw(chai, uint256(-1));\n\t\t\tIChai(chai).exit(address(this), IERC20Token(chai).balanceOf(address(this)));\n\t\t}\n\t\telse\n\t\t\tILendFMe(lendFMe).withdraw(_token, uint256(-1));\n\n\t\treturn true;\n\t}\n\n\t// create new pairs\n\tfunction createPair(address _input, address _output, uint256 _priceInOut, uint256 _priceOutIn, uint256 _fee) external auth returns (bool) {\n\t\tsetPrices(_input, _output, _priceInOut, _priceOutIn);\n\t\tsetFee(_input, _output, _fee);\n\t\treturn true;\n\t}\n\n\tfunction setPrices(address _input, address _output, uint256 _priceInOut, uint256 _priceOutIn) public auth returns (bool) {\n\t\tsetPrices(_input, _output, _priceInOut);\n\t\tsetPrices(_output, _input, _priceOutIn);\n\t\treturn true;\n\t}\n\t//SWC-101-Integer Overflow and Underflow: L152\n\tfunction setPrices(address _input, address _output, uint256 _price) public auth returns (bool) {\n\t\tprices[_input][_output] = _price;\n\t\treturn true;\n\t}\n\n\tfunction setFee(address _input, address _output, uint256 _fee) public auth returns (bool) {\n\t\tfee[_input][_output] = _fee;\n\t\tfee[_output][_input] = _fee;\n\t\treturn true;\n\t}\n\n\tfunction setTokenDecimals(address _token, uint256 _decimals) public auth returns (bool){\n\t\trequire(_decimals <= 18, \"not supported decimal\");\n\t\tdecimals[_token] = _decimals;\n\t\treturn true;\n\t}\n\n\tfunction emergencyStop(bool _open) external auth returns (bool) {\n\t\tisOpen = _open;\n\t\treturn true;\n\t}\n\n\tfunction transferOut(address _token, address _receiver, uint256 _amount) external auth returns (bool) {\n\t\tif(supportLending[_token]) {\n\t\t\tif (_token == dai) {\n\t\t\t\tILendFMe(lendFMe).withdraw(chai, _amount);\n\t\t\t\tIChai(chai).draw(address(this), _amount);\n\t\t\t}\n\t\t\telse\n\t\t\t\tILendFMe(lendFMe).withdraw(_token, _amount);\n\t\t}\n\t\tuint256 _balance = NonStandardIERC20Token(_token).balanceOf(address(this));\n\t\tif(_balance >= _amount) {\n\t\t\tNonStandardIERC20Token(_token).transfer(_receiver, _amount);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tfunction transferOutALL(address _token, address _receiver) external auth returns (bool) {\n\t\tif(supportLending[_token]) {\n\t\t\tif (_token == dai) {\n\t\t\t\tILendFMe(lendFMe).withdraw(chai, uint256(-1));\n\t\t\t\tIChai(chai).exit(address(this), IERC20Token(chai).balanceOf(address(this)));\n\t\t\t}\n\t\t\telse\n\t\t\t\tILendFMe(lendFMe).withdraw(_token, uint256(-1));\n\t\t}\n\t\tuint256 _balance = NonStandardIERC20Token(_token).balanceOf(address(this));\n\t\tif(_balance > 0) {\n\t\t\tNonStandardIERC20Token(_token).transfer(_receiver, _balance);\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tfunction transferIn(address _token, uint256 _amount) external auth returns (bool) {\n\t\tNonStandardIERC20Token(_token).transferFrom(msg.sender, address(this), _amount);\n\t\tif(supportLending[_token]) {\n\t\t\tif (_token == dai) {\n\t\t\t\tIChai(chai).join(address(this), NonStandardIERC20Token(dai).balanceOf(address(this)));\n\t\t\t\tILendFMe(lendFMe).supply(chai, IERC20Token(chai).balanceOf(address(this)));\n\t\t\t}\n\t\t\telse\n\t\t\t\tILendFMe(lendFMe).supply(_token, NonStandardIERC20Token(_token).balanceOf(address(this)));\n\t\t}\n\t    return true;\n\t}\n\n\tfunction normalizeToken(address _token, uint256 _amount) internal view returns (uint256) {\n\t\tuint256 n = 18;\n\t\treturn _amount.mul((10 ** (n.sub(decimals[_token]))));\n\t}\n\n\tfunction denormalizedToken(address _token, uint256 _amount) internal view returns (uint256) {\n\t\tuint256 n = 18;\n\t\treturn _amount.div((10 ** (n.sub(decimals[_token]))));\n\t}\n}",
        "function": "enableLending(address)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/PeckShield-XSwap/xswap-326a3246b327cd2b8481fd8c22fe8d864e43b0da/contracts/XSwap.sol",
        "vulnerability": "State access after external call (SWC 107)",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract XSwap is DSAuth {\n\tusing DSMath for uint256;\n\n\tuint256 constant internal OFFSET = 10 ** 18;\n\t//Mainnet\n\t// address private chai = 0x06AF07097C9Eeb7fD685c692751D5C66dB49c215;\n\t// address private dai  = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n\n\t//Rinkeby\n\taddress private chai = 0x8a5C1BD4D75e168a4f65eB902c289400B90FD980;\n\taddress private dai  = 0xA3A59273494BB5B8F0a8FAcf21B3f666A47d6140;\n\n\tbool private actived;\n\taddress public lendFMe;\n\tbool public isOpen;\n\tmapping(address => mapping(address => uint256)) public prices; // 1 tokenA = ? tokenB\n\tmapping(address => mapping(address => uint256)) public fee;   // fee from tokenA to tokenB\n\tmapping(address => bool) public supportLending;\n\tmapping(address => uint256) public decimals;\n\n\tconstructor() public {\n\t}\n\n\tfunction active(address _lendFMe) public {\n\t\trequire(actived == false, \"already actived.\");\n\t\towner = msg.sender;\n\t\tisOpen = true;\n\t\tlendFMe = _lendFMe;\n\t\tactived = true;\n\t}\n\n\t// trade _inputAmount of _input token to get _output token\n\tfunction trade(address _input, address _output, uint256 _inputAmount) public returns (bool) {\n\t\treturn trade(_input, _output, _inputAmount, msg.sender);\n\t}\n\n\tfunction trade(address _input, address _output, uint256 _inputAmount, address _receiver) public returns (bool) {\n\t\trequire(isOpen, \"not open\");\n\t\trequire(prices[_input][_output] != 0, \"invalid token address\");\n\t\trequire(decimals[_input] != 0, \"input decimal not setteled\");\n\t\trequire(decimals[_output] != 0, \"output decimal not setteled\");\n\n\t\tNonStandardIERC20Token(_input).transferFrom(msg.sender, address(this), _inputAmount);\n\t\tif(supportLending[_input]) {\n\t\t\tif (_input == dai) {\n\t\t\t\tIChai(chai).join(address(this), _inputAmount);\n\t\t\t\tILendFMe(lendFMe).supply(chai, IERC20Token(chai).balanceOf(address(this)));\n\t\t\t}\n\t\t\telse\n\t\t\t\tILendFMe(lendFMe).supply(_input, _inputAmount);\n\t\t}\n\t\tuint256 _tokenAmount = normalizeToken(_input, _inputAmount).mul(prices[_input][_output]).div(OFFSET);\n\t\tuint256 _fee = _tokenAmount.mul(fee[_input][_output]).div(OFFSET);\n\t\tuint256 _amountToUser = _tokenAmount.sub(_fee);\n\n\t\tif(supportLending[_output]) {\n\t\t\tif (_output == dai) {\n\t\t\t\tILendFMe(lendFMe).withdraw(chai, _amountToUser); //assume chai / dai >= 1;\n\t\t\t\tIChai(chai).draw(address(this), _amountToUser);\n\t\t\t}\n\t\t\telse\n\t\t\t\tILendFMe(lendFMe).withdraw(_output, denormalizedToken(_output, _amountToUser));\n\t\t}\n\t\tNonStandardIERC20Token(_output).transfer(_receiver, denormalizedToken(_output, _amountToUser));\n\t\treturn true;\n\t}\n\n\tfunction getTokenLiquidation(address _token) public view returns (uint256) {\n\t\tuint256 balanceInDefi = ILendFMe(lendFMe).getSupplyBalance(address(this), _token);\n\t\treturn balanceInDefi.add(NonStandardIERC20Token(_token).balanceOf(address(this)));\n\t}\n\n\tfunction setLendFMe(address _lendFMe) public auth returns (bool) {\n\t\tlendFMe = _lendFMe;\n\t\treturn true;\n\t}\n\n\tfunction enableLending(address _token) public auth returns (bool) {\n\t\trequire(!supportLending[_token], \"the token is already supported lending\");\n\t\tsupportLending[_token] = true;\n\n\t\tif (_token == dai) {\n\t\t\tIERC20Token(_token).approve(chai, uint256(-1));\n\t\t\tIERC20Token(chai).approve(lendFMe, uint256(-1));\n\t\t}\n\t\telse {\n\t\t\tNonStandardIERC20Token(_token).approve(lendFMe, uint256(-1));\n\t\t}\n\n\t\tuint256 _balance = NonStandardIERC20Token(_token).balanceOf(address(this));\n\t\tif(_balance > 0) {\n\t\t\tif (_token == dai) {\n\t\t\t\tIChai(chai).join(address(this), _balance);\n\t\t\t\tILendFMe(lendFMe).supply(chai, IERC20Token(chai).balanceOf(address(this)));\n\t\t\t}\n\t\t\telse\n\t\t\t\tILendFMe(lendFMe).supply(_token, _balance);\n\t\t}\n\t\treturn true;\n\t}\n\n\tfunction disableLending(address _token) public auth returns (bool) {\n\t\trequire(supportLending[_token], \"the token doesnt support lending\");\n\t\tsupportLending[_token] = false;\n\n\t\tif (_token == dai) {\n\t\t\tILendFMe(lendFMe).withdraw(chai, uint256(-1));\n\t\t\tIChai(chai).exit(address(this), IERC20Token(chai).balanceOf(address(this)));\n\t\t}\n\t\telse\n\t\t\tILendFMe(lendFMe).withdraw(_token, uint256(-1));\n\n\t\treturn true;\n\t}\n\n\t// create new pairs\n\tfunction createPair(address _input, address _output, uint256 _priceInOut, uint256 _priceOutIn, uint256 _fee) external auth returns (bool) {\n\t\tsetPrices(_input, _output, _priceInOut, _priceOutIn);\n\t\tsetFee(_input, _output, _fee);\n\t\treturn true;\n\t}\n\n\tfunction setPrices(address _input, address _output, uint256 _priceInOut, uint256 _priceOutIn) public auth returns (bool) {\n\t\tsetPrices(_input, _output, _priceInOut);\n\t\tsetPrices(_output, _input, _priceOutIn);\n\t\treturn true;\n\t}\n\t//SWC-101-Integer Overflow and Underflow: L152\n\tfunction setPrices(address _input, address _output, uint256 _price) public auth returns (bool) {\n\t\tprices[_input][_output] = _price;\n\t\treturn true;\n\t}\n\n\tfunction setFee(address _input, address _output, uint256 _fee) public auth returns (bool) {\n\t\tfee[_input][_output] = _fee;\n\t\tfee[_output][_input] = _fee;\n\t\treturn true;\n\t}\n\n\tfunction setTokenDecimals(address _token, uint256 _decimals) public auth returns (bool){\n\t\trequire(_decimals <= 18, \"not supported decimal\");\n\t\tdecimals[_token] = _decimals;\n\t\treturn true;\n\t}\n\n\tfunction emergencyStop(bool _open) external auth returns (bool) {\n\t\tisOpen = _open;\n\t\treturn true;\n\t}\n\n\tfunction transferOut(address _token, address _receiver, uint256 _amount) external auth returns (bool) {\n\t\tif(supportLending[_token]) {\n\t\t\tif (_token == dai) {\n\t\t\t\tILendFMe(lendFMe).withdraw(chai, _amount);\n\t\t\t\tIChai(chai).draw(address(this), _amount);\n\t\t\t}\n\t\t\telse\n\t\t\t\tILendFMe(lendFMe).withdraw(_token, _amount);\n\t\t}\n\t\tuint256 _balance = NonStandardIERC20Token(_token).balanceOf(address(this));\n\t\tif(_balance >= _amount) {\n\t\t\tNonStandardIERC20Token(_token).transfer(_receiver, _amount);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tfunction transferOutALL(address _token, address _receiver) external auth returns (bool) {\n\t\tif(supportLending[_token]) {\n\t\t\tif (_token == dai) {\n\t\t\t\tILendFMe(lendFMe).withdraw(chai, uint256(-1));\n\t\t\t\tIChai(chai).exit(address(this), IERC20Token(chai).balanceOf(address(this)));\n\t\t\t}\n\t\t\telse\n\t\t\t\tILendFMe(lendFMe).withdraw(_token, uint256(-1));\n\t\t}\n\t\tuint256 _balance = NonStandardIERC20Token(_token).balanceOf(address(this));\n\t\tif(_balance > 0) {\n\t\t\tNonStandardIERC20Token(_token).transfer(_receiver, _balance);\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tfunction transferIn(address _token, uint256 _amount) external auth returns (bool) {\n\t\tNonStandardIERC20Token(_token).transferFrom(msg.sender, address(this), _amount);\n\t\tif(supportLending[_token]) {\n\t\t\tif (_token == dai) {\n\t\t\t\tIChai(chai).join(address(this), NonStandardIERC20Token(dai).balanceOf(address(this)));\n\t\t\t\tILendFMe(lendFMe).supply(chai, IERC20Token(chai).balanceOf(address(this)));\n\t\t\t}\n\t\t\telse\n\t\t\t\tILendFMe(lendFMe).supply(_token, NonStandardIERC20Token(_token).balanceOf(address(this)));\n\t\t}\n\t    return true;\n\t}\n\n\tfunction normalizeToken(address _token, uint256 _amount) internal view returns (uint256) {\n\t\tuint256 n = 18;\n\t\treturn _amount.mul((10 ** (n.sub(decimals[_token]))));\n\t}\n\n\tfunction denormalizedToken(address _token, uint256 _amount) internal view returns (uint256) {\n\t\tuint256 n = 18;\n\t\treturn _amount.div((10 ** (n.sub(decimals[_token]))));\n\t}\n}",
        "function": "transferIn(address,uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/PeckShield-XSwap/xswap-326a3246b327cd2b8481fd8c22fe8d864e43b0da/contracts/XSwap.sol",
        "vulnerability": "External Call To User-Supplied Address (SWC 107)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract XSwap is DSAuth {\n\tusing DSMath for uint256;\n\n\tuint256 constant internal OFFSET = 10 ** 18;\n\t//Mainnet\n\t// address private chai = 0x06AF07097C9Eeb7fD685c692751D5C66dB49c215;\n\t// address private dai  = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n\n\t//Rinkeby\n\taddress private chai = 0x8a5C1BD4D75e168a4f65eB902c289400B90FD980;\n\taddress private dai  = 0xA3A59273494BB5B8F0a8FAcf21B3f666A47d6140;\n\n\tbool private actived;\n\taddress public lendFMe;\n\tbool public isOpen;\n\tmapping(address => mapping(address => uint256)) public prices; // 1 tokenA = ? tokenB\n\tmapping(address => mapping(address => uint256)) public fee;   // fee from tokenA to tokenB\n\tmapping(address => bool) public supportLending;\n\tmapping(address => uint256) public decimals;\n\n\tconstructor() public {\n\t}\n\n\tfunction active(address _lendFMe) public {\n\t\trequire(actived == false, \"already actived.\");\n\t\towner = msg.sender;\n\t\tisOpen = true;\n\t\tlendFMe = _lendFMe;\n\t\tactived = true;\n\t}\n\n\t// trade _inputAmount of _input token to get _output token\n\tfunction trade(address _input, address _output, uint256 _inputAmount) public returns (bool) {\n\t\treturn trade(_input, _output, _inputAmount, msg.sender);\n\t}\n\n\tfunction trade(address _input, address _output, uint256 _inputAmount, address _receiver) public returns (bool) {\n\t\trequire(isOpen, \"not open\");\n\t\trequire(prices[_input][_output] != 0, \"invalid token address\");\n\t\trequire(decimals[_input] != 0, \"input decimal not setteled\");\n\t\trequire(decimals[_output] != 0, \"output decimal not setteled\");\n\n\t\tNonStandardIERC20Token(_input).transferFrom(msg.sender, address(this), _inputAmount);\n\t\tif(supportLending[_input]) {\n\t\t\tif (_input == dai) {\n\t\t\t\tIChai(chai).join(address(this), _inputAmount);\n\t\t\t\tILendFMe(lendFMe).supply(chai, IERC20Token(chai).balanceOf(address(this)));\n\t\t\t}\n\t\t\telse\n\t\t\t\tILendFMe(lendFMe).supply(_input, _inputAmount);\n\t\t}\n\t\tuint256 _tokenAmount = normalizeToken(_input, _inputAmount).mul(prices[_input][_output]).div(OFFSET);\n\t\tuint256 _fee = _tokenAmount.mul(fee[_input][_output]).div(OFFSET);\n\t\tuint256 _amountToUser = _tokenAmount.sub(_fee);\n\n\t\tif(supportLending[_output]) {\n\t\t\tif (_output == dai) {\n\t\t\t\tILendFMe(lendFMe).withdraw(chai, _amountToUser); //assume chai / dai >= 1;\n\t\t\t\tIChai(chai).draw(address(this), _amountToUser);\n\t\t\t}\n\t\t\telse\n\t\t\t\tILendFMe(lendFMe).withdraw(_output, denormalizedToken(_output, _amountToUser));\n\t\t}\n\t\tNonStandardIERC20Token(_output).transfer(_receiver, denormalizedToken(_output, _amountToUser));\n\t\treturn true;\n\t}\n\n\tfunction getTokenLiquidation(address _token) public view returns (uint256) {\n\t\tuint256 balanceInDefi = ILendFMe(lendFMe).getSupplyBalance(address(this), _token);\n\t\treturn balanceInDefi.add(NonStandardIERC20Token(_token).balanceOf(address(this)));\n\t}\n\n\tfunction setLendFMe(address _lendFMe) public auth returns (bool) {\n\t\tlendFMe = _lendFMe;\n\t\treturn true;\n\t}\n\n\tfunction enableLending(address _token) public auth returns (bool) {\n\t\trequire(!supportLending[_token], \"the token is already supported lending\");\n\t\tsupportLending[_token] = true;\n\n\t\tif (_token == dai) {\n\t\t\tIERC20Token(_token).approve(chai, uint256(-1));\n\t\t\tIERC20Token(chai).approve(lendFMe, uint256(-1));\n\t\t}\n\t\telse {\n\t\t\tNonStandardIERC20Token(_token).approve(lendFMe, uint256(-1));\n\t\t}\n\n\t\tuint256 _balance = NonStandardIERC20Token(_token).balanceOf(address(this));\n\t\tif(_balance > 0) {\n\t\t\tif (_token == dai) {\n\t\t\t\tIChai(chai).join(address(this), _balance);\n\t\t\t\tILendFMe(lendFMe).supply(chai, IERC20Token(chai).balanceOf(address(this)));\n\t\t\t}\n\t\t\telse\n\t\t\t\tILendFMe(lendFMe).supply(_token, _balance);\n\t\t}\n\t\treturn true;\n\t}\n\n\tfunction disableLending(address _token) public auth returns (bool) {\n\t\trequire(supportLending[_token], \"the token doesnt support lending\");\n\t\tsupportLending[_token] = false;\n\n\t\tif (_token == dai) {\n\t\t\tILendFMe(lendFMe).withdraw(chai, uint256(-1));\n\t\t\tIChai(chai).exit(address(this), IERC20Token(chai).balanceOf(address(this)));\n\t\t}\n\t\telse\n\t\t\tILendFMe(lendFMe).withdraw(_token, uint256(-1));\n\n\t\treturn true;\n\t}\n\n\t// create new pairs\n\tfunction createPair(address _input, address _output, uint256 _priceInOut, uint256 _priceOutIn, uint256 _fee) external auth returns (bool) {\n\t\tsetPrices(_input, _output, _priceInOut, _priceOutIn);\n\t\tsetFee(_input, _output, _fee);\n\t\treturn true;\n\t}\n\n\tfunction setPrices(address _input, address _output, uint256 _priceInOut, uint256 _priceOutIn) public auth returns (bool) {\n\t\tsetPrices(_input, _output, _priceInOut);\n\t\tsetPrices(_output, _input, _priceOutIn);\n\t\treturn true;\n\t}\n\t//SWC-101-Integer Overflow and Underflow: L152\n\tfunction setPrices(address _input, address _output, uint256 _price) public auth returns (bool) {\n\t\tprices[_input][_output] = _price;\n\t\treturn true;\n\t}\n\n\tfunction setFee(address _input, address _output, uint256 _fee) public auth returns (bool) {\n\t\tfee[_input][_output] = _fee;\n\t\tfee[_output][_input] = _fee;\n\t\treturn true;\n\t}\n\n\tfunction setTokenDecimals(address _token, uint256 _decimals) public auth returns (bool){\n\t\trequire(_decimals <= 18, \"not supported decimal\");\n\t\tdecimals[_token] = _decimals;\n\t\treturn true;\n\t}\n\n\tfunction emergencyStop(bool _open) external auth returns (bool) {\n\t\tisOpen = _open;\n\t\treturn true;\n\t}\n\n\tfunction transferOut(address _token, address _receiver, uint256 _amount) external auth returns (bool) {\n\t\tif(supportLending[_token]) {\n\t\t\tif (_token == dai) {\n\t\t\t\tILendFMe(lendFMe).withdraw(chai, _amount);\n\t\t\t\tIChai(chai).draw(address(this), _amount);\n\t\t\t}\n\t\t\telse\n\t\t\t\tILendFMe(lendFMe).withdraw(_token, _amount);\n\t\t}\n\t\tuint256 _balance = NonStandardIERC20Token(_token).balanceOf(address(this));\n\t\tif(_balance >= _amount) {\n\t\t\tNonStandardIERC20Token(_token).transfer(_receiver, _amount);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tfunction transferOutALL(address _token, address _receiver) external auth returns (bool) {\n\t\tif(supportLending[_token]) {\n\t\t\tif (_token == dai) {\n\t\t\t\tILendFMe(lendFMe).withdraw(chai, uint256(-1));\n\t\t\t\tIChai(chai).exit(address(this), IERC20Token(chai).balanceOf(address(this)));\n\t\t\t}\n\t\t\telse\n\t\t\t\tILendFMe(lendFMe).withdraw(_token, uint256(-1));\n\t\t}\n\t\tuint256 _balance = NonStandardIERC20Token(_token).balanceOf(address(this));\n\t\tif(_balance > 0) {\n\t\t\tNonStandardIERC20Token(_token).transfer(_receiver, _balance);\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tfunction transferIn(address _token, uint256 _amount) external auth returns (bool) {\n\t\tNonStandardIERC20Token(_token).transferFrom(msg.sender, address(this), _amount);\n\t\tif(supportLending[_token]) {\n\t\t\tif (_token == dai) {\n\t\t\t\tIChai(chai).join(address(this), NonStandardIERC20Token(dai).balanceOf(address(this)));\n\t\t\t\tILendFMe(lendFMe).supply(chai, IERC20Token(chai).balanceOf(address(this)));\n\t\t\t}\n\t\t\telse\n\t\t\t\tILendFMe(lendFMe).supply(_token, NonStandardIERC20Token(_token).balanceOf(address(this)));\n\t\t}\n\t    return true;\n\t}\n\n\tfunction normalizeToken(address _token, uint256 _amount) internal view returns (uint256) {\n\t\tuint256 n = 18;\n\t\treturn _amount.mul((10 ** (n.sub(decimals[_token]))));\n\t}\n\n\tfunction denormalizedToken(address _token, uint256 _amount) internal view returns (uint256) {\n\t\tuint256 n = 18;\n\t\treturn _amount.div((10 ** (n.sub(decimals[_token]))));\n\t}\n}",
        "function": "transferIn(address,uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/PeckShield-XSwap/xswap-326a3246b327cd2b8481fd8c22fe8d864e43b0da/contracts/XSwap.sol",
        "vulnerability": "State access after external call (SWC 107)",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract KOK_Contract is ERC20Interface, Owned {\n\tstring public constant symbol = \"KOK\";\n\tstring public constant name = \"KOK Coin\";\n\tuint8 public constant decimals = 18;\n\tuint256 public constant totalSupply = 5000000000000000000000000000;\n\n\tbool public stopped;\n\n\tmapping (address => int8) public blackList;\n\n\tmapping (address => uint256) public balances;\n\tmapping (address => mapping (address => uint256)) public allowed;\n\n\n    event Blacklisted(address indexed target);\n    event DeleteFromBlacklist(address indexed target);\n    event RejectedPaymentToBlacklistedAddr(address indexed from, address indexed to, uint256 value);\n    event RejectedPaymentFromBlacklistedAddr(address indexed from, address indexed to, uint256 value);\n\n\n\tmodifier notStopped {\n        require(!stopped);\n        _;\n    }\n\n// constructor\n// SWC-118-Incorrect Constructor Name: L63\n\tfunction KOKContract() public {\n\t\tbalances[msg.sender] = totalSupply;\n\t}\n\t\n// function made for airdrop\n\tfunction airdrop(address[] _to, uint256[] _value) onlyOwner notStopped public {\n\t    for(uint256 i = 0; i < _to.length; i++){\n\t        if(balances[_to[i]] > 0){\n\t            continue;\n\t        }\n\t        transfer(_to[i], _value[i]);\n\t    }\n\t}\n\n// blacklist management\n    function blacklisting(address _addr) onlyOwner public {\n        blackList[_addr] = 1;\n        emit Blacklisted(_addr);\n    }\n    function deleteFromBlacklist(address _addr) onlyOwner public {\n        blackList[_addr] = -1;\n        emit DeleteFromBlacklist(_addr);\n    }\n\n// stop the contract\n// SWC-100-Function Default Visibility: L88\n\tfunction stop() onlyOwner {\n        stopped = true;\n    }\n// SWC-100-Function Default Visibility: L92\n    function start() onlyOwner {\n        stopped = false;\n    }\n\t\n// ERC20 functions\n\tfunction balanceOf(address _owner) public constant returns (uint256 balance){\n\t\treturn balances[_owner];\n\t}\n\tfunction transfer(address _to, uint256 _value) notStopped public returns (bool success){\n\t\trequire(balances[msg.sender] >= _value);\n\n\t\tif(blackList[msg.sender] > 0){\n\t\t\temit RejectedPaymentFromBlacklistedAddr(msg.sender, _to, _value);\n\t\t\treturn false;\n\t\t}\n\t\tif(blackList[_to] > 0){\n\t\t\temit RejectedPaymentToBlacklistedAddr(msg.sender, _to, _value);\n\t\t\treturn false;\n\t\t}\n\n\t\tbalances[msg.sender] -= _value;\n\t\tbalances[_to] += _value;\n\t\temit Transfer(msg.sender, _to, _value);\n\t\treturn true;\n\t}\n\tfunction transferFrom(address _from, address _to, uint256 _value) notStopped public returns (bool success){\n\t\trequire(balances[_from] >= _value\n\t\t\t&& allowed[_from][msg.sender] >= _value);\n\n\t\tif(blackList[_from] > 0){\n\t\t\temit RejectedPaymentFromBlacklistedAddr(_from, _to, _value);\n\t\t\treturn false;\n\t\t}\n\t\tif(blackList[_to] > 0){\n\t\t\temit RejectedPaymentToBlacklistedAddr(_from, _to, _value);\n\t\t\treturn false;\n\t\t}\n\n\t\tbalances[_from] -= _value;\n\t\tallowed[_from][msg.sender] -= _value;\n\t\tbalances[_to] += _value;\n\t\temit Transfer(_from, _to, _value);\n\t\treturn true;\n\t}\n\tfunction approve(address _spender, uint256 _value) notStopped public returns (bool success){\n\t\tallowed[msg.sender][_spender] = _value;\n\t\temit Approval(msg.sender, _spender, _value);\n\t\treturn true;\n\t}\n\tfunction allowance(address _owner, address _spender) public constant returns (uint256 remaining){\n\t\treturn allowed[_owner][_spender];\n\t}\n}",
        "function": "airdrop(address[],uint256[])",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Iosiro-KOK Token Smart Contract Audit/ERC-20-55a501fde12e782b99fe9d5756388c0de82f45ba/contract.sol",
        "vulnerability": "Integer Arithmetic Bugs (SWC 101)",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract KOK_Contract is ERC20Interface, Owned {\n\tstring public constant symbol = \"KOK\";\n\tstring public constant name = \"KOK Coin\";\n\tuint8 public constant decimals = 18;\n\tuint256 public constant totalSupply = 5000000000000000000000000000;\n\n\tbool public stopped;\n\n\tmapping (address => int8) public blackList;\n\n\tmapping (address => uint256) public balances;\n\tmapping (address => mapping (address => uint256)) public allowed;\n\n\n    event Blacklisted(address indexed target);\n    event DeleteFromBlacklist(address indexed target);\n    event RejectedPaymentToBlacklistedAddr(address indexed from, address indexed to, uint256 value);\n    event RejectedPaymentFromBlacklistedAddr(address indexed from, address indexed to, uint256 value);\n\n\n\tmodifier notStopped {\n        require(!stopped);\n        _;\n    }\n\n// constructor\n// SWC-118-Incorrect Constructor Name: L63\n\tfunction KOKContract() public {\n\t\tbalances[msg.sender] = totalSupply;\n\t}\n\t\n// function made for airdrop\n\tfunction airdrop(address[] _to, uint256[] _value) onlyOwner notStopped public {\n\t    for(uint256 i = 0; i < _to.length; i++){\n\t        if(balances[_to[i]] > 0){\n\t            continue;\n\t        }\n\t        transfer(_to[i], _value[i]);\n\t    }\n\t}\n\n// blacklist management\n    function blacklisting(address _addr) onlyOwner public {\n        blackList[_addr] = 1;\n        emit Blacklisted(_addr);\n    }\n    function deleteFromBlacklist(address _addr) onlyOwner public {\n        blackList[_addr] = -1;\n        emit DeleteFromBlacklist(_addr);\n    }\n\n// stop the contract\n// SWC-100-Function Default Visibility: L88\n\tfunction stop() onlyOwner {\n        stopped = true;\n    }\n// SWC-100-Function Default Visibility: L92\n    function start() onlyOwner {\n        stopped = false;\n    }\n\t\n// ERC20 functions\n\tfunction balanceOf(address _owner) public constant returns (uint256 balance){\n\t\treturn balances[_owner];\n\t}\n\tfunction transfer(address _to, uint256 _value) notStopped public returns (bool success){\n\t\trequire(balances[msg.sender] >= _value);\n\n\t\tif(blackList[msg.sender] > 0){\n\t\t\temit RejectedPaymentFromBlacklistedAddr(msg.sender, _to, _value);\n\t\t\treturn false;\n\t\t}\n\t\tif(blackList[_to] > 0){\n\t\t\temit RejectedPaymentToBlacklistedAddr(msg.sender, _to, _value);\n\t\t\treturn false;\n\t\t}\n\n\t\tbalances[msg.sender] -= _value;\n\t\tbalances[_to] += _value;\n\t\temit Transfer(msg.sender, _to, _value);\n\t\treturn true;\n\t}\n\tfunction transferFrom(address _from, address _to, uint256 _value) notStopped public returns (bool success){\n\t\trequire(balances[_from] >= _value\n\t\t\t&& allowed[_from][msg.sender] >= _value);\n\n\t\tif(blackList[_from] > 0){\n\t\t\temit RejectedPaymentFromBlacklistedAddr(_from, _to, _value);\n\t\t\treturn false;\n\t\t}\n\t\tif(blackList[_to] > 0){\n\t\t\temit RejectedPaymentToBlacklistedAddr(_from, _to, _value);\n\t\t\treturn false;\n\t\t}\n\n\t\tbalances[_from] -= _value;\n\t\tallowed[_from][msg.sender] -= _value;\n\t\tbalances[_to] += _value;\n\t\temit Transfer(_from, _to, _value);\n\t\treturn true;\n\t}\n\tfunction approve(address _spender, uint256 _value) notStopped public returns (bool success){\n\t\tallowed[msg.sender][_spender] = _value;\n\t\temit Approval(msg.sender, _spender, _value);\n\t\treturn true;\n\t}\n\tfunction allowance(address _owner, address _spender) public constant returns (uint256 remaining){\n\t\treturn allowed[_owner][_spender];\n\t}\n}",
        "function": "airdrop(address[],uint256[])",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Iosiro-KOK Token Smart Contract Audit/ERC-20-55a501fde12e782b99fe9d5756388c0de82f45ba/contract.sol",
        "vulnerability": "Exception State (SWC 110)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract RocketStorage is RocketStorageInterface {\n\n    // Events\n    event NodeWithdrawalAddressSet(address indexed node, address indexed withdrawalAddress, uint256 time);\n    event GuardianChanged(address oldGuardian, address newGuardian);\n\n    // Libraries\n    using SafeMath for uint256;\n\n    // Complex storage maps\n    mapping(bytes32 => string)     private stringStorage;\n    mapping(bytes32 => bytes)      private bytesStorage;\n\n    // Protected storage (not accessible by network contracts)\n    mapping(address => address)    private withdrawalAddresses;\n    mapping(address => address)    private pendingWithdrawalAddresses;\n\n    // Guardian address\n    address guardian;\n    address newGuardian;\n\n    // Flag storage has been initialised\n    bool storageInit = false;\n\n    \n    modifier onlyLatestRocketNetworkContract() {\n        if (storageInit == true) {\n            // Make sure the access is permitted to only contracts in our Dapp\n            require(_getBool(keccak256(abi.encodePacked(\"contract.exists\", msg.sender))), \"Invalid or outdated network contract\");\n        } else {\n            // Only Dapp and the guardian account are allowed access during initialisation.\n            // tx.origin is only safe to use in this case for deployment since no external contracts are interacted with\n            // SWC-115-Authorization through tx.origin: L45\n            require((\n                _getBool(keccak256(abi.encodePacked(\"contract.exists\", msg.sender))) || tx.origin == guardian\n            ), \"Invalid or outdated network contract attempting access during deployment\");\n        }\n        _;\n    }\n\n\n    \n    constructor() {\n        // Set the guardian upon deployment\n        guardian = msg.sender;\n    }\n\n    // Get guardian address\n    function getGuardian() external override view returns (address) {\n        return guardian;\n    }\n\n    // Transfers guardianship to a new address\n    function setGuardian(address _newAddress) external override {\n        // Check tx comes from current guardian\n        require(msg.sender == guardian, \"Is not guardian account\");\n        // Store new address awaiting confirmation\n        newGuardian = _newAddress;\n    }\n\n    // Confirms change of guardian\n    function confirmGuardian() external override {\n        // Check tx came from new guardian address\n        require(msg.sender == newGuardian, \"Confirmation must come from new guardian address\");\n        // Store old guardian for event\n        address oldGuardian = guardian;\n        // Update guardian and clear storage\n        guardian = newGuardian;\n        delete newGuardian;\n        // Emit event\n        emit GuardianChanged(oldGuardian, guardian);\n    }\n\n    // Set this as being deployed now\n    function getDeployedStatus() external view returns (bool) {\n        return storageInit;\n    }\n\n    // Set this as being deployed now\n    function setDeployedStatus() external {\n        // Only guardian can lock this down\n        require(msg.sender == guardian, \"Is not guardian account\");\n        // Set it now\n        storageInit = true;\n    }\n\n    // Protected storage\n\n    // Get a node's withdrawal address\n    function getNodeWithdrawalAddress(address _nodeAddress) public override view returns (address) {\n        // Check if _nodeAddress is a valid node\n        if (!_getBool(keccak256(abi.encodePacked(\"node.exists\", _nodeAddress)))) {\n            return address(0);\n        }\n        // If no withdrawal address has been set, return the nodes address\n        address withdrawalAddress = withdrawalAddresses[_nodeAddress];\n        if (withdrawalAddress == address(0)) {\n            return _nodeAddress;\n        }\n        return withdrawalAddress;\n    }\n\n    // Get a node's pending withdrawal address\n    function getNodePendingWithdrawalAddress(address _nodeAddress) external override view returns (address) {\n        return pendingWithdrawalAddresses[_nodeAddress];\n    }\n\n    // Set a node's withdrawal address\n    function setWithdrawalAddress(address _nodeAddress, address _newWithdrawalAddress, bool _confirm) external override {\n        // Check new withdrawal address\n        require(_newWithdrawalAddress != address(0x0), \"Invalid withdrawal address\");\n        // Confirm the transaction is from the node's current withdrawal address\n        address withdrawalAddress = getNodeWithdrawalAddress(_nodeAddress);\n        require(withdrawalAddress == msg.sender, \"Only a tx from a node's withdrawal address can update it\");\n        // Update immediately if confirmed\n        if (_confirm) {\n            updateWithdrawalAddress(_nodeAddress, _newWithdrawalAddress);\n        }\n        // Set pending withdrawal address if not confirmed\n        else {\n            pendingWithdrawalAddresses[_nodeAddress] = _newWithdrawalAddress;\n        }\n    }\n\n    // Confirm a node's new withdrawal address\n    function confirmWithdrawalAddress(address _nodeAddress) external override {\n        // Get node by pending withdrawal address\n        require(pendingWithdrawalAddresses[_nodeAddress] == msg.sender, \"Confirmation must come from the pending withdrawal address\");\n        delete pendingWithdrawalAddresses[_nodeAddress];\n        // Update withdrawal address\n        updateWithdrawalAddress(_nodeAddress, msg.sender);\n    }\n\n    // Update a node's withdrawal address\n    function updateWithdrawalAddress(address _nodeAddress, address _newWithdrawalAddress) private {\n        // Set new withdrawal address\n        withdrawalAddresses[_nodeAddress] = _newWithdrawalAddress;\n        // Emit withdrawal address set event\n        emit NodeWithdrawalAddressSet(_nodeAddress, _newWithdrawalAddress, block.timestamp);\n    }\n\n    \n    function getAddress(bytes32 _key) override external view returns (address r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n    \n    function getUint(bytes32 _key) override external view returns (uint256 r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n    \n    function getString(bytes32 _key) override external view returns (string memory) {\n        return stringStorage[_key];\n    }\n\n    \n    function getBytes(bytes32 _key) override external view returns (bytes memory) {\n        return bytesStorage[_key];\n    }\n\n    \n    function getBool(bytes32 _key) override external view returns (bool r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n    \n    function getInt(bytes32 _key) override external view returns (int r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n    \n    function getBytes32(bytes32 _key) override external view returns (bytes32 r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n\n    \n    function setAddress(bytes32 _key, address _value) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n\n    \n    // SWC-124-Write to Arbitrary Storage Location: L206 - L210\n    function setUint(bytes32 _key, uint _value) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n\n    \n    function setString(bytes32 _key, string calldata _value) onlyLatestRocketNetworkContract override external {\n        stringStorage[_key] = _value;\n    }\n\n    \n    function setBytes(bytes32 _key, bytes calldata _value) onlyLatestRocketNetworkContract override external {\n        bytesStorage[_key] = _value;\n    }\n\n    \n    function setBool(bytes32 _key, bool _value) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n\n    \n    // SWC-124-Write to Arbitrary Storage Location: L231 - L235\n    function setInt(bytes32 _key, int _value) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n\n    \n    function setBytes32(bytes32 _key, bytes32 _value) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n\n\n    \n    function deleteAddress(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, 0)\n        }\n    }\n\n    \n    function deleteUint(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, 0)\n        }\n    }\n\n    \n    function deleteString(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        delete stringStorage[_key];\n    }\n\n    \n    function deleteBytes(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        delete bytesStorage[_key];\n    }\n\n    \n    function deleteBool(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, 0)\n        }\n    }\n\n    \n    function deleteInt(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, 0)\n        }\n    }\n\n    \n    function deleteBytes32(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, 0)\n        }\n    }\n\n\n    \n    \n    function addUint(bytes32 _key, uint256 _amount) onlyLatestRocketNetworkContract override external {\n        uint256 a;\n        uint256 b;\n        assembly {\n            a := sload (_key)\n            b := add(a, _amount)\n            sstore (_key, b)\n        }\n        require(b >= a, \"SafeMath: addition overflow\");\n    }\n\n    \n    \n    function subUint(bytes32 _key, uint256 _amount) onlyLatestRocketNetworkContract override external {\n        uint256 a;\n        assembly {\n            a := sload (_key)\n        }\n        require(_amount <= a, \"SafeMath: subtraction overflow\");\n        assembly {\n            a := sub(a, _amount)\n            sstore (_key, a)\n        }\n    }\n\n    // Private methods\n\n    function _getBool(bytes32 _key) private view returns (bool r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n    function _setBool(bytes32 _key, bool _value) private {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n}",
        "function": "deleteBytes32(bytes32)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-RocketPool/rocketpool-a65b203cf99c7a991c2d85a7468a97bfb5dbba31/contracts/contract/RocketStorage.sol",
        "vulnerability": "Dependence on tx.origin (SWC 115)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract RocketStorage is RocketStorageInterface {\n\n    // Events\n    event NodeWithdrawalAddressSet(address indexed node, address indexed withdrawalAddress, uint256 time);\n    event GuardianChanged(address oldGuardian, address newGuardian);\n\n    // Libraries\n    using SafeMath for uint256;\n\n    // Complex storage maps\n    mapping(bytes32 => string)     private stringStorage;\n    mapping(bytes32 => bytes)      private bytesStorage;\n\n    // Protected storage (not accessible by network contracts)\n    mapping(address => address)    private withdrawalAddresses;\n    mapping(address => address)    private pendingWithdrawalAddresses;\n\n    // Guardian address\n    address guardian;\n    address newGuardian;\n\n    // Flag storage has been initialised\n    bool storageInit = false;\n\n    \n    modifier onlyLatestRocketNetworkContract() {\n        if (storageInit == true) {\n            // Make sure the access is permitted to only contracts in our Dapp\n            require(_getBool(keccak256(abi.encodePacked(\"contract.exists\", msg.sender))), \"Invalid or outdated network contract\");\n        } else {\n            // Only Dapp and the guardian account are allowed access during initialisation.\n            // tx.origin is only safe to use in this case for deployment since no external contracts are interacted with\n            // SWC-115-Authorization through tx.origin: L45\n            require((\n                _getBool(keccak256(abi.encodePacked(\"contract.exists\", msg.sender))) || tx.origin == guardian\n            ), \"Invalid or outdated network contract attempting access during deployment\");\n        }\n        _;\n    }\n\n\n    \n    constructor() {\n        // Set the guardian upon deployment\n        guardian = msg.sender;\n    }\n\n    // Get guardian address\n    function getGuardian() external override view returns (address) {\n        return guardian;\n    }\n\n    // Transfers guardianship to a new address\n    function setGuardian(address _newAddress) external override {\n        // Check tx comes from current guardian\n        require(msg.sender == guardian, \"Is not guardian account\");\n        // Store new address awaiting confirmation\n        newGuardian = _newAddress;\n    }\n\n    // Confirms change of guardian\n    function confirmGuardian() external override {\n        // Check tx came from new guardian address\n        require(msg.sender == newGuardian, \"Confirmation must come from new guardian address\");\n        // Store old guardian for event\n        address oldGuardian = guardian;\n        // Update guardian and clear storage\n        guardian = newGuardian;\n        delete newGuardian;\n        // Emit event\n        emit GuardianChanged(oldGuardian, guardian);\n    }\n\n    // Set this as being deployed now\n    function getDeployedStatus() external view returns (bool) {\n        return storageInit;\n    }\n\n    // Set this as being deployed now\n    function setDeployedStatus() external {\n        // Only guardian can lock this down\n        require(msg.sender == guardian, \"Is not guardian account\");\n        // Set it now\n        storageInit = true;\n    }\n\n    // Protected storage\n\n    // Get a node's withdrawal address\n    function getNodeWithdrawalAddress(address _nodeAddress) public override view returns (address) {\n        // Check if _nodeAddress is a valid node\n        if (!_getBool(keccak256(abi.encodePacked(\"node.exists\", _nodeAddress)))) {\n            return address(0);\n        }\n        // If no withdrawal address has been set, return the nodes address\n        address withdrawalAddress = withdrawalAddresses[_nodeAddress];\n        if (withdrawalAddress == address(0)) {\n            return _nodeAddress;\n        }\n        return withdrawalAddress;\n    }\n\n    // Get a node's pending withdrawal address\n    function getNodePendingWithdrawalAddress(address _nodeAddress) external override view returns (address) {\n        return pendingWithdrawalAddresses[_nodeAddress];\n    }\n\n    // Set a node's withdrawal address\n    function setWithdrawalAddress(address _nodeAddress, address _newWithdrawalAddress, bool _confirm) external override {\n        // Check new withdrawal address\n        require(_newWithdrawalAddress != address(0x0), \"Invalid withdrawal address\");\n        // Confirm the transaction is from the node's current withdrawal address\n        address withdrawalAddress = getNodeWithdrawalAddress(_nodeAddress);\n        require(withdrawalAddress == msg.sender, \"Only a tx from a node's withdrawal address can update it\");\n        // Update immediately if confirmed\n        if (_confirm) {\n            updateWithdrawalAddress(_nodeAddress, _newWithdrawalAddress);\n        }\n        // Set pending withdrawal address if not confirmed\n        else {\n            pendingWithdrawalAddresses[_nodeAddress] = _newWithdrawalAddress;\n        }\n    }\n\n    // Confirm a node's new withdrawal address\n    function confirmWithdrawalAddress(address _nodeAddress) external override {\n        // Get node by pending withdrawal address\n        require(pendingWithdrawalAddresses[_nodeAddress] == msg.sender, \"Confirmation must come from the pending withdrawal address\");\n        delete pendingWithdrawalAddresses[_nodeAddress];\n        // Update withdrawal address\n        updateWithdrawalAddress(_nodeAddress, msg.sender);\n    }\n\n    // Update a node's withdrawal address\n    function updateWithdrawalAddress(address _nodeAddress, address _newWithdrawalAddress) private {\n        // Set new withdrawal address\n        withdrawalAddresses[_nodeAddress] = _newWithdrawalAddress;\n        // Emit withdrawal address set event\n        emit NodeWithdrawalAddressSet(_nodeAddress, _newWithdrawalAddress, block.timestamp);\n    }\n\n    \n    function getAddress(bytes32 _key) override external view returns (address r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n    \n    function getUint(bytes32 _key) override external view returns (uint256 r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n    \n    function getString(bytes32 _key) override external view returns (string memory) {\n        return stringStorage[_key];\n    }\n\n    \n    function getBytes(bytes32 _key) override external view returns (bytes memory) {\n        return bytesStorage[_key];\n    }\n\n    \n    function getBool(bytes32 _key) override external view returns (bool r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n    \n    function getInt(bytes32 _key) override external view returns (int r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n    \n    function getBytes32(bytes32 _key) override external view returns (bytes32 r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n\n    \n    function setAddress(bytes32 _key, address _value) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n\n    \n    // SWC-124-Write to Arbitrary Storage Location: L206 - L210\n    function setUint(bytes32 _key, uint _value) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n\n    \n    function setString(bytes32 _key, string calldata _value) onlyLatestRocketNetworkContract override external {\n        stringStorage[_key] = _value;\n    }\n\n    \n    function setBytes(bytes32 _key, bytes calldata _value) onlyLatestRocketNetworkContract override external {\n        bytesStorage[_key] = _value;\n    }\n\n    \n    function setBool(bytes32 _key, bool _value) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n\n    \n    // SWC-124-Write to Arbitrary Storage Location: L231 - L235\n    function setInt(bytes32 _key, int _value) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n\n    \n    function setBytes32(bytes32 _key, bytes32 _value) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n\n\n    \n    function deleteAddress(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, 0)\n        }\n    }\n\n    \n    function deleteUint(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, 0)\n        }\n    }\n\n    \n    function deleteString(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        delete stringStorage[_key];\n    }\n\n    \n    function deleteBytes(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        delete bytesStorage[_key];\n    }\n\n    \n    function deleteBool(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, 0)\n        }\n    }\n\n    \n    function deleteInt(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, 0)\n        }\n    }\n\n    \n    function deleteBytes32(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, 0)\n        }\n    }\n\n\n    \n    \n    function addUint(bytes32 _key, uint256 _amount) onlyLatestRocketNetworkContract override external {\n        uint256 a;\n        uint256 b;\n        assembly {\n            a := sload (_key)\n            b := add(a, _amount)\n            sstore (_key, b)\n        }\n        require(b >= a, \"SafeMath: addition overflow\");\n    }\n\n    \n    \n    function subUint(bytes32 _key, uint256 _amount) onlyLatestRocketNetworkContract override external {\n        uint256 a;\n        assembly {\n            a := sload (_key)\n        }\n        require(_amount <= a, \"SafeMath: subtraction overflow\");\n        assembly {\n            a := sub(a, _amount)\n            sstore (_key, a)\n        }\n    }\n\n    // Private methods\n\n    function _getBool(bytes32 _key) private view returns (bool r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n    function _setBool(bytes32 _key, bool _value) private {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n}",
        "function": "deleteBytes32(bytes32)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-RocketPool/rocketpool-a65b203cf99c7a991c2d85a7468a97bfb5dbba31/contracts/contract/RocketStorage.sol",
        "vulnerability": "Write to an arbitrary storage location (SWC 124)",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract RocketStorage is RocketStorageInterface {\n\n    // Events\n    event NodeWithdrawalAddressSet(address indexed node, address indexed withdrawalAddress, uint256 time);\n    event GuardianChanged(address oldGuardian, address newGuardian);\n\n    // Libraries\n    using SafeMath for uint256;\n\n    // Complex storage maps\n    mapping(bytes32 => string)     private stringStorage;\n    mapping(bytes32 => bytes)      private bytesStorage;\n\n    // Protected storage (not accessible by network contracts)\n    mapping(address => address)    private withdrawalAddresses;\n    mapping(address => address)    private pendingWithdrawalAddresses;\n\n    // Guardian address\n    address guardian;\n    address newGuardian;\n\n    // Flag storage has been initialised\n    bool storageInit = false;\n\n    \n    modifier onlyLatestRocketNetworkContract() {\n        if (storageInit == true) {\n            // Make sure the access is permitted to only contracts in our Dapp\n            require(_getBool(keccak256(abi.encodePacked(\"contract.exists\", msg.sender))), \"Invalid or outdated network contract\");\n        } else {\n            // Only Dapp and the guardian account are allowed access during initialisation.\n            // tx.origin is only safe to use in this case for deployment since no external contracts are interacted with\n            // SWC-115-Authorization through tx.origin: L45\n            require((\n                _getBool(keccak256(abi.encodePacked(\"contract.exists\", msg.sender))) || tx.origin == guardian\n            ), \"Invalid or outdated network contract attempting access during deployment\");\n        }\n        _;\n    }\n\n\n    \n    constructor() {\n        // Set the guardian upon deployment\n        guardian = msg.sender;\n    }\n\n    // Get guardian address\n    function getGuardian() external override view returns (address) {\n        return guardian;\n    }\n\n    // Transfers guardianship to a new address\n    function setGuardian(address _newAddress) external override {\n        // Check tx comes from current guardian\n        require(msg.sender == guardian, \"Is not guardian account\");\n        // Store new address awaiting confirmation\n        newGuardian = _newAddress;\n    }\n\n    // Confirms change of guardian\n    function confirmGuardian() external override {\n        // Check tx came from new guardian address\n        require(msg.sender == newGuardian, \"Confirmation must come from new guardian address\");\n        // Store old guardian for event\n        address oldGuardian = guardian;\n        // Update guardian and clear storage\n        guardian = newGuardian;\n        delete newGuardian;\n        // Emit event\n        emit GuardianChanged(oldGuardian, guardian);\n    }\n\n    // Set this as being deployed now\n    function getDeployedStatus() external view returns (bool) {\n        return storageInit;\n    }\n\n    // Set this as being deployed now\n    function setDeployedStatus() external {\n        // Only guardian can lock this down\n        require(msg.sender == guardian, \"Is not guardian account\");\n        // Set it now\n        storageInit = true;\n    }\n\n    // Protected storage\n\n    // Get a node's withdrawal address\n    function getNodeWithdrawalAddress(address _nodeAddress) public override view returns (address) {\n        // Check if _nodeAddress is a valid node\n        if (!_getBool(keccak256(abi.encodePacked(\"node.exists\", _nodeAddress)))) {\n            return address(0);\n        }\n        // If no withdrawal address has been set, return the nodes address\n        address withdrawalAddress = withdrawalAddresses[_nodeAddress];\n        if (withdrawalAddress == address(0)) {\n            return _nodeAddress;\n        }\n        return withdrawalAddress;\n    }\n\n    // Get a node's pending withdrawal address\n    function getNodePendingWithdrawalAddress(address _nodeAddress) external override view returns (address) {\n        return pendingWithdrawalAddresses[_nodeAddress];\n    }\n\n    // Set a node's withdrawal address\n    function setWithdrawalAddress(address _nodeAddress, address _newWithdrawalAddress, bool _confirm) external override {\n        // Check new withdrawal address\n        require(_newWithdrawalAddress != address(0x0), \"Invalid withdrawal address\");\n        // Confirm the transaction is from the node's current withdrawal address\n        address withdrawalAddress = getNodeWithdrawalAddress(_nodeAddress);\n        require(withdrawalAddress == msg.sender, \"Only a tx from a node's withdrawal address can update it\");\n        // Update immediately if confirmed\n        if (_confirm) {\n            updateWithdrawalAddress(_nodeAddress, _newWithdrawalAddress);\n        }\n        // Set pending withdrawal address if not confirmed\n        else {\n            pendingWithdrawalAddresses[_nodeAddress] = _newWithdrawalAddress;\n        }\n    }\n\n    // Confirm a node's new withdrawal address\n    function confirmWithdrawalAddress(address _nodeAddress) external override {\n        // Get node by pending withdrawal address\n        require(pendingWithdrawalAddresses[_nodeAddress] == msg.sender, \"Confirmation must come from the pending withdrawal address\");\n        delete pendingWithdrawalAddresses[_nodeAddress];\n        // Update withdrawal address\n        updateWithdrawalAddress(_nodeAddress, msg.sender);\n    }\n\n    // Update a node's withdrawal address\n    function updateWithdrawalAddress(address _nodeAddress, address _newWithdrawalAddress) private {\n        // Set new withdrawal address\n        withdrawalAddresses[_nodeAddress] = _newWithdrawalAddress;\n        // Emit withdrawal address set event\n        emit NodeWithdrawalAddressSet(_nodeAddress, _newWithdrawalAddress, block.timestamp);\n    }\n\n    \n    function getAddress(bytes32 _key) override external view returns (address r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n    \n    function getUint(bytes32 _key) override external view returns (uint256 r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n    \n    function getString(bytes32 _key) override external view returns (string memory) {\n        return stringStorage[_key];\n    }\n\n    \n    function getBytes(bytes32 _key) override external view returns (bytes memory) {\n        return bytesStorage[_key];\n    }\n\n    \n    function getBool(bytes32 _key) override external view returns (bool r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n    \n    function getInt(bytes32 _key) override external view returns (int r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n    \n    function getBytes32(bytes32 _key) override external view returns (bytes32 r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n\n    \n    function setAddress(bytes32 _key, address _value) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n\n    \n    // SWC-124-Write to Arbitrary Storage Location: L206 - L210\n    function setUint(bytes32 _key, uint _value) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n\n    \n    function setString(bytes32 _key, string calldata _value) onlyLatestRocketNetworkContract override external {\n        stringStorage[_key] = _value;\n    }\n\n    \n    function setBytes(bytes32 _key, bytes calldata _value) onlyLatestRocketNetworkContract override external {\n        bytesStorage[_key] = _value;\n    }\n\n    \n    function setBool(bytes32 _key, bool _value) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n\n    \n    // SWC-124-Write to Arbitrary Storage Location: L231 - L235\n    function setInt(bytes32 _key, int _value) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n\n    \n    function setBytes32(bytes32 _key, bytes32 _value) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n\n\n    \n    function deleteAddress(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, 0)\n        }\n    }\n\n    \n    function deleteUint(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, 0)\n        }\n    }\n\n    \n    function deleteString(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        delete stringStorage[_key];\n    }\n\n    \n    function deleteBytes(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        delete bytesStorage[_key];\n    }\n\n    \n    function deleteBool(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, 0)\n        }\n    }\n\n    \n    function deleteInt(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, 0)\n        }\n    }\n\n    \n    function deleteBytes32(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, 0)\n        }\n    }\n\n\n    \n    \n    function addUint(bytes32 _key, uint256 _amount) onlyLatestRocketNetworkContract override external {\n        uint256 a;\n        uint256 b;\n        assembly {\n            a := sload (_key)\n            b := add(a, _amount)\n            sstore (_key, b)\n        }\n        require(b >= a, \"SafeMath: addition overflow\");\n    }\n\n    \n    \n    function subUint(bytes32 _key, uint256 _amount) onlyLatestRocketNetworkContract override external {\n        uint256 a;\n        assembly {\n            a := sload (_key)\n        }\n        require(_amount <= a, \"SafeMath: subtraction overflow\");\n        assembly {\n            a := sub(a, _amount)\n            sstore (_key, a)\n        }\n    }\n\n    // Private methods\n\n    function _getBool(bytes32 _key) private view returns (bool r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n    function _setBool(bytes32 _key, bool _value) private {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n}",
        "function": "deleteAddress(bytes32)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-RocketPool/rocketpool-a65b203cf99c7a991c2d85a7468a97bfb5dbba31/contracts/contract/RocketStorage.sol",
        "vulnerability": "Dependence on tx.origin (SWC 115)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract RocketStorage is RocketStorageInterface {\n\n    // Events\n    event NodeWithdrawalAddressSet(address indexed node, address indexed withdrawalAddress, uint256 time);\n    event GuardianChanged(address oldGuardian, address newGuardian);\n\n    // Libraries\n    using SafeMath for uint256;\n\n    // Complex storage maps\n    mapping(bytes32 => string)     private stringStorage;\n    mapping(bytes32 => bytes)      private bytesStorage;\n\n    // Protected storage (not accessible by network contracts)\n    mapping(address => address)    private withdrawalAddresses;\n    mapping(address => address)    private pendingWithdrawalAddresses;\n\n    // Guardian address\n    address guardian;\n    address newGuardian;\n\n    // Flag storage has been initialised\n    bool storageInit = false;\n\n    \n    modifier onlyLatestRocketNetworkContract() {\n        if (storageInit == true) {\n            // Make sure the access is permitted to only contracts in our Dapp\n            require(_getBool(keccak256(abi.encodePacked(\"contract.exists\", msg.sender))), \"Invalid or outdated network contract\");\n        } else {\n            // Only Dapp and the guardian account are allowed access during initialisation.\n            // tx.origin is only safe to use in this case for deployment since no external contracts are interacted with\n            // SWC-115-Authorization through tx.origin: L45\n            require((\n                _getBool(keccak256(abi.encodePacked(\"contract.exists\", msg.sender))) || tx.origin == guardian\n            ), \"Invalid or outdated network contract attempting access during deployment\");\n        }\n        _;\n    }\n\n\n    \n    constructor() {\n        // Set the guardian upon deployment\n        guardian = msg.sender;\n    }\n\n    // Get guardian address\n    function getGuardian() external override view returns (address) {\n        return guardian;\n    }\n\n    // Transfers guardianship to a new address\n    function setGuardian(address _newAddress) external override {\n        // Check tx comes from current guardian\n        require(msg.sender == guardian, \"Is not guardian account\");\n        // Store new address awaiting confirmation\n        newGuardian = _newAddress;\n    }\n\n    // Confirms change of guardian\n    function confirmGuardian() external override {\n        // Check tx came from new guardian address\n        require(msg.sender == newGuardian, \"Confirmation must come from new guardian address\");\n        // Store old guardian for event\n        address oldGuardian = guardian;\n        // Update guardian and clear storage\n        guardian = newGuardian;\n        delete newGuardian;\n        // Emit event\n        emit GuardianChanged(oldGuardian, guardian);\n    }\n\n    // Set this as being deployed now\n    function getDeployedStatus() external view returns (bool) {\n        return storageInit;\n    }\n\n    // Set this as being deployed now\n    function setDeployedStatus() external {\n        // Only guardian can lock this down\n        require(msg.sender == guardian, \"Is not guardian account\");\n        // Set it now\n        storageInit = true;\n    }\n\n    // Protected storage\n\n    // Get a node's withdrawal address\n    function getNodeWithdrawalAddress(address _nodeAddress) public override view returns (address) {\n        // Check if _nodeAddress is a valid node\n        if (!_getBool(keccak256(abi.encodePacked(\"node.exists\", _nodeAddress)))) {\n            return address(0);\n        }\n        // If no withdrawal address has been set, return the nodes address\n        address withdrawalAddress = withdrawalAddresses[_nodeAddress];\n        if (withdrawalAddress == address(0)) {\n            return _nodeAddress;\n        }\n        return withdrawalAddress;\n    }\n\n    // Get a node's pending withdrawal address\n    function getNodePendingWithdrawalAddress(address _nodeAddress) external override view returns (address) {\n        return pendingWithdrawalAddresses[_nodeAddress];\n    }\n\n    // Set a node's withdrawal address\n    function setWithdrawalAddress(address _nodeAddress, address _newWithdrawalAddress, bool _confirm) external override {\n        // Check new withdrawal address\n        require(_newWithdrawalAddress != address(0x0), \"Invalid withdrawal address\");\n        // Confirm the transaction is from the node's current withdrawal address\n        address withdrawalAddress = getNodeWithdrawalAddress(_nodeAddress);\n        require(withdrawalAddress == msg.sender, \"Only a tx from a node's withdrawal address can update it\");\n        // Update immediately if confirmed\n        if (_confirm) {\n            updateWithdrawalAddress(_nodeAddress, _newWithdrawalAddress);\n        }\n        // Set pending withdrawal address if not confirmed\n        else {\n            pendingWithdrawalAddresses[_nodeAddress] = _newWithdrawalAddress;\n        }\n    }\n\n    // Confirm a node's new withdrawal address\n    function confirmWithdrawalAddress(address _nodeAddress) external override {\n        // Get node by pending withdrawal address\n        require(pendingWithdrawalAddresses[_nodeAddress] == msg.sender, \"Confirmation must come from the pending withdrawal address\");\n        delete pendingWithdrawalAddresses[_nodeAddress];\n        // Update withdrawal address\n        updateWithdrawalAddress(_nodeAddress, msg.sender);\n    }\n\n    // Update a node's withdrawal address\n    function updateWithdrawalAddress(address _nodeAddress, address _newWithdrawalAddress) private {\n        // Set new withdrawal address\n        withdrawalAddresses[_nodeAddress] = _newWithdrawalAddress;\n        // Emit withdrawal address set event\n        emit NodeWithdrawalAddressSet(_nodeAddress, _newWithdrawalAddress, block.timestamp);\n    }\n\n    \n    function getAddress(bytes32 _key) override external view returns (address r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n    \n    function getUint(bytes32 _key) override external view returns (uint256 r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n    \n    function getString(bytes32 _key) override external view returns (string memory) {\n        return stringStorage[_key];\n    }\n\n    \n    function getBytes(bytes32 _key) override external view returns (bytes memory) {\n        return bytesStorage[_key];\n    }\n\n    \n    function getBool(bytes32 _key) override external view returns (bool r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n    \n    function getInt(bytes32 _key) override external view returns (int r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n    \n    function getBytes32(bytes32 _key) override external view returns (bytes32 r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n\n    \n    function setAddress(bytes32 _key, address _value) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n\n    \n    // SWC-124-Write to Arbitrary Storage Location: L206 - L210\n    function setUint(bytes32 _key, uint _value) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n\n    \n    function setString(bytes32 _key, string calldata _value) onlyLatestRocketNetworkContract override external {\n        stringStorage[_key] = _value;\n    }\n\n    \n    function setBytes(bytes32 _key, bytes calldata _value) onlyLatestRocketNetworkContract override external {\n        bytesStorage[_key] = _value;\n    }\n\n    \n    function setBool(bytes32 _key, bool _value) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n\n    \n    // SWC-124-Write to Arbitrary Storage Location: L231 - L235\n    function setInt(bytes32 _key, int _value) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n\n    \n    function setBytes32(bytes32 _key, bytes32 _value) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n\n\n    \n    function deleteAddress(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, 0)\n        }\n    }\n\n    \n    function deleteUint(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, 0)\n        }\n    }\n\n    \n    function deleteString(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        delete stringStorage[_key];\n    }\n\n    \n    function deleteBytes(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        delete bytesStorage[_key];\n    }\n\n    \n    function deleteBool(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, 0)\n        }\n    }\n\n    \n    function deleteInt(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, 0)\n        }\n    }\n\n    \n    function deleteBytes32(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, 0)\n        }\n    }\n\n\n    \n    \n    function addUint(bytes32 _key, uint256 _amount) onlyLatestRocketNetworkContract override external {\n        uint256 a;\n        uint256 b;\n        assembly {\n            a := sload (_key)\n            b := add(a, _amount)\n            sstore (_key, b)\n        }\n        require(b >= a, \"SafeMath: addition overflow\");\n    }\n\n    \n    \n    function subUint(bytes32 _key, uint256 _amount) onlyLatestRocketNetworkContract override external {\n        uint256 a;\n        assembly {\n            a := sload (_key)\n        }\n        require(_amount <= a, \"SafeMath: subtraction overflow\");\n        assembly {\n            a := sub(a, _amount)\n            sstore (_key, a)\n        }\n    }\n\n    // Private methods\n\n    function _getBool(bytes32 _key) private view returns (bool r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n    function _setBool(bytes32 _key, bool _value) private {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n}",
        "function": "deleteAddress(bytes32)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-RocketPool/rocketpool-a65b203cf99c7a991c2d85a7468a97bfb5dbba31/contracts/contract/RocketStorage.sol",
        "vulnerability": "Write to an arbitrary storage location (SWC 124)",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract RocketStorage is RocketStorageInterface {\n\n    // Events\n    event NodeWithdrawalAddressSet(address indexed node, address indexed withdrawalAddress, uint256 time);\n    event GuardianChanged(address oldGuardian, address newGuardian);\n\n    // Libraries\n    using SafeMath for uint256;\n\n    // Complex storage maps\n    mapping(bytes32 => string)     private stringStorage;\n    mapping(bytes32 => bytes)      private bytesStorage;\n\n    // Protected storage (not accessible by network contracts)\n    mapping(address => address)    private withdrawalAddresses;\n    mapping(address => address)    private pendingWithdrawalAddresses;\n\n    // Guardian address\n    address guardian;\n    address newGuardian;\n\n    // Flag storage has been initialised\n    bool storageInit = false;\n\n    \n    modifier onlyLatestRocketNetworkContract() {\n        if (storageInit == true) {\n            // Make sure the access is permitted to only contracts in our Dapp\n            require(_getBool(keccak256(abi.encodePacked(\"contract.exists\", msg.sender))), \"Invalid or outdated network contract\");\n        } else {\n            // Only Dapp and the guardian account are allowed access during initialisation.\n            // tx.origin is only safe to use in this case for deployment since no external contracts are interacted with\n            // SWC-115-Authorization through tx.origin: L45\n            require((\n                _getBool(keccak256(abi.encodePacked(\"contract.exists\", msg.sender))) || tx.origin == guardian\n            ), \"Invalid or outdated network contract attempting access during deployment\");\n        }\n        _;\n    }\n\n\n    \n    constructor() {\n        // Set the guardian upon deployment\n        guardian = msg.sender;\n    }\n\n    // Get guardian address\n    function getGuardian() external override view returns (address) {\n        return guardian;\n    }\n\n    // Transfers guardianship to a new address\n    function setGuardian(address _newAddress) external override {\n        // Check tx comes from current guardian\n        require(msg.sender == guardian, \"Is not guardian account\");\n        // Store new address awaiting confirmation\n        newGuardian = _newAddress;\n    }\n\n    // Confirms change of guardian\n    function confirmGuardian() external override {\n        // Check tx came from new guardian address\n        require(msg.sender == newGuardian, \"Confirmation must come from new guardian address\");\n        // Store old guardian for event\n        address oldGuardian = guardian;\n        // Update guardian and clear storage\n        guardian = newGuardian;\n        delete newGuardian;\n        // Emit event\n        emit GuardianChanged(oldGuardian, guardian);\n    }\n\n    // Set this as being deployed now\n    function getDeployedStatus() external view returns (bool) {\n        return storageInit;\n    }\n\n    // Set this as being deployed now\n    function setDeployedStatus() external {\n        // Only guardian can lock this down\n        require(msg.sender == guardian, \"Is not guardian account\");\n        // Set it now\n        storageInit = true;\n    }\n\n    // Protected storage\n\n    // Get a node's withdrawal address\n    function getNodeWithdrawalAddress(address _nodeAddress) public override view returns (address) {\n        // Check if _nodeAddress is a valid node\n        if (!_getBool(keccak256(abi.encodePacked(\"node.exists\", _nodeAddress)))) {\n            return address(0);\n        }\n        // If no withdrawal address has been set, return the nodes address\n        address withdrawalAddress = withdrawalAddresses[_nodeAddress];\n        if (withdrawalAddress == address(0)) {\n            return _nodeAddress;\n        }\n        return withdrawalAddress;\n    }\n\n    // Get a node's pending withdrawal address\n    function getNodePendingWithdrawalAddress(address _nodeAddress) external override view returns (address) {\n        return pendingWithdrawalAddresses[_nodeAddress];\n    }\n\n    // Set a node's withdrawal address\n    function setWithdrawalAddress(address _nodeAddress, address _newWithdrawalAddress, bool _confirm) external override {\n        // Check new withdrawal address\n        require(_newWithdrawalAddress != address(0x0), \"Invalid withdrawal address\");\n        // Confirm the transaction is from the node's current withdrawal address\n        address withdrawalAddress = getNodeWithdrawalAddress(_nodeAddress);\n        require(withdrawalAddress == msg.sender, \"Only a tx from a node's withdrawal address can update it\");\n        // Update immediately if confirmed\n        if (_confirm) {\n            updateWithdrawalAddress(_nodeAddress, _newWithdrawalAddress);\n        }\n        // Set pending withdrawal address if not confirmed\n        else {\n            pendingWithdrawalAddresses[_nodeAddress] = _newWithdrawalAddress;\n        }\n    }\n\n    // Confirm a node's new withdrawal address\n    function confirmWithdrawalAddress(address _nodeAddress) external override {\n        // Get node by pending withdrawal address\n        require(pendingWithdrawalAddresses[_nodeAddress] == msg.sender, \"Confirmation must come from the pending withdrawal address\");\n        delete pendingWithdrawalAddresses[_nodeAddress];\n        // Update withdrawal address\n        updateWithdrawalAddress(_nodeAddress, msg.sender);\n    }\n\n    // Update a node's withdrawal address\n    function updateWithdrawalAddress(address _nodeAddress, address _newWithdrawalAddress) private {\n        // Set new withdrawal address\n        withdrawalAddresses[_nodeAddress] = _newWithdrawalAddress;\n        // Emit withdrawal address set event\n        emit NodeWithdrawalAddressSet(_nodeAddress, _newWithdrawalAddress, block.timestamp);\n    }\n\n    \n    function getAddress(bytes32 _key) override external view returns (address r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n    \n    function getUint(bytes32 _key) override external view returns (uint256 r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n    \n    function getString(bytes32 _key) override external view returns (string memory) {\n        return stringStorage[_key];\n    }\n\n    \n    function getBytes(bytes32 _key) override external view returns (bytes memory) {\n        return bytesStorage[_key];\n    }\n\n    \n    function getBool(bytes32 _key) override external view returns (bool r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n    \n    function getInt(bytes32 _key) override external view returns (int r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n    \n    function getBytes32(bytes32 _key) override external view returns (bytes32 r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n\n    \n    function setAddress(bytes32 _key, address _value) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n\n    \n    // SWC-124-Write to Arbitrary Storage Location: L206 - L210\n    function setUint(bytes32 _key, uint _value) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n\n    \n    function setString(bytes32 _key, string calldata _value) onlyLatestRocketNetworkContract override external {\n        stringStorage[_key] = _value;\n    }\n\n    \n    function setBytes(bytes32 _key, bytes calldata _value) onlyLatestRocketNetworkContract override external {\n        bytesStorage[_key] = _value;\n    }\n\n    \n    function setBool(bytes32 _key, bool _value) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n\n    \n    // SWC-124-Write to Arbitrary Storage Location: L231 - L235\n    function setInt(bytes32 _key, int _value) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n\n    \n    function setBytes32(bytes32 _key, bytes32 _value) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n\n\n    \n    function deleteAddress(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, 0)\n        }\n    }\n\n    \n    function deleteUint(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, 0)\n        }\n    }\n\n    \n    function deleteString(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        delete stringStorage[_key];\n    }\n\n    \n    function deleteBytes(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        delete bytesStorage[_key];\n    }\n\n    \n    function deleteBool(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, 0)\n        }\n    }\n\n    \n    function deleteInt(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, 0)\n        }\n    }\n\n    \n    function deleteBytes32(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, 0)\n        }\n    }\n\n\n    \n    \n    function addUint(bytes32 _key, uint256 _amount) onlyLatestRocketNetworkContract override external {\n        uint256 a;\n        uint256 b;\n        assembly {\n            a := sload (_key)\n            b := add(a, _amount)\n            sstore (_key, b)\n        }\n        require(b >= a, \"SafeMath: addition overflow\");\n    }\n\n    \n    \n    function subUint(bytes32 _key, uint256 _amount) onlyLatestRocketNetworkContract override external {\n        uint256 a;\n        assembly {\n            a := sload (_key)\n        }\n        require(_amount <= a, \"SafeMath: subtraction overflow\");\n        assembly {\n            a := sub(a, _amount)\n            sstore (_key, a)\n        }\n    }\n\n    // Private methods\n\n    function _getBool(bytes32 _key) private view returns (bool r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n    function _setBool(bytes32 _key, bool _value) private {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n}",
        "function": "deleteBool(bytes32)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-RocketPool/rocketpool-a65b203cf99c7a991c2d85a7468a97bfb5dbba31/contracts/contract/RocketStorage.sol",
        "vulnerability": "Dependence on tx.origin (SWC 115)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract RocketStorage is RocketStorageInterface {\n\n    // Events\n    event NodeWithdrawalAddressSet(address indexed node, address indexed withdrawalAddress, uint256 time);\n    event GuardianChanged(address oldGuardian, address newGuardian);\n\n    // Libraries\n    using SafeMath for uint256;\n\n    // Complex storage maps\n    mapping(bytes32 => string)     private stringStorage;\n    mapping(bytes32 => bytes)      private bytesStorage;\n\n    // Protected storage (not accessible by network contracts)\n    mapping(address => address)    private withdrawalAddresses;\n    mapping(address => address)    private pendingWithdrawalAddresses;\n\n    // Guardian address\n    address guardian;\n    address newGuardian;\n\n    // Flag storage has been initialised\n    bool storageInit = false;\n\n    \n    modifier onlyLatestRocketNetworkContract() {\n        if (storageInit == true) {\n            // Make sure the access is permitted to only contracts in our Dapp\n            require(_getBool(keccak256(abi.encodePacked(\"contract.exists\", msg.sender))), \"Invalid or outdated network contract\");\n        } else {\n            // Only Dapp and the guardian account are allowed access during initialisation.\n            // tx.origin is only safe to use in this case for deployment since no external contracts are interacted with\n            // SWC-115-Authorization through tx.origin: L45\n            require((\n                _getBool(keccak256(abi.encodePacked(\"contract.exists\", msg.sender))) || tx.origin == guardian\n            ), \"Invalid or outdated network contract attempting access during deployment\");\n        }\n        _;\n    }\n\n\n    \n    constructor() {\n        // Set the guardian upon deployment\n        guardian = msg.sender;\n    }\n\n    // Get guardian address\n    function getGuardian() external override view returns (address) {\n        return guardian;\n    }\n\n    // Transfers guardianship to a new address\n    function setGuardian(address _newAddress) external override {\n        // Check tx comes from current guardian\n        require(msg.sender == guardian, \"Is not guardian account\");\n        // Store new address awaiting confirmation\n        newGuardian = _newAddress;\n    }\n\n    // Confirms change of guardian\n    function confirmGuardian() external override {\n        // Check tx came from new guardian address\n        require(msg.sender == newGuardian, \"Confirmation must come from new guardian address\");\n        // Store old guardian for event\n        address oldGuardian = guardian;\n        // Update guardian and clear storage\n        guardian = newGuardian;\n        delete newGuardian;\n        // Emit event\n        emit GuardianChanged(oldGuardian, guardian);\n    }\n\n    // Set this as being deployed now\n    function getDeployedStatus() external view returns (bool) {\n        return storageInit;\n    }\n\n    // Set this as being deployed now\n    function setDeployedStatus() external {\n        // Only guardian can lock this down\n        require(msg.sender == guardian, \"Is not guardian account\");\n        // Set it now\n        storageInit = true;\n    }\n\n    // Protected storage\n\n    // Get a node's withdrawal address\n    function getNodeWithdrawalAddress(address _nodeAddress) public override view returns (address) {\n        // Check if _nodeAddress is a valid node\n        if (!_getBool(keccak256(abi.encodePacked(\"node.exists\", _nodeAddress)))) {\n            return address(0);\n        }\n        // If no withdrawal address has been set, return the nodes address\n        address withdrawalAddress = withdrawalAddresses[_nodeAddress];\n        if (withdrawalAddress == address(0)) {\n            return _nodeAddress;\n        }\n        return withdrawalAddress;\n    }\n\n    // Get a node's pending withdrawal address\n    function getNodePendingWithdrawalAddress(address _nodeAddress) external override view returns (address) {\n        return pendingWithdrawalAddresses[_nodeAddress];\n    }\n\n    // Set a node's withdrawal address\n    function setWithdrawalAddress(address _nodeAddress, address _newWithdrawalAddress, bool _confirm) external override {\n        // Check new withdrawal address\n        require(_newWithdrawalAddress != address(0x0), \"Invalid withdrawal address\");\n        // Confirm the transaction is from the node's current withdrawal address\n        address withdrawalAddress = getNodeWithdrawalAddress(_nodeAddress);\n        require(withdrawalAddress == msg.sender, \"Only a tx from a node's withdrawal address can update it\");\n        // Update immediately if confirmed\n        if (_confirm) {\n            updateWithdrawalAddress(_nodeAddress, _newWithdrawalAddress);\n        }\n        // Set pending withdrawal address if not confirmed\n        else {\n            pendingWithdrawalAddresses[_nodeAddress] = _newWithdrawalAddress;\n        }\n    }\n\n    // Confirm a node's new withdrawal address\n    function confirmWithdrawalAddress(address _nodeAddress) external override {\n        // Get node by pending withdrawal address\n        require(pendingWithdrawalAddresses[_nodeAddress] == msg.sender, \"Confirmation must come from the pending withdrawal address\");\n        delete pendingWithdrawalAddresses[_nodeAddress];\n        // Update withdrawal address\n        updateWithdrawalAddress(_nodeAddress, msg.sender);\n    }\n\n    // Update a node's withdrawal address\n    function updateWithdrawalAddress(address _nodeAddress, address _newWithdrawalAddress) private {\n        // Set new withdrawal address\n        withdrawalAddresses[_nodeAddress] = _newWithdrawalAddress;\n        // Emit withdrawal address set event\n        emit NodeWithdrawalAddressSet(_nodeAddress, _newWithdrawalAddress, block.timestamp);\n    }\n\n    \n    function getAddress(bytes32 _key) override external view returns (address r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n    \n    function getUint(bytes32 _key) override external view returns (uint256 r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n    \n    function getString(bytes32 _key) override external view returns (string memory) {\n        return stringStorage[_key];\n    }\n\n    \n    function getBytes(bytes32 _key) override external view returns (bytes memory) {\n        return bytesStorage[_key];\n    }\n\n    \n    function getBool(bytes32 _key) override external view returns (bool r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n    \n    function getInt(bytes32 _key) override external view returns (int r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n    \n    function getBytes32(bytes32 _key) override external view returns (bytes32 r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n\n    \n    function setAddress(bytes32 _key, address _value) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n\n    \n    // SWC-124-Write to Arbitrary Storage Location: L206 - L210\n    function setUint(bytes32 _key, uint _value) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n\n    \n    function setString(bytes32 _key, string calldata _value) onlyLatestRocketNetworkContract override external {\n        stringStorage[_key] = _value;\n    }\n\n    \n    function setBytes(bytes32 _key, bytes calldata _value) onlyLatestRocketNetworkContract override external {\n        bytesStorage[_key] = _value;\n    }\n\n    \n    function setBool(bytes32 _key, bool _value) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n\n    \n    // SWC-124-Write to Arbitrary Storage Location: L231 - L235\n    function setInt(bytes32 _key, int _value) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n\n    \n    function setBytes32(bytes32 _key, bytes32 _value) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n\n\n    \n    function deleteAddress(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, 0)\n        }\n    }\n\n    \n    function deleteUint(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, 0)\n        }\n    }\n\n    \n    function deleteString(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        delete stringStorage[_key];\n    }\n\n    \n    function deleteBytes(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        delete bytesStorage[_key];\n    }\n\n    \n    function deleteBool(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, 0)\n        }\n    }\n\n    \n    function deleteInt(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, 0)\n        }\n    }\n\n    \n    function deleteBytes32(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, 0)\n        }\n    }\n\n\n    \n    \n    function addUint(bytes32 _key, uint256 _amount) onlyLatestRocketNetworkContract override external {\n        uint256 a;\n        uint256 b;\n        assembly {\n            a := sload (_key)\n            b := add(a, _amount)\n            sstore (_key, b)\n        }\n        require(b >= a, \"SafeMath: addition overflow\");\n    }\n\n    \n    \n    function subUint(bytes32 _key, uint256 _amount) onlyLatestRocketNetworkContract override external {\n        uint256 a;\n        assembly {\n            a := sload (_key)\n        }\n        require(_amount <= a, \"SafeMath: subtraction overflow\");\n        assembly {\n            a := sub(a, _amount)\n            sstore (_key, a)\n        }\n    }\n\n    // Private methods\n\n    function _getBool(bytes32 _key) private view returns (bool r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n    function _setBool(bytes32 _key, bool _value) private {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n}",
        "function": "deleteBool(bytes32)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-RocketPool/rocketpool-a65b203cf99c7a991c2d85a7468a97bfb5dbba31/contracts/contract/RocketStorage.sol",
        "vulnerability": "Write to an arbitrary storage location (SWC 124)",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract RocketStorage is RocketStorageInterface {\n\n    // Events\n    event NodeWithdrawalAddressSet(address indexed node, address indexed withdrawalAddress, uint256 time);\n    event GuardianChanged(address oldGuardian, address newGuardian);\n\n    // Libraries\n    using SafeMath for uint256;\n\n    // Complex storage maps\n    mapping(bytes32 => string)     private stringStorage;\n    mapping(bytes32 => bytes)      private bytesStorage;\n\n    // Protected storage (not accessible by network contracts)\n    mapping(address => address)    private withdrawalAddresses;\n    mapping(address => address)    private pendingWithdrawalAddresses;\n\n    // Guardian address\n    address guardian;\n    address newGuardian;\n\n    // Flag storage has been initialised\n    bool storageInit = false;\n\n    \n    modifier onlyLatestRocketNetworkContract() {\n        if (storageInit == true) {\n            // Make sure the access is permitted to only contracts in our Dapp\n            require(_getBool(keccak256(abi.encodePacked(\"contract.exists\", msg.sender))), \"Invalid or outdated network contract\");\n        } else {\n            // Only Dapp and the guardian account are allowed access during initialisation.\n            // tx.origin is only safe to use in this case for deployment since no external contracts are interacted with\n            // SWC-115-Authorization through tx.origin: L45\n            require((\n                _getBool(keccak256(abi.encodePacked(\"contract.exists\", msg.sender))) || tx.origin == guardian\n            ), \"Invalid or outdated network contract attempting access during deployment\");\n        }\n        _;\n    }\n\n\n    \n    constructor() {\n        // Set the guardian upon deployment\n        guardian = msg.sender;\n    }\n\n    // Get guardian address\n    function getGuardian() external override view returns (address) {\n        return guardian;\n    }\n\n    // Transfers guardianship to a new address\n    function setGuardian(address _newAddress) external override {\n        // Check tx comes from current guardian\n        require(msg.sender == guardian, \"Is not guardian account\");\n        // Store new address awaiting confirmation\n        newGuardian = _newAddress;\n    }\n\n    // Confirms change of guardian\n    function confirmGuardian() external override {\n        // Check tx came from new guardian address\n        require(msg.sender == newGuardian, \"Confirmation must come from new guardian address\");\n        // Store old guardian for event\n        address oldGuardian = guardian;\n        // Update guardian and clear storage\n        guardian = newGuardian;\n        delete newGuardian;\n        // Emit event\n        emit GuardianChanged(oldGuardian, guardian);\n    }\n\n    // Set this as being deployed now\n    function getDeployedStatus() external view returns (bool) {\n        return storageInit;\n    }\n\n    // Set this as being deployed now\n    function setDeployedStatus() external {\n        // Only guardian can lock this down\n        require(msg.sender == guardian, \"Is not guardian account\");\n        // Set it now\n        storageInit = true;\n    }\n\n    // Protected storage\n\n    // Get a node's withdrawal address\n    function getNodeWithdrawalAddress(address _nodeAddress) public override view returns (address) {\n        // Check if _nodeAddress is a valid node\n        if (!_getBool(keccak256(abi.encodePacked(\"node.exists\", _nodeAddress)))) {\n            return address(0);\n        }\n        // If no withdrawal address has been set, return the nodes address\n        address withdrawalAddress = withdrawalAddresses[_nodeAddress];\n        if (withdrawalAddress == address(0)) {\n            return _nodeAddress;\n        }\n        return withdrawalAddress;\n    }\n\n    // Get a node's pending withdrawal address\n    function getNodePendingWithdrawalAddress(address _nodeAddress) external override view returns (address) {\n        return pendingWithdrawalAddresses[_nodeAddress];\n    }\n\n    // Set a node's withdrawal address\n    function setWithdrawalAddress(address _nodeAddress, address _newWithdrawalAddress, bool _confirm) external override {\n        // Check new withdrawal address\n        require(_newWithdrawalAddress != address(0x0), \"Invalid withdrawal address\");\n        // Confirm the transaction is from the node's current withdrawal address\n        address withdrawalAddress = getNodeWithdrawalAddress(_nodeAddress);\n        require(withdrawalAddress == msg.sender, \"Only a tx from a node's withdrawal address can update it\");\n        // Update immediately if confirmed\n        if (_confirm) {\n            updateWithdrawalAddress(_nodeAddress, _newWithdrawalAddress);\n        }\n        // Set pending withdrawal address if not confirmed\n        else {\n            pendingWithdrawalAddresses[_nodeAddress] = _newWithdrawalAddress;\n        }\n    }\n\n    // Confirm a node's new withdrawal address\n    function confirmWithdrawalAddress(address _nodeAddress) external override {\n        // Get node by pending withdrawal address\n        require(pendingWithdrawalAddresses[_nodeAddress] == msg.sender, \"Confirmation must come from the pending withdrawal address\");\n        delete pendingWithdrawalAddresses[_nodeAddress];\n        // Update withdrawal address\n        updateWithdrawalAddress(_nodeAddress, msg.sender);\n    }\n\n    // Update a node's withdrawal address\n    function updateWithdrawalAddress(address _nodeAddress, address _newWithdrawalAddress) private {\n        // Set new withdrawal address\n        withdrawalAddresses[_nodeAddress] = _newWithdrawalAddress;\n        // Emit withdrawal address set event\n        emit NodeWithdrawalAddressSet(_nodeAddress, _newWithdrawalAddress, block.timestamp);\n    }\n\n    \n    function getAddress(bytes32 _key) override external view returns (address r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n    \n    function getUint(bytes32 _key) override external view returns (uint256 r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n    \n    function getString(bytes32 _key) override external view returns (string memory) {\n        return stringStorage[_key];\n    }\n\n    \n    function getBytes(bytes32 _key) override external view returns (bytes memory) {\n        return bytesStorage[_key];\n    }\n\n    \n    function getBool(bytes32 _key) override external view returns (bool r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n    \n    function getInt(bytes32 _key) override external view returns (int r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n    \n    function getBytes32(bytes32 _key) override external view returns (bytes32 r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n\n    \n    function setAddress(bytes32 _key, address _value) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n\n    \n    // SWC-124-Write to Arbitrary Storage Location: L206 - L210\n    function setUint(bytes32 _key, uint _value) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n\n    \n    function setString(bytes32 _key, string calldata _value) onlyLatestRocketNetworkContract override external {\n        stringStorage[_key] = _value;\n    }\n\n    \n    function setBytes(bytes32 _key, bytes calldata _value) onlyLatestRocketNetworkContract override external {\n        bytesStorage[_key] = _value;\n    }\n\n    \n    function setBool(bytes32 _key, bool _value) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n\n    \n    // SWC-124-Write to Arbitrary Storage Location: L231 - L235\n    function setInt(bytes32 _key, int _value) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n\n    \n    function setBytes32(bytes32 _key, bytes32 _value) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n\n\n    \n    function deleteAddress(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, 0)\n        }\n    }\n\n    \n    function deleteUint(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, 0)\n        }\n    }\n\n    \n    function deleteString(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        delete stringStorage[_key];\n    }\n\n    \n    function deleteBytes(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        delete bytesStorage[_key];\n    }\n\n    \n    function deleteBool(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, 0)\n        }\n    }\n\n    \n    function deleteInt(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, 0)\n        }\n    }\n\n    \n    function deleteBytes32(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, 0)\n        }\n    }\n\n\n    \n    \n    function addUint(bytes32 _key, uint256 _amount) onlyLatestRocketNetworkContract override external {\n        uint256 a;\n        uint256 b;\n        assembly {\n            a := sload (_key)\n            b := add(a, _amount)\n            sstore (_key, b)\n        }\n        require(b >= a, \"SafeMath: addition overflow\");\n    }\n\n    \n    \n    function subUint(bytes32 _key, uint256 _amount) onlyLatestRocketNetworkContract override external {\n        uint256 a;\n        assembly {\n            a := sload (_key)\n        }\n        require(_amount <= a, \"SafeMath: subtraction overflow\");\n        assembly {\n            a := sub(a, _amount)\n            sstore (_key, a)\n        }\n    }\n\n    // Private methods\n\n    function _getBool(bytes32 _key) private view returns (bool r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n    function _setBool(bytes32 _key, bool _value) private {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n}",
        "function": "setBytes(bytes32,bytes)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-RocketPool/rocketpool-a65b203cf99c7a991c2d85a7468a97bfb5dbba31/contracts/contract/RocketStorage.sol",
        "vulnerability": "Dependence on tx.origin (SWC 115)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract RocketStorage is RocketStorageInterface {\n\n    // Events\n    event NodeWithdrawalAddressSet(address indexed node, address indexed withdrawalAddress, uint256 time);\n    event GuardianChanged(address oldGuardian, address newGuardian);\n\n    // Libraries\n    using SafeMath for uint256;\n\n    // Complex storage maps\n    mapping(bytes32 => string)     private stringStorage;\n    mapping(bytes32 => bytes)      private bytesStorage;\n\n    // Protected storage (not accessible by network contracts)\n    mapping(address => address)    private withdrawalAddresses;\n    mapping(address => address)    private pendingWithdrawalAddresses;\n\n    // Guardian address\n    address guardian;\n    address newGuardian;\n\n    // Flag storage has been initialised\n    bool storageInit = false;\n\n    \n    modifier onlyLatestRocketNetworkContract() {\n        if (storageInit == true) {\n            // Make sure the access is permitted to only contracts in our Dapp\n            require(_getBool(keccak256(abi.encodePacked(\"contract.exists\", msg.sender))), \"Invalid or outdated network contract\");\n        } else {\n            // Only Dapp and the guardian account are allowed access during initialisation.\n            // tx.origin is only safe to use in this case for deployment since no external contracts are interacted with\n            // SWC-115-Authorization through tx.origin: L45\n            require((\n                _getBool(keccak256(abi.encodePacked(\"contract.exists\", msg.sender))) || tx.origin == guardian\n            ), \"Invalid or outdated network contract attempting access during deployment\");\n        }\n        _;\n    }\n\n\n    \n    constructor() {\n        // Set the guardian upon deployment\n        guardian = msg.sender;\n    }\n\n    // Get guardian address\n    function getGuardian() external override view returns (address) {\n        return guardian;\n    }\n\n    // Transfers guardianship to a new address\n    function setGuardian(address _newAddress) external override {\n        // Check tx comes from current guardian\n        require(msg.sender == guardian, \"Is not guardian account\");\n        // Store new address awaiting confirmation\n        newGuardian = _newAddress;\n    }\n\n    // Confirms change of guardian\n    function confirmGuardian() external override {\n        // Check tx came from new guardian address\n        require(msg.sender == newGuardian, \"Confirmation must come from new guardian address\");\n        // Store old guardian for event\n        address oldGuardian = guardian;\n        // Update guardian and clear storage\n        guardian = newGuardian;\n        delete newGuardian;\n        // Emit event\n        emit GuardianChanged(oldGuardian, guardian);\n    }\n\n    // Set this as being deployed now\n    function getDeployedStatus() external view returns (bool) {\n        return storageInit;\n    }\n\n    // Set this as being deployed now\n    function setDeployedStatus() external {\n        // Only guardian can lock this down\n        require(msg.sender == guardian, \"Is not guardian account\");\n        // Set it now\n        storageInit = true;\n    }\n\n    // Protected storage\n\n    // Get a node's withdrawal address\n    function getNodeWithdrawalAddress(address _nodeAddress) public override view returns (address) {\n        // Check if _nodeAddress is a valid node\n        if (!_getBool(keccak256(abi.encodePacked(\"node.exists\", _nodeAddress)))) {\n            return address(0);\n        }\n        // If no withdrawal address has been set, return the nodes address\n        address withdrawalAddress = withdrawalAddresses[_nodeAddress];\n        if (withdrawalAddress == address(0)) {\n            return _nodeAddress;\n        }\n        return withdrawalAddress;\n    }\n\n    // Get a node's pending withdrawal address\n    function getNodePendingWithdrawalAddress(address _nodeAddress) external override view returns (address) {\n        return pendingWithdrawalAddresses[_nodeAddress];\n    }\n\n    // Set a node's withdrawal address\n    function setWithdrawalAddress(address _nodeAddress, address _newWithdrawalAddress, bool _confirm) external override {\n        // Check new withdrawal address\n        require(_newWithdrawalAddress != address(0x0), \"Invalid withdrawal address\");\n        // Confirm the transaction is from the node's current withdrawal address\n        address withdrawalAddress = getNodeWithdrawalAddress(_nodeAddress);\n        require(withdrawalAddress == msg.sender, \"Only a tx from a node's withdrawal address can update it\");\n        // Update immediately if confirmed\n        if (_confirm) {\n            updateWithdrawalAddress(_nodeAddress, _newWithdrawalAddress);\n        }\n        // Set pending withdrawal address if not confirmed\n        else {\n            pendingWithdrawalAddresses[_nodeAddress] = _newWithdrawalAddress;\n        }\n    }\n\n    // Confirm a node's new withdrawal address\n    function confirmWithdrawalAddress(address _nodeAddress) external override {\n        // Get node by pending withdrawal address\n        require(pendingWithdrawalAddresses[_nodeAddress] == msg.sender, \"Confirmation must come from the pending withdrawal address\");\n        delete pendingWithdrawalAddresses[_nodeAddress];\n        // Update withdrawal address\n        updateWithdrawalAddress(_nodeAddress, msg.sender);\n    }\n\n    // Update a node's withdrawal address\n    function updateWithdrawalAddress(address _nodeAddress, address _newWithdrawalAddress) private {\n        // Set new withdrawal address\n        withdrawalAddresses[_nodeAddress] = _newWithdrawalAddress;\n        // Emit withdrawal address set event\n        emit NodeWithdrawalAddressSet(_nodeAddress, _newWithdrawalAddress, block.timestamp);\n    }\n\n    \n    function getAddress(bytes32 _key) override external view returns (address r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n    \n    function getUint(bytes32 _key) override external view returns (uint256 r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n    \n    function getString(bytes32 _key) override external view returns (string memory) {\n        return stringStorage[_key];\n    }\n\n    \n    function getBytes(bytes32 _key) override external view returns (bytes memory) {\n        return bytesStorage[_key];\n    }\n\n    \n    function getBool(bytes32 _key) override external view returns (bool r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n    \n    function getInt(bytes32 _key) override external view returns (int r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n    \n    function getBytes32(bytes32 _key) override external view returns (bytes32 r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n\n    \n    function setAddress(bytes32 _key, address _value) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n\n    \n    // SWC-124-Write to Arbitrary Storage Location: L206 - L210\n    function setUint(bytes32 _key, uint _value) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n\n    \n    function setString(bytes32 _key, string calldata _value) onlyLatestRocketNetworkContract override external {\n        stringStorage[_key] = _value;\n    }\n\n    \n    function setBytes(bytes32 _key, bytes calldata _value) onlyLatestRocketNetworkContract override external {\n        bytesStorage[_key] = _value;\n    }\n\n    \n    function setBool(bytes32 _key, bool _value) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n\n    \n    // SWC-124-Write to Arbitrary Storage Location: L231 - L235\n    function setInt(bytes32 _key, int _value) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n\n    \n    function setBytes32(bytes32 _key, bytes32 _value) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n\n\n    \n    function deleteAddress(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, 0)\n        }\n    }\n\n    \n    function deleteUint(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, 0)\n        }\n    }\n\n    \n    function deleteString(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        delete stringStorage[_key];\n    }\n\n    \n    function deleteBytes(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        delete bytesStorage[_key];\n    }\n\n    \n    function deleteBool(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, 0)\n        }\n    }\n\n    \n    function deleteInt(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, 0)\n        }\n    }\n\n    \n    function deleteBytes32(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, 0)\n        }\n    }\n\n\n    \n    \n    function addUint(bytes32 _key, uint256 _amount) onlyLatestRocketNetworkContract override external {\n        uint256 a;\n        uint256 b;\n        assembly {\n            a := sload (_key)\n            b := add(a, _amount)\n            sstore (_key, b)\n        }\n        require(b >= a, \"SafeMath: addition overflow\");\n    }\n\n    \n    \n    function subUint(bytes32 _key, uint256 _amount) onlyLatestRocketNetworkContract override external {\n        uint256 a;\n        assembly {\n            a := sload (_key)\n        }\n        require(_amount <= a, \"SafeMath: subtraction overflow\");\n        assembly {\n            a := sub(a, _amount)\n            sstore (_key, a)\n        }\n    }\n\n    // Private methods\n\n    function _getBool(bytes32 _key) private view returns (bool r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n    function _setBool(bytes32 _key, bool _value) private {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n}",
        "function": "setInt(bytes32,int256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-RocketPool/rocketpool-a65b203cf99c7a991c2d85a7468a97bfb5dbba31/contracts/contract/RocketStorage.sol",
        "vulnerability": "Dependence on tx.origin (SWC 115)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract RocketStorage is RocketStorageInterface {\n\n    // Events\n    event NodeWithdrawalAddressSet(address indexed node, address indexed withdrawalAddress, uint256 time);\n    event GuardianChanged(address oldGuardian, address newGuardian);\n\n    // Libraries\n    using SafeMath for uint256;\n\n    // Complex storage maps\n    mapping(bytes32 => string)     private stringStorage;\n    mapping(bytes32 => bytes)      private bytesStorage;\n\n    // Protected storage (not accessible by network contracts)\n    mapping(address => address)    private withdrawalAddresses;\n    mapping(address => address)    private pendingWithdrawalAddresses;\n\n    // Guardian address\n    address guardian;\n    address newGuardian;\n\n    // Flag storage has been initialised\n    bool storageInit = false;\n\n    \n    modifier onlyLatestRocketNetworkContract() {\n        if (storageInit == true) {\n            // Make sure the access is permitted to only contracts in our Dapp\n            require(_getBool(keccak256(abi.encodePacked(\"contract.exists\", msg.sender))), \"Invalid or outdated network contract\");\n        } else {\n            // Only Dapp and the guardian account are allowed access during initialisation.\n            // tx.origin is only safe to use in this case for deployment since no external contracts are interacted with\n            // SWC-115-Authorization through tx.origin: L45\n            require((\n                _getBool(keccak256(abi.encodePacked(\"contract.exists\", msg.sender))) || tx.origin == guardian\n            ), \"Invalid or outdated network contract attempting access during deployment\");\n        }\n        _;\n    }\n\n\n    \n    constructor() {\n        // Set the guardian upon deployment\n        guardian = msg.sender;\n    }\n\n    // Get guardian address\n    function getGuardian() external override view returns (address) {\n        return guardian;\n    }\n\n    // Transfers guardianship to a new address\n    function setGuardian(address _newAddress) external override {\n        // Check tx comes from current guardian\n        require(msg.sender == guardian, \"Is not guardian account\");\n        // Store new address awaiting confirmation\n        newGuardian = _newAddress;\n    }\n\n    // Confirms change of guardian\n    function confirmGuardian() external override {\n        // Check tx came from new guardian address\n        require(msg.sender == newGuardian, \"Confirmation must come from new guardian address\");\n        // Store old guardian for event\n        address oldGuardian = guardian;\n        // Update guardian and clear storage\n        guardian = newGuardian;\n        delete newGuardian;\n        // Emit event\n        emit GuardianChanged(oldGuardian, guardian);\n    }\n\n    // Set this as being deployed now\n    function getDeployedStatus() external view returns (bool) {\n        return storageInit;\n    }\n\n    // Set this as being deployed now\n    function setDeployedStatus() external {\n        // Only guardian can lock this down\n        require(msg.sender == guardian, \"Is not guardian account\");\n        // Set it now\n        storageInit = true;\n    }\n\n    // Protected storage\n\n    // Get a node's withdrawal address\n    function getNodeWithdrawalAddress(address _nodeAddress) public override view returns (address) {\n        // Check if _nodeAddress is a valid node\n        if (!_getBool(keccak256(abi.encodePacked(\"node.exists\", _nodeAddress)))) {\n            return address(0);\n        }\n        // If no withdrawal address has been set, return the nodes address\n        address withdrawalAddress = withdrawalAddresses[_nodeAddress];\n        if (withdrawalAddress == address(0)) {\n            return _nodeAddress;\n        }\n        return withdrawalAddress;\n    }\n\n    // Get a node's pending withdrawal address\n    function getNodePendingWithdrawalAddress(address _nodeAddress) external override view returns (address) {\n        return pendingWithdrawalAddresses[_nodeAddress];\n    }\n\n    // Set a node's withdrawal address\n    function setWithdrawalAddress(address _nodeAddress, address _newWithdrawalAddress, bool _confirm) external override {\n        // Check new withdrawal address\n        require(_newWithdrawalAddress != address(0x0), \"Invalid withdrawal address\");\n        // Confirm the transaction is from the node's current withdrawal address\n        address withdrawalAddress = getNodeWithdrawalAddress(_nodeAddress);\n        require(withdrawalAddress == msg.sender, \"Only a tx from a node's withdrawal address can update it\");\n        // Update immediately if confirmed\n        if (_confirm) {\n            updateWithdrawalAddress(_nodeAddress, _newWithdrawalAddress);\n        }\n        // Set pending withdrawal address if not confirmed\n        else {\n            pendingWithdrawalAddresses[_nodeAddress] = _newWithdrawalAddress;\n        }\n    }\n\n    // Confirm a node's new withdrawal address\n    function confirmWithdrawalAddress(address _nodeAddress) external override {\n        // Get node by pending withdrawal address\n        require(pendingWithdrawalAddresses[_nodeAddress] == msg.sender, \"Confirmation must come from the pending withdrawal address\");\n        delete pendingWithdrawalAddresses[_nodeAddress];\n        // Update withdrawal address\n        updateWithdrawalAddress(_nodeAddress, msg.sender);\n    }\n\n    // Update a node's withdrawal address\n    function updateWithdrawalAddress(address _nodeAddress, address _newWithdrawalAddress) private {\n        // Set new withdrawal address\n        withdrawalAddresses[_nodeAddress] = _newWithdrawalAddress;\n        // Emit withdrawal address set event\n        emit NodeWithdrawalAddressSet(_nodeAddress, _newWithdrawalAddress, block.timestamp);\n    }\n\n    \n    function getAddress(bytes32 _key) override external view returns (address r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n    \n    function getUint(bytes32 _key) override external view returns (uint256 r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n    \n    function getString(bytes32 _key) override external view returns (string memory) {\n        return stringStorage[_key];\n    }\n\n    \n    function getBytes(bytes32 _key) override external view returns (bytes memory) {\n        return bytesStorage[_key];\n    }\n\n    \n    function getBool(bytes32 _key) override external view returns (bool r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n    \n    function getInt(bytes32 _key) override external view returns (int r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n    \n    function getBytes32(bytes32 _key) override external view returns (bytes32 r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n\n    \n    function setAddress(bytes32 _key, address _value) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n\n    \n    // SWC-124-Write to Arbitrary Storage Location: L206 - L210\n    function setUint(bytes32 _key, uint _value) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n\n    \n    function setString(bytes32 _key, string calldata _value) onlyLatestRocketNetworkContract override external {\n        stringStorage[_key] = _value;\n    }\n\n    \n    function setBytes(bytes32 _key, bytes calldata _value) onlyLatestRocketNetworkContract override external {\n        bytesStorage[_key] = _value;\n    }\n\n    \n    function setBool(bytes32 _key, bool _value) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n\n    \n    // SWC-124-Write to Arbitrary Storage Location: L231 - L235\n    function setInt(bytes32 _key, int _value) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n\n    \n    function setBytes32(bytes32 _key, bytes32 _value) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n\n\n    \n    function deleteAddress(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, 0)\n        }\n    }\n\n    \n    function deleteUint(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, 0)\n        }\n    }\n\n    \n    function deleteString(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        delete stringStorage[_key];\n    }\n\n    \n    function deleteBytes(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        delete bytesStorage[_key];\n    }\n\n    \n    function deleteBool(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, 0)\n        }\n    }\n\n    \n    function deleteInt(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, 0)\n        }\n    }\n\n    \n    function deleteBytes32(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, 0)\n        }\n    }\n\n\n    \n    \n    function addUint(bytes32 _key, uint256 _amount) onlyLatestRocketNetworkContract override external {\n        uint256 a;\n        uint256 b;\n        assembly {\n            a := sload (_key)\n            b := add(a, _amount)\n            sstore (_key, b)\n        }\n        require(b >= a, \"SafeMath: addition overflow\");\n    }\n\n    \n    \n    function subUint(bytes32 _key, uint256 _amount) onlyLatestRocketNetworkContract override external {\n        uint256 a;\n        assembly {\n            a := sload (_key)\n        }\n        require(_amount <= a, \"SafeMath: subtraction overflow\");\n        assembly {\n            a := sub(a, _amount)\n            sstore (_key, a)\n        }\n    }\n\n    // Private methods\n\n    function _getBool(bytes32 _key) private view returns (bool r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n    function _setBool(bytes32 _key, bool _value) private {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n}",
        "function": "setInt(bytes32,int256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-RocketPool/rocketpool-a65b203cf99c7a991c2d85a7468a97bfb5dbba31/contracts/contract/RocketStorage.sol",
        "vulnerability": "Write to an arbitrary storage location (SWC 124)",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract RocketStorage is RocketStorageInterface {\n\n    // Events\n    event NodeWithdrawalAddressSet(address indexed node, address indexed withdrawalAddress, uint256 time);\n    event GuardianChanged(address oldGuardian, address newGuardian);\n\n    // Libraries\n    using SafeMath for uint256;\n\n    // Complex storage maps\n    mapping(bytes32 => string)     private stringStorage;\n    mapping(bytes32 => bytes)      private bytesStorage;\n\n    // Protected storage (not accessible by network contracts)\n    mapping(address => address)    private withdrawalAddresses;\n    mapping(address => address)    private pendingWithdrawalAddresses;\n\n    // Guardian address\n    address guardian;\n    address newGuardian;\n\n    // Flag storage has been initialised\n    bool storageInit = false;\n\n    \n    modifier onlyLatestRocketNetworkContract() {\n        if (storageInit == true) {\n            // Make sure the access is permitted to only contracts in our Dapp\n            require(_getBool(keccak256(abi.encodePacked(\"contract.exists\", msg.sender))), \"Invalid or outdated network contract\");\n        } else {\n            // Only Dapp and the guardian account are allowed access during initialisation.\n            // tx.origin is only safe to use in this case for deployment since no external contracts are interacted with\n            // SWC-115-Authorization through tx.origin: L45\n            require((\n                _getBool(keccak256(abi.encodePacked(\"contract.exists\", msg.sender))) || tx.origin == guardian\n            ), \"Invalid or outdated network contract attempting access during deployment\");\n        }\n        _;\n    }\n\n\n    \n    constructor() {\n        // Set the guardian upon deployment\n        guardian = msg.sender;\n    }\n\n    // Get guardian address\n    function getGuardian() external override view returns (address) {\n        return guardian;\n    }\n\n    // Transfers guardianship to a new address\n    function setGuardian(address _newAddress) external override {\n        // Check tx comes from current guardian\n        require(msg.sender == guardian, \"Is not guardian account\");\n        // Store new address awaiting confirmation\n        newGuardian = _newAddress;\n    }\n\n    // Confirms change of guardian\n    function confirmGuardian() external override {\n        // Check tx came from new guardian address\n        require(msg.sender == newGuardian, \"Confirmation must come from new guardian address\");\n        // Store old guardian for event\n        address oldGuardian = guardian;\n        // Update guardian and clear storage\n        guardian = newGuardian;\n        delete newGuardian;\n        // Emit event\n        emit GuardianChanged(oldGuardian, guardian);\n    }\n\n    // Set this as being deployed now\n    function getDeployedStatus() external view returns (bool) {\n        return storageInit;\n    }\n\n    // Set this as being deployed now\n    function setDeployedStatus() external {\n        // Only guardian can lock this down\n        require(msg.sender == guardian, \"Is not guardian account\");\n        // Set it now\n        storageInit = true;\n    }\n\n    // Protected storage\n\n    // Get a node's withdrawal address\n    function getNodeWithdrawalAddress(address _nodeAddress) public override view returns (address) {\n        // Check if _nodeAddress is a valid node\n        if (!_getBool(keccak256(abi.encodePacked(\"node.exists\", _nodeAddress)))) {\n            return address(0);\n        }\n        // If no withdrawal address has been set, return the nodes address\n        address withdrawalAddress = withdrawalAddresses[_nodeAddress];\n        if (withdrawalAddress == address(0)) {\n            return _nodeAddress;\n        }\n        return withdrawalAddress;\n    }\n\n    // Get a node's pending withdrawal address\n    function getNodePendingWithdrawalAddress(address _nodeAddress) external override view returns (address) {\n        return pendingWithdrawalAddresses[_nodeAddress];\n    }\n\n    // Set a node's withdrawal address\n    function setWithdrawalAddress(address _nodeAddress, address _newWithdrawalAddress, bool _confirm) external override {\n        // Check new withdrawal address\n        require(_newWithdrawalAddress != address(0x0), \"Invalid withdrawal address\");\n        // Confirm the transaction is from the node's current withdrawal address\n        address withdrawalAddress = getNodeWithdrawalAddress(_nodeAddress);\n        require(withdrawalAddress == msg.sender, \"Only a tx from a node's withdrawal address can update it\");\n        // Update immediately if confirmed\n        if (_confirm) {\n            updateWithdrawalAddress(_nodeAddress, _newWithdrawalAddress);\n        }\n        // Set pending withdrawal address if not confirmed\n        else {\n            pendingWithdrawalAddresses[_nodeAddress] = _newWithdrawalAddress;\n        }\n    }\n\n    // Confirm a node's new withdrawal address\n    function confirmWithdrawalAddress(address _nodeAddress) external override {\n        // Get node by pending withdrawal address\n        require(pendingWithdrawalAddresses[_nodeAddress] == msg.sender, \"Confirmation must come from the pending withdrawal address\");\n        delete pendingWithdrawalAddresses[_nodeAddress];\n        // Update withdrawal address\n        updateWithdrawalAddress(_nodeAddress, msg.sender);\n    }\n\n    // Update a node's withdrawal address\n    function updateWithdrawalAddress(address _nodeAddress, address _newWithdrawalAddress) private {\n        // Set new withdrawal address\n        withdrawalAddresses[_nodeAddress] = _newWithdrawalAddress;\n        // Emit withdrawal address set event\n        emit NodeWithdrawalAddressSet(_nodeAddress, _newWithdrawalAddress, block.timestamp);\n    }\n\n    \n    function getAddress(bytes32 _key) override external view returns (address r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n    \n    function getUint(bytes32 _key) override external view returns (uint256 r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n    \n    function getString(bytes32 _key) override external view returns (string memory) {\n        return stringStorage[_key];\n    }\n\n    \n    function getBytes(bytes32 _key) override external view returns (bytes memory) {\n        return bytesStorage[_key];\n    }\n\n    \n    function getBool(bytes32 _key) override external view returns (bool r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n    \n    function getInt(bytes32 _key) override external view returns (int r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n    \n    function getBytes32(bytes32 _key) override external view returns (bytes32 r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n\n    \n    function setAddress(bytes32 _key, address _value) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n\n    \n    // SWC-124-Write to Arbitrary Storage Location: L206 - L210\n    function setUint(bytes32 _key, uint _value) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n\n    \n    function setString(bytes32 _key, string calldata _value) onlyLatestRocketNetworkContract override external {\n        stringStorage[_key] = _value;\n    }\n\n    \n    function setBytes(bytes32 _key, bytes calldata _value) onlyLatestRocketNetworkContract override external {\n        bytesStorage[_key] = _value;\n    }\n\n    \n    function setBool(bytes32 _key, bool _value) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n\n    \n    // SWC-124-Write to Arbitrary Storage Location: L231 - L235\n    function setInt(bytes32 _key, int _value) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n\n    \n    function setBytes32(bytes32 _key, bytes32 _value) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n\n\n    \n    function deleteAddress(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, 0)\n        }\n    }\n\n    \n    function deleteUint(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, 0)\n        }\n    }\n\n    \n    function deleteString(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        delete stringStorage[_key];\n    }\n\n    \n    function deleteBytes(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        delete bytesStorage[_key];\n    }\n\n    \n    function deleteBool(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, 0)\n        }\n    }\n\n    \n    function deleteInt(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, 0)\n        }\n    }\n\n    \n    function deleteBytes32(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, 0)\n        }\n    }\n\n\n    \n    \n    function addUint(bytes32 _key, uint256 _amount) onlyLatestRocketNetworkContract override external {\n        uint256 a;\n        uint256 b;\n        assembly {\n            a := sload (_key)\n            b := add(a, _amount)\n            sstore (_key, b)\n        }\n        require(b >= a, \"SafeMath: addition overflow\");\n    }\n\n    \n    \n    function subUint(bytes32 _key, uint256 _amount) onlyLatestRocketNetworkContract override external {\n        uint256 a;\n        assembly {\n            a := sload (_key)\n        }\n        require(_amount <= a, \"SafeMath: subtraction overflow\");\n        assembly {\n            a := sub(a, _amount)\n            sstore (_key, a)\n        }\n    }\n\n    // Private methods\n\n    function _getBool(bytes32 _key) private view returns (bool r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n    function _setBool(bytes32 _key, bool _value) private {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n}",
        "function": "setBytes32(bytes32,bytes32)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-RocketPool/rocketpool-a65b203cf99c7a991c2d85a7468a97bfb5dbba31/contracts/contract/RocketStorage.sol",
        "vulnerability": "Dependence on tx.origin (SWC 115)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract RocketStorage is RocketStorageInterface {\n\n    // Events\n    event NodeWithdrawalAddressSet(address indexed node, address indexed withdrawalAddress, uint256 time);\n    event GuardianChanged(address oldGuardian, address newGuardian);\n\n    // Libraries\n    using SafeMath for uint256;\n\n    // Complex storage maps\n    mapping(bytes32 => string)     private stringStorage;\n    mapping(bytes32 => bytes)      private bytesStorage;\n\n    // Protected storage (not accessible by network contracts)\n    mapping(address => address)    private withdrawalAddresses;\n    mapping(address => address)    private pendingWithdrawalAddresses;\n\n    // Guardian address\n    address guardian;\n    address newGuardian;\n\n    // Flag storage has been initialised\n    bool storageInit = false;\n\n    \n    modifier onlyLatestRocketNetworkContract() {\n        if (storageInit == true) {\n            // Make sure the access is permitted to only contracts in our Dapp\n            require(_getBool(keccak256(abi.encodePacked(\"contract.exists\", msg.sender))), \"Invalid or outdated network contract\");\n        } else {\n            // Only Dapp and the guardian account are allowed access during initialisation.\n            // tx.origin is only safe to use in this case for deployment since no external contracts are interacted with\n            // SWC-115-Authorization through tx.origin: L45\n            require((\n                _getBool(keccak256(abi.encodePacked(\"contract.exists\", msg.sender))) || tx.origin == guardian\n            ), \"Invalid or outdated network contract attempting access during deployment\");\n        }\n        _;\n    }\n\n\n    \n    constructor() {\n        // Set the guardian upon deployment\n        guardian = msg.sender;\n    }\n\n    // Get guardian address\n    function getGuardian() external override view returns (address) {\n        return guardian;\n    }\n\n    // Transfers guardianship to a new address\n    function setGuardian(address _newAddress) external override {\n        // Check tx comes from current guardian\n        require(msg.sender == guardian, \"Is not guardian account\");\n        // Store new address awaiting confirmation\n        newGuardian = _newAddress;\n    }\n\n    // Confirms change of guardian\n    function confirmGuardian() external override {\n        // Check tx came from new guardian address\n        require(msg.sender == newGuardian, \"Confirmation must come from new guardian address\");\n        // Store old guardian for event\n        address oldGuardian = guardian;\n        // Update guardian and clear storage\n        guardian = newGuardian;\n        delete newGuardian;\n        // Emit event\n        emit GuardianChanged(oldGuardian, guardian);\n    }\n\n    // Set this as being deployed now\n    function getDeployedStatus() external view returns (bool) {\n        return storageInit;\n    }\n\n    // Set this as being deployed now\n    function setDeployedStatus() external {\n        // Only guardian can lock this down\n        require(msg.sender == guardian, \"Is not guardian account\");\n        // Set it now\n        storageInit = true;\n    }\n\n    // Protected storage\n\n    // Get a node's withdrawal address\n    function getNodeWithdrawalAddress(address _nodeAddress) public override view returns (address) {\n        // Check if _nodeAddress is a valid node\n        if (!_getBool(keccak256(abi.encodePacked(\"node.exists\", _nodeAddress)))) {\n            return address(0);\n        }\n        // If no withdrawal address has been set, return the nodes address\n        address withdrawalAddress = withdrawalAddresses[_nodeAddress];\n        if (withdrawalAddress == address(0)) {\n            return _nodeAddress;\n        }\n        return withdrawalAddress;\n    }\n\n    // Get a node's pending withdrawal address\n    function getNodePendingWithdrawalAddress(address _nodeAddress) external override view returns (address) {\n        return pendingWithdrawalAddresses[_nodeAddress];\n    }\n\n    // Set a node's withdrawal address\n    function setWithdrawalAddress(address _nodeAddress, address _newWithdrawalAddress, bool _confirm) external override {\n        // Check new withdrawal address\n        require(_newWithdrawalAddress != address(0x0), \"Invalid withdrawal address\");\n        // Confirm the transaction is from the node's current withdrawal address\n        address withdrawalAddress = getNodeWithdrawalAddress(_nodeAddress);\n        require(withdrawalAddress == msg.sender, \"Only a tx from a node's withdrawal address can update it\");\n        // Update immediately if confirmed\n        if (_confirm) {\n            updateWithdrawalAddress(_nodeAddress, _newWithdrawalAddress);\n        }\n        // Set pending withdrawal address if not confirmed\n        else {\n            pendingWithdrawalAddresses[_nodeAddress] = _newWithdrawalAddress;\n        }\n    }\n\n    // Confirm a node's new withdrawal address\n    function confirmWithdrawalAddress(address _nodeAddress) external override {\n        // Get node by pending withdrawal address\n        require(pendingWithdrawalAddresses[_nodeAddress] == msg.sender, \"Confirmation must come from the pending withdrawal address\");\n        delete pendingWithdrawalAddresses[_nodeAddress];\n        // Update withdrawal address\n        updateWithdrawalAddress(_nodeAddress, msg.sender);\n    }\n\n    // Update a node's withdrawal address\n    function updateWithdrawalAddress(address _nodeAddress, address _newWithdrawalAddress) private {\n        // Set new withdrawal address\n        withdrawalAddresses[_nodeAddress] = _newWithdrawalAddress;\n        // Emit withdrawal address set event\n        emit NodeWithdrawalAddressSet(_nodeAddress, _newWithdrawalAddress, block.timestamp);\n    }\n\n    \n    function getAddress(bytes32 _key) override external view returns (address r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n    \n    function getUint(bytes32 _key) override external view returns (uint256 r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n    \n    function getString(bytes32 _key) override external view returns (string memory) {\n        return stringStorage[_key];\n    }\n\n    \n    function getBytes(bytes32 _key) override external view returns (bytes memory) {\n        return bytesStorage[_key];\n    }\n\n    \n    function getBool(bytes32 _key) override external view returns (bool r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n    \n    function getInt(bytes32 _key) override external view returns (int r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n    \n    function getBytes32(bytes32 _key) override external view returns (bytes32 r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n\n    \n    function setAddress(bytes32 _key, address _value) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n\n    \n    // SWC-124-Write to Arbitrary Storage Location: L206 - L210\n    function setUint(bytes32 _key, uint _value) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n\n    \n    function setString(bytes32 _key, string calldata _value) onlyLatestRocketNetworkContract override external {\n        stringStorage[_key] = _value;\n    }\n\n    \n    function setBytes(bytes32 _key, bytes calldata _value) onlyLatestRocketNetworkContract override external {\n        bytesStorage[_key] = _value;\n    }\n\n    \n    function setBool(bytes32 _key, bool _value) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n\n    \n    // SWC-124-Write to Arbitrary Storage Location: L231 - L235\n    function setInt(bytes32 _key, int _value) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n\n    \n    function setBytes32(bytes32 _key, bytes32 _value) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n\n\n    \n    function deleteAddress(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, 0)\n        }\n    }\n\n    \n    function deleteUint(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, 0)\n        }\n    }\n\n    \n    function deleteString(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        delete stringStorage[_key];\n    }\n\n    \n    function deleteBytes(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        delete bytesStorage[_key];\n    }\n\n    \n    function deleteBool(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, 0)\n        }\n    }\n\n    \n    function deleteInt(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, 0)\n        }\n    }\n\n    \n    function deleteBytes32(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, 0)\n        }\n    }\n\n\n    \n    \n    function addUint(bytes32 _key, uint256 _amount) onlyLatestRocketNetworkContract override external {\n        uint256 a;\n        uint256 b;\n        assembly {\n            a := sload (_key)\n            b := add(a, _amount)\n            sstore (_key, b)\n        }\n        require(b >= a, \"SafeMath: addition overflow\");\n    }\n\n    \n    \n    function subUint(bytes32 _key, uint256 _amount) onlyLatestRocketNetworkContract override external {\n        uint256 a;\n        assembly {\n            a := sload (_key)\n        }\n        require(_amount <= a, \"SafeMath: subtraction overflow\");\n        assembly {\n            a := sub(a, _amount)\n            sstore (_key, a)\n        }\n    }\n\n    // Private methods\n\n    function _getBool(bytes32 _key) private view returns (bool r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n    function _setBool(bytes32 _key, bool _value) private {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n}",
        "function": "setBytes32(bytes32,bytes32)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-RocketPool/rocketpool-a65b203cf99c7a991c2d85a7468a97bfb5dbba31/contracts/contract/RocketStorage.sol",
        "vulnerability": "Write to an arbitrary storage location (SWC 124)",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract RocketStorage is RocketStorageInterface {\n\n    // Events\n    event NodeWithdrawalAddressSet(address indexed node, address indexed withdrawalAddress, uint256 time);\n    event GuardianChanged(address oldGuardian, address newGuardian);\n\n    // Libraries\n    using SafeMath for uint256;\n\n    // Complex storage maps\n    mapping(bytes32 => string)     private stringStorage;\n    mapping(bytes32 => bytes)      private bytesStorage;\n\n    // Protected storage (not accessible by network contracts)\n    mapping(address => address)    private withdrawalAddresses;\n    mapping(address => address)    private pendingWithdrawalAddresses;\n\n    // Guardian address\n    address guardian;\n    address newGuardian;\n\n    // Flag storage has been initialised\n    bool storageInit = false;\n\n    \n    modifier onlyLatestRocketNetworkContract() {\n        if (storageInit == true) {\n            // Make sure the access is permitted to only contracts in our Dapp\n            require(_getBool(keccak256(abi.encodePacked(\"contract.exists\", msg.sender))), \"Invalid or outdated network contract\");\n        } else {\n            // Only Dapp and the guardian account are allowed access during initialisation.\n            // tx.origin is only safe to use in this case for deployment since no external contracts are interacted with\n            // SWC-115-Authorization through tx.origin: L45\n            require((\n                _getBool(keccak256(abi.encodePacked(\"contract.exists\", msg.sender))) || tx.origin == guardian\n            ), \"Invalid or outdated network contract attempting access during deployment\");\n        }\n        _;\n    }\n\n\n    \n    constructor() {\n        // Set the guardian upon deployment\n        guardian = msg.sender;\n    }\n\n    // Get guardian address\n    function getGuardian() external override view returns (address) {\n        return guardian;\n    }\n\n    // Transfers guardianship to a new address\n    function setGuardian(address _newAddress) external override {\n        // Check tx comes from current guardian\n        require(msg.sender == guardian, \"Is not guardian account\");\n        // Store new address awaiting confirmation\n        newGuardian = _newAddress;\n    }\n\n    // Confirms change of guardian\n    function confirmGuardian() external override {\n        // Check tx came from new guardian address\n        require(msg.sender == newGuardian, \"Confirmation must come from new guardian address\");\n        // Store old guardian for event\n        address oldGuardian = guardian;\n        // Update guardian and clear storage\n        guardian = newGuardian;\n        delete newGuardian;\n        // Emit event\n        emit GuardianChanged(oldGuardian, guardian);\n    }\n\n    // Set this as being deployed now\n    function getDeployedStatus() external view returns (bool) {\n        return storageInit;\n    }\n\n    // Set this as being deployed now\n    function setDeployedStatus() external {\n        // Only guardian can lock this down\n        require(msg.sender == guardian, \"Is not guardian account\");\n        // Set it now\n        storageInit = true;\n    }\n\n    // Protected storage\n\n    // Get a node's withdrawal address\n    function getNodeWithdrawalAddress(address _nodeAddress) public override view returns (address) {\n        // Check if _nodeAddress is a valid node\n        if (!_getBool(keccak256(abi.encodePacked(\"node.exists\", _nodeAddress)))) {\n            return address(0);\n        }\n        // If no withdrawal address has been set, return the nodes address\n        address withdrawalAddress = withdrawalAddresses[_nodeAddress];\n        if (withdrawalAddress == address(0)) {\n            return _nodeAddress;\n        }\n        return withdrawalAddress;\n    }\n\n    // Get a node's pending withdrawal address\n    function getNodePendingWithdrawalAddress(address _nodeAddress) external override view returns (address) {\n        return pendingWithdrawalAddresses[_nodeAddress];\n    }\n\n    // Set a node's withdrawal address\n    function setWithdrawalAddress(address _nodeAddress, address _newWithdrawalAddress, bool _confirm) external override {\n        // Check new withdrawal address\n        require(_newWithdrawalAddress != address(0x0), \"Invalid withdrawal address\");\n        // Confirm the transaction is from the node's current withdrawal address\n        address withdrawalAddress = getNodeWithdrawalAddress(_nodeAddress);\n        require(withdrawalAddress == msg.sender, \"Only a tx from a node's withdrawal address can update it\");\n        // Update immediately if confirmed\n        if (_confirm) {\n            updateWithdrawalAddress(_nodeAddress, _newWithdrawalAddress);\n        }\n        // Set pending withdrawal address if not confirmed\n        else {\n            pendingWithdrawalAddresses[_nodeAddress] = _newWithdrawalAddress;\n        }\n    }\n\n    // Confirm a node's new withdrawal address\n    function confirmWithdrawalAddress(address _nodeAddress) external override {\n        // Get node by pending withdrawal address\n        require(pendingWithdrawalAddresses[_nodeAddress] == msg.sender, \"Confirmation must come from the pending withdrawal address\");\n        delete pendingWithdrawalAddresses[_nodeAddress];\n        // Update withdrawal address\n        updateWithdrawalAddress(_nodeAddress, msg.sender);\n    }\n\n    // Update a node's withdrawal address\n    function updateWithdrawalAddress(address _nodeAddress, address _newWithdrawalAddress) private {\n        // Set new withdrawal address\n        withdrawalAddresses[_nodeAddress] = _newWithdrawalAddress;\n        // Emit withdrawal address set event\n        emit NodeWithdrawalAddressSet(_nodeAddress, _newWithdrawalAddress, block.timestamp);\n    }\n\n    \n    function getAddress(bytes32 _key) override external view returns (address r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n    \n    function getUint(bytes32 _key) override external view returns (uint256 r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n    \n    function getString(bytes32 _key) override external view returns (string memory) {\n        return stringStorage[_key];\n    }\n\n    \n    function getBytes(bytes32 _key) override external view returns (bytes memory) {\n        return bytesStorage[_key];\n    }\n\n    \n    function getBool(bytes32 _key) override external view returns (bool r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n    \n    function getInt(bytes32 _key) override external view returns (int r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n    \n    function getBytes32(bytes32 _key) override external view returns (bytes32 r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n\n    \n    function setAddress(bytes32 _key, address _value) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n\n    \n    // SWC-124-Write to Arbitrary Storage Location: L206 - L210\n    function setUint(bytes32 _key, uint _value) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n\n    \n    function setString(bytes32 _key, string calldata _value) onlyLatestRocketNetworkContract override external {\n        stringStorage[_key] = _value;\n    }\n\n    \n    function setBytes(bytes32 _key, bytes calldata _value) onlyLatestRocketNetworkContract override external {\n        bytesStorage[_key] = _value;\n    }\n\n    \n    function setBool(bytes32 _key, bool _value) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n\n    \n    // SWC-124-Write to Arbitrary Storage Location: L231 - L235\n    function setInt(bytes32 _key, int _value) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n\n    \n    function setBytes32(bytes32 _key, bytes32 _value) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n\n\n    \n    function deleteAddress(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, 0)\n        }\n    }\n\n    \n    function deleteUint(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, 0)\n        }\n    }\n\n    \n    function deleteString(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        delete stringStorage[_key];\n    }\n\n    \n    function deleteBytes(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        delete bytesStorage[_key];\n    }\n\n    \n    function deleteBool(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, 0)\n        }\n    }\n\n    \n    function deleteInt(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, 0)\n        }\n    }\n\n    \n    function deleteBytes32(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, 0)\n        }\n    }\n\n\n    \n    \n    function addUint(bytes32 _key, uint256 _amount) onlyLatestRocketNetworkContract override external {\n        uint256 a;\n        uint256 b;\n        assembly {\n            a := sload (_key)\n            b := add(a, _amount)\n            sstore (_key, b)\n        }\n        require(b >= a, \"SafeMath: addition overflow\");\n    }\n\n    \n    \n    function subUint(bytes32 _key, uint256 _amount) onlyLatestRocketNetworkContract override external {\n        uint256 a;\n        assembly {\n            a := sload (_key)\n        }\n        require(_amount <= a, \"SafeMath: subtraction overflow\");\n        assembly {\n            a := sub(a, _amount)\n            sstore (_key, a)\n        }\n    }\n\n    // Private methods\n\n    function _getBool(bytes32 _key) private view returns (bool r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n    function _setBool(bytes32 _key, bool _value) private {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n}",
        "function": "deleteBytes(bytes32)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-RocketPool/rocketpool-a65b203cf99c7a991c2d85a7468a97bfb5dbba31/contracts/contract/RocketStorage.sol",
        "vulnerability": "Dependence on tx.origin (SWC 115)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract RocketStorage is RocketStorageInterface {\n\n    // Events\n    event NodeWithdrawalAddressSet(address indexed node, address indexed withdrawalAddress, uint256 time);\n    event GuardianChanged(address oldGuardian, address newGuardian);\n\n    // Libraries\n    using SafeMath for uint256;\n\n    // Complex storage maps\n    mapping(bytes32 => string)     private stringStorage;\n    mapping(bytes32 => bytes)      private bytesStorage;\n\n    // Protected storage (not accessible by network contracts)\n    mapping(address => address)    private withdrawalAddresses;\n    mapping(address => address)    private pendingWithdrawalAddresses;\n\n    // Guardian address\n    address guardian;\n    address newGuardian;\n\n    // Flag storage has been initialised\n    bool storageInit = false;\n\n    \n    modifier onlyLatestRocketNetworkContract() {\n        if (storageInit == true) {\n            // Make sure the access is permitted to only contracts in our Dapp\n            require(_getBool(keccak256(abi.encodePacked(\"contract.exists\", msg.sender))), \"Invalid or outdated network contract\");\n        } else {\n            // Only Dapp and the guardian account are allowed access during initialisation.\n            // tx.origin is only safe to use in this case for deployment since no external contracts are interacted with\n            // SWC-115-Authorization through tx.origin: L45\n            require((\n                _getBool(keccak256(abi.encodePacked(\"contract.exists\", msg.sender))) || tx.origin == guardian\n            ), \"Invalid or outdated network contract attempting access during deployment\");\n        }\n        _;\n    }\n\n\n    \n    constructor() {\n        // Set the guardian upon deployment\n        guardian = msg.sender;\n    }\n\n    // Get guardian address\n    function getGuardian() external override view returns (address) {\n        return guardian;\n    }\n\n    // Transfers guardianship to a new address\n    function setGuardian(address _newAddress) external override {\n        // Check tx comes from current guardian\n        require(msg.sender == guardian, \"Is not guardian account\");\n        // Store new address awaiting confirmation\n        newGuardian = _newAddress;\n    }\n\n    // Confirms change of guardian\n    function confirmGuardian() external override {\n        // Check tx came from new guardian address\n        require(msg.sender == newGuardian, \"Confirmation must come from new guardian address\");\n        // Store old guardian for event\n        address oldGuardian = guardian;\n        // Update guardian and clear storage\n        guardian = newGuardian;\n        delete newGuardian;\n        // Emit event\n        emit GuardianChanged(oldGuardian, guardian);\n    }\n\n    // Set this as being deployed now\n    function getDeployedStatus() external view returns (bool) {\n        return storageInit;\n    }\n\n    // Set this as being deployed now\n    function setDeployedStatus() external {\n        // Only guardian can lock this down\n        require(msg.sender == guardian, \"Is not guardian account\");\n        // Set it now\n        storageInit = true;\n    }\n\n    // Protected storage\n\n    // Get a node's withdrawal address\n    function getNodeWithdrawalAddress(address _nodeAddress) public override view returns (address) {\n        // Check if _nodeAddress is a valid node\n        if (!_getBool(keccak256(abi.encodePacked(\"node.exists\", _nodeAddress)))) {\n            return address(0);\n        }\n        // If no withdrawal address has been set, return the nodes address\n        address withdrawalAddress = withdrawalAddresses[_nodeAddress];\n        if (withdrawalAddress == address(0)) {\n            return _nodeAddress;\n        }\n        return withdrawalAddress;\n    }\n\n    // Get a node's pending withdrawal address\n    function getNodePendingWithdrawalAddress(address _nodeAddress) external override view returns (address) {\n        return pendingWithdrawalAddresses[_nodeAddress];\n    }\n\n    // Set a node's withdrawal address\n    function setWithdrawalAddress(address _nodeAddress, address _newWithdrawalAddress, bool _confirm) external override {\n        // Check new withdrawal address\n        require(_newWithdrawalAddress != address(0x0), \"Invalid withdrawal address\");\n        // Confirm the transaction is from the node's current withdrawal address\n        address withdrawalAddress = getNodeWithdrawalAddress(_nodeAddress);\n        require(withdrawalAddress == msg.sender, \"Only a tx from a node's withdrawal address can update it\");\n        // Update immediately if confirmed\n        if (_confirm) {\n            updateWithdrawalAddress(_nodeAddress, _newWithdrawalAddress);\n        }\n        // Set pending withdrawal address if not confirmed\n        else {\n            pendingWithdrawalAddresses[_nodeAddress] = _newWithdrawalAddress;\n        }\n    }\n\n    // Confirm a node's new withdrawal address\n    function confirmWithdrawalAddress(address _nodeAddress) external override {\n        // Get node by pending withdrawal address\n        require(pendingWithdrawalAddresses[_nodeAddress] == msg.sender, \"Confirmation must come from the pending withdrawal address\");\n        delete pendingWithdrawalAddresses[_nodeAddress];\n        // Update withdrawal address\n        updateWithdrawalAddress(_nodeAddress, msg.sender);\n    }\n\n    // Update a node's withdrawal address\n    function updateWithdrawalAddress(address _nodeAddress, address _newWithdrawalAddress) private {\n        // Set new withdrawal address\n        withdrawalAddresses[_nodeAddress] = _newWithdrawalAddress;\n        // Emit withdrawal address set event\n        emit NodeWithdrawalAddressSet(_nodeAddress, _newWithdrawalAddress, block.timestamp);\n    }\n\n    \n    function getAddress(bytes32 _key) override external view returns (address r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n    \n    function getUint(bytes32 _key) override external view returns (uint256 r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n    \n    function getString(bytes32 _key) override external view returns (string memory) {\n        return stringStorage[_key];\n    }\n\n    \n    function getBytes(bytes32 _key) override external view returns (bytes memory) {\n        return bytesStorage[_key];\n    }\n\n    \n    function getBool(bytes32 _key) override external view returns (bool r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n    \n    function getInt(bytes32 _key) override external view returns (int r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n    \n    function getBytes32(bytes32 _key) override external view returns (bytes32 r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n\n    \n    function setAddress(bytes32 _key, address _value) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n\n    \n    // SWC-124-Write to Arbitrary Storage Location: L206 - L210\n    function setUint(bytes32 _key, uint _value) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n\n    \n    function setString(bytes32 _key, string calldata _value) onlyLatestRocketNetworkContract override external {\n        stringStorage[_key] = _value;\n    }\n\n    \n    function setBytes(bytes32 _key, bytes calldata _value) onlyLatestRocketNetworkContract override external {\n        bytesStorage[_key] = _value;\n    }\n\n    \n    function setBool(bytes32 _key, bool _value) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n\n    \n    // SWC-124-Write to Arbitrary Storage Location: L231 - L235\n    function setInt(bytes32 _key, int _value) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n\n    \n    function setBytes32(bytes32 _key, bytes32 _value) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n\n\n    \n    function deleteAddress(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, 0)\n        }\n    }\n\n    \n    function deleteUint(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, 0)\n        }\n    }\n\n    \n    function deleteString(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        delete stringStorage[_key];\n    }\n\n    \n    function deleteBytes(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        delete bytesStorage[_key];\n    }\n\n    \n    function deleteBool(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, 0)\n        }\n    }\n\n    \n    function deleteInt(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, 0)\n        }\n    }\n\n    \n    function deleteBytes32(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, 0)\n        }\n    }\n\n\n    \n    \n    function addUint(bytes32 _key, uint256 _amount) onlyLatestRocketNetworkContract override external {\n        uint256 a;\n        uint256 b;\n        assembly {\n            a := sload (_key)\n            b := add(a, _amount)\n            sstore (_key, b)\n        }\n        require(b >= a, \"SafeMath: addition overflow\");\n    }\n\n    \n    \n    function subUint(bytes32 _key, uint256 _amount) onlyLatestRocketNetworkContract override external {\n        uint256 a;\n        assembly {\n            a := sload (_key)\n        }\n        require(_amount <= a, \"SafeMath: subtraction overflow\");\n        assembly {\n            a := sub(a, _amount)\n            sstore (_key, a)\n        }\n    }\n\n    // Private methods\n\n    function _getBool(bytes32 _key) private view returns (bool r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n    function _setBool(bytes32 _key, bool _value) private {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n}",
        "function": "setString(bytes32,string)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-RocketPool/rocketpool-a65b203cf99c7a991c2d85a7468a97bfb5dbba31/contracts/contract/RocketStorage.sol",
        "vulnerability": "Dependence on tx.origin (SWC 115)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract RocketStorage is RocketStorageInterface {\n\n    // Events\n    event NodeWithdrawalAddressSet(address indexed node, address indexed withdrawalAddress, uint256 time);\n    event GuardianChanged(address oldGuardian, address newGuardian);\n\n    // Libraries\n    using SafeMath for uint256;\n\n    // Complex storage maps\n    mapping(bytes32 => string)     private stringStorage;\n    mapping(bytes32 => bytes)      private bytesStorage;\n\n    // Protected storage (not accessible by network contracts)\n    mapping(address => address)    private withdrawalAddresses;\n    mapping(address => address)    private pendingWithdrawalAddresses;\n\n    // Guardian address\n    address guardian;\n    address newGuardian;\n\n    // Flag storage has been initialised\n    bool storageInit = false;\n\n    \n    modifier onlyLatestRocketNetworkContract() {\n        if (storageInit == true) {\n            // Make sure the access is permitted to only contracts in our Dapp\n            require(_getBool(keccak256(abi.encodePacked(\"contract.exists\", msg.sender))), \"Invalid or outdated network contract\");\n        } else {\n            // Only Dapp and the guardian account are allowed access during initialisation.\n            // tx.origin is only safe to use in this case for deployment since no external contracts are interacted with\n            // SWC-115-Authorization through tx.origin: L45\n            require((\n                _getBool(keccak256(abi.encodePacked(\"contract.exists\", msg.sender))) || tx.origin == guardian\n            ), \"Invalid or outdated network contract attempting access during deployment\");\n        }\n        _;\n    }\n\n\n    \n    constructor() {\n        // Set the guardian upon deployment\n        guardian = msg.sender;\n    }\n\n    // Get guardian address\n    function getGuardian() external override view returns (address) {\n        return guardian;\n    }\n\n    // Transfers guardianship to a new address\n    function setGuardian(address _newAddress) external override {\n        // Check tx comes from current guardian\n        require(msg.sender == guardian, \"Is not guardian account\");\n        // Store new address awaiting confirmation\n        newGuardian = _newAddress;\n    }\n\n    // Confirms change of guardian\n    function confirmGuardian() external override {\n        // Check tx came from new guardian address\n        require(msg.sender == newGuardian, \"Confirmation must come from new guardian address\");\n        // Store old guardian for event\n        address oldGuardian = guardian;\n        // Update guardian and clear storage\n        guardian = newGuardian;\n        delete newGuardian;\n        // Emit event\n        emit GuardianChanged(oldGuardian, guardian);\n    }\n\n    // Set this as being deployed now\n    function getDeployedStatus() external view returns (bool) {\n        return storageInit;\n    }\n\n    // Set this as being deployed now\n    function setDeployedStatus() external {\n        // Only guardian can lock this down\n        require(msg.sender == guardian, \"Is not guardian account\");\n        // Set it now\n        storageInit = true;\n    }\n\n    // Protected storage\n\n    // Get a node's withdrawal address\n    function getNodeWithdrawalAddress(address _nodeAddress) public override view returns (address) {\n        // Check if _nodeAddress is a valid node\n        if (!_getBool(keccak256(abi.encodePacked(\"node.exists\", _nodeAddress)))) {\n            return address(0);\n        }\n        // If no withdrawal address has been set, return the nodes address\n        address withdrawalAddress = withdrawalAddresses[_nodeAddress];\n        if (withdrawalAddress == address(0)) {\n            return _nodeAddress;\n        }\n        return withdrawalAddress;\n    }\n\n    // Get a node's pending withdrawal address\n    function getNodePendingWithdrawalAddress(address _nodeAddress) external override view returns (address) {\n        return pendingWithdrawalAddresses[_nodeAddress];\n    }\n\n    // Set a node's withdrawal address\n    function setWithdrawalAddress(address _nodeAddress, address _newWithdrawalAddress, bool _confirm) external override {\n        // Check new withdrawal address\n        require(_newWithdrawalAddress != address(0x0), \"Invalid withdrawal address\");\n        // Confirm the transaction is from the node's current withdrawal address\n        address withdrawalAddress = getNodeWithdrawalAddress(_nodeAddress);\n        require(withdrawalAddress == msg.sender, \"Only a tx from a node's withdrawal address can update it\");\n        // Update immediately if confirmed\n        if (_confirm) {\n            updateWithdrawalAddress(_nodeAddress, _newWithdrawalAddress);\n        }\n        // Set pending withdrawal address if not confirmed\n        else {\n            pendingWithdrawalAddresses[_nodeAddress] = _newWithdrawalAddress;\n        }\n    }\n\n    // Confirm a node's new withdrawal address\n    function confirmWithdrawalAddress(address _nodeAddress) external override {\n        // Get node by pending withdrawal address\n        require(pendingWithdrawalAddresses[_nodeAddress] == msg.sender, \"Confirmation must come from the pending withdrawal address\");\n        delete pendingWithdrawalAddresses[_nodeAddress];\n        // Update withdrawal address\n        updateWithdrawalAddress(_nodeAddress, msg.sender);\n    }\n\n    // Update a node's withdrawal address\n    function updateWithdrawalAddress(address _nodeAddress, address _newWithdrawalAddress) private {\n        // Set new withdrawal address\n        withdrawalAddresses[_nodeAddress] = _newWithdrawalAddress;\n        // Emit withdrawal address set event\n        emit NodeWithdrawalAddressSet(_nodeAddress, _newWithdrawalAddress, block.timestamp);\n    }\n\n    \n    function getAddress(bytes32 _key) override external view returns (address r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n    \n    function getUint(bytes32 _key) override external view returns (uint256 r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n    \n    function getString(bytes32 _key) override external view returns (string memory) {\n        return stringStorage[_key];\n    }\n\n    \n    function getBytes(bytes32 _key) override external view returns (bytes memory) {\n        return bytesStorage[_key];\n    }\n\n    \n    function getBool(bytes32 _key) override external view returns (bool r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n    \n    function getInt(bytes32 _key) override external view returns (int r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n    \n    function getBytes32(bytes32 _key) override external view returns (bytes32 r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n\n    \n    function setAddress(bytes32 _key, address _value) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n\n    \n    // SWC-124-Write to Arbitrary Storage Location: L206 - L210\n    function setUint(bytes32 _key, uint _value) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n\n    \n    function setString(bytes32 _key, string calldata _value) onlyLatestRocketNetworkContract override external {\n        stringStorage[_key] = _value;\n    }\n\n    \n    function setBytes(bytes32 _key, bytes calldata _value) onlyLatestRocketNetworkContract override external {\n        bytesStorage[_key] = _value;\n    }\n\n    \n    function setBool(bytes32 _key, bool _value) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n\n    \n    // SWC-124-Write to Arbitrary Storage Location: L231 - L235\n    function setInt(bytes32 _key, int _value) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n\n    \n    function setBytes32(bytes32 _key, bytes32 _value) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n\n\n    \n    function deleteAddress(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, 0)\n        }\n    }\n\n    \n    function deleteUint(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, 0)\n        }\n    }\n\n    \n    function deleteString(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        delete stringStorage[_key];\n    }\n\n    \n    function deleteBytes(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        delete bytesStorage[_key];\n    }\n\n    \n    function deleteBool(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, 0)\n        }\n    }\n\n    \n    function deleteInt(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, 0)\n        }\n    }\n\n    \n    function deleteBytes32(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, 0)\n        }\n    }\n\n\n    \n    \n    function addUint(bytes32 _key, uint256 _amount) onlyLatestRocketNetworkContract override external {\n        uint256 a;\n        uint256 b;\n        assembly {\n            a := sload (_key)\n            b := add(a, _amount)\n            sstore (_key, b)\n        }\n        require(b >= a, \"SafeMath: addition overflow\");\n    }\n\n    \n    \n    function subUint(bytes32 _key, uint256 _amount) onlyLatestRocketNetworkContract override external {\n        uint256 a;\n        assembly {\n            a := sload (_key)\n        }\n        require(_amount <= a, \"SafeMath: subtraction overflow\");\n        assembly {\n            a := sub(a, _amount)\n            sstore (_key, a)\n        }\n    }\n\n    // Private methods\n\n    function _getBool(bytes32 _key) private view returns (bool r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n    function _setBool(bytes32 _key, bool _value) private {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n}",
        "function": "deleteInt(bytes32)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-RocketPool/rocketpool-a65b203cf99c7a991c2d85a7468a97bfb5dbba31/contracts/contract/RocketStorage.sol",
        "vulnerability": "Dependence on tx.origin (SWC 115)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract RocketStorage is RocketStorageInterface {\n\n    // Events\n    event NodeWithdrawalAddressSet(address indexed node, address indexed withdrawalAddress, uint256 time);\n    event GuardianChanged(address oldGuardian, address newGuardian);\n\n    // Libraries\n    using SafeMath for uint256;\n\n    // Complex storage maps\n    mapping(bytes32 => string)     private stringStorage;\n    mapping(bytes32 => bytes)      private bytesStorage;\n\n    // Protected storage (not accessible by network contracts)\n    mapping(address => address)    private withdrawalAddresses;\n    mapping(address => address)    private pendingWithdrawalAddresses;\n\n    // Guardian address\n    address guardian;\n    address newGuardian;\n\n    // Flag storage has been initialised\n    bool storageInit = false;\n\n    \n    modifier onlyLatestRocketNetworkContract() {\n        if (storageInit == true) {\n            // Make sure the access is permitted to only contracts in our Dapp\n            require(_getBool(keccak256(abi.encodePacked(\"contract.exists\", msg.sender))), \"Invalid or outdated network contract\");\n        } else {\n            // Only Dapp and the guardian account are allowed access during initialisation.\n            // tx.origin is only safe to use in this case for deployment since no external contracts are interacted with\n            // SWC-115-Authorization through tx.origin: L45\n            require((\n                _getBool(keccak256(abi.encodePacked(\"contract.exists\", msg.sender))) || tx.origin == guardian\n            ), \"Invalid or outdated network contract attempting access during deployment\");\n        }\n        _;\n    }\n\n\n    \n    constructor() {\n        // Set the guardian upon deployment\n        guardian = msg.sender;\n    }\n\n    // Get guardian address\n    function getGuardian() external override view returns (address) {\n        return guardian;\n    }\n\n    // Transfers guardianship to a new address\n    function setGuardian(address _newAddress) external override {\n        // Check tx comes from current guardian\n        require(msg.sender == guardian, \"Is not guardian account\");\n        // Store new address awaiting confirmation\n        newGuardian = _newAddress;\n    }\n\n    // Confirms change of guardian\n    function confirmGuardian() external override {\n        // Check tx came from new guardian address\n        require(msg.sender == newGuardian, \"Confirmation must come from new guardian address\");\n        // Store old guardian for event\n        address oldGuardian = guardian;\n        // Update guardian and clear storage\n        guardian = newGuardian;\n        delete newGuardian;\n        // Emit event\n        emit GuardianChanged(oldGuardian, guardian);\n    }\n\n    // Set this as being deployed now\n    function getDeployedStatus() external view returns (bool) {\n        return storageInit;\n    }\n\n    // Set this as being deployed now\n    function setDeployedStatus() external {\n        // Only guardian can lock this down\n        require(msg.sender == guardian, \"Is not guardian account\");\n        // Set it now\n        storageInit = true;\n    }\n\n    // Protected storage\n\n    // Get a node's withdrawal address\n    function getNodeWithdrawalAddress(address _nodeAddress) public override view returns (address) {\n        // Check if _nodeAddress is a valid node\n        if (!_getBool(keccak256(abi.encodePacked(\"node.exists\", _nodeAddress)))) {\n            return address(0);\n        }\n        // If no withdrawal address has been set, return the nodes address\n        address withdrawalAddress = withdrawalAddresses[_nodeAddress];\n        if (withdrawalAddress == address(0)) {\n            return _nodeAddress;\n        }\n        return withdrawalAddress;\n    }\n\n    // Get a node's pending withdrawal address\n    function getNodePendingWithdrawalAddress(address _nodeAddress) external override view returns (address) {\n        return pendingWithdrawalAddresses[_nodeAddress];\n    }\n\n    // Set a node's withdrawal address\n    function setWithdrawalAddress(address _nodeAddress, address _newWithdrawalAddress, bool _confirm) external override {\n        // Check new withdrawal address\n        require(_newWithdrawalAddress != address(0x0), \"Invalid withdrawal address\");\n        // Confirm the transaction is from the node's current withdrawal address\n        address withdrawalAddress = getNodeWithdrawalAddress(_nodeAddress);\n        require(withdrawalAddress == msg.sender, \"Only a tx from a node's withdrawal address can update it\");\n        // Update immediately if confirmed\n        if (_confirm) {\n            updateWithdrawalAddress(_nodeAddress, _newWithdrawalAddress);\n        }\n        // Set pending withdrawal address if not confirmed\n        else {\n            pendingWithdrawalAddresses[_nodeAddress] = _newWithdrawalAddress;\n        }\n    }\n\n    // Confirm a node's new withdrawal address\n    function confirmWithdrawalAddress(address _nodeAddress) external override {\n        // Get node by pending withdrawal address\n        require(pendingWithdrawalAddresses[_nodeAddress] == msg.sender, \"Confirmation must come from the pending withdrawal address\");\n        delete pendingWithdrawalAddresses[_nodeAddress];\n        // Update withdrawal address\n        updateWithdrawalAddress(_nodeAddress, msg.sender);\n    }\n\n    // Update a node's withdrawal address\n    function updateWithdrawalAddress(address _nodeAddress, address _newWithdrawalAddress) private {\n        // Set new withdrawal address\n        withdrawalAddresses[_nodeAddress] = _newWithdrawalAddress;\n        // Emit withdrawal address set event\n        emit NodeWithdrawalAddressSet(_nodeAddress, _newWithdrawalAddress, block.timestamp);\n    }\n\n    \n    function getAddress(bytes32 _key) override external view returns (address r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n    \n    function getUint(bytes32 _key) override external view returns (uint256 r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n    \n    function getString(bytes32 _key) override external view returns (string memory) {\n        return stringStorage[_key];\n    }\n\n    \n    function getBytes(bytes32 _key) override external view returns (bytes memory) {\n        return bytesStorage[_key];\n    }\n\n    \n    function getBool(bytes32 _key) override external view returns (bool r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n    \n    function getInt(bytes32 _key) override external view returns (int r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n    \n    function getBytes32(bytes32 _key) override external view returns (bytes32 r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n\n    \n    function setAddress(bytes32 _key, address _value) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n\n    \n    // SWC-124-Write to Arbitrary Storage Location: L206 - L210\n    function setUint(bytes32 _key, uint _value) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n\n    \n    function setString(bytes32 _key, string calldata _value) onlyLatestRocketNetworkContract override external {\n        stringStorage[_key] = _value;\n    }\n\n    \n    function setBytes(bytes32 _key, bytes calldata _value) onlyLatestRocketNetworkContract override external {\n        bytesStorage[_key] = _value;\n    }\n\n    \n    function setBool(bytes32 _key, bool _value) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n\n    \n    // SWC-124-Write to Arbitrary Storage Location: L231 - L235\n    function setInt(bytes32 _key, int _value) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n\n    \n    function setBytes32(bytes32 _key, bytes32 _value) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n\n\n    \n    function deleteAddress(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, 0)\n        }\n    }\n\n    \n    function deleteUint(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, 0)\n        }\n    }\n\n    \n    function deleteString(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        delete stringStorage[_key];\n    }\n\n    \n    function deleteBytes(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        delete bytesStorage[_key];\n    }\n\n    \n    function deleteBool(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, 0)\n        }\n    }\n\n    \n    function deleteInt(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, 0)\n        }\n    }\n\n    \n    function deleteBytes32(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, 0)\n        }\n    }\n\n\n    \n    \n    function addUint(bytes32 _key, uint256 _amount) onlyLatestRocketNetworkContract override external {\n        uint256 a;\n        uint256 b;\n        assembly {\n            a := sload (_key)\n            b := add(a, _amount)\n            sstore (_key, b)\n        }\n        require(b >= a, \"SafeMath: addition overflow\");\n    }\n\n    \n    \n    function subUint(bytes32 _key, uint256 _amount) onlyLatestRocketNetworkContract override external {\n        uint256 a;\n        assembly {\n            a := sload (_key)\n        }\n        require(_amount <= a, \"SafeMath: subtraction overflow\");\n        assembly {\n            a := sub(a, _amount)\n            sstore (_key, a)\n        }\n    }\n\n    // Private methods\n\n    function _getBool(bytes32 _key) private view returns (bool r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n    function _setBool(bytes32 _key, bool _value) private {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n}",
        "function": "deleteInt(bytes32)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-RocketPool/rocketpool-a65b203cf99c7a991c2d85a7468a97bfb5dbba31/contracts/contract/RocketStorage.sol",
        "vulnerability": "Write to an arbitrary storage location (SWC 124)",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract RocketStorage is RocketStorageInterface {\n\n    // Events\n    event NodeWithdrawalAddressSet(address indexed node, address indexed withdrawalAddress, uint256 time);\n    event GuardianChanged(address oldGuardian, address newGuardian);\n\n    // Libraries\n    using SafeMath for uint256;\n\n    // Complex storage maps\n    mapping(bytes32 => string)     private stringStorage;\n    mapping(bytes32 => bytes)      private bytesStorage;\n\n    // Protected storage (not accessible by network contracts)\n    mapping(address => address)    private withdrawalAddresses;\n    mapping(address => address)    private pendingWithdrawalAddresses;\n\n    // Guardian address\n    address guardian;\n    address newGuardian;\n\n    // Flag storage has been initialised\n    bool storageInit = false;\n\n    \n    modifier onlyLatestRocketNetworkContract() {\n        if (storageInit == true) {\n            // Make sure the access is permitted to only contracts in our Dapp\n            require(_getBool(keccak256(abi.encodePacked(\"contract.exists\", msg.sender))), \"Invalid or outdated network contract\");\n        } else {\n            // Only Dapp and the guardian account are allowed access during initialisation.\n            // tx.origin is only safe to use in this case for deployment since no external contracts are interacted with\n            // SWC-115-Authorization through tx.origin: L45\n            require((\n                _getBool(keccak256(abi.encodePacked(\"contract.exists\", msg.sender))) || tx.origin == guardian\n            ), \"Invalid or outdated network contract attempting access during deployment\");\n        }\n        _;\n    }\n\n\n    \n    constructor() {\n        // Set the guardian upon deployment\n        guardian = msg.sender;\n    }\n\n    // Get guardian address\n    function getGuardian() external override view returns (address) {\n        return guardian;\n    }\n\n    // Transfers guardianship to a new address\n    function setGuardian(address _newAddress) external override {\n        // Check tx comes from current guardian\n        require(msg.sender == guardian, \"Is not guardian account\");\n        // Store new address awaiting confirmation\n        newGuardian = _newAddress;\n    }\n\n    // Confirms change of guardian\n    function confirmGuardian() external override {\n        // Check tx came from new guardian address\n        require(msg.sender == newGuardian, \"Confirmation must come from new guardian address\");\n        // Store old guardian for event\n        address oldGuardian = guardian;\n        // Update guardian and clear storage\n        guardian = newGuardian;\n        delete newGuardian;\n        // Emit event\n        emit GuardianChanged(oldGuardian, guardian);\n    }\n\n    // Set this as being deployed now\n    function getDeployedStatus() external view returns (bool) {\n        return storageInit;\n    }\n\n    // Set this as being deployed now\n    function setDeployedStatus() external {\n        // Only guardian can lock this down\n        require(msg.sender == guardian, \"Is not guardian account\");\n        // Set it now\n        storageInit = true;\n    }\n\n    // Protected storage\n\n    // Get a node's withdrawal address\n    function getNodeWithdrawalAddress(address _nodeAddress) public override view returns (address) {\n        // Check if _nodeAddress is a valid node\n        if (!_getBool(keccak256(abi.encodePacked(\"node.exists\", _nodeAddress)))) {\n            return address(0);\n        }\n        // If no withdrawal address has been set, return the nodes address\n        address withdrawalAddress = withdrawalAddresses[_nodeAddress];\n        if (withdrawalAddress == address(0)) {\n            return _nodeAddress;\n        }\n        return withdrawalAddress;\n    }\n\n    // Get a node's pending withdrawal address\n    function getNodePendingWithdrawalAddress(address _nodeAddress) external override view returns (address) {\n        return pendingWithdrawalAddresses[_nodeAddress];\n    }\n\n    // Set a node's withdrawal address\n    function setWithdrawalAddress(address _nodeAddress, address _newWithdrawalAddress, bool _confirm) external override {\n        // Check new withdrawal address\n        require(_newWithdrawalAddress != address(0x0), \"Invalid withdrawal address\");\n        // Confirm the transaction is from the node's current withdrawal address\n        address withdrawalAddress = getNodeWithdrawalAddress(_nodeAddress);\n        require(withdrawalAddress == msg.sender, \"Only a tx from a node's withdrawal address can update it\");\n        // Update immediately if confirmed\n        if (_confirm) {\n            updateWithdrawalAddress(_nodeAddress, _newWithdrawalAddress);\n        }\n        // Set pending withdrawal address if not confirmed\n        else {\n            pendingWithdrawalAddresses[_nodeAddress] = _newWithdrawalAddress;\n        }\n    }\n\n    // Confirm a node's new withdrawal address\n    function confirmWithdrawalAddress(address _nodeAddress) external override {\n        // Get node by pending withdrawal address\n        require(pendingWithdrawalAddresses[_nodeAddress] == msg.sender, \"Confirmation must come from the pending withdrawal address\");\n        delete pendingWithdrawalAddresses[_nodeAddress];\n        // Update withdrawal address\n        updateWithdrawalAddress(_nodeAddress, msg.sender);\n    }\n\n    // Update a node's withdrawal address\n    function updateWithdrawalAddress(address _nodeAddress, address _newWithdrawalAddress) private {\n        // Set new withdrawal address\n        withdrawalAddresses[_nodeAddress] = _newWithdrawalAddress;\n        // Emit withdrawal address set event\n        emit NodeWithdrawalAddressSet(_nodeAddress, _newWithdrawalAddress, block.timestamp);\n    }\n\n    \n    function getAddress(bytes32 _key) override external view returns (address r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n    \n    function getUint(bytes32 _key) override external view returns (uint256 r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n    \n    function getString(bytes32 _key) override external view returns (string memory) {\n        return stringStorage[_key];\n    }\n\n    \n    function getBytes(bytes32 _key) override external view returns (bytes memory) {\n        return bytesStorage[_key];\n    }\n\n    \n    function getBool(bytes32 _key) override external view returns (bool r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n    \n    function getInt(bytes32 _key) override external view returns (int r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n    \n    function getBytes32(bytes32 _key) override external view returns (bytes32 r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n\n    \n    function setAddress(bytes32 _key, address _value) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n\n    \n    // SWC-124-Write to Arbitrary Storage Location: L206 - L210\n    function setUint(bytes32 _key, uint _value) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n\n    \n    function setString(bytes32 _key, string calldata _value) onlyLatestRocketNetworkContract override external {\n        stringStorage[_key] = _value;\n    }\n\n    \n    function setBytes(bytes32 _key, bytes calldata _value) onlyLatestRocketNetworkContract override external {\n        bytesStorage[_key] = _value;\n    }\n\n    \n    function setBool(bytes32 _key, bool _value) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n\n    \n    // SWC-124-Write to Arbitrary Storage Location: L231 - L235\n    function setInt(bytes32 _key, int _value) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n\n    \n    function setBytes32(bytes32 _key, bytes32 _value) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n\n\n    \n    function deleteAddress(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, 0)\n        }\n    }\n\n    \n    function deleteUint(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, 0)\n        }\n    }\n\n    \n    function deleteString(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        delete stringStorage[_key];\n    }\n\n    \n    function deleteBytes(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        delete bytesStorage[_key];\n    }\n\n    \n    function deleteBool(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, 0)\n        }\n    }\n\n    \n    function deleteInt(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, 0)\n        }\n    }\n\n    \n    function deleteBytes32(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, 0)\n        }\n    }\n\n\n    \n    \n    function addUint(bytes32 _key, uint256 _amount) onlyLatestRocketNetworkContract override external {\n        uint256 a;\n        uint256 b;\n        assembly {\n            a := sload (_key)\n            b := add(a, _amount)\n            sstore (_key, b)\n        }\n        require(b >= a, \"SafeMath: addition overflow\");\n    }\n\n    \n    \n    function subUint(bytes32 _key, uint256 _amount) onlyLatestRocketNetworkContract override external {\n        uint256 a;\n        assembly {\n            a := sload (_key)\n        }\n        require(_amount <= a, \"SafeMath: subtraction overflow\");\n        assembly {\n            a := sub(a, _amount)\n            sstore (_key, a)\n        }\n    }\n\n    // Private methods\n\n    function _getBool(bytes32 _key) private view returns (bool r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n    function _setBool(bytes32 _key, bool _value) private {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n}",
        "function": "setWithdrawalAddress(address,address,bool)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-RocketPool/rocketpool-a65b203cf99c7a991c2d85a7468a97bfb5dbba31/contracts/contract/RocketStorage.sol",
        "vulnerability": "Dependence on tx.origin (SWC 115)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract RocketStorage is RocketStorageInterface {\n\n    // Events\n    event NodeWithdrawalAddressSet(address indexed node, address indexed withdrawalAddress, uint256 time);\n    event GuardianChanged(address oldGuardian, address newGuardian);\n\n    // Libraries\n    using SafeMath for uint256;\n\n    // Complex storage maps\n    mapping(bytes32 => string)     private stringStorage;\n    mapping(bytes32 => bytes)      private bytesStorage;\n\n    // Protected storage (not accessible by network contracts)\n    mapping(address => address)    private withdrawalAddresses;\n    mapping(address => address)    private pendingWithdrawalAddresses;\n\n    // Guardian address\n    address guardian;\n    address newGuardian;\n\n    // Flag storage has been initialised\n    bool storageInit = false;\n\n    \n    modifier onlyLatestRocketNetworkContract() {\n        if (storageInit == true) {\n            // Make sure the access is permitted to only contracts in our Dapp\n            require(_getBool(keccak256(abi.encodePacked(\"contract.exists\", msg.sender))), \"Invalid or outdated network contract\");\n        } else {\n            // Only Dapp and the guardian account are allowed access during initialisation.\n            // tx.origin is only safe to use in this case for deployment since no external contracts are interacted with\n            // SWC-115-Authorization through tx.origin: L45\n            require((\n                _getBool(keccak256(abi.encodePacked(\"contract.exists\", msg.sender))) || tx.origin == guardian\n            ), \"Invalid or outdated network contract attempting access during deployment\");\n        }\n        _;\n    }\n\n\n    \n    constructor() {\n        // Set the guardian upon deployment\n        guardian = msg.sender;\n    }\n\n    // Get guardian address\n    function getGuardian() external override view returns (address) {\n        return guardian;\n    }\n\n    // Transfers guardianship to a new address\n    function setGuardian(address _newAddress) external override {\n        // Check tx comes from current guardian\n        require(msg.sender == guardian, \"Is not guardian account\");\n        // Store new address awaiting confirmation\n        newGuardian = _newAddress;\n    }\n\n    // Confirms change of guardian\n    function confirmGuardian() external override {\n        // Check tx came from new guardian address\n        require(msg.sender == newGuardian, \"Confirmation must come from new guardian address\");\n        // Store old guardian for event\n        address oldGuardian = guardian;\n        // Update guardian and clear storage\n        guardian = newGuardian;\n        delete newGuardian;\n        // Emit event\n        emit GuardianChanged(oldGuardian, guardian);\n    }\n\n    // Set this as being deployed now\n    function getDeployedStatus() external view returns (bool) {\n        return storageInit;\n    }\n\n    // Set this as being deployed now\n    function setDeployedStatus() external {\n        // Only guardian can lock this down\n        require(msg.sender == guardian, \"Is not guardian account\");\n        // Set it now\n        storageInit = true;\n    }\n\n    // Protected storage\n\n    // Get a node's withdrawal address\n    function getNodeWithdrawalAddress(address _nodeAddress) public override view returns (address) {\n        // Check if _nodeAddress is a valid node\n        if (!_getBool(keccak256(abi.encodePacked(\"node.exists\", _nodeAddress)))) {\n            return address(0);\n        }\n        // If no withdrawal address has been set, return the nodes address\n        address withdrawalAddress = withdrawalAddresses[_nodeAddress];\n        if (withdrawalAddress == address(0)) {\n            return _nodeAddress;\n        }\n        return withdrawalAddress;\n    }\n\n    // Get a node's pending withdrawal address\n    function getNodePendingWithdrawalAddress(address _nodeAddress) external override view returns (address) {\n        return pendingWithdrawalAddresses[_nodeAddress];\n    }\n\n    // Set a node's withdrawal address\n    function setWithdrawalAddress(address _nodeAddress, address _newWithdrawalAddress, bool _confirm) external override {\n        // Check new withdrawal address\n        require(_newWithdrawalAddress != address(0x0), \"Invalid withdrawal address\");\n        // Confirm the transaction is from the node's current withdrawal address\n        address withdrawalAddress = getNodeWithdrawalAddress(_nodeAddress);\n        require(withdrawalAddress == msg.sender, \"Only a tx from a node's withdrawal address can update it\");\n        // Update immediately if confirmed\n        if (_confirm) {\n            updateWithdrawalAddress(_nodeAddress, _newWithdrawalAddress);\n        }\n        // Set pending withdrawal address if not confirmed\n        else {\n            pendingWithdrawalAddresses[_nodeAddress] = _newWithdrawalAddress;\n        }\n    }\n\n    // Confirm a node's new withdrawal address\n    function confirmWithdrawalAddress(address _nodeAddress) external override {\n        // Get node by pending withdrawal address\n        require(pendingWithdrawalAddresses[_nodeAddress] == msg.sender, \"Confirmation must come from the pending withdrawal address\");\n        delete pendingWithdrawalAddresses[_nodeAddress];\n        // Update withdrawal address\n        updateWithdrawalAddress(_nodeAddress, msg.sender);\n    }\n\n    // Update a node's withdrawal address\n    function updateWithdrawalAddress(address _nodeAddress, address _newWithdrawalAddress) private {\n        // Set new withdrawal address\n        withdrawalAddresses[_nodeAddress] = _newWithdrawalAddress;\n        // Emit withdrawal address set event\n        emit NodeWithdrawalAddressSet(_nodeAddress, _newWithdrawalAddress, block.timestamp);\n    }\n\n    \n    function getAddress(bytes32 _key) override external view returns (address r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n    \n    function getUint(bytes32 _key) override external view returns (uint256 r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n    \n    function getString(bytes32 _key) override external view returns (string memory) {\n        return stringStorage[_key];\n    }\n\n    \n    function getBytes(bytes32 _key) override external view returns (bytes memory) {\n        return bytesStorage[_key];\n    }\n\n    \n    function getBool(bytes32 _key) override external view returns (bool r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n    \n    function getInt(bytes32 _key) override external view returns (int r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n    \n    function getBytes32(bytes32 _key) override external view returns (bytes32 r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n\n    \n    function setAddress(bytes32 _key, address _value) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n\n    \n    // SWC-124-Write to Arbitrary Storage Location: L206 - L210\n    function setUint(bytes32 _key, uint _value) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n\n    \n    function setString(bytes32 _key, string calldata _value) onlyLatestRocketNetworkContract override external {\n        stringStorage[_key] = _value;\n    }\n\n    \n    function setBytes(bytes32 _key, bytes calldata _value) onlyLatestRocketNetworkContract override external {\n        bytesStorage[_key] = _value;\n    }\n\n    \n    function setBool(bytes32 _key, bool _value) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n\n    \n    // SWC-124-Write to Arbitrary Storage Location: L231 - L235\n    function setInt(bytes32 _key, int _value) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n\n    \n    function setBytes32(bytes32 _key, bytes32 _value) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n\n\n    \n    function deleteAddress(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, 0)\n        }\n    }\n\n    \n    function deleteUint(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, 0)\n        }\n    }\n\n    \n    function deleteString(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        delete stringStorage[_key];\n    }\n\n    \n    function deleteBytes(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        delete bytesStorage[_key];\n    }\n\n    \n    function deleteBool(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, 0)\n        }\n    }\n\n    \n    function deleteInt(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, 0)\n        }\n    }\n\n    \n    function deleteBytes32(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, 0)\n        }\n    }\n\n\n    \n    \n    function addUint(bytes32 _key, uint256 _amount) onlyLatestRocketNetworkContract override external {\n        uint256 a;\n        uint256 b;\n        assembly {\n            a := sload (_key)\n            b := add(a, _amount)\n            sstore (_key, b)\n        }\n        require(b >= a, \"SafeMath: addition overflow\");\n    }\n\n    \n    \n    function subUint(bytes32 _key, uint256 _amount) onlyLatestRocketNetworkContract override external {\n        uint256 a;\n        assembly {\n            a := sload (_key)\n        }\n        require(_amount <= a, \"SafeMath: subtraction overflow\");\n        assembly {\n            a := sub(a, _amount)\n            sstore (_key, a)\n        }\n    }\n\n    // Private methods\n\n    function _getBool(bytes32 _key) private view returns (bool r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n    function _setBool(bytes32 _key, bool _value) private {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n}",
        "function": "setBool(bytes32,bool)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-RocketPool/rocketpool-a65b203cf99c7a991c2d85a7468a97bfb5dbba31/contracts/contract/RocketStorage.sol",
        "vulnerability": "Dependence on tx.origin (SWC 115)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract RocketStorage is RocketStorageInterface {\n\n    // Events\n    event NodeWithdrawalAddressSet(address indexed node, address indexed withdrawalAddress, uint256 time);\n    event GuardianChanged(address oldGuardian, address newGuardian);\n\n    // Libraries\n    using SafeMath for uint256;\n\n    // Complex storage maps\n    mapping(bytes32 => string)     private stringStorage;\n    mapping(bytes32 => bytes)      private bytesStorage;\n\n    // Protected storage (not accessible by network contracts)\n    mapping(address => address)    private withdrawalAddresses;\n    mapping(address => address)    private pendingWithdrawalAddresses;\n\n    // Guardian address\n    address guardian;\n    address newGuardian;\n\n    // Flag storage has been initialised\n    bool storageInit = false;\n\n    \n    modifier onlyLatestRocketNetworkContract() {\n        if (storageInit == true) {\n            // Make sure the access is permitted to only contracts in our Dapp\n            require(_getBool(keccak256(abi.encodePacked(\"contract.exists\", msg.sender))), \"Invalid or outdated network contract\");\n        } else {\n            // Only Dapp and the guardian account are allowed access during initialisation.\n            // tx.origin is only safe to use in this case for deployment since no external contracts are interacted with\n            // SWC-115-Authorization through tx.origin: L45\n            require((\n                _getBool(keccak256(abi.encodePacked(\"contract.exists\", msg.sender))) || tx.origin == guardian\n            ), \"Invalid or outdated network contract attempting access during deployment\");\n        }\n        _;\n    }\n\n\n    \n    constructor() {\n        // Set the guardian upon deployment\n        guardian = msg.sender;\n    }\n\n    // Get guardian address\n    function getGuardian() external override view returns (address) {\n        return guardian;\n    }\n\n    // Transfers guardianship to a new address\n    function setGuardian(address _newAddress) external override {\n        // Check tx comes from current guardian\n        require(msg.sender == guardian, \"Is not guardian account\");\n        // Store new address awaiting confirmation\n        newGuardian = _newAddress;\n    }\n\n    // Confirms change of guardian\n    function confirmGuardian() external override {\n        // Check tx came from new guardian address\n        require(msg.sender == newGuardian, \"Confirmation must come from new guardian address\");\n        // Store old guardian for event\n        address oldGuardian = guardian;\n        // Update guardian and clear storage\n        guardian = newGuardian;\n        delete newGuardian;\n        // Emit event\n        emit GuardianChanged(oldGuardian, guardian);\n    }\n\n    // Set this as being deployed now\n    function getDeployedStatus() external view returns (bool) {\n        return storageInit;\n    }\n\n    // Set this as being deployed now\n    function setDeployedStatus() external {\n        // Only guardian can lock this down\n        require(msg.sender == guardian, \"Is not guardian account\");\n        // Set it now\n        storageInit = true;\n    }\n\n    // Protected storage\n\n    // Get a node's withdrawal address\n    function getNodeWithdrawalAddress(address _nodeAddress) public override view returns (address) {\n        // Check if _nodeAddress is a valid node\n        if (!_getBool(keccak256(abi.encodePacked(\"node.exists\", _nodeAddress)))) {\n            return address(0);\n        }\n        // If no withdrawal address has been set, return the nodes address\n        address withdrawalAddress = withdrawalAddresses[_nodeAddress];\n        if (withdrawalAddress == address(0)) {\n            return _nodeAddress;\n        }\n        return withdrawalAddress;\n    }\n\n    // Get a node's pending withdrawal address\n    function getNodePendingWithdrawalAddress(address _nodeAddress) external override view returns (address) {\n        return pendingWithdrawalAddresses[_nodeAddress];\n    }\n\n    // Set a node's withdrawal address\n    function setWithdrawalAddress(address _nodeAddress, address _newWithdrawalAddress, bool _confirm) external override {\n        // Check new withdrawal address\n        require(_newWithdrawalAddress != address(0x0), \"Invalid withdrawal address\");\n        // Confirm the transaction is from the node's current withdrawal address\n        address withdrawalAddress = getNodeWithdrawalAddress(_nodeAddress);\n        require(withdrawalAddress == msg.sender, \"Only a tx from a node's withdrawal address can update it\");\n        // Update immediately if confirmed\n        if (_confirm) {\n            updateWithdrawalAddress(_nodeAddress, _newWithdrawalAddress);\n        }\n        // Set pending withdrawal address if not confirmed\n        else {\n            pendingWithdrawalAddresses[_nodeAddress] = _newWithdrawalAddress;\n        }\n    }\n\n    // Confirm a node's new withdrawal address\n    function confirmWithdrawalAddress(address _nodeAddress) external override {\n        // Get node by pending withdrawal address\n        require(pendingWithdrawalAddresses[_nodeAddress] == msg.sender, \"Confirmation must come from the pending withdrawal address\");\n        delete pendingWithdrawalAddresses[_nodeAddress];\n        // Update withdrawal address\n        updateWithdrawalAddress(_nodeAddress, msg.sender);\n    }\n\n    // Update a node's withdrawal address\n    function updateWithdrawalAddress(address _nodeAddress, address _newWithdrawalAddress) private {\n        // Set new withdrawal address\n        withdrawalAddresses[_nodeAddress] = _newWithdrawalAddress;\n        // Emit withdrawal address set event\n        emit NodeWithdrawalAddressSet(_nodeAddress, _newWithdrawalAddress, block.timestamp);\n    }\n\n    \n    function getAddress(bytes32 _key) override external view returns (address r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n    \n    function getUint(bytes32 _key) override external view returns (uint256 r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n    \n    function getString(bytes32 _key) override external view returns (string memory) {\n        return stringStorage[_key];\n    }\n\n    \n    function getBytes(bytes32 _key) override external view returns (bytes memory) {\n        return bytesStorage[_key];\n    }\n\n    \n    function getBool(bytes32 _key) override external view returns (bool r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n    \n    function getInt(bytes32 _key) override external view returns (int r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n    \n    function getBytes32(bytes32 _key) override external view returns (bytes32 r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n\n    \n    function setAddress(bytes32 _key, address _value) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n\n    \n    // SWC-124-Write to Arbitrary Storage Location: L206 - L210\n    function setUint(bytes32 _key, uint _value) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n\n    \n    function setString(bytes32 _key, string calldata _value) onlyLatestRocketNetworkContract override external {\n        stringStorage[_key] = _value;\n    }\n\n    \n    function setBytes(bytes32 _key, bytes calldata _value) onlyLatestRocketNetworkContract override external {\n        bytesStorage[_key] = _value;\n    }\n\n    \n    function setBool(bytes32 _key, bool _value) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n\n    \n    // SWC-124-Write to Arbitrary Storage Location: L231 - L235\n    function setInt(bytes32 _key, int _value) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n\n    \n    function setBytes32(bytes32 _key, bytes32 _value) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n\n\n    \n    function deleteAddress(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, 0)\n        }\n    }\n\n    \n    function deleteUint(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, 0)\n        }\n    }\n\n    \n    function deleteString(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        delete stringStorage[_key];\n    }\n\n    \n    function deleteBytes(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        delete bytesStorage[_key];\n    }\n\n    \n    function deleteBool(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, 0)\n        }\n    }\n\n    \n    function deleteInt(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, 0)\n        }\n    }\n\n    \n    function deleteBytes32(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, 0)\n        }\n    }\n\n\n    \n    \n    function addUint(bytes32 _key, uint256 _amount) onlyLatestRocketNetworkContract override external {\n        uint256 a;\n        uint256 b;\n        assembly {\n            a := sload (_key)\n            b := add(a, _amount)\n            sstore (_key, b)\n        }\n        require(b >= a, \"SafeMath: addition overflow\");\n    }\n\n    \n    \n    function subUint(bytes32 _key, uint256 _amount) onlyLatestRocketNetworkContract override external {\n        uint256 a;\n        assembly {\n            a := sload (_key)\n        }\n        require(_amount <= a, \"SafeMath: subtraction overflow\");\n        assembly {\n            a := sub(a, _amount)\n            sstore (_key, a)\n        }\n    }\n\n    // Private methods\n\n    function _getBool(bytes32 _key) private view returns (bool r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n    function _setBool(bytes32 _key, bool _value) private {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n}",
        "function": "setBool(bytes32,bool)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-RocketPool/rocketpool-a65b203cf99c7a991c2d85a7468a97bfb5dbba31/contracts/contract/RocketStorage.sol",
        "vulnerability": "Write to an arbitrary storage location (SWC 124)",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract RocketStorage is RocketStorageInterface {\n\n    // Events\n    event NodeWithdrawalAddressSet(address indexed node, address indexed withdrawalAddress, uint256 time);\n    event GuardianChanged(address oldGuardian, address newGuardian);\n\n    // Libraries\n    using SafeMath for uint256;\n\n    // Complex storage maps\n    mapping(bytes32 => string)     private stringStorage;\n    mapping(bytes32 => bytes)      private bytesStorage;\n\n    // Protected storage (not accessible by network contracts)\n    mapping(address => address)    private withdrawalAddresses;\n    mapping(address => address)    private pendingWithdrawalAddresses;\n\n    // Guardian address\n    address guardian;\n    address newGuardian;\n\n    // Flag storage has been initialised\n    bool storageInit = false;\n\n    \n    modifier onlyLatestRocketNetworkContract() {\n        if (storageInit == true) {\n            // Make sure the access is permitted to only contracts in our Dapp\n            require(_getBool(keccak256(abi.encodePacked(\"contract.exists\", msg.sender))), \"Invalid or outdated network contract\");\n        } else {\n            // Only Dapp and the guardian account are allowed access during initialisation.\n            // tx.origin is only safe to use in this case for deployment since no external contracts are interacted with\n            // SWC-115-Authorization through tx.origin: L45\n            require((\n                _getBool(keccak256(abi.encodePacked(\"contract.exists\", msg.sender))) || tx.origin == guardian\n            ), \"Invalid or outdated network contract attempting access during deployment\");\n        }\n        _;\n    }\n\n\n    \n    constructor() {\n        // Set the guardian upon deployment\n        guardian = msg.sender;\n    }\n\n    // Get guardian address\n    function getGuardian() external override view returns (address) {\n        return guardian;\n    }\n\n    // Transfers guardianship to a new address\n    function setGuardian(address _newAddress) external override {\n        // Check tx comes from current guardian\n        require(msg.sender == guardian, \"Is not guardian account\");\n        // Store new address awaiting confirmation\n        newGuardian = _newAddress;\n    }\n\n    // Confirms change of guardian\n    function confirmGuardian() external override {\n        // Check tx came from new guardian address\n        require(msg.sender == newGuardian, \"Confirmation must come from new guardian address\");\n        // Store old guardian for event\n        address oldGuardian = guardian;\n        // Update guardian and clear storage\n        guardian = newGuardian;\n        delete newGuardian;\n        // Emit event\n        emit GuardianChanged(oldGuardian, guardian);\n    }\n\n    // Set this as being deployed now\n    function getDeployedStatus() external view returns (bool) {\n        return storageInit;\n    }\n\n    // Set this as being deployed now\n    function setDeployedStatus() external {\n        // Only guardian can lock this down\n        require(msg.sender == guardian, \"Is not guardian account\");\n        // Set it now\n        storageInit = true;\n    }\n\n    // Protected storage\n\n    // Get a node's withdrawal address\n    function getNodeWithdrawalAddress(address _nodeAddress) public override view returns (address) {\n        // Check if _nodeAddress is a valid node\n        if (!_getBool(keccak256(abi.encodePacked(\"node.exists\", _nodeAddress)))) {\n            return address(0);\n        }\n        // If no withdrawal address has been set, return the nodes address\n        address withdrawalAddress = withdrawalAddresses[_nodeAddress];\n        if (withdrawalAddress == address(0)) {\n            return _nodeAddress;\n        }\n        return withdrawalAddress;\n    }\n\n    // Get a node's pending withdrawal address\n    function getNodePendingWithdrawalAddress(address _nodeAddress) external override view returns (address) {\n        return pendingWithdrawalAddresses[_nodeAddress];\n    }\n\n    // Set a node's withdrawal address\n    function setWithdrawalAddress(address _nodeAddress, address _newWithdrawalAddress, bool _confirm) external override {\n        // Check new withdrawal address\n        require(_newWithdrawalAddress != address(0x0), \"Invalid withdrawal address\");\n        // Confirm the transaction is from the node's current withdrawal address\n        address withdrawalAddress = getNodeWithdrawalAddress(_nodeAddress);\n        require(withdrawalAddress == msg.sender, \"Only a tx from a node's withdrawal address can update it\");\n        // Update immediately if confirmed\n        if (_confirm) {\n            updateWithdrawalAddress(_nodeAddress, _newWithdrawalAddress);\n        }\n        // Set pending withdrawal address if not confirmed\n        else {\n            pendingWithdrawalAddresses[_nodeAddress] = _newWithdrawalAddress;\n        }\n    }\n\n    // Confirm a node's new withdrawal address\n    function confirmWithdrawalAddress(address _nodeAddress) external override {\n        // Get node by pending withdrawal address\n        require(pendingWithdrawalAddresses[_nodeAddress] == msg.sender, \"Confirmation must come from the pending withdrawal address\");\n        delete pendingWithdrawalAddresses[_nodeAddress];\n        // Update withdrawal address\n        updateWithdrawalAddress(_nodeAddress, msg.sender);\n    }\n\n    // Update a node's withdrawal address\n    function updateWithdrawalAddress(address _nodeAddress, address _newWithdrawalAddress) private {\n        // Set new withdrawal address\n        withdrawalAddresses[_nodeAddress] = _newWithdrawalAddress;\n        // Emit withdrawal address set event\n        emit NodeWithdrawalAddressSet(_nodeAddress, _newWithdrawalAddress, block.timestamp);\n    }\n\n    \n    function getAddress(bytes32 _key) override external view returns (address r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n    \n    function getUint(bytes32 _key) override external view returns (uint256 r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n    \n    function getString(bytes32 _key) override external view returns (string memory) {\n        return stringStorage[_key];\n    }\n\n    \n    function getBytes(bytes32 _key) override external view returns (bytes memory) {\n        return bytesStorage[_key];\n    }\n\n    \n    function getBool(bytes32 _key) override external view returns (bool r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n    \n    function getInt(bytes32 _key) override external view returns (int r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n    \n    function getBytes32(bytes32 _key) override external view returns (bytes32 r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n\n    \n    function setAddress(bytes32 _key, address _value) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n\n    \n    // SWC-124-Write to Arbitrary Storage Location: L206 - L210\n    function setUint(bytes32 _key, uint _value) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n\n    \n    function setString(bytes32 _key, string calldata _value) onlyLatestRocketNetworkContract override external {\n        stringStorage[_key] = _value;\n    }\n\n    \n    function setBytes(bytes32 _key, bytes calldata _value) onlyLatestRocketNetworkContract override external {\n        bytesStorage[_key] = _value;\n    }\n\n    \n    function setBool(bytes32 _key, bool _value) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n\n    \n    // SWC-124-Write to Arbitrary Storage Location: L231 - L235\n    function setInt(bytes32 _key, int _value) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n\n    \n    function setBytes32(bytes32 _key, bytes32 _value) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n\n\n    \n    function deleteAddress(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, 0)\n        }\n    }\n\n    \n    function deleteUint(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, 0)\n        }\n    }\n\n    \n    function deleteString(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        delete stringStorage[_key];\n    }\n\n    \n    function deleteBytes(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        delete bytesStorage[_key];\n    }\n\n    \n    function deleteBool(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, 0)\n        }\n    }\n\n    \n    function deleteInt(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, 0)\n        }\n    }\n\n    \n    function deleteBytes32(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, 0)\n        }\n    }\n\n\n    \n    \n    function addUint(bytes32 _key, uint256 _amount) onlyLatestRocketNetworkContract override external {\n        uint256 a;\n        uint256 b;\n        assembly {\n            a := sload (_key)\n            b := add(a, _amount)\n            sstore (_key, b)\n        }\n        require(b >= a, \"SafeMath: addition overflow\");\n    }\n\n    \n    \n    function subUint(bytes32 _key, uint256 _amount) onlyLatestRocketNetworkContract override external {\n        uint256 a;\n        assembly {\n            a := sload (_key)\n        }\n        require(_amount <= a, \"SafeMath: subtraction overflow\");\n        assembly {\n            a := sub(a, _amount)\n            sstore (_key, a)\n        }\n    }\n\n    // Private methods\n\n    function _getBool(bytes32 _key) private view returns (bool r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n    function _setBool(bytes32 _key, bool _value) private {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n}",
        "function": "addUint(bytes32,uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-RocketPool/rocketpool-a65b203cf99c7a991c2d85a7468a97bfb5dbba31/contracts/contract/RocketStorage.sol",
        "vulnerability": "Dependence on tx.origin (SWC 115)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract RocketStorage is RocketStorageInterface {\n\n    // Events\n    event NodeWithdrawalAddressSet(address indexed node, address indexed withdrawalAddress, uint256 time);\n    event GuardianChanged(address oldGuardian, address newGuardian);\n\n    // Libraries\n    using SafeMath for uint256;\n\n    // Complex storage maps\n    mapping(bytes32 => string)     private stringStorage;\n    mapping(bytes32 => bytes)      private bytesStorage;\n\n    // Protected storage (not accessible by network contracts)\n    mapping(address => address)    private withdrawalAddresses;\n    mapping(address => address)    private pendingWithdrawalAddresses;\n\n    // Guardian address\n    address guardian;\n    address newGuardian;\n\n    // Flag storage has been initialised\n    bool storageInit = false;\n\n    \n    modifier onlyLatestRocketNetworkContract() {\n        if (storageInit == true) {\n            // Make sure the access is permitted to only contracts in our Dapp\n            require(_getBool(keccak256(abi.encodePacked(\"contract.exists\", msg.sender))), \"Invalid or outdated network contract\");\n        } else {\n            // Only Dapp and the guardian account are allowed access during initialisation.\n            // tx.origin is only safe to use in this case for deployment since no external contracts are interacted with\n            // SWC-115-Authorization through tx.origin: L45\n            require((\n                _getBool(keccak256(abi.encodePacked(\"contract.exists\", msg.sender))) || tx.origin == guardian\n            ), \"Invalid or outdated network contract attempting access during deployment\");\n        }\n        _;\n    }\n\n\n    \n    constructor() {\n        // Set the guardian upon deployment\n        guardian = msg.sender;\n    }\n\n    // Get guardian address\n    function getGuardian() external override view returns (address) {\n        return guardian;\n    }\n\n    // Transfers guardianship to a new address\n    function setGuardian(address _newAddress) external override {\n        // Check tx comes from current guardian\n        require(msg.sender == guardian, \"Is not guardian account\");\n        // Store new address awaiting confirmation\n        newGuardian = _newAddress;\n    }\n\n    // Confirms change of guardian\n    function confirmGuardian() external override {\n        // Check tx came from new guardian address\n        require(msg.sender == newGuardian, \"Confirmation must come from new guardian address\");\n        // Store old guardian for event\n        address oldGuardian = guardian;\n        // Update guardian and clear storage\n        guardian = newGuardian;\n        delete newGuardian;\n        // Emit event\n        emit GuardianChanged(oldGuardian, guardian);\n    }\n\n    // Set this as being deployed now\n    function getDeployedStatus() external view returns (bool) {\n        return storageInit;\n    }\n\n    // Set this as being deployed now\n    function setDeployedStatus() external {\n        // Only guardian can lock this down\n        require(msg.sender == guardian, \"Is not guardian account\");\n        // Set it now\n        storageInit = true;\n    }\n\n    // Protected storage\n\n    // Get a node's withdrawal address\n    function getNodeWithdrawalAddress(address _nodeAddress) public override view returns (address) {\n        // Check if _nodeAddress is a valid node\n        if (!_getBool(keccak256(abi.encodePacked(\"node.exists\", _nodeAddress)))) {\n            return address(0);\n        }\n        // If no withdrawal address has been set, return the nodes address\n        address withdrawalAddress = withdrawalAddresses[_nodeAddress];\n        if (withdrawalAddress == address(0)) {\n            return _nodeAddress;\n        }\n        return withdrawalAddress;\n    }\n\n    // Get a node's pending withdrawal address\n    function getNodePendingWithdrawalAddress(address _nodeAddress) external override view returns (address) {\n        return pendingWithdrawalAddresses[_nodeAddress];\n    }\n\n    // Set a node's withdrawal address\n    function setWithdrawalAddress(address _nodeAddress, address _newWithdrawalAddress, bool _confirm) external override {\n        // Check new withdrawal address\n        require(_newWithdrawalAddress != address(0x0), \"Invalid withdrawal address\");\n        // Confirm the transaction is from the node's current withdrawal address\n        address withdrawalAddress = getNodeWithdrawalAddress(_nodeAddress);\n        require(withdrawalAddress == msg.sender, \"Only a tx from a node's withdrawal address can update it\");\n        // Update immediately if confirmed\n        if (_confirm) {\n            updateWithdrawalAddress(_nodeAddress, _newWithdrawalAddress);\n        }\n        // Set pending withdrawal address if not confirmed\n        else {\n            pendingWithdrawalAddresses[_nodeAddress] = _newWithdrawalAddress;\n        }\n    }\n\n    // Confirm a node's new withdrawal address\n    function confirmWithdrawalAddress(address _nodeAddress) external override {\n        // Get node by pending withdrawal address\n        require(pendingWithdrawalAddresses[_nodeAddress] == msg.sender, \"Confirmation must come from the pending withdrawal address\");\n        delete pendingWithdrawalAddresses[_nodeAddress];\n        // Update withdrawal address\n        updateWithdrawalAddress(_nodeAddress, msg.sender);\n    }\n\n    // Update a node's withdrawal address\n    function updateWithdrawalAddress(address _nodeAddress, address _newWithdrawalAddress) private {\n        // Set new withdrawal address\n        withdrawalAddresses[_nodeAddress] = _newWithdrawalAddress;\n        // Emit withdrawal address set event\n        emit NodeWithdrawalAddressSet(_nodeAddress, _newWithdrawalAddress, block.timestamp);\n    }\n\n    \n    function getAddress(bytes32 _key) override external view returns (address r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n    \n    function getUint(bytes32 _key) override external view returns (uint256 r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n    \n    function getString(bytes32 _key) override external view returns (string memory) {\n        return stringStorage[_key];\n    }\n\n    \n    function getBytes(bytes32 _key) override external view returns (bytes memory) {\n        return bytesStorage[_key];\n    }\n\n    \n    function getBool(bytes32 _key) override external view returns (bool r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n    \n    function getInt(bytes32 _key) override external view returns (int r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n    \n    function getBytes32(bytes32 _key) override external view returns (bytes32 r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n\n    \n    function setAddress(bytes32 _key, address _value) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n\n    \n    // SWC-124-Write to Arbitrary Storage Location: L206 - L210\n    function setUint(bytes32 _key, uint _value) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n\n    \n    function setString(bytes32 _key, string calldata _value) onlyLatestRocketNetworkContract override external {\n        stringStorage[_key] = _value;\n    }\n\n    \n    function setBytes(bytes32 _key, bytes calldata _value) onlyLatestRocketNetworkContract override external {\n        bytesStorage[_key] = _value;\n    }\n\n    \n    function setBool(bytes32 _key, bool _value) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n\n    \n    // SWC-124-Write to Arbitrary Storage Location: L231 - L235\n    function setInt(bytes32 _key, int _value) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n\n    \n    function setBytes32(bytes32 _key, bytes32 _value) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n\n\n    \n    function deleteAddress(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, 0)\n        }\n    }\n\n    \n    function deleteUint(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, 0)\n        }\n    }\n\n    \n    function deleteString(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        delete stringStorage[_key];\n    }\n\n    \n    function deleteBytes(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        delete bytesStorage[_key];\n    }\n\n    \n    function deleteBool(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, 0)\n        }\n    }\n\n    \n    function deleteInt(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, 0)\n        }\n    }\n\n    \n    function deleteBytes32(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, 0)\n        }\n    }\n\n\n    \n    \n    function addUint(bytes32 _key, uint256 _amount) onlyLatestRocketNetworkContract override external {\n        uint256 a;\n        uint256 b;\n        assembly {\n            a := sload (_key)\n            b := add(a, _amount)\n            sstore (_key, b)\n        }\n        require(b >= a, \"SafeMath: addition overflow\");\n    }\n\n    \n    \n    function subUint(bytes32 _key, uint256 _amount) onlyLatestRocketNetworkContract override external {\n        uint256 a;\n        assembly {\n            a := sload (_key)\n        }\n        require(_amount <= a, \"SafeMath: subtraction overflow\");\n        assembly {\n            a := sub(a, _amount)\n            sstore (_key, a)\n        }\n    }\n\n    // Private methods\n\n    function _getBool(bytes32 _key) private view returns (bool r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n    function _setBool(bytes32 _key, bool _value) private {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n}",
        "function": "addUint(bytes32,uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-RocketPool/rocketpool-a65b203cf99c7a991c2d85a7468a97bfb5dbba31/contracts/contract/RocketStorage.sol",
        "vulnerability": "Write to an arbitrary storage location (SWC 124)",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract RocketStorage is RocketStorageInterface {\n\n    // Events\n    event NodeWithdrawalAddressSet(address indexed node, address indexed withdrawalAddress, uint256 time);\n    event GuardianChanged(address oldGuardian, address newGuardian);\n\n    // Libraries\n    using SafeMath for uint256;\n\n    // Complex storage maps\n    mapping(bytes32 => string)     private stringStorage;\n    mapping(bytes32 => bytes)      private bytesStorage;\n\n    // Protected storage (not accessible by network contracts)\n    mapping(address => address)    private withdrawalAddresses;\n    mapping(address => address)    private pendingWithdrawalAddresses;\n\n    // Guardian address\n    address guardian;\n    address newGuardian;\n\n    // Flag storage has been initialised\n    bool storageInit = false;\n\n    \n    modifier onlyLatestRocketNetworkContract() {\n        if (storageInit == true) {\n            // Make sure the access is permitted to only contracts in our Dapp\n            require(_getBool(keccak256(abi.encodePacked(\"contract.exists\", msg.sender))), \"Invalid or outdated network contract\");\n        } else {\n            // Only Dapp and the guardian account are allowed access during initialisation.\n            // tx.origin is only safe to use in this case for deployment since no external contracts are interacted with\n            // SWC-115-Authorization through tx.origin: L45\n            require((\n                _getBool(keccak256(abi.encodePacked(\"contract.exists\", msg.sender))) || tx.origin == guardian\n            ), \"Invalid or outdated network contract attempting access during deployment\");\n        }\n        _;\n    }\n\n\n    \n    constructor() {\n        // Set the guardian upon deployment\n        guardian = msg.sender;\n    }\n\n    // Get guardian address\n    function getGuardian() external override view returns (address) {\n        return guardian;\n    }\n\n    // Transfers guardianship to a new address\n    function setGuardian(address _newAddress) external override {\n        // Check tx comes from current guardian\n        require(msg.sender == guardian, \"Is not guardian account\");\n        // Store new address awaiting confirmation\n        newGuardian = _newAddress;\n    }\n\n    // Confirms change of guardian\n    function confirmGuardian() external override {\n        // Check tx came from new guardian address\n        require(msg.sender == newGuardian, \"Confirmation must come from new guardian address\");\n        // Store old guardian for event\n        address oldGuardian = guardian;\n        // Update guardian and clear storage\n        guardian = newGuardian;\n        delete newGuardian;\n        // Emit event\n        emit GuardianChanged(oldGuardian, guardian);\n    }\n\n    // Set this as being deployed now\n    function getDeployedStatus() external view returns (bool) {\n        return storageInit;\n    }\n\n    // Set this as being deployed now\n    function setDeployedStatus() external {\n        // Only guardian can lock this down\n        require(msg.sender == guardian, \"Is not guardian account\");\n        // Set it now\n        storageInit = true;\n    }\n\n    // Protected storage\n\n    // Get a node's withdrawal address\n    function getNodeWithdrawalAddress(address _nodeAddress) public override view returns (address) {\n        // Check if _nodeAddress is a valid node\n        if (!_getBool(keccak256(abi.encodePacked(\"node.exists\", _nodeAddress)))) {\n            return address(0);\n        }\n        // If no withdrawal address has been set, return the nodes address\n        address withdrawalAddress = withdrawalAddresses[_nodeAddress];\n        if (withdrawalAddress == address(0)) {\n            return _nodeAddress;\n        }\n        return withdrawalAddress;\n    }\n\n    // Get a node's pending withdrawal address\n    function getNodePendingWithdrawalAddress(address _nodeAddress) external override view returns (address) {\n        return pendingWithdrawalAddresses[_nodeAddress];\n    }\n\n    // Set a node's withdrawal address\n    function setWithdrawalAddress(address _nodeAddress, address _newWithdrawalAddress, bool _confirm) external override {\n        // Check new withdrawal address\n        require(_newWithdrawalAddress != address(0x0), \"Invalid withdrawal address\");\n        // Confirm the transaction is from the node's current withdrawal address\n        address withdrawalAddress = getNodeWithdrawalAddress(_nodeAddress);\n        require(withdrawalAddress == msg.sender, \"Only a tx from a node's withdrawal address can update it\");\n        // Update immediately if confirmed\n        if (_confirm) {\n            updateWithdrawalAddress(_nodeAddress, _newWithdrawalAddress);\n        }\n        // Set pending withdrawal address if not confirmed\n        else {\n            pendingWithdrawalAddresses[_nodeAddress] = _newWithdrawalAddress;\n        }\n    }\n\n    // Confirm a node's new withdrawal address\n    function confirmWithdrawalAddress(address _nodeAddress) external override {\n        // Get node by pending withdrawal address\n        require(pendingWithdrawalAddresses[_nodeAddress] == msg.sender, \"Confirmation must come from the pending withdrawal address\");\n        delete pendingWithdrawalAddresses[_nodeAddress];\n        // Update withdrawal address\n        updateWithdrawalAddress(_nodeAddress, msg.sender);\n    }\n\n    // Update a node's withdrawal address\n    function updateWithdrawalAddress(address _nodeAddress, address _newWithdrawalAddress) private {\n        // Set new withdrawal address\n        withdrawalAddresses[_nodeAddress] = _newWithdrawalAddress;\n        // Emit withdrawal address set event\n        emit NodeWithdrawalAddressSet(_nodeAddress, _newWithdrawalAddress, block.timestamp);\n    }\n\n    \n    function getAddress(bytes32 _key) override external view returns (address r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n    \n    function getUint(bytes32 _key) override external view returns (uint256 r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n    \n    function getString(bytes32 _key) override external view returns (string memory) {\n        return stringStorage[_key];\n    }\n\n    \n    function getBytes(bytes32 _key) override external view returns (bytes memory) {\n        return bytesStorage[_key];\n    }\n\n    \n    function getBool(bytes32 _key) override external view returns (bool r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n    \n    function getInt(bytes32 _key) override external view returns (int r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n    \n    function getBytes32(bytes32 _key) override external view returns (bytes32 r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n\n    \n    function setAddress(bytes32 _key, address _value) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n\n    \n    // SWC-124-Write to Arbitrary Storage Location: L206 - L210\n    function setUint(bytes32 _key, uint _value) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n\n    \n    function setString(bytes32 _key, string calldata _value) onlyLatestRocketNetworkContract override external {\n        stringStorage[_key] = _value;\n    }\n\n    \n    function setBytes(bytes32 _key, bytes calldata _value) onlyLatestRocketNetworkContract override external {\n        bytesStorage[_key] = _value;\n    }\n\n    \n    function setBool(bytes32 _key, bool _value) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n\n    \n    // SWC-124-Write to Arbitrary Storage Location: L231 - L235\n    function setInt(bytes32 _key, int _value) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n\n    \n    function setBytes32(bytes32 _key, bytes32 _value) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n\n\n    \n    function deleteAddress(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, 0)\n        }\n    }\n\n    \n    function deleteUint(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, 0)\n        }\n    }\n\n    \n    function deleteString(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        delete stringStorage[_key];\n    }\n\n    \n    function deleteBytes(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        delete bytesStorage[_key];\n    }\n\n    \n    function deleteBool(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, 0)\n        }\n    }\n\n    \n    function deleteInt(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, 0)\n        }\n    }\n\n    \n    function deleteBytes32(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, 0)\n        }\n    }\n\n\n    \n    \n    function addUint(bytes32 _key, uint256 _amount) onlyLatestRocketNetworkContract override external {\n        uint256 a;\n        uint256 b;\n        assembly {\n            a := sload (_key)\n            b := add(a, _amount)\n            sstore (_key, b)\n        }\n        require(b >= a, \"SafeMath: addition overflow\");\n    }\n\n    \n    \n    function subUint(bytes32 _key, uint256 _amount) onlyLatestRocketNetworkContract override external {\n        uint256 a;\n        assembly {\n            a := sload (_key)\n        }\n        require(_amount <= a, \"SafeMath: subtraction overflow\");\n        assembly {\n            a := sub(a, _amount)\n            sstore (_key, a)\n        }\n    }\n\n    // Private methods\n\n    function _getBool(bytes32 _key) private view returns (bool r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n    function _setBool(bytes32 _key, bool _value) private {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n}",
        "function": "setAddress(bytes32,address)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-RocketPool/rocketpool-a65b203cf99c7a991c2d85a7468a97bfb5dbba31/contracts/contract/RocketStorage.sol",
        "vulnerability": "Dependence on tx.origin (SWC 115)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract RocketStorage is RocketStorageInterface {\n\n    // Events\n    event NodeWithdrawalAddressSet(address indexed node, address indexed withdrawalAddress, uint256 time);\n    event GuardianChanged(address oldGuardian, address newGuardian);\n\n    // Libraries\n    using SafeMath for uint256;\n\n    // Complex storage maps\n    mapping(bytes32 => string)     private stringStorage;\n    mapping(bytes32 => bytes)      private bytesStorage;\n\n    // Protected storage (not accessible by network contracts)\n    mapping(address => address)    private withdrawalAddresses;\n    mapping(address => address)    private pendingWithdrawalAddresses;\n\n    // Guardian address\n    address guardian;\n    address newGuardian;\n\n    // Flag storage has been initialised\n    bool storageInit = false;\n\n    \n    modifier onlyLatestRocketNetworkContract() {\n        if (storageInit == true) {\n            // Make sure the access is permitted to only contracts in our Dapp\n            require(_getBool(keccak256(abi.encodePacked(\"contract.exists\", msg.sender))), \"Invalid or outdated network contract\");\n        } else {\n            // Only Dapp and the guardian account are allowed access during initialisation.\n            // tx.origin is only safe to use in this case for deployment since no external contracts are interacted with\n            // SWC-115-Authorization through tx.origin: L45\n            require((\n                _getBool(keccak256(abi.encodePacked(\"contract.exists\", msg.sender))) || tx.origin == guardian\n            ), \"Invalid or outdated network contract attempting access during deployment\");\n        }\n        _;\n    }\n\n\n    \n    constructor() {\n        // Set the guardian upon deployment\n        guardian = msg.sender;\n    }\n\n    // Get guardian address\n    function getGuardian() external override view returns (address) {\n        return guardian;\n    }\n\n    // Transfers guardianship to a new address\n    function setGuardian(address _newAddress) external override {\n        // Check tx comes from current guardian\n        require(msg.sender == guardian, \"Is not guardian account\");\n        // Store new address awaiting confirmation\n        newGuardian = _newAddress;\n    }\n\n    // Confirms change of guardian\n    function confirmGuardian() external override {\n        // Check tx came from new guardian address\n        require(msg.sender == newGuardian, \"Confirmation must come from new guardian address\");\n        // Store old guardian for event\n        address oldGuardian = guardian;\n        // Update guardian and clear storage\n        guardian = newGuardian;\n        delete newGuardian;\n        // Emit event\n        emit GuardianChanged(oldGuardian, guardian);\n    }\n\n    // Set this as being deployed now\n    function getDeployedStatus() external view returns (bool) {\n        return storageInit;\n    }\n\n    // Set this as being deployed now\n    function setDeployedStatus() external {\n        // Only guardian can lock this down\n        require(msg.sender == guardian, \"Is not guardian account\");\n        // Set it now\n        storageInit = true;\n    }\n\n    // Protected storage\n\n    // Get a node's withdrawal address\n    function getNodeWithdrawalAddress(address _nodeAddress) public override view returns (address) {\n        // Check if _nodeAddress is a valid node\n        if (!_getBool(keccak256(abi.encodePacked(\"node.exists\", _nodeAddress)))) {\n            return address(0);\n        }\n        // If no withdrawal address has been set, return the nodes address\n        address withdrawalAddress = withdrawalAddresses[_nodeAddress];\n        if (withdrawalAddress == address(0)) {\n            return _nodeAddress;\n        }\n        return withdrawalAddress;\n    }\n\n    // Get a node's pending withdrawal address\n    function getNodePendingWithdrawalAddress(address _nodeAddress) external override view returns (address) {\n        return pendingWithdrawalAddresses[_nodeAddress];\n    }\n\n    // Set a node's withdrawal address\n    function setWithdrawalAddress(address _nodeAddress, address _newWithdrawalAddress, bool _confirm) external override {\n        // Check new withdrawal address\n        require(_newWithdrawalAddress != address(0x0), \"Invalid withdrawal address\");\n        // Confirm the transaction is from the node's current withdrawal address\n        address withdrawalAddress = getNodeWithdrawalAddress(_nodeAddress);\n        require(withdrawalAddress == msg.sender, \"Only a tx from a node's withdrawal address can update it\");\n        // Update immediately if confirmed\n        if (_confirm) {\n            updateWithdrawalAddress(_nodeAddress, _newWithdrawalAddress);\n        }\n        // Set pending withdrawal address if not confirmed\n        else {\n            pendingWithdrawalAddresses[_nodeAddress] = _newWithdrawalAddress;\n        }\n    }\n\n    // Confirm a node's new withdrawal address\n    function confirmWithdrawalAddress(address _nodeAddress) external override {\n        // Get node by pending withdrawal address\n        require(pendingWithdrawalAddresses[_nodeAddress] == msg.sender, \"Confirmation must come from the pending withdrawal address\");\n        delete pendingWithdrawalAddresses[_nodeAddress];\n        // Update withdrawal address\n        updateWithdrawalAddress(_nodeAddress, msg.sender);\n    }\n\n    // Update a node's withdrawal address\n    function updateWithdrawalAddress(address _nodeAddress, address _newWithdrawalAddress) private {\n        // Set new withdrawal address\n        withdrawalAddresses[_nodeAddress] = _newWithdrawalAddress;\n        // Emit withdrawal address set event\n        emit NodeWithdrawalAddressSet(_nodeAddress, _newWithdrawalAddress, block.timestamp);\n    }\n\n    \n    function getAddress(bytes32 _key) override external view returns (address r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n    \n    function getUint(bytes32 _key) override external view returns (uint256 r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n    \n    function getString(bytes32 _key) override external view returns (string memory) {\n        return stringStorage[_key];\n    }\n\n    \n    function getBytes(bytes32 _key) override external view returns (bytes memory) {\n        return bytesStorage[_key];\n    }\n\n    \n    function getBool(bytes32 _key) override external view returns (bool r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n    \n    function getInt(bytes32 _key) override external view returns (int r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n    \n    function getBytes32(bytes32 _key) override external view returns (bytes32 r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n\n    \n    function setAddress(bytes32 _key, address _value) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n\n    \n    // SWC-124-Write to Arbitrary Storage Location: L206 - L210\n    function setUint(bytes32 _key, uint _value) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n\n    \n    function setString(bytes32 _key, string calldata _value) onlyLatestRocketNetworkContract override external {\n        stringStorage[_key] = _value;\n    }\n\n    \n    function setBytes(bytes32 _key, bytes calldata _value) onlyLatestRocketNetworkContract override external {\n        bytesStorage[_key] = _value;\n    }\n\n    \n    function setBool(bytes32 _key, bool _value) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n\n    \n    // SWC-124-Write to Arbitrary Storage Location: L231 - L235\n    function setInt(bytes32 _key, int _value) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n\n    \n    function setBytes32(bytes32 _key, bytes32 _value) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n\n\n    \n    function deleteAddress(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, 0)\n        }\n    }\n\n    \n    function deleteUint(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, 0)\n        }\n    }\n\n    \n    function deleteString(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        delete stringStorage[_key];\n    }\n\n    \n    function deleteBytes(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        delete bytesStorage[_key];\n    }\n\n    \n    function deleteBool(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, 0)\n        }\n    }\n\n    \n    function deleteInt(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, 0)\n        }\n    }\n\n    \n    function deleteBytes32(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, 0)\n        }\n    }\n\n\n    \n    \n    function addUint(bytes32 _key, uint256 _amount) onlyLatestRocketNetworkContract override external {\n        uint256 a;\n        uint256 b;\n        assembly {\n            a := sload (_key)\n            b := add(a, _amount)\n            sstore (_key, b)\n        }\n        require(b >= a, \"SafeMath: addition overflow\");\n    }\n\n    \n    \n    function subUint(bytes32 _key, uint256 _amount) onlyLatestRocketNetworkContract override external {\n        uint256 a;\n        assembly {\n            a := sload (_key)\n        }\n        require(_amount <= a, \"SafeMath: subtraction overflow\");\n        assembly {\n            a := sub(a, _amount)\n            sstore (_key, a)\n        }\n    }\n\n    // Private methods\n\n    function _getBool(bytes32 _key) private view returns (bool r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n    function _setBool(bytes32 _key, bool _value) private {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n}",
        "function": "setAddress(bytes32,address)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-RocketPool/rocketpool-a65b203cf99c7a991c2d85a7468a97bfb5dbba31/contracts/contract/RocketStorage.sol",
        "vulnerability": "Write to an arbitrary storage location (SWC 124)",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract RocketStorage is RocketStorageInterface {\n\n    // Events\n    event NodeWithdrawalAddressSet(address indexed node, address indexed withdrawalAddress, uint256 time);\n    event GuardianChanged(address oldGuardian, address newGuardian);\n\n    // Libraries\n    using SafeMath for uint256;\n\n    // Complex storage maps\n    mapping(bytes32 => string)     private stringStorage;\n    mapping(bytes32 => bytes)      private bytesStorage;\n\n    // Protected storage (not accessible by network contracts)\n    mapping(address => address)    private withdrawalAddresses;\n    mapping(address => address)    private pendingWithdrawalAddresses;\n\n    // Guardian address\n    address guardian;\n    address newGuardian;\n\n    // Flag storage has been initialised\n    bool storageInit = false;\n\n    \n    modifier onlyLatestRocketNetworkContract() {\n        if (storageInit == true) {\n            // Make sure the access is permitted to only contracts in our Dapp\n            require(_getBool(keccak256(abi.encodePacked(\"contract.exists\", msg.sender))), \"Invalid or outdated network contract\");\n        } else {\n            // Only Dapp and the guardian account are allowed access during initialisation.\n            // tx.origin is only safe to use in this case for deployment since no external contracts are interacted with\n            // SWC-115-Authorization through tx.origin: L45\n            require((\n                _getBool(keccak256(abi.encodePacked(\"contract.exists\", msg.sender))) || tx.origin == guardian\n            ), \"Invalid or outdated network contract attempting access during deployment\");\n        }\n        _;\n    }\n\n\n    \n    constructor() {\n        // Set the guardian upon deployment\n        guardian = msg.sender;\n    }\n\n    // Get guardian address\n    function getGuardian() external override view returns (address) {\n        return guardian;\n    }\n\n    // Transfers guardianship to a new address\n    function setGuardian(address _newAddress) external override {\n        // Check tx comes from current guardian\n        require(msg.sender == guardian, \"Is not guardian account\");\n        // Store new address awaiting confirmation\n        newGuardian = _newAddress;\n    }\n\n    // Confirms change of guardian\n    function confirmGuardian() external override {\n        // Check tx came from new guardian address\n        require(msg.sender == newGuardian, \"Confirmation must come from new guardian address\");\n        // Store old guardian for event\n        address oldGuardian = guardian;\n        // Update guardian and clear storage\n        guardian = newGuardian;\n        delete newGuardian;\n        // Emit event\n        emit GuardianChanged(oldGuardian, guardian);\n    }\n\n    // Set this as being deployed now\n    function getDeployedStatus() external view returns (bool) {\n        return storageInit;\n    }\n\n    // Set this as being deployed now\n    function setDeployedStatus() external {\n        // Only guardian can lock this down\n        require(msg.sender == guardian, \"Is not guardian account\");\n        // Set it now\n        storageInit = true;\n    }\n\n    // Protected storage\n\n    // Get a node's withdrawal address\n    function getNodeWithdrawalAddress(address _nodeAddress) public override view returns (address) {\n        // Check if _nodeAddress is a valid node\n        if (!_getBool(keccak256(abi.encodePacked(\"node.exists\", _nodeAddress)))) {\n            return address(0);\n        }\n        // If no withdrawal address has been set, return the nodes address\n        address withdrawalAddress = withdrawalAddresses[_nodeAddress];\n        if (withdrawalAddress == address(0)) {\n            return _nodeAddress;\n        }\n        return withdrawalAddress;\n    }\n\n    // Get a node's pending withdrawal address\n    function getNodePendingWithdrawalAddress(address _nodeAddress) external override view returns (address) {\n        return pendingWithdrawalAddresses[_nodeAddress];\n    }\n\n    // Set a node's withdrawal address\n    function setWithdrawalAddress(address _nodeAddress, address _newWithdrawalAddress, bool _confirm) external override {\n        // Check new withdrawal address\n        require(_newWithdrawalAddress != address(0x0), \"Invalid withdrawal address\");\n        // Confirm the transaction is from the node's current withdrawal address\n        address withdrawalAddress = getNodeWithdrawalAddress(_nodeAddress);\n        require(withdrawalAddress == msg.sender, \"Only a tx from a node's withdrawal address can update it\");\n        // Update immediately if confirmed\n        if (_confirm) {\n            updateWithdrawalAddress(_nodeAddress, _newWithdrawalAddress);\n        }\n        // Set pending withdrawal address if not confirmed\n        else {\n            pendingWithdrawalAddresses[_nodeAddress] = _newWithdrawalAddress;\n        }\n    }\n\n    // Confirm a node's new withdrawal address\n    function confirmWithdrawalAddress(address _nodeAddress) external override {\n        // Get node by pending withdrawal address\n        require(pendingWithdrawalAddresses[_nodeAddress] == msg.sender, \"Confirmation must come from the pending withdrawal address\");\n        delete pendingWithdrawalAddresses[_nodeAddress];\n        // Update withdrawal address\n        updateWithdrawalAddress(_nodeAddress, msg.sender);\n    }\n\n    // Update a node's withdrawal address\n    function updateWithdrawalAddress(address _nodeAddress, address _newWithdrawalAddress) private {\n        // Set new withdrawal address\n        withdrawalAddresses[_nodeAddress] = _newWithdrawalAddress;\n        // Emit withdrawal address set event\n        emit NodeWithdrawalAddressSet(_nodeAddress, _newWithdrawalAddress, block.timestamp);\n    }\n\n    \n    function getAddress(bytes32 _key) override external view returns (address r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n    \n    function getUint(bytes32 _key) override external view returns (uint256 r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n    \n    function getString(bytes32 _key) override external view returns (string memory) {\n        return stringStorage[_key];\n    }\n\n    \n    function getBytes(bytes32 _key) override external view returns (bytes memory) {\n        return bytesStorage[_key];\n    }\n\n    \n    function getBool(bytes32 _key) override external view returns (bool r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n    \n    function getInt(bytes32 _key) override external view returns (int r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n    \n    function getBytes32(bytes32 _key) override external view returns (bytes32 r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n\n    \n    function setAddress(bytes32 _key, address _value) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n\n    \n    // SWC-124-Write to Arbitrary Storage Location: L206 - L210\n    function setUint(bytes32 _key, uint _value) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n\n    \n    function setString(bytes32 _key, string calldata _value) onlyLatestRocketNetworkContract override external {\n        stringStorage[_key] = _value;\n    }\n\n    \n    function setBytes(bytes32 _key, bytes calldata _value) onlyLatestRocketNetworkContract override external {\n        bytesStorage[_key] = _value;\n    }\n\n    \n    function setBool(bytes32 _key, bool _value) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n\n    \n    // SWC-124-Write to Arbitrary Storage Location: L231 - L235\n    function setInt(bytes32 _key, int _value) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n\n    \n    function setBytes32(bytes32 _key, bytes32 _value) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n\n\n    \n    function deleteAddress(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, 0)\n        }\n    }\n\n    \n    function deleteUint(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, 0)\n        }\n    }\n\n    \n    function deleteString(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        delete stringStorage[_key];\n    }\n\n    \n    function deleteBytes(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        delete bytesStorage[_key];\n    }\n\n    \n    function deleteBool(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, 0)\n        }\n    }\n\n    \n    function deleteInt(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, 0)\n        }\n    }\n\n    \n    function deleteBytes32(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, 0)\n        }\n    }\n\n\n    \n    \n    function addUint(bytes32 _key, uint256 _amount) onlyLatestRocketNetworkContract override external {\n        uint256 a;\n        uint256 b;\n        assembly {\n            a := sload (_key)\n            b := add(a, _amount)\n            sstore (_key, b)\n        }\n        require(b >= a, \"SafeMath: addition overflow\");\n    }\n\n    \n    \n    function subUint(bytes32 _key, uint256 _amount) onlyLatestRocketNetworkContract override external {\n        uint256 a;\n        assembly {\n            a := sload (_key)\n        }\n        require(_amount <= a, \"SafeMath: subtraction overflow\");\n        assembly {\n            a := sub(a, _amount)\n            sstore (_key, a)\n        }\n    }\n\n    // Private methods\n\n    function _getBool(bytes32 _key) private view returns (bool r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n    function _setBool(bytes32 _key, bool _value) private {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n}",
        "function": "setUint(bytes32,uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-RocketPool/rocketpool-a65b203cf99c7a991c2d85a7468a97bfb5dbba31/contracts/contract/RocketStorage.sol",
        "vulnerability": "Dependence on tx.origin (SWC 115)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract RocketStorage is RocketStorageInterface {\n\n    // Events\n    event NodeWithdrawalAddressSet(address indexed node, address indexed withdrawalAddress, uint256 time);\n    event GuardianChanged(address oldGuardian, address newGuardian);\n\n    // Libraries\n    using SafeMath for uint256;\n\n    // Complex storage maps\n    mapping(bytes32 => string)     private stringStorage;\n    mapping(bytes32 => bytes)      private bytesStorage;\n\n    // Protected storage (not accessible by network contracts)\n    mapping(address => address)    private withdrawalAddresses;\n    mapping(address => address)    private pendingWithdrawalAddresses;\n\n    // Guardian address\n    address guardian;\n    address newGuardian;\n\n    // Flag storage has been initialised\n    bool storageInit = false;\n\n    \n    modifier onlyLatestRocketNetworkContract() {\n        if (storageInit == true) {\n            // Make sure the access is permitted to only contracts in our Dapp\n            require(_getBool(keccak256(abi.encodePacked(\"contract.exists\", msg.sender))), \"Invalid or outdated network contract\");\n        } else {\n            // Only Dapp and the guardian account are allowed access during initialisation.\n            // tx.origin is only safe to use in this case for deployment since no external contracts are interacted with\n            // SWC-115-Authorization through tx.origin: L45\n            require((\n                _getBool(keccak256(abi.encodePacked(\"contract.exists\", msg.sender))) || tx.origin == guardian\n            ), \"Invalid or outdated network contract attempting access during deployment\");\n        }\n        _;\n    }\n\n\n    \n    constructor() {\n        // Set the guardian upon deployment\n        guardian = msg.sender;\n    }\n\n    // Get guardian address\n    function getGuardian() external override view returns (address) {\n        return guardian;\n    }\n\n    // Transfers guardianship to a new address\n    function setGuardian(address _newAddress) external override {\n        // Check tx comes from current guardian\n        require(msg.sender == guardian, \"Is not guardian account\");\n        // Store new address awaiting confirmation\n        newGuardian = _newAddress;\n    }\n\n    // Confirms change of guardian\n    function confirmGuardian() external override {\n        // Check tx came from new guardian address\n        require(msg.sender == newGuardian, \"Confirmation must come from new guardian address\");\n        // Store old guardian for event\n        address oldGuardian = guardian;\n        // Update guardian and clear storage\n        guardian = newGuardian;\n        delete newGuardian;\n        // Emit event\n        emit GuardianChanged(oldGuardian, guardian);\n    }\n\n    // Set this as being deployed now\n    function getDeployedStatus() external view returns (bool) {\n        return storageInit;\n    }\n\n    // Set this as being deployed now\n    function setDeployedStatus() external {\n        // Only guardian can lock this down\n        require(msg.sender == guardian, \"Is not guardian account\");\n        // Set it now\n        storageInit = true;\n    }\n\n    // Protected storage\n\n    // Get a node's withdrawal address\n    function getNodeWithdrawalAddress(address _nodeAddress) public override view returns (address) {\n        // Check if _nodeAddress is a valid node\n        if (!_getBool(keccak256(abi.encodePacked(\"node.exists\", _nodeAddress)))) {\n            return address(0);\n        }\n        // If no withdrawal address has been set, return the nodes address\n        address withdrawalAddress = withdrawalAddresses[_nodeAddress];\n        if (withdrawalAddress == address(0)) {\n            return _nodeAddress;\n        }\n        return withdrawalAddress;\n    }\n\n    // Get a node's pending withdrawal address\n    function getNodePendingWithdrawalAddress(address _nodeAddress) external override view returns (address) {\n        return pendingWithdrawalAddresses[_nodeAddress];\n    }\n\n    // Set a node's withdrawal address\n    function setWithdrawalAddress(address _nodeAddress, address _newWithdrawalAddress, bool _confirm) external override {\n        // Check new withdrawal address\n        require(_newWithdrawalAddress != address(0x0), \"Invalid withdrawal address\");\n        // Confirm the transaction is from the node's current withdrawal address\n        address withdrawalAddress = getNodeWithdrawalAddress(_nodeAddress);\n        require(withdrawalAddress == msg.sender, \"Only a tx from a node's withdrawal address can update it\");\n        // Update immediately if confirmed\n        if (_confirm) {\n            updateWithdrawalAddress(_nodeAddress, _newWithdrawalAddress);\n        }\n        // Set pending withdrawal address if not confirmed\n        else {\n            pendingWithdrawalAddresses[_nodeAddress] = _newWithdrawalAddress;\n        }\n    }\n\n    // Confirm a node's new withdrawal address\n    function confirmWithdrawalAddress(address _nodeAddress) external override {\n        // Get node by pending withdrawal address\n        require(pendingWithdrawalAddresses[_nodeAddress] == msg.sender, \"Confirmation must come from the pending withdrawal address\");\n        delete pendingWithdrawalAddresses[_nodeAddress];\n        // Update withdrawal address\n        updateWithdrawalAddress(_nodeAddress, msg.sender);\n    }\n\n    // Update a node's withdrawal address\n    function updateWithdrawalAddress(address _nodeAddress, address _newWithdrawalAddress) private {\n        // Set new withdrawal address\n        withdrawalAddresses[_nodeAddress] = _newWithdrawalAddress;\n        // Emit withdrawal address set event\n        emit NodeWithdrawalAddressSet(_nodeAddress, _newWithdrawalAddress, block.timestamp);\n    }\n\n    \n    function getAddress(bytes32 _key) override external view returns (address r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n    \n    function getUint(bytes32 _key) override external view returns (uint256 r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n    \n    function getString(bytes32 _key) override external view returns (string memory) {\n        return stringStorage[_key];\n    }\n\n    \n    function getBytes(bytes32 _key) override external view returns (bytes memory) {\n        return bytesStorage[_key];\n    }\n\n    \n    function getBool(bytes32 _key) override external view returns (bool r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n    \n    function getInt(bytes32 _key) override external view returns (int r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n    \n    function getBytes32(bytes32 _key) override external view returns (bytes32 r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n\n    \n    function setAddress(bytes32 _key, address _value) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n\n    \n    // SWC-124-Write to Arbitrary Storage Location: L206 - L210\n    function setUint(bytes32 _key, uint _value) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n\n    \n    function setString(bytes32 _key, string calldata _value) onlyLatestRocketNetworkContract override external {\n        stringStorage[_key] = _value;\n    }\n\n    \n    function setBytes(bytes32 _key, bytes calldata _value) onlyLatestRocketNetworkContract override external {\n        bytesStorage[_key] = _value;\n    }\n\n    \n    function setBool(bytes32 _key, bool _value) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n\n    \n    // SWC-124-Write to Arbitrary Storage Location: L231 - L235\n    function setInt(bytes32 _key, int _value) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n\n    \n    function setBytes32(bytes32 _key, bytes32 _value) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n\n\n    \n    function deleteAddress(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, 0)\n        }\n    }\n\n    \n    function deleteUint(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, 0)\n        }\n    }\n\n    \n    function deleteString(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        delete stringStorage[_key];\n    }\n\n    \n    function deleteBytes(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        delete bytesStorage[_key];\n    }\n\n    \n    function deleteBool(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, 0)\n        }\n    }\n\n    \n    function deleteInt(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, 0)\n        }\n    }\n\n    \n    function deleteBytes32(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, 0)\n        }\n    }\n\n\n    \n    \n    function addUint(bytes32 _key, uint256 _amount) onlyLatestRocketNetworkContract override external {\n        uint256 a;\n        uint256 b;\n        assembly {\n            a := sload (_key)\n            b := add(a, _amount)\n            sstore (_key, b)\n        }\n        require(b >= a, \"SafeMath: addition overflow\");\n    }\n\n    \n    \n    function subUint(bytes32 _key, uint256 _amount) onlyLatestRocketNetworkContract override external {\n        uint256 a;\n        assembly {\n            a := sload (_key)\n        }\n        require(_amount <= a, \"SafeMath: subtraction overflow\");\n        assembly {\n            a := sub(a, _amount)\n            sstore (_key, a)\n        }\n    }\n\n    // Private methods\n\n    function _getBool(bytes32 _key) private view returns (bool r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n    function _setBool(bytes32 _key, bool _value) private {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n}",
        "function": "setUint(bytes32,uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-RocketPool/rocketpool-a65b203cf99c7a991c2d85a7468a97bfb5dbba31/contracts/contract/RocketStorage.sol",
        "vulnerability": "Write to an arbitrary storage location (SWC 124)",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract RocketStorage is RocketStorageInterface {\n\n    // Events\n    event NodeWithdrawalAddressSet(address indexed node, address indexed withdrawalAddress, uint256 time);\n    event GuardianChanged(address oldGuardian, address newGuardian);\n\n    // Libraries\n    using SafeMath for uint256;\n\n    // Complex storage maps\n    mapping(bytes32 => string)     private stringStorage;\n    mapping(bytes32 => bytes)      private bytesStorage;\n\n    // Protected storage (not accessible by network contracts)\n    mapping(address => address)    private withdrawalAddresses;\n    mapping(address => address)    private pendingWithdrawalAddresses;\n\n    // Guardian address\n    address guardian;\n    address newGuardian;\n\n    // Flag storage has been initialised\n    bool storageInit = false;\n\n    \n    modifier onlyLatestRocketNetworkContract() {\n        if (storageInit == true) {\n            // Make sure the access is permitted to only contracts in our Dapp\n            require(_getBool(keccak256(abi.encodePacked(\"contract.exists\", msg.sender))), \"Invalid or outdated network contract\");\n        } else {\n            // Only Dapp and the guardian account are allowed access during initialisation.\n            // tx.origin is only safe to use in this case for deployment since no external contracts are interacted with\n            // SWC-115-Authorization through tx.origin: L45\n            require((\n                _getBool(keccak256(abi.encodePacked(\"contract.exists\", msg.sender))) || tx.origin == guardian\n            ), \"Invalid or outdated network contract attempting access during deployment\");\n        }\n        _;\n    }\n\n\n    \n    constructor() {\n        // Set the guardian upon deployment\n        guardian = msg.sender;\n    }\n\n    // Get guardian address\n    function getGuardian() external override view returns (address) {\n        return guardian;\n    }\n\n    // Transfers guardianship to a new address\n    function setGuardian(address _newAddress) external override {\n        // Check tx comes from current guardian\n        require(msg.sender == guardian, \"Is not guardian account\");\n        // Store new address awaiting confirmation\n        newGuardian = _newAddress;\n    }\n\n    // Confirms change of guardian\n    function confirmGuardian() external override {\n        // Check tx came from new guardian address\n        require(msg.sender == newGuardian, \"Confirmation must come from new guardian address\");\n        // Store old guardian for event\n        address oldGuardian = guardian;\n        // Update guardian and clear storage\n        guardian = newGuardian;\n        delete newGuardian;\n        // Emit event\n        emit GuardianChanged(oldGuardian, guardian);\n    }\n\n    // Set this as being deployed now\n    function getDeployedStatus() external view returns (bool) {\n        return storageInit;\n    }\n\n    // Set this as being deployed now\n    function setDeployedStatus() external {\n        // Only guardian can lock this down\n        require(msg.sender == guardian, \"Is not guardian account\");\n        // Set it now\n        storageInit = true;\n    }\n\n    // Protected storage\n\n    // Get a node's withdrawal address\n    function getNodeWithdrawalAddress(address _nodeAddress) public override view returns (address) {\n        // Check if _nodeAddress is a valid node\n        if (!_getBool(keccak256(abi.encodePacked(\"node.exists\", _nodeAddress)))) {\n            return address(0);\n        }\n        // If no withdrawal address has been set, return the nodes address\n        address withdrawalAddress = withdrawalAddresses[_nodeAddress];\n        if (withdrawalAddress == address(0)) {\n            return _nodeAddress;\n        }\n        return withdrawalAddress;\n    }\n\n    // Get a node's pending withdrawal address\n    function getNodePendingWithdrawalAddress(address _nodeAddress) external override view returns (address) {\n        return pendingWithdrawalAddresses[_nodeAddress];\n    }\n\n    // Set a node's withdrawal address\n    function setWithdrawalAddress(address _nodeAddress, address _newWithdrawalAddress, bool _confirm) external override {\n        // Check new withdrawal address\n        require(_newWithdrawalAddress != address(0x0), \"Invalid withdrawal address\");\n        // Confirm the transaction is from the node's current withdrawal address\n        address withdrawalAddress = getNodeWithdrawalAddress(_nodeAddress);\n        require(withdrawalAddress == msg.sender, \"Only a tx from a node's withdrawal address can update it\");\n        // Update immediately if confirmed\n        if (_confirm) {\n            updateWithdrawalAddress(_nodeAddress, _newWithdrawalAddress);\n        }\n        // Set pending withdrawal address if not confirmed\n        else {\n            pendingWithdrawalAddresses[_nodeAddress] = _newWithdrawalAddress;\n        }\n    }\n\n    // Confirm a node's new withdrawal address\n    function confirmWithdrawalAddress(address _nodeAddress) external override {\n        // Get node by pending withdrawal address\n        require(pendingWithdrawalAddresses[_nodeAddress] == msg.sender, \"Confirmation must come from the pending withdrawal address\");\n        delete pendingWithdrawalAddresses[_nodeAddress];\n        // Update withdrawal address\n        updateWithdrawalAddress(_nodeAddress, msg.sender);\n    }\n\n    // Update a node's withdrawal address\n    function updateWithdrawalAddress(address _nodeAddress, address _newWithdrawalAddress) private {\n        // Set new withdrawal address\n        withdrawalAddresses[_nodeAddress] = _newWithdrawalAddress;\n        // Emit withdrawal address set event\n        emit NodeWithdrawalAddressSet(_nodeAddress, _newWithdrawalAddress, block.timestamp);\n    }\n\n    \n    function getAddress(bytes32 _key) override external view returns (address r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n    \n    function getUint(bytes32 _key) override external view returns (uint256 r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n    \n    function getString(bytes32 _key) override external view returns (string memory) {\n        return stringStorage[_key];\n    }\n\n    \n    function getBytes(bytes32 _key) override external view returns (bytes memory) {\n        return bytesStorage[_key];\n    }\n\n    \n    function getBool(bytes32 _key) override external view returns (bool r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n    \n    function getInt(bytes32 _key) override external view returns (int r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n    \n    function getBytes32(bytes32 _key) override external view returns (bytes32 r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n\n    \n    function setAddress(bytes32 _key, address _value) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n\n    \n    // SWC-124-Write to Arbitrary Storage Location: L206 - L210\n    function setUint(bytes32 _key, uint _value) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n\n    \n    function setString(bytes32 _key, string calldata _value) onlyLatestRocketNetworkContract override external {\n        stringStorage[_key] = _value;\n    }\n\n    \n    function setBytes(bytes32 _key, bytes calldata _value) onlyLatestRocketNetworkContract override external {\n        bytesStorage[_key] = _value;\n    }\n\n    \n    function setBool(bytes32 _key, bool _value) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n\n    \n    // SWC-124-Write to Arbitrary Storage Location: L231 - L235\n    function setInt(bytes32 _key, int _value) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n\n    \n    function setBytes32(bytes32 _key, bytes32 _value) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n\n\n    \n    function deleteAddress(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, 0)\n        }\n    }\n\n    \n    function deleteUint(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, 0)\n        }\n    }\n\n    \n    function deleteString(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        delete stringStorage[_key];\n    }\n\n    \n    function deleteBytes(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        delete bytesStorage[_key];\n    }\n\n    \n    function deleteBool(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, 0)\n        }\n    }\n\n    \n    function deleteInt(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, 0)\n        }\n    }\n\n    \n    function deleteBytes32(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, 0)\n        }\n    }\n\n\n    \n    \n    function addUint(bytes32 _key, uint256 _amount) onlyLatestRocketNetworkContract override external {\n        uint256 a;\n        uint256 b;\n        assembly {\n            a := sload (_key)\n            b := add(a, _amount)\n            sstore (_key, b)\n        }\n        require(b >= a, \"SafeMath: addition overflow\");\n    }\n\n    \n    \n    function subUint(bytes32 _key, uint256 _amount) onlyLatestRocketNetworkContract override external {\n        uint256 a;\n        assembly {\n            a := sload (_key)\n        }\n        require(_amount <= a, \"SafeMath: subtraction overflow\");\n        assembly {\n            a := sub(a, _amount)\n            sstore (_key, a)\n        }\n    }\n\n    // Private methods\n\n    function _getBool(bytes32 _key) private view returns (bool r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n    function _setBool(bytes32 _key, bool _value) private {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n}",
        "function": "deleteUint(bytes32)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-RocketPool/rocketpool-a65b203cf99c7a991c2d85a7468a97bfb5dbba31/contracts/contract/RocketStorage.sol",
        "vulnerability": "Dependence on tx.origin (SWC 115)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract RocketStorage is RocketStorageInterface {\n\n    // Events\n    event NodeWithdrawalAddressSet(address indexed node, address indexed withdrawalAddress, uint256 time);\n    event GuardianChanged(address oldGuardian, address newGuardian);\n\n    // Libraries\n    using SafeMath for uint256;\n\n    // Complex storage maps\n    mapping(bytes32 => string)     private stringStorage;\n    mapping(bytes32 => bytes)      private bytesStorage;\n\n    // Protected storage (not accessible by network contracts)\n    mapping(address => address)    private withdrawalAddresses;\n    mapping(address => address)    private pendingWithdrawalAddresses;\n\n    // Guardian address\n    address guardian;\n    address newGuardian;\n\n    // Flag storage has been initialised\n    bool storageInit = false;\n\n    \n    modifier onlyLatestRocketNetworkContract() {\n        if (storageInit == true) {\n            // Make sure the access is permitted to only contracts in our Dapp\n            require(_getBool(keccak256(abi.encodePacked(\"contract.exists\", msg.sender))), \"Invalid or outdated network contract\");\n        } else {\n            // Only Dapp and the guardian account are allowed access during initialisation.\n            // tx.origin is only safe to use in this case for deployment since no external contracts are interacted with\n            // SWC-115-Authorization through tx.origin: L45\n            require((\n                _getBool(keccak256(abi.encodePacked(\"contract.exists\", msg.sender))) || tx.origin == guardian\n            ), \"Invalid or outdated network contract attempting access during deployment\");\n        }\n        _;\n    }\n\n\n    \n    constructor() {\n        // Set the guardian upon deployment\n        guardian = msg.sender;\n    }\n\n    // Get guardian address\n    function getGuardian() external override view returns (address) {\n        return guardian;\n    }\n\n    // Transfers guardianship to a new address\n    function setGuardian(address _newAddress) external override {\n        // Check tx comes from current guardian\n        require(msg.sender == guardian, \"Is not guardian account\");\n        // Store new address awaiting confirmation\n        newGuardian = _newAddress;\n    }\n\n    // Confirms change of guardian\n    function confirmGuardian() external override {\n        // Check tx came from new guardian address\n        require(msg.sender == newGuardian, \"Confirmation must come from new guardian address\");\n        // Store old guardian for event\n        address oldGuardian = guardian;\n        // Update guardian and clear storage\n        guardian = newGuardian;\n        delete newGuardian;\n        // Emit event\n        emit GuardianChanged(oldGuardian, guardian);\n    }\n\n    // Set this as being deployed now\n    function getDeployedStatus() external view returns (bool) {\n        return storageInit;\n    }\n\n    // Set this as being deployed now\n    function setDeployedStatus() external {\n        // Only guardian can lock this down\n        require(msg.sender == guardian, \"Is not guardian account\");\n        // Set it now\n        storageInit = true;\n    }\n\n    // Protected storage\n\n    // Get a node's withdrawal address\n    function getNodeWithdrawalAddress(address _nodeAddress) public override view returns (address) {\n        // Check if _nodeAddress is a valid node\n        if (!_getBool(keccak256(abi.encodePacked(\"node.exists\", _nodeAddress)))) {\n            return address(0);\n        }\n        // If no withdrawal address has been set, return the nodes address\n        address withdrawalAddress = withdrawalAddresses[_nodeAddress];\n        if (withdrawalAddress == address(0)) {\n            return _nodeAddress;\n        }\n        return withdrawalAddress;\n    }\n\n    // Get a node's pending withdrawal address\n    function getNodePendingWithdrawalAddress(address _nodeAddress) external override view returns (address) {\n        return pendingWithdrawalAddresses[_nodeAddress];\n    }\n\n    // Set a node's withdrawal address\n    function setWithdrawalAddress(address _nodeAddress, address _newWithdrawalAddress, bool _confirm) external override {\n        // Check new withdrawal address\n        require(_newWithdrawalAddress != address(0x0), \"Invalid withdrawal address\");\n        // Confirm the transaction is from the node's current withdrawal address\n        address withdrawalAddress = getNodeWithdrawalAddress(_nodeAddress);\n        require(withdrawalAddress == msg.sender, \"Only a tx from a node's withdrawal address can update it\");\n        // Update immediately if confirmed\n        if (_confirm) {\n            updateWithdrawalAddress(_nodeAddress, _newWithdrawalAddress);\n        }\n        // Set pending withdrawal address if not confirmed\n        else {\n            pendingWithdrawalAddresses[_nodeAddress] = _newWithdrawalAddress;\n        }\n    }\n\n    // Confirm a node's new withdrawal address\n    function confirmWithdrawalAddress(address _nodeAddress) external override {\n        // Get node by pending withdrawal address\n        require(pendingWithdrawalAddresses[_nodeAddress] == msg.sender, \"Confirmation must come from the pending withdrawal address\");\n        delete pendingWithdrawalAddresses[_nodeAddress];\n        // Update withdrawal address\n        updateWithdrawalAddress(_nodeAddress, msg.sender);\n    }\n\n    // Update a node's withdrawal address\n    function updateWithdrawalAddress(address _nodeAddress, address _newWithdrawalAddress) private {\n        // Set new withdrawal address\n        withdrawalAddresses[_nodeAddress] = _newWithdrawalAddress;\n        // Emit withdrawal address set event\n        emit NodeWithdrawalAddressSet(_nodeAddress, _newWithdrawalAddress, block.timestamp);\n    }\n\n    \n    function getAddress(bytes32 _key) override external view returns (address r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n    \n    function getUint(bytes32 _key) override external view returns (uint256 r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n    \n    function getString(bytes32 _key) override external view returns (string memory) {\n        return stringStorage[_key];\n    }\n\n    \n    function getBytes(bytes32 _key) override external view returns (bytes memory) {\n        return bytesStorage[_key];\n    }\n\n    \n    function getBool(bytes32 _key) override external view returns (bool r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n    \n    function getInt(bytes32 _key) override external view returns (int r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n    \n    function getBytes32(bytes32 _key) override external view returns (bytes32 r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n\n    \n    function setAddress(bytes32 _key, address _value) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n\n    \n    // SWC-124-Write to Arbitrary Storage Location: L206 - L210\n    function setUint(bytes32 _key, uint _value) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n\n    \n    function setString(bytes32 _key, string calldata _value) onlyLatestRocketNetworkContract override external {\n        stringStorage[_key] = _value;\n    }\n\n    \n    function setBytes(bytes32 _key, bytes calldata _value) onlyLatestRocketNetworkContract override external {\n        bytesStorage[_key] = _value;\n    }\n\n    \n    function setBool(bytes32 _key, bool _value) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n\n    \n    // SWC-124-Write to Arbitrary Storage Location: L231 - L235\n    function setInt(bytes32 _key, int _value) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n\n    \n    function setBytes32(bytes32 _key, bytes32 _value) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n\n\n    \n    function deleteAddress(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, 0)\n        }\n    }\n\n    \n    function deleteUint(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, 0)\n        }\n    }\n\n    \n    function deleteString(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        delete stringStorage[_key];\n    }\n\n    \n    function deleteBytes(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        delete bytesStorage[_key];\n    }\n\n    \n    function deleteBool(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, 0)\n        }\n    }\n\n    \n    function deleteInt(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, 0)\n        }\n    }\n\n    \n    function deleteBytes32(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, 0)\n        }\n    }\n\n\n    \n    \n    function addUint(bytes32 _key, uint256 _amount) onlyLatestRocketNetworkContract override external {\n        uint256 a;\n        uint256 b;\n        assembly {\n            a := sload (_key)\n            b := add(a, _amount)\n            sstore (_key, b)\n        }\n        require(b >= a, \"SafeMath: addition overflow\");\n    }\n\n    \n    \n    function subUint(bytes32 _key, uint256 _amount) onlyLatestRocketNetworkContract override external {\n        uint256 a;\n        assembly {\n            a := sload (_key)\n        }\n        require(_amount <= a, \"SafeMath: subtraction overflow\");\n        assembly {\n            a := sub(a, _amount)\n            sstore (_key, a)\n        }\n    }\n\n    // Private methods\n\n    function _getBool(bytes32 _key) private view returns (bool r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n    function _setBool(bytes32 _key, bool _value) private {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n}",
        "function": "deleteUint(bytes32)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-RocketPool/rocketpool-a65b203cf99c7a991c2d85a7468a97bfb5dbba31/contracts/contract/RocketStorage.sol",
        "vulnerability": "Write to an arbitrary storage location (SWC 124)",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract RocketStorage is RocketStorageInterface {\n\n    // Events\n    event NodeWithdrawalAddressSet(address indexed node, address indexed withdrawalAddress, uint256 time);\n    event GuardianChanged(address oldGuardian, address newGuardian);\n\n    // Libraries\n    using SafeMath for uint256;\n\n    // Complex storage maps\n    mapping(bytes32 => string)     private stringStorage;\n    mapping(bytes32 => bytes)      private bytesStorage;\n\n    // Protected storage (not accessible by network contracts)\n    mapping(address => address)    private withdrawalAddresses;\n    mapping(address => address)    private pendingWithdrawalAddresses;\n\n    // Guardian address\n    address guardian;\n    address newGuardian;\n\n    // Flag storage has been initialised\n    bool storageInit = false;\n\n    \n    modifier onlyLatestRocketNetworkContract() {\n        if (storageInit == true) {\n            // Make sure the access is permitted to only contracts in our Dapp\n            require(_getBool(keccak256(abi.encodePacked(\"contract.exists\", msg.sender))), \"Invalid or outdated network contract\");\n        } else {\n            // Only Dapp and the guardian account are allowed access during initialisation.\n            // tx.origin is only safe to use in this case for deployment since no external contracts are interacted with\n            // SWC-115-Authorization through tx.origin: L45\n            require((\n                _getBool(keccak256(abi.encodePacked(\"contract.exists\", msg.sender))) || tx.origin == guardian\n            ), \"Invalid or outdated network contract attempting access during deployment\");\n        }\n        _;\n    }\n\n\n    \n    constructor() {\n        // Set the guardian upon deployment\n        guardian = msg.sender;\n    }\n\n    // Get guardian address\n    function getGuardian() external override view returns (address) {\n        return guardian;\n    }\n\n    // Transfers guardianship to a new address\n    function setGuardian(address _newAddress) external override {\n        // Check tx comes from current guardian\n        require(msg.sender == guardian, \"Is not guardian account\");\n        // Store new address awaiting confirmation\n        newGuardian = _newAddress;\n    }\n\n    // Confirms change of guardian\n    function confirmGuardian() external override {\n        // Check tx came from new guardian address\n        require(msg.sender == newGuardian, \"Confirmation must come from new guardian address\");\n        // Store old guardian for event\n        address oldGuardian = guardian;\n        // Update guardian and clear storage\n        guardian = newGuardian;\n        delete newGuardian;\n        // Emit event\n        emit GuardianChanged(oldGuardian, guardian);\n    }\n\n    // Set this as being deployed now\n    function getDeployedStatus() external view returns (bool) {\n        return storageInit;\n    }\n\n    // Set this as being deployed now\n    function setDeployedStatus() external {\n        // Only guardian can lock this down\n        require(msg.sender == guardian, \"Is not guardian account\");\n        // Set it now\n        storageInit = true;\n    }\n\n    // Protected storage\n\n    // Get a node's withdrawal address\n    function getNodeWithdrawalAddress(address _nodeAddress) public override view returns (address) {\n        // Check if _nodeAddress is a valid node\n        if (!_getBool(keccak256(abi.encodePacked(\"node.exists\", _nodeAddress)))) {\n            return address(0);\n        }\n        // If no withdrawal address has been set, return the nodes address\n        address withdrawalAddress = withdrawalAddresses[_nodeAddress];\n        if (withdrawalAddress == address(0)) {\n            return _nodeAddress;\n        }\n        return withdrawalAddress;\n    }\n\n    // Get a node's pending withdrawal address\n    function getNodePendingWithdrawalAddress(address _nodeAddress) external override view returns (address) {\n        return pendingWithdrawalAddresses[_nodeAddress];\n    }\n\n    // Set a node's withdrawal address\n    function setWithdrawalAddress(address _nodeAddress, address _newWithdrawalAddress, bool _confirm) external override {\n        // Check new withdrawal address\n        require(_newWithdrawalAddress != address(0x0), \"Invalid withdrawal address\");\n        // Confirm the transaction is from the node's current withdrawal address\n        address withdrawalAddress = getNodeWithdrawalAddress(_nodeAddress);\n        require(withdrawalAddress == msg.sender, \"Only a tx from a node's withdrawal address can update it\");\n        // Update immediately if confirmed\n        if (_confirm) {\n            updateWithdrawalAddress(_nodeAddress, _newWithdrawalAddress);\n        }\n        // Set pending withdrawal address if not confirmed\n        else {\n            pendingWithdrawalAddresses[_nodeAddress] = _newWithdrawalAddress;\n        }\n    }\n\n    // Confirm a node's new withdrawal address\n    function confirmWithdrawalAddress(address _nodeAddress) external override {\n        // Get node by pending withdrawal address\n        require(pendingWithdrawalAddresses[_nodeAddress] == msg.sender, \"Confirmation must come from the pending withdrawal address\");\n        delete pendingWithdrawalAddresses[_nodeAddress];\n        // Update withdrawal address\n        updateWithdrawalAddress(_nodeAddress, msg.sender);\n    }\n\n    // Update a node's withdrawal address\n    function updateWithdrawalAddress(address _nodeAddress, address _newWithdrawalAddress) private {\n        // Set new withdrawal address\n        withdrawalAddresses[_nodeAddress] = _newWithdrawalAddress;\n        // Emit withdrawal address set event\n        emit NodeWithdrawalAddressSet(_nodeAddress, _newWithdrawalAddress, block.timestamp);\n    }\n\n    \n    function getAddress(bytes32 _key) override external view returns (address r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n    \n    function getUint(bytes32 _key) override external view returns (uint256 r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n    \n    function getString(bytes32 _key) override external view returns (string memory) {\n        return stringStorage[_key];\n    }\n\n    \n    function getBytes(bytes32 _key) override external view returns (bytes memory) {\n        return bytesStorage[_key];\n    }\n\n    \n    function getBool(bytes32 _key) override external view returns (bool r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n    \n    function getInt(bytes32 _key) override external view returns (int r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n    \n    function getBytes32(bytes32 _key) override external view returns (bytes32 r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n\n    \n    function setAddress(bytes32 _key, address _value) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n\n    \n    // SWC-124-Write to Arbitrary Storage Location: L206 - L210\n    function setUint(bytes32 _key, uint _value) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n\n    \n    function setString(bytes32 _key, string calldata _value) onlyLatestRocketNetworkContract override external {\n        stringStorage[_key] = _value;\n    }\n\n    \n    function setBytes(bytes32 _key, bytes calldata _value) onlyLatestRocketNetworkContract override external {\n        bytesStorage[_key] = _value;\n    }\n\n    \n    function setBool(bytes32 _key, bool _value) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n\n    \n    // SWC-124-Write to Arbitrary Storage Location: L231 - L235\n    function setInt(bytes32 _key, int _value) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n\n    \n    function setBytes32(bytes32 _key, bytes32 _value) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n\n\n    \n    function deleteAddress(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, 0)\n        }\n    }\n\n    \n    function deleteUint(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, 0)\n        }\n    }\n\n    \n    function deleteString(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        delete stringStorage[_key];\n    }\n\n    \n    function deleteBytes(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        delete bytesStorage[_key];\n    }\n\n    \n    function deleteBool(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, 0)\n        }\n    }\n\n    \n    function deleteInt(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, 0)\n        }\n    }\n\n    \n    function deleteBytes32(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, 0)\n        }\n    }\n\n\n    \n    \n    function addUint(bytes32 _key, uint256 _amount) onlyLatestRocketNetworkContract override external {\n        uint256 a;\n        uint256 b;\n        assembly {\n            a := sload (_key)\n            b := add(a, _amount)\n            sstore (_key, b)\n        }\n        require(b >= a, \"SafeMath: addition overflow\");\n    }\n\n    \n    \n    function subUint(bytes32 _key, uint256 _amount) onlyLatestRocketNetworkContract override external {\n        uint256 a;\n        assembly {\n            a := sload (_key)\n        }\n        require(_amount <= a, \"SafeMath: subtraction overflow\");\n        assembly {\n            a := sub(a, _amount)\n            sstore (_key, a)\n        }\n    }\n\n    // Private methods\n\n    function _getBool(bytes32 _key) private view returns (bool r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n    function _setBool(bytes32 _key, bool _value) private {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n}",
        "function": "subUint(bytes32,uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-RocketPool/rocketpool-a65b203cf99c7a991c2d85a7468a97bfb5dbba31/contracts/contract/RocketStorage.sol",
        "vulnerability": "Dependence on tx.origin (SWC 115)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract RocketStorage is RocketStorageInterface {\n\n    // Events\n    event NodeWithdrawalAddressSet(address indexed node, address indexed withdrawalAddress, uint256 time);\n    event GuardianChanged(address oldGuardian, address newGuardian);\n\n    // Libraries\n    using SafeMath for uint256;\n\n    // Complex storage maps\n    mapping(bytes32 => string)     private stringStorage;\n    mapping(bytes32 => bytes)      private bytesStorage;\n\n    // Protected storage (not accessible by network contracts)\n    mapping(address => address)    private withdrawalAddresses;\n    mapping(address => address)    private pendingWithdrawalAddresses;\n\n    // Guardian address\n    address guardian;\n    address newGuardian;\n\n    // Flag storage has been initialised\n    bool storageInit = false;\n\n    \n    modifier onlyLatestRocketNetworkContract() {\n        if (storageInit == true) {\n            // Make sure the access is permitted to only contracts in our Dapp\n            require(_getBool(keccak256(abi.encodePacked(\"contract.exists\", msg.sender))), \"Invalid or outdated network contract\");\n        } else {\n            // Only Dapp and the guardian account are allowed access during initialisation.\n            // tx.origin is only safe to use in this case for deployment since no external contracts are interacted with\n            // SWC-115-Authorization through tx.origin: L45\n            require((\n                _getBool(keccak256(abi.encodePacked(\"contract.exists\", msg.sender))) || tx.origin == guardian\n            ), \"Invalid or outdated network contract attempting access during deployment\");\n        }\n        _;\n    }\n\n\n    \n    constructor() {\n        // Set the guardian upon deployment\n        guardian = msg.sender;\n    }\n\n    // Get guardian address\n    function getGuardian() external override view returns (address) {\n        return guardian;\n    }\n\n    // Transfers guardianship to a new address\n    function setGuardian(address _newAddress) external override {\n        // Check tx comes from current guardian\n        require(msg.sender == guardian, \"Is not guardian account\");\n        // Store new address awaiting confirmation\n        newGuardian = _newAddress;\n    }\n\n    // Confirms change of guardian\n    function confirmGuardian() external override {\n        // Check tx came from new guardian address\n        require(msg.sender == newGuardian, \"Confirmation must come from new guardian address\");\n        // Store old guardian for event\n        address oldGuardian = guardian;\n        // Update guardian and clear storage\n        guardian = newGuardian;\n        delete newGuardian;\n        // Emit event\n        emit GuardianChanged(oldGuardian, guardian);\n    }\n\n    // Set this as being deployed now\n    function getDeployedStatus() external view returns (bool) {\n        return storageInit;\n    }\n\n    // Set this as being deployed now\n    function setDeployedStatus() external {\n        // Only guardian can lock this down\n        require(msg.sender == guardian, \"Is not guardian account\");\n        // Set it now\n        storageInit = true;\n    }\n\n    // Protected storage\n\n    // Get a node's withdrawal address\n    function getNodeWithdrawalAddress(address _nodeAddress) public override view returns (address) {\n        // Check if _nodeAddress is a valid node\n        if (!_getBool(keccak256(abi.encodePacked(\"node.exists\", _nodeAddress)))) {\n            return address(0);\n        }\n        // If no withdrawal address has been set, return the nodes address\n        address withdrawalAddress = withdrawalAddresses[_nodeAddress];\n        if (withdrawalAddress == address(0)) {\n            return _nodeAddress;\n        }\n        return withdrawalAddress;\n    }\n\n    // Get a node's pending withdrawal address\n    function getNodePendingWithdrawalAddress(address _nodeAddress) external override view returns (address) {\n        return pendingWithdrawalAddresses[_nodeAddress];\n    }\n\n    // Set a node's withdrawal address\n    function setWithdrawalAddress(address _nodeAddress, address _newWithdrawalAddress, bool _confirm) external override {\n        // Check new withdrawal address\n        require(_newWithdrawalAddress != address(0x0), \"Invalid withdrawal address\");\n        // Confirm the transaction is from the node's current withdrawal address\n        address withdrawalAddress = getNodeWithdrawalAddress(_nodeAddress);\n        require(withdrawalAddress == msg.sender, \"Only a tx from a node's withdrawal address can update it\");\n        // Update immediately if confirmed\n        if (_confirm) {\n            updateWithdrawalAddress(_nodeAddress, _newWithdrawalAddress);\n        }\n        // Set pending withdrawal address if not confirmed\n        else {\n            pendingWithdrawalAddresses[_nodeAddress] = _newWithdrawalAddress;\n        }\n    }\n\n    // Confirm a node's new withdrawal address\n    function confirmWithdrawalAddress(address _nodeAddress) external override {\n        // Get node by pending withdrawal address\n        require(pendingWithdrawalAddresses[_nodeAddress] == msg.sender, \"Confirmation must come from the pending withdrawal address\");\n        delete pendingWithdrawalAddresses[_nodeAddress];\n        // Update withdrawal address\n        updateWithdrawalAddress(_nodeAddress, msg.sender);\n    }\n\n    // Update a node's withdrawal address\n    function updateWithdrawalAddress(address _nodeAddress, address _newWithdrawalAddress) private {\n        // Set new withdrawal address\n        withdrawalAddresses[_nodeAddress] = _newWithdrawalAddress;\n        // Emit withdrawal address set event\n        emit NodeWithdrawalAddressSet(_nodeAddress, _newWithdrawalAddress, block.timestamp);\n    }\n\n    \n    function getAddress(bytes32 _key) override external view returns (address r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n    \n    function getUint(bytes32 _key) override external view returns (uint256 r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n    \n    function getString(bytes32 _key) override external view returns (string memory) {\n        return stringStorage[_key];\n    }\n\n    \n    function getBytes(bytes32 _key) override external view returns (bytes memory) {\n        return bytesStorage[_key];\n    }\n\n    \n    function getBool(bytes32 _key) override external view returns (bool r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n    \n    function getInt(bytes32 _key) override external view returns (int r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n    \n    function getBytes32(bytes32 _key) override external view returns (bytes32 r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n\n    \n    function setAddress(bytes32 _key, address _value) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n\n    \n    // SWC-124-Write to Arbitrary Storage Location: L206 - L210\n    function setUint(bytes32 _key, uint _value) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n\n    \n    function setString(bytes32 _key, string calldata _value) onlyLatestRocketNetworkContract override external {\n        stringStorage[_key] = _value;\n    }\n\n    \n    function setBytes(bytes32 _key, bytes calldata _value) onlyLatestRocketNetworkContract override external {\n        bytesStorage[_key] = _value;\n    }\n\n    \n    function setBool(bytes32 _key, bool _value) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n\n    \n    // SWC-124-Write to Arbitrary Storage Location: L231 - L235\n    function setInt(bytes32 _key, int _value) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n\n    \n    function setBytes32(bytes32 _key, bytes32 _value) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n\n\n    \n    function deleteAddress(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, 0)\n        }\n    }\n\n    \n    function deleteUint(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, 0)\n        }\n    }\n\n    \n    function deleteString(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        delete stringStorage[_key];\n    }\n\n    \n    function deleteBytes(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        delete bytesStorage[_key];\n    }\n\n    \n    function deleteBool(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, 0)\n        }\n    }\n\n    \n    function deleteInt(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, 0)\n        }\n    }\n\n    \n    function deleteBytes32(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, 0)\n        }\n    }\n\n\n    \n    \n    function addUint(bytes32 _key, uint256 _amount) onlyLatestRocketNetworkContract override external {\n        uint256 a;\n        uint256 b;\n        assembly {\n            a := sload (_key)\n            b := add(a, _amount)\n            sstore (_key, b)\n        }\n        require(b >= a, \"SafeMath: addition overflow\");\n    }\n\n    \n    \n    function subUint(bytes32 _key, uint256 _amount) onlyLatestRocketNetworkContract override external {\n        uint256 a;\n        assembly {\n            a := sload (_key)\n        }\n        require(_amount <= a, \"SafeMath: subtraction overflow\");\n        assembly {\n            a := sub(a, _amount)\n            sstore (_key, a)\n        }\n    }\n\n    // Private methods\n\n    function _getBool(bytes32 _key) private view returns (bool r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n    function _setBool(bytes32 _key, bool _value) private {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n}",
        "function": "subUint(bytes32,uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-RocketPool/rocketpool-a65b203cf99c7a991c2d85a7468a97bfb5dbba31/contracts/contract/RocketStorage.sol",
        "vulnerability": "Write to an arbitrary storage location (SWC 124)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract RocketStorage is RocketStorageInterface {\n\n    // Events\n    event NodeWithdrawalAddressSet(address indexed node, address indexed withdrawalAddress, uint256 time);\n    event GuardianChanged(address oldGuardian, address newGuardian);\n\n    // Libraries\n    using SafeMath for uint256;\n\n    // Complex storage maps\n    mapping(bytes32 => string)     private stringStorage;\n    mapping(bytes32 => bytes)      private bytesStorage;\n\n    // Protected storage (not accessible by network contracts)\n    mapping(address => address)    private withdrawalAddresses;\n    mapping(address => address)    private pendingWithdrawalAddresses;\n\n    // Guardian address\n    address guardian;\n    address newGuardian;\n\n    // Flag storage has been initialised\n    bool storageInit = false;\n\n    \n    modifier onlyLatestRocketNetworkContract() {\n        if (storageInit == true) {\n            // Make sure the access is permitted to only contracts in our Dapp\n            require(_getBool(keccak256(abi.encodePacked(\"contract.exists\", msg.sender))), \"Invalid or outdated network contract\");\n        } else {\n            // Only Dapp and the guardian account are allowed access during initialisation.\n            // tx.origin is only safe to use in this case for deployment since no external contracts are interacted with\n            // SWC-115-Authorization through tx.origin: L45\n            require((\n                _getBool(keccak256(abi.encodePacked(\"contract.exists\", msg.sender))) || tx.origin == guardian\n            ), \"Invalid or outdated network contract attempting access during deployment\");\n        }\n        _;\n    }\n\n\n    \n    constructor() {\n        // Set the guardian upon deployment\n        guardian = msg.sender;\n    }\n\n    // Get guardian address\n    function getGuardian() external override view returns (address) {\n        return guardian;\n    }\n\n    // Transfers guardianship to a new address\n    function setGuardian(address _newAddress) external override {\n        // Check tx comes from current guardian\n        require(msg.sender == guardian, \"Is not guardian account\");\n        // Store new address awaiting confirmation\n        newGuardian = _newAddress;\n    }\n\n    // Confirms change of guardian\n    function confirmGuardian() external override {\n        // Check tx came from new guardian address\n        require(msg.sender == newGuardian, \"Confirmation must come from new guardian address\");\n        // Store old guardian for event\n        address oldGuardian = guardian;\n        // Update guardian and clear storage\n        guardian = newGuardian;\n        delete newGuardian;\n        // Emit event\n        emit GuardianChanged(oldGuardian, guardian);\n    }\n\n    // Set this as being deployed now\n    function getDeployedStatus() external view returns (bool) {\n        return storageInit;\n    }\n\n    // Set this as being deployed now\n    function setDeployedStatus() external {\n        // Only guardian can lock this down\n        require(msg.sender == guardian, \"Is not guardian account\");\n        // Set it now\n        storageInit = true;\n    }\n\n    // Protected storage\n\n    // Get a node's withdrawal address\n    function getNodeWithdrawalAddress(address _nodeAddress) public override view returns (address) {\n        // Check if _nodeAddress is a valid node\n        if (!_getBool(keccak256(abi.encodePacked(\"node.exists\", _nodeAddress)))) {\n            return address(0);\n        }\n        // If no withdrawal address has been set, return the nodes address\n        address withdrawalAddress = withdrawalAddresses[_nodeAddress];\n        if (withdrawalAddress == address(0)) {\n            return _nodeAddress;\n        }\n        return withdrawalAddress;\n    }\n\n    // Get a node's pending withdrawal address\n    function getNodePendingWithdrawalAddress(address _nodeAddress) external override view returns (address) {\n        return pendingWithdrawalAddresses[_nodeAddress];\n    }\n\n    // Set a node's withdrawal address\n    function setWithdrawalAddress(address _nodeAddress, address _newWithdrawalAddress, bool _confirm) external override {\n        // Check new withdrawal address\n        require(_newWithdrawalAddress != address(0x0), \"Invalid withdrawal address\");\n        // Confirm the transaction is from the node's current withdrawal address\n        address withdrawalAddress = getNodeWithdrawalAddress(_nodeAddress);\n        require(withdrawalAddress == msg.sender, \"Only a tx from a node's withdrawal address can update it\");\n        // Update immediately if confirmed\n        if (_confirm) {\n            updateWithdrawalAddress(_nodeAddress, _newWithdrawalAddress);\n        }\n        // Set pending withdrawal address if not confirmed\n        else {\n            pendingWithdrawalAddresses[_nodeAddress] = _newWithdrawalAddress;\n        }\n    }\n\n    // Confirm a node's new withdrawal address\n    function confirmWithdrawalAddress(address _nodeAddress) external override {\n        // Get node by pending withdrawal address\n        require(pendingWithdrawalAddresses[_nodeAddress] == msg.sender, \"Confirmation must come from the pending withdrawal address\");\n        delete pendingWithdrawalAddresses[_nodeAddress];\n        // Update withdrawal address\n        updateWithdrawalAddress(_nodeAddress, msg.sender);\n    }\n\n    // Update a node's withdrawal address\n    function updateWithdrawalAddress(address _nodeAddress, address _newWithdrawalAddress) private {\n        // Set new withdrawal address\n        withdrawalAddresses[_nodeAddress] = _newWithdrawalAddress;\n        // Emit withdrawal address set event\n        emit NodeWithdrawalAddressSet(_nodeAddress, _newWithdrawalAddress, block.timestamp);\n    }\n\n    \n    function getAddress(bytes32 _key) override external view returns (address r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n    \n    function getUint(bytes32 _key) override external view returns (uint256 r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n    \n    function getString(bytes32 _key) override external view returns (string memory) {\n        return stringStorage[_key];\n    }\n\n    \n    function getBytes(bytes32 _key) override external view returns (bytes memory) {\n        return bytesStorage[_key];\n    }\n\n    \n    function getBool(bytes32 _key) override external view returns (bool r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n    \n    function getInt(bytes32 _key) override external view returns (int r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n    \n    function getBytes32(bytes32 _key) override external view returns (bytes32 r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n\n    \n    function setAddress(bytes32 _key, address _value) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n\n    \n    // SWC-124-Write to Arbitrary Storage Location: L206 - L210\n    function setUint(bytes32 _key, uint _value) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n\n    \n    function setString(bytes32 _key, string calldata _value) onlyLatestRocketNetworkContract override external {\n        stringStorage[_key] = _value;\n    }\n\n    \n    function setBytes(bytes32 _key, bytes calldata _value) onlyLatestRocketNetworkContract override external {\n        bytesStorage[_key] = _value;\n    }\n\n    \n    function setBool(bytes32 _key, bool _value) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n\n    \n    // SWC-124-Write to Arbitrary Storage Location: L231 - L235\n    function setInt(bytes32 _key, int _value) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n\n    \n    function setBytes32(bytes32 _key, bytes32 _value) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n\n\n    \n    function deleteAddress(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, 0)\n        }\n    }\n\n    \n    function deleteUint(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, 0)\n        }\n    }\n\n    \n    function deleteString(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        delete stringStorage[_key];\n    }\n\n    \n    function deleteBytes(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        delete bytesStorage[_key];\n    }\n\n    \n    function deleteBool(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, 0)\n        }\n    }\n\n    \n    function deleteInt(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, 0)\n        }\n    }\n\n    \n    function deleteBytes32(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        assembly {\n            sstore (_key, 0)\n        }\n    }\n\n\n    \n    \n    function addUint(bytes32 _key, uint256 _amount) onlyLatestRocketNetworkContract override external {\n        uint256 a;\n        uint256 b;\n        assembly {\n            a := sload (_key)\n            b := add(a, _amount)\n            sstore (_key, b)\n        }\n        require(b >= a, \"SafeMath: addition overflow\");\n    }\n\n    \n    \n    function subUint(bytes32 _key, uint256 _amount) onlyLatestRocketNetworkContract override external {\n        uint256 a;\n        assembly {\n            a := sload (_key)\n        }\n        require(_amount <= a, \"SafeMath: subtraction overflow\");\n        assembly {\n            a := sub(a, _amount)\n            sstore (_key, a)\n        }\n    }\n\n    // Private methods\n\n    function _getBool(bytes32 _key) private view returns (bool r) {\n        assembly {\n            r := sload (_key)\n        }\n    }\n\n    function _setBool(bytes32 _key, bool _value) private {\n        assembly {\n            sstore (_key, _value)\n        }\n    }\n}",
        "function": "deleteString(bytes32)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-RocketPool/rocketpool-a65b203cf99c7a991c2d85a7468a97bfb5dbba31/contracts/contract/RocketStorage.sol",
        "vulnerability": "Dependence on tx.origin (SWC 115)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract OwnerManager is SelfAuthorized {\n\n    event AddedOwner(address owner);\n    event RemovedOwner(address owner);\n    event ChangedThreshold(uint256 threshold);\n\n    address public constant SENTINEL_OWNERS = address(0x1);\n\n    mapping(address => address) internal owners;\n    uint256 ownerCount;\n    uint256 internal threshold;\n\n    \n    \n    \n    function setupOwners(address[] memory _owners, uint256 _threshold)\n        internal\n    {\n        // Threshold can only be 0 at initialization.\n        // Check ensures that setup function can only be called once.\n        require(threshold == 0, \"Owners have already been setup\");\n        // Validate that threshold is smaller than number of added owners.\n        require(_threshold <= _owners.length, \"Threshold cannot exceed owner count\");\n        // There has to be at least one Safe owner.\n        require(_threshold >= 1, \"Threshold needs to be greater than 0\");\n        // Initializing Safe owners.\n        address currentOwner = SENTINEL_OWNERS;\n        for (uint256 i = 0; i < _owners.length; i++) {\n            // Owner address cannot be null.\n            address owner = _owners[i];\n            require(owner != address(0) && owner != SENTINEL_OWNERS, \"Invalid owner address provided\");\n            // No duplicate owners allowed.\n            require(owners[owner] == address(0), \"Duplicate owner address provided\");\n            owners[currentOwner] = owner;\n            currentOwner = owner;\n        }\n        owners[currentOwner] = SENTINEL_OWNERS;\n        ownerCount = _owners.length;\n        threshold = _threshold;\n    }\n\n    \n    \n    \n    \n    // SWC-114-Transaction Order Dependence: L53 - L68\n    function addOwnerWithThreshold(address owner, uint256 _threshold)\n        public\n        authorized\n    {\n        // Owner address cannot be null.\n        require(owner != address(0) && owner != SENTINEL_OWNERS, \"Invalid owner address provided\");\n        // No duplicate owners allowed.\n        require(owners[owner] == address(0), \"Address is already an owner\");\n        owners[owner] = owners[SENTINEL_OWNERS];\n        owners[SENTINEL_OWNERS] = owner;\n        // SWC-101-Integer Overflow and Underflow: L64\n        ownerCount++;\n        emit AddedOwner(owner);\n        // Change threshold if threshold was changed.\n        if (threshold != _threshold)\n            changeThreshold(_threshold);\n    }\n\n    \n    \n    \n    \n    \n    function removeOwner(address prevOwner, address owner, uint256 _threshold)\n        public\n        authorized\n    {\n        // Only allow to remove an owner, if threshold can still be reached.\n        // SWC-101-Integer Overflow and Underflow: L82\n        require(ownerCount - 1 >= _threshold, \"New owner count needs to be larger than new threshold\");\n        // Validate owner address and check that it corresponds to owner index.\n        require(owner != address(0) && owner != SENTINEL_OWNERS, \"Invalid owner address provided\");\n        require(owners[prevOwner] == owner, \"Invalid prevOwner, owner pair provided\");\n        owners[prevOwner] = owners[owner];\n        owners[owner] = address(0);\n        // SWC-101-Integer Overflow and Underflow: L89\n        ownerCount--;\n        emit RemovedOwner(owner);\n        // Change threshold if threshold was changed.\n        if (threshold != _threshold)\n            changeThreshold(_threshold);\n    }\n\n    \n    \n    \n    \n    \n    function swapOwner(address prevOwner, address oldOwner, address newOwner)\n        public\n        authorized\n    {\n        // Owner address cannot be null.\n        require(newOwner != address(0) && newOwner != SENTINEL_OWNERS, \"Invalid owner address provided\");\n        // No duplicate owners allowed.\n        require(owners[newOwner] == address(0), \"Address is already an owner\");\n        // Validate oldOwner address and check that it corresponds to owner index.\n        require(oldOwner != address(0) && oldOwner != SENTINEL_OWNERS, \"Invalid owner address provided\");\n        require(owners[prevOwner] == oldOwner, \"Invalid prevOwner, owner pair provided\");\n        owners[newOwner] = owners[oldOwner];\n        owners[prevOwner] = newOwner;\n        owners[oldOwner] = address(0);\n        emit RemovedOwner(oldOwner);\n        emit AddedOwner(newOwner);\n    }\n\n    \n    \n    \n    function changeThreshold(uint256 _threshold)\n        public\n        authorized\n    {\n        // Validate that threshold is smaller than number of owners.\n        require(_threshold <= ownerCount, \"Threshold cannot exceed owner count\");\n        // There has to be at least one Safe owner.\n        require(_threshold >= 1, \"Threshold needs to be greater than 0\");\n        threshold = _threshold;\n        emit ChangedThreshold(threshold);\n    }\n\n    function getThreshold()\n        public\n        view\n        returns (uint256)\n    {\n        return threshold;\n    }\n\n    function isOwner(address owner)\n        public\n        view\n        returns (bool)\n    {\n        return owners[owner] != address(0);\n    }\n\n    \n    \n    function getOwners()\n        public\n        view\n        returns (address[] memory)\n    {\n        address[] memory array = new address[](ownerCount);\n\n        // populate return array\n        uint256 index = 0;\n        address currentOwner = owners[SENTINEL_OWNERS];\n        while(currentOwner != SENTINEL_OWNERS) {\n            array[index] = currentOwner;\n            currentOwner = owners[currentOwner];\n            index ++;\n        }\n        return array;\n    }\n}",
        "function": "getOwners()",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Runtime_Vrification-GnosisSafe/safe-contracts-427d6f7e779431333c54bcb4d4cde31e4d57ce96/contracts/base/OwnerManager.sol",
        "vulnerability": "Exception State (SWC 110)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract OneSwapFactoryTEST {\n    address public feeTo;\n    address public feeToSetter;\n    address public weth;\n\n    mapping(address => mapping(address => address)) public pairs;\n    address[] public allPairs;\n\n    event PairCreated(address indexed stock, address indexed money, address pair, uint);\n\n    function createPair(address stock, address money) external {\n        require(stock != money, \"OneSwap: IDENTICAL_ADDRESSES\");\n        require(stock != address(0) && money != address(0), \"OneSwap: ZERO_ADDRESS\");\n        require(pairs[stock][money] == address(0), \"OneSwap: PAIR_EXISTS\"); // single check is sufficient\n        uint8 dec = IERC20(stock).decimals();\n        require(25 >= dec && dec >= 6, \"OneSwap: DECIMALS_NOT_SUPPORTED\");\n        dec -= 6;\n        bytes32 salt = keccak256(abi.encodePacked(stock, money));\n        OneSwapPair oneswap = new OneSwapPair{salt: salt}(weth, stock, money, false, 1/*uint64(uint(10)**uint(dec))*/, 1, 1);\n        address pair = address(oneswap);\n        pairs[stock][money] = pair;\n        allPairs.push(pair);\n        emit PairCreated(stock, money, pair, allPairs.length);\n    }\n\n    function allPairsLength() external view returns (uint) {\n        return allPairs.length;\n    }\n\n    function feeBPS() external pure returns (uint32) {\n        return 30;\n    }\n}",
        "function": "allPairs(uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/PeckShield-OneSwap/oneswap_contract_ethereum-4194ac1a55934cd573bd93987111eaa8f70676fe/contracts/OneSwapPair.sol",
        "vulnerability": "Exception State (SWC 110)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract Migrations {\n  address public owner;\n  uint public last_completed_migration;\n\n  modifier restricted() {\n    if (msg.sender == owner) _;\n  }\n\n  function Migrations() {\n    owner = msg.sender;\n  }\n\n  function setCompleted(uint completed) restricted {\n    last_completed_migration = completed;\n  }\n\n  function upgrade(address new_address) restricted {\n    Migrations upgraded = Migrations(new_address);\n    upgraded.setCompleted(last_completed_migration);\n  }\n}",
        "function": "upgrade(address)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Blockchain Labs NZ-SynchroLife/synchrocoin-contracts-master/contracts/Migrations.sol",
        "vulnerability": "External Call To User-Supplied Address (SWC 107)",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract TMC_Contract is ERC20Interface, Owned {\n\tstring public constant symbol = \"TMC\";\n\tstring public constant name = \"TMC Token\";\n\tuint8 public constant decimals = 18;\n\tuint256 public constant totalSupply = 500000000000000000000000000;\n\n\tbool public stopped;\n\n\tmapping (address => int8) public blackList;\n\n\tmapping (address => uint256) public balances;\n\tmapping (address => mapping (address => uint256)) public allowed;\n\n\n    event Blacklisted(address indexed target);\n    event DeleteFromBlacklist(address indexed target);\n    event RejectedPaymentToBlacklistedAddr(address indexed from, address indexed to, uint256 value);\n    event RejectedPaymentFromBlacklistedAddr(address indexed from, address indexed to, uint256 value);\n\n\n\tmodifier notStopped {\n        require(!stopped);\n        _;\n    }\n\n// constructor\n\tfunction TMC_Contract() public {\n\t\tbalances[msg.sender] = totalSupply;\n\t}\n\t\n// function made for airdrop\n\tfunction airdrop(address[] _to, uint256[] _value) onlyOwner notStopped public {\n\t    for(uint256 i = 0; i < _to.length; i++){\n\t        if(balances[_to[i]] > 0){\n\t            continue;\n\t        }\n\t        transfer(_to[i], _value[i]);\n\t    }\n\t}\n\n// blacklist management\n    function blacklisting(address _addr) onlyOwner public {\n        blackList[_addr] = 1;\n        emit Blacklisted(_addr);\n    }\n    function deleteFromBlacklist(address _addr) onlyOwner public {\n        blackList[_addr] = -1;\n        emit DeleteFromBlacklist(_addr);\n    }\n\n// stop the contract\n// SWC-100-Function Default Visibility: L86\n\tfunction stop() onlyOwner {\n        stopped = true;\n    }\n// SWC-100-Function Default Visibility: L90\n    function start() onlyOwner {\n        stopped = false;\n    }\n\t\n// ERC20 functions\n\tfunction balanceOf(address _owner) public constant returns (uint256 balance){\n\t\treturn balances[_owner];\n\t}\n\tfunction transfer(address _to, uint256 _value) notStopped public returns (bool success){\n\t\trequire(balances[msg.sender] >= _value);\n\n\t\tif(blackList[msg.sender] > 0){\n\t\t\temit RejectedPaymentFromBlacklistedAddr(msg.sender, _to, _value);\n\t\t\treturn false;\n\t\t}\n\t\tif(blackList[_to] > 0){\n\t\t\temit RejectedPaymentToBlacklistedAddr(msg.sender, _to, _value);\n\t\t\treturn false;\n\t\t}\n\n\t\tbalances[msg.sender] -= _value;\n\t\tbalances[_to] += _value;\n\t\temit Transfer(msg.sender, _to, _value);\n\t\treturn true;\n\t}\n\tfunction transferFrom(address _from, address _to, uint256 _value) notStopped public returns (bool success){\n\t\trequire(balances[_from] >= _value\n\t\t\t&& allowed[_from][msg.sender] >= _value);\n\n\t\tif(blackList[_from] > 0){\n\t\t\temit RejectedPaymentFromBlacklistedAddr(_from, _to, _value);\n\t\t\treturn false;\n\t\t}\n\t\tif(blackList[_to] > 0){\n\t\t\temit RejectedPaymentToBlacklistedAddr(_from, _to, _value);\n\t\t\treturn false;\n\t\t}\n\n\t\tbalances[_from] -= _value;\n\t\tallowed[_from][msg.sender] -= _value;\n\t\tbalances[_to] += _value;\n\t\temit Transfer(_from, _to, _value);\n\t\treturn true;\n\t}\n\tfunction approve(address _spender, uint256 _value) notStopped public returns (bool success){\n\t\tallowed[msg.sender][_spender] = _value;\n\t\temit Approval(msg.sender, _spender, _value);\n\t\treturn true;\n\t}\n\tfunction allowance(address _owner, address _spender) public constant returns (uint256 remaining){\n\t\treturn allowed[_owner][_spender];\n\t}\n}",
        "function": "airdrop(address[],uint256[])",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Iosiro-TMC Token Smart Contract Audit/ERC20-Contract-b923cde02d2fd928760cc1e810410c2064fe1530/ERC20_Contract.sol",
        "vulnerability": "Integer Arithmetic Bugs (SWC 101)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract TMC_Contract is ERC20Interface, Owned {\n\tstring public constant symbol = \"TMC\";\n\tstring public constant name = \"TMC Token\";\n\tuint8 public constant decimals = 18;\n\tuint256 public constant totalSupply = 500000000000000000000000000;\n\n\tbool public stopped;\n\n\tmapping (address => int8) public blackList;\n\n\tmapping (address => uint256) public balances;\n\tmapping (address => mapping (address => uint256)) public allowed;\n\n\n    event Blacklisted(address indexed target);\n    event DeleteFromBlacklist(address indexed target);\n    event RejectedPaymentToBlacklistedAddr(address indexed from, address indexed to, uint256 value);\n    event RejectedPaymentFromBlacklistedAddr(address indexed from, address indexed to, uint256 value);\n\n\n\tmodifier notStopped {\n        require(!stopped);\n        _;\n    }\n\n// constructor\n\tfunction TMC_Contract() public {\n\t\tbalances[msg.sender] = totalSupply;\n\t}\n\t\n// function made for airdrop\n\tfunction airdrop(address[] _to, uint256[] _value) onlyOwner notStopped public {\n\t    for(uint256 i = 0; i < _to.length; i++){\n\t        if(balances[_to[i]] > 0){\n\t            continue;\n\t        }\n\t        transfer(_to[i], _value[i]);\n\t    }\n\t}\n\n// blacklist management\n    function blacklisting(address _addr) onlyOwner public {\n        blackList[_addr] = 1;\n        emit Blacklisted(_addr);\n    }\n    function deleteFromBlacklist(address _addr) onlyOwner public {\n        blackList[_addr] = -1;\n        emit DeleteFromBlacklist(_addr);\n    }\n\n// stop the contract\n// SWC-100-Function Default Visibility: L86\n\tfunction stop() onlyOwner {\n        stopped = true;\n    }\n// SWC-100-Function Default Visibility: L90\n    function start() onlyOwner {\n        stopped = false;\n    }\n\t\n// ERC20 functions\n\tfunction balanceOf(address _owner) public constant returns (uint256 balance){\n\t\treturn balances[_owner];\n\t}\n\tfunction transfer(address _to, uint256 _value) notStopped public returns (bool success){\n\t\trequire(balances[msg.sender] >= _value);\n\n\t\tif(blackList[msg.sender] > 0){\n\t\t\temit RejectedPaymentFromBlacklistedAddr(msg.sender, _to, _value);\n\t\t\treturn false;\n\t\t}\n\t\tif(blackList[_to] > 0){\n\t\t\temit RejectedPaymentToBlacklistedAddr(msg.sender, _to, _value);\n\t\t\treturn false;\n\t\t}\n\n\t\tbalances[msg.sender] -= _value;\n\t\tbalances[_to] += _value;\n\t\temit Transfer(msg.sender, _to, _value);\n\t\treturn true;\n\t}\n\tfunction transferFrom(address _from, address _to, uint256 _value) notStopped public returns (bool success){\n\t\trequire(balances[_from] >= _value\n\t\t\t&& allowed[_from][msg.sender] >= _value);\n\n\t\tif(blackList[_from] > 0){\n\t\t\temit RejectedPaymentFromBlacklistedAddr(_from, _to, _value);\n\t\t\treturn false;\n\t\t}\n\t\tif(blackList[_to] > 0){\n\t\t\temit RejectedPaymentToBlacklistedAddr(_from, _to, _value);\n\t\t\treturn false;\n\t\t}\n\n\t\tbalances[_from] -= _value;\n\t\tallowed[_from][msg.sender] -= _value;\n\t\tbalances[_to] += _value;\n\t\temit Transfer(_from, _to, _value);\n\t\treturn true;\n\t}\n\tfunction approve(address _spender, uint256 _value) notStopped public returns (bool success){\n\t\tallowed[msg.sender][_spender] = _value;\n\t\temit Approval(msg.sender, _spender, _value);\n\t\treturn true;\n\t}\n\tfunction allowance(address _owner, address _spender) public constant returns (uint256 remaining){\n\t\treturn allowed[_owner][_spender];\n\t}\n}",
        "function": "airdrop(address[],uint256[])",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Iosiro-TMC Token Smart Contract Audit/ERC20-Contract-b923cde02d2fd928760cc1e810410c2064fe1530/ERC20_Contract.sol",
        "vulnerability": "Exception State (SWC 110)",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract Spawn {\n    constructor(address logicContract, bytes memory initializationCalldata) public payable {\n        // delegatecall into the logic contract to perform initialization.\n        (bool ok, ) = logicContract.delegatecall(initializationCalldata);\n        if (!ok) {\n            // pass along failure message from delegatecall and revert.\n            assembly {\n                returndatacopy(0, 0, returndatasize())\n                revert(0, returndatasize())\n            }\n        }\n\n        // place eip-1167 runtime code in memory.\n        bytes memory runtimeCode = abi.encodePacked(\n            bytes10(0x363d3d373d3d3d363d73),\n            logicContract,\n            bytes15(0x5af43d82803e903d91602b57fd5bf3)\n        );\n\n        // return eip-1167 code to write it to spawned contract runtime.\n        assembly {\n            return(add(0x20, runtimeCode), 45) // eip-1167 runtime code, length\n        }\n    }\n}",
        "function": "fallback",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/openzeppelin-Opyn_Gamma_Protocol/GammaProtocol-d151621b33134789b29dc78eb89dad2b557b25b9/contracts/OtokenFactory.sol",
        "vulnerability": "Delegatecall to user-supplied address (SWC 112)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract Spawn {\n    constructor(address logicContract, bytes memory initializationCalldata) public payable {\n        // delegatecall into the logic contract to perform initialization.\n        (bool ok, ) = logicContract.delegatecall(initializationCalldata);\n        if (!ok) {\n            // pass along failure message from delegatecall and revert.\n            assembly {\n                returndatacopy(0, 0, returndatasize())\n                revert(0, returndatasize())\n            }\n        }\n\n        // place eip-1167 runtime code in memory.\n        bytes memory runtimeCode = abi.encodePacked(\n            bytes10(0x363d3d373d3d3d363d73),\n            logicContract,\n            bytes15(0x5af43d82803e903d91602b57fd5bf3)\n        );\n\n        // return eip-1167 code to write it to spawned contract runtime.\n        assembly {\n            return(add(0x20, runtimeCode), 45) // eip-1167 runtime code, length\n        }\n    }\n}",
        "function": "constructor",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/openzeppelin-Opyn_Gamma_Protocol/GammaProtocol-d151621b33134789b29dc78eb89dad2b557b25b9/contracts/OtokenFactory.sol",
        "vulnerability": "Delegatecall to user-supplied address (SWC 112)",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract ComptrollerV1Storage is UnitrollerAdminStorage {\n\n    /**\n     * @notice Oracle which gives the price of any given asset\n     */\n    PriceOracle public oracle;\n\n    /**\n     * @notice Multiplier used to calculate the maximum repayAmount when liquidating a borrow\n     */\n    uint public closeFactorMantissa;\n\n    /**\n     * @notice Multiplier representing the discount on collateral that a liquidator receives\n     */\n    uint public liquidationIncentiveMantissa;\n\n    /**\n     * @notice Max number of assets a single account can participate in (borrow or use as collateral)\n     */\n    uint public maxAssets;\n\n    /**\n     * @notice Per-account mapping of \"assets you are in\", capped by maxAssets\n     */\n    mapping(address => CToken[]) public accountAssets;\n\n}",
        "function": "accountAssets(address,uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/QuillAudits-C.R.E.A.M. Finance-Compound Protocol/compound-protocol-23a4ae93adc70334553f5a83429a4e967c1eefaa/contracts/CCollateralCapErc20.sol",
        "vulnerability": "Exception State (SWC 110)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract ComptrollerV2Storage is ComptrollerV1Storage {\n    enum Version {\n        VANILLA,\n        COLLATERALCAP\n    }\n\n    struct Market {\n        \n        bool isListed;\n\n        /**\n         * @notice Multiplier representing the most one can borrow against their collateral in this market.\n         *  For instance, 0.9 to allow borrowing 90% of collateral value.\n         *  Must be between 0 and 1, and stored as a mantissa.\n         */\n        uint collateralFactorMantissa;\n\n        \n        mapping(address => bool) accountMembership;\n\n        \n        bool isComped;\n\n        \n        Version version;\n    }\n\n    /**\n     * @notice Official mapping of cTokens -> Market metadata\n     * @dev Used e.g. to determine if a market is supported\n     */\n    mapping(address => Market) public markets;\n\n\n    /**\n     * @notice The Pause Guardian can pause certain actions as a safety mechanism.\n     *  Actions which allow users to remove their own assets cannot be paused.\n     *  Liquidation / seizing / transfer can only be paused globally, not by market.\n     */\n    address public pauseGuardian;\n    bool public _mintGuardianPaused;\n    bool public _borrowGuardianPaused;\n    bool public transferGuardianPaused;\n    bool public seizeGuardianPaused;\n    mapping(address => bool) public mintGuardianPaused;\n    mapping(address => bool) public borrowGuardianPaused;\n}",
        "function": "accountAssets(address,uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/QuillAudits-C.R.E.A.M. Finance-Compound Protocol/compound-protocol-23a4ae93adc70334553f5a83429a4e967c1eefaa/contracts/CCollateralCapErc20.sol",
        "vulnerability": "Exception State (SWC 110)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract ComptrollerV3Storage is ComptrollerV2Storage {\n    struct CompMarketState {\n        \n        uint224 index;\n\n        \n        uint32 block;\n    }\n\n    \n    CToken[] public allMarkets;\n\n    \n    uint public compRate;\n\n    \n    mapping(address => uint) public compSpeeds;\n\n    \n    mapping(address => CompMarketState) public compSupplyState;\n\n    \n    mapping(address => CompMarketState) public compBorrowState;\n\n    \n    mapping(address => mapping(address => uint)) public compSupplierIndex;\n\n    \n    mapping(address => mapping(address => uint)) public compBorrowerIndex;\n\n    \n    mapping(address => uint) public compAccrued;\n}",
        "function": "allMarkets(uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/QuillAudits-C.R.E.A.M. Finance-Compound Protocol/compound-protocol-23a4ae93adc70334553f5a83429a4e967c1eefaa/contracts/CCollateralCapErc20.sol",
        "vulnerability": "Exception State (SWC 110)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract ComptrollerV4Storage is ComptrollerV3Storage {\n    // @notice The borrowCapGuardian can set borrowCaps to any number for any market. Lowering the borrow cap could disable borrowing on the given market.\n    address public borrowCapGuardian;\n\n    // @notice Borrow caps enforced by borrowAllowed for each cToken address. Defaults to zero which corresponds to unlimited borrowing.\n    mapping(address => uint) public borrowCaps;\n}",
        "function": "allMarkets(uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/QuillAudits-C.R.E.A.M. Finance-Compound Protocol/compound-protocol-23a4ae93adc70334553f5a83429a4e967c1eefaa/contracts/CCollateralCapErc20.sol",
        "vulnerability": "Exception State (SWC 110)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract ComptrollerV5Storage is ComptrollerV4Storage {\n    // @notice The supplyCapGuardian can set supplyCaps to any number for any market. Lowering the supply cap could disable supplying to the given market.\n    address public supplyCapGuardian;\n\n    // @notice Supply caps enforced by mintAllowed for each cToken address. Defaults to zero which corresponds to unlimited supplying.\n    mapping(address => uint) public supplyCaps;\n}",
        "function": "allMarkets(uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/QuillAudits-C.R.E.A.M. Finance-Compound Protocol/compound-protocol-23a4ae93adc70334553f5a83429a4e967c1eefaa/contracts/CCollateralCapErc20.sol",
        "vulnerability": "Exception State (SWC 110)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract ComptrollerV3Storage is ComptrollerV2Storage {\n    struct CompMarketState {\n        \n        uint224 index;\n\n        \n        uint32 block;\n    }\n\n    \n    CToken[] public allMarkets;\n\n    \n    uint public compRate;\n\n    \n    mapping(address => uint) public compSpeeds;\n\n    \n    mapping(address => CompMarketState) public compSupplyState;\n\n    \n    mapping(address => CompMarketState) public compBorrowState;\n\n    \n    mapping(address => mapping(address => uint)) public compSupplierIndex;\n\n    \n    mapping(address => mapping(address => uint)) public compBorrowerIndex;\n\n    \n    mapping(address => uint) public compAccrued;\n}",
        "function": "accountAssets(address,uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/QuillAudits-C.R.E.A.M. Finance-Compound Protocol/compound-protocol-23a4ae93adc70334553f5a83429a4e967c1eefaa/contracts/CCollateralCapErc20.sol",
        "vulnerability": "Exception State (SWC 110)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract ComptrollerV4Storage is ComptrollerV3Storage {\n    // @notice The borrowCapGuardian can set borrowCaps to any number for any market. Lowering the borrow cap could disable borrowing on the given market.\n    address public borrowCapGuardian;\n\n    // @notice Borrow caps enforced by borrowAllowed for each cToken address. Defaults to zero which corresponds to unlimited borrowing.\n    mapping(address => uint) public borrowCaps;\n}",
        "function": "accountAssets(address,uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/QuillAudits-C.R.E.A.M. Finance-Compound Protocol/compound-protocol-23a4ae93adc70334553f5a83429a4e967c1eefaa/contracts/CCollateralCapErc20.sol",
        "vulnerability": "Exception State (SWC 110)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract ComptrollerV5Storage is ComptrollerV4Storage {\n    // @notice The supplyCapGuardian can set supplyCaps to any number for any market. Lowering the supply cap could disable supplying to the given market.\n    address public supplyCapGuardian;\n\n    // @notice Supply caps enforced by mintAllowed for each cToken address. Defaults to zero which corresponds to unlimited supplying.\n    mapping(address => uint) public supplyCaps;\n}",
        "function": "accountAssets(address,uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/QuillAudits-C.R.E.A.M. Finance-Compound Protocol/compound-protocol-23a4ae93adc70334553f5a83429a4e967c1eefaa/contracts/CCollateralCapErc20.sol",
        "vulnerability": "Exception State (SWC 110)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract CCollateralCapErc20 is CToken, CCollateralCapErc20Interface {\n    /**\n     * @notice Initialize the new money market\n     * @param underlying_ The address of the underlying asset\n     * @param comptroller_ The address of the Comptroller\n     * @param interestRateModel_ The address of the interest rate model\n     * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18\n     * @param name_ ERC-20 name of this token\n     * @param symbol_ ERC-20 symbol of this token\n     * @param decimals_ ERC-20 decimal precision of this token\n     */\n    function initialize(address underlying_,\n                        ComptrollerInterface comptroller_,\n                        InterestRateModel interestRateModel_,\n                        uint initialExchangeRateMantissa_,\n                        string memory name_,\n                        string memory symbol_,\n                        uint8 decimals_) public {\n        // CToken initialize does the bulk of the work\n        super.initialize(comptroller_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_);\n\n        // Set underlying and sanity check it\n        underlying = underlying_;\n        EIP20Interface(underlying).totalSupply();\n    }\n\n    /*** User Interface ***/\n\n    /**\n     * @notice Sender supplies assets into the market and receives cTokens in exchange\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param mintAmount The amount of the underlying asset to supply\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function mint(uint mintAmount) external returns (uint) {\n        (uint err,) = mintInternal(mintAmount);\n        return err;\n    }\n\n    /**\n     * @notice Sender redeems cTokens in exchange for the underlying asset\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param redeemTokens The number of cTokens to redeem into underlying\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function redeem(uint redeemTokens) external returns (uint) {\n        return redeemInternal(redeemTokens);\n    }\n\n    /**\n     * @notice Sender redeems cTokens in exchange for a specified amount of underlying asset\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param redeemAmount The amount of underlying to redeem\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function redeemUnderlying(uint redeemAmount) external returns (uint) {\n        return redeemUnderlyingInternal(redeemAmount);\n    }\n\n    /**\n      * @notice Sender borrows assets from the protocol to their own address\n      * @param borrowAmount The amount of the underlying asset to borrow\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n      */\n    function borrow(uint borrowAmount) external returns (uint) {\n        return borrowInternal(borrowAmount);\n    }\n\n    /**\n     * @notice Sender repays their own borrow\n     * @param repayAmount The amount to repay\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function repayBorrow(uint repayAmount) external returns (uint) {\n        (uint err,) = repayBorrowInternal(repayAmount);\n        return err;\n    }\n\n    /**\n     * @notice Sender repays a borrow belonging to borrower\n     * @param borrower the account with the debt being payed off\n     * @param repayAmount The amount to repay\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function repayBorrowBehalf(address borrower, uint repayAmount) external returns (uint) {\n        (uint err,) = repayBorrowBehalfInternal(borrower, repayAmount);\n        return err;\n    }\n\n    /**\n     * @notice The sender liquidates the borrowers collateral.\n     *  The collateral seized is transferred to the liquidator.\n     * @param borrower The borrower of this cToken to be liquidated\n     * @param repayAmount The amount of the underlying borrowed asset to repay\n     * @param cTokenCollateral The market in which to seize collateral from the borrower\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function liquidateBorrow(address borrower, uint repayAmount, CTokenInterface cTokenCollateral) external returns (uint) {\n        (uint err,) = liquidateBorrowInternal(borrower, repayAmount, cTokenCollateral);\n        return err;\n    }\n\n    /**\n     * @notice The sender adds to reserves.\n     * @param addAmount The amount fo underlying token to add as reserves\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _addReserves(uint addAmount) external returns (uint) {\n        return _addReservesInternal(addAmount);\n    }\n\n    /**\n     * @notice Set the given collateral cap for the market.\n     * @param newCollateralCap New collateral cap for this market. A value of 0 corresponds to no cap.\n     */\n    function _setCollateralCap(uint newCollateralCap) external {\n        require(msg.sender == admin, \"only admin can set collateral cap\");\n\n        collateralCap = newCollateralCap;\n        emit NewCollateralCap(address(this), newCollateralCap);\n    }\n\n    /**\n     * @notice Absorb excess cash into reserves.\n     */\n    function gulp() external nonReentrant {\n        uint256 cashOnChain = getCashOnChain();\n        uint256 cashPrior = getCashPrior();\n\n        uint excessCash = sub_(cashOnChain, cashPrior);\n        totalReserves = add_(totalReserves, excessCash);\n        internalCash = cashOnChain;\n    }\n\n    /**\n     * @notice Flash loan funds to a given account.\n     * @param receiver The receiver address for the funds\n     * @param amount The amount of the funds to be loaned\n     * @param params The other parameters\n     */\n    function flashLoan(address receiver, uint amount, bytes calldata params) external nonReentrant {\n        uint cashOnChainBefore = getCashOnChain();\n        uint cashBefore = getCashPrior();\n        require(cashBefore >= amount, \"INSUFFICIENT_LIQUIDITY\");\n\n        // 1. calculate fee, 1 bips = 1/10000\n        uint totalFee = div_(mul_(amount, flashFeeBips), 10000);\n\n        // 2. transfer fund to receiver\n        doTransferOut(address(uint160(receiver)), amount);\n\n        // 3. execute receiver's callback function\n        IFlashloanReceiver(receiver).executeOperation(msg.sender, underlying, amount, totalFee, params);\n\n        // 4. check balance\n        uint cashOnChainAfter = getCashOnChain();\n        require(cashOnChainAfter == add_(cashOnChainBefore, totalFee), \"BALANCE_INCONSISTENT\");\n\n        // 5. update reserves and internal cash\n        uint reservesFee = mul_ScalarTruncate(Exp({mantissa: reserveFactorMantissa}), totalFee);\n        totalReserves = add_(totalReserves, reservesFee);\n        internalCash = add_(cashBefore, totalFee);\n\n        emit Flashloan(receiver, amount, totalFee, reservesFee);\n    }\n\n    /**\n     * @notice Register account collateral tokens if there is space.\n     * @param account The account to register\n     * @dev This function could only be called by comptroller.\n     * @return The actual registered amount of collateral\n     */\n    function registerCollateral(address account) external returns (uint) {\n        // Make sure accountCollateralTokens of `account` is initialized.\n        initializeAccountCollateralTokens(account);\n\n        require(msg.sender == address(comptroller), \"only comptroller may register collateral for user\");\n\n        uint amount = sub_(accountTokens[account], accountCollateralTokens[account]);\n        return increaseUserCollateralInternal(account, amount);\n    }\n\n    /**\n     * @notice Unregister account collateral tokens if the account still has enough collateral.\n     * @dev This function could only be called by comptroller.\n     * @param account The account to unregister\n     */\n    function unregisterCollateral(address account) external {\n        // Make sure accountCollateralTokens of `account` is initialized.\n        initializeAccountCollateralTokens(account);\n\n        require(msg.sender == address(comptroller), \"only comptroller may unregister collateral for user\");\n\n        decreaseUserCollateralInternal(account, accountCollateralTokens[account]);\n    }\n\n    /*** Safe Token ***/\n\n    /**\n     * @notice Gets internal balance of this contract in terms of the underlying.\n     *  It excludes balance from direct transfer.\n     * @dev This excludes the value of the current message, if any\n     * @return The quantity of underlying tokens owned by this contract\n     */\n    function getCashPrior() internal view returns (uint) {\n        return internalCash;\n    }\n\n    /**\n     * @notice Gets total balance of this contract in terms of the underlying\n     * @dev This excludes the value of the current message, if any\n     * @return The quantity of underlying tokens owned by this contract\n     */\n    function getCashOnChain() internal view returns (uint) {\n        EIP20Interface token = EIP20Interface(underlying);\n        return token.balanceOf(address(this));\n    }\n\n    /**\n     * @notice Initialize the account's collateral tokens. This function should be called in the beginning of every function\n     *  that accesses accountCollateralTokens or accountTokens.\n     * @param account The account of accountCollateralTokens that needs to be updated\n     */\n    function initializeAccountCollateralTokens(address account) internal {\n        /**\n         * If isCollateralTokenInit is false, it means accountCollateralTokens was not initialized yet.\n         * This case will only happen once and must be the very beginning. accountCollateralTokens is a new structure and its\n         * initial value should be equal to accountTokens if user has entered the market. However, it's almost impossible to\n         * check every user's value when the implementation becomes active. Therefore, it must rely on every action which will\n         * access accountTokens to call this function to check if accountCollateralTokens needed to be initialized.\n         */\n        if (!isCollateralTokenInit[account]) {\n            if (ComptrollerInterfaceExtension(address(comptroller)).checkMembership(account, CToken(this))) {\n                accountCollateralTokens[account] = accountTokens[account];\n                totalCollateralTokens = add_(totalCollateralTokens, accountTokens[account]);\n\n                emit UserCollateralChanged(account, accountCollateralTokens[account]);\n            }\n            isCollateralTokenInit[account] = true;\n        }\n    }\n\n    /**\n     * @dev Similar to EIP20 transfer, except it handles a False result from `transferFrom` and reverts in that case.\n     *      This will revert due to insufficient balance or insufficient allowance.\n     *      This function returns the actual amount received,\n     *      which may be less than `amount` if there is a fee attached to the transfer.\n     *\n     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.\n     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\n     */\n    function doTransferIn(address from, uint amount) internal returns (uint) {\n        EIP20NonStandardInterface token = EIP20NonStandardInterface(underlying);\n        uint balanceBefore = EIP20Interface(underlying).balanceOf(address(this));\n        token.transferFrom(from, address(this), amount);\n\n        bool success;\n        assembly {\n            switch returndatasize()\n                case 0 {                       // This is a non-standard ERC-20\n                    success := not(0)          // set success to true\n                }\n                case 32 {                      // This is a compliant ERC-20\n                    returndatacopy(0, 0, 32)\n                    success := mload(0)        // Set `success = returndata` of external call\n                }\n                default {                      // This is an excessively non-compliant ERC-20, revert.\n                    revert(0, 0)\n                }\n        }\n        require(success, \"TOKEN_TRANSFER_IN_FAILED\");\n\n        // Calculate the amount that was *actually* transferred\n        uint balanceAfter = EIP20Interface(underlying).balanceOf(address(this));\n        uint transferredIn = sub_(balanceAfter, balanceBefore);\n        internalCash = add_(internalCash, transferredIn);\n        return transferredIn;\n    }\n\n    /**\n     * @dev Similar to EIP20 transfer, except it handles a False success from `transfer` and returns an explanatory\n     *      error code rather than reverting. If caller has not called checked protocol's balance, this may revert due to\n     *      insufficient cash held in this contract. If caller has checked protocol's balance prior to this call, and verified\n     *      it is >= amount, this should not revert in normal conditions.\n     *\n     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.\n     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\n     */\n    function doTransferOut(address payable to, uint amount) internal {\n        EIP20NonStandardInterface token = EIP20NonStandardInterface(underlying);\n        token.transfer(to, amount);\n\n        bool success;\n        assembly {\n            switch returndatasize()\n                case 0 {                      // This is a non-standard ERC-20\n                    success := not(0)          // set success to true\n                }\n                case 32 {                     // This is a complaint ERC-20\n                    returndatacopy(0, 0, 32)\n                    success := mload(0)        // Set `success = returndata` of external call\n                }\n                default {                     // This is an excessively non-compliant ERC-20, revert.\n                    revert(0, 0)\n                }\n        }\n        require(success, \"TOKEN_TRANSFER_OUT_FAILED\");\n        internalCash = sub_(internalCash, amount);\n    }\n\n    /**\n     * @notice Transfer `tokens` tokens from `src` to `dst` by `spender`\n     * @dev Called by both `transfer` and `transferFrom` internally\n     * @param spender The address of the account performing the transfer\n     * @param src The address of the source account\n     * @param dst The address of the destination account\n     * @param tokens The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     */\n    function transferTokens(address spender, address src, address dst, uint tokens) internal returns (uint) {\n        // Make sure accountCollateralTokens of `src` and `dst` are initialized.\n        initializeAccountCollateralTokens(src);\n        initializeAccountCollateralTokens(dst);\n\n        /**\n         * For every user, accountTokens must be greater than or equal to accountCollateralTokens.\n         * The buffer between the two values will be transferred first.\n         * bufferTokens = accountTokens[src] - accountCollateralTokens[src]\n         * collateralTokens = tokens - bufferTokens\n         */\n        uint bufferTokens = sub_(accountTokens[src], accountCollateralTokens[src]);\n        uint collateralTokens = 0;\n        if (tokens > bufferTokens) {\n            collateralTokens = sub_(tokens, bufferTokens);\n        }\n\n        /**\n         * Since bufferTokens are not collateralized and can be transferred freely, we only check with comptroller\n         * whether collateralized tokens can be transferred.\n         */\n        uint allowed = comptroller.transferAllowed(address(this), src, dst, collateralTokens);\n        if (allowed != 0) {\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.TRANSFER_COMPTROLLER_REJECTION, allowed);\n        }\n\n        /* Do not allow self-transfers */\n        if (src == dst) {\n            return fail(Error.BAD_INPUT, FailureInfo.TRANSFER_NOT_ALLOWED);\n        }\n\n        /* Get the allowance, infinite for the account owner */\n        uint startingAllowance = 0;\n        if (spender == src) {\n            startingAllowance = uint(-1);\n        } else {\n            startingAllowance = transferAllowances[src][spender];\n        }\n\n        /* Do the calculations, checking for {under,over}flow */\n        uint allowanceNew = sub_(startingAllowance, tokens);\n        accountTokens[src] = sub_(accountTokens[src], tokens);\n        accountTokens[dst] = add_(accountTokens[dst], tokens);\n        if (collateralTokens > 0) {\n            accountCollateralTokens[src] = sub_(accountCollateralTokens[src], collateralTokens);\n            accountCollateralTokens[dst] = add_(accountCollateralTokens[dst], collateralTokens);\n\n            emit UserCollateralChanged(src, accountCollateralTokens[src]);\n            emit UserCollateralChanged(dst, accountCollateralTokens[dst]);\n        }\n\n        /* Eat some of the allowance (if necessary) */\n        if (startingAllowance != uint(-1)) {\n            transferAllowances[src][spender] = allowanceNew;\n        }\n\n        /* We emit a Transfer event */\n        emit Transfer(src, dst, tokens);\n\n        // unused function\n        // comptroller.transferVerify(address(this), src, dst, tokens);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Get the account's cToken balances\n     * @param account The address of the account\n     */\n    //  SWC-135-Code With No Effects: L410\n    function getCTokenBalanceInternal(address account) internal view returns (uint) {\n        if (isCollateralTokenInit[account]) {\n            return accountCollateralTokens[account];\n        } else {\n            /**\n             * If the value of accountCollateralTokens was not initialized, we should return the value of accountTokens.\n             */\n            return accountTokens[account];\n        }\n    }\n\n    /**\n     * @notice Increase user's collateral. Increase as much as we can.\n     * @param account The address of the account\n     * @param amount The amount of collateral user wants to increase\n     * @return The actual increased amount of collateral\n     */\n    function increaseUserCollateralInternal(address account, uint amount) internal returns (uint) {\n        uint totalCollateralTokensNew = add_(totalCollateralTokens, amount);\n        if (collateralCap == 0 || (collateralCap != 0 && totalCollateralTokensNew <= collateralCap)) {\n            // 1. If collateral cap is not set,\n            // 2. If collateral cap is set but has enough space for this user,\n            // give all the user needs.\n            totalCollateralTokens = totalCollateralTokensNew;\n            accountCollateralTokens[account] = add_(accountCollateralTokens[account], amount);\n\n            emit UserCollateralChanged(account, accountCollateralTokens[account]);\n            return amount;\n        } else if (collateralCap > totalCollateralTokens) {\n            // If the collateral cap is set but the remaining cap is not enough for this user,\n            // give the remaining parts to the user.\n            uint gap = sub_(collateralCap, totalCollateralTokens);\n            totalCollateralTokens = add_(totalCollateralTokens, gap);\n            accountCollateralTokens[account] = add_(accountCollateralTokens[account], gap);\n\n            emit UserCollateralChanged(account, accountCollateralTokens[account]);\n            return gap;\n        }\n        return 0;\n    }\n\n    /**\n     * @notice Decrease user's collateral. Reject if the amount can't be fully decrease.\n     * @param account The address of the account\n     * @param amount The amount of collateral user wants to decrease\n     */\n    function decreaseUserCollateralInternal(address account, uint amount) internal {\n        require(comptroller.redeemAllowed(address(this), account, amount) == 0, \"comptroller rejection\");\n\n        totalCollateralTokens = sub_(totalCollateralTokens, amount);\n        accountCollateralTokens[account] = sub_(accountCollateralTokens[account], amount);\n\n        emit UserCollateralChanged(account, accountCollateralTokens[account]);\n    }\n\n    struct MintLocalVars {\n        uint exchangeRateMantissa;\n        uint mintTokens;\n        uint actualMintAmount;\n    }\n\n    /**\n     * @notice User supplies assets into the market and receives cTokens in exchange\n     * @dev Assumes interest has already been accrued up to the current block\n     * @param minter The address of the account which is supplying the assets\n     * @param mintAmount The amount of the underlying asset to supply\n     * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual mint amount.\n     */\n    function mintFresh(address minter, uint mintAmount) internal returns (uint, uint) {\n        // Make sure accountCollateralTokens of `minter` is initialized.\n        initializeAccountCollateralTokens(minter);\n\n        /* Fail if mint not allowed */\n        uint allowed = comptroller.mintAllowed(address(this), minter, mintAmount);\n        if (allowed != 0) {\n            return (failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.MINT_COMPTROLLER_REJECTION, allowed), 0);\n        }\n\n        /* Verify market's block number equals current block number */\n        if (accrualBlockNumber != getBlockNumber()) {\n            return (fail(Error.MARKET_NOT_FRESH, FailureInfo.MINT_FRESHNESS_CHECK), 0);\n        }\n\n        MintLocalVars memory vars;\n\n        vars.exchangeRateMantissa = exchangeRateStoredInternal();\n\n        \n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        /*\n         *  We call `doTransferIn` for the minter and the mintAmount.\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n         *  `doTransferIn` reverts if anything goes wrong, since we can't be sure if\n         *  side-effects occurred. The function returns the amount actually transferred,\n         *  in case of a fee. On success, the cToken holds an additional `actualMintAmount`\n         *  of cash.\n         */\n        vars.actualMintAmount = doTransferIn(minter, mintAmount);\n\n        /*\n         * We get the current exchange rate and calculate the number of cTokens to be minted:\n         *  mintTokens = actualMintAmount / exchangeRate\n         */\n        vars.mintTokens = div_ScalarByExpTruncate(vars.actualMintAmount, Exp({mantissa: vars.exchangeRateMantissa}));\n\n        /*\n         * We calculate the new total supply of cTokens and minter token balance, checking for overflow:\n         *  totalSupply = totalSupply + mintTokens\n         *  accountTokens[minter] = accountTokens[minter] + mintTokens\n         */\n        totalSupply = add_(totalSupply, vars.mintTokens);\n        accountTokens[minter] = add_(accountTokens[minter], vars.mintTokens);\n\n        /*\n         * We only allocate collateral tokens if the minter has entered the market.\n         */\n        if (ComptrollerInterfaceExtension(address(comptroller)).checkMembership(minter, CToken(this))) {\n            increaseUserCollateralInternal(minter, vars.mintTokens);\n        }\n\n        /* We emit a Mint event, and a Transfer event */\n        emit Mint(minter, vars.actualMintAmount, vars.mintTokens);\n        emit Transfer(address(this), minter, vars.mintTokens);\n\n        /* We call the defense hook */\n        // unused function\n        // comptroller.mintVerify(address(this), minter, vars.actualMintAmount, vars.mintTokens);\n\n        return (uint(Error.NO_ERROR), vars.actualMintAmount);\n    }\n\n    struct RedeemLocalVars {\n        uint exchangeRateMantissa;\n        uint redeemTokens;\n        uint redeemAmount;\n    }\n\n    /**\n     * @notice User redeems cTokens in exchange for the underlying asset\n     * @dev Assumes interest has already been accrued up to the current block\n     * @param redeemer The address of the account which is redeeming the tokens\n     * @param redeemTokensIn The number of cTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be non-zero)\n     * @param redeemAmountIn The number of underlying tokens to receive from redeeming cTokens (only one of redeemTokensIn or redeemAmountIn may be non-zero)\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n        // Make sure accountCollateralTokens of `redeemer` is initialized.\n        initializeAccountCollateralTokens(redeemer);\n\n        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n\n        RedeemLocalVars memory vars;\n\n        /* exchangeRate = invoke Exchange Rate Stored() */\n        vars.exchangeRateMantissa = exchangeRateStoredInternal();\n\n        /* If redeemTokensIn > 0: */\n        if (redeemTokensIn > 0) {\n            /*\n             * We calculate the exchange rate and the amount of underlying to be redeemed:\n             *  redeemTokens = redeemTokensIn\n             *  redeemAmount = redeemTokensIn x exchangeRateCurrent\n             */\n            vars.redeemTokens = redeemTokensIn;\n            vars.redeemAmount = mul_ScalarTruncate(Exp({mantissa: vars.exchangeRateMantissa}), redeemTokensIn);\n        } else {\n            /*\n             * We get the current exchange rate and calculate the amount to be redeemed:\n             *  redeemTokens = redeemAmountIn / exchangeRate\n             *  redeemAmount = redeemAmountIn\n             */\n            vars.redeemTokens = div_ScalarByExpTruncate(redeemAmountIn, Exp({mantissa: vars.exchangeRateMantissa}));\n            vars.redeemAmount = redeemAmountIn;\n        }\n\n        /**\n         * For every user, accountTokens must be greater than or equal to accountCollateralTokens.\n         * The buffer between the two values will be redeemed first.\n         * bufferTokens = accountTokens[redeemer] - accountCollateralTokens[redeemer]\n         * collateralTokens = redeemTokens - bufferTokens\n         */\n        uint bufferTokens = sub_(accountTokens[redeemer], accountCollateralTokens[redeemer]);\n        uint collateralTokens = 0;\n        if (vars.redeemTokens > bufferTokens) {\n            collateralTokens = sub_(vars.redeemTokens, bufferTokens);\n        }\n\n        /* Verify market's block number equals current block number */\n        if (accrualBlockNumber != getBlockNumber()) {\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);\n        }\n\n        /* Fail gracefully if protocol has insufficient cash */\n        if (getCashPrior() < vars.redeemAmount) {\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);\n        }\n\n        \n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        /*\n         * We invoke doTransferOut for the redeemer and the redeemAmount.\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n         *  On success, the cToken has redeemAmount less of cash.\n         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n         */\n        doTransferOut(redeemer, vars.redeemAmount);\n\n        /*\n         * We calculate the new total supply and redeemer balance, checking for underflow:\n         *  totalSupplyNew = totalSupply - redeemTokens\n         *  accountTokensNew = accountTokens[redeemer] - redeemTokens\n         */\n        totalSupply = sub_(totalSupply, vars.redeemTokens);\n        accountTokens[redeemer] = sub_(accountTokens[redeemer], vars.redeemTokens);\n\n        /*\n         * We only deallocate collateral tokens if the redeemer needs to redeem them.\n         */\n        if (collateralTokens > 0) {\n            decreaseUserCollateralInternal(redeemer, collateralTokens);\n        }\n\n        /* We emit a Transfer event, and a Redeem event */\n        emit Transfer(redeemer, address(this), vars.redeemTokens);\n        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);\n\n        /* We call the defense hook */\n        comptroller.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Transfers collateral tokens (this market) to the liquidator.\n     * @dev Called only during an in-kind liquidation, or by liquidateBorrow during the liquidation of another CToken.\n     *  Its absolutely critical to use msg.sender as the seizer cToken and not a parameter.\n     * @param seizerToken The contract seizing the collateral (i.e. borrowed cToken)\n     * @param liquidator The account receiving seized collateral\n     * @param borrower The account having collateral seized\n     * @param seizeTokens The number of cTokens to seize\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function seizeInternal(address seizerToken, address liquidator, address borrower, uint seizeTokens) internal returns (uint) {\n        // Make sure accountCollateralTokens of `liquidator` and `borrower` are initialized.\n        initializeAccountCollateralTokens(liquidator);\n        initializeAccountCollateralTokens(borrower);\n\n        /* Fail if seize not allowed */\n        uint allowed = comptroller.seizeAllowed(address(this), seizerToken, liquidator, borrower, seizeTokens);\n        if (allowed != 0) {\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_SEIZE_COMPTROLLER_REJECTION, allowed);\n        }\n\n        /* Fail if borrower = liquidator */\n        if (borrower == liquidator) {\n            return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER);\n        }\n\n        /*\n         * We calculate the new borrower and liquidator token balances and token collateral balances, failing on underflow/overflow:\n         *  accountTokens[borrower] = accountTokens[borrower] - seizeTokens\n         *  accountTokens[liquidator] = accountTokens[liquidator] + seizeTokens\n         *  accountCollateralTokens[borrower] = accountCollateralTokens[borrower] - seizeTokens\n         *  accountCollateralTokens[liquidator] = accountCollateralTokens[liquidator] + seizeTokens\n         */\n        accountTokens[borrower] = sub_(accountTokens[borrower], seizeTokens);\n        accountTokens[liquidator] = add_(accountTokens[liquidator], seizeTokens);\n        accountCollateralTokens[borrower] = sub_(accountCollateralTokens[borrower], seizeTokens);\n        accountCollateralTokens[liquidator] = add_(accountCollateralTokens[liquidator], seizeTokens);\n\n        /* Emit a Transfer, UserCollateralChanged events */\n        emit Transfer(borrower, liquidator, seizeTokens);\n        emit UserCollateralChanged(borrower, accountCollateralTokens[borrower]);\n        emit UserCollateralChanged(liquidator, accountCollateralTokens[liquidator]);\n\n        /* We call the defense hook */\n        // unused function\n        // comptroller.seizeVerify(address(this), seizerToken, liquidator, borrower, seizeTokens);\n\n        return uint(Error.NO_ERROR);\n    }\n}",
        "function": "accrueInterest()",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/QuillAudits-C.R.E.A.M. Finance-Compound Protocol/compound-protocol-23a4ae93adc70334553f5a83429a4e967c1eefaa/contracts/CCollateralCapErc20.sol",
        "vulnerability": "Dependence on predictable environment variable (SWC 120)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract CCollateralCapErc20 is CToken, CCollateralCapErc20Interface {\n    /**\n     * @notice Initialize the new money market\n     * @param underlying_ The address of the underlying asset\n     * @param comptroller_ The address of the Comptroller\n     * @param interestRateModel_ The address of the interest rate model\n     * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18\n     * @param name_ ERC-20 name of this token\n     * @param symbol_ ERC-20 symbol of this token\n     * @param decimals_ ERC-20 decimal precision of this token\n     */\n    function initialize(address underlying_,\n                        ComptrollerInterface comptroller_,\n                        InterestRateModel interestRateModel_,\n                        uint initialExchangeRateMantissa_,\n                        string memory name_,\n                        string memory symbol_,\n                        uint8 decimals_) public {\n        // CToken initialize does the bulk of the work\n        super.initialize(comptroller_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_);\n\n        // Set underlying and sanity check it\n        underlying = underlying_;\n        EIP20Interface(underlying).totalSupply();\n    }\n\n    /*** User Interface ***/\n\n    /**\n     * @notice Sender supplies assets into the market and receives cTokens in exchange\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param mintAmount The amount of the underlying asset to supply\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function mint(uint mintAmount) external returns (uint) {\n        (uint err,) = mintInternal(mintAmount);\n        return err;\n    }\n\n    /**\n     * @notice Sender redeems cTokens in exchange for the underlying asset\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param redeemTokens The number of cTokens to redeem into underlying\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function redeem(uint redeemTokens) external returns (uint) {\n        return redeemInternal(redeemTokens);\n    }\n\n    /**\n     * @notice Sender redeems cTokens in exchange for a specified amount of underlying asset\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param redeemAmount The amount of underlying to redeem\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function redeemUnderlying(uint redeemAmount) external returns (uint) {\n        return redeemUnderlyingInternal(redeemAmount);\n    }\n\n    /**\n      * @notice Sender borrows assets from the protocol to their own address\n      * @param borrowAmount The amount of the underlying asset to borrow\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n      */\n    function borrow(uint borrowAmount) external returns (uint) {\n        return borrowInternal(borrowAmount);\n    }\n\n    /**\n     * @notice Sender repays their own borrow\n     * @param repayAmount The amount to repay\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function repayBorrow(uint repayAmount) external returns (uint) {\n        (uint err,) = repayBorrowInternal(repayAmount);\n        return err;\n    }\n\n    /**\n     * @notice Sender repays a borrow belonging to borrower\n     * @param borrower the account with the debt being payed off\n     * @param repayAmount The amount to repay\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function repayBorrowBehalf(address borrower, uint repayAmount) external returns (uint) {\n        (uint err,) = repayBorrowBehalfInternal(borrower, repayAmount);\n        return err;\n    }\n\n    /**\n     * @notice The sender liquidates the borrowers collateral.\n     *  The collateral seized is transferred to the liquidator.\n     * @param borrower The borrower of this cToken to be liquidated\n     * @param repayAmount The amount of the underlying borrowed asset to repay\n     * @param cTokenCollateral The market in which to seize collateral from the borrower\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function liquidateBorrow(address borrower, uint repayAmount, CTokenInterface cTokenCollateral) external returns (uint) {\n        (uint err,) = liquidateBorrowInternal(borrower, repayAmount, cTokenCollateral);\n        return err;\n    }\n\n    /**\n     * @notice The sender adds to reserves.\n     * @param addAmount The amount fo underlying token to add as reserves\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _addReserves(uint addAmount) external returns (uint) {\n        return _addReservesInternal(addAmount);\n    }\n\n    /**\n     * @notice Set the given collateral cap for the market.\n     * @param newCollateralCap New collateral cap for this market. A value of 0 corresponds to no cap.\n     */\n    function _setCollateralCap(uint newCollateralCap) external {\n        require(msg.sender == admin, \"only admin can set collateral cap\");\n\n        collateralCap = newCollateralCap;\n        emit NewCollateralCap(address(this), newCollateralCap);\n    }\n\n    /**\n     * @notice Absorb excess cash into reserves.\n     */\n    function gulp() external nonReentrant {\n        uint256 cashOnChain = getCashOnChain();\n        uint256 cashPrior = getCashPrior();\n\n        uint excessCash = sub_(cashOnChain, cashPrior);\n        totalReserves = add_(totalReserves, excessCash);\n        internalCash = cashOnChain;\n    }\n\n    /**\n     * @notice Flash loan funds to a given account.\n     * @param receiver The receiver address for the funds\n     * @param amount The amount of the funds to be loaned\n     * @param params The other parameters\n     */\n    function flashLoan(address receiver, uint amount, bytes calldata params) external nonReentrant {\n        uint cashOnChainBefore = getCashOnChain();\n        uint cashBefore = getCashPrior();\n        require(cashBefore >= amount, \"INSUFFICIENT_LIQUIDITY\");\n\n        // 1. calculate fee, 1 bips = 1/10000\n        uint totalFee = div_(mul_(amount, flashFeeBips), 10000);\n\n        // 2. transfer fund to receiver\n        doTransferOut(address(uint160(receiver)), amount);\n\n        // 3. execute receiver's callback function\n        IFlashloanReceiver(receiver).executeOperation(msg.sender, underlying, amount, totalFee, params);\n\n        // 4. check balance\n        uint cashOnChainAfter = getCashOnChain();\n        require(cashOnChainAfter == add_(cashOnChainBefore, totalFee), \"BALANCE_INCONSISTENT\");\n\n        // 5. update reserves and internal cash\n        uint reservesFee = mul_ScalarTruncate(Exp({mantissa: reserveFactorMantissa}), totalFee);\n        totalReserves = add_(totalReserves, reservesFee);\n        internalCash = add_(cashBefore, totalFee);\n\n        emit Flashloan(receiver, amount, totalFee, reservesFee);\n    }\n\n    /**\n     * @notice Register account collateral tokens if there is space.\n     * @param account The account to register\n     * @dev This function could only be called by comptroller.\n     * @return The actual registered amount of collateral\n     */\n    function registerCollateral(address account) external returns (uint) {\n        // Make sure accountCollateralTokens of `account` is initialized.\n        initializeAccountCollateralTokens(account);\n\n        require(msg.sender == address(comptroller), \"only comptroller may register collateral for user\");\n\n        uint amount = sub_(accountTokens[account], accountCollateralTokens[account]);\n        return increaseUserCollateralInternal(account, amount);\n    }\n\n    /**\n     * @notice Unregister account collateral tokens if the account still has enough collateral.\n     * @dev This function could only be called by comptroller.\n     * @param account The account to unregister\n     */\n    function unregisterCollateral(address account) external {\n        // Make sure accountCollateralTokens of `account` is initialized.\n        initializeAccountCollateralTokens(account);\n\n        require(msg.sender == address(comptroller), \"only comptroller may unregister collateral for user\");\n\n        decreaseUserCollateralInternal(account, accountCollateralTokens[account]);\n    }\n\n    /*** Safe Token ***/\n\n    /**\n     * @notice Gets internal balance of this contract in terms of the underlying.\n     *  It excludes balance from direct transfer.\n     * @dev This excludes the value of the current message, if any\n     * @return The quantity of underlying tokens owned by this contract\n     */\n    function getCashPrior() internal view returns (uint) {\n        return internalCash;\n    }\n\n    /**\n     * @notice Gets total balance of this contract in terms of the underlying\n     * @dev This excludes the value of the current message, if any\n     * @return The quantity of underlying tokens owned by this contract\n     */\n    function getCashOnChain() internal view returns (uint) {\n        EIP20Interface token = EIP20Interface(underlying);\n        return token.balanceOf(address(this));\n    }\n\n    /**\n     * @notice Initialize the account's collateral tokens. This function should be called in the beginning of every function\n     *  that accesses accountCollateralTokens or accountTokens.\n     * @param account The account of accountCollateralTokens that needs to be updated\n     */\n    function initializeAccountCollateralTokens(address account) internal {\n        /**\n         * If isCollateralTokenInit is false, it means accountCollateralTokens was not initialized yet.\n         * This case will only happen once and must be the very beginning. accountCollateralTokens is a new structure and its\n         * initial value should be equal to accountTokens if user has entered the market. However, it's almost impossible to\n         * check every user's value when the implementation becomes active. Therefore, it must rely on every action which will\n         * access accountTokens to call this function to check if accountCollateralTokens needed to be initialized.\n         */\n        if (!isCollateralTokenInit[account]) {\n            if (ComptrollerInterfaceExtension(address(comptroller)).checkMembership(account, CToken(this))) {\n                accountCollateralTokens[account] = accountTokens[account];\n                totalCollateralTokens = add_(totalCollateralTokens, accountTokens[account]);\n\n                emit UserCollateralChanged(account, accountCollateralTokens[account]);\n            }\n            isCollateralTokenInit[account] = true;\n        }\n    }\n\n    /**\n     * @dev Similar to EIP20 transfer, except it handles a False result from `transferFrom` and reverts in that case.\n     *      This will revert due to insufficient balance or insufficient allowance.\n     *      This function returns the actual amount received,\n     *      which may be less than `amount` if there is a fee attached to the transfer.\n     *\n     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.\n     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\n     */\n    function doTransferIn(address from, uint amount) internal returns (uint) {\n        EIP20NonStandardInterface token = EIP20NonStandardInterface(underlying);\n        uint balanceBefore = EIP20Interface(underlying).balanceOf(address(this));\n        token.transferFrom(from, address(this), amount);\n\n        bool success;\n        assembly {\n            switch returndatasize()\n                case 0 {                       // This is a non-standard ERC-20\n                    success := not(0)          // set success to true\n                }\n                case 32 {                      // This is a compliant ERC-20\n                    returndatacopy(0, 0, 32)\n                    success := mload(0)        // Set `success = returndata` of external call\n                }\n                default {                      // This is an excessively non-compliant ERC-20, revert.\n                    revert(0, 0)\n                }\n        }\n        require(success, \"TOKEN_TRANSFER_IN_FAILED\");\n\n        // Calculate the amount that was *actually* transferred\n        uint balanceAfter = EIP20Interface(underlying).balanceOf(address(this));\n        uint transferredIn = sub_(balanceAfter, balanceBefore);\n        internalCash = add_(internalCash, transferredIn);\n        return transferredIn;\n    }\n\n    /**\n     * @dev Similar to EIP20 transfer, except it handles a False success from `transfer` and returns an explanatory\n     *      error code rather than reverting. If caller has not called checked protocol's balance, this may revert due to\n     *      insufficient cash held in this contract. If caller has checked protocol's balance prior to this call, and verified\n     *      it is >= amount, this should not revert in normal conditions.\n     *\n     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.\n     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\n     */\n    function doTransferOut(address payable to, uint amount) internal {\n        EIP20NonStandardInterface token = EIP20NonStandardInterface(underlying);\n        token.transfer(to, amount);\n\n        bool success;\n        assembly {\n            switch returndatasize()\n                case 0 {                      // This is a non-standard ERC-20\n                    success := not(0)          // set success to true\n                }\n                case 32 {                     // This is a complaint ERC-20\n                    returndatacopy(0, 0, 32)\n                    success := mload(0)        // Set `success = returndata` of external call\n                }\n                default {                     // This is an excessively non-compliant ERC-20, revert.\n                    revert(0, 0)\n                }\n        }\n        require(success, \"TOKEN_TRANSFER_OUT_FAILED\");\n        internalCash = sub_(internalCash, amount);\n    }\n\n    /**\n     * @notice Transfer `tokens` tokens from `src` to `dst` by `spender`\n     * @dev Called by both `transfer` and `transferFrom` internally\n     * @param spender The address of the account performing the transfer\n     * @param src The address of the source account\n     * @param dst The address of the destination account\n     * @param tokens The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     */\n    function transferTokens(address spender, address src, address dst, uint tokens) internal returns (uint) {\n        // Make sure accountCollateralTokens of `src` and `dst` are initialized.\n        initializeAccountCollateralTokens(src);\n        initializeAccountCollateralTokens(dst);\n\n        /**\n         * For every user, accountTokens must be greater than or equal to accountCollateralTokens.\n         * The buffer between the two values will be transferred first.\n         * bufferTokens = accountTokens[src] - accountCollateralTokens[src]\n         * collateralTokens = tokens - bufferTokens\n         */\n        uint bufferTokens = sub_(accountTokens[src], accountCollateralTokens[src]);\n        uint collateralTokens = 0;\n        if (tokens > bufferTokens) {\n            collateralTokens = sub_(tokens, bufferTokens);\n        }\n\n        /**\n         * Since bufferTokens are not collateralized and can be transferred freely, we only check with comptroller\n         * whether collateralized tokens can be transferred.\n         */\n        uint allowed = comptroller.transferAllowed(address(this), src, dst, collateralTokens);\n        if (allowed != 0) {\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.TRANSFER_COMPTROLLER_REJECTION, allowed);\n        }\n\n        /* Do not allow self-transfers */\n        if (src == dst) {\n            return fail(Error.BAD_INPUT, FailureInfo.TRANSFER_NOT_ALLOWED);\n        }\n\n        /* Get the allowance, infinite for the account owner */\n        uint startingAllowance = 0;\n        if (spender == src) {\n            startingAllowance = uint(-1);\n        } else {\n            startingAllowance = transferAllowances[src][spender];\n        }\n\n        /* Do the calculations, checking for {under,over}flow */\n        uint allowanceNew = sub_(startingAllowance, tokens);\n        accountTokens[src] = sub_(accountTokens[src], tokens);\n        accountTokens[dst] = add_(accountTokens[dst], tokens);\n        if (collateralTokens > 0) {\n            accountCollateralTokens[src] = sub_(accountCollateralTokens[src], collateralTokens);\n            accountCollateralTokens[dst] = add_(accountCollateralTokens[dst], collateralTokens);\n\n            emit UserCollateralChanged(src, accountCollateralTokens[src]);\n            emit UserCollateralChanged(dst, accountCollateralTokens[dst]);\n        }\n\n        /* Eat some of the allowance (if necessary) */\n        if (startingAllowance != uint(-1)) {\n            transferAllowances[src][spender] = allowanceNew;\n        }\n\n        /* We emit a Transfer event */\n        emit Transfer(src, dst, tokens);\n\n        // unused function\n        // comptroller.transferVerify(address(this), src, dst, tokens);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Get the account's cToken balances\n     * @param account The address of the account\n     */\n    //  SWC-135-Code With No Effects: L410\n    function getCTokenBalanceInternal(address account) internal view returns (uint) {\n        if (isCollateralTokenInit[account]) {\n            return accountCollateralTokens[account];\n        } else {\n            /**\n             * If the value of accountCollateralTokens was not initialized, we should return the value of accountTokens.\n             */\n            return accountTokens[account];\n        }\n    }\n\n    /**\n     * @notice Increase user's collateral. Increase as much as we can.\n     * @param account The address of the account\n     * @param amount The amount of collateral user wants to increase\n     * @return The actual increased amount of collateral\n     */\n    function increaseUserCollateralInternal(address account, uint amount) internal returns (uint) {\n        uint totalCollateralTokensNew = add_(totalCollateralTokens, amount);\n        if (collateralCap == 0 || (collateralCap != 0 && totalCollateralTokensNew <= collateralCap)) {\n            // 1. If collateral cap is not set,\n            // 2. If collateral cap is set but has enough space for this user,\n            // give all the user needs.\n            totalCollateralTokens = totalCollateralTokensNew;\n            accountCollateralTokens[account] = add_(accountCollateralTokens[account], amount);\n\n            emit UserCollateralChanged(account, accountCollateralTokens[account]);\n            return amount;\n        } else if (collateralCap > totalCollateralTokens) {\n            // If the collateral cap is set but the remaining cap is not enough for this user,\n            // give the remaining parts to the user.\n            uint gap = sub_(collateralCap, totalCollateralTokens);\n            totalCollateralTokens = add_(totalCollateralTokens, gap);\n            accountCollateralTokens[account] = add_(accountCollateralTokens[account], gap);\n\n            emit UserCollateralChanged(account, accountCollateralTokens[account]);\n            return gap;\n        }\n        return 0;\n    }\n\n    /**\n     * @notice Decrease user's collateral. Reject if the amount can't be fully decrease.\n     * @param account The address of the account\n     * @param amount The amount of collateral user wants to decrease\n     */\n    function decreaseUserCollateralInternal(address account, uint amount) internal {\n        require(comptroller.redeemAllowed(address(this), account, amount) == 0, \"comptroller rejection\");\n\n        totalCollateralTokens = sub_(totalCollateralTokens, amount);\n        accountCollateralTokens[account] = sub_(accountCollateralTokens[account], amount);\n\n        emit UserCollateralChanged(account, accountCollateralTokens[account]);\n    }\n\n    struct MintLocalVars {\n        uint exchangeRateMantissa;\n        uint mintTokens;\n        uint actualMintAmount;\n    }\n\n    /**\n     * @notice User supplies assets into the market and receives cTokens in exchange\n     * @dev Assumes interest has already been accrued up to the current block\n     * @param minter The address of the account which is supplying the assets\n     * @param mintAmount The amount of the underlying asset to supply\n     * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual mint amount.\n     */\n    function mintFresh(address minter, uint mintAmount) internal returns (uint, uint) {\n        // Make sure accountCollateralTokens of `minter` is initialized.\n        initializeAccountCollateralTokens(minter);\n\n        /* Fail if mint not allowed */\n        uint allowed = comptroller.mintAllowed(address(this), minter, mintAmount);\n        if (allowed != 0) {\n            return (failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.MINT_COMPTROLLER_REJECTION, allowed), 0);\n        }\n\n        /* Verify market's block number equals current block number */\n        if (accrualBlockNumber != getBlockNumber()) {\n            return (fail(Error.MARKET_NOT_FRESH, FailureInfo.MINT_FRESHNESS_CHECK), 0);\n        }\n\n        MintLocalVars memory vars;\n\n        vars.exchangeRateMantissa = exchangeRateStoredInternal();\n\n        \n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        /*\n         *  We call `doTransferIn` for the minter and the mintAmount.\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n         *  `doTransferIn` reverts if anything goes wrong, since we can't be sure if\n         *  side-effects occurred. The function returns the amount actually transferred,\n         *  in case of a fee. On success, the cToken holds an additional `actualMintAmount`\n         *  of cash.\n         */\n        vars.actualMintAmount = doTransferIn(minter, mintAmount);\n\n        /*\n         * We get the current exchange rate and calculate the number of cTokens to be minted:\n         *  mintTokens = actualMintAmount / exchangeRate\n         */\n        vars.mintTokens = div_ScalarByExpTruncate(vars.actualMintAmount, Exp({mantissa: vars.exchangeRateMantissa}));\n\n        /*\n         * We calculate the new total supply of cTokens and minter token balance, checking for overflow:\n         *  totalSupply = totalSupply + mintTokens\n         *  accountTokens[minter] = accountTokens[minter] + mintTokens\n         */\n        totalSupply = add_(totalSupply, vars.mintTokens);\n        accountTokens[minter] = add_(accountTokens[minter], vars.mintTokens);\n\n        /*\n         * We only allocate collateral tokens if the minter has entered the market.\n         */\n        if (ComptrollerInterfaceExtension(address(comptroller)).checkMembership(minter, CToken(this))) {\n            increaseUserCollateralInternal(minter, vars.mintTokens);\n        }\n\n        /* We emit a Mint event, and a Transfer event */\n        emit Mint(minter, vars.actualMintAmount, vars.mintTokens);\n        emit Transfer(address(this), minter, vars.mintTokens);\n\n        /* We call the defense hook */\n        // unused function\n        // comptroller.mintVerify(address(this), minter, vars.actualMintAmount, vars.mintTokens);\n\n        return (uint(Error.NO_ERROR), vars.actualMintAmount);\n    }\n\n    struct RedeemLocalVars {\n        uint exchangeRateMantissa;\n        uint redeemTokens;\n        uint redeemAmount;\n    }\n\n    /**\n     * @notice User redeems cTokens in exchange for the underlying asset\n     * @dev Assumes interest has already been accrued up to the current block\n     * @param redeemer The address of the account which is redeeming the tokens\n     * @param redeemTokensIn The number of cTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be non-zero)\n     * @param redeemAmountIn The number of underlying tokens to receive from redeeming cTokens (only one of redeemTokensIn or redeemAmountIn may be non-zero)\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n        // Make sure accountCollateralTokens of `redeemer` is initialized.\n        initializeAccountCollateralTokens(redeemer);\n\n        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n\n        RedeemLocalVars memory vars;\n\n        /* exchangeRate = invoke Exchange Rate Stored() */\n        vars.exchangeRateMantissa = exchangeRateStoredInternal();\n\n        /* If redeemTokensIn > 0: */\n        if (redeemTokensIn > 0) {\n            /*\n             * We calculate the exchange rate and the amount of underlying to be redeemed:\n             *  redeemTokens = redeemTokensIn\n             *  redeemAmount = redeemTokensIn x exchangeRateCurrent\n             */\n            vars.redeemTokens = redeemTokensIn;\n            vars.redeemAmount = mul_ScalarTruncate(Exp({mantissa: vars.exchangeRateMantissa}), redeemTokensIn);\n        } else {\n            /*\n             * We get the current exchange rate and calculate the amount to be redeemed:\n             *  redeemTokens = redeemAmountIn / exchangeRate\n             *  redeemAmount = redeemAmountIn\n             */\n            vars.redeemTokens = div_ScalarByExpTruncate(redeemAmountIn, Exp({mantissa: vars.exchangeRateMantissa}));\n            vars.redeemAmount = redeemAmountIn;\n        }\n\n        /**\n         * For every user, accountTokens must be greater than or equal to accountCollateralTokens.\n         * The buffer between the two values will be redeemed first.\n         * bufferTokens = accountTokens[redeemer] - accountCollateralTokens[redeemer]\n         * collateralTokens = redeemTokens - bufferTokens\n         */\n        uint bufferTokens = sub_(accountTokens[redeemer], accountCollateralTokens[redeemer]);\n        uint collateralTokens = 0;\n        if (vars.redeemTokens > bufferTokens) {\n            collateralTokens = sub_(vars.redeemTokens, bufferTokens);\n        }\n\n        /* Verify market's block number equals current block number */\n        if (accrualBlockNumber != getBlockNumber()) {\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);\n        }\n\n        /* Fail gracefully if protocol has insufficient cash */\n        if (getCashPrior() < vars.redeemAmount) {\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);\n        }\n\n        \n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        /*\n         * We invoke doTransferOut for the redeemer and the redeemAmount.\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n         *  On success, the cToken has redeemAmount less of cash.\n         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n         */\n        doTransferOut(redeemer, vars.redeemAmount);\n\n        /*\n         * We calculate the new total supply and redeemer balance, checking for underflow:\n         *  totalSupplyNew = totalSupply - redeemTokens\n         *  accountTokensNew = accountTokens[redeemer] - redeemTokens\n         */\n        totalSupply = sub_(totalSupply, vars.redeemTokens);\n        accountTokens[redeemer] = sub_(accountTokens[redeemer], vars.redeemTokens);\n\n        /*\n         * We only deallocate collateral tokens if the redeemer needs to redeem them.\n         */\n        if (collateralTokens > 0) {\n            decreaseUserCollateralInternal(redeemer, collateralTokens);\n        }\n\n        /* We emit a Transfer event, and a Redeem event */\n        emit Transfer(redeemer, address(this), vars.redeemTokens);\n        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);\n\n        /* We call the defense hook */\n        comptroller.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Transfers collateral tokens (this market) to the liquidator.\n     * @dev Called only during an in-kind liquidation, or by liquidateBorrow during the liquidation of another CToken.\n     *  Its absolutely critical to use msg.sender as the seizer cToken and not a parameter.\n     * @param seizerToken The contract seizing the collateral (i.e. borrowed cToken)\n     * @param liquidator The account receiving seized collateral\n     * @param borrower The account having collateral seized\n     * @param seizeTokens The number of cTokens to seize\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function seizeInternal(address seizerToken, address liquidator, address borrower, uint seizeTokens) internal returns (uint) {\n        // Make sure accountCollateralTokens of `liquidator` and `borrower` are initialized.\n        initializeAccountCollateralTokens(liquidator);\n        initializeAccountCollateralTokens(borrower);\n\n        /* Fail if seize not allowed */\n        uint allowed = comptroller.seizeAllowed(address(this), seizerToken, liquidator, borrower, seizeTokens);\n        if (allowed != 0) {\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_SEIZE_COMPTROLLER_REJECTION, allowed);\n        }\n\n        /* Fail if borrower = liquidator */\n        if (borrower == liquidator) {\n            return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER);\n        }\n\n        /*\n         * We calculate the new borrower and liquidator token balances and token collateral balances, failing on underflow/overflow:\n         *  accountTokens[borrower] = accountTokens[borrower] - seizeTokens\n         *  accountTokens[liquidator] = accountTokens[liquidator] + seizeTokens\n         *  accountCollateralTokens[borrower] = accountCollateralTokens[borrower] - seizeTokens\n         *  accountCollateralTokens[liquidator] = accountCollateralTokens[liquidator] + seizeTokens\n         */\n        accountTokens[borrower] = sub_(accountTokens[borrower], seizeTokens);\n        accountTokens[liquidator] = add_(accountTokens[liquidator], seizeTokens);\n        accountCollateralTokens[borrower] = sub_(accountCollateralTokens[borrower], seizeTokens);\n        accountCollateralTokens[liquidator] = add_(accountCollateralTokens[liquidator], seizeTokens);\n\n        /* Emit a Transfer, UserCollateralChanged events */\n        emit Transfer(borrower, liquidator, seizeTokens);\n        emit UserCollateralChanged(borrower, accountCollateralTokens[borrower]);\n        emit UserCollateralChanged(liquidator, accountCollateralTokens[liquidator]);\n\n        /* We call the defense hook */\n        // unused function\n        // comptroller.seizeVerify(address(this), seizerToken, liquidator, borrower, seizeTokens);\n\n        return uint(Error.NO_ERROR);\n    }\n}",
        "function": "accrueInterest()",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/QuillAudits-C.R.E.A.M. Finance-Compound Protocol/compound-protocol-23a4ae93adc70334553f5a83429a4e967c1eefaa/contracts/CCollateralCapErc20.sol",
        "vulnerability": "Dependence on predictable environment variable (SWC 120)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract CCollateralCapErc20 is CToken, CCollateralCapErc20Interface {\n    /**\n     * @notice Initialize the new money market\n     * @param underlying_ The address of the underlying asset\n     * @param comptroller_ The address of the Comptroller\n     * @param interestRateModel_ The address of the interest rate model\n     * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18\n     * @param name_ ERC-20 name of this token\n     * @param symbol_ ERC-20 symbol of this token\n     * @param decimals_ ERC-20 decimal precision of this token\n     */\n    function initialize(address underlying_,\n                        ComptrollerInterface comptroller_,\n                        InterestRateModel interestRateModel_,\n                        uint initialExchangeRateMantissa_,\n                        string memory name_,\n                        string memory symbol_,\n                        uint8 decimals_) public {\n        // CToken initialize does the bulk of the work\n        super.initialize(comptroller_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_);\n\n        // Set underlying and sanity check it\n        underlying = underlying_;\n        EIP20Interface(underlying).totalSupply();\n    }\n\n    /*** User Interface ***/\n\n    /**\n     * @notice Sender supplies assets into the market and receives cTokens in exchange\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param mintAmount The amount of the underlying asset to supply\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function mint(uint mintAmount) external returns (uint) {\n        (uint err,) = mintInternal(mintAmount);\n        return err;\n    }\n\n    /**\n     * @notice Sender redeems cTokens in exchange for the underlying asset\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param redeemTokens The number of cTokens to redeem into underlying\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function redeem(uint redeemTokens) external returns (uint) {\n        return redeemInternal(redeemTokens);\n    }\n\n    /**\n     * @notice Sender redeems cTokens in exchange for a specified amount of underlying asset\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param redeemAmount The amount of underlying to redeem\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function redeemUnderlying(uint redeemAmount) external returns (uint) {\n        return redeemUnderlyingInternal(redeemAmount);\n    }\n\n    /**\n      * @notice Sender borrows assets from the protocol to their own address\n      * @param borrowAmount The amount of the underlying asset to borrow\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n      */\n    function borrow(uint borrowAmount) external returns (uint) {\n        return borrowInternal(borrowAmount);\n    }\n\n    /**\n     * @notice Sender repays their own borrow\n     * @param repayAmount The amount to repay\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function repayBorrow(uint repayAmount) external returns (uint) {\n        (uint err,) = repayBorrowInternal(repayAmount);\n        return err;\n    }\n\n    /**\n     * @notice Sender repays a borrow belonging to borrower\n     * @param borrower the account with the debt being payed off\n     * @param repayAmount The amount to repay\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function repayBorrowBehalf(address borrower, uint repayAmount) external returns (uint) {\n        (uint err,) = repayBorrowBehalfInternal(borrower, repayAmount);\n        return err;\n    }\n\n    /**\n     * @notice The sender liquidates the borrowers collateral.\n     *  The collateral seized is transferred to the liquidator.\n     * @param borrower The borrower of this cToken to be liquidated\n     * @param repayAmount The amount of the underlying borrowed asset to repay\n     * @param cTokenCollateral The market in which to seize collateral from the borrower\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function liquidateBorrow(address borrower, uint repayAmount, CTokenInterface cTokenCollateral) external returns (uint) {\n        (uint err,) = liquidateBorrowInternal(borrower, repayAmount, cTokenCollateral);\n        return err;\n    }\n\n    /**\n     * @notice The sender adds to reserves.\n     * @param addAmount The amount fo underlying token to add as reserves\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _addReserves(uint addAmount) external returns (uint) {\n        return _addReservesInternal(addAmount);\n    }\n\n    /**\n     * @notice Set the given collateral cap for the market.\n     * @param newCollateralCap New collateral cap for this market. A value of 0 corresponds to no cap.\n     */\n    function _setCollateralCap(uint newCollateralCap) external {\n        require(msg.sender == admin, \"only admin can set collateral cap\");\n\n        collateralCap = newCollateralCap;\n        emit NewCollateralCap(address(this), newCollateralCap);\n    }\n\n    /**\n     * @notice Absorb excess cash into reserves.\n     */\n    function gulp() external nonReentrant {\n        uint256 cashOnChain = getCashOnChain();\n        uint256 cashPrior = getCashPrior();\n\n        uint excessCash = sub_(cashOnChain, cashPrior);\n        totalReserves = add_(totalReserves, excessCash);\n        internalCash = cashOnChain;\n    }\n\n    /**\n     * @notice Flash loan funds to a given account.\n     * @param receiver The receiver address for the funds\n     * @param amount The amount of the funds to be loaned\n     * @param params The other parameters\n     */\n    function flashLoan(address receiver, uint amount, bytes calldata params) external nonReentrant {\n        uint cashOnChainBefore = getCashOnChain();\n        uint cashBefore = getCashPrior();\n        require(cashBefore >= amount, \"INSUFFICIENT_LIQUIDITY\");\n\n        // 1. calculate fee, 1 bips = 1/10000\n        uint totalFee = div_(mul_(amount, flashFeeBips), 10000);\n\n        // 2. transfer fund to receiver\n        doTransferOut(address(uint160(receiver)), amount);\n\n        // 3. execute receiver's callback function\n        IFlashloanReceiver(receiver).executeOperation(msg.sender, underlying, amount, totalFee, params);\n\n        // 4. check balance\n        uint cashOnChainAfter = getCashOnChain();\n        require(cashOnChainAfter == add_(cashOnChainBefore, totalFee), \"BALANCE_INCONSISTENT\");\n\n        // 5. update reserves and internal cash\n        uint reservesFee = mul_ScalarTruncate(Exp({mantissa: reserveFactorMantissa}), totalFee);\n        totalReserves = add_(totalReserves, reservesFee);\n        internalCash = add_(cashBefore, totalFee);\n\n        emit Flashloan(receiver, amount, totalFee, reservesFee);\n    }\n\n    /**\n     * @notice Register account collateral tokens if there is space.\n     * @param account The account to register\n     * @dev This function could only be called by comptroller.\n     * @return The actual registered amount of collateral\n     */\n    function registerCollateral(address account) external returns (uint) {\n        // Make sure accountCollateralTokens of `account` is initialized.\n        initializeAccountCollateralTokens(account);\n\n        require(msg.sender == address(comptroller), \"only comptroller may register collateral for user\");\n\n        uint amount = sub_(accountTokens[account], accountCollateralTokens[account]);\n        return increaseUserCollateralInternal(account, amount);\n    }\n\n    /**\n     * @notice Unregister account collateral tokens if the account still has enough collateral.\n     * @dev This function could only be called by comptroller.\n     * @param account The account to unregister\n     */\n    function unregisterCollateral(address account) external {\n        // Make sure accountCollateralTokens of `account` is initialized.\n        initializeAccountCollateralTokens(account);\n\n        require(msg.sender == address(comptroller), \"only comptroller may unregister collateral for user\");\n\n        decreaseUserCollateralInternal(account, accountCollateralTokens[account]);\n    }\n\n    /*** Safe Token ***/\n\n    /**\n     * @notice Gets internal balance of this contract in terms of the underlying.\n     *  It excludes balance from direct transfer.\n     * @dev This excludes the value of the current message, if any\n     * @return The quantity of underlying tokens owned by this contract\n     */\n    function getCashPrior() internal view returns (uint) {\n        return internalCash;\n    }\n\n    /**\n     * @notice Gets total balance of this contract in terms of the underlying\n     * @dev This excludes the value of the current message, if any\n     * @return The quantity of underlying tokens owned by this contract\n     */\n    function getCashOnChain() internal view returns (uint) {\n        EIP20Interface token = EIP20Interface(underlying);\n        return token.balanceOf(address(this));\n    }\n\n    /**\n     * @notice Initialize the account's collateral tokens. This function should be called in the beginning of every function\n     *  that accesses accountCollateralTokens or accountTokens.\n     * @param account The account of accountCollateralTokens that needs to be updated\n     */\n    function initializeAccountCollateralTokens(address account) internal {\n        /**\n         * If isCollateralTokenInit is false, it means accountCollateralTokens was not initialized yet.\n         * This case will only happen once and must be the very beginning. accountCollateralTokens is a new structure and its\n         * initial value should be equal to accountTokens if user has entered the market. However, it's almost impossible to\n         * check every user's value when the implementation becomes active. Therefore, it must rely on every action which will\n         * access accountTokens to call this function to check if accountCollateralTokens needed to be initialized.\n         */\n        if (!isCollateralTokenInit[account]) {\n            if (ComptrollerInterfaceExtension(address(comptroller)).checkMembership(account, CToken(this))) {\n                accountCollateralTokens[account] = accountTokens[account];\n                totalCollateralTokens = add_(totalCollateralTokens, accountTokens[account]);\n\n                emit UserCollateralChanged(account, accountCollateralTokens[account]);\n            }\n            isCollateralTokenInit[account] = true;\n        }\n    }\n\n    /**\n     * @dev Similar to EIP20 transfer, except it handles a False result from `transferFrom` and reverts in that case.\n     *      This will revert due to insufficient balance or insufficient allowance.\n     *      This function returns the actual amount received,\n     *      which may be less than `amount` if there is a fee attached to the transfer.\n     *\n     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.\n     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\n     */\n    function doTransferIn(address from, uint amount) internal returns (uint) {\n        EIP20NonStandardInterface token = EIP20NonStandardInterface(underlying);\n        uint balanceBefore = EIP20Interface(underlying).balanceOf(address(this));\n        token.transferFrom(from, address(this), amount);\n\n        bool success;\n        assembly {\n            switch returndatasize()\n                case 0 {                       // This is a non-standard ERC-20\n                    success := not(0)          // set success to true\n                }\n                case 32 {                      // This is a compliant ERC-20\n                    returndatacopy(0, 0, 32)\n                    success := mload(0)        // Set `success = returndata` of external call\n                }\n                default {                      // This is an excessively non-compliant ERC-20, revert.\n                    revert(0, 0)\n                }\n        }\n        require(success, \"TOKEN_TRANSFER_IN_FAILED\");\n\n        // Calculate the amount that was *actually* transferred\n        uint balanceAfter = EIP20Interface(underlying).balanceOf(address(this));\n        uint transferredIn = sub_(balanceAfter, balanceBefore);\n        internalCash = add_(internalCash, transferredIn);\n        return transferredIn;\n    }\n\n    /**\n     * @dev Similar to EIP20 transfer, except it handles a False success from `transfer` and returns an explanatory\n     *      error code rather than reverting. If caller has not called checked protocol's balance, this may revert due to\n     *      insufficient cash held in this contract. If caller has checked protocol's balance prior to this call, and verified\n     *      it is >= amount, this should not revert in normal conditions.\n     *\n     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.\n     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\n     */\n    function doTransferOut(address payable to, uint amount) internal {\n        EIP20NonStandardInterface token = EIP20NonStandardInterface(underlying);\n        token.transfer(to, amount);\n\n        bool success;\n        assembly {\n            switch returndatasize()\n                case 0 {                      // This is a non-standard ERC-20\n                    success := not(0)          // set success to true\n                }\n                case 32 {                     // This is a complaint ERC-20\n                    returndatacopy(0, 0, 32)\n                    success := mload(0)        // Set `success = returndata` of external call\n                }\n                default {                     // This is an excessively non-compliant ERC-20, revert.\n                    revert(0, 0)\n                }\n        }\n        require(success, \"TOKEN_TRANSFER_OUT_FAILED\");\n        internalCash = sub_(internalCash, amount);\n    }\n\n    /**\n     * @notice Transfer `tokens` tokens from `src` to `dst` by `spender`\n     * @dev Called by both `transfer` and `transferFrom` internally\n     * @param spender The address of the account performing the transfer\n     * @param src The address of the source account\n     * @param dst The address of the destination account\n     * @param tokens The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     */\n    function transferTokens(address spender, address src, address dst, uint tokens) internal returns (uint) {\n        // Make sure accountCollateralTokens of `src` and `dst` are initialized.\n        initializeAccountCollateralTokens(src);\n        initializeAccountCollateralTokens(dst);\n\n        /**\n         * For every user, accountTokens must be greater than or equal to accountCollateralTokens.\n         * The buffer between the two values will be transferred first.\n         * bufferTokens = accountTokens[src] - accountCollateralTokens[src]\n         * collateralTokens = tokens - bufferTokens\n         */\n        uint bufferTokens = sub_(accountTokens[src], accountCollateralTokens[src]);\n        uint collateralTokens = 0;\n        if (tokens > bufferTokens) {\n            collateralTokens = sub_(tokens, bufferTokens);\n        }\n\n        /**\n         * Since bufferTokens are not collateralized and can be transferred freely, we only check with comptroller\n         * whether collateralized tokens can be transferred.\n         */\n        uint allowed = comptroller.transferAllowed(address(this), src, dst, collateralTokens);\n        if (allowed != 0) {\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.TRANSFER_COMPTROLLER_REJECTION, allowed);\n        }\n\n        /* Do not allow self-transfers */\n        if (src == dst) {\n            return fail(Error.BAD_INPUT, FailureInfo.TRANSFER_NOT_ALLOWED);\n        }\n\n        /* Get the allowance, infinite for the account owner */\n        uint startingAllowance = 0;\n        if (spender == src) {\n            startingAllowance = uint(-1);\n        } else {\n            startingAllowance = transferAllowances[src][spender];\n        }\n\n        /* Do the calculations, checking for {under,over}flow */\n        uint allowanceNew = sub_(startingAllowance, tokens);\n        accountTokens[src] = sub_(accountTokens[src], tokens);\n        accountTokens[dst] = add_(accountTokens[dst], tokens);\n        if (collateralTokens > 0) {\n            accountCollateralTokens[src] = sub_(accountCollateralTokens[src], collateralTokens);\n            accountCollateralTokens[dst] = add_(accountCollateralTokens[dst], collateralTokens);\n\n            emit UserCollateralChanged(src, accountCollateralTokens[src]);\n            emit UserCollateralChanged(dst, accountCollateralTokens[dst]);\n        }\n\n        /* Eat some of the allowance (if necessary) */\n        if (startingAllowance != uint(-1)) {\n            transferAllowances[src][spender] = allowanceNew;\n        }\n\n        /* We emit a Transfer event */\n        emit Transfer(src, dst, tokens);\n\n        // unused function\n        // comptroller.transferVerify(address(this), src, dst, tokens);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Get the account's cToken balances\n     * @param account The address of the account\n     */\n    //  SWC-135-Code With No Effects: L410\n    function getCTokenBalanceInternal(address account) internal view returns (uint) {\n        if (isCollateralTokenInit[account]) {\n            return accountCollateralTokens[account];\n        } else {\n            /**\n             * If the value of accountCollateralTokens was not initialized, we should return the value of accountTokens.\n             */\n            return accountTokens[account];\n        }\n    }\n\n    /**\n     * @notice Increase user's collateral. Increase as much as we can.\n     * @param account The address of the account\n     * @param amount The amount of collateral user wants to increase\n     * @return The actual increased amount of collateral\n     */\n    function increaseUserCollateralInternal(address account, uint amount) internal returns (uint) {\n        uint totalCollateralTokensNew = add_(totalCollateralTokens, amount);\n        if (collateralCap == 0 || (collateralCap != 0 && totalCollateralTokensNew <= collateralCap)) {\n            // 1. If collateral cap is not set,\n            // 2. If collateral cap is set but has enough space for this user,\n            // give all the user needs.\n            totalCollateralTokens = totalCollateralTokensNew;\n            accountCollateralTokens[account] = add_(accountCollateralTokens[account], amount);\n\n            emit UserCollateralChanged(account, accountCollateralTokens[account]);\n            return amount;\n        } else if (collateralCap > totalCollateralTokens) {\n            // If the collateral cap is set but the remaining cap is not enough for this user,\n            // give the remaining parts to the user.\n            uint gap = sub_(collateralCap, totalCollateralTokens);\n            totalCollateralTokens = add_(totalCollateralTokens, gap);\n            accountCollateralTokens[account] = add_(accountCollateralTokens[account], gap);\n\n            emit UserCollateralChanged(account, accountCollateralTokens[account]);\n            return gap;\n        }\n        return 0;\n    }\n\n    /**\n     * @notice Decrease user's collateral. Reject if the amount can't be fully decrease.\n     * @param account The address of the account\n     * @param amount The amount of collateral user wants to decrease\n     */\n    function decreaseUserCollateralInternal(address account, uint amount) internal {\n        require(comptroller.redeemAllowed(address(this), account, amount) == 0, \"comptroller rejection\");\n\n        totalCollateralTokens = sub_(totalCollateralTokens, amount);\n        accountCollateralTokens[account] = sub_(accountCollateralTokens[account], amount);\n\n        emit UserCollateralChanged(account, accountCollateralTokens[account]);\n    }\n\n    struct MintLocalVars {\n        uint exchangeRateMantissa;\n        uint mintTokens;\n        uint actualMintAmount;\n    }\n\n    /**\n     * @notice User supplies assets into the market and receives cTokens in exchange\n     * @dev Assumes interest has already been accrued up to the current block\n     * @param minter The address of the account which is supplying the assets\n     * @param mintAmount The amount of the underlying asset to supply\n     * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual mint amount.\n     */\n    function mintFresh(address minter, uint mintAmount) internal returns (uint, uint) {\n        // Make sure accountCollateralTokens of `minter` is initialized.\n        initializeAccountCollateralTokens(minter);\n\n        /* Fail if mint not allowed */\n        uint allowed = comptroller.mintAllowed(address(this), minter, mintAmount);\n        if (allowed != 0) {\n            return (failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.MINT_COMPTROLLER_REJECTION, allowed), 0);\n        }\n\n        /* Verify market's block number equals current block number */\n        if (accrualBlockNumber != getBlockNumber()) {\n            return (fail(Error.MARKET_NOT_FRESH, FailureInfo.MINT_FRESHNESS_CHECK), 0);\n        }\n\n        MintLocalVars memory vars;\n\n        vars.exchangeRateMantissa = exchangeRateStoredInternal();\n\n        \n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        /*\n         *  We call `doTransferIn` for the minter and the mintAmount.\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n         *  `doTransferIn` reverts if anything goes wrong, since we can't be sure if\n         *  side-effects occurred. The function returns the amount actually transferred,\n         *  in case of a fee. On success, the cToken holds an additional `actualMintAmount`\n         *  of cash.\n         */\n        vars.actualMintAmount = doTransferIn(minter, mintAmount);\n\n        /*\n         * We get the current exchange rate and calculate the number of cTokens to be minted:\n         *  mintTokens = actualMintAmount / exchangeRate\n         */\n        vars.mintTokens = div_ScalarByExpTruncate(vars.actualMintAmount, Exp({mantissa: vars.exchangeRateMantissa}));\n\n        /*\n         * We calculate the new total supply of cTokens and minter token balance, checking for overflow:\n         *  totalSupply = totalSupply + mintTokens\n         *  accountTokens[minter] = accountTokens[minter] + mintTokens\n         */\n        totalSupply = add_(totalSupply, vars.mintTokens);\n        accountTokens[minter] = add_(accountTokens[minter], vars.mintTokens);\n\n        /*\n         * We only allocate collateral tokens if the minter has entered the market.\n         */\n        if (ComptrollerInterfaceExtension(address(comptroller)).checkMembership(minter, CToken(this))) {\n            increaseUserCollateralInternal(minter, vars.mintTokens);\n        }\n\n        /* We emit a Mint event, and a Transfer event */\n        emit Mint(minter, vars.actualMintAmount, vars.mintTokens);\n        emit Transfer(address(this), minter, vars.mintTokens);\n\n        /* We call the defense hook */\n        // unused function\n        // comptroller.mintVerify(address(this), minter, vars.actualMintAmount, vars.mintTokens);\n\n        return (uint(Error.NO_ERROR), vars.actualMintAmount);\n    }\n\n    struct RedeemLocalVars {\n        uint exchangeRateMantissa;\n        uint redeemTokens;\n        uint redeemAmount;\n    }\n\n    /**\n     * @notice User redeems cTokens in exchange for the underlying asset\n     * @dev Assumes interest has already been accrued up to the current block\n     * @param redeemer The address of the account which is redeeming the tokens\n     * @param redeemTokensIn The number of cTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be non-zero)\n     * @param redeemAmountIn The number of underlying tokens to receive from redeeming cTokens (only one of redeemTokensIn or redeemAmountIn may be non-zero)\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n        // Make sure accountCollateralTokens of `redeemer` is initialized.\n        initializeAccountCollateralTokens(redeemer);\n\n        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n\n        RedeemLocalVars memory vars;\n\n        /* exchangeRate = invoke Exchange Rate Stored() */\n        vars.exchangeRateMantissa = exchangeRateStoredInternal();\n\n        /* If redeemTokensIn > 0: */\n        if (redeemTokensIn > 0) {\n            /*\n             * We calculate the exchange rate and the amount of underlying to be redeemed:\n             *  redeemTokens = redeemTokensIn\n             *  redeemAmount = redeemTokensIn x exchangeRateCurrent\n             */\n            vars.redeemTokens = redeemTokensIn;\n            vars.redeemAmount = mul_ScalarTruncate(Exp({mantissa: vars.exchangeRateMantissa}), redeemTokensIn);\n        } else {\n            /*\n             * We get the current exchange rate and calculate the amount to be redeemed:\n             *  redeemTokens = redeemAmountIn / exchangeRate\n             *  redeemAmount = redeemAmountIn\n             */\n            vars.redeemTokens = div_ScalarByExpTruncate(redeemAmountIn, Exp({mantissa: vars.exchangeRateMantissa}));\n            vars.redeemAmount = redeemAmountIn;\n        }\n\n        /**\n         * For every user, accountTokens must be greater than or equal to accountCollateralTokens.\n         * The buffer between the two values will be redeemed first.\n         * bufferTokens = accountTokens[redeemer] - accountCollateralTokens[redeemer]\n         * collateralTokens = redeemTokens - bufferTokens\n         */\n        uint bufferTokens = sub_(accountTokens[redeemer], accountCollateralTokens[redeemer]);\n        uint collateralTokens = 0;\n        if (vars.redeemTokens > bufferTokens) {\n            collateralTokens = sub_(vars.redeemTokens, bufferTokens);\n        }\n\n        /* Verify market's block number equals current block number */\n        if (accrualBlockNumber != getBlockNumber()) {\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);\n        }\n\n        /* Fail gracefully if protocol has insufficient cash */\n        if (getCashPrior() < vars.redeemAmount) {\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);\n        }\n\n        \n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        /*\n         * We invoke doTransferOut for the redeemer and the redeemAmount.\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n         *  On success, the cToken has redeemAmount less of cash.\n         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n         */\n        doTransferOut(redeemer, vars.redeemAmount);\n\n        /*\n         * We calculate the new total supply and redeemer balance, checking for underflow:\n         *  totalSupplyNew = totalSupply - redeemTokens\n         *  accountTokensNew = accountTokens[redeemer] - redeemTokens\n         */\n        totalSupply = sub_(totalSupply, vars.redeemTokens);\n        accountTokens[redeemer] = sub_(accountTokens[redeemer], vars.redeemTokens);\n\n        /*\n         * We only deallocate collateral tokens if the redeemer needs to redeem them.\n         */\n        if (collateralTokens > 0) {\n            decreaseUserCollateralInternal(redeemer, collateralTokens);\n        }\n\n        /* We emit a Transfer event, and a Redeem event */\n        emit Transfer(redeemer, address(this), vars.redeemTokens);\n        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);\n\n        /* We call the defense hook */\n        comptroller.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Transfers collateral tokens (this market) to the liquidator.\n     * @dev Called only during an in-kind liquidation, or by liquidateBorrow during the liquidation of another CToken.\n     *  Its absolutely critical to use msg.sender as the seizer cToken and not a parameter.\n     * @param seizerToken The contract seizing the collateral (i.e. borrowed cToken)\n     * @param liquidator The account receiving seized collateral\n     * @param borrower The account having collateral seized\n     * @param seizeTokens The number of cTokens to seize\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function seizeInternal(address seizerToken, address liquidator, address borrower, uint seizeTokens) internal returns (uint) {\n        // Make sure accountCollateralTokens of `liquidator` and `borrower` are initialized.\n        initializeAccountCollateralTokens(liquidator);\n        initializeAccountCollateralTokens(borrower);\n\n        /* Fail if seize not allowed */\n        uint allowed = comptroller.seizeAllowed(address(this), seizerToken, liquidator, borrower, seizeTokens);\n        if (allowed != 0) {\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_SEIZE_COMPTROLLER_REJECTION, allowed);\n        }\n\n        /* Fail if borrower = liquidator */\n        if (borrower == liquidator) {\n            return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER);\n        }\n\n        /*\n         * We calculate the new borrower and liquidator token balances and token collateral balances, failing on underflow/overflow:\n         *  accountTokens[borrower] = accountTokens[borrower] - seizeTokens\n         *  accountTokens[liquidator] = accountTokens[liquidator] + seizeTokens\n         *  accountCollateralTokens[borrower] = accountCollateralTokens[borrower] - seizeTokens\n         *  accountCollateralTokens[liquidator] = accountCollateralTokens[liquidator] + seizeTokens\n         */\n        accountTokens[borrower] = sub_(accountTokens[borrower], seizeTokens);\n        accountTokens[liquidator] = add_(accountTokens[liquidator], seizeTokens);\n        accountCollateralTokens[borrower] = sub_(accountCollateralTokens[borrower], seizeTokens);\n        accountCollateralTokens[liquidator] = add_(accountCollateralTokens[liquidator], seizeTokens);\n\n        /* Emit a Transfer, UserCollateralChanged events */\n        emit Transfer(borrower, liquidator, seizeTokens);\n        emit UserCollateralChanged(borrower, accountCollateralTokens[borrower]);\n        emit UserCollateralChanged(liquidator, accountCollateralTokens[liquidator]);\n\n        /* We call the defense hook */\n        // unused function\n        // comptroller.seizeVerify(address(this), seizerToken, liquidator, borrower, seizeTokens);\n\n        return uint(Error.NO_ERROR);\n    }\n}",
        "function": "accrueInterest()",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/QuillAudits-C.R.E.A.M. Finance-Compound Protocol/compound-protocol-23a4ae93adc70334553f5a83429a4e967c1eefaa/contracts/CCollateralCapErc20.sol",
        "vulnerability": "Dependence on predictable environment variable (SWC 120)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract CCollateralCapErc20 is CToken, CCollateralCapErc20Interface {\n    /**\n     * @notice Initialize the new money market\n     * @param underlying_ The address of the underlying asset\n     * @param comptroller_ The address of the Comptroller\n     * @param interestRateModel_ The address of the interest rate model\n     * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18\n     * @param name_ ERC-20 name of this token\n     * @param symbol_ ERC-20 symbol of this token\n     * @param decimals_ ERC-20 decimal precision of this token\n     */\n    function initialize(address underlying_,\n                        ComptrollerInterface comptroller_,\n                        InterestRateModel interestRateModel_,\n                        uint initialExchangeRateMantissa_,\n                        string memory name_,\n                        string memory symbol_,\n                        uint8 decimals_) public {\n        // CToken initialize does the bulk of the work\n        super.initialize(comptroller_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_);\n\n        // Set underlying and sanity check it\n        underlying = underlying_;\n        EIP20Interface(underlying).totalSupply();\n    }\n\n    /*** User Interface ***/\n\n    /**\n     * @notice Sender supplies assets into the market and receives cTokens in exchange\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param mintAmount The amount of the underlying asset to supply\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function mint(uint mintAmount) external returns (uint) {\n        (uint err,) = mintInternal(mintAmount);\n        return err;\n    }\n\n    /**\n     * @notice Sender redeems cTokens in exchange for the underlying asset\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param redeemTokens The number of cTokens to redeem into underlying\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function redeem(uint redeemTokens) external returns (uint) {\n        return redeemInternal(redeemTokens);\n    }\n\n    /**\n     * @notice Sender redeems cTokens in exchange for a specified amount of underlying asset\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param redeemAmount The amount of underlying to redeem\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function redeemUnderlying(uint redeemAmount) external returns (uint) {\n        return redeemUnderlyingInternal(redeemAmount);\n    }\n\n    /**\n      * @notice Sender borrows assets from the protocol to their own address\n      * @param borrowAmount The amount of the underlying asset to borrow\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n      */\n    function borrow(uint borrowAmount) external returns (uint) {\n        return borrowInternal(borrowAmount);\n    }\n\n    /**\n     * @notice Sender repays their own borrow\n     * @param repayAmount The amount to repay\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function repayBorrow(uint repayAmount) external returns (uint) {\n        (uint err,) = repayBorrowInternal(repayAmount);\n        return err;\n    }\n\n    /**\n     * @notice Sender repays a borrow belonging to borrower\n     * @param borrower the account with the debt being payed off\n     * @param repayAmount The amount to repay\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function repayBorrowBehalf(address borrower, uint repayAmount) external returns (uint) {\n        (uint err,) = repayBorrowBehalfInternal(borrower, repayAmount);\n        return err;\n    }\n\n    /**\n     * @notice The sender liquidates the borrowers collateral.\n     *  The collateral seized is transferred to the liquidator.\n     * @param borrower The borrower of this cToken to be liquidated\n     * @param repayAmount The amount of the underlying borrowed asset to repay\n     * @param cTokenCollateral The market in which to seize collateral from the borrower\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function liquidateBorrow(address borrower, uint repayAmount, CTokenInterface cTokenCollateral) external returns (uint) {\n        (uint err,) = liquidateBorrowInternal(borrower, repayAmount, cTokenCollateral);\n        return err;\n    }\n\n    /**\n     * @notice The sender adds to reserves.\n     * @param addAmount The amount fo underlying token to add as reserves\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _addReserves(uint addAmount) external returns (uint) {\n        return _addReservesInternal(addAmount);\n    }\n\n    /**\n     * @notice Set the given collateral cap for the market.\n     * @param newCollateralCap New collateral cap for this market. A value of 0 corresponds to no cap.\n     */\n    function _setCollateralCap(uint newCollateralCap) external {\n        require(msg.sender == admin, \"only admin can set collateral cap\");\n\n        collateralCap = newCollateralCap;\n        emit NewCollateralCap(address(this), newCollateralCap);\n    }\n\n    /**\n     * @notice Absorb excess cash into reserves.\n     */\n    function gulp() external nonReentrant {\n        uint256 cashOnChain = getCashOnChain();\n        uint256 cashPrior = getCashPrior();\n\n        uint excessCash = sub_(cashOnChain, cashPrior);\n        totalReserves = add_(totalReserves, excessCash);\n        internalCash = cashOnChain;\n    }\n\n    /**\n     * @notice Flash loan funds to a given account.\n     * @param receiver The receiver address for the funds\n     * @param amount The amount of the funds to be loaned\n     * @param params The other parameters\n     */\n    function flashLoan(address receiver, uint amount, bytes calldata params) external nonReentrant {\n        uint cashOnChainBefore = getCashOnChain();\n        uint cashBefore = getCashPrior();\n        require(cashBefore >= amount, \"INSUFFICIENT_LIQUIDITY\");\n\n        // 1. calculate fee, 1 bips = 1/10000\n        uint totalFee = div_(mul_(amount, flashFeeBips), 10000);\n\n        // 2. transfer fund to receiver\n        doTransferOut(address(uint160(receiver)), amount);\n\n        // 3. execute receiver's callback function\n        IFlashloanReceiver(receiver).executeOperation(msg.sender, underlying, amount, totalFee, params);\n\n        // 4. check balance\n        uint cashOnChainAfter = getCashOnChain();\n        require(cashOnChainAfter == add_(cashOnChainBefore, totalFee), \"BALANCE_INCONSISTENT\");\n\n        // 5. update reserves and internal cash\n        uint reservesFee = mul_ScalarTruncate(Exp({mantissa: reserveFactorMantissa}), totalFee);\n        totalReserves = add_(totalReserves, reservesFee);\n        internalCash = add_(cashBefore, totalFee);\n\n        emit Flashloan(receiver, amount, totalFee, reservesFee);\n    }\n\n    /**\n     * @notice Register account collateral tokens if there is space.\n     * @param account The account to register\n     * @dev This function could only be called by comptroller.\n     * @return The actual registered amount of collateral\n     */\n    function registerCollateral(address account) external returns (uint) {\n        // Make sure accountCollateralTokens of `account` is initialized.\n        initializeAccountCollateralTokens(account);\n\n        require(msg.sender == address(comptroller), \"only comptroller may register collateral for user\");\n\n        uint amount = sub_(accountTokens[account], accountCollateralTokens[account]);\n        return increaseUserCollateralInternal(account, amount);\n    }\n\n    /**\n     * @notice Unregister account collateral tokens if the account still has enough collateral.\n     * @dev This function could only be called by comptroller.\n     * @param account The account to unregister\n     */\n    function unregisterCollateral(address account) external {\n        // Make sure accountCollateralTokens of `account` is initialized.\n        initializeAccountCollateralTokens(account);\n\n        require(msg.sender == address(comptroller), \"only comptroller may unregister collateral for user\");\n\n        decreaseUserCollateralInternal(account, accountCollateralTokens[account]);\n    }\n\n    /*** Safe Token ***/\n\n    /**\n     * @notice Gets internal balance of this contract in terms of the underlying.\n     *  It excludes balance from direct transfer.\n     * @dev This excludes the value of the current message, if any\n     * @return The quantity of underlying tokens owned by this contract\n     */\n    function getCashPrior() internal view returns (uint) {\n        return internalCash;\n    }\n\n    /**\n     * @notice Gets total balance of this contract in terms of the underlying\n     * @dev This excludes the value of the current message, if any\n     * @return The quantity of underlying tokens owned by this contract\n     */\n    function getCashOnChain() internal view returns (uint) {\n        EIP20Interface token = EIP20Interface(underlying);\n        return token.balanceOf(address(this));\n    }\n\n    /**\n     * @notice Initialize the account's collateral tokens. This function should be called in the beginning of every function\n     *  that accesses accountCollateralTokens or accountTokens.\n     * @param account The account of accountCollateralTokens that needs to be updated\n     */\n    function initializeAccountCollateralTokens(address account) internal {\n        /**\n         * If isCollateralTokenInit is false, it means accountCollateralTokens was not initialized yet.\n         * This case will only happen once and must be the very beginning. accountCollateralTokens is a new structure and its\n         * initial value should be equal to accountTokens if user has entered the market. However, it's almost impossible to\n         * check every user's value when the implementation becomes active. Therefore, it must rely on every action which will\n         * access accountTokens to call this function to check if accountCollateralTokens needed to be initialized.\n         */\n        if (!isCollateralTokenInit[account]) {\n            if (ComptrollerInterfaceExtension(address(comptroller)).checkMembership(account, CToken(this))) {\n                accountCollateralTokens[account] = accountTokens[account];\n                totalCollateralTokens = add_(totalCollateralTokens, accountTokens[account]);\n\n                emit UserCollateralChanged(account, accountCollateralTokens[account]);\n            }\n            isCollateralTokenInit[account] = true;\n        }\n    }\n\n    /**\n     * @dev Similar to EIP20 transfer, except it handles a False result from `transferFrom` and reverts in that case.\n     *      This will revert due to insufficient balance or insufficient allowance.\n     *      This function returns the actual amount received,\n     *      which may be less than `amount` if there is a fee attached to the transfer.\n     *\n     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.\n     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\n     */\n    function doTransferIn(address from, uint amount) internal returns (uint) {\n        EIP20NonStandardInterface token = EIP20NonStandardInterface(underlying);\n        uint balanceBefore = EIP20Interface(underlying).balanceOf(address(this));\n        token.transferFrom(from, address(this), amount);\n\n        bool success;\n        assembly {\n            switch returndatasize()\n                case 0 {                       // This is a non-standard ERC-20\n                    success := not(0)          // set success to true\n                }\n                case 32 {                      // This is a compliant ERC-20\n                    returndatacopy(0, 0, 32)\n                    success := mload(0)        // Set `success = returndata` of external call\n                }\n                default {                      // This is an excessively non-compliant ERC-20, revert.\n                    revert(0, 0)\n                }\n        }\n        require(success, \"TOKEN_TRANSFER_IN_FAILED\");\n\n        // Calculate the amount that was *actually* transferred\n        uint balanceAfter = EIP20Interface(underlying).balanceOf(address(this));\n        uint transferredIn = sub_(balanceAfter, balanceBefore);\n        internalCash = add_(internalCash, transferredIn);\n        return transferredIn;\n    }\n\n    /**\n     * @dev Similar to EIP20 transfer, except it handles a False success from `transfer` and returns an explanatory\n     *      error code rather than reverting. If caller has not called checked protocol's balance, this may revert due to\n     *      insufficient cash held in this contract. If caller has checked protocol's balance prior to this call, and verified\n     *      it is >= amount, this should not revert in normal conditions.\n     *\n     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.\n     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\n     */\n    function doTransferOut(address payable to, uint amount) internal {\n        EIP20NonStandardInterface token = EIP20NonStandardInterface(underlying);\n        token.transfer(to, amount);\n\n        bool success;\n        assembly {\n            switch returndatasize()\n                case 0 {                      // This is a non-standard ERC-20\n                    success := not(0)          // set success to true\n                }\n                case 32 {                     // This is a complaint ERC-20\n                    returndatacopy(0, 0, 32)\n                    success := mload(0)        // Set `success = returndata` of external call\n                }\n                default {                     // This is an excessively non-compliant ERC-20, revert.\n                    revert(0, 0)\n                }\n        }\n        require(success, \"TOKEN_TRANSFER_OUT_FAILED\");\n        internalCash = sub_(internalCash, amount);\n    }\n\n    /**\n     * @notice Transfer `tokens` tokens from `src` to `dst` by `spender`\n     * @dev Called by both `transfer` and `transferFrom` internally\n     * @param spender The address of the account performing the transfer\n     * @param src The address of the source account\n     * @param dst The address of the destination account\n     * @param tokens The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     */\n    function transferTokens(address spender, address src, address dst, uint tokens) internal returns (uint) {\n        // Make sure accountCollateralTokens of `src` and `dst` are initialized.\n        initializeAccountCollateralTokens(src);\n        initializeAccountCollateralTokens(dst);\n\n        /**\n         * For every user, accountTokens must be greater than or equal to accountCollateralTokens.\n         * The buffer between the two values will be transferred first.\n         * bufferTokens = accountTokens[src] - accountCollateralTokens[src]\n         * collateralTokens = tokens - bufferTokens\n         */\n        uint bufferTokens = sub_(accountTokens[src], accountCollateralTokens[src]);\n        uint collateralTokens = 0;\n        if (tokens > bufferTokens) {\n            collateralTokens = sub_(tokens, bufferTokens);\n        }\n\n        /**\n         * Since bufferTokens are not collateralized and can be transferred freely, we only check with comptroller\n         * whether collateralized tokens can be transferred.\n         */\n        uint allowed = comptroller.transferAllowed(address(this), src, dst, collateralTokens);\n        if (allowed != 0) {\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.TRANSFER_COMPTROLLER_REJECTION, allowed);\n        }\n\n        /* Do not allow self-transfers */\n        if (src == dst) {\n            return fail(Error.BAD_INPUT, FailureInfo.TRANSFER_NOT_ALLOWED);\n        }\n\n        /* Get the allowance, infinite for the account owner */\n        uint startingAllowance = 0;\n        if (spender == src) {\n            startingAllowance = uint(-1);\n        } else {\n            startingAllowance = transferAllowances[src][spender];\n        }\n\n        /* Do the calculations, checking for {under,over}flow */\n        uint allowanceNew = sub_(startingAllowance, tokens);\n        accountTokens[src] = sub_(accountTokens[src], tokens);\n        accountTokens[dst] = add_(accountTokens[dst], tokens);\n        if (collateralTokens > 0) {\n            accountCollateralTokens[src] = sub_(accountCollateralTokens[src], collateralTokens);\n            accountCollateralTokens[dst] = add_(accountCollateralTokens[dst], collateralTokens);\n\n            emit UserCollateralChanged(src, accountCollateralTokens[src]);\n            emit UserCollateralChanged(dst, accountCollateralTokens[dst]);\n        }\n\n        /* Eat some of the allowance (if necessary) */\n        if (startingAllowance != uint(-1)) {\n            transferAllowances[src][spender] = allowanceNew;\n        }\n\n        /* We emit a Transfer event */\n        emit Transfer(src, dst, tokens);\n\n        // unused function\n        // comptroller.transferVerify(address(this), src, dst, tokens);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Get the account's cToken balances\n     * @param account The address of the account\n     */\n    //  SWC-135-Code With No Effects: L410\n    function getCTokenBalanceInternal(address account) internal view returns (uint) {\n        if (isCollateralTokenInit[account]) {\n            return accountCollateralTokens[account];\n        } else {\n            /**\n             * If the value of accountCollateralTokens was not initialized, we should return the value of accountTokens.\n             */\n            return accountTokens[account];\n        }\n    }\n\n    /**\n     * @notice Increase user's collateral. Increase as much as we can.\n     * @param account The address of the account\n     * @param amount The amount of collateral user wants to increase\n     * @return The actual increased amount of collateral\n     */\n    function increaseUserCollateralInternal(address account, uint amount) internal returns (uint) {\n        uint totalCollateralTokensNew = add_(totalCollateralTokens, amount);\n        if (collateralCap == 0 || (collateralCap != 0 && totalCollateralTokensNew <= collateralCap)) {\n            // 1. If collateral cap is not set,\n            // 2. If collateral cap is set but has enough space for this user,\n            // give all the user needs.\n            totalCollateralTokens = totalCollateralTokensNew;\n            accountCollateralTokens[account] = add_(accountCollateralTokens[account], amount);\n\n            emit UserCollateralChanged(account, accountCollateralTokens[account]);\n            return amount;\n        } else if (collateralCap > totalCollateralTokens) {\n            // If the collateral cap is set but the remaining cap is not enough for this user,\n            // give the remaining parts to the user.\n            uint gap = sub_(collateralCap, totalCollateralTokens);\n            totalCollateralTokens = add_(totalCollateralTokens, gap);\n            accountCollateralTokens[account] = add_(accountCollateralTokens[account], gap);\n\n            emit UserCollateralChanged(account, accountCollateralTokens[account]);\n            return gap;\n        }\n        return 0;\n    }\n\n    /**\n     * @notice Decrease user's collateral. Reject if the amount can't be fully decrease.\n     * @param account The address of the account\n     * @param amount The amount of collateral user wants to decrease\n     */\n    function decreaseUserCollateralInternal(address account, uint amount) internal {\n        require(comptroller.redeemAllowed(address(this), account, amount) == 0, \"comptroller rejection\");\n\n        totalCollateralTokens = sub_(totalCollateralTokens, amount);\n        accountCollateralTokens[account] = sub_(accountCollateralTokens[account], amount);\n\n        emit UserCollateralChanged(account, accountCollateralTokens[account]);\n    }\n\n    struct MintLocalVars {\n        uint exchangeRateMantissa;\n        uint mintTokens;\n        uint actualMintAmount;\n    }\n\n    /**\n     * @notice User supplies assets into the market and receives cTokens in exchange\n     * @dev Assumes interest has already been accrued up to the current block\n     * @param minter The address of the account which is supplying the assets\n     * @param mintAmount The amount of the underlying asset to supply\n     * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual mint amount.\n     */\n    function mintFresh(address minter, uint mintAmount) internal returns (uint, uint) {\n        // Make sure accountCollateralTokens of `minter` is initialized.\n        initializeAccountCollateralTokens(minter);\n\n        /* Fail if mint not allowed */\n        uint allowed = comptroller.mintAllowed(address(this), minter, mintAmount);\n        if (allowed != 0) {\n            return (failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.MINT_COMPTROLLER_REJECTION, allowed), 0);\n        }\n\n        /* Verify market's block number equals current block number */\n        if (accrualBlockNumber != getBlockNumber()) {\n            return (fail(Error.MARKET_NOT_FRESH, FailureInfo.MINT_FRESHNESS_CHECK), 0);\n        }\n\n        MintLocalVars memory vars;\n\n        vars.exchangeRateMantissa = exchangeRateStoredInternal();\n\n        \n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        /*\n         *  We call `doTransferIn` for the minter and the mintAmount.\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n         *  `doTransferIn` reverts if anything goes wrong, since we can't be sure if\n         *  side-effects occurred. The function returns the amount actually transferred,\n         *  in case of a fee. On success, the cToken holds an additional `actualMintAmount`\n         *  of cash.\n         */\n        vars.actualMintAmount = doTransferIn(minter, mintAmount);\n\n        /*\n         * We get the current exchange rate and calculate the number of cTokens to be minted:\n         *  mintTokens = actualMintAmount / exchangeRate\n         */\n        vars.mintTokens = div_ScalarByExpTruncate(vars.actualMintAmount, Exp({mantissa: vars.exchangeRateMantissa}));\n\n        /*\n         * We calculate the new total supply of cTokens and minter token balance, checking for overflow:\n         *  totalSupply = totalSupply + mintTokens\n         *  accountTokens[minter] = accountTokens[minter] + mintTokens\n         */\n        totalSupply = add_(totalSupply, vars.mintTokens);\n        accountTokens[minter] = add_(accountTokens[minter], vars.mintTokens);\n\n        /*\n         * We only allocate collateral tokens if the minter has entered the market.\n         */\n        if (ComptrollerInterfaceExtension(address(comptroller)).checkMembership(minter, CToken(this))) {\n            increaseUserCollateralInternal(minter, vars.mintTokens);\n        }\n\n        /* We emit a Mint event, and a Transfer event */\n        emit Mint(minter, vars.actualMintAmount, vars.mintTokens);\n        emit Transfer(address(this), minter, vars.mintTokens);\n\n        /* We call the defense hook */\n        // unused function\n        // comptroller.mintVerify(address(this), minter, vars.actualMintAmount, vars.mintTokens);\n\n        return (uint(Error.NO_ERROR), vars.actualMintAmount);\n    }\n\n    struct RedeemLocalVars {\n        uint exchangeRateMantissa;\n        uint redeemTokens;\n        uint redeemAmount;\n    }\n\n    /**\n     * @notice User redeems cTokens in exchange for the underlying asset\n     * @dev Assumes interest has already been accrued up to the current block\n     * @param redeemer The address of the account which is redeeming the tokens\n     * @param redeemTokensIn The number of cTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be non-zero)\n     * @param redeemAmountIn The number of underlying tokens to receive from redeeming cTokens (only one of redeemTokensIn or redeemAmountIn may be non-zero)\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n        // Make sure accountCollateralTokens of `redeemer` is initialized.\n        initializeAccountCollateralTokens(redeemer);\n\n        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n\n        RedeemLocalVars memory vars;\n\n        /* exchangeRate = invoke Exchange Rate Stored() */\n        vars.exchangeRateMantissa = exchangeRateStoredInternal();\n\n        /* If redeemTokensIn > 0: */\n        if (redeemTokensIn > 0) {\n            /*\n             * We calculate the exchange rate and the amount of underlying to be redeemed:\n             *  redeemTokens = redeemTokensIn\n             *  redeemAmount = redeemTokensIn x exchangeRateCurrent\n             */\n            vars.redeemTokens = redeemTokensIn;\n            vars.redeemAmount = mul_ScalarTruncate(Exp({mantissa: vars.exchangeRateMantissa}), redeemTokensIn);\n        } else {\n            /*\n             * We get the current exchange rate and calculate the amount to be redeemed:\n             *  redeemTokens = redeemAmountIn / exchangeRate\n             *  redeemAmount = redeemAmountIn\n             */\n            vars.redeemTokens = div_ScalarByExpTruncate(redeemAmountIn, Exp({mantissa: vars.exchangeRateMantissa}));\n            vars.redeemAmount = redeemAmountIn;\n        }\n\n        /**\n         * For every user, accountTokens must be greater than or equal to accountCollateralTokens.\n         * The buffer between the two values will be redeemed first.\n         * bufferTokens = accountTokens[redeemer] - accountCollateralTokens[redeemer]\n         * collateralTokens = redeemTokens - bufferTokens\n         */\n        uint bufferTokens = sub_(accountTokens[redeemer], accountCollateralTokens[redeemer]);\n        uint collateralTokens = 0;\n        if (vars.redeemTokens > bufferTokens) {\n            collateralTokens = sub_(vars.redeemTokens, bufferTokens);\n        }\n\n        /* Verify market's block number equals current block number */\n        if (accrualBlockNumber != getBlockNumber()) {\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);\n        }\n\n        /* Fail gracefully if protocol has insufficient cash */\n        if (getCashPrior() < vars.redeemAmount) {\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);\n        }\n\n        \n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        /*\n         * We invoke doTransferOut for the redeemer and the redeemAmount.\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n         *  On success, the cToken has redeemAmount less of cash.\n         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n         */\n        doTransferOut(redeemer, vars.redeemAmount);\n\n        /*\n         * We calculate the new total supply and redeemer balance, checking for underflow:\n         *  totalSupplyNew = totalSupply - redeemTokens\n         *  accountTokensNew = accountTokens[redeemer] - redeemTokens\n         */\n        totalSupply = sub_(totalSupply, vars.redeemTokens);\n        accountTokens[redeemer] = sub_(accountTokens[redeemer], vars.redeemTokens);\n\n        /*\n         * We only deallocate collateral tokens if the redeemer needs to redeem them.\n         */\n        if (collateralTokens > 0) {\n            decreaseUserCollateralInternal(redeemer, collateralTokens);\n        }\n\n        /* We emit a Transfer event, and a Redeem event */\n        emit Transfer(redeemer, address(this), vars.redeemTokens);\n        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);\n\n        /* We call the defense hook */\n        comptroller.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Transfers collateral tokens (this market) to the liquidator.\n     * @dev Called only during an in-kind liquidation, or by liquidateBorrow during the liquidation of another CToken.\n     *  Its absolutely critical to use msg.sender as the seizer cToken and not a parameter.\n     * @param seizerToken The contract seizing the collateral (i.e. borrowed cToken)\n     * @param liquidator The account receiving seized collateral\n     * @param borrower The account having collateral seized\n     * @param seizeTokens The number of cTokens to seize\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function seizeInternal(address seizerToken, address liquidator, address borrower, uint seizeTokens) internal returns (uint) {\n        // Make sure accountCollateralTokens of `liquidator` and `borrower` are initialized.\n        initializeAccountCollateralTokens(liquidator);\n        initializeAccountCollateralTokens(borrower);\n\n        /* Fail if seize not allowed */\n        uint allowed = comptroller.seizeAllowed(address(this), seizerToken, liquidator, borrower, seizeTokens);\n        if (allowed != 0) {\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_SEIZE_COMPTROLLER_REJECTION, allowed);\n        }\n\n        /* Fail if borrower = liquidator */\n        if (borrower == liquidator) {\n            return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER);\n        }\n\n        /*\n         * We calculate the new borrower and liquidator token balances and token collateral balances, failing on underflow/overflow:\n         *  accountTokens[borrower] = accountTokens[borrower] - seizeTokens\n         *  accountTokens[liquidator] = accountTokens[liquidator] + seizeTokens\n         *  accountCollateralTokens[borrower] = accountCollateralTokens[borrower] - seizeTokens\n         *  accountCollateralTokens[liquidator] = accountCollateralTokens[liquidator] + seizeTokens\n         */\n        accountTokens[borrower] = sub_(accountTokens[borrower], seizeTokens);\n        accountTokens[liquidator] = add_(accountTokens[liquidator], seizeTokens);\n        accountCollateralTokens[borrower] = sub_(accountCollateralTokens[borrower], seizeTokens);\n        accountCollateralTokens[liquidator] = add_(accountCollateralTokens[liquidator], seizeTokens);\n\n        /* Emit a Transfer, UserCollateralChanged events */\n        emit Transfer(borrower, liquidator, seizeTokens);\n        emit UserCollateralChanged(borrower, accountCollateralTokens[borrower]);\n        emit UserCollateralChanged(liquidator, accountCollateralTokens[liquidator]);\n\n        /* We call the defense hook */\n        // unused function\n        // comptroller.seizeVerify(address(this), seizerToken, liquidator, borrower, seizeTokens);\n\n        return uint(Error.NO_ERROR);\n    }\n}",
        "function": "accrueInterest()",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/QuillAudits-C.R.E.A.M. Finance-Compound Protocol/compound-protocol-23a4ae93adc70334553f5a83429a4e967c1eefaa/contracts/CCollateralCapErc20.sol",
        "vulnerability": "Dependence on predictable environment variable (SWC 120)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract TxPermission is UpgradeableOwned, ITxPermission {\n\n    // =============================================== Storage ========================================================\n\n    // WARNING: since this contract is upgradeable, do not remove\n    // existing storage variables, do not change their order,\n    // and do not change their types!\n\n    address[] internal _allowedSenders;\n\n    \n    ICertifier public certifierContract;\n\n    \n    \n    \n    mapping(address => bool) public isSenderAllowed;\n\n    \n    IValidatorSetAuRa public validatorSetContract;\n\n    mapping(address => uint256) internal _deployerInputLengthLimit;\n\n    \n    \n    mapping(address => uint256) public senderMinGasPrice;\n\n    // ============================================== Constants =======================================================\n\n    \n    \n    uint256 public constant BLOCK_GAS_LIMIT = 12500000;\n\n    \n    \n    uint256 public constant BLOCK_GAS_LIMIT_REDUCED = 4000000;\n\n    // ================================================ Events ========================================================\n\n    \n    \n    \n    event DeployerInputLengthLimitSet(address indexed deployer, uint256 limit);\n\n    \n    \n    \n    event SenderMinGasPriceSet(address indexed sender, uint256 minGasPrice);\n\n    // ============================================== Modifiers =======================================================\n\n    \n    modifier onlyInitialized {\n        require(isInitialized());\n        _;\n    }\n\n    // =============================================== Setters ========================================================\n\n    \n    \n    \n    \n    \n    \n    \n    function initialize(\n        address[] calldata _allowed,\n        address _certifier,\n        address _validatorSet\n    ) external {\n        require(block.number == 0 || msg.sender == _admin());\n        require(!isInitialized());\n        require(_certifier != address(0));\n        require(_validatorSet != address(0));\n        for (uint256 i = 0; i < _allowed.length; i++) {\n            _addAllowedSender(_allowed[i]);\n        }\n        certifierContract = ICertifier(_certifier);\n        validatorSetContract = IValidatorSetAuRa(_validatorSet);\n    }\n\n    \n    \n    \n    function addAllowedSender(address _sender) public onlyOwner onlyInitialized {\n        _addAllowedSender(_sender);\n    }\n\n    \n    \n    \n    \n    function removeAllowedSender(address _sender) public onlyOwner onlyInitialized {\n        require(isSenderAllowed[_sender]);\n\n        uint256 allowedSendersLength = _allowedSenders.length;\n\n        for (uint256 i = 0; i < allowedSendersLength; i++) {\n            if (_sender == _allowedSenders[i]) {\n                _allowedSenders[i] = _allowedSenders[allowedSendersLength - 1];\n                _allowedSenders.length--;\n                break;\n            }\n        }\n\n        isSenderAllowed[_sender] = false;\n    }\n\n    \n    \n    \n    \n    \n    function setDeployerInputLengthLimit(address _deployer, uint256 _limit) public onlyOwner onlyInitialized {\n        _deployerInputLengthLimit[_deployer] = _limit;\n        emit DeployerInputLengthLimitSet(_deployer, _limit);\n    }\n\n    \n    \n    \n    function setSenderMinGasPrice(address _sender, uint256 _minGasPrice) public onlyOwner onlyInitialized {\n        senderMinGasPrice[_sender] = _minGasPrice;\n        emit SenderMinGasPriceSet(_sender, _minGasPrice);\n    }\n\n    // =============================================== Getters ========================================================\n\n    \n    function contractName() public pure returns(string memory) {\n        return \"TX_PERMISSION_CONTRACT\";\n    }\n\n    \n    function contractNameHash() public pure returns(bytes32) {\n        return keccak256(abi.encodePacked(contractName()));\n    }\n\n    \n    function contractVersion() public pure returns(uint256) {\n        return 3;\n    }\n\n    \n    \n    \n    function allowedSenders() public view returns(address[] memory) {\n        return _allowedSenders;\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    function allowedTxTypes(\n        address _sender,\n        address _to,\n        uint256 _value, // SWC-131-Presence of unused variables: L184\n        uint256 _gasPrice,\n        bytes memory _data\n    )\n        public\n        view\n        returns(uint32 typesMask, bool cache)\n    {\n        if (isSenderAllowed[_sender]) {\n            // Let the `_sender` initiate any transaction if the `_sender` is in the `allowedSenders` list\n            return (ALL, false);\n        }\n\n        if (_to == address(0) && _data.length > deployerInputLengthLimit(_sender)) {\n            // Don't let to deploy too big contracts\n            return (NONE, false);\n        }\n\n        // Get the called function's signature\n        bytes4 signature = bytes4(0);\n        assembly {\n            signature := shl(224, mload(add(_data, 4)))\n        }\n\n        if (_to == validatorSetContract.randomContract()) {\n            if (signature == COMMIT_HASH_SIGNATURE && _data.length > 4+32) {\n                bytes32 numberHash;\n                assembly { numberHash := mload(add(_data, 36)) }\n                return (IRandomAuRa(_to).commitHashCallable(_sender, numberHash) ? CALL : NONE, false);\n            } else if (\n                (signature == REVEAL_NUMBER_SIGNATURE || signature == REVEAL_SECRET_SIGNATURE) &&\n                _data.length == 4+32\n            ) {\n                uint256 num;\n                assembly { num := mload(add(_data, 36)) }\n                return (IRandomAuRa(_to).revealNumberCallable(_sender, num) ? CALL : NONE, false);\n            } else {\n                return (NONE, false);\n            }\n        }\n\n        if (_to == address(validatorSetContract)) {\n            // The rules for the ValidatorSetAuRa contract\n            if (signature == EMIT_INITIATE_CHANGE_SIGNATURE) {\n                // The `emitInitiateChange()` can be called by anyone\n                // if `emitInitiateChangeCallable()` returns `true`\n                return (validatorSetContract.emitInitiateChangeCallable() ? CALL : NONE, false);\n            } else if (signature == REPORT_MALICIOUS_SIGNATURE && _data.length >= 4+64) {\n                address maliciousMiningAddress;\n                uint256 blockNumber;\n                assembly {\n                    maliciousMiningAddress := mload(add(_data, 36))\n                    blockNumber := mload(add(_data, 68))\n                }\n                // The `reportMalicious()` can only be called by the validator's mining address\n                // when the calling is allowed\n                (bool callable,) = validatorSetContract.reportMaliciousCallable(\n                    _sender, maliciousMiningAddress, blockNumber\n                );\n\n                return (callable ? CALL : NONE, false);\n            } else if (_gasPrice > 0) {\n                // The other functions of ValidatorSetAuRa contract can be called\n                // by anyone except validators' mining addresses if gasPrice is not zero\n                return (validatorSetContract.isValidator(_sender) ? NONE : CALL, false);\n            }\n        }\n\n        if (validatorSetContract.isValidator(_sender) && _gasPrice > 0) {\n            // Let the validator's mining address send their accumulated tx fees to some wallet\n            return (_sender.balance > 0 ? BASIC : NONE, false);\n        }\n\n        if (validatorSetContract.isValidator(_to)) {\n            // Validator's mining address can't receive any coins\n            return (NONE, false);\n        }\n\n        // Don't let the `_sender` use a zero gas price, if it is not explicitly allowed by the `Certifier` contract\n        if (_gasPrice == 0) {\n            return (certifierContract.certifiedExplicitly(_sender) ? ALL : NONE, false);\n        }\n\n        // Disallow invalid gas price for the specified sender\n        if (_gasPrice < senderMinGasPrice[_sender]) {\n            return (NONE, false);\n        }\n\n        // In other cases let the `_sender` create any transaction with non-zero gas price\n        return (ALL, false);\n    }\n\n    \n    \n    function blockGasLimit() public view returns(uint256) {\n        address stakingContract = validatorSetContract.stakingContract();\n        uint256 stakingEpochEndBlock = IStakingAuRa(stakingContract).stakingEpochEndBlock();\n        if (block.number == stakingEpochEndBlock - 1 || block.number == stakingEpochEndBlock) {\n            return BLOCK_GAS_LIMIT_REDUCED;\n        }\n        return BLOCK_GAS_LIMIT;\n    }\n\n    \n    \n    \n    function deployerInputLengthLimit(address _deployer) public view returns(uint256) {\n        uint256 limit = _deployerInputLengthLimit[_deployer];\n\n        if (limit != 0) {\n            return limit;\n        } else {\n            return 30720; // default EIP 170 limit (24 Kb + overhead)\n        }\n    }\n\n    \n    function isInitialized() public view returns(bool) {\n        return validatorSetContract != IValidatorSetAuRa(0);\n    }\n\n    // ============================================== Internal ========================================================\n\n    // Allowed transaction types mask\n    uint32 internal constant NONE = 0;\n    uint32 internal constant ALL = 0xffffffff;\n    uint32 internal constant BASIC = 0x01;\n    uint32 internal constant CALL = 0x02;\n    // SWC-131-Presence of unused variables: L313-314s\n    uint32 internal constant CREATE = 0x04;\n    uint32 internal constant PRIVATE = 0x08;\n\n    // Function signatures\n\n    // bytes4(keccak256(\"commitHash(bytes32,bytes)\"))\n    bytes4 internal constant COMMIT_HASH_SIGNATURE = 0x0b61ba85; \n\n    // bytes4(keccak256(\"emitInitiateChange()\"))\n    bytes4 internal constant EMIT_INITIATE_CHANGE_SIGNATURE = 0x93b4e25e;\n\n    // bytes4(keccak256(\"reportMalicious(address,uint256,bytes)\"))\n    bytes4 internal constant REPORT_MALICIOUS_SIGNATURE = 0xc476dd40;\n\n    // bytes4(keccak256(\"revealSecret(uint256)\"))\n    bytes4 internal constant REVEAL_SECRET_SIGNATURE = 0x98df67c6;\n\n    // bytes4(keccak256(\"revealNumber(uint256)\"))\n    bytes4 internal constant REVEAL_NUMBER_SIGNATURE = 0xfe7d567d;\n\n    \n    \n    function _addAllowedSender(address _sender) internal {\n        require(!isSenderAllowed[_sender]);\n        require(_sender != address(0));\n        _allowedSenders.push(_sender);\n        isSenderAllowed[_sender] = true;\n    }\n}",
        "function": "initialize(address[],address,address)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Hacken-Etherlite/pos-contracts-e56317bd80a0368a1d9106361c188b589a419b94/contracts/TxPermission.sol",
        "vulnerability": "Dependence on predictable environment variable (SWC 120)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract TxPermission is UpgradeableOwned, ITxPermission {\n\n    // =============================================== Storage ========================================================\n\n    // WARNING: since this contract is upgradeable, do not remove\n    // existing storage variables, do not change their order,\n    // and do not change their types!\n\n    address[] internal _allowedSenders;\n\n    \n    ICertifier public certifierContract;\n\n    \n    \n    \n    mapping(address => bool) public isSenderAllowed;\n\n    \n    IValidatorSetAuRa public validatorSetContract;\n\n    mapping(address => uint256) internal _deployerInputLengthLimit;\n\n    \n    \n    mapping(address => uint256) public senderMinGasPrice;\n\n    // ============================================== Constants =======================================================\n\n    \n    \n    uint256 public constant BLOCK_GAS_LIMIT = 12500000;\n\n    \n    \n    uint256 public constant BLOCK_GAS_LIMIT_REDUCED = 4000000;\n\n    // ================================================ Events ========================================================\n\n    \n    \n    \n    event DeployerInputLengthLimitSet(address indexed deployer, uint256 limit);\n\n    \n    \n    \n    event SenderMinGasPriceSet(address indexed sender, uint256 minGasPrice);\n\n    // ============================================== Modifiers =======================================================\n\n    \n    modifier onlyInitialized {\n        require(isInitialized());\n        _;\n    }\n\n    // =============================================== Setters ========================================================\n\n    \n    \n    \n    \n    \n    \n    \n    function initialize(\n        address[] calldata _allowed,\n        address _certifier,\n        address _validatorSet\n    ) external {\n        require(block.number == 0 || msg.sender == _admin());\n        require(!isInitialized());\n        require(_certifier != address(0));\n        require(_validatorSet != address(0));\n        for (uint256 i = 0; i < _allowed.length; i++) {\n            _addAllowedSender(_allowed[i]);\n        }\n        certifierContract = ICertifier(_certifier);\n        validatorSetContract = IValidatorSetAuRa(_validatorSet);\n    }\n\n    \n    \n    \n    function addAllowedSender(address _sender) public onlyOwner onlyInitialized {\n        _addAllowedSender(_sender);\n    }\n\n    \n    \n    \n    \n    function removeAllowedSender(address _sender) public onlyOwner onlyInitialized {\n        require(isSenderAllowed[_sender]);\n\n        uint256 allowedSendersLength = _allowedSenders.length;\n\n        for (uint256 i = 0; i < allowedSendersLength; i++) {\n            if (_sender == _allowedSenders[i]) {\n                _allowedSenders[i] = _allowedSenders[allowedSendersLength - 1];\n                _allowedSenders.length--;\n                break;\n            }\n        }\n\n        isSenderAllowed[_sender] = false;\n    }\n\n    \n    \n    \n    \n    \n    function setDeployerInputLengthLimit(address _deployer, uint256 _limit) public onlyOwner onlyInitialized {\n        _deployerInputLengthLimit[_deployer] = _limit;\n        emit DeployerInputLengthLimitSet(_deployer, _limit);\n    }\n\n    \n    \n    \n    function setSenderMinGasPrice(address _sender, uint256 _minGasPrice) public onlyOwner onlyInitialized {\n        senderMinGasPrice[_sender] = _minGasPrice;\n        emit SenderMinGasPriceSet(_sender, _minGasPrice);\n    }\n\n    // =============================================== Getters ========================================================\n\n    \n    function contractName() public pure returns(string memory) {\n        return \"TX_PERMISSION_CONTRACT\";\n    }\n\n    \n    function contractNameHash() public pure returns(bytes32) {\n        return keccak256(abi.encodePacked(contractName()));\n    }\n\n    \n    function contractVersion() public pure returns(uint256) {\n        return 3;\n    }\n\n    \n    \n    \n    function allowedSenders() public view returns(address[] memory) {\n        return _allowedSenders;\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    function allowedTxTypes(\n        address _sender,\n        address _to,\n        uint256 _value, // SWC-131-Presence of unused variables: L184\n        uint256 _gasPrice,\n        bytes memory _data\n    )\n        public\n        view\n        returns(uint32 typesMask, bool cache)\n    {\n        if (isSenderAllowed[_sender]) {\n            // Let the `_sender` initiate any transaction if the `_sender` is in the `allowedSenders` list\n            return (ALL, false);\n        }\n\n        if (_to == address(0) && _data.length > deployerInputLengthLimit(_sender)) {\n            // Don't let to deploy too big contracts\n            return (NONE, false);\n        }\n\n        // Get the called function's signature\n        bytes4 signature = bytes4(0);\n        assembly {\n            signature := shl(224, mload(add(_data, 4)))\n        }\n\n        if (_to == validatorSetContract.randomContract()) {\n            if (signature == COMMIT_HASH_SIGNATURE && _data.length > 4+32) {\n                bytes32 numberHash;\n                assembly { numberHash := mload(add(_data, 36)) }\n                return (IRandomAuRa(_to).commitHashCallable(_sender, numberHash) ? CALL : NONE, false);\n            } else if (\n                (signature == REVEAL_NUMBER_SIGNATURE || signature == REVEAL_SECRET_SIGNATURE) &&\n                _data.length == 4+32\n            ) {\n                uint256 num;\n                assembly { num := mload(add(_data, 36)) }\n                return (IRandomAuRa(_to).revealNumberCallable(_sender, num) ? CALL : NONE, false);\n            } else {\n                return (NONE, false);\n            }\n        }\n\n        if (_to == address(validatorSetContract)) {\n            // The rules for the ValidatorSetAuRa contract\n            if (signature == EMIT_INITIATE_CHANGE_SIGNATURE) {\n                // The `emitInitiateChange()` can be called by anyone\n                // if `emitInitiateChangeCallable()` returns `true`\n                return (validatorSetContract.emitInitiateChangeCallable() ? CALL : NONE, false);\n            } else if (signature == REPORT_MALICIOUS_SIGNATURE && _data.length >= 4+64) {\n                address maliciousMiningAddress;\n                uint256 blockNumber;\n                assembly {\n                    maliciousMiningAddress := mload(add(_data, 36))\n                    blockNumber := mload(add(_data, 68))\n                }\n                // The `reportMalicious()` can only be called by the validator's mining address\n                // when the calling is allowed\n                (bool callable,) = validatorSetContract.reportMaliciousCallable(\n                    _sender, maliciousMiningAddress, blockNumber\n                );\n\n                return (callable ? CALL : NONE, false);\n            } else if (_gasPrice > 0) {\n                // The other functions of ValidatorSetAuRa contract can be called\n                // by anyone except validators' mining addresses if gasPrice is not zero\n                return (validatorSetContract.isValidator(_sender) ? NONE : CALL, false);\n            }\n        }\n\n        if (validatorSetContract.isValidator(_sender) && _gasPrice > 0) {\n            // Let the validator's mining address send their accumulated tx fees to some wallet\n            return (_sender.balance > 0 ? BASIC : NONE, false);\n        }\n\n        if (validatorSetContract.isValidator(_to)) {\n            // Validator's mining address can't receive any coins\n            return (NONE, false);\n        }\n\n        // Don't let the `_sender` use a zero gas price, if it is not explicitly allowed by the `Certifier` contract\n        if (_gasPrice == 0) {\n            return (certifierContract.certifiedExplicitly(_sender) ? ALL : NONE, false);\n        }\n\n        // Disallow invalid gas price for the specified sender\n        if (_gasPrice < senderMinGasPrice[_sender]) {\n            return (NONE, false);\n        }\n\n        // In other cases let the `_sender` create any transaction with non-zero gas price\n        return (ALL, false);\n    }\n\n    \n    \n    function blockGasLimit() public view returns(uint256) {\n        address stakingContract = validatorSetContract.stakingContract();\n        uint256 stakingEpochEndBlock = IStakingAuRa(stakingContract).stakingEpochEndBlock();\n        if (block.number == stakingEpochEndBlock - 1 || block.number == stakingEpochEndBlock) {\n            return BLOCK_GAS_LIMIT_REDUCED;\n        }\n        return BLOCK_GAS_LIMIT;\n    }\n\n    \n    \n    \n    function deployerInputLengthLimit(address _deployer) public view returns(uint256) {\n        uint256 limit = _deployerInputLengthLimit[_deployer];\n\n        if (limit != 0) {\n            return limit;\n        } else {\n            return 30720; // default EIP 170 limit (24 Kb + overhead)\n        }\n    }\n\n    \n    function isInitialized() public view returns(bool) {\n        return validatorSetContract != IValidatorSetAuRa(0);\n    }\n\n    // ============================================== Internal ========================================================\n\n    // Allowed transaction types mask\n    uint32 internal constant NONE = 0;\n    uint32 internal constant ALL = 0xffffffff;\n    uint32 internal constant BASIC = 0x01;\n    uint32 internal constant CALL = 0x02;\n    // SWC-131-Presence of unused variables: L313-314s\n    uint32 internal constant CREATE = 0x04;\n    uint32 internal constant PRIVATE = 0x08;\n\n    // Function signatures\n\n    // bytes4(keccak256(\"commitHash(bytes32,bytes)\"))\n    bytes4 internal constant COMMIT_HASH_SIGNATURE = 0x0b61ba85; \n\n    // bytes4(keccak256(\"emitInitiateChange()\"))\n    bytes4 internal constant EMIT_INITIATE_CHANGE_SIGNATURE = 0x93b4e25e;\n\n    // bytes4(keccak256(\"reportMalicious(address,uint256,bytes)\"))\n    bytes4 internal constant REPORT_MALICIOUS_SIGNATURE = 0xc476dd40;\n\n    // bytes4(keccak256(\"revealSecret(uint256)\"))\n    bytes4 internal constant REVEAL_SECRET_SIGNATURE = 0x98df67c6;\n\n    // bytes4(keccak256(\"revealNumber(uint256)\"))\n    bytes4 internal constant REVEAL_NUMBER_SIGNATURE = 0xfe7d567d;\n\n    \n    \n    function _addAllowedSender(address _sender) internal {\n        require(!isSenderAllowed[_sender]);\n        require(_sender != address(0));\n        _allowedSenders.push(_sender);\n        isSenderAllowed[_sender] = true;\n    }\n}",
        "function": "initialize(address[],address,address)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Hacken-Etherlite/pos-contracts-e56317bd80a0368a1d9106361c188b589a419b94/contracts/TxPermission.sol",
        "vulnerability": "Dependence on predictable environment variable (SWC 120)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract GuildBank {\n    address public owner;\n\n    constructor () public {\n        owner = msg.sender;\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    event Withdrawal(address indexed receiver, address indexed tokenAddress, uint256 amount);\n\n    function withdraw(address receiver, uint256 shares, uint256 totalShares, IERC20[] memory approvedTokens) public onlyOwner returns (bool) {\n        for (uint256 i = 0; i < approvedTokens.length; i++) {\n            uint256 amount = fairShare(approvedTokens[i].balanceOf(address(this)), shares, totalShares);\n            emit Withdrawal(receiver, address(approvedTokens[i]), amount);\n            require(approvedTokens[i].transfer(receiver, amount));\n        }\n        return true;\n    }\n\n    function withdrawToken(IERC20 token, address receiver, uint256 amount) public onlyOwner returns (bool) {\n        emit Withdrawal(receiver, address(token), amount);\n        return token.transfer(receiver, amount);\n    }\n\n    function fairShare(uint256 balance, uint256 shares, uint256 totalShares) internal pure returns (uint256) {\n        require(totalShares != 0);\n\n        if (balance == 0) { return 0; }\n\n        uint256 prod = balance * shares;\n\n        if (prod / balance == shares) { // no overflow in multiplication above?\n            return prod / totalShares;\n        }\n\n        return (balance / totalShares) * shares;\n    }\n\n}",
        "function": "withdrawToken(address,address,uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/consensys-The_LAO/moloch-4bc443f4dad60279b47978fc6987bb978d3dfc58/contracts/Moloch.sol",
        "vulnerability": "External Call To User-Supplied Address (SWC 107)",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract BsktEthLPPool is LPTokenWrapper {\n    \n    IERC20 public STAKEBSKT = IERC20(0x3d3c60970D3369e48f79664787433fc0d2B7C44b); // Basket token address\n    \n    uint256 public constant duration = 100 days;     //-----| Pool Duration |-----       \n    uint256 public starttime = 0;                    //-----| Pool will start once notify the reward |-----                           \n    uint256 public periodFinish = 0;\n    uint256 public rewardRate = 0;\n    uint256 public lastUpdateTime;\n    uint256 public rewardPerTokenStored;\n\n    bool firstNotify;\n  \n    mapping(address => uint256) public userRewardPerTokenPaid;\n    mapping(address => uint256) public rewards;\n    mapping(address => bool) public minimumBsktStakingEntry;\n\n    event Staked(address indexed user, uint256 amount);\n    event Withdrawn(address indexed user, uint256 amount);\n    event Rewarded(address indexed from, address indexed to, uint256 value);\n\n    modifier checkStart() {\n        require(\n            block.timestamp >= starttime,\n            \"Error:Pool not started yet.\"\n        );\n        _;\n    }\n//SWC-116-Block values as a proxy for time: L400, L417\n    modifier updateReward(address account) {\n        rewardPerTokenStored = rewardPerToken();\n        lastUpdateTime = lastTimeRewardApplicable();\n        if (account != address(0)) {\n            rewards[account] = earned(account);\n            userRewardPerTokenPaid[account] = rewardPerTokenStored;\n        }\n        _;\n    }\n    \n    function lastTimeRewardApplicable() public view returns (uint256) {\n        return Math.min(block.timestamp, periodFinish);\n    }\n\n    function rewardPerToken() public view returns (uint256) {\n        if (totalSupply() == 0) {\n            return rewardPerTokenStored;\n        }\n        return\n            rewardPerTokenStored.add(\n                lastTimeRewardApplicable()\n                    .sub(lastUpdateTime)\n                    .mul(rewardRate)\n                    .mul(1e18)\n                    .div(totalSupply())\n            );\n    }\n\n    function earned(address account) public view returns (uint256) {\n        return balanceOf(account)\n                .mul(rewardPerToken().sub(userRewardPerTokenPaid[account]))\n                .div(1e18)\n                .add(rewards[account]);\n    }\n\n    function stake(uint256 amount) public updateReward(_msgSender()) checkStart {\n        require(amount > 0, \"Cannot stake 0\");\n        super.stake(amount);\n        \n        emit Staked(_msgSender(), amount);\n    }\n\n    function withdraw(uint256 amount)\n        public\n        updateReward(_msgSender())\n    {\n        require(amount > 0, \"Cannot withdraw 0\");\n        super.withdraw(amount);\n        \n        emit Withdrawn(_msgSender(), amount);\n    }\n//SWC-107-Reentrancy: L459-462\n    // Withdraw staked lp token and earned reward immediately\n    function exit() nonReentrant external {\n        withdraw(balanceOf(_msgSender()));\n        getReward();\n    }\n    \n    // Withdraw earned reward\n    function getReward() public nonReentrant updateReward(_msgSender()){\n        uint256 reward = earned(_msgSender());\n\n        if (reward > 0) {\n            rewards[_msgSender()] = 0;\n        \n            STAKEBSKT.safeTransfer(_msgSender(), reward);\n            \n            emit Rewarded(address(this), _msgSender(), reward);\n        }\n        \n    }\n\n    // Notify reward set for duration\n    function notifyRewardRate(uint256 _reward) public updateReward(address(0)) onlyOwner{\n       \n        require(!firstNotify, \"Error : Notify rewards allowed once only\");\n        \n        rewardRate = _reward.div(duration);\n       \n        lastUpdateTime = block.timestamp;\n        starttime = block.timestamp; \n        periodFinish = block.timestamp.add(duration);\n\n        firstNotify = true;\n    }\n}",
        "function": "stake(uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/QuillAudits-BsktEthLPPool Smart Contract/code/BsktEthLPPool.sol",
        "vulnerability": "Dependence on predictable environment variable (SWC 116)",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract BsktEthLPPool is LPTokenWrapper {\n    \n    IERC20 public STAKEBSKT = IERC20(0x3d3c60970D3369e48f79664787433fc0d2B7C44b); // Basket token address\n    \n    uint256 public constant duration = 100 days;     //-----| Pool Duration |-----       \n    uint256 public starttime = 0;                    //-----| Pool will start once notify the reward |-----                           \n    uint256 public periodFinish = 0;\n    uint256 public rewardRate = 0;\n    uint256 public lastUpdateTime;\n    uint256 public rewardPerTokenStored;\n\n    bool firstNotify;\n  \n    mapping(address => uint256) public userRewardPerTokenPaid;\n    mapping(address => uint256) public rewards;\n    mapping(address => bool) public minimumBsktStakingEntry;\n\n    event Staked(address indexed user, uint256 amount);\n    event Withdrawn(address indexed user, uint256 amount);\n    event Rewarded(address indexed from, address indexed to, uint256 value);\n\n    modifier checkStart() {\n        require(\n            block.timestamp >= starttime,\n            \"Error:Pool not started yet.\"\n        );\n        _;\n    }\n//SWC-116-Block values as a proxy for time: L400, L417\n    modifier updateReward(address account) {\n        rewardPerTokenStored = rewardPerToken();\n        lastUpdateTime = lastTimeRewardApplicable();\n        if (account != address(0)) {\n            rewards[account] = earned(account);\n            userRewardPerTokenPaid[account] = rewardPerTokenStored;\n        }\n        _;\n    }\n    \n    function lastTimeRewardApplicable() public view returns (uint256) {\n        return Math.min(block.timestamp, periodFinish);\n    }\n\n    function rewardPerToken() public view returns (uint256) {\n        if (totalSupply() == 0) {\n            return rewardPerTokenStored;\n        }\n        return\n            rewardPerTokenStored.add(\n                lastTimeRewardApplicable()\n                    .sub(lastUpdateTime)\n                    .mul(rewardRate)\n                    .mul(1e18)\n                    .div(totalSupply())\n            );\n    }\n\n    function earned(address account) public view returns (uint256) {\n        return balanceOf(account)\n                .mul(rewardPerToken().sub(userRewardPerTokenPaid[account]))\n                .div(1e18)\n                .add(rewards[account]);\n    }\n\n    function stake(uint256 amount) public updateReward(_msgSender()) checkStart {\n        require(amount > 0, \"Cannot stake 0\");\n        super.stake(amount);\n        \n        emit Staked(_msgSender(), amount);\n    }\n\n    function withdraw(uint256 amount)\n        public\n        updateReward(_msgSender())\n    {\n        require(amount > 0, \"Cannot withdraw 0\");\n        super.withdraw(amount);\n        \n        emit Withdrawn(_msgSender(), amount);\n    }\n//SWC-107-Reentrancy: L459-462\n    // Withdraw staked lp token and earned reward immediately\n    function exit() nonReentrant external {\n        withdraw(balanceOf(_msgSender()));\n        getReward();\n    }\n    \n    // Withdraw earned reward\n    function getReward() public nonReentrant updateReward(_msgSender()){\n        uint256 reward = earned(_msgSender());\n\n        if (reward > 0) {\n            rewards[_msgSender()] = 0;\n        \n            STAKEBSKT.safeTransfer(_msgSender(), reward);\n            \n            emit Rewarded(address(this), _msgSender(), reward);\n        }\n        \n    }\n\n    // Notify reward set for duration\n    function notifyRewardRate(uint256 _reward) public updateReward(address(0)) onlyOwner{\n       \n        require(!firstNotify, \"Error : Notify rewards allowed once only\");\n        \n        rewardRate = _reward.div(duration);\n       \n        lastUpdateTime = block.timestamp;\n        starttime = block.timestamp; \n        periodFinish = block.timestamp.add(duration);\n\n        firstNotify = true;\n    }\n}",
        "function": "notifyRewardRate(uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/QuillAudits-BsktEthLPPool Smart Contract/code/BsktEthLPPool.sol",
        "vulnerability": "Dependence on predictable environment variable (SWC 116)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract BsktEthLPPool is LPTokenWrapper {\n    \n    IERC20 public STAKEBSKT = IERC20(0x3d3c60970D3369e48f79664787433fc0d2B7C44b); // Basket token address\n    \n    uint256 public constant duration = 100 days;     //-----| Pool Duration |-----       \n    uint256 public starttime = 0;                    //-----| Pool will start once notify the reward |-----                           \n    uint256 public periodFinish = 0;\n    uint256 public rewardRate = 0;\n    uint256 public lastUpdateTime;\n    uint256 public rewardPerTokenStored;\n\n    bool firstNotify;\n  \n    mapping(address => uint256) public userRewardPerTokenPaid;\n    mapping(address => uint256) public rewards;\n    mapping(address => bool) public minimumBsktStakingEntry;\n\n    event Staked(address indexed user, uint256 amount);\n    event Withdrawn(address indexed user, uint256 amount);\n    event Rewarded(address indexed from, address indexed to, uint256 value);\n\n    modifier checkStart() {\n        require(\n            block.timestamp >= starttime,\n            \"Error:Pool not started yet.\"\n        );\n        _;\n    }\n//SWC-116-Block values as a proxy for time: L400, L417\n    modifier updateReward(address account) {\n        rewardPerTokenStored = rewardPerToken();\n        lastUpdateTime = lastTimeRewardApplicable();\n        if (account != address(0)) {\n            rewards[account] = earned(account);\n            userRewardPerTokenPaid[account] = rewardPerTokenStored;\n        }\n        _;\n    }\n    \n    function lastTimeRewardApplicable() public view returns (uint256) {\n        return Math.min(block.timestamp, periodFinish);\n    }\n\n    function rewardPerToken() public view returns (uint256) {\n        if (totalSupply() == 0) {\n            return rewardPerTokenStored;\n        }\n        return\n            rewardPerTokenStored.add(\n                lastTimeRewardApplicable()\n                    .sub(lastUpdateTime)\n                    .mul(rewardRate)\n                    .mul(1e18)\n                    .div(totalSupply())\n            );\n    }\n\n    function earned(address account) public view returns (uint256) {\n        return balanceOf(account)\n                .mul(rewardPerToken().sub(userRewardPerTokenPaid[account]))\n                .div(1e18)\n                .add(rewards[account]);\n    }\n\n    function stake(uint256 amount) public updateReward(_msgSender()) checkStart {\n        require(amount > 0, \"Cannot stake 0\");\n        super.stake(amount);\n        \n        emit Staked(_msgSender(), amount);\n    }\n\n    function withdraw(uint256 amount)\n        public\n        updateReward(_msgSender())\n    {\n        require(amount > 0, \"Cannot withdraw 0\");\n        super.withdraw(amount);\n        \n        emit Withdrawn(_msgSender(), amount);\n    }\n//SWC-107-Reentrancy: L459-462\n    // Withdraw staked lp token and earned reward immediately\n    function exit() nonReentrant external {\n        withdraw(balanceOf(_msgSender()));\n        getReward();\n    }\n    \n    // Withdraw earned reward\n    function getReward() public nonReentrant updateReward(_msgSender()){\n        uint256 reward = earned(_msgSender());\n\n        if (reward > 0) {\n            rewards[_msgSender()] = 0;\n        \n            STAKEBSKT.safeTransfer(_msgSender(), reward);\n            \n            emit Rewarded(address(this), _msgSender(), reward);\n        }\n        \n    }\n\n    // Notify reward set for duration\n    function notifyRewardRate(uint256 _reward) public updateReward(address(0)) onlyOwner{\n       \n        require(!firstNotify, \"Error : Notify rewards allowed once only\");\n        \n        rewardRate = _reward.div(duration);\n       \n        lastUpdateTime = block.timestamp;\n        starttime = block.timestamp; \n        periodFinish = block.timestamp.add(duration);\n\n        firstNotify = true;\n    }\n}",
        "function": "lastTimeRewardApplicable()",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/QuillAudits-BsktEthLPPool Smart Contract/code/BsktEthLPPool.sol",
        "vulnerability": "Dependence on predictable environment variable (SWC 116)",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract ChainlinkAdapter {\n    using LibMathSigned for int256;\n\n    IChainlinkFeeder public feeder;\n    int256 public constant chainlinkDecimalsAdapter = 10**10;\n\n    constructor(address _feeder) public {\n        feeder = IChainlinkFeeder(_feeder);\n    }\n\n    function price() public view returns (uint256 newPrice, uint256 timestamp) {\n        // SWC-101-Integer Overflow and Underflow: L18\n        newPrice = (feeder.latestAnswer() * chainlinkDecimalsAdapter).toUint256();\n        timestamp = feeder.latestTimestamp();\n    }\n}",
        "function": "price()",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/consensys-MCDEX_Mai_Protocol_V2/mai-protocol-v2-4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/oracle/ChainlinkAdapter.sol",
        "vulnerability": "Integer Arithmetic Bugs (SWC 101)",
        "check": "TP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract ChainlinkAdapter {\n    using LibMathSigned for int256;\n\n    IChainlinkFeeder public feeder;\n    int256 public constant chainlinkDecimalsAdapter = 10**10;\n\n    constructor(address _feeder) public {\n        feeder = IChainlinkFeeder(_feeder);\n    }\n\n    function price() public view returns (uint256 newPrice, uint256 timestamp) {\n        // SWC-101-Integer Overflow and Underflow: L18\n        newPrice = (feeder.latestAnswer() * chainlinkDecimalsAdapter).toUint256();\n        timestamp = feeder.latestTimestamp();\n    }\n}",
        "function": "price()",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/consensys-MCDEX_Mai_Protocol_V2/mai-protocol-v2-4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/oracle/ChainlinkAdapter.sol",
        "vulnerability": "Multiple Calls in a Single Transaction (SWC 113)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract Brokerage {\n    using LibMathUnsigned for uint256;\n\n    event BrokerUpdate(address indexed account, address indexed guy, uint256 appliedHeight);\n\n    mapping(address => LibTypes.Broker) public brokers;\n\n    // delay set: set the newBroker after n blocks (including the current block)\n    // rules:\n    // 1. new user => set immediately\n    // 2. last broker change is waiting for delay => overwrite the delayed broker and timer\n    // 3. last broker change has taken effect\n    // 3.1 newBroker is the same => ignore\n    // 3.2 newBroker is changing => push the current broker, set the delayed broker and timer\n    //\n    // delay: during this n blocks (including setBroker() itself), current broker does not change\n    function setBroker(address trader, address newBroker, uint256 delay) internal {\n        require(trader != address(0), \"invalid trader\");\n        require(newBroker != address(0), \"invalid guy\");\n        LibTypes.Broker memory broker = brokers[trader];\n        if (broker.current.appliedHeight == 0) {\n            // condition 1\n            broker.current.broker = newBroker;\n            broker.current.appliedHeight = block.number;\n        } else {\n            bool isPreviousChangeApplied = block.number >= broker.current.appliedHeight;\n            if (isPreviousChangeApplied) {\n                if (broker.current.broker == newBroker) {\n                    // condition 3.1\n                    return;\n                } else {\n                    // condition 3.2\n                    broker.previous.broker = broker.current.broker;\n                    broker.previous.appliedHeight = broker.current.appliedHeight;\n                }\n            }\n            // condition 2, 3.2\n            broker.current.broker = newBroker;\n            broker.current.appliedHeight = block.number.add(delay);\n        }\n        // condition 1, 2, 3.2\n        brokers[trader] = broker;\n        emit BrokerUpdate(trader, newBroker, broker.current.appliedHeight);\n    }\n\n    // note: do NOT call this function in a non-transaction request, unless you do not care about the broker appliedHeight.\n    // because in a call(), block.number is the on-chain height, and it will be 1 more in a transaction\n    function currentBroker(address trader) public view returns (address) {\n        LibTypes.Broker storage broker = brokers[trader];\n        return block.number >= broker.current.appliedHeight ? broker.current.broker : broker.previous.broker;\n    }\n\n    function getBroker(address trader) public view returns (LibTypes.Broker memory) {\n        return brokers[trader];\n    }\n}",
        "function": "currentBroker(address)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/consensys-MCDEX_Mai_Protocol_V2/mai-protocol-v2-4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/perpetual/Brokerage.sol",
        "vulnerability": "Dependence on predictable environment variable (SWC 120)",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract aqarchain is Ownable {\n     using SafeMath for uint256;\n     \n     // Info of each user in seed,public and private .\n     \n    struct seedUserInfo {\n        string firstname;\n        string lastname;\n        string country;\n        uint256 amount;    \n        uint256 phase; \n        string aqarid;\n        string modeofpayment;\n    }\n     struct privateUserInfo {\n        string firstname;\n        string lastname;\n        string country;\n        uint256 amount;    \n        uint256 phase; \n        string aqarid;\n        string modeofpayment;\n    }\n     struct publicUserInfo {\n        string firstname;\n        string lastname;\n        string country;\n        uint256 amount;    \n        uint256 phase; \n        string aqarid;\n        string modeofpayment;\n    }\n    //aqar token address\n      IERC20 public token;\n      \n      //useraddress input toh you will get userinfo\n      mapping (address => seedUserInfo) public usermapseed;\n      mapping (address => privateUserInfo) public usermapprivate;\n      mapping (address => publicUserInfo) public usermappublic;\n      \n      // aqar id to get amount invested\n      mapping (string => uint256) public amountmaptouserseed;\n      mapping (string => uint256) public amountmaptouserprivate;\n      mapping (string => uint256) public amountmaptouserpublic;\n      \n      //count of total transactions\n      uint256 public i=0;\n      \n      //claim amount variable \n      uint256 claimamount=0;\n      \n      // prices of various rounds\n      uint256 public seedprice = 4;\n      uint256 public privateprice = 2857;\n      uint256 public publicprice = 22;\n      \n      //soldout amount\n      uint256 public seedamount;\n      uint256 public privateamount;\n      uint256 public publicamount;\n      \n      // variables to turn on and off private and public functions\n      bool public seedrun = false;\n      bool public privaterun = false;\n      bool public publicrun = false;\n      bool public claimbool = false;\n      \n      //all addresses\n      address[] public usersarr;\n      \n      // usdt address\n      IERC20 private usdt = IERC20(0x7ef95a0FEE0Dd31b22626fA2e10Ee6A223F8a684);\n      \n       //router to get bnb price\n       IUniswapV2Router01 pancakerouter1;\n    \n      constructor() public {\n        pancakerouter1 = IUniswapV2Router01(\n            0x9Ac64Cc6e4415144C455BD8E4837Fea55603e5c3\n        );\n    }\n      address[] private arr = [\n        0xae13d989daC2f0dEbFf460aC112a837C89BAa7cd, //WBNB\n        0x7ef95a0FEE0Dd31b22626fA2e10Ee6A223F8a684 //usdt\n    ];\n\n    function getBnbRate() public view returns (uint256) {\n        uint256[] memory amounts = pancakerouter1.getAmountsOut(1e18, arr);\n        return amounts[1];\n    }\n    function settoken(address _token)external onlyOwner{\n        token = IERC20(_token);\n    }\n    function seedusdt(string calldata _first,string calldata _last,string calldata _country,string calldata _id, uint256 _amount)  external returns (string memory aqarid){\n        require(_amount>=100000000000000000000 ,\"Enter amount greater than 100 usd\");\n        require(seedamount<=7000000000000000000000000,\"seed round token sale completed\");\n        // SWC-129-Typographical Error: L444\n        require(seedrun = true,\"seed round is not started or over\");\n\n        if(seedamount.add(_amount.mul(seedprice))<=7000000000000000000000000){\n        usdt.transferFrom(msg.sender,address(this), _amount);\n        usermapseed[msg.sender]=seedUserInfo({firstname:_first,lastname:_last,country:_country,amount: usermapseed[msg.sender].amount.add(_amount.mul(seedprice)),phase:seedprice,aqarid:_id,modeofpayment:\"USDT\"});\n        amountmaptouserseed[_id]=amountmaptouserseed[_id].add(_amount.mul(seedprice));\n        seedamount=seedamount.add(_amount.mul(seedprice));\n        i++;\n        usersarr.push(msg.sender);\n        }\n        else{\n            revert(\"try reducing amount or seed round is finished\");\n        }\n    }\n    \n      function seedbnb(string calldata _first,string calldata _last,string calldata _country,string calldata _id) external payable {\n        // user enter amount of ether which is then transfered into the smart contract and tokens to be given is saved in the mapping\n        require(\n            msg.value.mul(getBnbRate()).div(1e18) >= 100000000000000000000,\n            \"the input bnb amount should be greater than hundred\"\n        );\n        require(seedamount<=7000000000000000000000000,\"seed round token sale completed\");\n        // SWC-129-Typographical Error: L467\n        require(seedrun = true,\"seed round is not started or over\");\n      \n       if(seedamount.add(msg.value.mul(getBnbRate()).mul(seedprice).div(1e18))<=7000000000000000000000000){\n        usermapseed[msg.sender]=seedUserInfo({firstname:_first,lastname:_last,country:_country,amount:usermapseed[msg.sender].amount.add(msg.value.mul(getBnbRate()).mul(seedprice).div(1e18)),phase:seedprice,aqarid:_id,modeofpayment:\"BNB\"});\n        amountmaptouserseed[_id]=amountmaptouserseed[_id].add(msg.value.mul(getBnbRate()).mul(seedprice).div(1e18));\n        seedamount=seedamount.add(msg.value.mul(getBnbRate()).mul(seedprice).div(1e18));\n        i++;\n        usersarr.push(msg.sender);\n        }\n        else{\n            revert(\"try reducing amount or seed round is finished\");\n        }\n    }\n     function privateusdt(string calldata _first,string calldata _last,string calldata _country,string calldata _id, uint256 _amount)  external returns (string memory aqarid){\n        require(_amount>=100000000000000000000,\"Enter amount greter than 100 usd\");\n        require(privateamount<=12000000000000000000000000,\"private round token sale completed\");\n        require(privaterun=true,\"Private sale haven't started yet\");\n        \n        if(privateamount.add(_amount.mul(privateprice).div(1000))<=12000000000000000000000000){\n        usermapprivate[msg.sender]=privateUserInfo({firstname:_first,lastname:_last,country:_country,amount:usermapprivate[msg.sender].amount.add(_amount.mul(privateprice).div(1000)),phase:privateprice,aqarid:_id,modeofpayment:\"USDT\"});\n        amountmaptouserprivate[_id]= amountmaptouserprivate[_id].add(_amount.mul(privateprice).div(1000));\n        usdt.transferFrom(msg.sender,address(this), _amount);\n        privateamount=privateamount.add(_amount.mul(privateprice).div(1000));\n        i++;\n        usersarr.push(msg.sender);\n        }\n        else{\n            revert(\"private round is over\");\n        }\n    }\n      function privatebnb(string calldata _first,string calldata _last,string calldata _country,string calldata _id) external payable {\n        // user enter amount of ether which is then transfered into the smart contract and tokens to be given is saved in the mapping\n       require(\n           msg.value.mul(getBnbRate()).div(1e18) >= 100000000000000000000 ,\n            \"the input bnb amount should be greater than hundred usd\"\n        );\n        require(privaterun=true,\"Private sale haven't started yet\");\n        require(privateamount<=12000000000000000000000000,\"private round token sale completed\");\n        \n      if(privateamount.add(msg.value.mul(getBnbRate()).mul(privateprice).div(1e18).div(1000))<=12000000000000000000000000){\n        usermapprivate[msg.sender]=privateUserInfo({firstname:_first,lastname:_last,country:_country,amount:usermapprivate[msg.sender].amount.add(msg.value.mul(getBnbRate()).mul(privateprice).div(1e18).div(1000)),phase:privateprice,aqarid:_id,modeofpayment:\"BNB\"});\n        amountmaptouserprivate[_id]=amountmaptouserprivate[_id].add(msg.value.mul(getBnbRate()).mul(privateprice).div(1e18).div(1000));\n        privateamount=privateamount.add(msg.value.mul(getBnbRate()).mul(privateprice).div(1e18).div(1000));\n        i++;\n        usersarr.push(msg.sender);\n        }\n        else{\n            revert(\"private round is over\");\n        }\n    }\n    \n     function publicusdt(string calldata _first,string calldata _last,string calldata _country,string calldata _id, uint256 _amount)  external returns (string memory aqarid){\n         require(_amount>=100000000000000000000 ,\"Enter amount more than 100 usd\");\n        \n         require(publicamount<=1000000000000000000000000,\"public round token sale completed\");\n         require(publicrun=true,\"Public sale haven't started yet\");\n        \n        if(publicamount.add(_amount.mul(publicprice).div(10))<=1000000000000000000000000){\n        usermappublic[msg.sender]=publicUserInfo({firstname:_first,lastname:_last,country:_country,amount:usermappublic[msg.sender].amount.add(_amount.mul(publicprice).div(10)),phase:publicprice,aqarid:_id,modeofpayment:\"usdt\"});\n        amountmaptouserpublic[_id]=amountmaptouserpublic[_id].add(_amount.mul(publicprice).div(10));\n        usdt.transferFrom(msg.sender,address(this), _amount);\n        publicamount=publicamount.add(_amount.mul(publicprice).div(10));\n        i++;\n        usersarr.push(msg.sender);\n        }\n        else{\n            revert(\"public round is over\");\n        }\n    }\n    function publicbnb(string calldata _first,string calldata _last,string calldata _country,string calldata _id) external payable {\n        // user enter amount of ether which is then transfered into the smart contract and tokens to be given is saved in the mapping\n        require(\n             msg.value.mul(getBnbRate()).div(1e18) >= 100000000000000000000 ,\n            \"the input bnb amount should be greater than hundred and less than sfivethousand\"\n        );\n        require(publicrun=true,\"Public sale haven't started yet\");\n        // SWC-123-Requirement Violation: L542\n        require(privateamount<=1000000000000000000000000,\"private round token sale completed\");\n     \n      if(publicamount.add(msg.value.mul(getBnbRate()).mul(publicprice).div(1e18).div(10))<=1000000000000000000000000){\n        usermappublic[msg.sender]=publicUserInfo({firstname:_first,lastname:_last,country:_country,amount:usermappublic[msg.sender].amount.add(msg.value.mul(getBnbRate()).mul(publicprice).div(1e18).div(10)),phase:publicprice,aqarid:_id,modeofpayment:\"BNB\"});\n        amountmaptouserpublic[_id]=amountmaptouserpublic[_id].add(msg.value.mul(getBnbRate()).mul(publicprice).div(1e18).div(10));\n        publicamount=privateamount.add(msg.value.mul(getBnbRate()).mul(publicprice).div(1e18).div(10));\n        i++;\n        usersarr.push(msg.sender);\n        }\n        else{\n            revert(\"private round is over\");\n        }\n    }\n    function claim() external {\n        // SWC-129-Typographical Error: L559\n        require(claimbool = true,\"claiming amount should be true\");\n       \n        claimamount = usermappublic[msg.sender].amount.add(usermapseed[msg.sender].amount).add(usermapprivate[msg.sender].amount);\n        token.transfer(msg.sender,claimamount);\n        usermappublic[msg.sender].amount=0;\n        usermapprivate[msg.sender].amount=0;\n        usermapseed[msg.sender].amount=0;\n        claimamount=0;\n    }\n    \n    function privatemap(string calldata _first,string calldata _last,string calldata _country,address _address,uint256 _amount,string calldata _aqarid) external onlyOwner{\n        usermapseed[_address] = seedUserInfo({firstname:_first,lastname:_last,country:_country,amount:_amount,phase:seedprice,aqarid:_aqarid,modeofpayment:\"private\"});\n        amountmaptouserseed[_aqarid] = _amount;\n    }\n    function toggleclaim() external onlyOwner returns (uint256) {\n        claimbool = !claimbool;\n    }\n    function toggleseed() external onlyOwner returns (uint256) {\n        seedrun = !seedrun;\n    }\n     function toggleprivate() external onlyOwner returns (uint256) {\n        privaterun = !privaterun;\n    }\n      function togglepublic() external onlyOwner returns (uint256) {\n        publicrun = !publicrun;\n    }\n    \n     function getBnbBalance() public view returns (uint256) {\n        return address(this).balance;\n    }\n\n    function adminTransferBnbFund() external onlyOwner {\n        msg.sender.transfer(address(this).balance);\n    }\n\n    function getContractTokenBalance(IERC20 _token)\n        public\n        view\n        returns (uint256)\n    {\n        return _token.balanceOf(address(this));\n    }\n\n    function fundsWithdrawal(IERC20 _token, uint256 value) external onlyOwner {\n        require(\n            getContractTokenBalance(_token) >= value,\n            \"the contract doesnt have tokens\"\n        );\n        \n      _token.transfer(msg.sender,value);\n\n    }\n    \n  \n}",
        "function": "usersarr(uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/ImmuneBytes-Aqar Chain-Final Audit Report/code/aq.sol",
        "vulnerability": "Exception State (SWC 110)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract aqarchain is Ownable {\n     using SafeMath for uint256;\n     \n     // Info of each user in seed,public and private .\n     \n    struct seedUserInfo {\n        string firstname;\n        string lastname;\n        string country;\n        uint256 amount;    \n        uint256 phase; \n        string aqarid;\n        string modeofpayment;\n    }\n     struct privateUserInfo {\n        string firstname;\n        string lastname;\n        string country;\n        uint256 amount;    \n        uint256 phase; \n        string aqarid;\n        string modeofpayment;\n    }\n     struct publicUserInfo {\n        string firstname;\n        string lastname;\n        string country;\n        uint256 amount;    \n        uint256 phase; \n        string aqarid;\n        string modeofpayment;\n    }\n    //aqar token address\n      IERC20 public token;\n      \n      //useraddress input toh you will get userinfo\n      mapping (address => seedUserInfo) public usermapseed;\n      mapping (address => privateUserInfo) public usermapprivate;\n      mapping (address => publicUserInfo) public usermappublic;\n      \n      // aqar id to get amount invested\n      mapping (string => uint256) public amountmaptouserseed;\n      mapping (string => uint256) public amountmaptouserprivate;\n      mapping (string => uint256) public amountmaptouserpublic;\n      \n      //count of total transactions\n      uint256 public i=0;\n      \n      //claim amount variable \n      uint256 claimamount=0;\n      \n      // prices of various rounds\n      uint256 public seedprice = 4;\n      uint256 public privateprice = 2857;\n      uint256 public publicprice = 22;\n      \n      //soldout amount\n      uint256 public seedamount;\n      uint256 public privateamount;\n      uint256 public publicamount;\n      \n      // variables to turn on and off private and public functions\n      bool public seedrun = false;\n      bool public privaterun = false;\n      bool public publicrun = false;\n      bool public claimbool = false;\n      \n      //all addresses\n      address[] public usersarr;\n      \n      // usdt address\n      IERC20 private usdt = IERC20(0x7ef95a0FEE0Dd31b22626fA2e10Ee6A223F8a684);\n      \n       //router to get bnb price\n       IUniswapV2Router01 pancakerouter1;\n    \n      constructor() public {\n        pancakerouter1 = IUniswapV2Router01(\n            0x9Ac64Cc6e4415144C455BD8E4837Fea55603e5c3\n        );\n    }\n      address[] private arr = [\n        0xae13d989daC2f0dEbFf460aC112a837C89BAa7cd, //WBNB\n        0x7ef95a0FEE0Dd31b22626fA2e10Ee6A223F8a684 //usdt\n    ];\n\n    function getBnbRate() public view returns (uint256) {\n        uint256[] memory amounts = pancakerouter1.getAmountsOut(1e18, arr);\n        return amounts[1];\n    }\n    function settoken(address _token)external onlyOwner{\n        token = IERC20(_token);\n    }\n    function seedusdt(string calldata _first,string calldata _last,string calldata _country,string calldata _id, uint256 _amount)  external returns (string memory aqarid){\n        require(_amount>=100000000000000000000 ,\"Enter amount greater than 100 usd\");\n        require(seedamount<=7000000000000000000000000,\"seed round token sale completed\");\n        // SWC-129-Typographical Error: L444\n        require(seedrun = true,\"seed round is not started or over\");\n\n        if(seedamount.add(_amount.mul(seedprice))<=7000000000000000000000000){\n        usdt.transferFrom(msg.sender,address(this), _amount);\n        usermapseed[msg.sender]=seedUserInfo({firstname:_first,lastname:_last,country:_country,amount: usermapseed[msg.sender].amount.add(_amount.mul(seedprice)),phase:seedprice,aqarid:_id,modeofpayment:\"USDT\"});\n        amountmaptouserseed[_id]=amountmaptouserseed[_id].add(_amount.mul(seedprice));\n        seedamount=seedamount.add(_amount.mul(seedprice));\n        i++;\n        usersarr.push(msg.sender);\n        }\n        else{\n            revert(\"try reducing amount or seed round is finished\");\n        }\n    }\n    \n      function seedbnb(string calldata _first,string calldata _last,string calldata _country,string calldata _id) external payable {\n        // user enter amount of ether which is then transfered into the smart contract and tokens to be given is saved in the mapping\n        require(\n            msg.value.mul(getBnbRate()).div(1e18) >= 100000000000000000000,\n            \"the input bnb amount should be greater than hundred\"\n        );\n        require(seedamount<=7000000000000000000000000,\"seed round token sale completed\");\n        // SWC-129-Typographical Error: L467\n        require(seedrun = true,\"seed round is not started or over\");\n      \n       if(seedamount.add(msg.value.mul(getBnbRate()).mul(seedprice).div(1e18))<=7000000000000000000000000){\n        usermapseed[msg.sender]=seedUserInfo({firstname:_first,lastname:_last,country:_country,amount:usermapseed[msg.sender].amount.add(msg.value.mul(getBnbRate()).mul(seedprice).div(1e18)),phase:seedprice,aqarid:_id,modeofpayment:\"BNB\"});\n        amountmaptouserseed[_id]=amountmaptouserseed[_id].add(msg.value.mul(getBnbRate()).mul(seedprice).div(1e18));\n        seedamount=seedamount.add(msg.value.mul(getBnbRate()).mul(seedprice).div(1e18));\n        i++;\n        usersarr.push(msg.sender);\n        }\n        else{\n            revert(\"try reducing amount or seed round is finished\");\n        }\n    }\n     function privateusdt(string calldata _first,string calldata _last,string calldata _country,string calldata _id, uint256 _amount)  external returns (string memory aqarid){\n        require(_amount>=100000000000000000000,\"Enter amount greter than 100 usd\");\n        require(privateamount<=12000000000000000000000000,\"private round token sale completed\");\n        require(privaterun=true,\"Private sale haven't started yet\");\n        \n        if(privateamount.add(_amount.mul(privateprice).div(1000))<=12000000000000000000000000){\n        usermapprivate[msg.sender]=privateUserInfo({firstname:_first,lastname:_last,country:_country,amount:usermapprivate[msg.sender].amount.add(_amount.mul(privateprice).div(1000)),phase:privateprice,aqarid:_id,modeofpayment:\"USDT\"});\n        amountmaptouserprivate[_id]= amountmaptouserprivate[_id].add(_amount.mul(privateprice).div(1000));\n        usdt.transferFrom(msg.sender,address(this), _amount);\n        privateamount=privateamount.add(_amount.mul(privateprice).div(1000));\n        i++;\n        usersarr.push(msg.sender);\n        }\n        else{\n            revert(\"private round is over\");\n        }\n    }\n      function privatebnb(string calldata _first,string calldata _last,string calldata _country,string calldata _id) external payable {\n        // user enter amount of ether which is then transfered into the smart contract and tokens to be given is saved in the mapping\n       require(\n           msg.value.mul(getBnbRate()).div(1e18) >= 100000000000000000000 ,\n            \"the input bnb amount should be greater than hundred usd\"\n        );\n        require(privaterun=true,\"Private sale haven't started yet\");\n        require(privateamount<=12000000000000000000000000,\"private round token sale completed\");\n        \n      if(privateamount.add(msg.value.mul(getBnbRate()).mul(privateprice).div(1e18).div(1000))<=12000000000000000000000000){\n        usermapprivate[msg.sender]=privateUserInfo({firstname:_first,lastname:_last,country:_country,amount:usermapprivate[msg.sender].amount.add(msg.value.mul(getBnbRate()).mul(privateprice).div(1e18).div(1000)),phase:privateprice,aqarid:_id,modeofpayment:\"BNB\"});\n        amountmaptouserprivate[_id]=amountmaptouserprivate[_id].add(msg.value.mul(getBnbRate()).mul(privateprice).div(1e18).div(1000));\n        privateamount=privateamount.add(msg.value.mul(getBnbRate()).mul(privateprice).div(1e18).div(1000));\n        i++;\n        usersarr.push(msg.sender);\n        }\n        else{\n            revert(\"private round is over\");\n        }\n    }\n    \n     function publicusdt(string calldata _first,string calldata _last,string calldata _country,string calldata _id, uint256 _amount)  external returns (string memory aqarid){\n         require(_amount>=100000000000000000000 ,\"Enter amount more than 100 usd\");\n        \n         require(publicamount<=1000000000000000000000000,\"public round token sale completed\");\n         require(publicrun=true,\"Public sale haven't started yet\");\n        \n        if(publicamount.add(_amount.mul(publicprice).div(10))<=1000000000000000000000000){\n        usermappublic[msg.sender]=publicUserInfo({firstname:_first,lastname:_last,country:_country,amount:usermappublic[msg.sender].amount.add(_amount.mul(publicprice).div(10)),phase:publicprice,aqarid:_id,modeofpayment:\"usdt\"});\n        amountmaptouserpublic[_id]=amountmaptouserpublic[_id].add(_amount.mul(publicprice).div(10));\n        usdt.transferFrom(msg.sender,address(this), _amount);\n        publicamount=publicamount.add(_amount.mul(publicprice).div(10));\n        i++;\n        usersarr.push(msg.sender);\n        }\n        else{\n            revert(\"public round is over\");\n        }\n    }\n    function publicbnb(string calldata _first,string calldata _last,string calldata _country,string calldata _id) external payable {\n        // user enter amount of ether which is then transfered into the smart contract and tokens to be given is saved in the mapping\n        require(\n             msg.value.mul(getBnbRate()).div(1e18) >= 100000000000000000000 ,\n            \"the input bnb amount should be greater than hundred and less than sfivethousand\"\n        );\n        require(publicrun=true,\"Public sale haven't started yet\");\n        // SWC-123-Requirement Violation: L542\n        require(privateamount<=1000000000000000000000000,\"private round token sale completed\");\n     \n      if(publicamount.add(msg.value.mul(getBnbRate()).mul(publicprice).div(1e18).div(10))<=1000000000000000000000000){\n        usermappublic[msg.sender]=publicUserInfo({firstname:_first,lastname:_last,country:_country,amount:usermappublic[msg.sender].amount.add(msg.value.mul(getBnbRate()).mul(publicprice).div(1e18).div(10)),phase:publicprice,aqarid:_id,modeofpayment:\"BNB\"});\n        amountmaptouserpublic[_id]=amountmaptouserpublic[_id].add(msg.value.mul(getBnbRate()).mul(publicprice).div(1e18).div(10));\n        publicamount=privateamount.add(msg.value.mul(getBnbRate()).mul(publicprice).div(1e18).div(10));\n        i++;\n        usersarr.push(msg.sender);\n        }\n        else{\n            revert(\"private round is over\");\n        }\n    }\n    function claim() external {\n        // SWC-129-Typographical Error: L559\n        require(claimbool = true,\"claiming amount should be true\");\n       \n        claimamount = usermappublic[msg.sender].amount.add(usermapseed[msg.sender].amount).add(usermapprivate[msg.sender].amount);\n        token.transfer(msg.sender,claimamount);\n        usermappublic[msg.sender].amount=0;\n        usermapprivate[msg.sender].amount=0;\n        usermapseed[msg.sender].amount=0;\n        claimamount=0;\n    }\n    \n    function privatemap(string calldata _first,string calldata _last,string calldata _country,address _address,uint256 _amount,string calldata _aqarid) external onlyOwner{\n        usermapseed[_address] = seedUserInfo({firstname:_first,lastname:_last,country:_country,amount:_amount,phase:seedprice,aqarid:_aqarid,modeofpayment:\"private\"});\n        amountmaptouserseed[_aqarid] = _amount;\n    }\n    function toggleclaim() external onlyOwner returns (uint256) {\n        claimbool = !claimbool;\n    }\n    function toggleseed() external onlyOwner returns (uint256) {\n        seedrun = !seedrun;\n    }\n     function toggleprivate() external onlyOwner returns (uint256) {\n        privaterun = !privaterun;\n    }\n      function togglepublic() external onlyOwner returns (uint256) {\n        publicrun = !publicrun;\n    }\n    \n     function getBnbBalance() public view returns (uint256) {\n        return address(this).balance;\n    }\n\n    function adminTransferBnbFund() external onlyOwner {\n        msg.sender.transfer(address(this).balance);\n    }\n\n    function getContractTokenBalance(IERC20 _token)\n        public\n        view\n        returns (uint256)\n    {\n        return _token.balanceOf(address(this));\n    }\n\n    function fundsWithdrawal(IERC20 _token, uint256 value) external onlyOwner {\n        require(\n            getContractTokenBalance(_token) >= value,\n            \"the contract doesnt have tokens\"\n        );\n        \n      _token.transfer(msg.sender,value);\n\n    }\n    \n  \n}",
        "function": "fundsWithdrawal(address,uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/ImmuneBytes-Aqar Chain-Final Audit Report/code/aq.sol",
        "vulnerability": "External Call To User-Supplied Address (SWC 107)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract aqarchain is Ownable {\n     using SafeMath for uint256;\n     \n     // Info of each user in seed,public and private .\n     \n    struct seedUserInfo {\n        string firstname;\n        string lastname;\n        string country;\n        uint256 amount;    \n        uint256 phase; \n        string aqarid;\n        string modeofpayment;\n    }\n     struct privateUserInfo {\n        string firstname;\n        string lastname;\n        string country;\n        uint256 amount;    \n        uint256 phase; \n        string aqarid;\n        string modeofpayment;\n    }\n     struct publicUserInfo {\n        string firstname;\n        string lastname;\n        string country;\n        uint256 amount;    \n        uint256 phase; \n        string aqarid;\n        string modeofpayment;\n    }\n    //aqar token address\n      IERC20 public token;\n      \n      //useraddress input toh you will get userinfo\n      mapping (address => seedUserInfo) public usermapseed;\n      mapping (address => privateUserInfo) public usermapprivate;\n      mapping (address => publicUserInfo) public usermappublic;\n      \n      // aqar id to get amount invested\n      mapping (string => uint256) public amountmaptouserseed;\n      mapping (string => uint256) public amountmaptouserprivate;\n      mapping (string => uint256) public amountmaptouserpublic;\n      \n      //count of total transactions\n      uint256 public i=0;\n      \n      //claim amount variable \n      uint256 claimamount=0;\n      \n      // prices of various rounds\n      uint256 public seedprice = 4;\n      uint256 public privateprice = 2857;\n      uint256 public publicprice = 22;\n      \n      //soldout amount\n      uint256 public seedamount;\n      uint256 public privateamount;\n      uint256 public publicamount;\n      \n      // variables to turn on and off private and public functions\n      bool public seedrun = false;\n      bool public privaterun = false;\n      bool public publicrun = false;\n      bool public claimbool = false;\n      \n      //all addresses\n      address[] public usersarr;\n      \n      // usdt address\n      IERC20 private usdt = IERC20(0x7ef95a0FEE0Dd31b22626fA2e10Ee6A223F8a684);\n      \n       //router to get bnb price\n       IUniswapV2Router01 pancakerouter1;\n    \n      constructor() public {\n        pancakerouter1 = IUniswapV2Router01(\n            0x9Ac64Cc6e4415144C455BD8E4837Fea55603e5c3\n        );\n    }\n      address[] private arr = [\n        0xae13d989daC2f0dEbFf460aC112a837C89BAa7cd, //WBNB\n        0x7ef95a0FEE0Dd31b22626fA2e10Ee6A223F8a684 //usdt\n    ];\n\n    function getBnbRate() public view returns (uint256) {\n        uint256[] memory amounts = pancakerouter1.getAmountsOut(1e18, arr);\n        return amounts[1];\n    }\n    function settoken(address _token)external onlyOwner{\n        token = IERC20(_token);\n    }\n    function seedusdt(string calldata _first,string calldata _last,string calldata _country,string calldata _id, uint256 _amount)  external returns (string memory aqarid){\n        require(_amount>=100000000000000000000 ,\"Enter amount greater than 100 usd\");\n        require(seedamount<=7000000000000000000000000,\"seed round token sale completed\");\n        // SWC-129-Typographical Error: L444\n        require(seedrun = true,\"seed round is not started or over\");\n\n        if(seedamount.add(_amount.mul(seedprice))<=7000000000000000000000000){\n        usdt.transferFrom(msg.sender,address(this), _amount);\n        usermapseed[msg.sender]=seedUserInfo({firstname:_first,lastname:_last,country:_country,amount: usermapseed[msg.sender].amount.add(_amount.mul(seedprice)),phase:seedprice,aqarid:_id,modeofpayment:\"USDT\"});\n        amountmaptouserseed[_id]=amountmaptouserseed[_id].add(_amount.mul(seedprice));\n        seedamount=seedamount.add(_amount.mul(seedprice));\n        i++;\n        usersarr.push(msg.sender);\n        }\n        else{\n            revert(\"try reducing amount or seed round is finished\");\n        }\n    }\n    \n      function seedbnb(string calldata _first,string calldata _last,string calldata _country,string calldata _id) external payable {\n        // user enter amount of ether which is then transfered into the smart contract and tokens to be given is saved in the mapping\n        require(\n            msg.value.mul(getBnbRate()).div(1e18) >= 100000000000000000000,\n            \"the input bnb amount should be greater than hundred\"\n        );\n        require(seedamount<=7000000000000000000000000,\"seed round token sale completed\");\n        // SWC-129-Typographical Error: L467\n        require(seedrun = true,\"seed round is not started or over\");\n      \n       if(seedamount.add(msg.value.mul(getBnbRate()).mul(seedprice).div(1e18))<=7000000000000000000000000){\n        usermapseed[msg.sender]=seedUserInfo({firstname:_first,lastname:_last,country:_country,amount:usermapseed[msg.sender].amount.add(msg.value.mul(getBnbRate()).mul(seedprice).div(1e18)),phase:seedprice,aqarid:_id,modeofpayment:\"BNB\"});\n        amountmaptouserseed[_id]=amountmaptouserseed[_id].add(msg.value.mul(getBnbRate()).mul(seedprice).div(1e18));\n        seedamount=seedamount.add(msg.value.mul(getBnbRate()).mul(seedprice).div(1e18));\n        i++;\n        usersarr.push(msg.sender);\n        }\n        else{\n            revert(\"try reducing amount or seed round is finished\");\n        }\n    }\n     function privateusdt(string calldata _first,string calldata _last,string calldata _country,string calldata _id, uint256 _amount)  external returns (string memory aqarid){\n        require(_amount>=100000000000000000000,\"Enter amount greter than 100 usd\");\n        require(privateamount<=12000000000000000000000000,\"private round token sale completed\");\n        require(privaterun=true,\"Private sale haven't started yet\");\n        \n        if(privateamount.add(_amount.mul(privateprice).div(1000))<=12000000000000000000000000){\n        usermapprivate[msg.sender]=privateUserInfo({firstname:_first,lastname:_last,country:_country,amount:usermapprivate[msg.sender].amount.add(_amount.mul(privateprice).div(1000)),phase:privateprice,aqarid:_id,modeofpayment:\"USDT\"});\n        amountmaptouserprivate[_id]= amountmaptouserprivate[_id].add(_amount.mul(privateprice).div(1000));\n        usdt.transferFrom(msg.sender,address(this), _amount);\n        privateamount=privateamount.add(_amount.mul(privateprice).div(1000));\n        i++;\n        usersarr.push(msg.sender);\n        }\n        else{\n            revert(\"private round is over\");\n        }\n    }\n      function privatebnb(string calldata _first,string calldata _last,string calldata _country,string calldata _id) external payable {\n        // user enter amount of ether which is then transfered into the smart contract and tokens to be given is saved in the mapping\n       require(\n           msg.value.mul(getBnbRate()).div(1e18) >= 100000000000000000000 ,\n            \"the input bnb amount should be greater than hundred usd\"\n        );\n        require(privaterun=true,\"Private sale haven't started yet\");\n        require(privateamount<=12000000000000000000000000,\"private round token sale completed\");\n        \n      if(privateamount.add(msg.value.mul(getBnbRate()).mul(privateprice).div(1e18).div(1000))<=12000000000000000000000000){\n        usermapprivate[msg.sender]=privateUserInfo({firstname:_first,lastname:_last,country:_country,amount:usermapprivate[msg.sender].amount.add(msg.value.mul(getBnbRate()).mul(privateprice).div(1e18).div(1000)),phase:privateprice,aqarid:_id,modeofpayment:\"BNB\"});\n        amountmaptouserprivate[_id]=amountmaptouserprivate[_id].add(msg.value.mul(getBnbRate()).mul(privateprice).div(1e18).div(1000));\n        privateamount=privateamount.add(msg.value.mul(getBnbRate()).mul(privateprice).div(1e18).div(1000));\n        i++;\n        usersarr.push(msg.sender);\n        }\n        else{\n            revert(\"private round is over\");\n        }\n    }\n    \n     function publicusdt(string calldata _first,string calldata _last,string calldata _country,string calldata _id, uint256 _amount)  external returns (string memory aqarid){\n         require(_amount>=100000000000000000000 ,\"Enter amount more than 100 usd\");\n        \n         require(publicamount<=1000000000000000000000000,\"public round token sale completed\");\n         require(publicrun=true,\"Public sale haven't started yet\");\n        \n        if(publicamount.add(_amount.mul(publicprice).div(10))<=1000000000000000000000000){\n        usermappublic[msg.sender]=publicUserInfo({firstname:_first,lastname:_last,country:_country,amount:usermappublic[msg.sender].amount.add(_amount.mul(publicprice).div(10)),phase:publicprice,aqarid:_id,modeofpayment:\"usdt\"});\n        amountmaptouserpublic[_id]=amountmaptouserpublic[_id].add(_amount.mul(publicprice).div(10));\n        usdt.transferFrom(msg.sender,address(this), _amount);\n        publicamount=publicamount.add(_amount.mul(publicprice).div(10));\n        i++;\n        usersarr.push(msg.sender);\n        }\n        else{\n            revert(\"public round is over\");\n        }\n    }\n    function publicbnb(string calldata _first,string calldata _last,string calldata _country,string calldata _id) external payable {\n        // user enter amount of ether which is then transfered into the smart contract and tokens to be given is saved in the mapping\n        require(\n             msg.value.mul(getBnbRate()).div(1e18) >= 100000000000000000000 ,\n            \"the input bnb amount should be greater than hundred and less than sfivethousand\"\n        );\n        require(publicrun=true,\"Public sale haven't started yet\");\n        // SWC-123-Requirement Violation: L542\n        require(privateamount<=1000000000000000000000000,\"private round token sale completed\");\n     \n      if(publicamount.add(msg.value.mul(getBnbRate()).mul(publicprice).div(1e18).div(10))<=1000000000000000000000000){\n        usermappublic[msg.sender]=publicUserInfo({firstname:_first,lastname:_last,country:_country,amount:usermappublic[msg.sender].amount.add(msg.value.mul(getBnbRate()).mul(publicprice).div(1e18).div(10)),phase:publicprice,aqarid:_id,modeofpayment:\"BNB\"});\n        amountmaptouserpublic[_id]=amountmaptouserpublic[_id].add(msg.value.mul(getBnbRate()).mul(publicprice).div(1e18).div(10));\n        publicamount=privateamount.add(msg.value.mul(getBnbRate()).mul(publicprice).div(1e18).div(10));\n        i++;\n        usersarr.push(msg.sender);\n        }\n        else{\n            revert(\"private round is over\");\n        }\n    }\n    function claim() external {\n        // SWC-129-Typographical Error: L559\n        require(claimbool = true,\"claiming amount should be true\");\n       \n        claimamount = usermappublic[msg.sender].amount.add(usermapseed[msg.sender].amount).add(usermapprivate[msg.sender].amount);\n        token.transfer(msg.sender,claimamount);\n        usermappublic[msg.sender].amount=0;\n        usermapprivate[msg.sender].amount=0;\n        usermapseed[msg.sender].amount=0;\n        claimamount=0;\n    }\n    \n    function privatemap(string calldata _first,string calldata _last,string calldata _country,address _address,uint256 _amount,string calldata _aqarid) external onlyOwner{\n        usermapseed[_address] = seedUserInfo({firstname:_first,lastname:_last,country:_country,amount:_amount,phase:seedprice,aqarid:_aqarid,modeofpayment:\"private\"});\n        amountmaptouserseed[_aqarid] = _amount;\n    }\n    function toggleclaim() external onlyOwner returns (uint256) {\n        claimbool = !claimbool;\n    }\n    function toggleseed() external onlyOwner returns (uint256) {\n        seedrun = !seedrun;\n    }\n     function toggleprivate() external onlyOwner returns (uint256) {\n        privaterun = !privaterun;\n    }\n      function togglepublic() external onlyOwner returns (uint256) {\n        publicrun = !publicrun;\n    }\n    \n     function getBnbBalance() public view returns (uint256) {\n        return address(this).balance;\n    }\n\n    function adminTransferBnbFund() external onlyOwner {\n        msg.sender.transfer(address(this).balance);\n    }\n\n    function getContractTokenBalance(IERC20 _token)\n        public\n        view\n        returns (uint256)\n    {\n        return _token.balanceOf(address(this));\n    }\n\n    function fundsWithdrawal(IERC20 _token, uint256 value) external onlyOwner {\n        require(\n            getContractTokenBalance(_token) >= value,\n            \"the contract doesnt have tokens\"\n        );\n        \n      _token.transfer(msg.sender,value);\n\n    }\n    \n  \n}",
        "function": "fundsWithdrawal(address,uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/ImmuneBytes-Aqar Chain-Final Audit Report/code/aq.sol",
        "vulnerability": "Multiple Calls in a Single Transaction (SWC 113)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract aqarchain is Ownable {\n     using SafeMath for uint256;\n     \n     // Info of each user in seed,public and private .\n     \n    struct seedUserInfo {\n        string firstname;\n        string lastname;\n        string country;\n        uint256 amount;    \n        uint256 phase; \n        string aqarid;\n        string modeofpayment;\n    }\n     struct privateUserInfo {\n        string firstname;\n        string lastname;\n        string country;\n        uint256 amount;    \n        uint256 phase; \n        string aqarid;\n        string modeofpayment;\n    }\n     struct publicUserInfo {\n        string firstname;\n        string lastname;\n        string country;\n        uint256 amount;    \n        uint256 phase; \n        string aqarid;\n        string modeofpayment;\n    }\n    //aqar token address\n      IERC20 public token;\n      \n      //useraddress input toh you will get userinfo\n      mapping (address => seedUserInfo) public usermapseed;\n      mapping (address => privateUserInfo) public usermapprivate;\n      mapping (address => publicUserInfo) public usermappublic;\n      \n      // aqar id to get amount invested\n      mapping (string => uint256) public amountmaptouserseed;\n      mapping (string => uint256) public amountmaptouserprivate;\n      mapping (string => uint256) public amountmaptouserpublic;\n      \n      //count of total transactions\n      uint256 public i=0;\n      \n      //claim amount variable \n      uint256 claimamount=0;\n      \n      // prices of various rounds\n      uint256 public seedprice = 4;\n      uint256 public privateprice = 2857;\n      uint256 public publicprice = 22;\n      \n      //soldout amount\n      uint256 public seedamount;\n      uint256 public privateamount;\n      uint256 public publicamount;\n      \n      // variables to turn on and off private and public functions\n      bool public seedrun = false;\n      bool public privaterun = false;\n      bool public publicrun = false;\n      bool public claimbool = false;\n      \n      //all addresses\n      address[] public usersarr;\n      \n      // usdt address\n      IERC20 private usdt = IERC20(0x7ef95a0FEE0Dd31b22626fA2e10Ee6A223F8a684);\n      \n       //router to get bnb price\n       IUniswapV2Router01 pancakerouter1;\n    \n      constructor() public {\n        pancakerouter1 = IUniswapV2Router01(\n            0x9Ac64Cc6e4415144C455BD8E4837Fea55603e5c3\n        );\n    }\n      address[] private arr = [\n        0xae13d989daC2f0dEbFf460aC112a837C89BAa7cd, //WBNB\n        0x7ef95a0FEE0Dd31b22626fA2e10Ee6A223F8a684 //usdt\n    ];\n\n    function getBnbRate() public view returns (uint256) {\n        uint256[] memory amounts = pancakerouter1.getAmountsOut(1e18, arr);\n        return amounts[1];\n    }\n    function settoken(address _token)external onlyOwner{\n        token = IERC20(_token);\n    }\n    function seedusdt(string calldata _first,string calldata _last,string calldata _country,string calldata _id, uint256 _amount)  external returns (string memory aqarid){\n        require(_amount>=100000000000000000000 ,\"Enter amount greater than 100 usd\");\n        require(seedamount<=7000000000000000000000000,\"seed round token sale completed\");\n        // SWC-129-Typographical Error: L444\n        require(seedrun = true,\"seed round is not started or over\");\n\n        if(seedamount.add(_amount.mul(seedprice))<=7000000000000000000000000){\n        usdt.transferFrom(msg.sender,address(this), _amount);\n        usermapseed[msg.sender]=seedUserInfo({firstname:_first,lastname:_last,country:_country,amount: usermapseed[msg.sender].amount.add(_amount.mul(seedprice)),phase:seedprice,aqarid:_id,modeofpayment:\"USDT\"});\n        amountmaptouserseed[_id]=amountmaptouserseed[_id].add(_amount.mul(seedprice));\n        seedamount=seedamount.add(_amount.mul(seedprice));\n        i++;\n        usersarr.push(msg.sender);\n        }\n        else{\n            revert(\"try reducing amount or seed round is finished\");\n        }\n    }\n    \n      function seedbnb(string calldata _first,string calldata _last,string calldata _country,string calldata _id) external payable {\n        // user enter amount of ether which is then transfered into the smart contract and tokens to be given is saved in the mapping\n        require(\n            msg.value.mul(getBnbRate()).div(1e18) >= 100000000000000000000,\n            \"the input bnb amount should be greater than hundred\"\n        );\n        require(seedamount<=7000000000000000000000000,\"seed round token sale completed\");\n        // SWC-129-Typographical Error: L467\n        require(seedrun = true,\"seed round is not started or over\");\n      \n       if(seedamount.add(msg.value.mul(getBnbRate()).mul(seedprice).div(1e18))<=7000000000000000000000000){\n        usermapseed[msg.sender]=seedUserInfo({firstname:_first,lastname:_last,country:_country,amount:usermapseed[msg.sender].amount.add(msg.value.mul(getBnbRate()).mul(seedprice).div(1e18)),phase:seedprice,aqarid:_id,modeofpayment:\"BNB\"});\n        amountmaptouserseed[_id]=amountmaptouserseed[_id].add(msg.value.mul(getBnbRate()).mul(seedprice).div(1e18));\n        seedamount=seedamount.add(msg.value.mul(getBnbRate()).mul(seedprice).div(1e18));\n        i++;\n        usersarr.push(msg.sender);\n        }\n        else{\n            revert(\"try reducing amount or seed round is finished\");\n        }\n    }\n     function privateusdt(string calldata _first,string calldata _last,string calldata _country,string calldata _id, uint256 _amount)  external returns (string memory aqarid){\n        require(_amount>=100000000000000000000,\"Enter amount greter than 100 usd\");\n        require(privateamount<=12000000000000000000000000,\"private round token sale completed\");\n        // SWC-129-Typographical Error: L484\n        require(privaterun=true,\"Private sale haven't started yet\");\n        \n        if(privateamount.add(_amount.mul(privateprice).div(1000))<=12000000000000000000000000){\n        usermapprivate[msg.sender]=privateUserInfo({firstname:_first,lastname:_last,country:_country,amount:usermapprivate[msg.sender].amount.add(_amount.mul(privateprice).div(1000)),phase:privateprice,aqarid:_id,modeofpayment:\"USDT\"});\n        amountmaptouserprivate[_id]= amountmaptouserprivate[_id].add(_amount.mul(privateprice).div(1000));\n        usdt.transferFrom(msg.sender,address(this), _amount);\n        privateamount=privateamount.add(_amount.mul(privateprice).div(1000));\n        i++;\n        usersarr.push(msg.sender);\n        }\n        else{\n            revert(\"private round is over\");\n        }\n    }\n      function privatebnb(string calldata _first,string calldata _last,string calldata _country,string calldata _id) external payable {\n        // user enter amount of ether which is then transfered into the smart contract and tokens to be given is saved in the mapping\n       require(\n           msg.value.mul(getBnbRate()).div(1e18) >= 100000000000000000000 ,\n            \"the input bnb amount should be greater than hundred usd\"\n        );\n        // SWC-129-Typographical Error: L505\n        require(privaterun=true,\"Private sale haven't started yet\");\n        require(privateamount<=12000000000000000000000000,\"private round token sale completed\");\n        \n      if(privateamount.add(msg.value.mul(getBnbRate()).mul(privateprice).div(1e18).div(1000))<=12000000000000000000000000){\n        usermapprivate[msg.sender]=privateUserInfo({firstname:_first,lastname:_last,country:_country,amount:usermapprivate[msg.sender].amount.add(msg.value.mul(getBnbRate()).mul(privateprice).div(1e18).div(1000)),phase:privateprice,aqarid:_id,modeofpayment:\"BNB\"});\n        amountmaptouserprivate[_id]=amountmaptouserprivate[_id].add(msg.value.mul(getBnbRate()).mul(privateprice).div(1e18).div(1000));\n        privateamount=privateamount.add(msg.value.mul(getBnbRate()).mul(privateprice).div(1e18).div(1000));\n        i++;\n        usersarr.push(msg.sender);\n        }\n        else{\n            revert(\"private round is over\");\n        }\n    }\n    \n     function publicusdt(string calldata _first,string calldata _last,string calldata _country,string calldata _id, uint256 _amount)  external returns (string memory aqarid){\n         require(_amount>=100000000000000000000 ,\"Enter amount more than 100 usd\");\n        \n         require(publicamount<=1000000000000000000000000,\"public round token sale completed\");\n        // SWC-129-Typographical Error: L525\n         require(publicrun=true,\"Public sale haven't started yet\");\n        \n        if(publicamount.add(_amount.mul(publicprice).div(10))<=1000000000000000000000000){\n        usermappublic[msg.sender]=publicUserInfo({firstname:_first,lastname:_last,country:_country,amount:usermappublic[msg.sender].amount.add(_amount.mul(publicprice).div(10)),phase:publicprice,aqarid:_id,modeofpayment:\"usdt\"});\n        amountmaptouserpublic[_id]=amountmaptouserpublic[_id].add(_amount.mul(publicprice).div(10));\n        usdt.transferFrom(msg.sender,address(this), _amount);\n        publicamount=publicamount.add(_amount.mul(publicprice).div(10));\n        i++;\n        usersarr.push(msg.sender);\n        }\n        else{\n            revert(\"public round is over\");\n        }\n    }\n    function publicbnb(string calldata _first,string calldata _last,string calldata _country,string calldata _id) external payable {\n        // user enter amount of ether which is then transfered into the smart contract and tokens to be given is saved in the mapping\n        require(\n             msg.value.mul(getBnbRate()).div(1e18) >= 100000000000000000000 ,\n            \"the input bnb amount should be greater than hundred and less than sfivethousand\"\n        );\n        // SWC-129-Typographical Error: L546\n        require(publicrun=true,\"Public sale haven't started yet\");\n        // SWC-123-Requirement Violation: L548\n        require(privateamount<=1000000000000000000000000,\"private round token sale completed\");\n     \n      if(publicamount.add(msg.value.mul(getBnbRate()).mul(publicprice).div(1e18).div(10))<=1000000000000000000000000){\n        usermappublic[msg.sender]=publicUserInfo({firstname:_first,lastname:_last,country:_country,amount:usermappublic[msg.sender].amount.add(msg.value.mul(getBnbRate()).mul(publicprice).div(1e18).div(10)),phase:publicprice,aqarid:_id,modeofpayment:\"BNB\"});\n        amountmaptouserpublic[_id]=amountmaptouserpublic[_id].add(msg.value.mul(getBnbRate()).mul(publicprice).div(1e18).div(10));\n        publicamount=privateamount.add(msg.value.mul(getBnbRate()).mul(publicprice).div(1e18).div(10));\n        i++;\n        usersarr.push(msg.sender);\n        }\n        else{\n            revert(\"private round is over\");\n        }\n    }\n    function claim() external {\n        // SWC-129-Typographical Error: L562\n        require(claimbool = true,\"claiming amount should be true\");\n       \n        claimamount = usermappublic[msg.sender].amount.add(usermapseed[msg.sender].amount).add(usermapprivate[msg.sender].amount);\n        token.transfer(msg.sender,claimamount);\n        usermappublic[msg.sender].amount=0;\n        usermapprivate[msg.sender].amount=0;\n        usermapseed[msg.sender].amount=0;\n        claimamount=0;\n    }\n    \n    function privatemap(string calldata _first,string calldata _last,string calldata _country,address _address,uint256 _amount,string calldata _aqarid) external onlyOwner{\n        usermapseed[_address] = seedUserInfo({firstname:_first,lastname:_last,country:_country,amount:_amount,phase:seedprice,aqarid:_aqarid,modeofpayment:\"private\"});\n        amountmaptouserseed[_aqarid] = _amount;\n    }\n    function toggleclaim() external onlyOwner returns (uint256) {\n        claimbool = !claimbool;\n    }\n    function toggleseed() external onlyOwner returns (uint256) {\n        seedrun = !seedrun;\n    }\n     function toggleprivate() external onlyOwner returns (uint256) {\n        privaterun = !privaterun;\n    }\n      function togglepublic() external onlyOwner returns (uint256) {\n        publicrun = !publicrun;\n    }\n    \n     function getBnbBalance() public view returns (uint256) {\n        return address(this).balance;\n    }\n\n    function adminTransferBnbFund() external onlyOwner {\n        msg.sender.transfer(address(this).balance);\n    }\n\n    function getContractTokenBalance(IERC20 _token)\n        public\n        view\n        returns (uint256)\n    {\n        return _token.balanceOf(address(this));\n    }\n\n    function fundsWithdrawal(IERC20 _token, uint256 value) external onlyOwner {\n        require(\n            getContractTokenBalance(_token) >= value,\n            \"the contract doesnt have tokens\"\n        );\n        \n      _token.transfer(msg.sender,value);\n\n    }\n    \n  \n}",
        "function": "usersarr(uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/ImmuneBytes-Aqar Chain-Audit Report/code/aq.sol",
        "vulnerability": "Exception State (SWC 110)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract aqarchain is Ownable {\n     using SafeMath for uint256;\n     \n     // Info of each user in seed,public and private .\n     \n    struct seedUserInfo {\n        string firstname;\n        string lastname;\n        string country;\n        uint256 amount;    \n        uint256 phase; \n        string aqarid;\n        string modeofpayment;\n    }\n     struct privateUserInfo {\n        string firstname;\n        string lastname;\n        string country;\n        uint256 amount;    \n        uint256 phase; \n        string aqarid;\n        string modeofpayment;\n    }\n     struct publicUserInfo {\n        string firstname;\n        string lastname;\n        string country;\n        uint256 amount;    \n        uint256 phase; \n        string aqarid;\n        string modeofpayment;\n    }\n    //aqar token address\n      IERC20 public token;\n      \n      //useraddress input toh you will get userinfo\n      mapping (address => seedUserInfo) public usermapseed;\n      mapping (address => privateUserInfo) public usermapprivate;\n      mapping (address => publicUserInfo) public usermappublic;\n      \n      // aqar id to get amount invested\n      mapping (string => uint256) public amountmaptouserseed;\n      mapping (string => uint256) public amountmaptouserprivate;\n      mapping (string => uint256) public amountmaptouserpublic;\n      \n      //count of total transactions\n      uint256 public i=0;\n      \n      //claim amount variable \n      uint256 claimamount=0;\n      \n      // prices of various rounds\n      uint256 public seedprice = 4;\n      uint256 public privateprice = 2857;\n      uint256 public publicprice = 22;\n      \n      //soldout amount\n      uint256 public seedamount;\n      uint256 public privateamount;\n      uint256 public publicamount;\n      \n      // variables to turn on and off private and public functions\n      bool public seedrun = false;\n      bool public privaterun = false;\n      bool public publicrun = false;\n      bool public claimbool = false;\n      \n      //all addresses\n      address[] public usersarr;\n      \n      // usdt address\n      IERC20 private usdt = IERC20(0x7ef95a0FEE0Dd31b22626fA2e10Ee6A223F8a684);\n      \n       //router to get bnb price\n       IUniswapV2Router01 pancakerouter1;\n    \n      constructor() public {\n        pancakerouter1 = IUniswapV2Router01(\n            0x9Ac64Cc6e4415144C455BD8E4837Fea55603e5c3\n        );\n    }\n      address[] private arr = [\n        0xae13d989daC2f0dEbFf460aC112a837C89BAa7cd, //WBNB\n        0x7ef95a0FEE0Dd31b22626fA2e10Ee6A223F8a684 //usdt\n    ];\n\n    function getBnbRate() public view returns (uint256) {\n        uint256[] memory amounts = pancakerouter1.getAmountsOut(1e18, arr);\n        return amounts[1];\n    }\n    function settoken(address _token)external onlyOwner{\n        token = IERC20(_token);\n    }\n    function seedusdt(string calldata _first,string calldata _last,string calldata _country,string calldata _id, uint256 _amount)  external returns (string memory aqarid){\n        require(_amount>=100000000000000000000 ,\"Enter amount greater than 100 usd\");\n        require(seedamount<=7000000000000000000000000,\"seed round token sale completed\");\n        // SWC-129-Typographical Error: L444\n        require(seedrun = true,\"seed round is not started or over\");\n\n        if(seedamount.add(_amount.mul(seedprice))<=7000000000000000000000000){\n        usdt.transferFrom(msg.sender,address(this), _amount);\n        usermapseed[msg.sender]=seedUserInfo({firstname:_first,lastname:_last,country:_country,amount: usermapseed[msg.sender].amount.add(_amount.mul(seedprice)),phase:seedprice,aqarid:_id,modeofpayment:\"USDT\"});\n        amountmaptouserseed[_id]=amountmaptouserseed[_id].add(_amount.mul(seedprice));\n        seedamount=seedamount.add(_amount.mul(seedprice));\n        i++;\n        usersarr.push(msg.sender);\n        }\n        else{\n            revert(\"try reducing amount or seed round is finished\");\n        }\n    }\n    \n      function seedbnb(string calldata _first,string calldata _last,string calldata _country,string calldata _id) external payable {\n        // user enter amount of ether which is then transfered into the smart contract and tokens to be given is saved in the mapping\n        require(\n            msg.value.mul(getBnbRate()).div(1e18) >= 100000000000000000000,\n            \"the input bnb amount should be greater than hundred\"\n        );\n        require(seedamount<=7000000000000000000000000,\"seed round token sale completed\");\n        // SWC-129-Typographical Error: L467\n        require(seedrun = true,\"seed round is not started or over\");\n      \n       if(seedamount.add(msg.value.mul(getBnbRate()).mul(seedprice).div(1e18))<=7000000000000000000000000){\n        usermapseed[msg.sender]=seedUserInfo({firstname:_first,lastname:_last,country:_country,amount:usermapseed[msg.sender].amount.add(msg.value.mul(getBnbRate()).mul(seedprice).div(1e18)),phase:seedprice,aqarid:_id,modeofpayment:\"BNB\"});\n        amountmaptouserseed[_id]=amountmaptouserseed[_id].add(msg.value.mul(getBnbRate()).mul(seedprice).div(1e18));\n        seedamount=seedamount.add(msg.value.mul(getBnbRate()).mul(seedprice).div(1e18));\n        i++;\n        usersarr.push(msg.sender);\n        }\n        else{\n            revert(\"try reducing amount or seed round is finished\");\n        }\n    }\n     function privateusdt(string calldata _first,string calldata _last,string calldata _country,string calldata _id, uint256 _amount)  external returns (string memory aqarid){\n        require(_amount>=100000000000000000000,\"Enter amount greter than 100 usd\");\n        require(privateamount<=12000000000000000000000000,\"private round token sale completed\");\n        // SWC-129-Typographical Error: L484\n        require(privaterun=true,\"Private sale haven't started yet\");\n        \n        if(privateamount.add(_amount.mul(privateprice).div(1000))<=12000000000000000000000000){\n        usermapprivate[msg.sender]=privateUserInfo({firstname:_first,lastname:_last,country:_country,amount:usermapprivate[msg.sender].amount.add(_amount.mul(privateprice).div(1000)),phase:privateprice,aqarid:_id,modeofpayment:\"USDT\"});\n        amountmaptouserprivate[_id]= amountmaptouserprivate[_id].add(_amount.mul(privateprice).div(1000));\n        usdt.transferFrom(msg.sender,address(this), _amount);\n        privateamount=privateamount.add(_amount.mul(privateprice).div(1000));\n        i++;\n        usersarr.push(msg.sender);\n        }\n        else{\n            revert(\"private round is over\");\n        }\n    }\n      function privatebnb(string calldata _first,string calldata _last,string calldata _country,string calldata _id) external payable {\n        // user enter amount of ether which is then transfered into the smart contract and tokens to be given is saved in the mapping\n       require(\n           msg.value.mul(getBnbRate()).div(1e18) >= 100000000000000000000 ,\n            \"the input bnb amount should be greater than hundred usd\"\n        );\n        // SWC-129-Typographical Error: L505\n        require(privaterun=true,\"Private sale haven't started yet\");\n        require(privateamount<=12000000000000000000000000,\"private round token sale completed\");\n        \n      if(privateamount.add(msg.value.mul(getBnbRate()).mul(privateprice).div(1e18).div(1000))<=12000000000000000000000000){\n        usermapprivate[msg.sender]=privateUserInfo({firstname:_first,lastname:_last,country:_country,amount:usermapprivate[msg.sender].amount.add(msg.value.mul(getBnbRate()).mul(privateprice).div(1e18).div(1000)),phase:privateprice,aqarid:_id,modeofpayment:\"BNB\"});\n        amountmaptouserprivate[_id]=amountmaptouserprivate[_id].add(msg.value.mul(getBnbRate()).mul(privateprice).div(1e18).div(1000));\n        privateamount=privateamount.add(msg.value.mul(getBnbRate()).mul(privateprice).div(1e18).div(1000));\n        i++;\n        usersarr.push(msg.sender);\n        }\n        else{\n            revert(\"private round is over\");\n        }\n    }\n    \n     function publicusdt(string calldata _first,string calldata _last,string calldata _country,string calldata _id, uint256 _amount)  external returns (string memory aqarid){\n         require(_amount>=100000000000000000000 ,\"Enter amount more than 100 usd\");\n        \n         require(publicamount<=1000000000000000000000000,\"public round token sale completed\");\n        // SWC-129-Typographical Error: L525\n         require(publicrun=true,\"Public sale haven't started yet\");\n        \n        if(publicamount.add(_amount.mul(publicprice).div(10))<=1000000000000000000000000){\n        usermappublic[msg.sender]=publicUserInfo({firstname:_first,lastname:_last,country:_country,amount:usermappublic[msg.sender].amount.add(_amount.mul(publicprice).div(10)),phase:publicprice,aqarid:_id,modeofpayment:\"usdt\"});\n        amountmaptouserpublic[_id]=amountmaptouserpublic[_id].add(_amount.mul(publicprice).div(10));\n        usdt.transferFrom(msg.sender,address(this), _amount);\n        publicamount=publicamount.add(_amount.mul(publicprice).div(10));\n        i++;\n        usersarr.push(msg.sender);\n        }\n        else{\n            revert(\"public round is over\");\n        }\n    }\n    function publicbnb(string calldata _first,string calldata _last,string calldata _country,string calldata _id) external payable {\n        // user enter amount of ether which is then transfered into the smart contract and tokens to be given is saved in the mapping\n        require(\n             msg.value.mul(getBnbRate()).div(1e18) >= 100000000000000000000 ,\n            \"the input bnb amount should be greater than hundred and less than sfivethousand\"\n        );\n        // SWC-129-Typographical Error: L546\n        require(publicrun=true,\"Public sale haven't started yet\");\n        // SWC-123-Requirement Violation: L548\n        require(privateamount<=1000000000000000000000000,\"private round token sale completed\");\n     \n      if(publicamount.add(msg.value.mul(getBnbRate()).mul(publicprice).div(1e18).div(10))<=1000000000000000000000000){\n        usermappublic[msg.sender]=publicUserInfo({firstname:_first,lastname:_last,country:_country,amount:usermappublic[msg.sender].amount.add(msg.value.mul(getBnbRate()).mul(publicprice).div(1e18).div(10)),phase:publicprice,aqarid:_id,modeofpayment:\"BNB\"});\n        amountmaptouserpublic[_id]=amountmaptouserpublic[_id].add(msg.value.mul(getBnbRate()).mul(publicprice).div(1e18).div(10));\n        publicamount=privateamount.add(msg.value.mul(getBnbRate()).mul(publicprice).div(1e18).div(10));\n        i++;\n        usersarr.push(msg.sender);\n        }\n        else{\n            revert(\"private round is over\");\n        }\n    }\n    function claim() external {\n        // SWC-129-Typographical Error: L562\n        require(claimbool = true,\"claiming amount should be true\");\n       \n        claimamount = usermappublic[msg.sender].amount.add(usermapseed[msg.sender].amount).add(usermapprivate[msg.sender].amount);\n        token.transfer(msg.sender,claimamount);\n        usermappublic[msg.sender].amount=0;\n        usermapprivate[msg.sender].amount=0;\n        usermapseed[msg.sender].amount=0;\n        claimamount=0;\n    }\n    \n    function privatemap(string calldata _first,string calldata _last,string calldata _country,address _address,uint256 _amount,string calldata _aqarid) external onlyOwner{\n        usermapseed[_address] = seedUserInfo({firstname:_first,lastname:_last,country:_country,amount:_amount,phase:seedprice,aqarid:_aqarid,modeofpayment:\"private\"});\n        amountmaptouserseed[_aqarid] = _amount;\n    }\n    function toggleclaim() external onlyOwner returns (uint256) {\n        claimbool = !claimbool;\n    }\n    function toggleseed() external onlyOwner returns (uint256) {\n        seedrun = !seedrun;\n    }\n     function toggleprivate() external onlyOwner returns (uint256) {\n        privaterun = !privaterun;\n    }\n      function togglepublic() external onlyOwner returns (uint256) {\n        publicrun = !publicrun;\n    }\n    \n     function getBnbBalance() public view returns (uint256) {\n        return address(this).balance;\n    }\n\n    function adminTransferBnbFund() external onlyOwner {\n        msg.sender.transfer(address(this).balance);\n    }\n\n    function getContractTokenBalance(IERC20 _token)\n        public\n        view\n        returns (uint256)\n    {\n        return _token.balanceOf(address(this));\n    }\n\n    function fundsWithdrawal(IERC20 _token, uint256 value) external onlyOwner {\n        require(\n            getContractTokenBalance(_token) >= value,\n            \"the contract doesnt have tokens\"\n        );\n        \n      _token.transfer(msg.sender,value);\n\n    }\n    \n  \n}",
        "function": "fundsWithdrawal(address,uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/ImmuneBytes-Aqar Chain-Audit Report/code/aq.sol",
        "vulnerability": "External Call To User-Supplied Address (SWC 107)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract aqarchain is Ownable {\n     using SafeMath for uint256;\n     \n     // Info of each user in seed,public and private .\n     \n    struct seedUserInfo {\n        string firstname;\n        string lastname;\n        string country;\n        uint256 amount;    \n        uint256 phase; \n        string aqarid;\n        string modeofpayment;\n    }\n     struct privateUserInfo {\n        string firstname;\n        string lastname;\n        string country;\n        uint256 amount;    \n        uint256 phase; \n        string aqarid;\n        string modeofpayment;\n    }\n     struct publicUserInfo {\n        string firstname;\n        string lastname;\n        string country;\n        uint256 amount;    \n        uint256 phase; \n        string aqarid;\n        string modeofpayment;\n    }\n    //aqar token address\n      IERC20 public token;\n      \n      //useraddress input toh you will get userinfo\n      mapping (address => seedUserInfo) public usermapseed;\n      mapping (address => privateUserInfo) public usermapprivate;\n      mapping (address => publicUserInfo) public usermappublic;\n      \n      // aqar id to get amount invested\n      mapping (string => uint256) public amountmaptouserseed;\n      mapping (string => uint256) public amountmaptouserprivate;\n      mapping (string => uint256) public amountmaptouserpublic;\n      \n      //count of total transactions\n      uint256 public i=0;\n      \n      //claim amount variable \n      uint256 claimamount=0;\n      \n      // prices of various rounds\n      uint256 public seedprice = 4;\n      uint256 public privateprice = 2857;\n      uint256 public publicprice = 22;\n      \n      //soldout amount\n      uint256 public seedamount;\n      uint256 public privateamount;\n      uint256 public publicamount;\n      \n      // variables to turn on and off private and public functions\n      bool public seedrun = false;\n      bool public privaterun = false;\n      bool public publicrun = false;\n      bool public claimbool = false;\n      \n      //all addresses\n      address[] public usersarr;\n      \n      // usdt address\n      IERC20 private usdt = IERC20(0x7ef95a0FEE0Dd31b22626fA2e10Ee6A223F8a684);\n      \n       //router to get bnb price\n       IUniswapV2Router01 pancakerouter1;\n    \n      constructor() public {\n        pancakerouter1 = IUniswapV2Router01(\n            0x9Ac64Cc6e4415144C455BD8E4837Fea55603e5c3\n        );\n    }\n      address[] private arr = [\n        0xae13d989daC2f0dEbFf460aC112a837C89BAa7cd, //WBNB\n        0x7ef95a0FEE0Dd31b22626fA2e10Ee6A223F8a684 //usdt\n    ];\n\n    function getBnbRate() public view returns (uint256) {\n        uint256[] memory amounts = pancakerouter1.getAmountsOut(1e18, arr);\n        return amounts[1];\n    }\n    function settoken(address _token)external onlyOwner{\n        token = IERC20(_token);\n    }\n    function seedusdt(string calldata _first,string calldata _last,string calldata _country,string calldata _id, uint256 _amount)  external returns (string memory aqarid){\n        require(_amount>=100000000000000000000 ,\"Enter amount greater than 100 usd\");\n        require(seedamount<=7000000000000000000000000,\"seed round token sale completed\");\n        // SWC-129-Typographical Error: L444\n        require(seedrun = true,\"seed round is not started or over\");\n\n        if(seedamount.add(_amount.mul(seedprice))<=7000000000000000000000000){\n        usdt.transferFrom(msg.sender,address(this), _amount);\n        usermapseed[msg.sender]=seedUserInfo({firstname:_first,lastname:_last,country:_country,amount: usermapseed[msg.sender].amount.add(_amount.mul(seedprice)),phase:seedprice,aqarid:_id,modeofpayment:\"USDT\"});\n        amountmaptouserseed[_id]=amountmaptouserseed[_id].add(_amount.mul(seedprice));\n        seedamount=seedamount.add(_amount.mul(seedprice));\n        i++;\n        usersarr.push(msg.sender);\n        }\n        else{\n            revert(\"try reducing amount or seed round is finished\");\n        }\n    }\n    \n      function seedbnb(string calldata _first,string calldata _last,string calldata _country,string calldata _id) external payable {\n        // user enter amount of ether which is then transfered into the smart contract and tokens to be given is saved in the mapping\n        require(\n            msg.value.mul(getBnbRate()).div(1e18) >= 100000000000000000000,\n            \"the input bnb amount should be greater than hundred\"\n        );\n        require(seedamount<=7000000000000000000000000,\"seed round token sale completed\");\n        // SWC-129-Typographical Error: L467\n        require(seedrun = true,\"seed round is not started or over\");\n      \n       if(seedamount.add(msg.value.mul(getBnbRate()).mul(seedprice).div(1e18))<=7000000000000000000000000){\n        usermapseed[msg.sender]=seedUserInfo({firstname:_first,lastname:_last,country:_country,amount:usermapseed[msg.sender].amount.add(msg.value.mul(getBnbRate()).mul(seedprice).div(1e18)),phase:seedprice,aqarid:_id,modeofpayment:\"BNB\"});\n        amountmaptouserseed[_id]=amountmaptouserseed[_id].add(msg.value.mul(getBnbRate()).mul(seedprice).div(1e18));\n        seedamount=seedamount.add(msg.value.mul(getBnbRate()).mul(seedprice).div(1e18));\n        i++;\n        usersarr.push(msg.sender);\n        }\n        else{\n            revert(\"try reducing amount or seed round is finished\");\n        }\n    }\n     function privateusdt(string calldata _first,string calldata _last,string calldata _country,string calldata _id, uint256 _amount)  external returns (string memory aqarid){\n        require(_amount>=100000000000000000000,\"Enter amount greter than 100 usd\");\n        require(privateamount<=12000000000000000000000000,\"private round token sale completed\");\n        // SWC-129-Typographical Error: L484\n        require(privaterun=true,\"Private sale haven't started yet\");\n        \n        if(privateamount.add(_amount.mul(privateprice).div(1000))<=12000000000000000000000000){\n        usermapprivate[msg.sender]=privateUserInfo({firstname:_first,lastname:_last,country:_country,amount:usermapprivate[msg.sender].amount.add(_amount.mul(privateprice).div(1000)),phase:privateprice,aqarid:_id,modeofpayment:\"USDT\"});\n        amountmaptouserprivate[_id]= amountmaptouserprivate[_id].add(_amount.mul(privateprice).div(1000));\n        usdt.transferFrom(msg.sender,address(this), _amount);\n        privateamount=privateamount.add(_amount.mul(privateprice).div(1000));\n        i++;\n        usersarr.push(msg.sender);\n        }\n        else{\n            revert(\"private round is over\");\n        }\n    }\n      function privatebnb(string calldata _first,string calldata _last,string calldata _country,string calldata _id) external payable {\n        // user enter amount of ether which is then transfered into the smart contract and tokens to be given is saved in the mapping\n       require(\n           msg.value.mul(getBnbRate()).div(1e18) >= 100000000000000000000 ,\n            \"the input bnb amount should be greater than hundred usd\"\n        );\n        // SWC-129-Typographical Error: L505\n        require(privaterun=true,\"Private sale haven't started yet\");\n        require(privateamount<=12000000000000000000000000,\"private round token sale completed\");\n        \n      if(privateamount.add(msg.value.mul(getBnbRate()).mul(privateprice).div(1e18).div(1000))<=12000000000000000000000000){\n        usermapprivate[msg.sender]=privateUserInfo({firstname:_first,lastname:_last,country:_country,amount:usermapprivate[msg.sender].amount.add(msg.value.mul(getBnbRate()).mul(privateprice).div(1e18).div(1000)),phase:privateprice,aqarid:_id,modeofpayment:\"BNB\"});\n        amountmaptouserprivate[_id]=amountmaptouserprivate[_id].add(msg.value.mul(getBnbRate()).mul(privateprice).div(1e18).div(1000));\n        privateamount=privateamount.add(msg.value.mul(getBnbRate()).mul(privateprice).div(1e18).div(1000));\n        i++;\n        usersarr.push(msg.sender);\n        }\n        else{\n            revert(\"private round is over\");\n        }\n    }\n    \n     function publicusdt(string calldata _first,string calldata _last,string calldata _country,string calldata _id, uint256 _amount)  external returns (string memory aqarid){\n         require(_amount>=100000000000000000000 ,\"Enter amount more than 100 usd\");\n        \n         require(publicamount<=1000000000000000000000000,\"public round token sale completed\");\n        // SWC-129-Typographical Error: L525\n         require(publicrun=true,\"Public sale haven't started yet\");\n        \n        if(publicamount.add(_amount.mul(publicprice).div(10))<=1000000000000000000000000){\n        usermappublic[msg.sender]=publicUserInfo({firstname:_first,lastname:_last,country:_country,amount:usermappublic[msg.sender].amount.add(_amount.mul(publicprice).div(10)),phase:publicprice,aqarid:_id,modeofpayment:\"usdt\"});\n        amountmaptouserpublic[_id]=amountmaptouserpublic[_id].add(_amount.mul(publicprice).div(10));\n        usdt.transferFrom(msg.sender,address(this), _amount);\n        publicamount=publicamount.add(_amount.mul(publicprice).div(10));\n        i++;\n        usersarr.push(msg.sender);\n        }\n        else{\n            revert(\"public round is over\");\n        }\n    }\n    function publicbnb(string calldata _first,string calldata _last,string calldata _country,string calldata _id) external payable {\n        // user enter amount of ether which is then transfered into the smart contract and tokens to be given is saved in the mapping\n        require(\n             msg.value.mul(getBnbRate()).div(1e18) >= 100000000000000000000 ,\n            \"the input bnb amount should be greater than hundred and less than sfivethousand\"\n        );\n        // SWC-129-Typographical Error: L546\n        require(publicrun=true,\"Public sale haven't started yet\");\n        // SWC-123-Requirement Violation: L548\n        require(privateamount<=1000000000000000000000000,\"private round token sale completed\");\n     \n      if(publicamount.add(msg.value.mul(getBnbRate()).mul(publicprice).div(1e18).div(10))<=1000000000000000000000000){\n        usermappublic[msg.sender]=publicUserInfo({firstname:_first,lastname:_last,country:_country,amount:usermappublic[msg.sender].amount.add(msg.value.mul(getBnbRate()).mul(publicprice).div(1e18).div(10)),phase:publicprice,aqarid:_id,modeofpayment:\"BNB\"});\n        amountmaptouserpublic[_id]=amountmaptouserpublic[_id].add(msg.value.mul(getBnbRate()).mul(publicprice).div(1e18).div(10));\n        publicamount=privateamount.add(msg.value.mul(getBnbRate()).mul(publicprice).div(1e18).div(10));\n        i++;\n        usersarr.push(msg.sender);\n        }\n        else{\n            revert(\"private round is over\");\n        }\n    }\n    function claim() external {\n        // SWC-129-Typographical Error: L562\n        require(claimbool = true,\"claiming amount should be true\");\n       \n        claimamount = usermappublic[msg.sender].amount.add(usermapseed[msg.sender].amount).add(usermapprivate[msg.sender].amount);\n        token.transfer(msg.sender,claimamount);\n        usermappublic[msg.sender].amount=0;\n        usermapprivate[msg.sender].amount=0;\n        usermapseed[msg.sender].amount=0;\n        claimamount=0;\n    }\n    \n    function privatemap(string calldata _first,string calldata _last,string calldata _country,address _address,uint256 _amount,string calldata _aqarid) external onlyOwner{\n        usermapseed[_address] = seedUserInfo({firstname:_first,lastname:_last,country:_country,amount:_amount,phase:seedprice,aqarid:_aqarid,modeofpayment:\"private\"});\n        amountmaptouserseed[_aqarid] = _amount;\n    }\n    function toggleclaim() external onlyOwner returns (uint256) {\n        claimbool = !claimbool;\n    }\n    function toggleseed() external onlyOwner returns (uint256) {\n        seedrun = !seedrun;\n    }\n     function toggleprivate() external onlyOwner returns (uint256) {\n        privaterun = !privaterun;\n    }\n      function togglepublic() external onlyOwner returns (uint256) {\n        publicrun = !publicrun;\n    }\n    \n     function getBnbBalance() public view returns (uint256) {\n        return address(this).balance;\n    }\n\n    function adminTransferBnbFund() external onlyOwner {\n        msg.sender.transfer(address(this).balance);\n    }\n\n    function getContractTokenBalance(IERC20 _token)\n        public\n        view\n        returns (uint256)\n    {\n        return _token.balanceOf(address(this));\n    }\n\n    function fundsWithdrawal(IERC20 _token, uint256 value) external onlyOwner {\n        require(\n            getContractTokenBalance(_token) >= value,\n            \"the contract doesnt have tokens\"\n        );\n        \n      _token.transfer(msg.sender,value);\n\n    }\n    \n  \n}",
        "function": "fundsWithdrawal(address,uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/ImmuneBytes-Aqar Chain-Audit Report/code/aq.sol",
        "vulnerability": "Multiple Calls in a Single Transaction (SWC 113)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract Falcons is BEP20 {\n    \n    constructor() BEP20(\"FalconSwaps Token\", \"FALCONS\") public {\n        _mint(msg.sender, 1 * 10**9 * 10**18);\n        _moveDelegates(address(0), _delegates[msg.sender], 1 * 10**9 * 10**18);\n    }\n\n    // Copied and modified from YAM code:\n    // https://github.com/yam-finance/yam-protocol/blob/master/contracts/token/YAMGovernanceStorage.sol\n    // https://github.com/yam-finance/yam-protocol/blob/master/contracts/token/YAMGovernance.sol\n    // Which is copied and modified from COMPOUND:\n    // https://github.com/compound-finance/compound-protocol/blob/master/contracts/Governance/Comp.sol\n\n    \n    mapping (address => address) internal _delegates;\n\n    \n    struct Checkpoint {\n        uint32 fromBlock;\n        uint256 votes;\n    }\n\n    \n    mapping (address => mapping (uint32 => Checkpoint)) public checkpoints;\n\n    \n    mapping (address => uint32) public numCheckpoints;\n\n    \n    bytes32 public constant DOMAIN_TYPEHASH = keccak256(\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\");\n\n    \n    bytes32 public constant DELEGATION_TYPEHASH = keccak256(\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\");\n\n    \n    mapping (address => uint) public nonces;\n\n      \n    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\n\n    \n    event DelegateVotesChanged(address indexed delegate, uint previousBalance, uint newBalance);\n\n    /**\n     * @notice Delegate votes from `msg.sender` to `delegatee`\n     * @param delegator The address to get delegatee for\n     */\n    function delegates(address delegator)\n        external\n        view\n        returns (address)\n    {\n        return _delegates[delegator];\n    }\n\n   /**\n    * @notice Delegate votes from `msg.sender` to `delegatee`\n    * @param delegatee The address to delegate votes to\n    */\n    function delegate(address delegatee) external {\n        return _delegate(msg.sender, delegatee);\n    }\n\n    /**\n     * @notice Delegates votes from signatory to `delegatee`\n     * @param delegatee The address to delegate votes to\n     * @param nonce The contract state required to match the signature\n     * @param expiry The time at which to expire the signature\n     * @param v The recovery byte of the signature\n     * @param r Half of the ECDSA signature pair\n     * @param s Half of the ECDSA signature pair\n     */\n    function delegateBySig(\n        address delegatee,\n        uint nonce,\n        uint expiry,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    )\n        external\n    {\n        bytes32 domainSeparator = keccak256(\n            abi.encode(\n                DOMAIN_TYPEHASH,\n                keccak256(bytes(name())),\n                getChainId(),\n                address(this)\n            )\n        );\n\n        bytes32 structHash = keccak256(\n            abi.encode(\n                DELEGATION_TYPEHASH,\n                delegatee,\n                nonce,\n                expiry\n            )\n        );\n\n        bytes32 digest = keccak256(\n            abi.encodePacked(\n                \"\\x19\\x01\",\n                domainSeparator,\n                structHash\n            )\n        );\n\n        address signatory = ecrecover(digest, v, r, s);\n        require(signatory != address(0), \"FLNS::delegateBySig: invalid signature\");\n        require(nonce == nonces[signatory]++, \"FLNS::delegateBySig: invalid nonce\");\n        require(now <= expiry, \"FLNS::delegateBySig: signature expired\");\n        return _delegate(signatory, delegatee);\n    }\n\n    /**\n     * @notice Gets the current votes balance for `account`\n     * @param account The address to get votes balance\n     * @return The number of current votes for `account`\n     */\n    function getCurrentVotes(address account)\n        external\n        view\n        returns (uint256)\n    {\n        uint32 nCheckpoints = numCheckpoints[account];\n        return nCheckpoints > 0 ? checkpoints[account][nCheckpoints - 1].votes : 0;\n    }\n\n    /**\n     * @notice Determine the prior number of votes for an account as of a block number\n     * @dev Block number must be a finalized block or else this function will revert to prevent misinformation.\n     * @param account The address of the account to check\n     * @param blockNumber The block number to get the vote balance at\n     * @return The number of votes the account had as of the given block\n     */\n    function getPriorVotes(address account, uint blockNumber)\n        external\n        view\n        returns (uint256)\n    {\n        require(blockNumber < block.number, \"FLNS::getPriorVotes: not yet determined\");\n\n        uint32 nCheckpoints = numCheckpoints[account];\n        if (nCheckpoints == 0) {\n            return 0;\n        }\n\n        // First check most recent balance\n        if (checkpoints[account][nCheckpoints - 1].fromBlock <= blockNumber) {\n            return checkpoints[account][nCheckpoints - 1].votes;\n        }\n\n        // Next check implicit zero balance\n        if (checkpoints[account][0].fromBlock > blockNumber) {\n            return 0;\n        }\n\n        uint32 lower = 0;\n        uint32 upper = nCheckpoints - 1;\n        while (upper > lower) {\n            uint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\n            Checkpoint memory cp = checkpoints[account][center];\n            if (cp.fromBlock == blockNumber) {\n                return cp.votes;\n            } else if (cp.fromBlock < blockNumber) {\n                lower = center;\n            } else {\n                upper = center - 1;\n            }\n        }\n        return checkpoints[account][lower].votes;\n    }\n\n    function _delegate(address delegator, address delegatee)\n        internal\n    {\n        address currentDelegate = _delegates[delegator];\n        uint256 delegatorBalance = balanceOf(delegator); // balance of underlying FLNSs (not scaled);\n        _delegates[delegator] = delegatee;\n\n        emit DelegateChanged(delegator, currentDelegate, delegatee);\n\n        _moveDelegates(currentDelegate, delegatee, delegatorBalance);\n    }\n\n    function _moveDelegates(address srcRep, address dstRep, uint256 amount) internal {\n        if (srcRep != dstRep && amount > 0) {\n            if (srcRep != address(0)) {\n                // decrease old representative\n                uint32 srcRepNum = numCheckpoints[srcRep];\n                uint256 srcRepOld = srcRepNum > 0 ? checkpoints[srcRep][srcRepNum - 1].votes : 0;\n                uint256 srcRepNew = srcRepOld.sub(amount);\n                _writeCheckpoint(srcRep, srcRepNum, srcRepOld, srcRepNew);\n            }\n\n            if (dstRep != address(0)) {\n                // increase new representative\n                uint32 dstRepNum = numCheckpoints[dstRep];\n                uint256 dstRepOld = dstRepNum > 0 ? checkpoints[dstRep][dstRepNum - 1].votes : 0;\n                uint256 dstRepNew = dstRepOld.add(amount);\n                _writeCheckpoint(dstRep, dstRepNum, dstRepOld, dstRepNew);\n            }\n        }\n    }\n\n    function _writeCheckpoint(\n        address delegatee,\n        uint32 nCheckpoints,\n        uint256 oldVotes,\n        uint256 newVotes\n    )\n        internal\n    {\n        uint32 blockNumber = safe32(block.number, \"FLNS::_writeCheckpoint: block number exceeds 32 bits\");\n\n        if (nCheckpoints > 0 && checkpoints[delegatee][nCheckpoints - 1].fromBlock == blockNumber) {\n            checkpoints[delegatee][nCheckpoints - 1].votes = newVotes;\n        } else {\n            checkpoints[delegatee][nCheckpoints] = Checkpoint(blockNumber, newVotes);\n            numCheckpoints[delegatee] = nCheckpoints + 1;\n        }\n\n        emit DelegateVotesChanged(delegatee, oldVotes, newVotes);\n    }\n\n    function safe32(uint n, string memory errorMessage) internal pure returns (uint32) {\n        require(n < 2**32, errorMessage);\n        return uint32(n);\n    }\n\n    function getChainId() internal pure returns (uint) {\n        uint256 chainId;\n        assembly { chainId := chainid() }\n        return chainId;\n    }\n}",
        "function": "getPriorVotes(address,uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/QuillAudits-FalconSwap Smart Contract/code/Falcons.sol",
        "vulnerability": "Dependence on predictable environment variable (SWC 120)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract Falcons is BEP20 {\n    \n    constructor() BEP20(\"FalconSwaps Token\", \"FALCONS\") public {\n        _mint(msg.sender, 1 * 10**9 * 10**18);\n        _moveDelegates(address(0), _delegates[msg.sender], 1 * 10**9 * 10**18);\n    }\n\n    // Copied and modified from YAM code:\n    // https://github.com/yam-finance/yam-protocol/blob/master/contracts/token/YAMGovernanceStorage.sol\n    // https://github.com/yam-finance/yam-protocol/blob/master/contracts/token/YAMGovernance.sol\n    // Which is copied and modified from COMPOUND:\n    // https://github.com/compound-finance/compound-protocol/blob/master/contracts/Governance/Comp.sol\n\n    \n    mapping (address => address) internal _delegates;\n\n    \n    struct Checkpoint {\n        uint32 fromBlock;\n        uint256 votes;\n    }\n\n    \n    mapping (address => mapping (uint32 => Checkpoint)) public checkpoints;\n\n    \n    mapping (address => uint32) public numCheckpoints;\n\n    \n    bytes32 public constant DOMAIN_TYPEHASH = keccak256(\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\");\n\n    \n    bytes32 public constant DELEGATION_TYPEHASH = keccak256(\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\");\n\n    \n    mapping (address => uint) public nonces;\n\n      \n    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\n\n    \n    event DelegateVotesChanged(address indexed delegate, uint previousBalance, uint newBalance);\n\n    /**\n     * @notice Delegate votes from `msg.sender` to `delegatee`\n     * @param delegator The address to get delegatee for\n     */\n    function delegates(address delegator)\n        external\n        view\n        returns (address)\n    {\n        return _delegates[delegator];\n    }\n\n   /**\n    * @notice Delegate votes from `msg.sender` to `delegatee`\n    * @param delegatee The address to delegate votes to\n    */\n    function delegate(address delegatee) external {\n        return _delegate(msg.sender, delegatee);\n    }\n\n    /**\n     * @notice Delegates votes from signatory to `delegatee`\n     * @param delegatee The address to delegate votes to\n     * @param nonce The contract state required to match the signature\n     * @param expiry The time at which to expire the signature\n     * @param v The recovery byte of the signature\n     * @param r Half of the ECDSA signature pair\n     * @param s Half of the ECDSA signature pair\n     */\n    function delegateBySig(\n        address delegatee,\n        uint nonce,\n        uint expiry,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    )\n        external\n    {\n        bytes32 domainSeparator = keccak256(\n            abi.encode(\n                DOMAIN_TYPEHASH,\n                keccak256(bytes(name())),\n                getChainId(),\n                address(this)\n            )\n        );\n\n        bytes32 structHash = keccak256(\n            abi.encode(\n                DELEGATION_TYPEHASH,\n                delegatee,\n                nonce,\n                expiry\n            )\n        );\n\n        bytes32 digest = keccak256(\n            abi.encodePacked(\n                \"\\x19\\x01\",\n                domainSeparator,\n                structHash\n            )\n        );\n\n        address signatory = ecrecover(digest, v, r, s);\n        require(signatory != address(0), \"FLNS::delegateBySig: invalid signature\");\n        require(nonce == nonces[signatory]++, \"FLNS::delegateBySig: invalid nonce\");\n        require(now <= expiry, \"FLNS::delegateBySig: signature expired\");\n        return _delegate(signatory, delegatee);\n    }\n\n    /**\n     * @notice Gets the current votes balance for `account`\n     * @param account The address to get votes balance\n     * @return The number of current votes for `account`\n     */\n    function getCurrentVotes(address account)\n        external\n        view\n        returns (uint256)\n    {\n        uint32 nCheckpoints = numCheckpoints[account];\n        return nCheckpoints > 0 ? checkpoints[account][nCheckpoints - 1].votes : 0;\n    }\n\n    /**\n     * @notice Determine the prior number of votes for an account as of a block number\n     * @dev Block number must be a finalized block or else this function will revert to prevent misinformation.\n     * @param account The address of the account to check\n     * @param blockNumber The block number to get the vote balance at\n     * @return The number of votes the account had as of the given block\n     */\n    function getPriorVotes(address account, uint blockNumber)\n        external\n        view\n        returns (uint256)\n    {\n        require(blockNumber < block.number, \"FLNS::getPriorVotes: not yet determined\");\n\n        uint32 nCheckpoints = numCheckpoints[account];\n        if (nCheckpoints == 0) {\n            return 0;\n        }\n\n        // First check most recent balance\n        if (checkpoints[account][nCheckpoints - 1].fromBlock <= blockNumber) {\n            return checkpoints[account][nCheckpoints - 1].votes;\n        }\n\n        // Next check implicit zero balance\n        if (checkpoints[account][0].fromBlock > blockNumber) {\n            return 0;\n        }\n\n        uint32 lower = 0;\n        uint32 upper = nCheckpoints - 1;\n        while (upper > lower) {\n            uint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\n            Checkpoint memory cp = checkpoints[account][center];\n            if (cp.fromBlock == blockNumber) {\n                return cp.votes;\n            } else if (cp.fromBlock < blockNumber) {\n                lower = center;\n            } else {\n                upper = center - 1;\n            }\n        }\n        return checkpoints[account][lower].votes;\n    }\n\n    function _delegate(address delegator, address delegatee)\n        internal\n    {\n        address currentDelegate = _delegates[delegator];\n        uint256 delegatorBalance = balanceOf(delegator); // balance of underlying FLNSs (not scaled);\n        _delegates[delegator] = delegatee;\n\n        emit DelegateChanged(delegator, currentDelegate, delegatee);\n\n        _moveDelegates(currentDelegate, delegatee, delegatorBalance);\n    }\n\n    function _moveDelegates(address srcRep, address dstRep, uint256 amount) internal {\n        if (srcRep != dstRep && amount > 0) {\n            if (srcRep != address(0)) {\n                // decrease old representative\n                uint32 srcRepNum = numCheckpoints[srcRep];\n                uint256 srcRepOld = srcRepNum > 0 ? checkpoints[srcRep][srcRepNum - 1].votes : 0;\n                uint256 srcRepNew = srcRepOld.sub(amount);\n                _writeCheckpoint(srcRep, srcRepNum, srcRepOld, srcRepNew);\n            }\n\n            if (dstRep != address(0)) {\n                // increase new representative\n                uint32 dstRepNum = numCheckpoints[dstRep];\n                uint256 dstRepOld = dstRepNum > 0 ? checkpoints[dstRep][dstRepNum - 1].votes : 0;\n                uint256 dstRepNew = dstRepOld.add(amount);\n                _writeCheckpoint(dstRep, dstRepNum, dstRepOld, dstRepNew);\n            }\n        }\n    }\n\n    function _writeCheckpoint(\n        address delegatee,\n        uint32 nCheckpoints,\n        uint256 oldVotes,\n        uint256 newVotes\n    )\n        internal\n    {\n        uint32 blockNumber = safe32(block.number, \"FLNS::_writeCheckpoint: block number exceeds 32 bits\");\n\n        if (nCheckpoints > 0 && checkpoints[delegatee][nCheckpoints - 1].fromBlock == blockNumber) {\n            checkpoints[delegatee][nCheckpoints - 1].votes = newVotes;\n        } else {\n            checkpoints[delegatee][nCheckpoints] = Checkpoint(blockNumber, newVotes);\n            numCheckpoints[delegatee] = nCheckpoints + 1;\n        }\n\n        emit DelegateVotesChanged(delegatee, oldVotes, newVotes);\n    }\n\n    function safe32(uint n, string memory errorMessage) internal pure returns (uint32) {\n        require(n < 2**32, errorMessage);\n        return uint32(n);\n    }\n\n    function getChainId() internal pure returns (uint) {\n        uint256 chainId;\n        assembly { chainId := chainid() }\n        return chainId;\n    }\n}",
        "function": "delegateBySig(address,uint256,uint256,uint8,bytes32,bytes32)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/QuillAudits-FalconSwap Smart Contract/code/Falcons.sol",
        "vulnerability": "Dependence on predictable environment variable (SWC 116)",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract Falcons is BEP20 {\n    \n    constructor() BEP20(\"FalconSwaps Token\", \"FALCONS\") public {\n        _mint(msg.sender, 1 * 10**9 * 10**18);\n        _moveDelegates(address(0), _delegates[msg.sender], 1 * 10**9 * 10**18);\n    }\n\n    // Copied and modified from YAM code:\n    // https://github.com/yam-finance/yam-protocol/blob/master/contracts/token/YAMGovernanceStorage.sol\n    // https://github.com/yam-finance/yam-protocol/blob/master/contracts/token/YAMGovernance.sol\n    // Which is copied and modified from COMPOUND:\n    // https://github.com/compound-finance/compound-protocol/blob/master/contracts/Governance/Comp.sol\n\n    \n    mapping (address => address) internal _delegates;\n\n    \n    struct Checkpoint {\n        uint32 fromBlock;\n        uint256 votes;\n    }\n\n    \n    mapping (address => mapping (uint32 => Checkpoint)) public checkpoints;\n\n    \n    mapping (address => uint32) public numCheckpoints;\n\n    \n    bytes32 public constant DOMAIN_TYPEHASH = keccak256(\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\");\n\n    \n    bytes32 public constant DELEGATION_TYPEHASH = keccak256(\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\");\n\n    \n    mapping (address => uint) public nonces;\n\n      \n    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\n\n    \n    event DelegateVotesChanged(address indexed delegate, uint previousBalance, uint newBalance);\n\n    /**\n     * @notice Delegate votes from `msg.sender` to `delegatee`\n     * @param delegator The address to get delegatee for\n     */\n    function delegates(address delegator)\n        external\n        view\n        returns (address)\n    {\n        return _delegates[delegator];\n    }\n\n   /**\n    * @notice Delegate votes from `msg.sender` to `delegatee`\n    * @param delegatee The address to delegate votes to\n    */\n    function delegate(address delegatee) external {\n        return _delegate(msg.sender, delegatee);\n    }\n\n    /**\n     * @notice Delegates votes from signatory to `delegatee`\n     * @param delegatee The address to delegate votes to\n     * @param nonce The contract state required to match the signature\n     * @param expiry The time at which to expire the signature\n     * @param v The recovery byte of the signature\n     * @param r Half of the ECDSA signature pair\n     * @param s Half of the ECDSA signature pair\n     */\n    function delegateBySig(\n        address delegatee,\n        uint nonce,\n        uint expiry,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    )\n        external\n    {\n        bytes32 domainSeparator = keccak256(\n            abi.encode(\n                DOMAIN_TYPEHASH,\n                keccak256(bytes(name())),\n                getChainId(),\n                address(this)\n            )\n        );\n\n        bytes32 structHash = keccak256(\n            abi.encode(\n                DELEGATION_TYPEHASH,\n                delegatee,\n                nonce,\n                expiry\n            )\n        );\n\n        bytes32 digest = keccak256(\n            abi.encodePacked(\n                \"\\x19\\x01\",\n                domainSeparator,\n                structHash\n            )\n        );\n\n        address signatory = ecrecover(digest, v, r, s);\n        require(signatory != address(0), \"FLNS::delegateBySig: invalid signature\");\n        require(nonce == nonces[signatory]++, \"FLNS::delegateBySig: invalid nonce\");\n        require(now <= expiry, \"FLNS::delegateBySig: signature expired\");\n        return _delegate(signatory, delegatee);\n    }\n\n    /**\n     * @notice Gets the current votes balance for `account`\n     * @param account The address to get votes balance\n     * @return The number of current votes for `account`\n     */\n    function getCurrentVotes(address account)\n        external\n        view\n        returns (uint256)\n    {\n        uint32 nCheckpoints = numCheckpoints[account];\n        return nCheckpoints > 0 ? checkpoints[account][nCheckpoints - 1].votes : 0;\n    }\n\n    /**\n     * @notice Determine the prior number of votes for an account as of a block number\n     * @dev Block number must be a finalized block or else this function will revert to prevent misinformation.\n     * @param account The address of the account to check\n     * @param blockNumber The block number to get the vote balance at\n     * @return The number of votes the account had as of the given block\n     */\n    function getPriorVotes(address account, uint blockNumber)\n        external\n        view\n        returns (uint256)\n    {\n        require(blockNumber < block.number, \"FLNS::getPriorVotes: not yet determined\");\n\n        uint32 nCheckpoints = numCheckpoints[account];\n        if (nCheckpoints == 0) {\n            return 0;\n        }\n\n        // First check most recent balance\n        if (checkpoints[account][nCheckpoints - 1].fromBlock <= blockNumber) {\n            return checkpoints[account][nCheckpoints - 1].votes;\n        }\n\n        // Next check implicit zero balance\n        if (checkpoints[account][0].fromBlock > blockNumber) {\n            return 0;\n        }\n\n        uint32 lower = 0;\n        uint32 upper = nCheckpoints - 1;\n        while (upper > lower) {\n            uint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\n            Checkpoint memory cp = checkpoints[account][center];\n            if (cp.fromBlock == blockNumber) {\n                return cp.votes;\n            } else if (cp.fromBlock < blockNumber) {\n                lower = center;\n            } else {\n                upper = center - 1;\n            }\n        }\n        return checkpoints[account][lower].votes;\n    }\n\n    function _delegate(address delegator, address delegatee)\n        internal\n    {\n        address currentDelegate = _delegates[delegator];\n        uint256 delegatorBalance = balanceOf(delegator); // balance of underlying FLNSs (not scaled);\n        _delegates[delegator] = delegatee;\n\n        emit DelegateChanged(delegator, currentDelegate, delegatee);\n\n        _moveDelegates(currentDelegate, delegatee, delegatorBalance);\n    }\n\n    function _moveDelegates(address srcRep, address dstRep, uint256 amount) internal {\n        if (srcRep != dstRep && amount > 0) {\n            if (srcRep != address(0)) {\n                // decrease old representative\n                uint32 srcRepNum = numCheckpoints[srcRep];\n                uint256 srcRepOld = srcRepNum > 0 ? checkpoints[srcRep][srcRepNum - 1].votes : 0;\n                uint256 srcRepNew = srcRepOld.sub(amount);\n                _writeCheckpoint(srcRep, srcRepNum, srcRepOld, srcRepNew);\n            }\n\n            if (dstRep != address(0)) {\n                // increase new representative\n                uint32 dstRepNum = numCheckpoints[dstRep];\n                uint256 dstRepOld = dstRepNum > 0 ? checkpoints[dstRep][dstRepNum - 1].votes : 0;\n                uint256 dstRepNew = dstRepOld.add(amount);\n                _writeCheckpoint(dstRep, dstRepNum, dstRepOld, dstRepNew);\n            }\n        }\n    }\n\n    function _writeCheckpoint(\n        address delegatee,\n        uint32 nCheckpoints,\n        uint256 oldVotes,\n        uint256 newVotes\n    )\n        internal\n    {\n        uint32 blockNumber = safe32(block.number, \"FLNS::_writeCheckpoint: block number exceeds 32 bits\");\n\n        if (nCheckpoints > 0 && checkpoints[delegatee][nCheckpoints - 1].fromBlock == blockNumber) {\n            checkpoints[delegatee][nCheckpoints - 1].votes = newVotes;\n        } else {\n            checkpoints[delegatee][nCheckpoints] = Checkpoint(blockNumber, newVotes);\n            numCheckpoints[delegatee] = nCheckpoints + 1;\n        }\n\n        emit DelegateVotesChanged(delegatee, oldVotes, newVotes);\n    }\n\n    function safe32(uint n, string memory errorMessage) internal pure returns (uint32) {\n        require(n < 2**32, errorMessage);\n        return uint32(n);\n    }\n\n    function getChainId() internal pure returns (uint) {\n        uint256 chainId;\n        assembly { chainId := chainid() }\n        return chainId;\n    }\n}",
        "function": "delegate(address)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/QuillAudits-FalconSwap Smart Contract/code/Falcons.sol",
        "vulnerability": "Dependence on predictable environment variable (SWC 120)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract ProjectWalletAuthoriser is Ownable {\n\n    address private authoriser;\n\n    /**\n    * @dev Throws if called by any account other than the authoriser.\n    */\n    modifier onlyAuthoriser() {\n        require(msg.sender == authoriser, \"Permission denied\");\n        _;\n    }\n\n    function setAuthoriser(address _authoriser) public onlyOwner returns (bool)\n    {\n        authoriser = _authoriser;\n    }\n\n  /**\n   * @dev Transfer the amount of tokens from the spender to the receiver.\n   * @param _sender The address which will spend the funds.\n   * @param _receiver The address which will receiver the funds.\n   * @param _amt The amount of tokens to send.\n   */\n    function transfer(\n        address _sender, \n        address _receiver, \n        uint256 _amt\n    )\n    public onlyAuthoriser\n    returns (bool)\n    {\n        // SWC-104-Unchecked Call Return Value: L38\n        ProjectWallet(_sender).transfer(_receiver, _amt);\n    }\n\n}",
        "function": "transfer(address,address,uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Iosiro-ixo Smart Contract Audit/ixo-solidity-417c40f1bd6600e5d1d8b49d136f2b97a098591c/contracts/project/ProjectWalletAuthoriser.sol",
        "vulnerability": "External Call To User-Supplied Address (SWC 107)",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract OVM_ProxySequencerEntrypoint {\n\n    /*********************\n     * Fallback Function *\n     *********************/\n\n    fallback()\n        external\n    {\n        //SWC-104-Unchecked Call Return Value: L26-L30\n        Lib_SafeExecutionManagerWrapper.safeDELEGATECALL(\n            gasleft(),\n            _getImplementation(),\n            msg.data\n        );\n    }\n\n\n    /********************\n     * Public Functions *\n     ********************/\n\n    function init(\n        address _implementation,\n        address _owner\n    )\n        external\n    {\n        Lib_SafeExecutionManagerWrapper.safeREQUIRE(\n            _getOwner() == address(0),\n            \"ProxySequencerEntrypoint has already been inited\"\n        );\n        _setOwner(_owner);\n        _setImplementation(_implementation);\n    }\n\n    function upgrade(\n        address _implementation\n    )\n        external\n    {\n        Lib_SafeExecutionManagerWrapper.safeREQUIRE(\n            _getOwner() == Lib_SafeExecutionManagerWrapper.safeCALLER(),\n            \"Only owner can upgrade the Entrypoint\"\n        );\n\n        _setImplementation(_implementation);\n    }\n\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    function _setImplementation(\n        address _implementation\n    )\n        internal\n    {\n        Lib_SafeExecutionManagerWrapper.safeSSTORE(\n            bytes32(uint256(0)),\n            bytes32(uint256(uint160(_implementation)))\n        );\n    }\n\n    function _getImplementation()\n        internal\n        returns (\n            address _implementation\n        )\n    {\n        return address(uint160(uint256(\n            Lib_SafeExecutionManagerWrapper.safeSLOAD(\n                bytes32(uint256(0))\n            )\n        )));\n    }\n\n    function _setOwner(\n        address _owner\n    )\n        internal\n    {\n        Lib_SafeExecutionManagerWrapper.safeSSTORE(\n            bytes32(uint256(1)),\n            bytes32(uint256(uint160(_owner)))\n        );\n    }\n\n    function _getOwner()\n        internal\n        returns (\n            address _owner\n        )\n    {\n        return address(uint160(uint256(\n            Lib_SafeExecutionManagerWrapper.safeSLOAD(\n                bytes32(uint256(1))\n            )\n        )));\n    }\n}",
        "function": "upgrade(address)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/openzeppelin-Optimism/contracts-18e128343731b9bde23812ce932e24d81440b6b7/contracts/optimistic-ethereum/OVM/precompiles/OVM_ProxySequencerEntrypoint.sol",
        "vulnerability": "External Call To User-Supplied Address (SWC 107)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract OVM_ProxySequencerEntrypoint {\n\n    /*********************\n     * Fallback Function *\n     *********************/\n\n    fallback()\n        external\n    {\n        //SWC-104-Unchecked Call Return Value: L26-L30\n        Lib_SafeExecutionManagerWrapper.safeDELEGATECALL(\n            gasleft(),\n            _getImplementation(),\n            msg.data\n        );\n    }\n\n\n    /********************\n     * Public Functions *\n     ********************/\n\n    function init(\n        address _implementation,\n        address _owner\n    )\n        external\n    {\n        Lib_SafeExecutionManagerWrapper.safeREQUIRE(\n            _getOwner() == address(0),\n            \"ProxySequencerEntrypoint has already been inited\"\n        );\n        _setOwner(_owner);\n        _setImplementation(_implementation);\n    }\n\n    function upgrade(\n        address _implementation\n    )\n        external\n    {\n        Lib_SafeExecutionManagerWrapper.safeREQUIRE(\n            _getOwner() == Lib_SafeExecutionManagerWrapper.safeCALLER(),\n            \"Only owner can upgrade the Entrypoint\"\n        );\n\n        _setImplementation(_implementation);\n    }\n\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    function _setImplementation(\n        address _implementation\n    )\n        internal\n    {\n        Lib_SafeExecutionManagerWrapper.safeSSTORE(\n            bytes32(uint256(0)),\n            bytes32(uint256(uint160(_implementation)))\n        );\n    }\n\n    function _getImplementation()\n        internal\n        returns (\n            address _implementation\n        )\n    {\n        return address(uint160(uint256(\n            Lib_SafeExecutionManagerWrapper.safeSLOAD(\n                bytes32(uint256(0))\n            )\n        )));\n    }\n\n    function _setOwner(\n        address _owner\n    )\n        internal\n    {\n        Lib_SafeExecutionManagerWrapper.safeSSTORE(\n            bytes32(uint256(1)),\n            bytes32(uint256(uint160(_owner)))\n        );\n    }\n\n    function _getOwner()\n        internal\n        returns (\n            address _owner\n        )\n    {\n        return address(uint160(uint256(\n            Lib_SafeExecutionManagerWrapper.safeSLOAD(\n                bytes32(uint256(1))\n            )\n        )));\n    }\n}",
        "function": "fallback",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/openzeppelin-Optimism/contracts-18e128343731b9bde23812ce932e24d81440b6b7/contracts/optimistic-ethereum/OVM/precompiles/OVM_ProxySequencerEntrypoint.sol",
        "vulnerability": "External Call To User-Supplied Address (SWC 107)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract OVM_ProxySequencerEntrypoint {\n\n    /*********************\n     * Fallback Function *\n     *********************/\n\n    fallback()\n        external\n    {\n        //SWC-104-Unchecked Call Return Value: L26-L30\n        Lib_SafeExecutionManagerWrapper.safeDELEGATECALL(\n            gasleft(),\n            _getImplementation(),\n            msg.data\n        );\n    }\n\n\n    /********************\n     * Public Functions *\n     ********************/\n\n    function init(\n        address _implementation,\n        address _owner\n    )\n        external\n    {\n        Lib_SafeExecutionManagerWrapper.safeREQUIRE(\n            _getOwner() == address(0),\n            \"ProxySequencerEntrypoint has already been inited\"\n        );\n        _setOwner(_owner);\n        _setImplementation(_implementation);\n    }\n\n    function upgrade(\n        address _implementation\n    )\n        external\n    {\n        Lib_SafeExecutionManagerWrapper.safeREQUIRE(\n            _getOwner() == Lib_SafeExecutionManagerWrapper.safeCALLER(),\n            \"Only owner can upgrade the Entrypoint\"\n        );\n\n        _setImplementation(_implementation);\n    }\n\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    function _setImplementation(\n        address _implementation\n    )\n        internal\n    {\n        Lib_SafeExecutionManagerWrapper.safeSSTORE(\n            bytes32(uint256(0)),\n            bytes32(uint256(uint160(_implementation)))\n        );\n    }\n\n    function _getImplementation()\n        internal\n        returns (\n            address _implementation\n        )\n    {\n        return address(uint160(uint256(\n            Lib_SafeExecutionManagerWrapper.safeSLOAD(\n                bytes32(uint256(0))\n            )\n        )));\n    }\n\n    function _setOwner(\n        address _owner\n    )\n        internal\n    {\n        Lib_SafeExecutionManagerWrapper.safeSSTORE(\n            bytes32(uint256(1)),\n            bytes32(uint256(uint160(_owner)))\n        );\n    }\n\n    function _getOwner()\n        internal\n        returns (\n            address _owner\n        )\n    {\n        return address(uint160(uint256(\n            Lib_SafeExecutionManagerWrapper.safeSLOAD(\n                bytes32(uint256(1))\n            )\n        )));\n    }\n}",
        "function": "upgrade(address)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/openzeppelin-Optimism/contracts-18e128343731b9bde23812ce932e24d81440b6b7/contracts/optimistic-ethereum/OVM/precompiles/OVM_ProxySequencerEntrypoint.sol",
        "vulnerability": "Multiple Calls in a Single Transaction (SWC 113)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract OVM_ProxySequencerEntrypoint {\n\n    /*********************\n     * Fallback Function *\n     *********************/\n\n    fallback()\n        external\n    {\n        //SWC-104-Unchecked Call Return Value: L26-L30\n        Lib_SafeExecutionManagerWrapper.safeDELEGATECALL(\n            gasleft(),\n            _getImplementation(),\n            msg.data\n        );\n    }\n\n\n    /********************\n     * Public Functions *\n     ********************/\n\n    function init(\n        address _implementation,\n        address _owner\n    )\n        external\n    {\n        Lib_SafeExecutionManagerWrapper.safeREQUIRE(\n            _getOwner() == address(0),\n            \"ProxySequencerEntrypoint has already been inited\"\n        );\n        _setOwner(_owner);\n        _setImplementation(_implementation);\n    }\n\n    function upgrade(\n        address _implementation\n    )\n        external\n    {\n        Lib_SafeExecutionManagerWrapper.safeREQUIRE(\n            _getOwner() == Lib_SafeExecutionManagerWrapper.safeCALLER(),\n            \"Only owner can upgrade the Entrypoint\"\n        );\n\n        _setImplementation(_implementation);\n    }\n\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    function _setImplementation(\n        address _implementation\n    )\n        internal\n    {\n        Lib_SafeExecutionManagerWrapper.safeSSTORE(\n            bytes32(uint256(0)),\n            bytes32(uint256(uint160(_implementation)))\n        );\n    }\n\n    function _getImplementation()\n        internal\n        returns (\n            address _implementation\n        )\n    {\n        return address(uint160(uint256(\n            Lib_SafeExecutionManagerWrapper.safeSLOAD(\n                bytes32(uint256(0))\n            )\n        )));\n    }\n\n    function _setOwner(\n        address _owner\n    )\n        internal\n    {\n        Lib_SafeExecutionManagerWrapper.safeSSTORE(\n            bytes32(uint256(1)),\n            bytes32(uint256(uint160(_owner)))\n        );\n    }\n\n    function _getOwner()\n        internal\n        returns (\n            address _owner\n        )\n    {\n        return address(uint160(uint256(\n            Lib_SafeExecutionManagerWrapper.safeSLOAD(\n                bytes32(uint256(1))\n            )\n        )));\n    }\n}",
        "function": "init(address,address)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/openzeppelin-Optimism/contracts-18e128343731b9bde23812ce932e24d81440b6b7/contracts/optimistic-ethereum/OVM/precompiles/OVM_ProxySequencerEntrypoint.sol",
        "vulnerability": "Multiple Calls in a Single Transaction (SWC 113)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract OVM_ProxySequencerEntrypoint {\n\n    /*********************\n     * Fallback Function *\n     *********************/\n\n    fallback()\n        external\n    {\n        //SWC-104-Unchecked Call Return Value: L26-L30\n        Lib_SafeExecutionManagerWrapper.safeDELEGATECALL(\n            gasleft(),\n            _getImplementation(),\n            msg.data\n        );\n    }\n\n\n    /********************\n     * Public Functions *\n     ********************/\n\n    function init(\n        address _implementation,\n        address _owner\n    )\n        external\n    {\n        Lib_SafeExecutionManagerWrapper.safeREQUIRE(\n            _getOwner() == address(0),\n            \"ProxySequencerEntrypoint has already been inited\"\n        );\n        _setOwner(_owner);\n        _setImplementation(_implementation);\n    }\n\n    function upgrade(\n        address _implementation\n    )\n        external\n    {\n        Lib_SafeExecutionManagerWrapper.safeREQUIRE(\n            _getOwner() == Lib_SafeExecutionManagerWrapper.safeCALLER(),\n            \"Only owner can upgrade the Entrypoint\"\n        );\n\n        _setImplementation(_implementation);\n    }\n\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    function _setImplementation(\n        address _implementation\n    )\n        internal\n    {\n        Lib_SafeExecutionManagerWrapper.safeSSTORE(\n            bytes32(uint256(0)),\n            bytes32(uint256(uint160(_implementation)))\n        );\n    }\n\n    function _getImplementation()\n        internal\n        returns (\n            address _implementation\n        )\n    {\n        return address(uint160(uint256(\n            Lib_SafeExecutionManagerWrapper.safeSLOAD(\n                bytes32(uint256(0))\n            )\n        )));\n    }\n\n    function _setOwner(\n        address _owner\n    )\n        internal\n    {\n        Lib_SafeExecutionManagerWrapper.safeSSTORE(\n            bytes32(uint256(1)),\n            bytes32(uint256(uint160(_owner)))\n        );\n    }\n\n    function _getOwner()\n        internal\n        returns (\n            address _owner\n        )\n    {\n        return address(uint160(uint256(\n            Lib_SafeExecutionManagerWrapper.safeSLOAD(\n                bytes32(uint256(1))\n            )\n        )));\n    }\n}",
        "function": "upgrade(address)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/openzeppelin-Optimism/contracts-18e128343731b9bde23812ce932e24d81440b6b7/contracts/optimistic-ethereum/OVM/precompiles/OVM_ProxySequencerEntrypoint.sol",
        "vulnerability": "Integer Arithmetic Bugs (SWC 101)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract OVM_ProxySequencerEntrypoint {\n\n    /*********************\n     * Fallback Function *\n     *********************/\n\n    fallback()\n        external\n    {\n        //SWC-104-Unchecked Call Return Value: L26-L30\n        Lib_SafeExecutionManagerWrapper.safeDELEGATECALL(\n            gasleft(),\n            _getImplementation(),\n            msg.data\n        );\n    }\n\n\n    /********************\n     * Public Functions *\n     ********************/\n\n    function init(\n        address _implementation,\n        address _owner\n    )\n        external\n    {\n        Lib_SafeExecutionManagerWrapper.safeREQUIRE(\n            _getOwner() == address(0),\n            \"ProxySequencerEntrypoint has already been inited\"\n        );\n        _setOwner(_owner);\n        _setImplementation(_implementation);\n    }\n\n    function upgrade(\n        address _implementation\n    )\n        external\n    {\n        Lib_SafeExecutionManagerWrapper.safeREQUIRE(\n            _getOwner() == Lib_SafeExecutionManagerWrapper.safeCALLER(),\n            \"Only owner can upgrade the Entrypoint\"\n        );\n\n        _setImplementation(_implementation);\n    }\n\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    function _setImplementation(\n        address _implementation\n    )\n        internal\n    {\n        Lib_SafeExecutionManagerWrapper.safeSSTORE(\n            bytes32(uint256(0)),\n            bytes32(uint256(uint160(_implementation)))\n        );\n    }\n\n    function _getImplementation()\n        internal\n        returns (\n            address _implementation\n        )\n    {\n        return address(uint160(uint256(\n            Lib_SafeExecutionManagerWrapper.safeSLOAD(\n                bytes32(uint256(0))\n            )\n        )));\n    }\n\n    function _setOwner(\n        address _owner\n    )\n        internal\n    {\n        Lib_SafeExecutionManagerWrapper.safeSSTORE(\n            bytes32(uint256(1)),\n            bytes32(uint256(uint160(_owner)))\n        );\n    }\n\n    function _getOwner()\n        internal\n        returns (\n            address _owner\n        )\n    {\n        return address(uint160(uint256(\n            Lib_SafeExecutionManagerWrapper.safeSLOAD(\n                bytes32(uint256(1))\n            )\n        )));\n    }\n}",
        "function": "init(address,address)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/openzeppelin-Optimism/contracts-18e128343731b9bde23812ce932e24d81440b6b7/contracts/optimistic-ethereum/OVM/precompiles/OVM_ProxySequencerEntrypoint.sol",
        "vulnerability": "Integer Arithmetic Bugs (SWC 101)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract Admin {\n\n    // Listing all admins\n    address [] public admins;\n\n    // Modifier for easier checking if user is admin\n    mapping(address => bool) public isAdmin;\n\n    // Modifier restricting access to only admin\n    modifier onlyAdmin {\n        require(isAdmin[msg.sender] == true, \"not admin\");\n        _;\n    }\n\n    // Constructor to set initial admins during deployment\n    constructor (address [] memory _admins) public {\n        for(uint i = 0; i < _admins.length; i++) {\n            admins.push(_admins[i]);\n            isAdmin[_admins[i]] = true;\n        }\n    }\n\n    function addAdmin(\n        address _adminAddress\n    )\n    external\n    onlyAdmin\n    {\n        // Can't add 0x address as an admin\n        require(_adminAddress != address(0x0), \"[RBAC] : Admin must be != than 0x0 address\");\n        // Can't add existing admin\n        require(isAdmin[_adminAddress] == false, \"[RBAC] : Admin already exists.\");\n        // Add admin to array of admins\n        admins.push(_adminAddress);\n        // Set mapping\n        isAdmin[_adminAddress] = true;\n    }\n\n    // SWC-113-DoS with Failed Call: L43\n    function removeAdmin(\n        address _adminAddress\n    )\n    external\n    onlyAdmin\n    {\n        // Admin has to exist\n        require(isAdmin[_adminAddress] == true);\n\n        uint i = 0;\n\n        while(admins[i] != _adminAddress) {\n            if(i == admins.length) {\n                revert(\"Passed admin address does not exist\");\n            }\n            i++;\n        }\n\n        // Copy the last admin position to the current index\n        admins[i] = admins[admins.length-1];\n\n        isAdmin[_adminAddress] = false;\n\n        // Remove the last admin, since it's double present\n        admins.pop();\n    }\n\n    // Fetch all admins\n    function getAllAdmins()\n    external\n    view\n    returns (address [] memory)\n    {\n        return admins;\n    }\n\n}",
        "function": "admins(uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinfabrik-Avalaunch Audit Allocation Staking and Sales/xava-protocol-fd252f8b9b0283d245d9d561130fe789ff08dfe9/contracts/Admin.sol",
        "vulnerability": "Exception State (SWC 110)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract GolemNetworkToken {\n    string public constant name = \"Test Golem Network Token\";\n    string public constant symbol = \"tGNT\";\n    uint8 public constant decimals = 18;  // 18 decimal places, the same as ETH.\n\n    uint256 public constant tokenCreationRate = 10000000000;\n\n    // The funding cap in weis.\n    uint256 public constant tokenCreationCap = 82 finney * tokenCreationRate;\n    uint256 public constant tokenCreationMin = 15 finney * tokenCreationRate;\n\n    uint256 public fundingStartBlock;\n    uint256 public fundingEndBlock;\n\n    // The flag indicates if the GNT contract is in Funding state.\n    bool public funding = true;\n\n    // Receives ETH and its own GNT endowment.\n    address public golemFactory;\n\n    // Has control over token migration to next version of token.\n    address public migrationMaster;\n\n    GNTAllocation lockedAllocation;\n\n    // The current total token supply.\n    uint256 public totalTokens;\n\n    mapping (address => uint256) balances;\n\n    address public migrationAgent;\n    uint256 public totalMigrated;\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Migrate(address indexed _from, address indexed _to, uint256 _value);\n    event Refund(address indexed _from, uint256 _value);\n\n    function GolemNetworkToken(address _golemFactory,\n                               address _migrationMaster,\n                               uint256 _fundingStartBlock,\n                               uint256 _fundingEndBlock) {\n\n        if (_golemFactory == 0) revert();\n        if (_migrationMaster == 0) revert();\n        if (_fundingStartBlock <= block.number) revert();\n        if (_fundingEndBlock   <= _fundingStartBlock) revert();\n\n        lockedAllocation = new GNTAllocation(_golemFactory);\n        migrationMaster = _migrationMaster;\n        golemFactory = _golemFactory;\n        fundingStartBlock = _fundingStartBlock;\n        fundingEndBlock = _fundingEndBlock;\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    function transfer(address _to, uint256 _value) returns (bool) {\n        // Abort if not in Operational state.\n        if (funding) revert();\n\n        var senderBalance = balances[msg.sender];\n        if (senderBalance >= _value && _value > 0) {\n            senderBalance -= _value;\n            balances[msg.sender] = senderBalance;\n            balances[_to] += _value;\n            Transfer(msg.sender, _to, _value);\n            return true;\n        }\n        return false;\n    }\n\n    function totalSupply() external view returns (uint256) {\n        return totalTokens;\n    }\n\n    function balanceOf(address _owner) external view returns (uint256) {\n        return balances[_owner];\n    }\n\n    // Token migration support:\n\n    \n    \n    \n    function migrate(uint256 _value) external {\n        // Abort if not in Operational Migration state.\n        if (funding) revert();\n        if (migrationAgent == 0) revert();\n\n        // Validate input value.\n        if (_value == 0) revert();\n        if (_value > balances[msg.sender]) revert();\n\n        balances[msg.sender] -= _value;\n        totalTokens -= _value;\n        totalMigrated += _value;\n        MigrationAgent(migrationAgent).migrateFrom(msg.sender, _value);\n        Migrate(msg.sender, migrationAgent, _value);\n    }\n\n    \n\t\n    \n    \n    \n    function setMigrationAgent(address _agent) external {\n        // Abort if not in Operational Normal state.\n        if (funding) revert();\n        if (migrationAgent != 0) revert();\n        if (msg.sender != migrationMaster) revert();\n        migrationAgent = _agent;\n    }\n\n    function setMigrationMaster(address _master) external {\n        if (msg.sender != migrationMaster) revert();\n        if (_master == 0) revert();\n        migrationMaster = _master;\n    }\n\n    // Crowdfunding:\n\n    \n    \n    \n    function create() payable external {\n        // Abort if not in Funding Active state.\n        // The checks are split (instead of using or operator) because it is\n        // cheaper this way.\n        if (!funding) revert();\n        if (block.number < fundingStartBlock) revert();\n        if (block.number > fundingEndBlock) revert();\n\n        // Do not allow creating 0 or more than the cap tokens.\n        if (msg.value == 0) revert();\n        if (msg.value > (tokenCreationCap - totalTokens) / tokenCreationRate)\n            revert();\n\n        var numTokens = msg.value * tokenCreationRate;\n        totalTokens += numTokens;\n\n        // Assign new tokens to the sender\n        balances[msg.sender] += numTokens;\n\n        // Log token creation event\n        Transfer(0, msg.sender, numTokens);\n    }\n\n    \n    \n    \n    \n    \n    \n    function finalize() external {\n        // Abort if not in Funding Success state.\n        if (!funding) revert();\n        if ((block.number <= fundingEndBlock ||\n             totalTokens < tokenCreationMin) &&\n            totalTokens < tokenCreationCap) revert();\n\n        // Switch to Operational state. This is the only place this can happen.\n        funding = false;\n\n        // Create additional GNT for the Golem Factory and developers as\n        // the 18% of total number of tokens.\n        // All additional tokens are transfered to the account controller by\n        // GNTAllocation contract which will not allow using them for 6 months.\n        uint256 percentOfTotal = 18;\n        uint256 additionalTokens =\n            totalTokens * percentOfTotal / (100 - percentOfTotal);\n        totalTokens += additionalTokens;\n        balances[lockedAllocation] += additionalTokens;\n        Transfer(0, lockedAllocation, additionalTokens);\n\n        // Transfer ETH to the Golem Factory address.\n        if (!golemFactory.send(this.balance)) revert();\n    }\n\n    \n    \n    \n    function refund() external {\n        // Abort if not in Funding Failure state.\n        if (!funding) revert();\n        if (block.number <= fundingEndBlock) revert();\n        if (totalTokens >= tokenCreationMin) revert();\n\n        var gntValue = balances[msg.sender];\n        if (gntValue == 0) revert();\n        balances[msg.sender] = 0;\n        totalTokens -= gntValue;\n\n        var ethValue = gntValue / tokenCreationRate;\n        Refund(msg.sender, ethValue);\n        if (!msg.sender.send(ethValue)) revert();\n    }\n}",
        "function": "constructor",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GolemNetworkToken.sol",
        "vulnerability": "Dependence on predictable environment variable (SWC 120)",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract GolemNetworkToken {\n    string public constant name = \"Test Golem Network Token\";\n    string public constant symbol = \"tGNT\";\n    uint8 public constant decimals = 18;  // 18 decimal places, the same as ETH.\n\n    uint256 public constant tokenCreationRate = 10000000000;\n\n    // The funding cap in weis.\n    uint256 public constant tokenCreationCap = 82 finney * tokenCreationRate;\n    uint256 public constant tokenCreationMin = 15 finney * tokenCreationRate;\n\n    uint256 public fundingStartBlock;\n    uint256 public fundingEndBlock;\n\n    // The flag indicates if the GNT contract is in Funding state.\n    bool public funding = true;\n\n    // Receives ETH and its own GNT endowment.\n    address public golemFactory;\n\n    // Has control over token migration to next version of token.\n    address public migrationMaster;\n\n    GNTAllocation lockedAllocation;\n\n    // The current total token supply.\n    uint256 public totalTokens;\n\n    mapping (address => uint256) balances;\n\n    address public migrationAgent;\n    uint256 public totalMigrated;\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Migrate(address indexed _from, address indexed _to, uint256 _value);\n    event Refund(address indexed _from, uint256 _value);\n\n    function GolemNetworkToken(address _golemFactory,\n                               address _migrationMaster,\n                               uint256 _fundingStartBlock,\n                               uint256 _fundingEndBlock) {\n\n        if (_golemFactory == 0) revert();\n        if (_migrationMaster == 0) revert();\n        if (_fundingStartBlock <= block.number) revert();\n        if (_fundingEndBlock   <= _fundingStartBlock) revert();\n\n        lockedAllocation = new GNTAllocation(_golemFactory);\n        migrationMaster = _migrationMaster;\n        golemFactory = _golemFactory;\n        fundingStartBlock = _fundingStartBlock;\n        fundingEndBlock = _fundingEndBlock;\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    function transfer(address _to, uint256 _value) returns (bool) {\n        // Abort if not in Operational state.\n        if (funding) revert();\n\n        var senderBalance = balances[msg.sender];\n        if (senderBalance >= _value && _value > 0) {\n            senderBalance -= _value;\n            balances[msg.sender] = senderBalance;\n            balances[_to] += _value;\n            Transfer(msg.sender, _to, _value);\n            return true;\n        }\n        return false;\n    }\n\n    function totalSupply() external view returns (uint256) {\n        return totalTokens;\n    }\n\n    function balanceOf(address _owner) external view returns (uint256) {\n        return balances[_owner];\n    }\n\n    // Token migration support:\n\n    \n    \n    \n    function migrate(uint256 _value) external {\n        // Abort if not in Operational Migration state.\n        if (funding) revert();\n        if (migrationAgent == 0) revert();\n\n        // Validate input value.\n        if (_value == 0) revert();\n        if (_value > balances[msg.sender]) revert();\n\n        balances[msg.sender] -= _value;\n        totalTokens -= _value;\n        totalMigrated += _value;\n        MigrationAgent(migrationAgent).migrateFrom(msg.sender, _value);\n        Migrate(msg.sender, migrationAgent, _value);\n    }\n\n    \n\t\n    \n    \n    \n    function setMigrationAgent(address _agent) external {\n        // Abort if not in Operational Normal state.\n        if (funding) revert();\n        if (migrationAgent != 0) revert();\n        if (msg.sender != migrationMaster) revert();\n        migrationAgent = _agent;\n    }\n\n    function setMigrationMaster(address _master) external {\n        if (msg.sender != migrationMaster) revert();\n        if (_master == 0) revert();\n        migrationMaster = _master;\n    }\n\n    // Crowdfunding:\n\n    \n    \n    \n    function create() payable external {\n        // Abort if not in Funding Active state.\n        // The checks are split (instead of using or operator) because it is\n        // cheaper this way.\n        if (!funding) revert();\n        if (block.number < fundingStartBlock) revert();\n        if (block.number > fundingEndBlock) revert();\n\n        // Do not allow creating 0 or more than the cap tokens.\n        if (msg.value == 0) revert();\n        if (msg.value > (tokenCreationCap - totalTokens) / tokenCreationRate)\n            revert();\n\n        var numTokens = msg.value * tokenCreationRate;\n        totalTokens += numTokens;\n\n        // Assign new tokens to the sender\n        balances[msg.sender] += numTokens;\n\n        // Log token creation event\n        Transfer(0, msg.sender, numTokens);\n    }\n\n    \n    \n    \n    \n    \n    \n    function finalize() external {\n        // Abort if not in Funding Success state.\n        if (!funding) revert();\n        if ((block.number <= fundingEndBlock ||\n             totalTokens < tokenCreationMin) &&\n            totalTokens < tokenCreationCap) revert();\n\n        // Switch to Operational state. This is the only place this can happen.\n        funding = false;\n\n        // Create additional GNT for the Golem Factory and developers as\n        // the 18% of total number of tokens.\n        // All additional tokens are transfered to the account controller by\n        // GNTAllocation contract which will not allow using them for 6 months.\n        uint256 percentOfTotal = 18;\n        uint256 additionalTokens =\n            totalTokens * percentOfTotal / (100 - percentOfTotal);\n        totalTokens += additionalTokens;\n        balances[lockedAllocation] += additionalTokens;\n        Transfer(0, lockedAllocation, additionalTokens);\n\n        // Transfer ETH to the Golem Factory address.\n        if (!golemFactory.send(this.balance)) revert();\n    }\n\n    \n    \n    \n    function refund() external {\n        // Abort if not in Funding Failure state.\n        if (!funding) revert();\n        if (block.number <= fundingEndBlock) revert();\n        if (totalTokens >= tokenCreationMin) revert();\n\n        var gntValue = balances[msg.sender];\n        if (gntValue == 0) revert();\n        balances[msg.sender] = 0;\n        totalTokens -= gntValue;\n\n        var ethValue = gntValue / tokenCreationRate;\n        Refund(msg.sender, ethValue);\n        if (!msg.sender.send(ethValue)) revert();\n    }\n}",
        "function": "finalize()",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GolemNetworkToken.sol",
        "vulnerability": "Dependence on predictable environment variable (SWC 120)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract GolemNetworkToken {\n    string public constant name = \"Test Golem Network Token\";\n    string public constant symbol = \"tGNT\";\n    uint8 public constant decimals = 18;  // 18 decimal places, the same as ETH.\n\n    uint256 public constant tokenCreationRate = 10000000000;\n\n    // The funding cap in weis.\n    uint256 public constant tokenCreationCap = 82 finney * tokenCreationRate;\n    uint256 public constant tokenCreationMin = 15 finney * tokenCreationRate;\n\n    uint256 public fundingStartBlock;\n    uint256 public fundingEndBlock;\n\n    // The flag indicates if the GNT contract is in Funding state.\n    bool public funding = true;\n\n    // Receives ETH and its own GNT endowment.\n    address public golemFactory;\n\n    // Has control over token migration to next version of token.\n    address public migrationMaster;\n\n    GNTAllocation lockedAllocation;\n\n    // The current total token supply.\n    uint256 public totalTokens;\n\n    mapping (address => uint256) balances;\n\n    address public migrationAgent;\n    uint256 public totalMigrated;\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Migrate(address indexed _from, address indexed _to, uint256 _value);\n    event Refund(address indexed _from, uint256 _value);\n\n    function GolemNetworkToken(address _golemFactory,\n                               address _migrationMaster,\n                               uint256 _fundingStartBlock,\n                               uint256 _fundingEndBlock) {\n\n        if (_golemFactory == 0) revert();\n        if (_migrationMaster == 0) revert();\n        if (_fundingStartBlock <= block.number) revert();\n        if (_fundingEndBlock   <= _fundingStartBlock) revert();\n\n        lockedAllocation = new GNTAllocation(_golemFactory);\n        migrationMaster = _migrationMaster;\n        golemFactory = _golemFactory;\n        fundingStartBlock = _fundingStartBlock;\n        fundingEndBlock = _fundingEndBlock;\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    function transfer(address _to, uint256 _value) returns (bool) {\n        // Abort if not in Operational state.\n        if (funding) revert();\n\n        var senderBalance = balances[msg.sender];\n        if (senderBalance >= _value && _value > 0) {\n            senderBalance -= _value;\n            balances[msg.sender] = senderBalance;\n            balances[_to] += _value;\n            Transfer(msg.sender, _to, _value);\n            return true;\n        }\n        return false;\n    }\n\n    function totalSupply() external view returns (uint256) {\n        return totalTokens;\n    }\n\n    function balanceOf(address _owner) external view returns (uint256) {\n        return balances[_owner];\n    }\n\n    // Token migration support:\n\n    \n    \n    \n    function migrate(uint256 _value) external {\n        // Abort if not in Operational Migration state.\n        if (funding) revert();\n        if (migrationAgent == 0) revert();\n\n        // Validate input value.\n        if (_value == 0) revert();\n        if (_value > balances[msg.sender]) revert();\n\n        balances[msg.sender] -= _value;\n        totalTokens -= _value;\n        totalMigrated += _value;\n        MigrationAgent(migrationAgent).migrateFrom(msg.sender, _value);\n        Migrate(msg.sender, migrationAgent, _value);\n    }\n\n    \n\t\n    \n    \n    \n    function setMigrationAgent(address _agent) external {\n        // Abort if not in Operational Normal state.\n        if (funding) revert();\n        if (migrationAgent != 0) revert();\n        if (msg.sender != migrationMaster) revert();\n        migrationAgent = _agent;\n    }\n\n    function setMigrationMaster(address _master) external {\n        if (msg.sender != migrationMaster) revert();\n        if (_master == 0) revert();\n        migrationMaster = _master;\n    }\n\n    // Crowdfunding:\n\n    \n    \n    \n    function create() payable external {\n        // Abort if not in Funding Active state.\n        // The checks are split (instead of using or operator) because it is\n        // cheaper this way.\n        if (!funding) revert();\n        if (block.number < fundingStartBlock) revert();\n        if (block.number > fundingEndBlock) revert();\n\n        // Do not allow creating 0 or more than the cap tokens.\n        if (msg.value == 0) revert();\n        if (msg.value > (tokenCreationCap - totalTokens) / tokenCreationRate)\n            revert();\n\n        var numTokens = msg.value * tokenCreationRate;\n        totalTokens += numTokens;\n\n        // Assign new tokens to the sender\n        balances[msg.sender] += numTokens;\n\n        // Log token creation event\n        Transfer(0, msg.sender, numTokens);\n    }\n\n    \n    \n    \n    \n    \n    \n    function finalize() external {\n        // Abort if not in Funding Success state.\n        if (!funding) revert();\n        if ((block.number <= fundingEndBlock ||\n             totalTokens < tokenCreationMin) &&\n            totalTokens < tokenCreationCap) revert();\n\n        // Switch to Operational state. This is the only place this can happen.\n        funding = false;\n\n        // Create additional GNT for the Golem Factory and developers as\n        // the 18% of total number of tokens.\n        // All additional tokens are transfered to the account controller by\n        // GNTAllocation contract which will not allow using them for 6 months.\n        uint256 percentOfTotal = 18;\n        uint256 additionalTokens =\n            totalTokens * percentOfTotal / (100 - percentOfTotal);\n        totalTokens += additionalTokens;\n        balances[lockedAllocation] += additionalTokens;\n        Transfer(0, lockedAllocation, additionalTokens);\n\n        // Transfer ETH to the Golem Factory address.\n        if (!golemFactory.send(this.balance)) revert();\n    }\n\n    \n    \n    \n    function refund() external {\n        // Abort if not in Funding Failure state.\n        if (!funding) revert();\n        if (block.number <= fundingEndBlock) revert();\n        if (totalTokens >= tokenCreationMin) revert();\n\n        var gntValue = balances[msg.sender];\n        if (gntValue == 0) revert();\n        balances[msg.sender] = 0;\n        totalTokens -= gntValue;\n\n        var ethValue = gntValue / tokenCreationRate;\n        Refund(msg.sender, ethValue);\n        if (!msg.sender.send(ethValue)) revert();\n    }\n}",
        "function": "finalize()",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GolemNetworkToken.sol",
        "vulnerability": "Dependence on predictable environment variable (SWC 120)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract GolemNetworkToken {\n    string public constant name = \"Test Golem Network Token\";\n    string public constant symbol = \"tGNT\";\n    uint8 public constant decimals = 18;  // 18 decimal places, the same as ETH.\n\n    uint256 public constant tokenCreationRate = 10000000000;\n\n    // The funding cap in weis.\n    uint256 public constant tokenCreationCap = 82 finney * tokenCreationRate;\n    uint256 public constant tokenCreationMin = 15 finney * tokenCreationRate;\n\n    uint256 public fundingStartBlock;\n    uint256 public fundingEndBlock;\n\n    // The flag indicates if the GNT contract is in Funding state.\n    bool public funding = true;\n\n    // Receives ETH and its own GNT endowment.\n    address public golemFactory;\n\n    // Has control over token migration to next version of token.\n    address public migrationMaster;\n\n    GNTAllocation lockedAllocation;\n\n    // The current total token supply.\n    uint256 public totalTokens;\n\n    mapping (address => uint256) balances;\n\n    address public migrationAgent;\n    uint256 public totalMigrated;\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Migrate(address indexed _from, address indexed _to, uint256 _value);\n    event Refund(address indexed _from, uint256 _value);\n\n    function GolemNetworkToken(address _golemFactory,\n                               address _migrationMaster,\n                               uint256 _fundingStartBlock,\n                               uint256 _fundingEndBlock) {\n\n        if (_golemFactory == 0) revert();\n        if (_migrationMaster == 0) revert();\n        if (_fundingStartBlock <= block.number) revert();\n        if (_fundingEndBlock   <= _fundingStartBlock) revert();\n\n        lockedAllocation = new GNTAllocation(_golemFactory);\n        migrationMaster = _migrationMaster;\n        golemFactory = _golemFactory;\n        fundingStartBlock = _fundingStartBlock;\n        fundingEndBlock = _fundingEndBlock;\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    function transfer(address _to, uint256 _value) returns (bool) {\n        // Abort if not in Operational state.\n        if (funding) revert();\n\n        var senderBalance = balances[msg.sender];\n        if (senderBalance >= _value && _value > 0) {\n            senderBalance -= _value;\n            balances[msg.sender] = senderBalance;\n            balances[_to] += _value;\n            Transfer(msg.sender, _to, _value);\n            return true;\n        }\n        return false;\n    }\n\n    function totalSupply() external view returns (uint256) {\n        return totalTokens;\n    }\n\n    function balanceOf(address _owner) external view returns (uint256) {\n        return balances[_owner];\n    }\n\n    // Token migration support:\n\n    \n    \n    \n    function migrate(uint256 _value) external {\n        // Abort if not in Operational Migration state.\n        if (funding) revert();\n        if (migrationAgent == 0) revert();\n\n        // Validate input value.\n        if (_value == 0) revert();\n        if (_value > balances[msg.sender]) revert();\n\n        balances[msg.sender] -= _value;\n        totalTokens -= _value;\n        totalMigrated += _value;\n        MigrationAgent(migrationAgent).migrateFrom(msg.sender, _value);\n        Migrate(msg.sender, migrationAgent, _value);\n    }\n\n    \n\t\n    \n    \n    \n    function setMigrationAgent(address _agent) external {\n        // Abort if not in Operational Normal state.\n        if (funding) revert();\n        if (migrationAgent != 0) revert();\n        if (msg.sender != migrationMaster) revert();\n        migrationAgent = _agent;\n    }\n\n    function setMigrationMaster(address _master) external {\n        if (msg.sender != migrationMaster) revert();\n        if (_master == 0) revert();\n        migrationMaster = _master;\n    }\n\n    // Crowdfunding:\n\n    \n    \n    \n    function create() payable external {\n        // Abort if not in Funding Active state.\n        // The checks are split (instead of using or operator) because it is\n        // cheaper this way.\n        if (!funding) revert();\n        if (block.number < fundingStartBlock) revert();\n        if (block.number > fundingEndBlock) revert();\n\n        // Do not allow creating 0 or more than the cap tokens.\n        if (msg.value == 0) revert();\n        if (msg.value > (tokenCreationCap - totalTokens) / tokenCreationRate)\n            revert();\n\n        var numTokens = msg.value * tokenCreationRate;\n        totalTokens += numTokens;\n\n        // Assign new tokens to the sender\n        balances[msg.sender] += numTokens;\n\n        // Log token creation event\n        Transfer(0, msg.sender, numTokens);\n    }\n\n    \n    \n    \n    \n    \n    \n    function finalize() external {\n        // Abort if not in Funding Success state.\n        if (!funding) revert();\n        if ((block.number <= fundingEndBlock ||\n             totalTokens < tokenCreationMin) &&\n            totalTokens < tokenCreationCap) revert();\n\n        // Switch to Operational state. This is the only place this can happen.\n        funding = false;\n\n        // Create additional GNT for the Golem Factory and developers as\n        // the 18% of total number of tokens.\n        // All additional tokens are transfered to the account controller by\n        // GNTAllocation contract which will not allow using them for 6 months.\n        uint256 percentOfTotal = 18;\n        uint256 additionalTokens =\n            totalTokens * percentOfTotal / (100 - percentOfTotal);\n        totalTokens += additionalTokens;\n        balances[lockedAllocation] += additionalTokens;\n        Transfer(0, lockedAllocation, additionalTokens);\n\n        // Transfer ETH to the Golem Factory address.\n        if (!golemFactory.send(this.balance)) revert();\n    }\n\n    \n    \n    \n    function refund() external {\n        // Abort if not in Funding Failure state.\n        if (!funding) revert();\n        if (block.number <= fundingEndBlock) revert();\n        if (totalTokens >= tokenCreationMin) revert();\n\n        var gntValue = balances[msg.sender];\n        if (gntValue == 0) revert();\n        balances[msg.sender] = 0;\n        totalTokens -= gntValue;\n\n        var ethValue = gntValue / tokenCreationRate;\n        Refund(msg.sender, ethValue);\n        if (!msg.sender.send(ethValue)) revert();\n    }\n}",
        "function": "refund()",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GolemNetworkToken.sol",
        "vulnerability": "Dependence on predictable environment variable (SWC 120)",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract GolemNetworkToken {\n    string public constant name = \"Test Golem Network Token\";\n    string public constant symbol = \"tGNT\";\n    uint8 public constant decimals = 18;  // 18 decimal places, the same as ETH.\n\n    uint256 public constant tokenCreationRate = 10000000000;\n\n    // The funding cap in weis.\n    uint256 public constant tokenCreationCap = 82 finney * tokenCreationRate;\n    uint256 public constant tokenCreationMin = 15 finney * tokenCreationRate;\n\n    uint256 public fundingStartBlock;\n    uint256 public fundingEndBlock;\n\n    // The flag indicates if the GNT contract is in Funding state.\n    bool public funding = true;\n\n    // Receives ETH and its own GNT endowment.\n    address public golemFactory;\n\n    // Has control over token migration to next version of token.\n    address public migrationMaster;\n\n    GNTAllocation lockedAllocation;\n\n    // The current total token supply.\n    uint256 public totalTokens;\n\n    mapping (address => uint256) balances;\n\n    address public migrationAgent;\n    uint256 public totalMigrated;\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Migrate(address indexed _from, address indexed _to, uint256 _value);\n    event Refund(address indexed _from, uint256 _value);\n\n    function GolemNetworkToken(address _golemFactory,\n                               address _migrationMaster,\n                               uint256 _fundingStartBlock,\n                               uint256 _fundingEndBlock) {\n\n        if (_golemFactory == 0) revert();\n        if (_migrationMaster == 0) revert();\n        if (_fundingStartBlock <= block.number) revert();\n        if (_fundingEndBlock   <= _fundingStartBlock) revert();\n\n        lockedAllocation = new GNTAllocation(_golemFactory);\n        migrationMaster = _migrationMaster;\n        golemFactory = _golemFactory;\n        fundingStartBlock = _fundingStartBlock;\n        fundingEndBlock = _fundingEndBlock;\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    function transfer(address _to, uint256 _value) returns (bool) {\n        // Abort if not in Operational state.\n        if (funding) revert();\n\n        var senderBalance = balances[msg.sender];\n        if (senderBalance >= _value && _value > 0) {\n            senderBalance -= _value;\n            balances[msg.sender] = senderBalance;\n            balances[_to] += _value;\n            Transfer(msg.sender, _to, _value);\n            return true;\n        }\n        return false;\n    }\n\n    function totalSupply() external view returns (uint256) {\n        return totalTokens;\n    }\n\n    function balanceOf(address _owner) external view returns (uint256) {\n        return balances[_owner];\n    }\n\n    // Token migration support:\n\n    \n    \n    \n    function migrate(uint256 _value) external {\n        // Abort if not in Operational Migration state.\n        if (funding) revert();\n        if (migrationAgent == 0) revert();\n\n        // Validate input value.\n        if (_value == 0) revert();\n        if (_value > balances[msg.sender]) revert();\n\n        balances[msg.sender] -= _value;\n        totalTokens -= _value;\n        totalMigrated += _value;\n        MigrationAgent(migrationAgent).migrateFrom(msg.sender, _value);\n        Migrate(msg.sender, migrationAgent, _value);\n    }\n\n    \n\t\n    \n    \n    \n    function setMigrationAgent(address _agent) external {\n        // Abort if not in Operational Normal state.\n        if (funding) revert();\n        if (migrationAgent != 0) revert();\n        if (msg.sender != migrationMaster) revert();\n        migrationAgent = _agent;\n    }\n\n    function setMigrationMaster(address _master) external {\n        if (msg.sender != migrationMaster) revert();\n        if (_master == 0) revert();\n        migrationMaster = _master;\n    }\n\n    // Crowdfunding:\n\n    \n    \n    \n    function create() payable external {\n        // Abort if not in Funding Active state.\n        // The checks are split (instead of using or operator) because it is\n        // cheaper this way.\n        if (!funding) revert();\n        if (block.number < fundingStartBlock) revert();\n        if (block.number > fundingEndBlock) revert();\n\n        // Do not allow creating 0 or more than the cap tokens.\n        if (msg.value == 0) revert();\n        if (msg.value > (tokenCreationCap - totalTokens) / tokenCreationRate)\n            revert();\n\n        var numTokens = msg.value * tokenCreationRate;\n        totalTokens += numTokens;\n\n        // Assign new tokens to the sender\n        balances[msg.sender] += numTokens;\n\n        // Log token creation event\n        Transfer(0, msg.sender, numTokens);\n    }\n\n    \n    \n    \n    \n    \n    \n    function finalize() external {\n        // Abort if not in Funding Success state.\n        if (!funding) revert();\n        if ((block.number <= fundingEndBlock ||\n             totalTokens < tokenCreationMin) &&\n            totalTokens < tokenCreationCap) revert();\n\n        // Switch to Operational state. This is the only place this can happen.\n        funding = false;\n\n        // Create additional GNT for the Golem Factory and developers as\n        // the 18% of total number of tokens.\n        // All additional tokens are transfered to the account controller by\n        // GNTAllocation contract which will not allow using them for 6 months.\n        uint256 percentOfTotal = 18;\n        uint256 additionalTokens =\n            totalTokens * percentOfTotal / (100 - percentOfTotal);\n        totalTokens += additionalTokens;\n        balances[lockedAllocation] += additionalTokens;\n        Transfer(0, lockedAllocation, additionalTokens);\n\n        // Transfer ETH to the Golem Factory address.\n        if (!golemFactory.send(this.balance)) revert();\n    }\n\n    \n    \n    \n    function refund() external {\n        // Abort if not in Funding Failure state.\n        if (!funding) revert();\n        if (block.number <= fundingEndBlock) revert();\n        if (totalTokens >= tokenCreationMin) revert();\n\n        var gntValue = balances[msg.sender];\n        if (gntValue == 0) revert();\n        balances[msg.sender] = 0;\n        totalTokens -= gntValue;\n\n        var ethValue = gntValue / tokenCreationRate;\n        Refund(msg.sender, ethValue);\n        if (!msg.sender.send(ethValue)) revert();\n    }\n}",
        "function": "create()",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GolemNetworkToken.sol",
        "vulnerability": "Dependence on predictable environment variable (SWC 120)",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract GNTDeposit is ReceivingContract {\n    address public concent;\n    address public coldwallet;\n    uint256 public withdrawal_delay;\n\n    ERC20 public token;\n    // owner => amount\n    mapping (address => uint256) public balances;\n    // owner => timestamp after which withdraw is possible\n    //        | 0 if locked\n    mapping (address => uint256) public locked_until;\n\n    event Deposit(address indexed _owner, uint256 _amount);\n    event Withdraw(address indexed _from, address indexed _to, uint256 _amount);\n    event Lock(address indexed _owner);\n    event Unlock(address indexed _owner);\n    event Burn(address indexed _who, uint256 _amount);\n    event ReimburseForSubtask(address indexed _requestor, address indexed _provider, uint256 _amount, bytes32 _subtask_id);\n    event ReimburseForNoPayment(address indexed _requestor, address indexed _provider, uint256 _amount, uint256 _closure_time);\n    event ReimburseForVerificationCosts(address indexed _from, uint256 _amount, bytes32 _subtask_id);\n\n    function GNTDeposit(\n        ERC20 _token,\n        address _concent,\n        address _coldwallet,\n        uint256 _withdrawal_delay\n    )\n        public\n    {\n        token = _token;\n        concent = _concent;\n        coldwallet = _coldwallet;\n        withdrawal_delay = _withdrawal_delay;\n    }\n\n    // modifiers\n\n    modifier onlyUnlocked() {\n        require(isUnlocked(msg.sender));\n        _;\n    }\n\n    modifier onlyConcent() {\n        require(msg.sender == concent);\n        _;\n    }\n\n    modifier onlyToken() {\n        require(msg.sender == address(token));\n        _;\n    }\n\n    // views\n\n    function balanceOf(address _owner) external view returns (uint256) {\n        return balances[_owner];\n    }\n\n    function isLocked(address _owner) external view returns (bool) {\n        return locked_until[_owner] == 0;\n    }\n\n    function isTimeLocked(address _owner) external view returns (bool) {\n        return locked_until[_owner] > block.timestamp;\n    }\n\n    function isUnlocked(address _owner) public view returns (bool) {\n        return locked_until[_owner] != 0 && locked_until[_owner] < block.timestamp;\n    }\n\n    function getTimelock(address _owner) external view returns (uint256) {\n        return locked_until[_owner];\n    }\n\n    // deposit API\n\n    function unlock() external {\n        locked_until[msg.sender] = block.timestamp + withdrawal_delay;\n        Unlock(msg.sender);\n    }\n\n    function lock() external {\n        locked_until[msg.sender] = 0;\n        Lock(msg.sender);\n    }\n\n    function onTokenReceived(address _from, uint _amount, bytes /* _data */) public onlyToken {\n        balances[_from] += _amount;\n        Deposit(_from, _amount);\n    }\n\n    function withdraw(address _to) onlyUnlocked external {\n        var _amount = balances[msg.sender];\n        balances[msg.sender] = 0;\n        locked_until[msg.sender] = 0;\n        require(token.transfer(_to, _amount));\n        Withdraw(msg.sender, _to, _amount);\n    }\n\n    function burn(address _whom, uint256 _burn) onlyConcent external {\n        _reimburse(_whom, 0xdeadbeef, _burn);\n        Burn(_whom, _burn);\n    }\n\n    function reimburseForSubtask(\n        address _requestor,\n        address _provider,\n        uint256 _amount,\n        bytes32 _subtask_id\n    )\n        onlyConcent\n        external\n    {\n        _reimburse(_requestor, _provider, _amount);\n        ReimburseForSubtask(_requestor, _provider, _amount, _subtask_id);\n    }\n\n    function reimburseForNoPayment(\n        address _requestor,\n        address _provider,\n        uint256 _amount,\n        uint256 _closure_time\n    )\n        onlyConcent\n        external\n    {\n        _reimburse(_requestor, _provider, _amount);\n        ReimburseForNoPayment(_requestor, _provider, _amount, _closure_time);\n    }\n\n    function reimburseForVerificationCosts(\n        address _from,\n        uint256 _amount,\n        bytes32 _subtask_id\n    )\n        onlyConcent\n        external\n    {\n        _reimburse(_from, coldwallet, _amount);\n        ReimburseForVerificationCosts(_from, _amount, _subtask_id);\n    }\n\n    // internals\n\n    function _reimburse(address _from, address _to, uint256 _amount) private {\n        require(balances[_from] >= _amount);\n        balances[_from] -= _amount;\n        if (balances[_from] == 0) {\n            locked_until[_from] = 0;\n        }\n        require(token.transfer(_to, _amount));\n    }\n\n}",
        "function": "withdraw(address)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GNTDeposit.sol",
        "vulnerability": "Dependence on predictable environment variable (SWC 116)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract GNTDeposit is ReceivingContract {\n    address public concent;\n    address public coldwallet;\n    uint256 public withdrawal_delay;\n\n    ERC20 public token;\n    // owner => amount\n    mapping (address => uint256) public balances;\n    // owner => timestamp after which withdraw is possible\n    //        | 0 if locked\n    mapping (address => uint256) public locked_until;\n\n    event Deposit(address indexed _owner, uint256 _amount);\n    event Withdraw(address indexed _from, address indexed _to, uint256 _amount);\n    event Lock(address indexed _owner);\n    event Unlock(address indexed _owner);\n    event Burn(address indexed _who, uint256 _amount);\n    event ReimburseForSubtask(address indexed _requestor, address indexed _provider, uint256 _amount, bytes32 _subtask_id);\n    event ReimburseForNoPayment(address indexed _requestor, address indexed _provider, uint256 _amount, uint256 _closure_time);\n    event ReimburseForVerificationCosts(address indexed _from, uint256 _amount, bytes32 _subtask_id);\n\n    function GNTDeposit(\n        ERC20 _token,\n        address _concent,\n        address _coldwallet,\n        uint256 _withdrawal_delay\n    )\n        public\n    {\n        token = _token;\n        concent = _concent;\n        coldwallet = _coldwallet;\n        withdrawal_delay = _withdrawal_delay;\n    }\n\n    // modifiers\n\n    modifier onlyUnlocked() {\n        require(isUnlocked(msg.sender));\n        _;\n    }\n\n    modifier onlyConcent() {\n        require(msg.sender == concent);\n        _;\n    }\n\n    modifier onlyToken() {\n        require(msg.sender == address(token));\n        _;\n    }\n\n    // views\n\n    function balanceOf(address _owner) external view returns (uint256) {\n        return balances[_owner];\n    }\n\n    function isLocked(address _owner) external view returns (bool) {\n        return locked_until[_owner] == 0;\n    }\n\n    function isTimeLocked(address _owner) external view returns (bool) {\n        return locked_until[_owner] > block.timestamp;\n    }\n\n    function isUnlocked(address _owner) public view returns (bool) {\n        return locked_until[_owner] != 0 && locked_until[_owner] < block.timestamp;\n    }\n\n    function getTimelock(address _owner) external view returns (uint256) {\n        return locked_until[_owner];\n    }\n\n    // deposit API\n\n    function unlock() external {\n        locked_until[msg.sender] = block.timestamp + withdrawal_delay;\n        Unlock(msg.sender);\n    }\n\n    function lock() external {\n        locked_until[msg.sender] = 0;\n        Lock(msg.sender);\n    }\n\n    function onTokenReceived(address _from, uint _amount, bytes /* _data */) public onlyToken {\n        balances[_from] += _amount;\n        Deposit(_from, _amount);\n    }\n\n    function withdraw(address _to) onlyUnlocked external {\n        var _amount = balances[msg.sender];\n        balances[msg.sender] = 0;\n        locked_until[msg.sender] = 0;\n        require(token.transfer(_to, _amount));\n        Withdraw(msg.sender, _to, _amount);\n    }\n\n    function burn(address _whom, uint256 _burn) onlyConcent external {\n        _reimburse(_whom, 0xdeadbeef, _burn);\n        Burn(_whom, _burn);\n    }\n\n    function reimburseForSubtask(\n        address _requestor,\n        address _provider,\n        uint256 _amount,\n        bytes32 _subtask_id\n    )\n        onlyConcent\n        external\n    {\n        _reimburse(_requestor, _provider, _amount);\n        ReimburseForSubtask(_requestor, _provider, _amount, _subtask_id);\n    }\n\n    function reimburseForNoPayment(\n        address _requestor,\n        address _provider,\n        uint256 _amount,\n        uint256 _closure_time\n    )\n        onlyConcent\n        external\n    {\n        _reimburse(_requestor, _provider, _amount);\n        ReimburseForNoPayment(_requestor, _provider, _amount, _closure_time);\n    }\n\n    function reimburseForVerificationCosts(\n        address _from,\n        uint256 _amount,\n        bytes32 _subtask_id\n    )\n        onlyConcent\n        external\n    {\n        _reimburse(_from, coldwallet, _amount);\n        ReimburseForVerificationCosts(_from, _amount, _subtask_id);\n    }\n\n    // internals\n\n    function _reimburse(address _from, address _to, uint256 _amount) private {\n        require(balances[_from] >= _amount);\n        balances[_from] -= _amount;\n        if (balances[_from] == 0) {\n            locked_until[_from] = 0;\n        }\n        require(token.transfer(_to, _amount));\n    }\n\n}",
        "function": "unlock()",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GNTDeposit.sol",
        "vulnerability": "Integer Arithmetic Bugs (SWC 101)",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract GNTDeposit is ReceivingContract {\n    address public concent;\n    address public coldwallet;\n    uint256 public withdrawal_delay;\n\n    ERC20 public token;\n    // owner => amount\n    mapping (address => uint256) public balances;\n    // owner => timestamp after which withdraw is possible\n    //        | 0 if locked\n    mapping (address => uint256) public locked_until;\n\n    event Deposit(address indexed _owner, uint256 _amount);\n    event Withdraw(address indexed _from, address indexed _to, uint256 _amount);\n    event Lock(address indexed _owner);\n    event Unlock(address indexed _owner);\n    event Burn(address indexed _who, uint256 _amount);\n    event ReimburseForSubtask(address indexed _requestor, address indexed _provider, uint256 _amount, bytes32 _subtask_id);\n    event ReimburseForNoPayment(address indexed _requestor, address indexed _provider, uint256 _amount, uint256 _closure_time);\n    event ReimburseForVerificationCosts(address indexed _from, uint256 _amount, bytes32 _subtask_id);\n\n    function GNTDeposit(\n        ERC20 _token,\n        address _concent,\n        address _coldwallet,\n        uint256 _withdrawal_delay\n    )\n        public\n    {\n        token = _token;\n        concent = _concent;\n        coldwallet = _coldwallet;\n        withdrawal_delay = _withdrawal_delay;\n    }\n\n    // modifiers\n\n    modifier onlyUnlocked() {\n        require(isUnlocked(msg.sender));\n        _;\n    }\n\n    modifier onlyConcent() {\n        require(msg.sender == concent);\n        _;\n    }\n\n    modifier onlyToken() {\n        require(msg.sender == address(token));\n        _;\n    }\n\n    // views\n\n    function balanceOf(address _owner) external view returns (uint256) {\n        return balances[_owner];\n    }\n\n    function isLocked(address _owner) external view returns (bool) {\n        return locked_until[_owner] == 0;\n    }\n\n    function isTimeLocked(address _owner) external view returns (bool) {\n        return locked_until[_owner] > block.timestamp;\n    }\n\n    function isUnlocked(address _owner) public view returns (bool) {\n        return locked_until[_owner] != 0 && locked_until[_owner] < block.timestamp;\n    }\n\n    function getTimelock(address _owner) external view returns (uint256) {\n        return locked_until[_owner];\n    }\n\n    // deposit API\n\n    function unlock() external {\n        locked_until[msg.sender] = block.timestamp + withdrawal_delay;\n        Unlock(msg.sender);\n    }\n\n    function lock() external {\n        locked_until[msg.sender] = 0;\n        Lock(msg.sender);\n    }\n\n    function onTokenReceived(address _from, uint _amount, bytes /* _data */) public onlyToken {\n        balances[_from] += _amount;\n        Deposit(_from, _amount);\n    }\n\n    function withdraw(address _to) onlyUnlocked external {\n        var _amount = balances[msg.sender];\n        balances[msg.sender] = 0;\n        locked_until[msg.sender] = 0;\n        require(token.transfer(_to, _amount));\n        Withdraw(msg.sender, _to, _amount);\n    }\n\n    function burn(address _whom, uint256 _burn) onlyConcent external {\n        _reimburse(_whom, 0xdeadbeef, _burn);\n        Burn(_whom, _burn);\n    }\n\n    function reimburseForSubtask(\n        address _requestor,\n        address _provider,\n        uint256 _amount,\n        bytes32 _subtask_id\n    )\n        onlyConcent\n        external\n    {\n        _reimburse(_requestor, _provider, _amount);\n        ReimburseForSubtask(_requestor, _provider, _amount, _subtask_id);\n    }\n\n    function reimburseForNoPayment(\n        address _requestor,\n        address _provider,\n        uint256 _amount,\n        uint256 _closure_time\n    )\n        onlyConcent\n        external\n    {\n        _reimburse(_requestor, _provider, _amount);\n        ReimburseForNoPayment(_requestor, _provider, _amount, _closure_time);\n    }\n\n    function reimburseForVerificationCosts(\n        address _from,\n        uint256 _amount,\n        bytes32 _subtask_id\n    )\n        onlyConcent\n        external\n    {\n        _reimburse(_from, coldwallet, _amount);\n        ReimburseForVerificationCosts(_from, _amount, _subtask_id);\n    }\n\n    // internals\n\n    function _reimburse(address _from, address _to, uint256 _amount) private {\n        require(balances[_from] >= _amount);\n        balances[_from] -= _amount;\n        if (balances[_from] == 0) {\n            locked_until[_from] = 0;\n        }\n        require(token.transfer(_to, _amount));\n    }\n\n}",
        "function": "reimburseForVerificationCosts(address,uint256,bytes32)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GNTDeposit.sol",
        "vulnerability": "External Call To User-Supplied Address (SWC 107)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract GNTDeposit is ReceivingContract {\n    address public concent;\n    address public coldwallet;\n    uint256 public withdrawal_delay;\n\n    ERC20 public token;\n    // owner => amount\n    mapping (address => uint256) public balances;\n    // owner => timestamp after which withdraw is possible\n    //        | 0 if locked\n    mapping (address => uint256) public locked_until;\n\n    event Deposit(address indexed _owner, uint256 _amount);\n    event Withdraw(address indexed _from, address indexed _to, uint256 _amount);\n    event Lock(address indexed _owner);\n    event Unlock(address indexed _owner);\n    event Burn(address indexed _who, uint256 _amount);\n    event ReimburseForSubtask(address indexed _requestor, address indexed _provider, uint256 _amount, bytes32 _subtask_id);\n    event ReimburseForNoPayment(address indexed _requestor, address indexed _provider, uint256 _amount, uint256 _closure_time);\n    event ReimburseForVerificationCosts(address indexed _from, uint256 _amount, bytes32 _subtask_id);\n\n    function GNTDeposit(\n        ERC20 _token,\n        address _concent,\n        address _coldwallet,\n        uint256 _withdrawal_delay\n    )\n        public\n    {\n        token = _token;\n        concent = _concent;\n        coldwallet = _coldwallet;\n        withdrawal_delay = _withdrawal_delay;\n    }\n\n    // modifiers\n\n    modifier onlyUnlocked() {\n        require(isUnlocked(msg.sender));\n        _;\n    }\n\n    modifier onlyConcent() {\n        require(msg.sender == concent);\n        _;\n    }\n\n    modifier onlyToken() {\n        require(msg.sender == address(token));\n        _;\n    }\n\n    // views\n\n    function balanceOf(address _owner) external view returns (uint256) {\n        return balances[_owner];\n    }\n\n    function isLocked(address _owner) external view returns (bool) {\n        return locked_until[_owner] == 0;\n    }\n\n    function isTimeLocked(address _owner) external view returns (bool) {\n        return locked_until[_owner] > block.timestamp;\n    }\n\n    function isUnlocked(address _owner) public view returns (bool) {\n        return locked_until[_owner] != 0 && locked_until[_owner] < block.timestamp;\n    }\n\n    function getTimelock(address _owner) external view returns (uint256) {\n        return locked_until[_owner];\n    }\n\n    // deposit API\n\n    function unlock() external {\n        locked_until[msg.sender] = block.timestamp + withdrawal_delay;\n        Unlock(msg.sender);\n    }\n\n    function lock() external {\n        locked_until[msg.sender] = 0;\n        Lock(msg.sender);\n    }\n\n    function onTokenReceived(address _from, uint _amount, bytes /* _data */) public onlyToken {\n        balances[_from] += _amount;\n        Deposit(_from, _amount);\n    }\n\n    function withdraw(address _to) onlyUnlocked external {\n        var _amount = balances[msg.sender];\n        balances[msg.sender] = 0;\n        locked_until[msg.sender] = 0;\n        require(token.transfer(_to, _amount));\n        Withdraw(msg.sender, _to, _amount);\n    }\n\n    function burn(address _whom, uint256 _burn) onlyConcent external {\n        _reimburse(_whom, 0xdeadbeef, _burn);\n        Burn(_whom, _burn);\n    }\n\n    function reimburseForSubtask(\n        address _requestor,\n        address _provider,\n        uint256 _amount,\n        bytes32 _subtask_id\n    )\n        onlyConcent\n        external\n    {\n        _reimburse(_requestor, _provider, _amount);\n        ReimburseForSubtask(_requestor, _provider, _amount, _subtask_id);\n    }\n\n    function reimburseForNoPayment(\n        address _requestor,\n        address _provider,\n        uint256 _amount,\n        uint256 _closure_time\n    )\n        onlyConcent\n        external\n    {\n        _reimburse(_requestor, _provider, _amount);\n        ReimburseForNoPayment(_requestor, _provider, _amount, _closure_time);\n    }\n\n    function reimburseForVerificationCosts(\n        address _from,\n        uint256 _amount,\n        bytes32 _subtask_id\n    )\n        onlyConcent\n        external\n    {\n        _reimburse(_from, coldwallet, _amount);\n        ReimburseForVerificationCosts(_from, _amount, _subtask_id);\n    }\n\n    // internals\n\n    function _reimburse(address _from, address _to, uint256 _amount) private {\n        require(balances[_from] >= _amount);\n        balances[_from] -= _amount;\n        if (balances[_from] == 0) {\n            locked_until[_from] = 0;\n        }\n        require(token.transfer(_to, _amount));\n    }\n\n}",
        "function": "burn(address,uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GNTDeposit.sol",
        "vulnerability": "External Call To User-Supplied Address (SWC 107)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract GNTDeposit is ReceivingContract {\n    address public concent;\n    address public coldwallet;\n    uint256 public withdrawal_delay;\n\n    ERC20 public token;\n    // owner => amount\n    mapping (address => uint256) public balances;\n    // owner => timestamp after which withdraw is possible\n    //        | 0 if locked\n    mapping (address => uint256) public locked_until;\n\n    event Deposit(address indexed _owner, uint256 _amount);\n    event Withdraw(address indexed _from, address indexed _to, uint256 _amount);\n    event Lock(address indexed _owner);\n    event Unlock(address indexed _owner);\n    event Burn(address indexed _who, uint256 _amount);\n    event ReimburseForSubtask(address indexed _requestor, address indexed _provider, uint256 _amount, bytes32 _subtask_id);\n    event ReimburseForNoPayment(address indexed _requestor, address indexed _provider, uint256 _amount, uint256 _closure_time);\n    event ReimburseForVerificationCosts(address indexed _from, uint256 _amount, bytes32 _subtask_id);\n\n    function GNTDeposit(\n        ERC20 _token,\n        address _concent,\n        address _coldwallet,\n        uint256 _withdrawal_delay\n    )\n        public\n    {\n        token = _token;\n        concent = _concent;\n        coldwallet = _coldwallet;\n        withdrawal_delay = _withdrawal_delay;\n    }\n\n    // modifiers\n\n    modifier onlyUnlocked() {\n        require(isUnlocked(msg.sender));\n        _;\n    }\n\n    modifier onlyConcent() {\n        require(msg.sender == concent);\n        _;\n    }\n\n    modifier onlyToken() {\n        require(msg.sender == address(token));\n        _;\n    }\n\n    // views\n\n    function balanceOf(address _owner) external view returns (uint256) {\n        return balances[_owner];\n    }\n\n    function isLocked(address _owner) external view returns (bool) {\n        return locked_until[_owner] == 0;\n    }\n\n    function isTimeLocked(address _owner) external view returns (bool) {\n        return locked_until[_owner] > block.timestamp;\n    }\n\n    function isUnlocked(address _owner) public view returns (bool) {\n        return locked_until[_owner] != 0 && locked_until[_owner] < block.timestamp;\n    }\n\n    function getTimelock(address _owner) external view returns (uint256) {\n        return locked_until[_owner];\n    }\n\n    // deposit API\n\n    function unlock() external {\n        locked_until[msg.sender] = block.timestamp + withdrawal_delay;\n        Unlock(msg.sender);\n    }\n\n    function lock() external {\n        locked_until[msg.sender] = 0;\n        Lock(msg.sender);\n    }\n\n    function onTokenReceived(address _from, uint _amount, bytes /* _data */) public onlyToken {\n        balances[_from] += _amount;\n        Deposit(_from, _amount);\n    }\n\n    function withdraw(address _to) onlyUnlocked external {\n        var _amount = balances[msg.sender];\n        balances[msg.sender] = 0;\n        locked_until[msg.sender] = 0;\n        require(token.transfer(_to, _amount));\n        Withdraw(msg.sender, _to, _amount);\n    }\n\n    function burn(address _whom, uint256 _burn) onlyConcent external {\n        _reimburse(_whom, 0xdeadbeef, _burn);\n        Burn(_whom, _burn);\n    }\n\n    function reimburseForSubtask(\n        address _requestor,\n        address _provider,\n        uint256 _amount,\n        bytes32 _subtask_id\n    )\n        onlyConcent\n        external\n    {\n        _reimburse(_requestor, _provider, _amount);\n        ReimburseForSubtask(_requestor, _provider, _amount, _subtask_id);\n    }\n\n    function reimburseForNoPayment(\n        address _requestor,\n        address _provider,\n        uint256 _amount,\n        uint256 _closure_time\n    )\n        onlyConcent\n        external\n    {\n        _reimburse(_requestor, _provider, _amount);\n        ReimburseForNoPayment(_requestor, _provider, _amount, _closure_time);\n    }\n\n    function reimburseForVerificationCosts(\n        address _from,\n        uint256 _amount,\n        bytes32 _subtask_id\n    )\n        onlyConcent\n        external\n    {\n        _reimburse(_from, coldwallet, _amount);\n        ReimburseForVerificationCosts(_from, _amount, _subtask_id);\n    }\n\n    // internals\n\n    function _reimburse(address _from, address _to, uint256 _amount) private {\n        require(balances[_from] >= _amount);\n        balances[_from] -= _amount;\n        if (balances[_from] == 0) {\n            locked_until[_from] = 0;\n        }\n        require(token.transfer(_to, _amount));\n    }\n\n}",
        "function": "reimburseForSubtask(address,address,uint256,bytes32)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GNTDeposit.sol",
        "vulnerability": "External Call To User-Supplied Address (SWC 107)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract GolemNetworkToken {\n    string public constant name = \"Test Golem Network Token\";\n    string public constant symbol = \"tGNT\";\n    uint8 public constant decimals = 18;  // 18 decimal places, the same as ETH.\n\n    uint256 public constant tokenCreationRate = 10000000000;\n\n    // The funding cap in weis.\n    uint256 public constant tokenCreationCap = 82 finney * tokenCreationRate;\n    uint256 public constant tokenCreationMin = 15 finney * tokenCreationRate;\n\n    uint256 public fundingStartBlock;\n    uint256 public fundingEndBlock;\n\n    // The flag indicates if the GNT contract is in Funding state.\n    bool public funding = true;\n\n    // Receives ETH and its own GNT endowment.\n    address public golemFactory;\n\n    // Has control over token migration to next version of token.\n    address public migrationMaster;\n\n    GNTAllocation lockedAllocation;\n\n    // The current total token supply.\n    uint256 public totalTokens;\n\n    mapping (address => uint256) balances;\n\n    address public migrationAgent;\n    uint256 public totalMigrated;\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Migrate(address indexed _from, address indexed _to, uint256 _value);\n    event Refund(address indexed _from, uint256 _value);\n\n    function GolemNetworkToken(address _golemFactory,\n                               address _migrationMaster,\n                               uint256 _fundingStartBlock,\n                               uint256 _fundingEndBlock) {\n\n        if (_golemFactory == 0) revert();\n        if (_migrationMaster == 0) revert();\n        if (_fundingStartBlock <= block.number) revert();\n        if (_fundingEndBlock   <= _fundingStartBlock) revert();\n\n        lockedAllocation = new GNTAllocation(_golemFactory);\n        migrationMaster = _migrationMaster;\n        golemFactory = _golemFactory;\n        fundingStartBlock = _fundingStartBlock;\n        fundingEndBlock = _fundingEndBlock;\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    function transfer(address _to, uint256 _value) returns (bool) {\n        // Abort if not in Operational state.\n        if (funding) revert();\n\n        var senderBalance = balances[msg.sender];\n        if (senderBalance >= _value && _value > 0) {\n            senderBalance -= _value;\n            balances[msg.sender] = senderBalance;\n            balances[_to] += _value;\n            Transfer(msg.sender, _to, _value);\n            return true;\n        }\n        return false;\n    }\n\n    function totalSupply() external view returns (uint256) {\n        return totalTokens;\n    }\n\n    function balanceOf(address _owner) external view returns (uint256) {\n        return balances[_owner];\n    }\n\n    // Token migration support:\n\n    \n    \n    \n    function migrate(uint256 _value) external {\n        // Abort if not in Operational Migration state.\n        if (funding) revert();\n        if (migrationAgent == 0) revert();\n\n        // Validate input value.\n        if (_value == 0) revert();\n        if (_value > balances[msg.sender]) revert();\n\n        balances[msg.sender] -= _value;\n        totalTokens -= _value;\n        totalMigrated += _value;\n        MigrationAgent(migrationAgent).migrateFrom(msg.sender, _value);\n        Migrate(msg.sender, migrationAgent, _value);\n    }\n\n    \n\t\n    \n    \n    \n    function setMigrationAgent(address _agent) external {\n        // Abort if not in Operational Normal state.\n        if (funding) revert();\n        if (migrationAgent != 0) revert();\n        if (msg.sender != migrationMaster) revert();\n        migrationAgent = _agent;\n    }\n\n    function setMigrationMaster(address _master) external {\n        if (msg.sender != migrationMaster) revert();\n        if (_master == 0) revert();\n        migrationMaster = _master;\n    }\n\n    // Crowdfunding:\n\n    \n    \n    \n    function create() payable external {\n        // Abort if not in Funding Active state.\n        // The checks are split (instead of using or operator) because it is\n        // cheaper this way.\n        if (!funding) revert();\n        if (block.number < fundingStartBlock) revert();\n        if (block.number > fundingEndBlock) revert();\n\n        // Do not allow creating 0 or more than the cap tokens.\n        if (msg.value == 0) revert();\n        if (msg.value > (tokenCreationCap - totalTokens) / tokenCreationRate)\n            revert();\n\n        var numTokens = msg.value * tokenCreationRate;\n        totalTokens += numTokens;\n\n        // Assign new tokens to the sender\n        balances[msg.sender] += numTokens;\n\n        // Log token creation event\n        Transfer(0, msg.sender, numTokens);\n    }\n\n    \n    \n    \n    \n    \n    \n    function finalize() external {\n        // Abort if not in Funding Success state.\n        if (!funding) revert();\n        if ((block.number <= fundingEndBlock ||\n             totalTokens < tokenCreationMin) &&\n            totalTokens < tokenCreationCap) revert();\n\n        // Switch to Operational state. This is the only place this can happen.\n        funding = false;\n\n        // Create additional GNT for the Golem Factory and developers as\n        // the 18% of total number of tokens.\n        // All additional tokens are transfered to the account controller by\n        // GNTAllocation contract which will not allow using them for 6 months.\n        uint256 percentOfTotal = 18;\n        uint256 additionalTokens =\n            totalTokens * percentOfTotal / (100 - percentOfTotal);\n        totalTokens += additionalTokens;\n        balances[lockedAllocation] += additionalTokens;\n        Transfer(0, lockedAllocation, additionalTokens);\n\n        // Transfer ETH to the Golem Factory address.\n        if (!golemFactory.send(this.balance)) revert();\n    }\n\n    \n    \n    \n    function refund() external {\n        // Abort if not in Funding Failure state.\n        if (!funding) revert();\n        if (block.number <= fundingEndBlock) revert();\n        if (totalTokens >= tokenCreationMin) revert();\n\n        var gntValue = balances[msg.sender];\n        if (gntValue == 0) revert();\n        balances[msg.sender] = 0;\n        totalTokens -= gntValue;\n\n        var ethValue = gntValue / tokenCreationRate;\n        Refund(msg.sender, ethValue);\n        if (!msg.sender.send(ethValue)) revert();\n    }\n}",
        "function": "constructor",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/Faucet.sol",
        "vulnerability": "Dependence on predictable environment variable (SWC 120)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract Faucet {\n    GolemNetworkToken public token;\n\n    function Faucet(address _token) {\n        token = GolemNetworkToken(_token);\n    }\n\n    // Note that this function does not actually create tGNT!\n    // Name was unchanged not to break API\n    function create() external {\n        uint256 tokens = 1000 * 10 ** uint256(token.decimals());\n        if (token.balanceOf(msg.sender) >= tokens) revert();\n        token.transfer(msg.sender, tokens);\n    }\n}",
        "function": "create()",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/Faucet.sol",
        "vulnerability": "External Call To User-Supplied Address (SWC 107)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract Faucet {\n    GolemNetworkToken public token;\n\n    function Faucet(address _token) {\n        token = GolemNetworkToken(_token);\n    }\n\n    // Note that this function does not actually create tGNT!\n    // Name was unchanged not to break API\n    function create() external {\n        uint256 tokens = 1000 * 10 ** uint256(token.decimals());\n        if (token.balanceOf(msg.sender) >= tokens) revert();\n        token.transfer(msg.sender, tokens);\n    }\n}",
        "function": "create()",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/Faucet.sol",
        "vulnerability": "Integer Arithmetic Bugs (SWC 101)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract Faucet {\n    GolemNetworkToken public token;\n\n    function Faucet(address _token) {\n        token = GolemNetworkToken(_token);\n    }\n\n    // Note that this function does not actually create tGNT!\n    // Name was unchanged not to break API\n    function create() external {\n        uint256 tokens = 1000 * 10 ** uint256(token.decimals());\n        if (token.balanceOf(msg.sender) >= tokens) revert();\n        token.transfer(msg.sender, tokens);\n    }\n}",
        "function": "create()",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/Faucet.sol",
        "vulnerability": "Integer Arithmetic Bugs (SWC 101)",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract Faucet {\n    GolemNetworkToken public token;\n\n    function Faucet(address _token) {\n        token = GolemNetworkToken(_token);\n    }\n\n    // Note that this function does not actually create tGNT!\n    // Name was unchanged not to break API\n    function create() external {\n        uint256 tokens = 1000 * 10 ** uint256(token.decimals());\n        if (token.balanceOf(msg.sender) >= tokens) revert();\n        token.transfer(msg.sender, tokens);\n    }\n}",
        "function": "create()",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/Faucet.sol",
        "vulnerability": "State access after external call (SWC 107)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract Faucet {\n    GolemNetworkToken public token;\n\n    function Faucet(address _token) {\n        token = GolemNetworkToken(_token);\n    }\n\n    // Note that this function does not actually create tGNT!\n    // Name was unchanged not to break API\n    function create() external {\n        uint256 tokens = 1000 * 10 ** uint256(token.decimals());\n        if (token.balanceOf(msg.sender) >= tokens) revert();\n        token.transfer(msg.sender, tokens);\n    }\n}",
        "function": "create()",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/Faucet.sol",
        "vulnerability": "External Call To User-Supplied Address (SWC 107)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract Faucet {\n    GolemNetworkToken public token;\n\n    function Faucet(address _token) {\n        token = GolemNetworkToken(_token);\n    }\n\n    // Note that this function does not actually create tGNT!\n    // Name was unchanged not to break API\n    function create() external {\n        uint256 tokens = 1000 * 10 ** uint256(token.decimals());\n        if (token.balanceOf(msg.sender) >= tokens) revert();\n        token.transfer(msg.sender, tokens);\n    }\n}",
        "function": "create()",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/Faucet.sol",
        "vulnerability": "Multiple Calls in a Single Transaction (SWC 113)",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract Faucet {\n    GolemNetworkToken public token;\n\n    function Faucet(address _token) {\n        token = GolemNetworkToken(_token);\n    }\n\n    // Note that this function does not actually create tGNT!\n    // Name was unchanged not to break API\n    function create() external {\n        uint256 tokens = 1000 * 10 ** uint256(token.decimals());\n        if (token.balanceOf(msg.sender) >= tokens) revert();\n        token.transfer(msg.sender, tokens);\n    }\n}",
        "function": "create()",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/Faucet.sol",
        "vulnerability": "State access after external call (SWC 107)",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract Faucet {\n    GolemNetworkToken public token;\n\n    function Faucet(address _token) {\n        token = GolemNetworkToken(_token);\n    }\n\n    // Note that this function does not actually create tGNT!\n    // Name was unchanged not to break API\n    function create() external {\n        uint256 tokens = 1000 * 10 ** uint256(token.decimals());\n        if (token.balanceOf(msg.sender) >= tokens) revert();\n        token.transfer(msg.sender, tokens);\n    }\n}",
        "function": "create()",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/Faucet.sol",
        "vulnerability": "State access after external call (SWC 107)",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract Faucet {\n    GolemNetworkToken public token;\n\n    function Faucet(address _token) {\n        token = GolemNetworkToken(_token);\n    }\n\n    // Note that this function does not actually create tGNT!\n    // Name was unchanged not to break API\n    function create() external {\n        uint256 tokens = 1000 * 10 ** uint256(token.decimals());\n        if (token.balanceOf(msg.sender) >= tokens) revert();\n        token.transfer(msg.sender, tokens);\n    }\n}",
        "function": "create()",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/Faucet.sol",
        "vulnerability": "External Call To User-Supplied Address (SWC 107)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract Faucet {\n    GolemNetworkToken public token;\n\n    function Faucet(address _token) {\n        token = GolemNetworkToken(_token);\n    }\n\n    // Note that this function does not actually create tGNT!\n    // Name was unchanged not to break API\n    function create() external {\n        uint256 tokens = 1000 * 10 ** uint256(token.decimals());\n        if (token.balanceOf(msg.sender) >= tokens) revert();\n        token.transfer(msg.sender, tokens);\n    }\n}",
        "function": "create()",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/Faucet.sol",
        "vulnerability": "Multiple Calls in a Single Transaction (SWC 113)",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract Faucet {\n    GolemNetworkToken public token;\n\n    function Faucet(address _token) {\n        token = GolemNetworkToken(_token);\n    }\n\n    // Note that this function does not actually create tGNT!\n    // Name was unchanged not to break API\n    function create() external {\n        uint256 tokens = 1000 * 10 ** uint256(token.decimals());\n        if (token.balanceOf(msg.sender) >= tokens) revert();\n        token.transfer(msg.sender, tokens);\n    }\n}",
        "function": "create()",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/Faucet.sol",
        "vulnerability": "State access after external call (SWC 107)",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract GolemNetworkToken {\n    string public constant name = \"Test Golem Network Token\";\n    string public constant symbol = \"tGNT\";\n    uint8 public constant decimals = 18;  // 18 decimal places, the same as ETH.\n\n    uint256 public constant tokenCreationRate = 10000000000;\n\n    // The funding cap in weis.\n    uint256 public constant tokenCreationCap = 82 finney * tokenCreationRate;\n    uint256 public constant tokenCreationMin = 15 finney * tokenCreationRate;\n\n    uint256 public fundingStartBlock;\n    uint256 public fundingEndBlock;\n\n    // The flag indicates if the GNT contract is in Funding state.\n    bool public funding = true;\n\n    // Receives ETH and its own GNT endowment.\n    address public golemFactory;\n\n    // Has control over token migration to next version of token.\n    address public migrationMaster;\n\n    GNTAllocation lockedAllocation;\n\n    // The current total token supply.\n    uint256 public totalTokens;\n\n    mapping (address => uint256) balances;\n\n    address public migrationAgent;\n    uint256 public totalMigrated;\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Migrate(address indexed _from, address indexed _to, uint256 _value);\n    event Refund(address indexed _from, uint256 _value);\n\n    function GolemNetworkToken(address _golemFactory,\n                               address _migrationMaster,\n                               uint256 _fundingStartBlock,\n                               uint256 _fundingEndBlock) {\n\n        if (_golemFactory == 0) revert();\n        if (_migrationMaster == 0) revert();\n        if (_fundingStartBlock <= block.number) revert();\n        if (_fundingEndBlock   <= _fundingStartBlock) revert();\n\n        lockedAllocation = new GNTAllocation(_golemFactory);\n        migrationMaster = _migrationMaster;\n        golemFactory = _golemFactory;\n        fundingStartBlock = _fundingStartBlock;\n        fundingEndBlock = _fundingEndBlock;\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    function transfer(address _to, uint256 _value) returns (bool) {\n        // Abort if not in Operational state.\n        if (funding) revert();\n\n        var senderBalance = balances[msg.sender];\n        if (senderBalance >= _value && _value > 0) {\n            senderBalance -= _value;\n            balances[msg.sender] = senderBalance;\n            balances[_to] += _value;\n            Transfer(msg.sender, _to, _value);\n            return true;\n        }\n        return false;\n    }\n\n    function totalSupply() external view returns (uint256) {\n        return totalTokens;\n    }\n\n    function balanceOf(address _owner) external view returns (uint256) {\n        return balances[_owner];\n    }\n\n    // Token migration support:\n\n    \n    \n    \n    function migrate(uint256 _value) external {\n        // Abort if not in Operational Migration state.\n        if (funding) revert();\n        if (migrationAgent == 0) revert();\n\n        // Validate input value.\n        if (_value == 0) revert();\n        if (_value > balances[msg.sender]) revert();\n\n        balances[msg.sender] -= _value;\n        totalTokens -= _value;\n        totalMigrated += _value;\n        MigrationAgent(migrationAgent).migrateFrom(msg.sender, _value);\n        Migrate(msg.sender, migrationAgent, _value);\n    }\n\n    \n\t\n    \n    \n    \n    function setMigrationAgent(address _agent) external {\n        // Abort if not in Operational Normal state.\n        if (funding) revert();\n        if (migrationAgent != 0) revert();\n        if (msg.sender != migrationMaster) revert();\n        migrationAgent = _agent;\n    }\n\n    function setMigrationMaster(address _master) external {\n        if (msg.sender != migrationMaster) revert();\n        if (_master == 0) revert();\n        migrationMaster = _master;\n    }\n\n    // Crowdfunding:\n\n    \n    \n    \n    function create() payable external {\n        // Abort if not in Funding Active state.\n        // The checks are split (instead of using or operator) because it is\n        // cheaper this way.\n        if (!funding) revert();\n        if (block.number < fundingStartBlock) revert();\n        if (block.number > fundingEndBlock) revert();\n\n        // Do not allow creating 0 or more than the cap tokens.\n        if (msg.value == 0) revert();\n        if (msg.value > (tokenCreationCap - totalTokens) / tokenCreationRate)\n            revert();\n\n        var numTokens = msg.value * tokenCreationRate;\n        totalTokens += numTokens;\n\n        // Assign new tokens to the sender\n        balances[msg.sender] += numTokens;\n\n        // Log token creation event\n        Transfer(0, msg.sender, numTokens);\n    }\n\n    \n    \n    \n    \n    \n    \n    function finalize() external {\n        // Abort if not in Funding Success state.\n        if (!funding) revert();\n        if ((block.number <= fundingEndBlock ||\n             totalTokens < tokenCreationMin) &&\n            totalTokens < tokenCreationCap) revert();\n\n        // Switch to Operational state. This is the only place this can happen.\n        funding = false;\n\n        // Create additional GNT for the Golem Factory and developers as\n        // the 18% of total number of tokens.\n        // All additional tokens are transfered to the account controller by\n        // GNTAllocation contract which will not allow using them for 6 months.\n        uint256 percentOfTotal = 18;\n        uint256 additionalTokens =\n            totalTokens * percentOfTotal / (100 - percentOfTotal);\n        totalTokens += additionalTokens;\n        balances[lockedAllocation] += additionalTokens;\n        Transfer(0, lockedAllocation, additionalTokens);\n\n        // Transfer ETH to the Golem Factory address.\n        if (!golemFactory.send(this.balance)) revert();\n    }\n\n    \n    \n    \n    function refund() external {\n        // Abort if not in Funding Failure state.\n        if (!funding) revert();\n        if (block.number <= fundingEndBlock) revert();\n        if (totalTokens >= tokenCreationMin) revert();\n\n        var gntValue = balances[msg.sender];\n        if (gntValue == 0) revert();\n        balances[msg.sender] = 0;\n        totalTokens -= gntValue;\n\n        var ethValue = gntValue / tokenCreationRate;\n        Refund(msg.sender, ethValue);\n        if (!msg.sender.send(ethValue)) revert();\n    }\n}",
        "function": "finalize()",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/Faucet.sol",
        "vulnerability": "Dependence on predictable environment variable (SWC 120)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract GolemNetworkToken {\n    string public constant name = \"Test Golem Network Token\";\n    string public constant symbol = \"tGNT\";\n    uint8 public constant decimals = 18;  // 18 decimal places, the same as ETH.\n\n    uint256 public constant tokenCreationRate = 10000000000;\n\n    // The funding cap in weis.\n    uint256 public constant tokenCreationCap = 82 finney * tokenCreationRate;\n    uint256 public constant tokenCreationMin = 15 finney * tokenCreationRate;\n\n    uint256 public fundingStartBlock;\n    uint256 public fundingEndBlock;\n\n    // The flag indicates if the GNT contract is in Funding state.\n    bool public funding = true;\n\n    // Receives ETH and its own GNT endowment.\n    address public golemFactory;\n\n    // Has control over token migration to next version of token.\n    address public migrationMaster;\n\n    GNTAllocation lockedAllocation;\n\n    // The current total token supply.\n    uint256 public totalTokens;\n\n    mapping (address => uint256) balances;\n\n    address public migrationAgent;\n    uint256 public totalMigrated;\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Migrate(address indexed _from, address indexed _to, uint256 _value);\n    event Refund(address indexed _from, uint256 _value);\n\n    function GolemNetworkToken(address _golemFactory,\n                               address _migrationMaster,\n                               uint256 _fundingStartBlock,\n                               uint256 _fundingEndBlock) {\n\n        if (_golemFactory == 0) revert();\n        if (_migrationMaster == 0) revert();\n        if (_fundingStartBlock <= block.number) revert();\n        if (_fundingEndBlock   <= _fundingStartBlock) revert();\n\n        lockedAllocation = new GNTAllocation(_golemFactory);\n        migrationMaster = _migrationMaster;\n        golemFactory = _golemFactory;\n        fundingStartBlock = _fundingStartBlock;\n        fundingEndBlock = _fundingEndBlock;\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    function transfer(address _to, uint256 _value) returns (bool) {\n        // Abort if not in Operational state.\n        if (funding) revert();\n\n        var senderBalance = balances[msg.sender];\n        if (senderBalance >= _value && _value > 0) {\n            senderBalance -= _value;\n            balances[msg.sender] = senderBalance;\n            balances[_to] += _value;\n            Transfer(msg.sender, _to, _value);\n            return true;\n        }\n        return false;\n    }\n\n    function totalSupply() external view returns (uint256) {\n        return totalTokens;\n    }\n\n    function balanceOf(address _owner) external view returns (uint256) {\n        return balances[_owner];\n    }\n\n    // Token migration support:\n\n    \n    \n    \n    function migrate(uint256 _value) external {\n        // Abort if not in Operational Migration state.\n        if (funding) revert();\n        if (migrationAgent == 0) revert();\n\n        // Validate input value.\n        if (_value == 0) revert();\n        if (_value > balances[msg.sender]) revert();\n\n        balances[msg.sender] -= _value;\n        totalTokens -= _value;\n        totalMigrated += _value;\n        MigrationAgent(migrationAgent).migrateFrom(msg.sender, _value);\n        Migrate(msg.sender, migrationAgent, _value);\n    }\n\n    \n\t\n    \n    \n    \n    function setMigrationAgent(address _agent) external {\n        // Abort if not in Operational Normal state.\n        if (funding) revert();\n        if (migrationAgent != 0) revert();\n        if (msg.sender != migrationMaster) revert();\n        migrationAgent = _agent;\n    }\n\n    function setMigrationMaster(address _master) external {\n        if (msg.sender != migrationMaster) revert();\n        if (_master == 0) revert();\n        migrationMaster = _master;\n    }\n\n    // Crowdfunding:\n\n    \n    \n    \n    function create() payable external {\n        // Abort if not in Funding Active state.\n        // The checks are split (instead of using or operator) because it is\n        // cheaper this way.\n        if (!funding) revert();\n        if (block.number < fundingStartBlock) revert();\n        if (block.number > fundingEndBlock) revert();\n\n        // Do not allow creating 0 or more than the cap tokens.\n        if (msg.value == 0) revert();\n        if (msg.value > (tokenCreationCap - totalTokens) / tokenCreationRate)\n            revert();\n\n        var numTokens = msg.value * tokenCreationRate;\n        totalTokens += numTokens;\n\n        // Assign new tokens to the sender\n        balances[msg.sender] += numTokens;\n\n        // Log token creation event\n        Transfer(0, msg.sender, numTokens);\n    }\n\n    \n    \n    \n    \n    \n    \n    function finalize() external {\n        // Abort if not in Funding Success state.\n        if (!funding) revert();\n        if ((block.number <= fundingEndBlock ||\n             totalTokens < tokenCreationMin) &&\n            totalTokens < tokenCreationCap) revert();\n\n        // Switch to Operational state. This is the only place this can happen.\n        funding = false;\n\n        // Create additional GNT for the Golem Factory and developers as\n        // the 18% of total number of tokens.\n        // All additional tokens are transfered to the account controller by\n        // GNTAllocation contract which will not allow using them for 6 months.\n        uint256 percentOfTotal = 18;\n        uint256 additionalTokens =\n            totalTokens * percentOfTotal / (100 - percentOfTotal);\n        totalTokens += additionalTokens;\n        balances[lockedAllocation] += additionalTokens;\n        Transfer(0, lockedAllocation, additionalTokens);\n\n        // Transfer ETH to the Golem Factory address.\n        if (!golemFactory.send(this.balance)) revert();\n    }\n\n    \n    \n    \n    function refund() external {\n        // Abort if not in Funding Failure state.\n        if (!funding) revert();\n        if (block.number <= fundingEndBlock) revert();\n        if (totalTokens >= tokenCreationMin) revert();\n\n        var gntValue = balances[msg.sender];\n        if (gntValue == 0) revert();\n        balances[msg.sender] = 0;\n        totalTokens -= gntValue;\n\n        var ethValue = gntValue / tokenCreationRate;\n        Refund(msg.sender, ethValue);\n        if (!msg.sender.send(ethValue)) revert();\n    }\n}",
        "function": "finalize()",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/Faucet.sol",
        "vulnerability": "Dependence on predictable environment variable (SWC 120)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract GolemNetworkToken {\n    string public constant name = \"Test Golem Network Token\";\n    string public constant symbol = \"tGNT\";\n    uint8 public constant decimals = 18;  // 18 decimal places, the same as ETH.\n\n    uint256 public constant tokenCreationRate = 10000000000;\n\n    // The funding cap in weis.\n    uint256 public constant tokenCreationCap = 82 finney * tokenCreationRate;\n    uint256 public constant tokenCreationMin = 15 finney * tokenCreationRate;\n\n    uint256 public fundingStartBlock;\n    uint256 public fundingEndBlock;\n\n    // The flag indicates if the GNT contract is in Funding state.\n    bool public funding = true;\n\n    // Receives ETH and its own GNT endowment.\n    address public golemFactory;\n\n    // Has control over token migration to next version of token.\n    address public migrationMaster;\n\n    GNTAllocation lockedAllocation;\n\n    // The current total token supply.\n    uint256 public totalTokens;\n\n    mapping (address => uint256) balances;\n\n    address public migrationAgent;\n    uint256 public totalMigrated;\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Migrate(address indexed _from, address indexed _to, uint256 _value);\n    event Refund(address indexed _from, uint256 _value);\n\n    function GolemNetworkToken(address _golemFactory,\n                               address _migrationMaster,\n                               uint256 _fundingStartBlock,\n                               uint256 _fundingEndBlock) {\n\n        if (_golemFactory == 0) revert();\n        if (_migrationMaster == 0) revert();\n        if (_fundingStartBlock <= block.number) revert();\n        if (_fundingEndBlock   <= _fundingStartBlock) revert();\n\n        lockedAllocation = new GNTAllocation(_golemFactory);\n        migrationMaster = _migrationMaster;\n        golemFactory = _golemFactory;\n        fundingStartBlock = _fundingStartBlock;\n        fundingEndBlock = _fundingEndBlock;\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    function transfer(address _to, uint256 _value) returns (bool) {\n        // Abort if not in Operational state.\n        if (funding) revert();\n\n        var senderBalance = balances[msg.sender];\n        if (senderBalance >= _value && _value > 0) {\n            senderBalance -= _value;\n            balances[msg.sender] = senderBalance;\n            balances[_to] += _value;\n            Transfer(msg.sender, _to, _value);\n            return true;\n        }\n        return false;\n    }\n\n    function totalSupply() external view returns (uint256) {\n        return totalTokens;\n    }\n\n    function balanceOf(address _owner) external view returns (uint256) {\n        return balances[_owner];\n    }\n\n    // Token migration support:\n\n    \n    \n    \n    function migrate(uint256 _value) external {\n        // Abort if not in Operational Migration state.\n        if (funding) revert();\n        if (migrationAgent == 0) revert();\n\n        // Validate input value.\n        if (_value == 0) revert();\n        if (_value > balances[msg.sender]) revert();\n\n        balances[msg.sender] -= _value;\n        totalTokens -= _value;\n        totalMigrated += _value;\n        MigrationAgent(migrationAgent).migrateFrom(msg.sender, _value);\n        Migrate(msg.sender, migrationAgent, _value);\n    }\n\n    \n\t\n    \n    \n    \n    function setMigrationAgent(address _agent) external {\n        // Abort if not in Operational Normal state.\n        if (funding) revert();\n        if (migrationAgent != 0) revert();\n        if (msg.sender != migrationMaster) revert();\n        migrationAgent = _agent;\n    }\n\n    function setMigrationMaster(address _master) external {\n        if (msg.sender != migrationMaster) revert();\n        if (_master == 0) revert();\n        migrationMaster = _master;\n    }\n\n    // Crowdfunding:\n\n    \n    \n    \n    function create() payable external {\n        // Abort if not in Funding Active state.\n        // The checks are split (instead of using or operator) because it is\n        // cheaper this way.\n        if (!funding) revert();\n        if (block.number < fundingStartBlock) revert();\n        if (block.number > fundingEndBlock) revert();\n\n        // Do not allow creating 0 or more than the cap tokens.\n        if (msg.value == 0) revert();\n        if (msg.value > (tokenCreationCap - totalTokens) / tokenCreationRate)\n            revert();\n\n        var numTokens = msg.value * tokenCreationRate;\n        totalTokens += numTokens;\n\n        // Assign new tokens to the sender\n        balances[msg.sender] += numTokens;\n\n        // Log token creation event\n        Transfer(0, msg.sender, numTokens);\n    }\n\n    \n    \n    \n    \n    \n    \n    function finalize() external {\n        // Abort if not in Funding Success state.\n        if (!funding) revert();\n        if ((block.number <= fundingEndBlock ||\n             totalTokens < tokenCreationMin) &&\n            totalTokens < tokenCreationCap) revert();\n\n        // Switch to Operational state. This is the only place this can happen.\n        funding = false;\n\n        // Create additional GNT for the Golem Factory and developers as\n        // the 18% of total number of tokens.\n        // All additional tokens are transfered to the account controller by\n        // GNTAllocation contract which will not allow using them for 6 months.\n        uint256 percentOfTotal = 18;\n        uint256 additionalTokens =\n            totalTokens * percentOfTotal / (100 - percentOfTotal);\n        totalTokens += additionalTokens;\n        balances[lockedAllocation] += additionalTokens;\n        Transfer(0, lockedAllocation, additionalTokens);\n\n        // Transfer ETH to the Golem Factory address.\n        if (!golemFactory.send(this.balance)) revert();\n    }\n\n    \n    \n    \n    function refund() external {\n        // Abort if not in Funding Failure state.\n        if (!funding) revert();\n        if (block.number <= fundingEndBlock) revert();\n        if (totalTokens >= tokenCreationMin) revert();\n\n        var gntValue = balances[msg.sender];\n        if (gntValue == 0) revert();\n        balances[msg.sender] = 0;\n        totalTokens -= gntValue;\n\n        var ethValue = gntValue / tokenCreationRate;\n        Refund(msg.sender, ethValue);\n        if (!msg.sender.send(ethValue)) revert();\n    }\n}",
        "function": "refund()",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/Faucet.sol",
        "vulnerability": "Dependence on predictable environment variable (SWC 120)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract GolemNetworkToken {\n    string public constant name = \"Test Golem Network Token\";\n    string public constant symbol = \"tGNT\";\n    uint8 public constant decimals = 18;  // 18 decimal places, the same as ETH.\n\n    uint256 public constant tokenCreationRate = 10000000000;\n\n    // The funding cap in weis.\n    uint256 public constant tokenCreationCap = 82 finney * tokenCreationRate;\n    uint256 public constant tokenCreationMin = 15 finney * tokenCreationRate;\n\n    uint256 public fundingStartBlock;\n    uint256 public fundingEndBlock;\n\n    // The flag indicates if the GNT contract is in Funding state.\n    bool public funding = true;\n\n    // Receives ETH and its own GNT endowment.\n    address public golemFactory;\n\n    // Has control over token migration to next version of token.\n    address public migrationMaster;\n\n    GNTAllocation lockedAllocation;\n\n    // The current total token supply.\n    uint256 public totalTokens;\n\n    mapping (address => uint256) balances;\n\n    address public migrationAgent;\n    uint256 public totalMigrated;\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Migrate(address indexed _from, address indexed _to, uint256 _value);\n    event Refund(address indexed _from, uint256 _value);\n\n    function GolemNetworkToken(address _golemFactory,\n                               address _migrationMaster,\n                               uint256 _fundingStartBlock,\n                               uint256 _fundingEndBlock) {\n\n        if (_golemFactory == 0) revert();\n        if (_migrationMaster == 0) revert();\n        if (_fundingStartBlock <= block.number) revert();\n        if (_fundingEndBlock   <= _fundingStartBlock) revert();\n\n        lockedAllocation = new GNTAllocation(_golemFactory);\n        migrationMaster = _migrationMaster;\n        golemFactory = _golemFactory;\n        fundingStartBlock = _fundingStartBlock;\n        fundingEndBlock = _fundingEndBlock;\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    function transfer(address _to, uint256 _value) returns (bool) {\n        // Abort if not in Operational state.\n        if (funding) revert();\n\n        var senderBalance = balances[msg.sender];\n        if (senderBalance >= _value && _value > 0) {\n            senderBalance -= _value;\n            balances[msg.sender] = senderBalance;\n            balances[_to] += _value;\n            Transfer(msg.sender, _to, _value);\n            return true;\n        }\n        return false;\n    }\n\n    function totalSupply() external view returns (uint256) {\n        return totalTokens;\n    }\n\n    function balanceOf(address _owner) external view returns (uint256) {\n        return balances[_owner];\n    }\n\n    // Token migration support:\n\n    \n    \n    \n    function migrate(uint256 _value) external {\n        // Abort if not in Operational Migration state.\n        if (funding) revert();\n        if (migrationAgent == 0) revert();\n\n        // Validate input value.\n        if (_value == 0) revert();\n        if (_value > balances[msg.sender]) revert();\n\n        balances[msg.sender] -= _value;\n        totalTokens -= _value;\n        totalMigrated += _value;\n        MigrationAgent(migrationAgent).migrateFrom(msg.sender, _value);\n        Migrate(msg.sender, migrationAgent, _value);\n    }\n\n    \n\t\n    \n    \n    \n    function setMigrationAgent(address _agent) external {\n        // Abort if not in Operational Normal state.\n        if (funding) revert();\n        if (migrationAgent != 0) revert();\n        if (msg.sender != migrationMaster) revert();\n        migrationAgent = _agent;\n    }\n\n    function setMigrationMaster(address _master) external {\n        if (msg.sender != migrationMaster) revert();\n        if (_master == 0) revert();\n        migrationMaster = _master;\n    }\n\n    // Crowdfunding:\n\n    \n    \n    \n    function create() payable external {\n        // Abort if not in Funding Active state.\n        // The checks are split (instead of using or operator) because it is\n        // cheaper this way.\n        if (!funding) revert();\n        if (block.number < fundingStartBlock) revert();\n        if (block.number > fundingEndBlock) revert();\n\n        // Do not allow creating 0 or more than the cap tokens.\n        if (msg.value == 0) revert();\n        if (msg.value > (tokenCreationCap - totalTokens) / tokenCreationRate)\n            revert();\n\n        var numTokens = msg.value * tokenCreationRate;\n        totalTokens += numTokens;\n\n        // Assign new tokens to the sender\n        balances[msg.sender] += numTokens;\n\n        // Log token creation event\n        Transfer(0, msg.sender, numTokens);\n    }\n\n    \n    \n    \n    \n    \n    \n    function finalize() external {\n        // Abort if not in Funding Success state.\n        if (!funding) revert();\n        if ((block.number <= fundingEndBlock ||\n             totalTokens < tokenCreationMin) &&\n            totalTokens < tokenCreationCap) revert();\n\n        // Switch to Operational state. This is the only place this can happen.\n        funding = false;\n\n        // Create additional GNT for the Golem Factory and developers as\n        // the 18% of total number of tokens.\n        // All additional tokens are transfered to the account controller by\n        // GNTAllocation contract which will not allow using them for 6 months.\n        uint256 percentOfTotal = 18;\n        uint256 additionalTokens =\n            totalTokens * percentOfTotal / (100 - percentOfTotal);\n        totalTokens += additionalTokens;\n        balances[lockedAllocation] += additionalTokens;\n        Transfer(0, lockedAllocation, additionalTokens);\n\n        // Transfer ETH to the Golem Factory address.\n        if (!golemFactory.send(this.balance)) revert();\n    }\n\n    \n    \n    \n    function refund() external {\n        // Abort if not in Funding Failure state.\n        if (!funding) revert();\n        if (block.number <= fundingEndBlock) revert();\n        if (totalTokens >= tokenCreationMin) revert();\n\n        var gntValue = balances[msg.sender];\n        if (gntValue == 0) revert();\n        balances[msg.sender] = 0;\n        totalTokens -= gntValue;\n\n        var ethValue = gntValue / tokenCreationRate;\n        Refund(msg.sender, ethValue);\n        if (!msg.sender.send(ethValue)) revert();\n    }\n}",
        "function": "create()",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/Faucet.sol",
        "vulnerability": "Dependence on predictable environment variable (SWC 120)",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract BaseMine is InitializableOwnable {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    // ============ Storage ============\n\n    struct RewardTokenInfo {\n        address rewardToken;\n        uint256 startBlock;\n        uint256 endBlock;\n        address rewardVault;\n        uint256 rewardPerBlock;\n        uint256 accRewardPerShare;\n        uint256 lastRewardBlock;\n        uint256 workThroughReward;\n        uint256 lastFlagBlock;\n        mapping(address => uint256) userRewardPerSharePaid;\n        mapping(address => uint256) userRewards;\n    }\n\n    RewardTokenInfo[] public rewardTokenInfos;\n\n    uint256 internal _totalSupply;\n    mapping(address => uint256) internal _balances;\n\n    // ============ Event =============\n\n    event Claim(uint256 indexed i, address indexed user, uint256 reward);\n    event UpdateReward(uint256 indexed i, uint256 rewardPerBlock);\n    event UpdateEndBlock(uint256 indexed i, uint256 endBlock);\n    event NewRewardToken(uint256 indexed i, address rewardToken);\n    event RemoveRewardToken(address rewardToken);\n    event WithdrawLeftOver(address owner, uint256 i);\n\n    // ============ View  ============\n\n    function getPendingReward(address user, uint256 i) public view returns (uint256) {\n        require(i<rewardTokenInfos.length, \"DODOMineV3: REWARD_ID_NOT_FOUND\");\n        RewardTokenInfo storage rt = rewardTokenInfos[i];\n        uint256 accRewardPerShare = rt.accRewardPerShare;\n        if (rt.lastRewardBlock != block.number) {\n            accRewardPerShare = _getAccRewardPerShare(i);\n        }\n        return\n            DecimalMath.mulFloor(\n                balanceOf(user), \n                accRewardPerShare.sub(rt.userRewardPerSharePaid[user])\n            ).add(rt.userRewards[user]);\n    }\n\n    function getPendingRewardByToken(address user, address rewardToken) external view returns (uint256) {\n        return getPendingReward(user, getIdByRewardToken(rewardToken));\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address user) public view returns (uint256) {\n        return _balances[user];\n    }\n\n    function getRewardTokenById(uint256 i) external view returns (address) {\n        require(i<rewardTokenInfos.length, \"DODOMineV3: REWARD_ID_NOT_FOUND\");\n        RewardTokenInfo memory rt = rewardTokenInfos[i];\n        return rt.rewardToken;\n    }\n\n    function getIdByRewardToken(address rewardToken) public view returns(uint256) {\n        uint256 len = rewardTokenInfos.length;\n        for (uint256 i = 0; i < len; i++) {\n            if (rewardToken == rewardTokenInfos[i].rewardToken) {\n                return i;\n            }\n        }\n        require(false, \"DODOMineV3: TOKEN_NOT_FOUND\");\n    }\n\n    function getRewardNum() external view returns(uint256) {\n        return rewardTokenInfos.length;\n    }\n\n    function getVaultByRewardToken(address rewardToken) public view returns(address) {\n        uint256 len = rewardTokenInfos.length;\n        for (uint256 i = 0; i < len; i++) {\n            if (rewardToken == rewardTokenInfos[i].rewardToken) {\n                return rewardTokenInfos[i].rewardVault;\n            }\n        }\n        require(false, \"DODOMineV3: TOKEN_NOT_FOUND\");\n    }\n\n    function getVaultDebtByRewardToken(address rewardToken) public view returns(uint256) {\n        uint256 len = rewardTokenInfos.length;\n        for (uint256 i = 0; i < len; i++) {\n            if (rewardToken == rewardTokenInfos[i].rewardToken) {\n                uint256 totalDepositReward = IRewardVault(rewardTokenInfos[i].rewardVault)._TOTAL_REWARD_();\n                uint256 gap = rewardTokenInfos[i].endBlock.sub(rewardTokenInfos[i].lastFlagBlock);\n                uint256 totalReward = rewardTokenInfos[i].workThroughReward.add(gap.mul(rewardTokenInfos[i].rewardPerBlock));\n                if(totalDepositReward >= totalReward) {\n                    return 0;\n                }else {\n                    return totalReward.sub(totalDepositReward);\n                }\n            }\n        }\n        require(false, \"DODOMineV3: TOKEN_NOT_FOUND\");\n    }\n\n    // ============ Claim ============\n\n    function claimReward(uint256 i) public {\n        require(i<rewardTokenInfos.length, \"DODOMineV3: REWARD_ID_NOT_FOUND\");\n        _updateReward(msg.sender, i);\n        RewardTokenInfo storage rt = rewardTokenInfos[i];\n        uint256 reward = rt.userRewards[msg.sender];\n        if (reward > 0) {\n            rt.userRewards[msg.sender] = 0;\n            IRewardVault(rt.rewardVault).reward(msg.sender, reward);\n            emit Claim(i, msg.sender, reward);\n        }\n    }\n\n    function claimAllRewards() external {\n        uint256 len = rewardTokenInfos.length;\n        for (uint256 i = 0; i < len; i++) {\n            claimReward(i);\n        }\n    }\n\n    // =============== Ownable  ================\n\n    function addRewardToken(\n        address rewardToken,\n        uint256 rewardPerBlock,\n        uint256 startBlock,\n        uint256 endBlock\n    ) external onlyOwner {\n        require(rewardToken != address(0), \"DODOMineV3: TOKEN_INVALID\");\n        require(startBlock > block.number, \"DODOMineV3: START_BLOCK_INVALID\");\n        require(endBlock > startBlock, \"DODOMineV3: DURATION_INVALID\");\n\n        uint256 len = rewardTokenInfos.length;\n        for (uint256 i = 0; i < len; i++) {\n            require(\n                rewardToken != rewardTokenInfos[i].rewardToken,\n                \"DODOMineV3: TOKEN_ALREADY_ADDED\"\n            );\n        }\n\n        RewardTokenInfo storage rt = rewardTokenInfos.push();\n        rt.rewardToken = rewardToken;\n        rt.startBlock = startBlock;\n        rt.lastFlagBlock = startBlock;\n        rt.endBlock = endBlock;\n        rt.rewardPerBlock = rewardPerBlock;\n        rt.rewardVault = address(new RewardVault(rewardToken));\n\n        uint256 rewardAmount = rewardPerBlock.mul(endBlock.sub(startBlock));\n        IERC20(rewardToken).transfer(rt.rewardVault, rewardAmount);\n        RewardVault(rt.rewardVault).syncValue();\n\n        emit NewRewardToken(len, rewardToken);\n    }\n\n    function setEndBlock(uint256 i, uint256 newEndBlock)\n        external\n        onlyOwner\n    {\n        require(i < rewardTokenInfos.length, \"DODOMineV3: REWARD_ID_NOT_FOUND\");\n        _updateReward(address(0), i);\n        RewardTokenInfo storage rt = rewardTokenInfos[i];\n\n\n        uint256 totalDepositReward = RewardVault(rt.rewardVault)._TOTAL_REWARD_();\n        uint256 gap = newEndBlock.sub(rt.lastFlagBlock);\n        uint256 totalReward = rt.workThroughReward.add(gap.mul(rt.rewardPerBlock));\n        require(totalDepositReward >= totalReward, \"DODOMineV3: REWARD_NOT_ENOUGH\");\n\n        require(block.number < newEndBlock, \"DODOMineV3: END_BLOCK_INVALID\");\n        require(block.number > rt.startBlock, \"DODOMineV3: NOT_START\");\n        require(block.number < rt.endBlock, \"DODOMineV3: ALREADY_CLOSE\");\n\n        rt.endBlock = newEndBlock;\n        emit UpdateEndBlock(i, newEndBlock);\n    }\n\n    function setReward(uint256 i, uint256 newRewardPerBlock)\n        external\n        onlyOwner\n    {\n        require(i < rewardTokenInfos.length, \"DODOMineV3: REWARD_ID_NOT_FOUND\");\n        _updateReward(address(0), i);\n        RewardTokenInfo storage rt = rewardTokenInfos[i];\n        \n        require(block.number < rt.endBlock, \"DODOMineV3: ALREADY_CLOSE\");\n        \n        rt.workThroughReward = rt.workThroughReward.add((block.number.sub(rt.lastFlagBlock)).mul(rt.rewardPerBlock));\n        rt.rewardPerBlock = newRewardPerBlock;\n        rt.lastFlagBlock = block.number;\n\n        uint256 totalDepositReward = RewardVault(rt.rewardVault)._TOTAL_REWARD_();\n        uint256 gap = rt.endBlock.sub(block.number);\n        uint256 totalReward = rt.workThroughReward.add(gap.mul(newRewardPerBlock));\n        require(totalDepositReward >= totalReward, \"DODOMineV3: REWARD_NOT_ENOUGH\");\n\n        emit UpdateReward(i, newRewardPerBlock);\n    }\n\n    function withdrawLeftOver(uint256 i, uint256 amount) external onlyOwner {\n        require(i < rewardTokenInfos.length, \"DODOMineV3: REWARD_ID_NOT_FOUND\");\n        \n        RewardTokenInfo storage rt = rewardTokenInfos[i];\n        require(block.number > rt.endBlock, \"DODOMineV3: MINING_NOT_FINISHED\");\n\n        IRewardVault(rt.rewardVault).withdrawLeftOver(msg.sender,amount);\n\n        emit WithdrawLeftOver(msg.sender, i);\n    }\n\n\n    function directTransferOwnership(address newOwner) external onlyOwner {\n        require(newOwner != address(0), \"DODOMineV3: ZERO_ADDRESS\");\n        emit OwnershipTransferred(_OWNER_, newOwner);\n        _OWNER_ = newOwner;\n    }\n\n    // ============ Internal  ============\n\n    function _updateReward(address user, uint256 i) internal {\n        RewardTokenInfo storage rt = rewardTokenInfos[i];\n        if (rt.lastRewardBlock != block.number){\n            rt.accRewardPerShare = _getAccRewardPerShare(i);\n            rt.lastRewardBlock = block.number;\n        }\n        if (user != address(0)) {\n            rt.userRewards[user] = getPendingReward(user, i);\n            rt.userRewardPerSharePaid[user] = rt.accRewardPerShare;\n        }\n    }\n    // SWC-128-DoS With Block Gas Limit: L260-L262\n    function _updateAllReward(address user) internal {\n        uint256 len = rewardTokenInfos.length;\n        for (uint256 i = 0; i < len; i++) {\n            _updateReward(user, i);\n        }\n    }\n\n    function _getUnrewardBlockNum(uint256 i) internal view returns (uint256) {\n        RewardTokenInfo memory rt = rewardTokenInfos[i];\n        if (block.number < rt.startBlock || rt.lastRewardBlock > rt.endBlock) {\n            return 0;\n        }\n        uint256 start = rt.lastRewardBlock < rt.startBlock ? rt.startBlock : rt.lastRewardBlock;\n        uint256 end = rt.endBlock < block.number ? rt.endBlock : block.number;\n        return end.sub(start);\n    }\n\n    function _getAccRewardPerShare(uint256 i) internal view returns (uint256) {\n        RewardTokenInfo memory rt = rewardTokenInfos[i];\n        if (totalSupply() == 0) {\n            return rt.accRewardPerShare;\n        }\n        return\n            rt.accRewardPerShare.add(\n                DecimalMath.divFloor(_getUnrewardBlockNum(i).mul(rt.rewardPerBlock), totalSupply())\n            );\n    }\n\n}",
        "function": "rewardTokenInfos(uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/SlowMist-DODO-MiningV3 and NFT Smart Contract Security Audit Report/contractV2-c7202eeae724783f572232a1d80b6b9082ee90b1/contracts/DODOToken/DODOMineV3/BaseMine.sol",
        "vulnerability": "Exception State (SWC 110)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract BaseMine is InitializableOwnable {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    // ============ Storage ============\n\n    struct RewardTokenInfo {\n        address rewardToken;\n        uint256 startBlock;\n        uint256 endBlock;\n        address rewardVault;\n        uint256 rewardPerBlock;\n        uint256 accRewardPerShare;\n        uint256 lastRewardBlock;\n        uint256 workThroughReward;\n        uint256 lastFlagBlock;\n        mapping(address => uint256) userRewardPerSharePaid;\n        mapping(address => uint256) userRewards;\n    }\n\n    RewardTokenInfo[] public rewardTokenInfos;\n\n    uint256 internal _totalSupply;\n    mapping(address => uint256) internal _balances;\n\n    // ============ Event =============\n\n    event Claim(uint256 indexed i, address indexed user, uint256 reward);\n    event UpdateReward(uint256 indexed i, uint256 rewardPerBlock);\n    event UpdateEndBlock(uint256 indexed i, uint256 endBlock);\n    event NewRewardToken(uint256 indexed i, address rewardToken);\n    event RemoveRewardToken(address rewardToken);\n    event WithdrawLeftOver(address owner, uint256 i);\n\n    // ============ View  ============\n\n    function getPendingReward(address user, uint256 i) public view returns (uint256) {\n        require(i<rewardTokenInfos.length, \"DODOMineV3: REWARD_ID_NOT_FOUND\");\n        RewardTokenInfo storage rt = rewardTokenInfos[i];\n        uint256 accRewardPerShare = rt.accRewardPerShare;\n        if (rt.lastRewardBlock != block.number) {\n            accRewardPerShare = _getAccRewardPerShare(i);\n        }\n        return\n            DecimalMath.mulFloor(\n                balanceOf(user), \n                accRewardPerShare.sub(rt.userRewardPerSharePaid[user])\n            ).add(rt.userRewards[user]);\n    }\n\n    function getPendingRewardByToken(address user, address rewardToken) external view returns (uint256) {\n        return getPendingReward(user, getIdByRewardToken(rewardToken));\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address user) public view returns (uint256) {\n        return _balances[user];\n    }\n\n    function getRewardTokenById(uint256 i) external view returns (address) {\n        require(i<rewardTokenInfos.length, \"DODOMineV3: REWARD_ID_NOT_FOUND\");\n        RewardTokenInfo memory rt = rewardTokenInfos[i];\n        return rt.rewardToken;\n    }\n\n    function getIdByRewardToken(address rewardToken) public view returns(uint256) {\n        uint256 len = rewardTokenInfos.length;\n        for (uint256 i = 0; i < len; i++) {\n            if (rewardToken == rewardTokenInfos[i].rewardToken) {\n                return i;\n            }\n        }\n        require(false, \"DODOMineV3: TOKEN_NOT_FOUND\");\n    }\n\n    function getRewardNum() external view returns(uint256) {\n        return rewardTokenInfos.length;\n    }\n\n    function getVaultByRewardToken(address rewardToken) public view returns(address) {\n        uint256 len = rewardTokenInfos.length;\n        for (uint256 i = 0; i < len; i++) {\n            if (rewardToken == rewardTokenInfos[i].rewardToken) {\n                return rewardTokenInfos[i].rewardVault;\n            }\n        }\n        require(false, \"DODOMineV3: TOKEN_NOT_FOUND\");\n    }\n\n    function getVaultDebtByRewardToken(address rewardToken) public view returns(uint256) {\n        uint256 len = rewardTokenInfos.length;\n        for (uint256 i = 0; i < len; i++) {\n            if (rewardToken == rewardTokenInfos[i].rewardToken) {\n                uint256 totalDepositReward = IRewardVault(rewardTokenInfos[i].rewardVault)._TOTAL_REWARD_();\n                uint256 gap = rewardTokenInfos[i].endBlock.sub(rewardTokenInfos[i].lastFlagBlock);\n                uint256 totalReward = rewardTokenInfos[i].workThroughReward.add(gap.mul(rewardTokenInfos[i].rewardPerBlock));\n                if(totalDepositReward >= totalReward) {\n                    return 0;\n                }else {\n                    return totalReward.sub(totalDepositReward);\n                }\n            }\n        }\n        require(false, \"DODOMineV3: TOKEN_NOT_FOUND\");\n    }\n\n    // ============ Claim ============\n\n    function claimReward(uint256 i) public {\n        require(i<rewardTokenInfos.length, \"DODOMineV3: REWARD_ID_NOT_FOUND\");\n        _updateReward(msg.sender, i);\n        RewardTokenInfo storage rt = rewardTokenInfos[i];\n        uint256 reward = rt.userRewards[msg.sender];\n        if (reward > 0) {\n            rt.userRewards[msg.sender] = 0;\n            IRewardVault(rt.rewardVault).reward(msg.sender, reward);\n            emit Claim(i, msg.sender, reward);\n        }\n    }\n\n    function claimAllRewards() external {\n        uint256 len = rewardTokenInfos.length;\n        for (uint256 i = 0; i < len; i++) {\n            claimReward(i);\n        }\n    }\n\n    // =============== Ownable  ================\n\n    function addRewardToken(\n        address rewardToken,\n        uint256 rewardPerBlock,\n        uint256 startBlock,\n        uint256 endBlock\n    ) external onlyOwner {\n        require(rewardToken != address(0), \"DODOMineV3: TOKEN_INVALID\");\n        require(startBlock > block.number, \"DODOMineV3: START_BLOCK_INVALID\");\n        require(endBlock > startBlock, \"DODOMineV3: DURATION_INVALID\");\n\n        uint256 len = rewardTokenInfos.length;\n        for (uint256 i = 0; i < len; i++) {\n            require(\n                rewardToken != rewardTokenInfos[i].rewardToken,\n                \"DODOMineV3: TOKEN_ALREADY_ADDED\"\n            );\n        }\n\n        RewardTokenInfo storage rt = rewardTokenInfos.push();\n        rt.rewardToken = rewardToken;\n        rt.startBlock = startBlock;\n        rt.lastFlagBlock = startBlock;\n        rt.endBlock = endBlock;\n        rt.rewardPerBlock = rewardPerBlock;\n        rt.rewardVault = address(new RewardVault(rewardToken));\n\n        uint256 rewardAmount = rewardPerBlock.mul(endBlock.sub(startBlock));\n        IERC20(rewardToken).transfer(rt.rewardVault, rewardAmount);\n        RewardVault(rt.rewardVault).syncValue();\n\n        emit NewRewardToken(len, rewardToken);\n    }\n\n    function setEndBlock(uint256 i, uint256 newEndBlock)\n        external\n        onlyOwner\n    {\n        require(i < rewardTokenInfos.length, \"DODOMineV3: REWARD_ID_NOT_FOUND\");\n        _updateReward(address(0), i);\n        RewardTokenInfo storage rt = rewardTokenInfos[i];\n\n\n        uint256 totalDepositReward = RewardVault(rt.rewardVault)._TOTAL_REWARD_();\n        uint256 gap = newEndBlock.sub(rt.lastFlagBlock);\n        uint256 totalReward = rt.workThroughReward.add(gap.mul(rt.rewardPerBlock));\n        require(totalDepositReward >= totalReward, \"DODOMineV3: REWARD_NOT_ENOUGH\");\n\n        require(block.number < newEndBlock, \"DODOMineV3: END_BLOCK_INVALID\");\n        require(block.number > rt.startBlock, \"DODOMineV3: NOT_START\");\n        require(block.number < rt.endBlock, \"DODOMineV3: ALREADY_CLOSE\");\n\n        rt.endBlock = newEndBlock;\n        emit UpdateEndBlock(i, newEndBlock);\n    }\n\n    function setReward(uint256 i, uint256 newRewardPerBlock)\n        external\n        onlyOwner\n    {\n        require(i < rewardTokenInfos.length, \"DODOMineV3: REWARD_ID_NOT_FOUND\");\n        _updateReward(address(0), i);\n        RewardTokenInfo storage rt = rewardTokenInfos[i];\n        \n        require(block.number < rt.endBlock, \"DODOMineV3: ALREADY_CLOSE\");\n        \n        rt.workThroughReward = rt.workThroughReward.add((block.number.sub(rt.lastFlagBlock)).mul(rt.rewardPerBlock));\n        rt.rewardPerBlock = newRewardPerBlock;\n        rt.lastFlagBlock = block.number;\n\n        uint256 totalDepositReward = RewardVault(rt.rewardVault)._TOTAL_REWARD_();\n        uint256 gap = rt.endBlock.sub(block.number);\n        uint256 totalReward = rt.workThroughReward.add(gap.mul(newRewardPerBlock));\n        require(totalDepositReward >= totalReward, \"DODOMineV3: REWARD_NOT_ENOUGH\");\n\n        emit UpdateReward(i, newRewardPerBlock);\n    }\n\n    function withdrawLeftOver(uint256 i, uint256 amount) external onlyOwner {\n        require(i < rewardTokenInfos.length, \"DODOMineV3: REWARD_ID_NOT_FOUND\");\n        \n        RewardTokenInfo storage rt = rewardTokenInfos[i];\n        require(block.number > rt.endBlock, \"DODOMineV3: MINING_NOT_FINISHED\");\n\n        IRewardVault(rt.rewardVault).withdrawLeftOver(msg.sender,amount);\n\n        emit WithdrawLeftOver(msg.sender, i);\n    }\n\n\n    function directTransferOwnership(address newOwner) external onlyOwner {\n        require(newOwner != address(0), \"DODOMineV3: ZERO_ADDRESS\");\n        emit OwnershipTransferred(_OWNER_, newOwner);\n        _OWNER_ = newOwner;\n    }\n\n    // ============ Internal  ============\n\n    function _updateReward(address user, uint256 i) internal {\n        RewardTokenInfo storage rt = rewardTokenInfos[i];\n        if (rt.lastRewardBlock != block.number){\n            rt.accRewardPerShare = _getAccRewardPerShare(i);\n            rt.lastRewardBlock = block.number;\n        }\n        if (user != address(0)) {\n            rt.userRewards[user] = getPendingReward(user, i);\n            rt.userRewardPerSharePaid[user] = rt.accRewardPerShare;\n        }\n    }\n    // SWC-128-DoS With Block Gas Limit: L260-L262\n    function _updateAllReward(address user) internal {\n        uint256 len = rewardTokenInfos.length;\n        for (uint256 i = 0; i < len; i++) {\n            _updateReward(user, i);\n        }\n    }\n\n    function _getUnrewardBlockNum(uint256 i) internal view returns (uint256) {\n        RewardTokenInfo memory rt = rewardTokenInfos[i];\n        if (block.number < rt.startBlock || rt.lastRewardBlock > rt.endBlock) {\n            return 0;\n        }\n        uint256 start = rt.lastRewardBlock < rt.startBlock ? rt.startBlock : rt.lastRewardBlock;\n        uint256 end = rt.endBlock < block.number ? rt.endBlock : block.number;\n        return end.sub(start);\n    }\n\n    function _getAccRewardPerShare(uint256 i) internal view returns (uint256) {\n        RewardTokenInfo memory rt = rewardTokenInfos[i];\n        if (totalSupply() == 0) {\n            return rt.accRewardPerShare;\n        }\n        return\n            rt.accRewardPerShare.add(\n                DecimalMath.divFloor(_getUnrewardBlockNum(i).mul(rt.rewardPerBlock), totalSupply())\n            );\n    }\n\n}",
        "function": "addRewardToken(address,uint256,uint256,uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/SlowMist-DODO-MiningV3 and NFT Smart Contract Security Audit Report/contractV2-c7202eeae724783f572232a1d80b6b9082ee90b1/contracts/DODOToken/DODOMineV3/BaseMine.sol",
        "vulnerability": "Dependence on predictable environment variable (SWC 120)",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract MonstaPresale is Pausable {\n  using SafeMath for uint;\n\n  uint constant public PRESALE_END_TIMESTAMP = 1633957199; // No Monstas can be adopted after this end date: Monday, October 11, 2021 12:59:59 PM GMT\n  uint constant public PRICE_INCREMENT = 383325347388596 wei; // 0.000383325347388596 BNB\n  uint constant public INITIAL_PRICE = 200000000000000000; // 0.2 BNB\n  uint constant public MAX_TOTAL_ADOPTED_MONSTA = 2088;\n  uint constant public MAX_TOTAL_GIVEAWAY_MONSTA = 2000;\n\n  uint public _currentPrice;\n  uint public _totalAdoptedMonstas;\n  uint public _totalGiveawayMonstas;\n  uint public _totalRedeemedMonstas;\n\n  address public _redemptionAddress;\n  mapping(address => bool) public _adopters;\n\n  event MonstaAdopted(address indexed adopter);\n  event AdoptedMonstaRedeemed(address indexed receiver);\n\n  modifier onlyRedemptionAddress {\n    require(msg.sender == _redemptionAddress);\n    _;\n  }\n\n  constructor() public {\n    _currentPrice = INITIAL_PRICE;\n  }\n\n  /**\n   * @dev Adopt some Monsta\n   */\n  function adoptMonsta() public payable whenNotPaused {\n    require(now <= PRESALE_END_TIMESTAMP);\n    require(!_adopters[msg.sender], \"Only can adopt once\");\n    require(_totalAdoptedMonstas.add(1) <= MAX_TOTAL_ADOPTED_MONSTA);\n    require(msg.value >= _currentPrice);\n    \n  \n    uint value = msg.value.sub(_currentPrice);\n    msg.sender.transfer(value);  // Refund back the remaining to the receiver\n\n    _adopters[msg.sender] = true;\n    _totalAdoptedMonstas = _totalAdoptedMonstas.add(1);\n    _currentPrice = _currentPrice.add(PRICE_INCREMENT);\n     \n    emit MonstaAdopted(msg.sender);\n  }\n  \n  /**\n   * @dev Set redemption contract address\n   */\n  function setRedemptionAddress(address redemptionAddress) external onlyOwner {\n    _redemptionAddress = redemptionAddress;\n  }\n\n  /**\n  * @dev Redeem adopted monsta, onlyRedemptionAddress is a redemption contract address\n  * @param receiver Address of the receiver.\n  */\n  function redeemAdoptedMonsta(address receiver) external onlyRedemptionAddress whenNotPaused returns(uint) {\n    require(_adopters[receiver]);\n     _totalRedeemedMonstas = _totalRedeemedMonstas.add(1);\n     _adopters[receiver] = false;\n    emit AdoptedMonstaRedeemed(receiver);\n    return _totalRedeemedMonstas;\n  }\n\n  /**\n   * @dev Giveaway monsta without effecting adopted Monsta counter counter\n   */\n  function giveaway(address[] calldata _addresses) external onlyOwner whenNotPaused {\n    require(_totalGiveawayMonstas.add(_addresses.length) <= MAX_TOTAL_GIVEAWAY_MONSTA);\n    uint given;\n    for (uint i = 0; i < _addresses.length; i++) {\n      if(!_adopters[_addresses[i]]){\n        given++;\n        _adopters[_addresses[i]] = true;\n        emit MonstaAdopted(_addresses[i]);\n      }\n    }\n    _totalGiveawayMonstas = _totalGiveawayMonstas.add(given);\n  }\n  \n  /**\n  * @dev Transfer all BNB held by the contract to the owner.\n  */\n  // SWC-105-Unprotected Ether Withdrawal: L94 - L96\n  function reclaimBNB() external onlyOwner {\n    owner.transfer(address(this).balance);\n  }\n}",
        "function": "adoptMonsta()",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Callisto_Network-Monsta Infinite Token Security Audit/moni-smart-contracts-3303268d5456d51a5f7412be8cfca7e3caf73ed5/contracts/presale/MonstaPresale.sol",
        "vulnerability": "Dependence on predictable environment variable (SWC 116)",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract MonstaPresale is Pausable {\n  using SafeMath for uint;\n\n  uint constant public PRESALE_END_TIMESTAMP = 1633957199; // No Monstas can be adopted after this end date: Monday, October 11, 2021 12:59:59 PM GMT\n  uint constant public PRICE_INCREMENT = 383325347388596 wei; // 0.000383325347388596 BNB\n  uint constant public INITIAL_PRICE = 200000000000000000; // 0.2 BNB\n  uint constant public MAX_TOTAL_ADOPTED_MONSTA = 2088;\n  uint constant public MAX_TOTAL_GIVEAWAY_MONSTA = 2000;\n\n  uint public _currentPrice;\n  uint public _totalAdoptedMonstas;\n  uint public _totalGiveawayMonstas;\n  uint public _totalRedeemedMonstas;\n\n  address public _redemptionAddress;\n  mapping(address => bool) public _adopters;\n\n  event MonstaAdopted(address indexed adopter);\n  event AdoptedMonstaRedeemed(address indexed receiver);\n\n  modifier onlyRedemptionAddress {\n    require(msg.sender == _redemptionAddress);\n    _;\n  }\n\n  constructor() public {\n    _currentPrice = INITIAL_PRICE;\n  }\n\n  /**\n   * @dev Adopt some Monsta\n   */\n  function adoptMonsta() public payable whenNotPaused {\n    require(now <= PRESALE_END_TIMESTAMP);\n    require(!_adopters[msg.sender], \"Only can adopt once\");\n    require(_totalAdoptedMonstas.add(1) <= MAX_TOTAL_ADOPTED_MONSTA);\n    require(msg.value >= _currentPrice);\n    \n  \n    uint value = msg.value.sub(_currentPrice);\n    msg.sender.transfer(value);  // Refund back the remaining to the receiver\n\n    _adopters[msg.sender] = true;\n    _totalAdoptedMonstas = _totalAdoptedMonstas.add(1);\n    _currentPrice = _currentPrice.add(PRICE_INCREMENT);\n     \n    emit MonstaAdopted(msg.sender);\n  }\n  \n  /**\n   * @dev Set redemption contract address\n   */\n  function setRedemptionAddress(address redemptionAddress) external onlyOwner {\n    _redemptionAddress = redemptionAddress;\n  }\n\n  /**\n  * @dev Redeem adopted monsta, onlyRedemptionAddress is a redemption contract address\n  * @param receiver Address of the receiver.\n  */\n  function redeemAdoptedMonsta(address receiver) external onlyRedemptionAddress whenNotPaused returns(uint) {\n    require(_adopters[receiver]);\n     _totalRedeemedMonstas = _totalRedeemedMonstas.add(1);\n     _adopters[receiver] = false;\n    emit AdoptedMonstaRedeemed(receiver);\n    return _totalRedeemedMonstas;\n  }\n\n  /**\n   * @dev Giveaway monsta without effecting adopted Monsta counter counter\n   */\n  function giveaway(address[] calldata _addresses) external onlyOwner whenNotPaused {\n    require(_totalGiveawayMonstas.add(_addresses.length) <= MAX_TOTAL_GIVEAWAY_MONSTA);\n    uint given;\n    for (uint i = 0; i < _addresses.length; i++) {\n      if(!_adopters[_addresses[i]]){\n        given++;\n        _adopters[_addresses[i]] = true;\n        emit MonstaAdopted(_addresses[i]);\n      }\n    }\n    _totalGiveawayMonstas = _totalGiveawayMonstas.add(given);\n  }\n  \n  /**\n  * @dev Transfer all BNB held by the contract to the owner.\n  */\n  // SWC-105-Unprotected Ether Withdrawal: L94 - L96\n  function reclaimBNB() external onlyOwner {\n    owner.transfer(address(this).balance);\n  }\n}",
        "function": "adoptMonsta()",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Callisto_Network-Monsta Infinite Token Security Audit/moni-smart-contracts-3303268d5456d51a5f7412be8cfca7e3caf73ed5/contracts/presale/MonstaPresale.sol",
        "vulnerability": "Transaction Order Dependence (SWC 114)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract CommunityVault is Ownable {\n\n    IERC20 private _bond;\n\n    constructor (address bond) public {\n        _bond = IERC20(bond);\n    }\n\n    event SetAllowance(address indexed caller, address indexed spender, uint256 amount);\n\n    function setAllowance(address spender, uint amount) public onlyOwner {\n        // SWC-107-Reentrancy: L18\n        _bond.approve(spender, amount);\n\n        emit SetAllowance(msg.sender, spender, amount);\n    }\n}",
        "function": "setAllowance(address,uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinbae-Barnbridge_Vault/CommunityVault0xA3C299eEE1998F45c20010276684921EBE6423D9/contracts/CommunityVault.sol",
        "vulnerability": "External Call To User-Supplied Address (SWC 107)",
        "check": "TP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract TemporarilyOwned {\n    address public temporaryOwner;\n    uint public expiryTime;\n\n    constructor(address _temporaryOwner, uint _ownershipDuration) public {\n        require(_temporaryOwner != address(0), \"Temp owner address cannot be 0\");\n\n        temporaryOwner = _temporaryOwner;\n        expiryTime = now + _ownershipDuration;\n    }\n//SWC-111-Use of Deprecated Solidity Functions:L11, 20\n    modifier onlyTemporaryOwner {\n        _onlyTemporaryOwner();\n        _;\n    }\n\n    function _onlyTemporaryOwner() private view {\n        require(now < expiryTime, \"Ownership expired\");\n        require(msg.sender == temporaryOwner, \"Only executable by temp owner\");\n    }\n}",
        "function": "constructor",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Iosiro-Synthetix Menkalinan Release Smart Contract Audit/synthetix-b88898909f8b7064f707609cd535f5caa1f7c5ae/TemporarilyOwned.sol",
        "vulnerability": "Integer Arithmetic Bugs (SWC 101)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract SOAR is Context, IERC20, Ownable { \n    using SafeMath for uint256;\n    using Address for address;\n\n    mapping (address => uint256) private _rOwned;\n    mapping (address => uint256) private _tOwned;\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    mapping (address => bool) private _isExcluded;\n    address[] private _excluded;\n   \n    uint256 private constant MAX = ~uint256(0);\n    uint256 private constant _tTotal = 10 * 10**6 * 10**9;  \n    \n    uint256 private _rTotal = (MAX - (MAX % _tTotal));\n    uint256 private _tFeeTotal;\n\n    string private _name = 'SOAR.FI'; \n    string private _symbol = 'SOAR'; \n    uint8 private _decimals = 9; \n    \n    uint256 private startTime;\n\n    constructor () public {\n        _rOwned[_msgSender()] = _rTotal;\n        emit Transfer(address(0), _msgSender(), _tTotal);\n        startTime = now + (60 * 60); //60 Minutes Delay to Launch Time Function since Contract Deployment\n    }\n\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n\n    function totalSupply() public view override returns (uint256) {\n        return _tTotal;\n    }\n\n    function balanceOf(address account) public view override returns (uint256) {\n        if (_isExcluded[account]) return _tOwned[account];\n        return tokenFromReflection(_rOwned[account]);\n    }\n\n    function transfer(address recipient, uint256 amount) public override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    function allowance(address owner, address spender) public view override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    function approve(address spender, uint256 amount) public override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    function isExcluded(address account) public view returns (bool) {\n        return _isExcluded[account];\n    }\n\n    function totalFees() public view returns (uint256) {\n        return _tFeeTotal;\n    }\n\n    function reflect(uint256 tAmount) public {\n        address sender = _msgSender();\n        require(!_isExcluded[sender], \"Excluded addresses cannot call this function\");\n        (uint256 rAmount,,,,) = _getValues(tAmount);\n        _rOwned[sender] = _rOwned[sender].sub(rAmount);\n        _rTotal = _rTotal.sub(rAmount);\n        _tFeeTotal = _tFeeTotal.add(tAmount);\n    }\n\n    function reflectionFromToken(uint256 tAmount, bool deductTransferFee) public view returns(uint256) {\n        require(tAmount <= _tTotal, \"Amount must be less than supply\");\n        if (!deductTransferFee) {\n            (uint256 rAmount,,,,) = _getValues(tAmount);\n            return rAmount;\n        } else {\n            (,uint256 rTransferAmount,,,) = _getValues(tAmount);\n            return rTransferAmount;\n        }\n    }\n\n    function tokenFromReflection(uint256 rAmount) public view returns(uint256) {\n        require(rAmount <= _rTotal, \"Amount must be less than total reflections\");\n        uint256 currentRate =  _getRate();\n        return rAmount.div(currentRate);\n    }\n\n    function excludeAccount(address account) external onlyOwner() {\n        require(!_isExcluded[account], \"Account is already excluded\");\n        if(_rOwned[account] > 0) {\n            _tOwned[account] = tokenFromReflection(_rOwned[account]);\n        }\n        _isExcluded[account] = true;\n        _excluded.push(account);\n    }\n\n    function includeAccount(address account) external onlyOwner() {\n        require(_isExcluded[account], \"Account is already excluded\");\n        for (uint256 i = 0; i < _excluded.length; i++) {\n            if (_excluded[i] == account) {\n                _excluded[i] = _excluded[_excluded.length - 1];\n                _tOwned[account] = 0;\n                _isExcluded[account] = false;\n                _excluded.pop();\n                break;\n            }\n        }\n    }\n\n    function _approve(address owner, address spender, uint256 amount) private {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    function _transfer(address sender, address recipient, uint256 amount) private {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n        require(amount > 0, \"Transfer amount must be greater than zero\");\n        \n        uint256 relaseTime1 = startTime + (120 * 60); //120 minutes\n        uint256 xLimit1 = 50000 * 10**9; \n    \n        uint256 relaseTime2 = startTime + (240 * 60); //240 minutes\n        uint256 xLimit2 = 100000 * 10**9; \n    \n        uint256 relaseTime3 = startTime + (360 * 60); //360 minutes\n        uint256 xLimit3 = 150000 * 10**9; \n        \n        if (now < startTime) {\n                if (_isExcluded[sender] && !_isExcluded[recipient]) {\n                    _transferFromExcluded(sender, recipient, amount);\n                } else if (!_isExcluded[sender] && _isExcluded[recipient]) {\n                    _transferToExcluded(sender, recipient, amount);\n                } else if (!_isExcluded[sender] && !_isExcluded[recipient]) {\n                    _transferStandard(sender, recipient, amount);\n                } else if (_isExcluded[sender] && _isExcluded[recipient]) {\n                    _transferBothExcluded(sender, recipient, amount);\n                } else {\n                    _transferStandard(sender, recipient, amount);\n                }\n        } else if (now >= startTime && now <= relaseTime1) {\n            if (amount <= xLimit1) {\n                if (_isExcluded[sender] && !_isExcluded[recipient]) {\n                    _transferFromExcluded(sender, recipient, amount);\n                } else if (!_isExcluded[sender] && _isExcluded[recipient]) {\n                    _transferToExcluded(sender, recipient, amount);\n                } else if (!_isExcluded[sender] && !_isExcluded[recipient]) {\n                    _transferStandard(sender, recipient, amount);\n                } else if (_isExcluded[sender] && _isExcluded[recipient]) {\n                    _transferBothExcluded(sender, recipient, amount);\n                } else {\n                    _transferStandard(sender, recipient, amount);\n                }\n            } else {\n                revert(\"ERC20: cannot transfer more than 50,000 tokens in first 120 minutes\");\n            }\n        } else if (now > relaseTime1 && now <= relaseTime2) {\n            if (amount <= xLimit2) {\n                if (_isExcluded[sender] && !_isExcluded[recipient]) {\n                    _transferFromExcluded(sender, recipient, amount);\n                } else if (!_isExcluded[sender] && _isExcluded[recipient]) {\n                    _transferToExcluded(sender, recipient, amount);\n                } else if (!_isExcluded[sender] && !_isExcluded[recipient]) {\n                    _transferStandard(sender, recipient, amount);\n                } else if (_isExcluded[sender] && _isExcluded[recipient]) {\n                    _transferBothExcluded(sender, recipient, amount);\n                } else {\n                    _transferStandard(sender, recipient, amount);\n                }\n            } else {\n                revert(\"ERC20: cannot transfer more than 100,000 tokens in first 240 minutes\");\n            }\n        } else if (now > relaseTime2 && now <= relaseTime3) {\n            if (amount <= xLimit3) {\n                if (_isExcluded[sender] && !_isExcluded[recipient]) {\n                    _transferFromExcluded(sender, recipient, amount);\n                } else if (!_isExcluded[sender] && _isExcluded[recipient]) {\n                    _transferToExcluded(sender, recipient, amount);\n                } else if (!_isExcluded[sender] && !_isExcluded[recipient]) {\n                    _transferStandard(sender, recipient, amount);\n                } else if (_isExcluded[sender] && _isExcluded[recipient]) {\n                    _transferBothExcluded(sender, recipient, amount);\n                } else {\n                    _transferStandard(sender, recipient, amount);\n                }\n            } else {\n                revert(\"ERC20: cannot transfer more than 150,000 tokens in first 360 minutes\");\n            }\n        } else if (now > relaseTime3) {\n            if (_isExcluded[sender] && !_isExcluded[recipient]) {\n                _transferFromExcluded(sender, recipient, amount);\n            } else if (!_isExcluded[sender] && _isExcluded[recipient]) {\n                _transferToExcluded(sender, recipient, amount);\n            } else if (!_isExcluded[sender] && !_isExcluded[recipient]) {\n                _transferStandard(sender, recipient, amount);\n            } else if (_isExcluded[sender] && _isExcluded[recipient]) {\n                _transferBothExcluded(sender, recipient, amount);\n            } else {\n                _transferStandard(sender, recipient, amount);\n            }\n        }\n    }\n\n    function _transferStandard(address sender, address recipient, uint256 tAmount) private {\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee) = _getValues(tAmount);\n        _rOwned[sender] = _rOwned[sender].sub(rAmount);\n        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);       \n        _reflectFee(rFee, tFee);\n        emit Transfer(sender, recipient, tTransferAmount);\n    }\n\n    function _transferToExcluded(address sender, address recipient, uint256 tAmount) private {\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee) = _getValues(tAmount);\n        _rOwned[sender] = _rOwned[sender].sub(rAmount);\n        _tOwned[recipient] = _tOwned[recipient].add(tTransferAmount);\n        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);           \n        _reflectFee(rFee, tFee);\n        emit Transfer(sender, recipient, tTransferAmount);\n    }\n\n    function _transferFromExcluded(address sender, address recipient, uint256 tAmount) private {\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee) = _getValues(tAmount);\n        _tOwned[sender] = _tOwned[sender].sub(tAmount);\n        _rOwned[sender] = _rOwned[sender].sub(rAmount);\n        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);   \n        _reflectFee(rFee, tFee);\n        emit Transfer(sender, recipient, tTransferAmount);\n    }\n\n    function _transferBothExcluded(address sender, address recipient, uint256 tAmount) private {\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee) = _getValues(tAmount);\n        _tOwned[sender] = _tOwned[sender].sub(tAmount);\n        _rOwned[sender] = _rOwned[sender].sub(rAmount);\n        _tOwned[recipient] = _tOwned[recipient].add(tTransferAmount);\n        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);        \n        _reflectFee(rFee, tFee);\n        emit Transfer(sender, recipient, tTransferAmount);\n    }\n\n    function _reflectFee(uint256 rFee, uint256 tFee) private {\n        _rTotal = _rTotal.sub(rFee);\n        _tFeeTotal = _tFeeTotal.add(tFee);\n    }\n\n    function _getValues(uint256 tAmount) private view returns (uint256, uint256, uint256, uint256, uint256) {\n        (uint256 tTransferAmount, uint256 tFee) = _getTValues(tAmount);\n        uint256 currentRate =  _getRate();\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee) = _getRValues(tAmount, tFee, currentRate);\n        return (rAmount, rTransferAmount, rFee, tTransferAmount, tFee);\n    }\n\n    function _getTValues(uint256 tAmount) private pure returns (uint256, uint256) {\n        uint256 tFee = tAmount.div(100);\n        uint256 tTransferAmount = tAmount.sub(tFee);\n        return (tTransferAmount, tFee);\n    }\n\n    function _getRValues(uint256 tAmount, uint256 tFee, uint256 currentRate) private pure returns (uint256, uint256, uint256) {\n        uint256 rAmount = tAmount.mul(currentRate);\n        uint256 rFee = tFee.mul(currentRate);\n        uint256 rTransferAmount = rAmount.sub(rFee);\n        return (rAmount, rTransferAmount, rFee);\n    }\n\n    function _getRate() private view returns(uint256) {\n        (uint256 rSupply, uint256 tSupply) = _getCurrentSupply();\n        return rSupply.div(tSupply);\n    }\n\n    function _getCurrentSupply() private view returns(uint256, uint256) {\n        uint256 rSupply = _rTotal;\n        uint256 tSupply = _tTotal;      \n        for (uint256 i = 0; i < _excluded.length; i++) {\n            if (_rOwned[_excluded[i]] > rSupply || _tOwned[_excluded[i]] > tSupply) return (_rTotal, _tTotal);\n            rSupply = rSupply.sub(_rOwned[_excluded[i]]);\n            tSupply = tSupply.sub(_tOwned[_excluded[i]]);\n        }\n        if (rSupply < _rTotal.div(_tTotal)) return (_rTotal, _tTotal);\n        return (rSupply, tSupply);\n    }\n}",
        "function": "constructor",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Hacken-SOAR-V1/code/SOAR.sol",
        "vulnerability": "Integer Arithmetic Bugs (SWC 101)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract SOAR is Context, IERC20, Ownable { \n    using SafeMath for uint256;\n    using Address for address;\n\n    mapping (address => uint256) private _rOwned;\n    mapping (address => uint256) private _tOwned;\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    mapping (address => bool) private _isExcluded;\n    address[] private _excluded;\n   \n    uint256 private constant MAX = ~uint256(0);\n    uint256 private constant _tTotal = 10 * 10**6 * 10**9;  \n    \n    uint256 private _rTotal = (MAX - (MAX % _tTotal));\n    uint256 private _tFeeTotal;\n\n    string private _name = 'SOAR.FI'; \n    string private _symbol = 'SOAR'; \n    uint8 private _decimals = 9; \n    \n    uint256 private startTime;\n\n    constructor () public {\n        _rOwned[_msgSender()] = _rTotal;\n        emit Transfer(address(0), _msgSender(), _tTotal);\n        startTime = now + (60 * 60); //60 Minutes Delay to Launch Time Function since Contract Deployment\n    }\n\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n\n    function totalSupply() public view override returns (uint256) {\n        return _tTotal;\n    }\n\n    function balanceOf(address account) public view override returns (uint256) {\n        if (_isExcluded[account]) return _tOwned[account];\n        return tokenFromReflection(_rOwned[account]);\n    }\n\n    function transfer(address recipient, uint256 amount) public override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    function allowance(address owner, address spender) public view override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    function approve(address spender, uint256 amount) public override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    function isExcluded(address account) public view returns (bool) {\n        return _isExcluded[account];\n    }\n\n    function totalFees() public view returns (uint256) {\n        return _tFeeTotal;\n    }\n\n    function reflect(uint256 tAmount) public {\n        address sender = _msgSender();\n        require(!_isExcluded[sender], \"Excluded addresses cannot call this function\");\n        (uint256 rAmount,,,,) = _getValues(tAmount);\n        _rOwned[sender] = _rOwned[sender].sub(rAmount);\n        _rTotal = _rTotal.sub(rAmount);\n        _tFeeTotal = _tFeeTotal.add(tAmount);\n    }\n\n    function reflectionFromToken(uint256 tAmount, bool deductTransferFee) public view returns(uint256) {\n        require(tAmount <= _tTotal, \"Amount must be less than supply\");\n        if (!deductTransferFee) {\n            (uint256 rAmount,,,,) = _getValues(tAmount);\n            return rAmount;\n        } else {\n            (,uint256 rTransferAmount,,,) = _getValues(tAmount);\n            return rTransferAmount;\n        }\n    }\n\n    function tokenFromReflection(uint256 rAmount) public view returns(uint256) {\n        require(rAmount <= _rTotal, \"Amount must be less than total reflections\");\n        uint256 currentRate =  _getRate();\n        return rAmount.div(currentRate);\n    }\n\n    function excludeAccount(address account) external onlyOwner() {\n        require(!_isExcluded[account], \"Account is already excluded\");\n        if(_rOwned[account] > 0) {\n            _tOwned[account] = tokenFromReflection(_rOwned[account]);\n        }\n        _isExcluded[account] = true;\n        _excluded.push(account);\n    }\n\n    function includeAccount(address account) external onlyOwner() {\n        require(_isExcluded[account], \"Account is already excluded\");\n        for (uint256 i = 0; i < _excluded.length; i++) {\n            if (_excluded[i] == account) {\n                _excluded[i] = _excluded[_excluded.length - 1];\n                _tOwned[account] = 0;\n                _isExcluded[account] = false;\n                _excluded.pop();\n                break;\n            }\n        }\n    }\n\n    function _approve(address owner, address spender, uint256 amount) private {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    function _transfer(address sender, address recipient, uint256 amount) private {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n        require(amount > 0, \"Transfer amount must be greater than zero\");\n        \n        uint256 relaseTime1 = startTime + (120 * 60); //120 minutes\n        uint256 xLimit1 = 50000 * 10**9; \n    \n        uint256 relaseTime2 = startTime + (240 * 60); //240 minutes\n        uint256 xLimit2 = 100000 * 10**9; \n    \n        uint256 relaseTime3 = startTime + (360 * 60); //360 minutes\n        uint256 xLimit3 = 150000 * 10**9; \n        \n        if (now < startTime) {\n                if (_isExcluded[sender] && !_isExcluded[recipient]) {\n                    _transferFromExcluded(sender, recipient, amount);\n                } else if (!_isExcluded[sender] && _isExcluded[recipient]) {\n                    _transferToExcluded(sender, recipient, amount);\n                } else if (!_isExcluded[sender] && !_isExcluded[recipient]) {\n                    _transferStandard(sender, recipient, amount);\n                } else if (_isExcluded[sender] && _isExcluded[recipient]) {\n                    _transferBothExcluded(sender, recipient, amount);\n                } else {\n                    _transferStandard(sender, recipient, amount);\n                }\n        } else if (now >= startTime && now <= relaseTime1) {\n            if (amount <= xLimit1) {\n                if (_isExcluded[sender] && !_isExcluded[recipient]) {\n                    _transferFromExcluded(sender, recipient, amount);\n                } else if (!_isExcluded[sender] && _isExcluded[recipient]) {\n                    _transferToExcluded(sender, recipient, amount);\n                } else if (!_isExcluded[sender] && !_isExcluded[recipient]) {\n                    _transferStandard(sender, recipient, amount);\n                } else if (_isExcluded[sender] && _isExcluded[recipient]) {\n                    _transferBothExcluded(sender, recipient, amount);\n                } else {\n                    _transferStandard(sender, recipient, amount);\n                }\n            } else {\n                revert(\"ERC20: cannot transfer more than 50,000 tokens in first 120 minutes\");\n            }\n        } else if (now > relaseTime1 && now <= relaseTime2) {\n            if (amount <= xLimit2) {\n                if (_isExcluded[sender] && !_isExcluded[recipient]) {\n                    _transferFromExcluded(sender, recipient, amount);\n                } else if (!_isExcluded[sender] && _isExcluded[recipient]) {\n                    _transferToExcluded(sender, recipient, amount);\n                } else if (!_isExcluded[sender] && !_isExcluded[recipient]) {\n                    _transferStandard(sender, recipient, amount);\n                } else if (_isExcluded[sender] && _isExcluded[recipient]) {\n                    _transferBothExcluded(sender, recipient, amount);\n                } else {\n                    _transferStandard(sender, recipient, amount);\n                }\n            } else {\n                revert(\"ERC20: cannot transfer more than 100,000 tokens in first 240 minutes\");\n            }\n        } else if (now > relaseTime2 && now <= relaseTime3) {\n            if (amount <= xLimit3) {\n                if (_isExcluded[sender] && !_isExcluded[recipient]) {\n                    _transferFromExcluded(sender, recipient, amount);\n                } else if (!_isExcluded[sender] && _isExcluded[recipient]) {\n                    _transferToExcluded(sender, recipient, amount);\n                } else if (!_isExcluded[sender] && !_isExcluded[recipient]) {\n                    _transferStandard(sender, recipient, amount);\n                } else if (_isExcluded[sender] && _isExcluded[recipient]) {\n                    _transferBothExcluded(sender, recipient, amount);\n                } else {\n                    _transferStandard(sender, recipient, amount);\n                }\n            } else {\n                revert(\"ERC20: cannot transfer more than 150,000 tokens in first 360 minutes\");\n            }\n        } else if (now > relaseTime3) {\n            if (_isExcluded[sender] && !_isExcluded[recipient]) {\n                _transferFromExcluded(sender, recipient, amount);\n            } else if (!_isExcluded[sender] && _isExcluded[recipient]) {\n                _transferToExcluded(sender, recipient, amount);\n            } else if (!_isExcluded[sender] && !_isExcluded[recipient]) {\n                _transferStandard(sender, recipient, amount);\n            } else if (_isExcluded[sender] && _isExcluded[recipient]) {\n                _transferBothExcluded(sender, recipient, amount);\n            } else {\n                _transferStandard(sender, recipient, amount);\n            }\n        }\n    }\n\n    function _transferStandard(address sender, address recipient, uint256 tAmount) private {\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee) = _getValues(tAmount);\n        _rOwned[sender] = _rOwned[sender].sub(rAmount);\n        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);       \n        _reflectFee(rFee, tFee);\n        emit Transfer(sender, recipient, tTransferAmount);\n    }\n\n    function _transferToExcluded(address sender, address recipient, uint256 tAmount) private {\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee) = _getValues(tAmount);\n        _rOwned[sender] = _rOwned[sender].sub(rAmount);\n        _tOwned[recipient] = _tOwned[recipient].add(tTransferAmount);\n        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);           \n        _reflectFee(rFee, tFee);\n        emit Transfer(sender, recipient, tTransferAmount);\n    }\n\n    function _transferFromExcluded(address sender, address recipient, uint256 tAmount) private {\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee) = _getValues(tAmount);\n        _tOwned[sender] = _tOwned[sender].sub(tAmount);\n        _rOwned[sender] = _rOwned[sender].sub(rAmount);\n        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);   \n        _reflectFee(rFee, tFee);\n        emit Transfer(sender, recipient, tTransferAmount);\n    }\n\n    function _transferBothExcluded(address sender, address recipient, uint256 tAmount) private {\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee) = _getValues(tAmount);\n        _tOwned[sender] = _tOwned[sender].sub(tAmount);\n        _rOwned[sender] = _rOwned[sender].sub(rAmount);\n        _tOwned[recipient] = _tOwned[recipient].add(tTransferAmount);\n        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);        \n        _reflectFee(rFee, tFee);\n        emit Transfer(sender, recipient, tTransferAmount);\n    }\n\n    function _reflectFee(uint256 rFee, uint256 tFee) private {\n        _rTotal = _rTotal.sub(rFee);\n        _tFeeTotal = _tFeeTotal.add(tFee);\n    }\n\n    function _getValues(uint256 tAmount) private view returns (uint256, uint256, uint256, uint256, uint256) {\n        (uint256 tTransferAmount, uint256 tFee) = _getTValues(tAmount);\n        uint256 currentRate =  _getRate();\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee) = _getRValues(tAmount, tFee, currentRate);\n        return (rAmount, rTransferAmount, rFee, tTransferAmount, tFee);\n    }\n\n    function _getTValues(uint256 tAmount) private pure returns (uint256, uint256) {\n        uint256 tFee = tAmount.div(100);\n        uint256 tTransferAmount = tAmount.sub(tFee);\n        return (tTransferAmount, tFee);\n    }\n\n    function _getRValues(uint256 tAmount, uint256 tFee, uint256 currentRate) private pure returns (uint256, uint256, uint256) {\n        uint256 rAmount = tAmount.mul(currentRate);\n        uint256 rFee = tFee.mul(currentRate);\n        uint256 rTransferAmount = rAmount.sub(rFee);\n        return (rAmount, rTransferAmount, rFee);\n    }\n\n    function _getRate() private view returns(uint256) {\n        (uint256 rSupply, uint256 tSupply) = _getCurrentSupply();\n        return rSupply.div(tSupply);\n    }\n\n    function _getCurrentSupply() private view returns(uint256, uint256) {\n        uint256 rSupply = _rTotal;\n        uint256 tSupply = _tTotal;      \n        for (uint256 i = 0; i < _excluded.length; i++) {\n            if (_rOwned[_excluded[i]] > rSupply || _tOwned[_excluded[i]] > tSupply) return (_rTotal, _tTotal);\n            rSupply = rSupply.sub(_rOwned[_excluded[i]]);\n            tSupply = tSupply.sub(_tOwned[_excluded[i]]);\n        }\n        if (rSupply < _rTotal.div(_tTotal)) return (_rTotal, _tTotal);\n        return (rSupply, tSupply);\n    }\n}",
        "function": "transfer(address,uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Hacken-SOAR-V1/code/SOAR.sol",
        "vulnerability": "Dependence on predictable environment variable (SWC 116)",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract SOAR is Context, IERC20, Ownable { \n    using SafeMath for uint256;\n    using Address for address;\n\n    mapping (address => uint256) private _rOwned;\n    mapping (address => uint256) private _tOwned;\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    mapping (address => bool) private _isExcluded;\n    address[] private _excluded;\n   \n    uint256 private constant MAX = ~uint256(0);\n    uint256 private constant _tTotal = 10 * 10**6 * 10**9;  \n    \n    uint256 private _rTotal = (MAX - (MAX % _tTotal));\n    uint256 private _tFeeTotal;\n\n    string private _name = 'SOAR.FI'; \n    string private _symbol = 'SOAR'; \n    uint8 private _decimals = 9; \n    \n    uint256 private startTime;\n\n    constructor () public {\n        _rOwned[_msgSender()] = _rTotal;\n        emit Transfer(address(0), _msgSender(), _tTotal);\n        startTime = now + (60 * 60); //60 Minutes Delay to Launch Time Function since Contract Deployment\n    }\n\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n\n    function totalSupply() public view override returns (uint256) {\n        return _tTotal;\n    }\n\n    function balanceOf(address account) public view override returns (uint256) {\n        if (_isExcluded[account]) return _tOwned[account];\n        return tokenFromReflection(_rOwned[account]);\n    }\n\n    function transfer(address recipient, uint256 amount) public override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    function allowance(address owner, address spender) public view override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    function approve(address spender, uint256 amount) public override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    function isExcluded(address account) public view returns (bool) {\n        return _isExcluded[account];\n    }\n\n    function totalFees() public view returns (uint256) {\n        return _tFeeTotal;\n    }\n\n    function reflect(uint256 tAmount) public {\n        address sender = _msgSender();\n        require(!_isExcluded[sender], \"Excluded addresses cannot call this function\");\n        (uint256 rAmount,,,,) = _getValues(tAmount);\n        _rOwned[sender] = _rOwned[sender].sub(rAmount);\n        _rTotal = _rTotal.sub(rAmount);\n        _tFeeTotal = _tFeeTotal.add(tAmount);\n    }\n\n    function reflectionFromToken(uint256 tAmount, bool deductTransferFee) public view returns(uint256) {\n        require(tAmount <= _tTotal, \"Amount must be less than supply\");\n        if (!deductTransferFee) {\n            (uint256 rAmount,,,,) = _getValues(tAmount);\n            return rAmount;\n        } else {\n            (,uint256 rTransferAmount,,,) = _getValues(tAmount);\n            return rTransferAmount;\n        }\n    }\n\n    function tokenFromReflection(uint256 rAmount) public view returns(uint256) {\n        require(rAmount <= _rTotal, \"Amount must be less than total reflections\");\n        uint256 currentRate =  _getRate();\n        return rAmount.div(currentRate);\n    }\n\n    function excludeAccount(address account) external onlyOwner() {\n        require(!_isExcluded[account], \"Account is already excluded\");\n        if(_rOwned[account] > 0) {\n            _tOwned[account] = tokenFromReflection(_rOwned[account]);\n        }\n        _isExcluded[account] = true;\n        _excluded.push(account);\n    }\n\n    function includeAccount(address account) external onlyOwner() {\n        require(_isExcluded[account], \"Account is already excluded\");\n        for (uint256 i = 0; i < _excluded.length; i++) {\n            if (_excluded[i] == account) {\n                _excluded[i] = _excluded[_excluded.length - 1];\n                _tOwned[account] = 0;\n                _isExcluded[account] = false;\n                _excluded.pop();\n                break;\n            }\n        }\n    }\n\n    function _approve(address owner, address spender, uint256 amount) private {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    function _transfer(address sender, address recipient, uint256 amount) private {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n        require(amount > 0, \"Transfer amount must be greater than zero\");\n        \n        uint256 relaseTime1 = startTime + (120 * 60); //120 minutes\n        uint256 xLimit1 = 50000 * 10**9; \n    \n        uint256 relaseTime2 = startTime + (240 * 60); //240 minutes\n        uint256 xLimit2 = 100000 * 10**9; \n    \n        uint256 relaseTime3 = startTime + (360 * 60); //360 minutes\n        uint256 xLimit3 = 150000 * 10**9; \n        \n        if (now < startTime) {\n                if (_isExcluded[sender] && !_isExcluded[recipient]) {\n                    _transferFromExcluded(sender, recipient, amount);\n                } else if (!_isExcluded[sender] && _isExcluded[recipient]) {\n                    _transferToExcluded(sender, recipient, amount);\n                } else if (!_isExcluded[sender] && !_isExcluded[recipient]) {\n                    _transferStandard(sender, recipient, amount);\n                } else if (_isExcluded[sender] && _isExcluded[recipient]) {\n                    _transferBothExcluded(sender, recipient, amount);\n                } else {\n                    _transferStandard(sender, recipient, amount);\n                }\n        } else if (now >= startTime && now <= relaseTime1) {\n            if (amount <= xLimit1) {\n                if (_isExcluded[sender] && !_isExcluded[recipient]) {\n                    _transferFromExcluded(sender, recipient, amount);\n                } else if (!_isExcluded[sender] && _isExcluded[recipient]) {\n                    _transferToExcluded(sender, recipient, amount);\n                } else if (!_isExcluded[sender] && !_isExcluded[recipient]) {\n                    _transferStandard(sender, recipient, amount);\n                } else if (_isExcluded[sender] && _isExcluded[recipient]) {\n                    _transferBothExcluded(sender, recipient, amount);\n                } else {\n                    _transferStandard(sender, recipient, amount);\n                }\n            } else {\n                revert(\"ERC20: cannot transfer more than 50,000 tokens in first 120 minutes\");\n            }\n        } else if (now > relaseTime1 && now <= relaseTime2) {\n            if (amount <= xLimit2) {\n                if (_isExcluded[sender] && !_isExcluded[recipient]) {\n                    _transferFromExcluded(sender, recipient, amount);\n                } else if (!_isExcluded[sender] && _isExcluded[recipient]) {\n                    _transferToExcluded(sender, recipient, amount);\n                } else if (!_isExcluded[sender] && !_isExcluded[recipient]) {\n                    _transferStandard(sender, recipient, amount);\n                } else if (_isExcluded[sender] && _isExcluded[recipient]) {\n                    _transferBothExcluded(sender, recipient, amount);\n                } else {\n                    _transferStandard(sender, recipient, amount);\n                }\n            } else {\n                revert(\"ERC20: cannot transfer more than 100,000 tokens in first 240 minutes\");\n            }\n        } else if (now > relaseTime2 && now <= relaseTime3) {\n            if (amount <= xLimit3) {\n                if (_isExcluded[sender] && !_isExcluded[recipient]) {\n                    _transferFromExcluded(sender, recipient, amount);\n                } else if (!_isExcluded[sender] && _isExcluded[recipient]) {\n                    _transferToExcluded(sender, recipient, amount);\n                } else if (!_isExcluded[sender] && !_isExcluded[recipient]) {\n                    _transferStandard(sender, recipient, amount);\n                } else if (_isExcluded[sender] && _isExcluded[recipient]) {\n                    _transferBothExcluded(sender, recipient, amount);\n                } else {\n                    _transferStandard(sender, recipient, amount);\n                }\n            } else {\n                revert(\"ERC20: cannot transfer more than 150,000 tokens in first 360 minutes\");\n            }\n        } else if (now > relaseTime3) {\n            if (_isExcluded[sender] && !_isExcluded[recipient]) {\n                _transferFromExcluded(sender, recipient, amount);\n            } else if (!_isExcluded[sender] && _isExcluded[recipient]) {\n                _transferToExcluded(sender, recipient, amount);\n            } else if (!_isExcluded[sender] && !_isExcluded[recipient]) {\n                _transferStandard(sender, recipient, amount);\n            } else if (_isExcluded[sender] && _isExcluded[recipient]) {\n                _transferBothExcluded(sender, recipient, amount);\n            } else {\n                _transferStandard(sender, recipient, amount);\n            }\n        }\n    }\n\n    function _transferStandard(address sender, address recipient, uint256 tAmount) private {\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee) = _getValues(tAmount);\n        _rOwned[sender] = _rOwned[sender].sub(rAmount);\n        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);       \n        _reflectFee(rFee, tFee);\n        emit Transfer(sender, recipient, tTransferAmount);\n    }\n\n    function _transferToExcluded(address sender, address recipient, uint256 tAmount) private {\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee) = _getValues(tAmount);\n        _rOwned[sender] = _rOwned[sender].sub(rAmount);\n        _tOwned[recipient] = _tOwned[recipient].add(tTransferAmount);\n        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);           \n        _reflectFee(rFee, tFee);\n        emit Transfer(sender, recipient, tTransferAmount);\n    }\n\n    function _transferFromExcluded(address sender, address recipient, uint256 tAmount) private {\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee) = _getValues(tAmount);\n        _tOwned[sender] = _tOwned[sender].sub(tAmount);\n        _rOwned[sender] = _rOwned[sender].sub(rAmount);\n        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);   \n        _reflectFee(rFee, tFee);\n        emit Transfer(sender, recipient, tTransferAmount);\n    }\n\n    function _transferBothExcluded(address sender, address recipient, uint256 tAmount) private {\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee) = _getValues(tAmount);\n        _tOwned[sender] = _tOwned[sender].sub(tAmount);\n        _rOwned[sender] = _rOwned[sender].sub(rAmount);\n        _tOwned[recipient] = _tOwned[recipient].add(tTransferAmount);\n        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);        \n        _reflectFee(rFee, tFee);\n        emit Transfer(sender, recipient, tTransferAmount);\n    }\n\n    function _reflectFee(uint256 rFee, uint256 tFee) private {\n        _rTotal = _rTotal.sub(rFee);\n        _tFeeTotal = _tFeeTotal.add(tFee);\n    }\n\n    function _getValues(uint256 tAmount) private view returns (uint256, uint256, uint256, uint256, uint256) {\n        (uint256 tTransferAmount, uint256 tFee) = _getTValues(tAmount);\n        uint256 currentRate =  _getRate();\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee) = _getRValues(tAmount, tFee, currentRate);\n        return (rAmount, rTransferAmount, rFee, tTransferAmount, tFee);\n    }\n\n    function _getTValues(uint256 tAmount) private pure returns (uint256, uint256) {\n        uint256 tFee = tAmount.div(100);\n        uint256 tTransferAmount = tAmount.sub(tFee);\n        return (tTransferAmount, tFee);\n    }\n\n    function _getRValues(uint256 tAmount, uint256 tFee, uint256 currentRate) private pure returns (uint256, uint256, uint256) {\n        uint256 rAmount = tAmount.mul(currentRate);\n        uint256 rFee = tFee.mul(currentRate);\n        uint256 rTransferAmount = rAmount.sub(rFee);\n        return (rAmount, rTransferAmount, rFee);\n    }\n\n    function _getRate() private view returns(uint256) {\n        (uint256 rSupply, uint256 tSupply) = _getCurrentSupply();\n        return rSupply.div(tSupply);\n    }\n\n    function _getCurrentSupply() private view returns(uint256, uint256) {\n        uint256 rSupply = _rTotal;\n        uint256 tSupply = _tTotal;      \n        for (uint256 i = 0; i < _excluded.length; i++) {\n            if (_rOwned[_excluded[i]] > rSupply || _tOwned[_excluded[i]] > tSupply) return (_rTotal, _tTotal);\n            rSupply = rSupply.sub(_rOwned[_excluded[i]]);\n            tSupply = tSupply.sub(_tOwned[_excluded[i]]);\n        }\n        if (rSupply < _rTotal.div(_tTotal)) return (_rTotal, _tTotal);\n        return (rSupply, tSupply);\n    }\n}",
        "function": "transfer(address,uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Hacken-SOAR-V1/code/SOAR.sol",
        "vulnerability": "Dependence on predictable environment variable (SWC 116)",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract SOAR is Context, IERC20, Ownable { \n    using SafeMath for uint256;\n    using Address for address;\n\n    mapping (address => uint256) private _rOwned;\n    mapping (address => uint256) private _tOwned;\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    mapping (address => bool) private _isExcluded;\n    address[] private _excluded;\n   \n    uint256 private constant MAX = ~uint256(0);\n    uint256 private constant _tTotal = 10 * 10**6 * 10**9;  \n    \n    uint256 private _rTotal = (MAX - (MAX % _tTotal));\n    uint256 private _tFeeTotal;\n\n    string private _name = 'SOAR.FI'; \n    string private _symbol = 'SOAR'; \n    uint8 private _decimals = 9; \n    \n    uint256 private startTime;\n\n    constructor () public {\n        _rOwned[_msgSender()] = _rTotal;\n        emit Transfer(address(0), _msgSender(), _tTotal);\n        startTime = now + (60 * 60); //60 Minutes Delay to Launch Time Function since Contract Deployment\n    }\n\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n\n    function totalSupply() public view override returns (uint256) {\n        return _tTotal;\n    }\n\n    function balanceOf(address account) public view override returns (uint256) {\n        if (_isExcluded[account]) return _tOwned[account];\n        return tokenFromReflection(_rOwned[account]);\n    }\n\n    function transfer(address recipient, uint256 amount) public override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    function allowance(address owner, address spender) public view override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    function approve(address spender, uint256 amount) public override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    function isExcluded(address account) public view returns (bool) {\n        return _isExcluded[account];\n    }\n\n    function totalFees() public view returns (uint256) {\n        return _tFeeTotal;\n    }\n\n    function reflect(uint256 tAmount) public {\n        address sender = _msgSender();\n        require(!_isExcluded[sender], \"Excluded addresses cannot call this function\");\n        (uint256 rAmount,,,,) = _getValues(tAmount);\n        _rOwned[sender] = _rOwned[sender].sub(rAmount);\n        _rTotal = _rTotal.sub(rAmount);\n        _tFeeTotal = _tFeeTotal.add(tAmount);\n    }\n\n    function reflectionFromToken(uint256 tAmount, bool deductTransferFee) public view returns(uint256) {\n        require(tAmount <= _tTotal, \"Amount must be less than supply\");\n        if (!deductTransferFee) {\n            (uint256 rAmount,,,,) = _getValues(tAmount);\n            return rAmount;\n        } else {\n            (,uint256 rTransferAmount,,,) = _getValues(tAmount);\n            return rTransferAmount;\n        }\n    }\n\n    function tokenFromReflection(uint256 rAmount) public view returns(uint256) {\n        require(rAmount <= _rTotal, \"Amount must be less than total reflections\");\n        uint256 currentRate =  _getRate();\n        return rAmount.div(currentRate);\n    }\n\n    function excludeAccount(address account) external onlyOwner() {\n        require(!_isExcluded[account], \"Account is already excluded\");\n        if(_rOwned[account] > 0) {\n            _tOwned[account] = tokenFromReflection(_rOwned[account]);\n        }\n        _isExcluded[account] = true;\n        _excluded.push(account);\n    }\n\n    function includeAccount(address account) external onlyOwner() {\n        require(_isExcluded[account], \"Account is already excluded\");\n        for (uint256 i = 0; i < _excluded.length; i++) {\n            if (_excluded[i] == account) {\n                _excluded[i] = _excluded[_excluded.length - 1];\n                _tOwned[account] = 0;\n                _isExcluded[account] = false;\n                _excluded.pop();\n                break;\n            }\n        }\n    }\n\n    function _approve(address owner, address spender, uint256 amount) private {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    function _transfer(address sender, address recipient, uint256 amount) private {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n        require(amount > 0, \"Transfer amount must be greater than zero\");\n        \n        uint256 relaseTime1 = startTime + (120 * 60); //120 minutes\n        uint256 xLimit1 = 50000 * 10**9; \n    \n        uint256 relaseTime2 = startTime + (240 * 60); //240 minutes\n        uint256 xLimit2 = 100000 * 10**9; \n    \n        uint256 relaseTime3 = startTime + (360 * 60); //360 minutes\n        uint256 xLimit3 = 150000 * 10**9; \n        \n        if (now < startTime) {\n                if (_isExcluded[sender] && !_isExcluded[recipient]) {\n                    _transferFromExcluded(sender, recipient, amount);\n                } else if (!_isExcluded[sender] && _isExcluded[recipient]) {\n                    _transferToExcluded(sender, recipient, amount);\n                } else if (!_isExcluded[sender] && !_isExcluded[recipient]) {\n                    _transferStandard(sender, recipient, amount);\n                } else if (_isExcluded[sender] && _isExcluded[recipient]) {\n                    _transferBothExcluded(sender, recipient, amount);\n                } else {\n                    _transferStandard(sender, recipient, amount);\n                }\n        } else if (now >= startTime && now <= relaseTime1) {\n            if (amount <= xLimit1) {\n                if (_isExcluded[sender] && !_isExcluded[recipient]) {\n                    _transferFromExcluded(sender, recipient, amount);\n                } else if (!_isExcluded[sender] && _isExcluded[recipient]) {\n                    _transferToExcluded(sender, recipient, amount);\n                } else if (!_isExcluded[sender] && !_isExcluded[recipient]) {\n                    _transferStandard(sender, recipient, amount);\n                } else if (_isExcluded[sender] && _isExcluded[recipient]) {\n                    _transferBothExcluded(sender, recipient, amount);\n                } else {\n                    _transferStandard(sender, recipient, amount);\n                }\n            } else {\n                revert(\"ERC20: cannot transfer more than 50,000 tokens in first 120 minutes\");\n            }\n        } else if (now > relaseTime1 && now <= relaseTime2) {\n            if (amount <= xLimit2) {\n                if (_isExcluded[sender] && !_isExcluded[recipient]) {\n                    _transferFromExcluded(sender, recipient, amount);\n                } else if (!_isExcluded[sender] && _isExcluded[recipient]) {\n                    _transferToExcluded(sender, recipient, amount);\n                } else if (!_isExcluded[sender] && !_isExcluded[recipient]) {\n                    _transferStandard(sender, recipient, amount);\n                } else if (_isExcluded[sender] && _isExcluded[recipient]) {\n                    _transferBothExcluded(sender, recipient, amount);\n                } else {\n                    _transferStandard(sender, recipient, amount);\n                }\n            } else {\n                revert(\"ERC20: cannot transfer more than 100,000 tokens in first 240 minutes\");\n            }\n        } else if (now > relaseTime2 && now <= relaseTime3) {\n            if (amount <= xLimit3) {\n                if (_isExcluded[sender] && !_isExcluded[recipient]) {\n                    _transferFromExcluded(sender, recipient, amount);\n                } else if (!_isExcluded[sender] && _isExcluded[recipient]) {\n                    _transferToExcluded(sender, recipient, amount);\n                } else if (!_isExcluded[sender] && !_isExcluded[recipient]) {\n                    _transferStandard(sender, recipient, amount);\n                } else if (_isExcluded[sender] && _isExcluded[recipient]) {\n                    _transferBothExcluded(sender, recipient, amount);\n                } else {\n                    _transferStandard(sender, recipient, amount);\n                }\n            } else {\n                revert(\"ERC20: cannot transfer more than 150,000 tokens in first 360 minutes\");\n            }\n        } else if (now > relaseTime3) {\n            if (_isExcluded[sender] && !_isExcluded[recipient]) {\n                _transferFromExcluded(sender, recipient, amount);\n            } else if (!_isExcluded[sender] && _isExcluded[recipient]) {\n                _transferToExcluded(sender, recipient, amount);\n            } else if (!_isExcluded[sender] && !_isExcluded[recipient]) {\n                _transferStandard(sender, recipient, amount);\n            } else if (_isExcluded[sender] && _isExcluded[recipient]) {\n                _transferBothExcluded(sender, recipient, amount);\n            } else {\n                _transferStandard(sender, recipient, amount);\n            }\n        }\n    }\n\n    function _transferStandard(address sender, address recipient, uint256 tAmount) private {\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee) = _getValues(tAmount);\n        _rOwned[sender] = _rOwned[sender].sub(rAmount);\n        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);       \n        _reflectFee(rFee, tFee);\n        emit Transfer(sender, recipient, tTransferAmount);\n    }\n\n    function _transferToExcluded(address sender, address recipient, uint256 tAmount) private {\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee) = _getValues(tAmount);\n        _rOwned[sender] = _rOwned[sender].sub(rAmount);\n        _tOwned[recipient] = _tOwned[recipient].add(tTransferAmount);\n        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);           \n        _reflectFee(rFee, tFee);\n        emit Transfer(sender, recipient, tTransferAmount);\n    }\n\n    function _transferFromExcluded(address sender, address recipient, uint256 tAmount) private {\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee) = _getValues(tAmount);\n        _tOwned[sender] = _tOwned[sender].sub(tAmount);\n        _rOwned[sender] = _rOwned[sender].sub(rAmount);\n        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);   \n        _reflectFee(rFee, tFee);\n        emit Transfer(sender, recipient, tTransferAmount);\n    }\n\n    function _transferBothExcluded(address sender, address recipient, uint256 tAmount) private {\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee) = _getValues(tAmount);\n        _tOwned[sender] = _tOwned[sender].sub(tAmount);\n        _rOwned[sender] = _rOwned[sender].sub(rAmount);\n        _tOwned[recipient] = _tOwned[recipient].add(tTransferAmount);\n        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);        \n        _reflectFee(rFee, tFee);\n        emit Transfer(sender, recipient, tTransferAmount);\n    }\n\n    function _reflectFee(uint256 rFee, uint256 tFee) private {\n        _rTotal = _rTotal.sub(rFee);\n        _tFeeTotal = _tFeeTotal.add(tFee);\n    }\n\n    function _getValues(uint256 tAmount) private view returns (uint256, uint256, uint256, uint256, uint256) {\n        (uint256 tTransferAmount, uint256 tFee) = _getTValues(tAmount);\n        uint256 currentRate =  _getRate();\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee) = _getRValues(tAmount, tFee, currentRate);\n        return (rAmount, rTransferAmount, rFee, tTransferAmount, tFee);\n    }\n\n    function _getTValues(uint256 tAmount) private pure returns (uint256, uint256) {\n        uint256 tFee = tAmount.div(100);\n        uint256 tTransferAmount = tAmount.sub(tFee);\n        return (tTransferAmount, tFee);\n    }\n\n    function _getRValues(uint256 tAmount, uint256 tFee, uint256 currentRate) private pure returns (uint256, uint256, uint256) {\n        uint256 rAmount = tAmount.mul(currentRate);\n        uint256 rFee = tFee.mul(currentRate);\n        uint256 rTransferAmount = rAmount.sub(rFee);\n        return (rAmount, rTransferAmount, rFee);\n    }\n\n    function _getRate() private view returns(uint256) {\n        (uint256 rSupply, uint256 tSupply) = _getCurrentSupply();\n        return rSupply.div(tSupply);\n    }\n\n    function _getCurrentSupply() private view returns(uint256, uint256) {\n        uint256 rSupply = _rTotal;\n        uint256 tSupply = _tTotal;      \n        for (uint256 i = 0; i < _excluded.length; i++) {\n            if (_rOwned[_excluded[i]] > rSupply || _tOwned[_excluded[i]] > tSupply) return (_rTotal, _tTotal);\n            rSupply = rSupply.sub(_rOwned[_excluded[i]]);\n            tSupply = tSupply.sub(_tOwned[_excluded[i]]);\n        }\n        if (rSupply < _rTotal.div(_tTotal)) return (_rTotal, _tTotal);\n        return (rSupply, tSupply);\n    }\n}",
        "function": "transfer(address,uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Hacken-SOAR-V1/code/SOAR.sol",
        "vulnerability": "Dependence on predictable environment variable (SWC 116)",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract SOAR is Context, IERC20, Ownable { \n    using SafeMath for uint256;\n    using Address for address;\n\n    mapping (address => uint256) private _rOwned;\n    mapping (address => uint256) private _tOwned;\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    mapping (address => bool) private _isExcluded;\n    address[] private _excluded;\n   \n    uint256 private constant MAX = ~uint256(0);\n    uint256 private constant _tTotal = 10 * 10**6 * 10**9;  \n    \n    uint256 private _rTotal = (MAX - (MAX % _tTotal));\n    uint256 private _tFeeTotal;\n\n    string private _name = 'SOAR.FI'; \n    string private _symbol = 'SOAR'; \n    uint8 private _decimals = 9; \n    \n    uint256 private startTime;\n\n    constructor () public {\n        _rOwned[_msgSender()] = _rTotal;\n        emit Transfer(address(0), _msgSender(), _tTotal);\n        startTime = now + (60 * 60); //60 Minutes Delay to Launch Time Function since Contract Deployment\n    }\n\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n\n    function totalSupply() public view override returns (uint256) {\n        return _tTotal;\n    }\n\n    function balanceOf(address account) public view override returns (uint256) {\n        if (_isExcluded[account]) return _tOwned[account];\n        return tokenFromReflection(_rOwned[account]);\n    }\n\n    function transfer(address recipient, uint256 amount) public override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    function allowance(address owner, address spender) public view override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    function approve(address spender, uint256 amount) public override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    function isExcluded(address account) public view returns (bool) {\n        return _isExcluded[account];\n    }\n\n    function totalFees() public view returns (uint256) {\n        return _tFeeTotal;\n    }\n\n    function reflect(uint256 tAmount) public {\n        address sender = _msgSender();\n        require(!_isExcluded[sender], \"Excluded addresses cannot call this function\");\n        (uint256 rAmount,,,,) = _getValues(tAmount);\n        _rOwned[sender] = _rOwned[sender].sub(rAmount);\n        _rTotal = _rTotal.sub(rAmount);\n        _tFeeTotal = _tFeeTotal.add(tAmount);\n    }\n\n    function reflectionFromToken(uint256 tAmount, bool deductTransferFee) public view returns(uint256) {\n        require(tAmount <= _tTotal, \"Amount must be less than supply\");\n        if (!deductTransferFee) {\n            (uint256 rAmount,,,,) = _getValues(tAmount);\n            return rAmount;\n        } else {\n            (,uint256 rTransferAmount,,,) = _getValues(tAmount);\n            return rTransferAmount;\n        }\n    }\n\n    function tokenFromReflection(uint256 rAmount) public view returns(uint256) {\n        require(rAmount <= _rTotal, \"Amount must be less than total reflections\");\n        uint256 currentRate =  _getRate();\n        return rAmount.div(currentRate);\n    }\n\n    function excludeAccount(address account) external onlyOwner() {\n        require(!_isExcluded[account], \"Account is already excluded\");\n        if(_rOwned[account] > 0) {\n            _tOwned[account] = tokenFromReflection(_rOwned[account]);\n        }\n        _isExcluded[account] = true;\n        _excluded.push(account);\n    }\n\n    function includeAccount(address account) external onlyOwner() {\n        require(_isExcluded[account], \"Account is already excluded\");\n        for (uint256 i = 0; i < _excluded.length; i++) {\n            if (_excluded[i] == account) {\n                _excluded[i] = _excluded[_excluded.length - 1];\n                _tOwned[account] = 0;\n                _isExcluded[account] = false;\n                _excluded.pop();\n                break;\n            }\n        }\n    }\n\n    function _approve(address owner, address spender, uint256 amount) private {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    function _transfer(address sender, address recipient, uint256 amount) private {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n        require(amount > 0, \"Transfer amount must be greater than zero\");\n        \n        uint256 relaseTime1 = startTime + (120 * 60); //120 minutes\n        uint256 xLimit1 = 50000 * 10**9; \n    \n        uint256 relaseTime2 = startTime + (240 * 60); //240 minutes\n        uint256 xLimit2 = 100000 * 10**9; \n    \n        uint256 relaseTime3 = startTime + (360 * 60); //360 minutes\n        uint256 xLimit3 = 150000 * 10**9; \n        \n        if (now < startTime) {\n                if (_isExcluded[sender] && !_isExcluded[recipient]) {\n                    _transferFromExcluded(sender, recipient, amount);\n                } else if (!_isExcluded[sender] && _isExcluded[recipient]) {\n                    _transferToExcluded(sender, recipient, amount);\n                } else if (!_isExcluded[sender] && !_isExcluded[recipient]) {\n                    _transferStandard(sender, recipient, amount);\n                } else if (_isExcluded[sender] && _isExcluded[recipient]) {\n                    _transferBothExcluded(sender, recipient, amount);\n                } else {\n                    _transferStandard(sender, recipient, amount);\n                }\n        } else if (now >= startTime && now <= relaseTime1) {\n            if (amount <= xLimit1) {\n                if (_isExcluded[sender] && !_isExcluded[recipient]) {\n                    _transferFromExcluded(sender, recipient, amount);\n                } else if (!_isExcluded[sender] && _isExcluded[recipient]) {\n                    _transferToExcluded(sender, recipient, amount);\n                } else if (!_isExcluded[sender] && !_isExcluded[recipient]) {\n                    _transferStandard(sender, recipient, amount);\n                } else if (_isExcluded[sender] && _isExcluded[recipient]) {\n                    _transferBothExcluded(sender, recipient, amount);\n                } else {\n                    _transferStandard(sender, recipient, amount);\n                }\n            } else {\n                revert(\"ERC20: cannot transfer more than 50,000 tokens in first 120 minutes\");\n            }\n        } else if (now > relaseTime1 && now <= relaseTime2) {\n            if (amount <= xLimit2) {\n                if (_isExcluded[sender] && !_isExcluded[recipient]) {\n                    _transferFromExcluded(sender, recipient, amount);\n                } else if (!_isExcluded[sender] && _isExcluded[recipient]) {\n                    _transferToExcluded(sender, recipient, amount);\n                } else if (!_isExcluded[sender] && !_isExcluded[recipient]) {\n                    _transferStandard(sender, recipient, amount);\n                } else if (_isExcluded[sender] && _isExcluded[recipient]) {\n                    _transferBothExcluded(sender, recipient, amount);\n                } else {\n                    _transferStandard(sender, recipient, amount);\n                }\n            } else {\n                revert(\"ERC20: cannot transfer more than 100,000 tokens in first 240 minutes\");\n            }\n        } else if (now > relaseTime2 && now <= relaseTime3) {\n            if (amount <= xLimit3) {\n                if (_isExcluded[sender] && !_isExcluded[recipient]) {\n                    _transferFromExcluded(sender, recipient, amount);\n                } else if (!_isExcluded[sender] && _isExcluded[recipient]) {\n                    _transferToExcluded(sender, recipient, amount);\n                } else if (!_isExcluded[sender] && !_isExcluded[recipient]) {\n                    _transferStandard(sender, recipient, amount);\n                } else if (_isExcluded[sender] && _isExcluded[recipient]) {\n                    _transferBothExcluded(sender, recipient, amount);\n                } else {\n                    _transferStandard(sender, recipient, amount);\n                }\n            } else {\n                revert(\"ERC20: cannot transfer more than 150,000 tokens in first 360 minutes\");\n            }\n        } else if (now > relaseTime3) {\n            if (_isExcluded[sender] && !_isExcluded[recipient]) {\n                _transferFromExcluded(sender, recipient, amount);\n            } else if (!_isExcluded[sender] && _isExcluded[recipient]) {\n                _transferToExcluded(sender, recipient, amount);\n            } else if (!_isExcluded[sender] && !_isExcluded[recipient]) {\n                _transferStandard(sender, recipient, amount);\n            } else if (_isExcluded[sender] && _isExcluded[recipient]) {\n                _transferBothExcluded(sender, recipient, amount);\n            } else {\n                _transferStandard(sender, recipient, amount);\n            }\n        }\n    }\n\n    function _transferStandard(address sender, address recipient, uint256 tAmount) private {\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee) = _getValues(tAmount);\n        _rOwned[sender] = _rOwned[sender].sub(rAmount);\n        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);       \n        _reflectFee(rFee, tFee);\n        emit Transfer(sender, recipient, tTransferAmount);\n    }\n\n    function _transferToExcluded(address sender, address recipient, uint256 tAmount) private {\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee) = _getValues(tAmount);\n        _rOwned[sender] = _rOwned[sender].sub(rAmount);\n        _tOwned[recipient] = _tOwned[recipient].add(tTransferAmount);\n        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);           \n        _reflectFee(rFee, tFee);\n        emit Transfer(sender, recipient, tTransferAmount);\n    }\n\n    function _transferFromExcluded(address sender, address recipient, uint256 tAmount) private {\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee) = _getValues(tAmount);\n        _tOwned[sender] = _tOwned[sender].sub(tAmount);\n        _rOwned[sender] = _rOwned[sender].sub(rAmount);\n        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);   \n        _reflectFee(rFee, tFee);\n        emit Transfer(sender, recipient, tTransferAmount);\n    }\n\n    function _transferBothExcluded(address sender, address recipient, uint256 tAmount) private {\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee) = _getValues(tAmount);\n        _tOwned[sender] = _tOwned[sender].sub(tAmount);\n        _rOwned[sender] = _rOwned[sender].sub(rAmount);\n        _tOwned[recipient] = _tOwned[recipient].add(tTransferAmount);\n        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);        \n        _reflectFee(rFee, tFee);\n        emit Transfer(sender, recipient, tTransferAmount);\n    }\n\n    function _reflectFee(uint256 rFee, uint256 tFee) private {\n        _rTotal = _rTotal.sub(rFee);\n        _tFeeTotal = _tFeeTotal.add(tFee);\n    }\n\n    function _getValues(uint256 tAmount) private view returns (uint256, uint256, uint256, uint256, uint256) {\n        (uint256 tTransferAmount, uint256 tFee) = _getTValues(tAmount);\n        uint256 currentRate =  _getRate();\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee) = _getRValues(tAmount, tFee, currentRate);\n        return (rAmount, rTransferAmount, rFee, tTransferAmount, tFee);\n    }\n\n    function _getTValues(uint256 tAmount) private pure returns (uint256, uint256) {\n        uint256 tFee = tAmount.div(100);\n        uint256 tTransferAmount = tAmount.sub(tFee);\n        return (tTransferAmount, tFee);\n    }\n\n    function _getRValues(uint256 tAmount, uint256 tFee, uint256 currentRate) private pure returns (uint256, uint256, uint256) {\n        uint256 rAmount = tAmount.mul(currentRate);\n        uint256 rFee = tFee.mul(currentRate);\n        uint256 rTransferAmount = rAmount.sub(rFee);\n        return (rAmount, rTransferAmount, rFee);\n    }\n\n    function _getRate() private view returns(uint256) {\n        (uint256 rSupply, uint256 tSupply) = _getCurrentSupply();\n        return rSupply.div(tSupply);\n    }\n\n    function _getCurrentSupply() private view returns(uint256, uint256) {\n        uint256 rSupply = _rTotal;\n        uint256 tSupply = _tTotal;      \n        for (uint256 i = 0; i < _excluded.length; i++) {\n            if (_rOwned[_excluded[i]] > rSupply || _tOwned[_excluded[i]] > tSupply) return (_rTotal, _tTotal);\n            rSupply = rSupply.sub(_rOwned[_excluded[i]]);\n            tSupply = tSupply.sub(_tOwned[_excluded[i]]);\n        }\n        if (rSupply < _rTotal.div(_tTotal)) return (_rTotal, _tTotal);\n        return (rSupply, tSupply);\n    }\n}",
        "function": "transfer(address,uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Hacken-SOAR-V1/code/SOAR.sol",
        "vulnerability": "Dependence on predictable environment variable (SWC 116)",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract SOAR is Context, IERC20, Ownable { \n    using SafeMath for uint256;\n    using Address for address;\n\n    mapping (address => uint256) private _rOwned;\n    mapping (address => uint256) private _tOwned;\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    mapping (address => bool) private _isExcluded;\n    address[] private _excluded;\n   \n    uint256 private constant MAX = ~uint256(0);\n    uint256 private constant _tTotal = 10 * 10**6 * 10**9;  \n    \n    uint256 private _rTotal = (MAX - (MAX % _tTotal));\n    uint256 private _tFeeTotal;\n\n    string private _name = 'SOAR.FI'; \n    string private _symbol = 'SOAR'; \n    uint8 private _decimals = 9; \n    \n    uint256 private startTime;\n\n    constructor () public {\n        _rOwned[_msgSender()] = _rTotal;\n        emit Transfer(address(0), _msgSender(), _tTotal);\n        startTime = now + (60 * 60); //60 Minutes Delay to Launch Time Function since Contract Deployment\n    }\n\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n\n    function totalSupply() public view override returns (uint256) {\n        return _tTotal;\n    }\n\n    function balanceOf(address account) public view override returns (uint256) {\n        if (_isExcluded[account]) return _tOwned[account];\n        return tokenFromReflection(_rOwned[account]);\n    }\n\n    function transfer(address recipient, uint256 amount) public override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    function allowance(address owner, address spender) public view override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    function approve(address spender, uint256 amount) public override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    function isExcluded(address account) public view returns (bool) {\n        return _isExcluded[account];\n    }\n\n    function totalFees() public view returns (uint256) {\n        return _tFeeTotal;\n    }\n\n    function reflect(uint256 tAmount) public {\n        address sender = _msgSender();\n        require(!_isExcluded[sender], \"Excluded addresses cannot call this function\");\n        (uint256 rAmount,,,,) = _getValues(tAmount);\n        _rOwned[sender] = _rOwned[sender].sub(rAmount);\n        _rTotal = _rTotal.sub(rAmount);\n        _tFeeTotal = _tFeeTotal.add(tAmount);\n    }\n\n    function reflectionFromToken(uint256 tAmount, bool deductTransferFee) public view returns(uint256) {\n        require(tAmount <= _tTotal, \"Amount must be less than supply\");\n        if (!deductTransferFee) {\n            (uint256 rAmount,,,,) = _getValues(tAmount);\n            return rAmount;\n        } else {\n            (,uint256 rTransferAmount,,,) = _getValues(tAmount);\n            return rTransferAmount;\n        }\n    }\n\n    function tokenFromReflection(uint256 rAmount) public view returns(uint256) {\n        require(rAmount <= _rTotal, \"Amount must be less than total reflections\");\n        uint256 currentRate =  _getRate();\n        return rAmount.div(currentRate);\n    }\n\n    function excludeAccount(address account) external onlyOwner() {\n        require(!_isExcluded[account], \"Account is already excluded\");\n        if(_rOwned[account] > 0) {\n            _tOwned[account] = tokenFromReflection(_rOwned[account]);\n        }\n        _isExcluded[account] = true;\n        _excluded.push(account);\n    }\n\n    function includeAccount(address account) external onlyOwner() {\n        require(_isExcluded[account], \"Account is already excluded\");\n        for (uint256 i = 0; i < _excluded.length; i++) {\n            if (_excluded[i] == account) {\n                _excluded[i] = _excluded[_excluded.length - 1];\n                _tOwned[account] = 0;\n                _isExcluded[account] = false;\n                _excluded.pop();\n                break;\n            }\n        }\n    }\n\n    function _approve(address owner, address spender, uint256 amount) private {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    function _transfer(address sender, address recipient, uint256 amount) private {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n        require(amount > 0, \"Transfer amount must be greater than zero\");\n        \n        uint256 relaseTime1 = startTime + (120 * 60); //120 minutes\n        uint256 xLimit1 = 50000 * 10**9; \n    \n        uint256 relaseTime2 = startTime + (240 * 60); //240 minutes\n        uint256 xLimit2 = 100000 * 10**9; \n    \n        uint256 relaseTime3 = startTime + (360 * 60); //360 minutes\n        uint256 xLimit3 = 150000 * 10**9; \n        \n        if (now < startTime) {\n                if (_isExcluded[sender] && !_isExcluded[recipient]) {\n                    _transferFromExcluded(sender, recipient, amount);\n                } else if (!_isExcluded[sender] && _isExcluded[recipient]) {\n                    _transferToExcluded(sender, recipient, amount);\n                } else if (!_isExcluded[sender] && !_isExcluded[recipient]) {\n                    _transferStandard(sender, recipient, amount);\n                } else if (_isExcluded[sender] && _isExcluded[recipient]) {\n                    _transferBothExcluded(sender, recipient, amount);\n                } else {\n                    _transferStandard(sender, recipient, amount);\n                }\n        } else if (now >= startTime && now <= relaseTime1) {\n            if (amount <= xLimit1) {\n                if (_isExcluded[sender] && !_isExcluded[recipient]) {\n                    _transferFromExcluded(sender, recipient, amount);\n                } else if (!_isExcluded[sender] && _isExcluded[recipient]) {\n                    _transferToExcluded(sender, recipient, amount);\n                } else if (!_isExcluded[sender] && !_isExcluded[recipient]) {\n                    _transferStandard(sender, recipient, amount);\n                } else if (_isExcluded[sender] && _isExcluded[recipient]) {\n                    _transferBothExcluded(sender, recipient, amount);\n                } else {\n                    _transferStandard(sender, recipient, amount);\n                }\n            } else {\n                revert(\"ERC20: cannot transfer more than 50,000 tokens in first 120 minutes\");\n            }\n        } else if (now > relaseTime1 && now <= relaseTime2) {\n            if (amount <= xLimit2) {\n                if (_isExcluded[sender] && !_isExcluded[recipient]) {\n                    _transferFromExcluded(sender, recipient, amount);\n                } else if (!_isExcluded[sender] && _isExcluded[recipient]) {\n                    _transferToExcluded(sender, recipient, amount);\n                } else if (!_isExcluded[sender] && !_isExcluded[recipient]) {\n                    _transferStandard(sender, recipient, amount);\n                } else if (_isExcluded[sender] && _isExcluded[recipient]) {\n                    _transferBothExcluded(sender, recipient, amount);\n                } else {\n                    _transferStandard(sender, recipient, amount);\n                }\n            } else {\n                revert(\"ERC20: cannot transfer more than 100,000 tokens in first 240 minutes\");\n            }\n        } else if (now > relaseTime2 && now <= relaseTime3) {\n            if (amount <= xLimit3) {\n                if (_isExcluded[sender] && !_isExcluded[recipient]) {\n                    _transferFromExcluded(sender, recipient, amount);\n                } else if (!_isExcluded[sender] && _isExcluded[recipient]) {\n                    _transferToExcluded(sender, recipient, amount);\n                } else if (!_isExcluded[sender] && !_isExcluded[recipient]) {\n                    _transferStandard(sender, recipient, amount);\n                } else if (_isExcluded[sender] && _isExcluded[recipient]) {\n                    _transferBothExcluded(sender, recipient, amount);\n                } else {\n                    _transferStandard(sender, recipient, amount);\n                }\n            } else {\n                revert(\"ERC20: cannot transfer more than 150,000 tokens in first 360 minutes\");\n            }\n        } else if (now > relaseTime3) {\n            if (_isExcluded[sender] && !_isExcluded[recipient]) {\n                _transferFromExcluded(sender, recipient, amount);\n            } else if (!_isExcluded[sender] && _isExcluded[recipient]) {\n                _transferToExcluded(sender, recipient, amount);\n            } else if (!_isExcluded[sender] && !_isExcluded[recipient]) {\n                _transferStandard(sender, recipient, amount);\n            } else if (_isExcluded[sender] && _isExcluded[recipient]) {\n                _transferBothExcluded(sender, recipient, amount);\n            } else {\n                _transferStandard(sender, recipient, amount);\n            }\n        }\n    }\n\n    function _transferStandard(address sender, address recipient, uint256 tAmount) private {\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee) = _getValues(tAmount);\n        _rOwned[sender] = _rOwned[sender].sub(rAmount);\n        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);       \n        _reflectFee(rFee, tFee);\n        emit Transfer(sender, recipient, tTransferAmount);\n    }\n\n    function _transferToExcluded(address sender, address recipient, uint256 tAmount) private {\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee) = _getValues(tAmount);\n        _rOwned[sender] = _rOwned[sender].sub(rAmount);\n        _tOwned[recipient] = _tOwned[recipient].add(tTransferAmount);\n        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);           \n        _reflectFee(rFee, tFee);\n        emit Transfer(sender, recipient, tTransferAmount);\n    }\n\n    function _transferFromExcluded(address sender, address recipient, uint256 tAmount) private {\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee) = _getValues(tAmount);\n        _tOwned[sender] = _tOwned[sender].sub(tAmount);\n        _rOwned[sender] = _rOwned[sender].sub(rAmount);\n        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);   \n        _reflectFee(rFee, tFee);\n        emit Transfer(sender, recipient, tTransferAmount);\n    }\n\n    function _transferBothExcluded(address sender, address recipient, uint256 tAmount) private {\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee) = _getValues(tAmount);\n        _tOwned[sender] = _tOwned[sender].sub(tAmount);\n        _rOwned[sender] = _rOwned[sender].sub(rAmount);\n        _tOwned[recipient] = _tOwned[recipient].add(tTransferAmount);\n        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);        \n        _reflectFee(rFee, tFee);\n        emit Transfer(sender, recipient, tTransferAmount);\n    }\n\n    function _reflectFee(uint256 rFee, uint256 tFee) private {\n        _rTotal = _rTotal.sub(rFee);\n        _tFeeTotal = _tFeeTotal.add(tFee);\n    }\n\n    function _getValues(uint256 tAmount) private view returns (uint256, uint256, uint256, uint256, uint256) {\n        (uint256 tTransferAmount, uint256 tFee) = _getTValues(tAmount);\n        uint256 currentRate =  _getRate();\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee) = _getRValues(tAmount, tFee, currentRate);\n        return (rAmount, rTransferAmount, rFee, tTransferAmount, tFee);\n    }\n\n    function _getTValues(uint256 tAmount) private pure returns (uint256, uint256) {\n        uint256 tFee = tAmount.div(100);\n        uint256 tTransferAmount = tAmount.sub(tFee);\n        return (tTransferAmount, tFee);\n    }\n\n    function _getRValues(uint256 tAmount, uint256 tFee, uint256 currentRate) private pure returns (uint256, uint256, uint256) {\n        uint256 rAmount = tAmount.mul(currentRate);\n        uint256 rFee = tFee.mul(currentRate);\n        uint256 rTransferAmount = rAmount.sub(rFee);\n        return (rAmount, rTransferAmount, rFee);\n    }\n\n    function _getRate() private view returns(uint256) {\n        (uint256 rSupply, uint256 tSupply) = _getCurrentSupply();\n        return rSupply.div(tSupply);\n    }\n\n    function _getCurrentSupply() private view returns(uint256, uint256) {\n        uint256 rSupply = _rTotal;\n        uint256 tSupply = _tTotal;      \n        for (uint256 i = 0; i < _excluded.length; i++) {\n            if (_rOwned[_excluded[i]] > rSupply || _tOwned[_excluded[i]] > tSupply) return (_rTotal, _tTotal);\n            rSupply = rSupply.sub(_rOwned[_excluded[i]]);\n            tSupply = tSupply.sub(_tOwned[_excluded[i]]);\n        }\n        if (rSupply < _rTotal.div(_tTotal)) return (_rTotal, _tTotal);\n        return (rSupply, tSupply);\n    }\n}",
        "function": "transfer(address,uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Hacken-SOAR-V1/code/SOAR.sol",
        "vulnerability": "Dependence on predictable environment variable (SWC 116)",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract SOAR is Context, IERC20, Ownable { \n    using SafeMath for uint256;\n    using Address for address;\n\n    mapping (address => uint256) private _rOwned;\n    mapping (address => uint256) private _tOwned;\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    mapping (address => bool) private _isExcluded;\n    address[] private _excluded;\n   \n    uint256 private constant MAX = ~uint256(0);\n    uint256 private constant _tTotal = 10 * 10**6 * 10**9;  \n    \n    uint256 private _rTotal = (MAX - (MAX % _tTotal));\n    uint256 private _tFeeTotal;\n\n    string private _name = 'SOAR.FI'; \n    string private _symbol = 'SOAR'; \n    uint8 private _decimals = 9; \n    \n    uint256 private startTime;\n\n    constructor () public {\n        _rOwned[_msgSender()] = _rTotal;\n        emit Transfer(address(0), _msgSender(), _tTotal);\n        startTime = now + (60 * 60); //60 Minutes Delay to Launch Time Function since Contract Deployment\n    }\n\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n\n    function totalSupply() public view override returns (uint256) {\n        return _tTotal;\n    }\n\n    function balanceOf(address account) public view override returns (uint256) {\n        if (_isExcluded[account]) return _tOwned[account];\n        return tokenFromReflection(_rOwned[account]);\n    }\n\n    function transfer(address recipient, uint256 amount) public override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    function allowance(address owner, address spender) public view override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    function approve(address spender, uint256 amount) public override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    function isExcluded(address account) public view returns (bool) {\n        return _isExcluded[account];\n    }\n\n    function totalFees() public view returns (uint256) {\n        return _tFeeTotal;\n    }\n\n    function reflect(uint256 tAmount) public {\n        address sender = _msgSender();\n        require(!_isExcluded[sender], \"Excluded addresses cannot call this function\");\n        (uint256 rAmount,,,,) = _getValues(tAmount);\n        _rOwned[sender] = _rOwned[sender].sub(rAmount);\n        _rTotal = _rTotal.sub(rAmount);\n        _tFeeTotal = _tFeeTotal.add(tAmount);\n    }\n\n    function reflectionFromToken(uint256 tAmount, bool deductTransferFee) public view returns(uint256) {\n        require(tAmount <= _tTotal, \"Amount must be less than supply\");\n        if (!deductTransferFee) {\n            (uint256 rAmount,,,,) = _getValues(tAmount);\n            return rAmount;\n        } else {\n            (,uint256 rTransferAmount,,,) = _getValues(tAmount);\n            return rTransferAmount;\n        }\n    }\n\n    function tokenFromReflection(uint256 rAmount) public view returns(uint256) {\n        require(rAmount <= _rTotal, \"Amount must be less than total reflections\");\n        uint256 currentRate =  _getRate();\n        return rAmount.div(currentRate);\n    }\n\n    function excludeAccount(address account) external onlyOwner() {\n        require(!_isExcluded[account], \"Account is already excluded\");\n        if(_rOwned[account] > 0) {\n            _tOwned[account] = tokenFromReflection(_rOwned[account]);\n        }\n        _isExcluded[account] = true;\n        _excluded.push(account);\n    }\n\n    function includeAccount(address account) external onlyOwner() {\n        require(_isExcluded[account], \"Account is already excluded\");\n        for (uint256 i = 0; i < _excluded.length; i++) {\n            if (_excluded[i] == account) {\n                _excluded[i] = _excluded[_excluded.length - 1];\n                _tOwned[account] = 0;\n                _isExcluded[account] = false;\n                _excluded.pop();\n                break;\n            }\n        }\n    }\n\n    function _approve(address owner, address spender, uint256 amount) private {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    function _transfer(address sender, address recipient, uint256 amount) private {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n        require(amount > 0, \"Transfer amount must be greater than zero\");\n        \n        uint256 relaseTime1 = startTime + (120 * 60); //120 minutes\n        uint256 xLimit1 = 50000 * 10**9; \n    \n        uint256 relaseTime2 = startTime + (240 * 60); //240 minutes\n        uint256 xLimit2 = 100000 * 10**9; \n    \n        uint256 relaseTime3 = startTime + (360 * 60); //360 minutes\n        uint256 xLimit3 = 150000 * 10**9; \n        \n        if (now < startTime) {\n                if (_isExcluded[sender] && !_isExcluded[recipient]) {\n                    _transferFromExcluded(sender, recipient, amount);\n                } else if (!_isExcluded[sender] && _isExcluded[recipient]) {\n                    _transferToExcluded(sender, recipient, amount);\n                } else if (!_isExcluded[sender] && !_isExcluded[recipient]) {\n                    _transferStandard(sender, recipient, amount);\n                } else if (_isExcluded[sender] && _isExcluded[recipient]) {\n                    _transferBothExcluded(sender, recipient, amount);\n                } else {\n                    _transferStandard(sender, recipient, amount);\n                }\n        } else if (now >= startTime && now <= relaseTime1) {\n            if (amount <= xLimit1) {\n                if (_isExcluded[sender] && !_isExcluded[recipient]) {\n                    _transferFromExcluded(sender, recipient, amount);\n                } else if (!_isExcluded[sender] && _isExcluded[recipient]) {\n                    _transferToExcluded(sender, recipient, amount);\n                } else if (!_isExcluded[sender] && !_isExcluded[recipient]) {\n                    _transferStandard(sender, recipient, amount);\n                } else if (_isExcluded[sender] && _isExcluded[recipient]) {\n                    _transferBothExcluded(sender, recipient, amount);\n                } else {\n                    _transferStandard(sender, recipient, amount);\n                }\n            } else {\n                revert(\"ERC20: cannot transfer more than 50,000 tokens in first 120 minutes\");\n            }\n        } else if (now > relaseTime1 && now <= relaseTime2) {\n            if (amount <= xLimit2) {\n                if (_isExcluded[sender] && !_isExcluded[recipient]) {\n                    _transferFromExcluded(sender, recipient, amount);\n                } else if (!_isExcluded[sender] && _isExcluded[recipient]) {\n                    _transferToExcluded(sender, recipient, amount);\n                } else if (!_isExcluded[sender] && !_isExcluded[recipient]) {\n                    _transferStandard(sender, recipient, amount);\n                } else if (_isExcluded[sender] && _isExcluded[recipient]) {\n                    _transferBothExcluded(sender, recipient, amount);\n                } else {\n                    _transferStandard(sender, recipient, amount);\n                }\n            } else {\n                revert(\"ERC20: cannot transfer more than 100,000 tokens in first 240 minutes\");\n            }\n        } else if (now > relaseTime2 && now <= relaseTime3) {\n            if (amount <= xLimit3) {\n                if (_isExcluded[sender] && !_isExcluded[recipient]) {\n                    _transferFromExcluded(sender, recipient, amount);\n                } else if (!_isExcluded[sender] && _isExcluded[recipient]) {\n                    _transferToExcluded(sender, recipient, amount);\n                } else if (!_isExcluded[sender] && !_isExcluded[recipient]) {\n                    _transferStandard(sender, recipient, amount);\n                } else if (_isExcluded[sender] && _isExcluded[recipient]) {\n                    _transferBothExcluded(sender, recipient, amount);\n                } else {\n                    _transferStandard(sender, recipient, amount);\n                }\n            } else {\n                revert(\"ERC20: cannot transfer more than 150,000 tokens in first 360 minutes\");\n            }\n        } else if (now > relaseTime3) {\n            if (_isExcluded[sender] && !_isExcluded[recipient]) {\n                _transferFromExcluded(sender, recipient, amount);\n            } else if (!_isExcluded[sender] && _isExcluded[recipient]) {\n                _transferToExcluded(sender, recipient, amount);\n            } else if (!_isExcluded[sender] && !_isExcluded[recipient]) {\n                _transferStandard(sender, recipient, amount);\n            } else if (_isExcluded[sender] && _isExcluded[recipient]) {\n                _transferBothExcluded(sender, recipient, amount);\n            } else {\n                _transferStandard(sender, recipient, amount);\n            }\n        }\n    }\n\n    function _transferStandard(address sender, address recipient, uint256 tAmount) private {\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee) = _getValues(tAmount);\n        _rOwned[sender] = _rOwned[sender].sub(rAmount);\n        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);       \n        _reflectFee(rFee, tFee);\n        emit Transfer(sender, recipient, tTransferAmount);\n    }\n\n    function _transferToExcluded(address sender, address recipient, uint256 tAmount) private {\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee) = _getValues(tAmount);\n        _rOwned[sender] = _rOwned[sender].sub(rAmount);\n        _tOwned[recipient] = _tOwned[recipient].add(tTransferAmount);\n        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);           \n        _reflectFee(rFee, tFee);\n        emit Transfer(sender, recipient, tTransferAmount);\n    }\n\n    function _transferFromExcluded(address sender, address recipient, uint256 tAmount) private {\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee) = _getValues(tAmount);\n        _tOwned[sender] = _tOwned[sender].sub(tAmount);\n        _rOwned[sender] = _rOwned[sender].sub(rAmount);\n        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);   \n        _reflectFee(rFee, tFee);\n        emit Transfer(sender, recipient, tTransferAmount);\n    }\n\n    function _transferBothExcluded(address sender, address recipient, uint256 tAmount) private {\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee) = _getValues(tAmount);\n        _tOwned[sender] = _tOwned[sender].sub(tAmount);\n        _rOwned[sender] = _rOwned[sender].sub(rAmount);\n        _tOwned[recipient] = _tOwned[recipient].add(tTransferAmount);\n        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);        \n        _reflectFee(rFee, tFee);\n        emit Transfer(sender, recipient, tTransferAmount);\n    }\n\n    function _reflectFee(uint256 rFee, uint256 tFee) private {\n        _rTotal = _rTotal.sub(rFee);\n        _tFeeTotal = _tFeeTotal.add(tFee);\n    }\n\n    function _getValues(uint256 tAmount) private view returns (uint256, uint256, uint256, uint256, uint256) {\n        (uint256 tTransferAmount, uint256 tFee) = _getTValues(tAmount);\n        uint256 currentRate =  _getRate();\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee) = _getRValues(tAmount, tFee, currentRate);\n        return (rAmount, rTransferAmount, rFee, tTransferAmount, tFee);\n    }\n\n    function _getTValues(uint256 tAmount) private pure returns (uint256, uint256) {\n        uint256 tFee = tAmount.div(100);\n        uint256 tTransferAmount = tAmount.sub(tFee);\n        return (tTransferAmount, tFee);\n    }\n\n    function _getRValues(uint256 tAmount, uint256 tFee, uint256 currentRate) private pure returns (uint256, uint256, uint256) {\n        uint256 rAmount = tAmount.mul(currentRate);\n        uint256 rFee = tFee.mul(currentRate);\n        uint256 rTransferAmount = rAmount.sub(rFee);\n        return (rAmount, rTransferAmount, rFee);\n    }\n\n    function _getRate() private view returns(uint256) {\n        (uint256 rSupply, uint256 tSupply) = _getCurrentSupply();\n        return rSupply.div(tSupply);\n    }\n\n    function _getCurrentSupply() private view returns(uint256, uint256) {\n        uint256 rSupply = _rTotal;\n        uint256 tSupply = _tTotal;      \n        for (uint256 i = 0; i < _excluded.length; i++) {\n            if (_rOwned[_excluded[i]] > rSupply || _tOwned[_excluded[i]] > tSupply) return (_rTotal, _tTotal);\n            rSupply = rSupply.sub(_rOwned[_excluded[i]]);\n            tSupply = tSupply.sub(_tOwned[_excluded[i]]);\n        }\n        if (rSupply < _rTotal.div(_tTotal)) return (_rTotal, _tTotal);\n        return (rSupply, tSupply);\n    }\n}",
        "function": "transfer(address,uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Hacken-SOAR-V1/code/SOAR.sol",
        "vulnerability": "Dependence on predictable environment variable (SWC 116)",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract SOAR is Context, IERC20, Ownable { \n    using SafeMath for uint256;\n    using Address for address;\n\n    mapping (address => uint256) private _rOwned;\n    mapping (address => uint256) private _tOwned;\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    mapping (address => bool) private _isExcluded;\n    address[] private _excluded;\n   \n    uint256 private constant MAX = ~uint256(0);\n    uint256 private constant _tTotal = 10 * 10**6 * 10**9;  \n    \n    uint256 private _rTotal = (MAX - (MAX % _tTotal));\n    uint256 private _tFeeTotal;\n\n    string private _name = 'SOAR.FI'; \n    string private _symbol = 'SOAR'; \n    uint8 private _decimals = 9; \n    \n    uint256 private startTime;\n\n    constructor () public {\n        _rOwned[_msgSender()] = _rTotal;\n        emit Transfer(address(0), _msgSender(), _tTotal);\n        startTime = now + (60 * 60); //60 Minutes Delay to Launch Time Function since Contract Deployment\n    }\n\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n\n    function totalSupply() public view override returns (uint256) {\n        return _tTotal;\n    }\n\n    function balanceOf(address account) public view override returns (uint256) {\n        if (_isExcluded[account]) return _tOwned[account];\n        return tokenFromReflection(_rOwned[account]);\n    }\n\n    function transfer(address recipient, uint256 amount) public override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    function allowance(address owner, address spender) public view override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    function approve(address spender, uint256 amount) public override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    function isExcluded(address account) public view returns (bool) {\n        return _isExcluded[account];\n    }\n\n    function totalFees() public view returns (uint256) {\n        return _tFeeTotal;\n    }\n\n    function reflect(uint256 tAmount) public {\n        address sender = _msgSender();\n        require(!_isExcluded[sender], \"Excluded addresses cannot call this function\");\n        (uint256 rAmount,,,,) = _getValues(tAmount);\n        _rOwned[sender] = _rOwned[sender].sub(rAmount);\n        _rTotal = _rTotal.sub(rAmount);\n        _tFeeTotal = _tFeeTotal.add(tAmount);\n    }\n\n    function reflectionFromToken(uint256 tAmount, bool deductTransferFee) public view returns(uint256) {\n        require(tAmount <= _tTotal, \"Amount must be less than supply\");\n        if (!deductTransferFee) {\n            (uint256 rAmount,,,,) = _getValues(tAmount);\n            return rAmount;\n        } else {\n            (,uint256 rTransferAmount,,,) = _getValues(tAmount);\n            return rTransferAmount;\n        }\n    }\n\n    function tokenFromReflection(uint256 rAmount) public view returns(uint256) {\n        require(rAmount <= _rTotal, \"Amount must be less than total reflections\");\n        uint256 currentRate =  _getRate();\n        return rAmount.div(currentRate);\n    }\n\n    function excludeAccount(address account) external onlyOwner() {\n        require(!_isExcluded[account], \"Account is already excluded\");\n        if(_rOwned[account] > 0) {\n            _tOwned[account] = tokenFromReflection(_rOwned[account]);\n        }\n        _isExcluded[account] = true;\n        _excluded.push(account);\n    }\n\n    function includeAccount(address account) external onlyOwner() {\n        require(_isExcluded[account], \"Account is already excluded\");\n        for (uint256 i = 0; i < _excluded.length; i++) {\n            if (_excluded[i] == account) {\n                _excluded[i] = _excluded[_excluded.length - 1];\n                _tOwned[account] = 0;\n                _isExcluded[account] = false;\n                _excluded.pop();\n                break;\n            }\n        }\n    }\n\n    function _approve(address owner, address spender, uint256 amount) private {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    function _transfer(address sender, address recipient, uint256 amount) private {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n        require(amount > 0, \"Transfer amount must be greater than zero\");\n        \n        uint256 relaseTime1 = startTime + (120 * 60); //120 minutes\n        uint256 xLimit1 = 50000 * 10**9; \n    \n        uint256 relaseTime2 = startTime + (240 * 60); //240 minutes\n        uint256 xLimit2 = 100000 * 10**9; \n    \n        uint256 relaseTime3 = startTime + (360 * 60); //360 minutes\n        uint256 xLimit3 = 150000 * 10**9; \n        \n        if (now < startTime) {\n                if (_isExcluded[sender] && !_isExcluded[recipient]) {\n                    _transferFromExcluded(sender, recipient, amount);\n                } else if (!_isExcluded[sender] && _isExcluded[recipient]) {\n                    _transferToExcluded(sender, recipient, amount);\n                } else if (!_isExcluded[sender] && !_isExcluded[recipient]) {\n                    _transferStandard(sender, recipient, amount);\n                } else if (_isExcluded[sender] && _isExcluded[recipient]) {\n                    _transferBothExcluded(sender, recipient, amount);\n                } else {\n                    _transferStandard(sender, recipient, amount);\n                }\n        } else if (now >= startTime && now <= relaseTime1) {\n            if (amount <= xLimit1) {\n                if (_isExcluded[sender] && !_isExcluded[recipient]) {\n                    _transferFromExcluded(sender, recipient, amount);\n                } else if (!_isExcluded[sender] && _isExcluded[recipient]) {\n                    _transferToExcluded(sender, recipient, amount);\n                } else if (!_isExcluded[sender] && !_isExcluded[recipient]) {\n                    _transferStandard(sender, recipient, amount);\n                } else if (_isExcluded[sender] && _isExcluded[recipient]) {\n                    _transferBothExcluded(sender, recipient, amount);\n                } else {\n                    _transferStandard(sender, recipient, amount);\n                }\n            } else {\n                revert(\"ERC20: cannot transfer more than 50,000 tokens in first 120 minutes\");\n            }\n        } else if (now > relaseTime1 && now <= relaseTime2) {\n            if (amount <= xLimit2) {\n                if (_isExcluded[sender] && !_isExcluded[recipient]) {\n                    _transferFromExcluded(sender, recipient, amount);\n                } else if (!_isExcluded[sender] && _isExcluded[recipient]) {\n                    _transferToExcluded(sender, recipient, amount);\n                } else if (!_isExcluded[sender] && !_isExcluded[recipient]) {\n                    _transferStandard(sender, recipient, amount);\n                } else if (_isExcluded[sender] && _isExcluded[recipient]) {\n                    _transferBothExcluded(sender, recipient, amount);\n                } else {\n                    _transferStandard(sender, recipient, amount);\n                }\n            } else {\n                revert(\"ERC20: cannot transfer more than 100,000 tokens in first 240 minutes\");\n            }\n        } else if (now > relaseTime2 && now <= relaseTime3) {\n            if (amount <= xLimit3) {\n                if (_isExcluded[sender] && !_isExcluded[recipient]) {\n                    _transferFromExcluded(sender, recipient, amount);\n                } else if (!_isExcluded[sender] && _isExcluded[recipient]) {\n                    _transferToExcluded(sender, recipient, amount);\n                } else if (!_isExcluded[sender] && !_isExcluded[recipient]) {\n                    _transferStandard(sender, recipient, amount);\n                } else if (_isExcluded[sender] && _isExcluded[recipient]) {\n                    _transferBothExcluded(sender, recipient, amount);\n                } else {\n                    _transferStandard(sender, recipient, amount);\n                }\n            } else {\n                revert(\"ERC20: cannot transfer more than 150,000 tokens in first 360 minutes\");\n            }\n        } else if (now > relaseTime3) {\n            if (_isExcluded[sender] && !_isExcluded[recipient]) {\n                _transferFromExcluded(sender, recipient, amount);\n            } else if (!_isExcluded[sender] && _isExcluded[recipient]) {\n                _transferToExcluded(sender, recipient, amount);\n            } else if (!_isExcluded[sender] && !_isExcluded[recipient]) {\n                _transferStandard(sender, recipient, amount);\n            } else if (_isExcluded[sender] && _isExcluded[recipient]) {\n                _transferBothExcluded(sender, recipient, amount);\n            } else {\n                _transferStandard(sender, recipient, amount);\n            }\n        }\n    }\n\n    function _transferStandard(address sender, address recipient, uint256 tAmount) private {\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee) = _getValues(tAmount);\n        _rOwned[sender] = _rOwned[sender].sub(rAmount);\n        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);       \n        _reflectFee(rFee, tFee);\n        emit Transfer(sender, recipient, tTransferAmount);\n    }\n\n    function _transferToExcluded(address sender, address recipient, uint256 tAmount) private {\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee) = _getValues(tAmount);\n        _rOwned[sender] = _rOwned[sender].sub(rAmount);\n        _tOwned[recipient] = _tOwned[recipient].add(tTransferAmount);\n        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);           \n        _reflectFee(rFee, tFee);\n        emit Transfer(sender, recipient, tTransferAmount);\n    }\n\n    function _transferFromExcluded(address sender, address recipient, uint256 tAmount) private {\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee) = _getValues(tAmount);\n        _tOwned[sender] = _tOwned[sender].sub(tAmount);\n        _rOwned[sender] = _rOwned[sender].sub(rAmount);\n        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);   \n        _reflectFee(rFee, tFee);\n        emit Transfer(sender, recipient, tTransferAmount);\n    }\n\n    function _transferBothExcluded(address sender, address recipient, uint256 tAmount) private {\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee) = _getValues(tAmount);\n        _tOwned[sender] = _tOwned[sender].sub(tAmount);\n        _rOwned[sender] = _rOwned[sender].sub(rAmount);\n        _tOwned[recipient] = _tOwned[recipient].add(tTransferAmount);\n        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);        \n        _reflectFee(rFee, tFee);\n        emit Transfer(sender, recipient, tTransferAmount);\n    }\n\n    function _reflectFee(uint256 rFee, uint256 tFee) private {\n        _rTotal = _rTotal.sub(rFee);\n        _tFeeTotal = _tFeeTotal.add(tFee);\n    }\n\n    function _getValues(uint256 tAmount) private view returns (uint256, uint256, uint256, uint256, uint256) {\n        (uint256 tTransferAmount, uint256 tFee) = _getTValues(tAmount);\n        uint256 currentRate =  _getRate();\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee) = _getRValues(tAmount, tFee, currentRate);\n        return (rAmount, rTransferAmount, rFee, tTransferAmount, tFee);\n    }\n\n    function _getTValues(uint256 tAmount) private pure returns (uint256, uint256) {\n        uint256 tFee = tAmount.div(100);\n        uint256 tTransferAmount = tAmount.sub(tFee);\n        return (tTransferAmount, tFee);\n    }\n\n    function _getRValues(uint256 tAmount, uint256 tFee, uint256 currentRate) private pure returns (uint256, uint256, uint256) {\n        uint256 rAmount = tAmount.mul(currentRate);\n        uint256 rFee = tFee.mul(currentRate);\n        uint256 rTransferAmount = rAmount.sub(rFee);\n        return (rAmount, rTransferAmount, rFee);\n    }\n\n    function _getRate() private view returns(uint256) {\n        (uint256 rSupply, uint256 tSupply) = _getCurrentSupply();\n        return rSupply.div(tSupply);\n    }\n\n    function _getCurrentSupply() private view returns(uint256, uint256) {\n        uint256 rSupply = _rTotal;\n        uint256 tSupply = _tTotal;      \n        for (uint256 i = 0; i < _excluded.length; i++) {\n            if (_rOwned[_excluded[i]] > rSupply || _tOwned[_excluded[i]] > tSupply) return (_rTotal, _tTotal);\n            rSupply = rSupply.sub(_rOwned[_excluded[i]]);\n            tSupply = tSupply.sub(_tOwned[_excluded[i]]);\n        }\n        if (rSupply < _rTotal.div(_tTotal)) return (_rTotal, _tTotal);\n        return (rSupply, tSupply);\n    }\n}",
        "function": "transfer(address,uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Hacken-SOAR-V1/code/SOAR.sol",
        "vulnerability": "Dependence on predictable environment variable (SWC 116)",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract SOAR is Context, IERC20, Ownable { \n    using SafeMath for uint256;\n    using Address for address;\n\n    mapping (address => uint256) private _rOwned;\n    mapping (address => uint256) private _tOwned;\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    mapping (address => bool) private _isExcluded;\n    address[] private _excluded;\n   \n    uint256 private constant MAX = ~uint256(0);\n    uint256 private constant _tTotal = 10 * 10**6 * 10**9;  \n    \n    uint256 private _rTotal = (MAX - (MAX % _tTotal));\n    uint256 private _tFeeTotal;\n\n    string private _name = 'SOAR.FI'; \n    string private _symbol = 'SOAR'; \n    uint8 private _decimals = 9; \n    \n    uint256 private startTime;\n\n    constructor () public {\n        _rOwned[_msgSender()] = _rTotal;\n        emit Transfer(address(0), _msgSender(), _tTotal);\n        startTime = now + (60 * 60); //60 Minutes Delay to Launch Time Function since Contract Deployment\n    }\n\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n\n    function totalSupply() public view override returns (uint256) {\n        return _tTotal;\n    }\n\n    function balanceOf(address account) public view override returns (uint256) {\n        if (_isExcluded[account]) return _tOwned[account];\n        return tokenFromReflection(_rOwned[account]);\n    }\n\n    function transfer(address recipient, uint256 amount) public override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    function allowance(address owner, address spender) public view override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    function approve(address spender, uint256 amount) public override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    function isExcluded(address account) public view returns (bool) {\n        return _isExcluded[account];\n    }\n\n    function totalFees() public view returns (uint256) {\n        return _tFeeTotal;\n    }\n\n    function reflect(uint256 tAmount) public {\n        address sender = _msgSender();\n        require(!_isExcluded[sender], \"Excluded addresses cannot call this function\");\n        (uint256 rAmount,,,,) = _getValues(tAmount);\n        _rOwned[sender] = _rOwned[sender].sub(rAmount);\n        _rTotal = _rTotal.sub(rAmount);\n        _tFeeTotal = _tFeeTotal.add(tAmount);\n    }\n\n    function reflectionFromToken(uint256 tAmount, bool deductTransferFee) public view returns(uint256) {\n        require(tAmount <= _tTotal, \"Amount must be less than supply\");\n        if (!deductTransferFee) {\n            (uint256 rAmount,,,,) = _getValues(tAmount);\n            return rAmount;\n        } else {\n            (,uint256 rTransferAmount,,,) = _getValues(tAmount);\n            return rTransferAmount;\n        }\n    }\n\n    function tokenFromReflection(uint256 rAmount) public view returns(uint256) {\n        require(rAmount <= _rTotal, \"Amount must be less than total reflections\");\n        uint256 currentRate =  _getRate();\n        return rAmount.div(currentRate);\n    }\n\n    function excludeAccount(address account) external onlyOwner() {\n        require(!_isExcluded[account], \"Account is already excluded\");\n        if(_rOwned[account] > 0) {\n            _tOwned[account] = tokenFromReflection(_rOwned[account]);\n        }\n        _isExcluded[account] = true;\n        _excluded.push(account);\n    }\n\n    function includeAccount(address account) external onlyOwner() {\n        require(_isExcluded[account], \"Account is already excluded\");\n        for (uint256 i = 0; i < _excluded.length; i++) {\n            if (_excluded[i] == account) {\n                _excluded[i] = _excluded[_excluded.length - 1];\n                _tOwned[account] = 0;\n                _isExcluded[account] = false;\n                _excluded.pop();\n                break;\n            }\n        }\n    }\n\n    function _approve(address owner, address spender, uint256 amount) private {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    function _transfer(address sender, address recipient, uint256 amount) private {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n        require(amount > 0, \"Transfer amount must be greater than zero\");\n        \n        uint256 relaseTime1 = startTime + (120 * 60); //120 minutes\n        uint256 xLimit1 = 50000 * 10**9; \n    \n        uint256 relaseTime2 = startTime + (240 * 60); //240 minutes\n        uint256 xLimit2 = 100000 * 10**9; \n    \n        uint256 relaseTime3 = startTime + (360 * 60); //360 minutes\n        uint256 xLimit3 = 150000 * 10**9; \n        \n        if (now < startTime) {\n                if (_isExcluded[sender] && !_isExcluded[recipient]) {\n                    _transferFromExcluded(sender, recipient, amount);\n                } else if (!_isExcluded[sender] && _isExcluded[recipient]) {\n                    _transferToExcluded(sender, recipient, amount);\n                } else if (!_isExcluded[sender] && !_isExcluded[recipient]) {\n                    _transferStandard(sender, recipient, amount);\n                } else if (_isExcluded[sender] && _isExcluded[recipient]) {\n                    _transferBothExcluded(sender, recipient, amount);\n                } else {\n                    _transferStandard(sender, recipient, amount);\n                }\n        } else if (now >= startTime && now <= relaseTime1) {\n            if (amount <= xLimit1) {\n                if (_isExcluded[sender] && !_isExcluded[recipient]) {\n                    _transferFromExcluded(sender, recipient, amount);\n                } else if (!_isExcluded[sender] && _isExcluded[recipient]) {\n                    _transferToExcluded(sender, recipient, amount);\n                } else if (!_isExcluded[sender] && !_isExcluded[recipient]) {\n                    _transferStandard(sender, recipient, amount);\n                } else if (_isExcluded[sender] && _isExcluded[recipient]) {\n                    _transferBothExcluded(sender, recipient, amount);\n                } else {\n                    _transferStandard(sender, recipient, amount);\n                }\n            } else {\n                revert(\"ERC20: cannot transfer more than 50,000 tokens in first 120 minutes\");\n            }\n        } else if (now > relaseTime1 && now <= relaseTime2) {\n            if (amount <= xLimit2) {\n                if (_isExcluded[sender] && !_isExcluded[recipient]) {\n                    _transferFromExcluded(sender, recipient, amount);\n                } else if (!_isExcluded[sender] && _isExcluded[recipient]) {\n                    _transferToExcluded(sender, recipient, amount);\n                } else if (!_isExcluded[sender] && !_isExcluded[recipient]) {\n                    _transferStandard(sender, recipient, amount);\n                } else if (_isExcluded[sender] && _isExcluded[recipient]) {\n                    _transferBothExcluded(sender, recipient, amount);\n                } else {\n                    _transferStandard(sender, recipient, amount);\n                }\n            } else {\n                revert(\"ERC20: cannot transfer more than 100,000 tokens in first 240 minutes\");\n            }\n        } else if (now > relaseTime2 && now <= relaseTime3) {\n            if (amount <= xLimit3) {\n                if (_isExcluded[sender] && !_isExcluded[recipient]) {\n                    _transferFromExcluded(sender, recipient, amount);\n                } else if (!_isExcluded[sender] && _isExcluded[recipient]) {\n                    _transferToExcluded(sender, recipient, amount);\n                } else if (!_isExcluded[sender] && !_isExcluded[recipient]) {\n                    _transferStandard(sender, recipient, amount);\n                } else if (_isExcluded[sender] && _isExcluded[recipient]) {\n                    _transferBothExcluded(sender, recipient, amount);\n                } else {\n                    _transferStandard(sender, recipient, amount);\n                }\n            } else {\n                revert(\"ERC20: cannot transfer more than 150,000 tokens in first 360 minutes\");\n            }\n        } else if (now > relaseTime3) {\n            if (_isExcluded[sender] && !_isExcluded[recipient]) {\n                _transferFromExcluded(sender, recipient, amount);\n            } else if (!_isExcluded[sender] && _isExcluded[recipient]) {\n                _transferToExcluded(sender, recipient, amount);\n            } else if (!_isExcluded[sender] && !_isExcluded[recipient]) {\n                _transferStandard(sender, recipient, amount);\n            } else if (_isExcluded[sender] && _isExcluded[recipient]) {\n                _transferBothExcluded(sender, recipient, amount);\n            } else {\n                _transferStandard(sender, recipient, amount);\n            }\n        }\n    }\n\n    function _transferStandard(address sender, address recipient, uint256 tAmount) private {\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee) = _getValues(tAmount);\n        _rOwned[sender] = _rOwned[sender].sub(rAmount);\n        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);       \n        _reflectFee(rFee, tFee);\n        emit Transfer(sender, recipient, tTransferAmount);\n    }\n\n    function _transferToExcluded(address sender, address recipient, uint256 tAmount) private {\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee) = _getValues(tAmount);\n        _rOwned[sender] = _rOwned[sender].sub(rAmount);\n        _tOwned[recipient] = _tOwned[recipient].add(tTransferAmount);\n        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);           \n        _reflectFee(rFee, tFee);\n        emit Transfer(sender, recipient, tTransferAmount);\n    }\n\n    function _transferFromExcluded(address sender, address recipient, uint256 tAmount) private {\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee) = _getValues(tAmount);\n        _tOwned[sender] = _tOwned[sender].sub(tAmount);\n        _rOwned[sender] = _rOwned[sender].sub(rAmount);\n        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);   \n        _reflectFee(rFee, tFee);\n        emit Transfer(sender, recipient, tTransferAmount);\n    }\n\n    function _transferBothExcluded(address sender, address recipient, uint256 tAmount) private {\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee) = _getValues(tAmount);\n        _tOwned[sender] = _tOwned[sender].sub(tAmount);\n        _rOwned[sender] = _rOwned[sender].sub(rAmount);\n        _tOwned[recipient] = _tOwned[recipient].add(tTransferAmount);\n        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);        \n        _reflectFee(rFee, tFee);\n        emit Transfer(sender, recipient, tTransferAmount);\n    }\n\n    function _reflectFee(uint256 rFee, uint256 tFee) private {\n        _rTotal = _rTotal.sub(rFee);\n        _tFeeTotal = _tFeeTotal.add(tFee);\n    }\n\n    function _getValues(uint256 tAmount) private view returns (uint256, uint256, uint256, uint256, uint256) {\n        (uint256 tTransferAmount, uint256 tFee) = _getTValues(tAmount);\n        uint256 currentRate =  _getRate();\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee) = _getRValues(tAmount, tFee, currentRate);\n        return (rAmount, rTransferAmount, rFee, tTransferAmount, tFee);\n    }\n\n    function _getTValues(uint256 tAmount) private pure returns (uint256, uint256) {\n        uint256 tFee = tAmount.div(100);\n        uint256 tTransferAmount = tAmount.sub(tFee);\n        return (tTransferAmount, tFee);\n    }\n\n    function _getRValues(uint256 tAmount, uint256 tFee, uint256 currentRate) private pure returns (uint256, uint256, uint256) {\n        uint256 rAmount = tAmount.mul(currentRate);\n        uint256 rFee = tFee.mul(currentRate);\n        uint256 rTransferAmount = rAmount.sub(rFee);\n        return (rAmount, rTransferAmount, rFee);\n    }\n\n    function _getRate() private view returns(uint256) {\n        (uint256 rSupply, uint256 tSupply) = _getCurrentSupply();\n        return rSupply.div(tSupply);\n    }\n\n    function _getCurrentSupply() private view returns(uint256, uint256) {\n        uint256 rSupply = _rTotal;\n        uint256 tSupply = _tTotal;      \n        for (uint256 i = 0; i < _excluded.length; i++) {\n            if (_rOwned[_excluded[i]] > rSupply || _tOwned[_excluded[i]] > tSupply) return (_rTotal, _tTotal);\n            rSupply = rSupply.sub(_rOwned[_excluded[i]]);\n            tSupply = tSupply.sub(_tOwned[_excluded[i]]);\n        }\n        if (rSupply < _rTotal.div(_tTotal)) return (_rTotal, _tTotal);\n        return (rSupply, tSupply);\n    }\n}",
        "function": "transfer(address,uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Hacken-SOAR-V1/code/SOAR.sol",
        "vulnerability": "Dependence on predictable environment variable (SWC 116)",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract FLUX is ERC20Interface, Owned {\n\tstring public constant symbol = \"FLX\";\n\tstring public constant name = \"FLUX\";\n\tuint8 public constant decimals = 18;\n\tuint256 public constant totalSupply = 1000000000000000000000000000;\n\n\tbool public stopped;\n\n\tmapping (address => int8) public blackList;\n\n\tmapping (address => uint256) public balances;\n\tmapping (address => mapping (address => uint256)) public allowed;\n\n\n    event Blacklisted(address indexed target);\n    event DeleteFromBlacklist(address indexed target);\n    event RejectedPaymentToBlacklistedAddr(address indexed from, address indexed to, uint256 value);\n    event RejectedPaymentFromBlacklistedAddr(address indexed from, address indexed to, uint256 value);\n\n\n\tmodifier notStopped {\n        require(!stopped);\n        _;\n    }\n\n// constructor\n\tfunction FLUX() public {\n\t\tbalances[msg.sender] = totalSupply;\n\t}\n\t\n// function made for airdrop\n\tfunction airdrop(address[] _to, uint256[] _value) onlyOwner notStopped public {\n\t    for(uint256 i = 0; i < _to.length; i++){\n\t        if(balances[_to[i]] > 0){\n\t            continue;\n\t        }\n\t        transfer(_to[i], _value[i]);\n\t    }\n\t}\n\n// blacklist management\n    function blacklisting(address _addr) onlyOwner public {\n        blackList[_addr] = 1;\n        emit Blacklisted(_addr);\n    }\n    function deleteFromBlacklist(address _addr) onlyOwner public {\n        blackList[_addr] = -1;\n        emit DeleteFromBlacklist(_addr);\n    }\n\n// stop the contract\n// SWC-100-Function Default Visibility: L90\n\tfunction stop() onlyOwner {\n        stopped = true;\n    }\n// SWC-100-Function Default Visibility: L94\n    function start() onlyOwner {\n        stopped = false;\n    }\n\t\n// ERC20 functions\n\tfunction balanceOf(address _owner) public constant returns (uint256 balance){\n\t\treturn balances[_owner];\n\t}\n\tfunction transfer(address _to, uint256 _value) notStopped public returns (bool success){\n\t\trequire(balances[msg.sender] >= _value);\n\n\t\tif(blackList[msg.sender] > 0){\n\t\t\temit RejectedPaymentFromBlacklistedAddr(msg.sender, _to, _value);\n\t\t\treturn false;\n\t\t}\n\t\tif(blackList[_to] > 0){\n\t\t\temit RejectedPaymentToBlacklistedAddr(msg.sender, _to, _value);\n\t\t\treturn false;\n\t\t}\n\n\t\tbalances[msg.sender] -= _value;\n\t\tbalances[_to] += _value;\n\t\temit Transfer(msg.sender, _to, _value);\n\t\treturn true;\n\t}\n\tfunction transferFrom(address _from, address _to, uint256 _value) notStopped public returns (bool success){\n\t\trequire(balances[_from] >= _value\n\t\t\t&& allowed[_from][msg.sender] >= _value);\n\n\t\tif(blackList[_from] > 0){\n\t\t\temit RejectedPaymentFromBlacklistedAddr(_from, _to, _value);\n\t\t\treturn false;\n\t\t}\n\t\tif(blackList[_to] > 0){\n\t\t\temit RejectedPaymentToBlacklistedAddr(_from, _to, _value);\n\t\t\treturn false;\n\t\t}\n\n\t\tbalances[_from] -= _value;\n\t\tallowed[_from][msg.sender] -= _value;\n\t\tbalances[_to] += _value;\n\t\temit Transfer(_from, _to, _value);\n\t\treturn true;\n\t}\n\tfunction approve(address _spender, uint256 _value) notStopped public returns (bool success){\n\t\tallowed[msg.sender][_spender] = _value;\n\t\temit Approval(msg.sender, _spender, _value);\n\t\treturn true;\n\t}\n\tfunction allowance(address _owner, address _spender) public constant returns (uint256 remaining){\n\t\treturn allowed[_owner][_spender];\n\t}\n}",
        "function": "airdrop(address[],uint256[])",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Iosiro-FLUX Token Smart Contract Audit/code/Etherscan-0x54735d716995071585A4f6ba341a6Ded79756F09.sol",
        "vulnerability": "Integer Arithmetic Bugs (SWC 101)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract FLUX is ERC20Interface, Owned {\n\tstring public constant symbol = \"FLX\";\n\tstring public constant name = \"FLUX\";\n\tuint8 public constant decimals = 18;\n\tuint256 public constant totalSupply = 1000000000000000000000000000;\n\n\tbool public stopped;\n\n\tmapping (address => int8) public blackList;\n\n\tmapping (address => uint256) public balances;\n\tmapping (address => mapping (address => uint256)) public allowed;\n\n\n    event Blacklisted(address indexed target);\n    event DeleteFromBlacklist(address indexed target);\n    event RejectedPaymentToBlacklistedAddr(address indexed from, address indexed to, uint256 value);\n    event RejectedPaymentFromBlacklistedAddr(address indexed from, address indexed to, uint256 value);\n\n\n\tmodifier notStopped {\n        require(!stopped);\n        _;\n    }\n\n// constructor\n\tfunction FLUX() public {\n\t\tbalances[msg.sender] = totalSupply;\n\t}\n\t\n// function made for airdrop\n\tfunction airdrop(address[] _to, uint256[] _value) onlyOwner notStopped public {\n\t    for(uint256 i = 0; i < _to.length; i++){\n\t        if(balances[_to[i]] > 0){\n\t            continue;\n\t        }\n\t        transfer(_to[i], _value[i]);\n\t    }\n\t}\n\n// blacklist management\n    function blacklisting(address _addr) onlyOwner public {\n        blackList[_addr] = 1;\n        emit Blacklisted(_addr);\n    }\n    function deleteFromBlacklist(address _addr) onlyOwner public {\n        blackList[_addr] = -1;\n        emit DeleteFromBlacklist(_addr);\n    }\n\n// stop the contract\n// SWC-100-Function Default Visibility: L90\n\tfunction stop() onlyOwner {\n        stopped = true;\n    }\n// SWC-100-Function Default Visibility: L94\n    function start() onlyOwner {\n        stopped = false;\n    }\n\t\n// ERC20 functions\n\tfunction balanceOf(address _owner) public constant returns (uint256 balance){\n\t\treturn balances[_owner];\n\t}\n\tfunction transfer(address _to, uint256 _value) notStopped public returns (bool success){\n\t\trequire(balances[msg.sender] >= _value);\n\n\t\tif(blackList[msg.sender] > 0){\n\t\t\temit RejectedPaymentFromBlacklistedAddr(msg.sender, _to, _value);\n\t\t\treturn false;\n\t\t}\n\t\tif(blackList[_to] > 0){\n\t\t\temit RejectedPaymentToBlacklistedAddr(msg.sender, _to, _value);\n\t\t\treturn false;\n\t\t}\n\n\t\tbalances[msg.sender] -= _value;\n\t\tbalances[_to] += _value;\n\t\temit Transfer(msg.sender, _to, _value);\n\t\treturn true;\n\t}\n\tfunction transferFrom(address _from, address _to, uint256 _value) notStopped public returns (bool success){\n\t\trequire(balances[_from] >= _value\n\t\t\t&& allowed[_from][msg.sender] >= _value);\n\n\t\tif(blackList[_from] > 0){\n\t\t\temit RejectedPaymentFromBlacklistedAddr(_from, _to, _value);\n\t\t\treturn false;\n\t\t}\n\t\tif(blackList[_to] > 0){\n\t\t\temit RejectedPaymentToBlacklistedAddr(_from, _to, _value);\n\t\t\treturn false;\n\t\t}\n\n\t\tbalances[_from] -= _value;\n\t\tallowed[_from][msg.sender] -= _value;\n\t\tbalances[_to] += _value;\n\t\temit Transfer(_from, _to, _value);\n\t\treturn true;\n\t}\n\tfunction approve(address _spender, uint256 _value) notStopped public returns (bool success){\n\t\tallowed[msg.sender][_spender] = _value;\n\t\temit Approval(msg.sender, _spender, _value);\n\t\treturn true;\n\t}\n\tfunction allowance(address _owner, address _spender) public constant returns (uint256 remaining){\n\t\treturn allowed[_owner][_spender];\n\t}\n}",
        "function": "airdrop(address[],uint256[])",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Iosiro-FLUX Token Smart Contract Audit/code/Etherscan-0x54735d716995071585A4f6ba341a6Ded79756F09.sol",
        "vulnerability": "Exception State (SWC 110)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract LPool is DelegateInterface, Adminable, LPoolInterface, Exponential, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint;\n\n    constructor() {\n\n    }\n    /**\n     * Initialize the money market\n     * @param controller_ The address of the Controller\n     * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18\n     * @param name_ EIP-20 name of this token\n     * @param symbol_ EIP-20 symbol of this token\n     * @param decimals_ EIP-20 decimal precision of this token\n     */\n    function initialize(\n        address underlying_,\n        bool isWethPool_,\n        address controller_,\n        uint256 baseRatePerBlock_,\n        uint256 multiplierPerBlock_,\n        uint256 jumpMultiplierPerBlock_,\n        uint256 kink_,\n        uint initialExchangeRateMantissa_,\n        string memory name_,\n        string memory symbol_,\n        uint8 decimals_) public {\n        require(underlying_ != address(0), \"underlying_ address cannot be 0\");\n        require(controller_ != address(0), \"controller_ address cannot be 0\");\n        require(msg.sender == admin, \"Only allow to be called by admin\");\n        require(accrualBlockNumber == 0 && borrowIndex == 0, \"inited once\");\n\n        // Set initial exchange rate\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\n        require(initialExchangeRateMantissa > 0, \"Initial Exchange Rate Mantissa should be greater zero\");\n        //set controller\n        controller = controller_;\n        isWethPool = isWethPool_;\n        //set interestRateModel\n        baseRatePerBlock = baseRatePerBlock_;\n        multiplierPerBlock = multiplierPerBlock_;\n        jumpMultiplierPerBlock = jumpMultiplierPerBlock_;\n        kink = kink_;\n\n        // Initialize block number and borrow index (block number mocks depend on controller being set)\n        accrualBlockNumber = getBlockNumber();\n        borrowIndex = 1e25;\n        //80%\n        borrowCapFactorMantissa = 0.8e18;\n        //20%\n        reserveFactorMantissa = 0.2e18;\n\n\n        name = name_;\n        symbol = symbol_;\n        decimals = decimals_;\n\n        _notEntered = true;\n\n        // Set underlying and sanity check it\n        underlying = underlying_;\n        IERC20(underlying).totalSupply();\n    }\n\n    /**\n     * Transfer `tokens` tokens from `src` to `dst` by `spender`\n     * @dev Called by both `transfer` and `transferFrom` internally\n     * @param spender The address of the account performing the transfer\n     * @param src The address of the source account\n     * @param dst The address of the destination account\n     * @param tokens The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     */\n    function transferTokens(address spender, address src, address dst, uint tokens) internal returns (bool) {\n        require(dst != address(0), \"dst address cannot be 0\");\n        /* Do not allow self-transfers */\n        require(src != dst, \"src = dst\");\n        /* Fail if transfer not allowed */\n        (ControllerInterface(controller)).transferAllowed(address(this), src, dst, tokens);\n\n        /* Get the allowance, infinite for the account owner */\n        uint startingAllowance = 0;\n        if (spender == src) {\n            startingAllowance = uint(- 1);\n        } else {\n            startingAllowance = transferAllowances[src][spender];\n        }\n\n        /* Do the calculations, checking for {under,over}flow */\n        MathError mathErr;\n        uint allowanceNew;\n        uint srcTokensNew;\n        uint dstTokensNew;\n\n        (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);\n        require(mathErr == MathError.NO_ERROR, 'not allowed');\n\n        (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);\n        require(mathErr == MathError.NO_ERROR, 'not enough');\n\n        (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);\n        require(mathErr == MathError.NO_ERROR, 'too much');\n\n        accountTokens[src] = srcTokensNew;\n        accountTokens[dst] = dstTokensNew;\n\n        /* Eat some of the allowance (if necessary) */\n        if (startingAllowance != uint(- 1)) {\n            transferAllowances[src][spender] = allowanceNew;\n        }\n        /* We emit a Transfer event */\n        emit Transfer(src, dst, tokens);\n        return true;\n    }\n\n    /**\n     * Transfer `amount` tokens from `msg.sender` to `dst`\n     * @param dst The address of the destination account\n     * @param amount The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     */\n    function transfer(address dst, uint256 amount) external override nonReentrant returns (bool) {\n        return transferTokens(msg.sender, msg.sender, dst, amount);\n    }\n\n    /**\n     * Transfer `amount` tokens from `src` to `dst`\n     * @param src The address of the source account\n     * @param dst The address of the destination account\n     * @param amount The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     */\n    function transferFrom(address src, address dst, uint256 amount) external override nonReentrant returns (bool) {\n        return transferTokens(msg.sender, src, dst, amount);\n    }\n\n    /**\n     * Approve `spender` to transfer up to `amount` from `src`\n     * @dev This will overwrite the approval amount for `spender`\n     *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n     * @param spender The address of the account which may transfer tokens\n     * @param amount The number of tokens that are approved (-1 means infinite)\n     * @return Whether or not the approval succeeded\n     */\n    function approve(address spender, uint256 amount) external override returns (bool) {\n        address src = msg.sender;\n        transferAllowances[src][spender] = amount;\n        emit Approval(src, spender, amount);\n        return true;\n    }\n\n    /**\n     * Get the current allowance from `owner` for `spender`\n     * @param owner The address of the account which owns the tokens to be spent\n     * @param spender The address of the account which may transfer tokens\n     * @return The number of tokens allowed to be spent (-1 means infinite)\n     */\n    function allowance(address owner, address spender) external override view returns (uint256) {\n        return transferAllowances[owner][spender];\n    }\n\n    /**\n     * Get the token balance of the `owner`\n     * @param owner The address of the account to query\n     * @return The number of tokens owned by `owner`\n     */\n    function balanceOf(address owner) external override view returns (uint256) {\n        return accountTokens[owner];\n    }\n\n    /**\n     * Get the underlying balance of the `owner`\n     * @dev This also accrues interest in a transaction\n     * @param owner The address of the account to query\n     * @return The amount of underlying owned by `owner`\n     */\n    function balanceOfUnderlying(address owner) external override returns (uint) {\n        Exp memory exchangeRate = Exp({mantissa : exchangeRateCurrent()});\n        (MathError mErr, uint balance) = mulScalarTruncate(exchangeRate, accountTokens[owner]);\n        require(mErr == MathError.NO_ERROR, \"calc failed\");\n        return balance;\n    }\n\n    /*** User Interface ***/\n\n    /**\n     * Sender supplies assets into the market and receives lTokens in exchange\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param mintAmount The amount of the underlying asset to supply\n     */\n    function mint(uint mintAmount) external override nonReentrant {\n        accrueInterest();\n        // mintFresh emits the actual Mint event if successful and logs on errors, so we don't need to\n        mintFresh(msg.sender, mintAmount);\n    }\n\n    function mintEth() external payable override nonReentrant {\n        require(isWethPool, \"not eth pool\");\n        accrueInterest();\n        mintFresh(msg.sender, msg.value);\n    }\n\n    /**\n     * Sender redeems lTokens in exchange for the underlying asset\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param redeemTokens The number of lTokens to redeem into underlying\n     */\n    function redeem(uint redeemTokens) external override nonReentrant {\n        accrueInterest();\n        // redeemFresh emits redeem-specific logs on errors, so we don't need to\n        redeemFresh(msg.sender, redeemTokens, 0);\n    }\n\n    /**\n     * Sender redeems lTokens in exchange for a specified amount of underlying asset\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param redeemAmount The amount of underlying to redeem\n     */\n    function redeemUnderlying(uint redeemAmount) external override nonReentrant {\n        accrueInterest();\n        // redeemFresh emits redeem-specific logs on errors, so we don't need to\n        redeemFresh(msg.sender, 0, redeemAmount);\n    }\n\n    function borrowBehalf(address borrower, uint borrowAmount) external override nonReentrant {\n        accrueInterest();\n        // borrowFresh emits borrow-specific logs on errors, so we don't need to\n        borrowFresh(payable(borrower), msg.sender, borrowAmount);\n    }\n\n    /**\n     * Sender repays a borrow belonging to borrower\n     * @param borrower the account with the debt being payed off\n     * @param repayAmount The amount to repay\n     */\n    function repayBorrowBehalf(address borrower, uint repayAmount) external override nonReentrant {\n        accrueInterest();\n        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\n        repayBorrowFresh(msg.sender, borrower, repayAmount, false);\n    }\n\n    function repayBorrowEndByOpenLev(address borrower, uint repayAmount) external override nonReentrant {\n        accrueInterest();\n        repayBorrowFresh(msg.sender, borrower, repayAmount, true);\n    }\n\n\n\n    /*** Safe Token ***/\n\n    /**\n     * Gets balance of this contract in terms of the underlying\n     * @dev This excludes the value of the current message, if any\n     * @return The quantity of underlying tokens owned by this contract\n     */\n    function getCashPrior() internal view returns (uint) {\n        IERC20 token = IERC20(underlying);\n        return token.balanceOf(address(this));\n    }\n\n    /**\n     * @dev Similar to EIP20 transfer, except it handles a False result from `transferFrom` and reverts in that case.\n     *      This will revert due to insufficient balance or insufficient allowance.\n     *      This function returns the actual amount received,\n     *      which may be less than `amount` if there is a fee attached to the transfer.\n     *\n     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.\n     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\n     */\n    function doTransferIn(address from, uint amount, bool convertWeth) internal returns (uint) {\n        uint balanceBefore = IERC20(underlying).balanceOf(address(this));\n        if (isWethPool && convertWeth) {\n            IWETH(underlying).deposit{value : msg.value}();\n        } else {\n            IERC20(underlying).transferFrom(from, address(this), amount);\n        }\n        // Calculate the amount that was *actually* transferred\n        uint balanceAfter = IERC20(underlying).balanceOf(address(this));\n        require(balanceAfter >= balanceBefore, \"transfer overflow\");\n        return balanceAfter - balanceBefore;\n    }\n\n    /**\n     * @dev Similar to EIP20 transfer, except it handles a False success from `transfer` and returns an explanatory\n     *      error code rather than reverting. If caller has not called checked protocol's balance, this may revert due to\n     *      insufficient cash held in this contract. If caller has checked protocol's balance prior to this call, and verified\n     *      it is >= amount, this should not revert in normal conditions.\n     *\n     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.\n     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\n     */\n    function doTransferOut(address payable to, uint amount, bool convertWeth) internal {\n        if (isWethPool && convertWeth) {\n            IWETH(underlying).withdraw(amount);\n            to.transfer(amount);\n        } else {\n            IERC20(underlying).safeTransfer(to, amount);\n        }\n    }\n\n    function availableForBorrow() external view override returns (uint){\n        uint cash = getCashPrior();\n        (MathError err0, uint sum) = addThenSubUInt(cash, totalBorrows, totalReserves);\n        if (err0 != MathError.NO_ERROR) {\n            return 0;\n        }\n        (MathError err1, uint maxAvailable) = mulScalarTruncate(Exp({mantissa : sum}), borrowCapFactorMantissa);\n        if (err1 != MathError.NO_ERROR) {\n            return 0;\n        }\n        if (totalBorrows > maxAvailable) {\n            return 0;\n        }\n        return maxAvailable - totalBorrows;\n    }\n\n\n    /**\n     * Get a snapshot of the account's balances, and the cached exchange rate\n     * @dev This is used by controller to more efficiently perform liquidity checks.\n     * @param account Address of the account to snapshot\n     * @return ( token balance, borrow balance, exchange rate mantissa)\n     */\n    function getAccountSnapshot(address account) external override view returns (uint, uint, uint) {\n        uint cTokenBalance = accountTokens[account];\n        uint borrowBalance;\n        uint exchangeRateMantissa;\n\n        MathError mErr;\n\n        (mErr, borrowBalance) = borrowBalanceStoredInternal(account);\n        if (mErr != MathError.NO_ERROR) {\n            return (0, 0, 0);\n        }\n\n        (mErr, exchangeRateMantissa) = exchangeRateStoredInternal();\n        if (mErr != MathError.NO_ERROR) {\n            return (0, 0, 0);\n        }\n\n        return (cTokenBalance, borrowBalance, exchangeRateMantissa);\n    }\n\n    /**\n     * @dev Function to simply retrieve block number\n     *  This exists mainly for inheriting test contracts to stub this result.\n     */\n    function getBlockNumber() internal view returns (uint) {\n        return block.number;\n    }\n\n    /**\n     * Returns the current per-block borrow interest rate for this cToken\n     * @return The borrow interest rate per block, scaled by 1e18\n     */\n    function borrowRatePerBlock() external override view returns (uint) {\n        return getBorrowRateInternal(getCashPrior(), totalBorrows, totalReserves);\n    }\n\n    /**\n     * Returns the current per-block supply interest rate for this cToken\n     * @return The supply interest rate per block, scaled by 1e18\n     */\n    function supplyRatePerBlock() external override view returns (uint) {\n        return getSupplyRateInternal(getCashPrior(), totalBorrows, totalReserves, reserveFactorMantissa);\n    }\n\n    function utilizationRate(uint cash, uint borrows, uint reserves) internal pure returns (uint) {\n        // Utilization rate is 0 when there are no borrows\n        if (borrows == 0) {\n            return 0;\n        }\n        return borrows.mul(1e18).div(cash.add(borrows).sub(reserves));\n    }\n\n    /**\n     * Calculates the current borrow rate per block, with the error code expected by the market\n     * @param cash The amount of cash in the market\n     * @param borrows The amount of borrows in the market\n     * @return The borrow rate percentage per block as a mantissa (scaled by 1e18)\n     */\n    function getBorrowRateInternal(uint cash, uint borrows, uint reserves) internal view returns (uint) {\n        uint util = utilizationRate(cash, borrows, reserves);\n        if (util <= kink) {\n            return util.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);\n        } else {\n            uint normalRate = kink.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);\n            uint excessUtil = util.sub(kink);\n            return excessUtil.mul(jumpMultiplierPerBlock).div(1e18).add(normalRate);\n        }\n    }\n\n    /**\n     * Calculates the current supply rate per block\n     * @param cash The amount of cash in the market\n     * @param borrows The amount of borrows in the market\n     * @return The supply rate percentage per block as a mantissa (scaled by 1e18)\n     */\n    function getSupplyRateInternal(uint cash, uint borrows, uint reserves, uint reserveFactor) internal view returns (uint) {\n        uint oneMinusReserveFactor = uint(1e18).sub(reserveFactor);\n        uint borrowRate = getBorrowRateInternal(cash, borrows, reserves);\n        uint rateToPool = borrowRate.mul(oneMinusReserveFactor).div(1e18);\n        return utilizationRate(cash, borrows, reserves).mul(rateToPool).div(1e18);\n    }\n    /**\n     * Returns the current total borrows plus accrued interest\n     * @return The total borrows with interest\n     */\n    function totalBorrowsCurrent() external override view returns (uint) {\n        /* Remember the initial block number */\n        uint currentBlockNumber = getBlockNumber();\n        uint accrualBlockNumberPrior = accrualBlockNumber;\n\n        /* Short-circuit accumulating 0 interest */\n        if (accrualBlockNumberPrior == currentBlockNumber) {\n            return totalBorrows;\n        }\n\n        /* Read the previous values out of storage */\n        uint cashPrior = getCashPrior();\n        uint borrowsPrior = totalBorrows;\n        uint reservesPrior = totalReserves;\n\n        /* Calculate the current borrow interest rate */\n        uint borrowRateMantissa = getBorrowRateInternal(cashPrior, borrowsPrior, reservesPrior);\n        require(borrowRateMantissa <= borrowRateMaxMantissa, \"borrower rate higher\");\n\n        /* Calculate the number of blocks elapsed since the last accrual */\n        (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);\n        require(mathErr == MathError.NO_ERROR, \"calc block delta erro\");\n\n        Exp memory simpleInterestFactor;\n        uint interestAccumulated;\n        uint totalBorrowsNew;\n\n        (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);\n        require(mathErr == MathError.NO_ERROR, 'calc interest factor error');\n\n        (mathErr, interestAccumulated) = mulScalarTruncate(simpleInterestFactor, borrowsPrior);\n        require(mathErr == MathError.NO_ERROR, 'calc interest acc error');\n\n        (mathErr, totalBorrowsNew) = addUInt(interestAccumulated, borrowsPrior);\n        require(mathErr == MathError.NO_ERROR, 'calc total borrows error');\n\n        return totalBorrowsNew;\n    }\n    /**\n     * Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex\n     * @param account The address whose balance should be calculated after updating borrowIndex\n     * @return The calculated balance\n     */\n    function borrowBalanceCurrent(address account) external view override returns (uint) {\n        (MathError err0, uint borrowIndex) = calCurrentBorrowIndex();\n        require(err0 == MathError.NO_ERROR, \"calc borrow index fail\");\n        (MathError err1, uint result) = borrowBalanceStoredInternalWithBorrowerIndex(account, borrowIndex);\n        require(err1 == MathError.NO_ERROR, \"calc fail\");\n        return result;\n    }\n\n    function borrowBalanceStored(address account) external override view returns (uint){\n        return accountBorrows[account].principal;\n    }\n\n\n    /**\n     * Return the borrow balance of account based on stored data\n     * @param account The address whose balance should be calculated\n     * @return (error code, the calculated balance or 0 if error code is non-zero)\n     */\n    function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {\n        return borrowBalanceStoredInternalWithBorrowerIndex(account, borrowIndex);\n    }\n    /**\n     * Return the borrow balance of account based on stored data\n     * @param account The address whose balance should be calculated\n     * @return (error code, the calculated balance or 0 if error code is non-zero)\n     */\n    function borrowBalanceStoredInternalWithBorrowerIndex(address account, uint borrowIndex) internal view returns (MathError, uint) {\n        /* Note: we do not assert that the market is up to date */\n        MathError mathErr;\n        uint principalTimesIndex;\n        uint result;\n\n        /* Get borrowBalance and borrowIndex */\n        BorrowSnapshot storage borrowSnapshot = accountBorrows[account];\n\n        /* If borrowBalance = 0 then borrowIndex is likely also 0.\n         * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.\n         */\n        if (borrowSnapshot.principal == 0) {\n            return (MathError.NO_ERROR, 0);\n        }\n\n        /* Calculate new borrow balance using the interest index:\n         *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex\n         */\n        (mathErr, principalTimesIndex) = mulUInt(borrowSnapshot.principal, borrowIndex);\n        if (mathErr != MathError.NO_ERROR) {\n            return (mathErr, 0);\n        }\n\n        (mathErr, result) = divUInt(principalTimesIndex, borrowSnapshot.interestIndex);\n        if (mathErr != MathError.NO_ERROR) {\n            return (mathErr, 0);\n        }\n\n        return (MathError.NO_ERROR, result);\n    }\n    /**\n     * Accrue interest then return the up-to-date exchange rate\n     * @return Calculated exchange rate scaled by 1e18\n     */\n    function exchangeRateCurrent() public override nonReentrant returns (uint) {\n        accrueInterest();\n        return exchangeRateStored();\n    }\n\n    /**\n     * Calculates the exchange rate from the underlying to the LToken\n     * @dev This function does not accrue interest before calculating the exchange rate\n     * @return Calculated exchange rate scaled by 1e18\n     */\n    function exchangeRateStored() public override view returns (uint) {\n        (MathError err, uint result) = exchangeRateStoredInternal();\n        require(err == MathError.NO_ERROR, \"calc fail\");\n        return result;\n    }\n\n    /**\n     * Calculates the exchange rate from the underlying to the LToken\n     * @dev This function does not accrue interest before calculating the exchange rate\n     * @return (error code, calculated exchange rate scaled by 1e18)\n     */\n    function exchangeRateStoredInternal() internal view returns (MathError, uint) {\n        uint _totalSupply = totalSupply;\n        if (_totalSupply == 0) {\n            /*\n             * If there are no tokens minted:\n             *  exchangeRate = initialExchangeRate\n             */\n            return (MathError.NO_ERROR, initialExchangeRateMantissa);\n        } else {\n            /*\n             * Otherwise:\n             *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply\n             */\n            uint totalCash = getCashPrior();\n            uint cashPlusBorrowsMinusReserves;\n            Exp memory exchangeRate;\n            MathError mathErr;\n\n            (mathErr, cashPlusBorrowsMinusReserves) = addThenSubUInt(totalCash, totalBorrows, totalReserves);\n            if (mathErr != MathError.NO_ERROR) {\n                return (mathErr, 0);\n            }\n\n            (mathErr, exchangeRate) = getExp(cashPlusBorrowsMinusReserves, _totalSupply);\n            if (mathErr != MathError.NO_ERROR) {\n                return (mathErr, 0);\n            }\n\n            return (MathError.NO_ERROR, exchangeRate.mantissa);\n        }\n    }\n\n    /**\n     * Get cash balance of this cToken in the underlying asset\n     * @return The quantity of underlying asset owned by this contract\n     */\n    function getCash() external override view returns (uint) {\n        return getCashPrior();\n    }\n\n    function calCurrentBorrowIndex() internal view returns (MathError, uint) {\n        /* Remember the initial block number */\n        uint currentBlockNumber = getBlockNumber();\n        uint accrualBlockNumberPrior = accrualBlockNumber;\n        uint borrowIndexNew;\n        /* Short-circuit accumulating 0 interest */\n        if (accrualBlockNumberPrior == currentBlockNumber) {\n            return (MathError.NO_ERROR, borrowIndex);\n        }\n        uint borrowRateMantissa = getBorrowRateInternal(getCashPrior(), totalBorrows, totalReserves);\n        (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);\n\n        Exp memory simpleInterestFactor;\n        (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);\n        if (mathErr != MathError.NO_ERROR) {\n            return (mathErr, 0);\n        }\n        (mathErr, borrowIndexNew) = mulScalarTruncateAddUInt(simpleInterestFactor, borrowIndex, borrowIndex);\n        return (mathErr, borrowIndexNew);\n    }\n\n    /**\n     * Applies accrued interest to total borrows and reserves\n     * @dev This calculates interest accrued from the last checkpointed block\n     *   up to the current block and writes new checkpoint to storage.\n     */\n    function accrueInterest() public override {\n        /* Remember the initial block number */\n        uint currentBlockNumber = getBlockNumber();\n        uint accrualBlockNumberPrior = accrualBlockNumber;\n\n        /* Short-circuit accumulating 0 interest */\n        if (accrualBlockNumberPrior == currentBlockNumber) {\n            return;\n        }\n\n        /* Read the previous values out of storage */\n        uint cashPrior = getCashPrior();\n        uint borrowsPrior = totalBorrows;\n        uint borrowIndexPrior = borrowIndex;\n        uint reservesPrior = totalReserves;\n\n        /* Calculate the current borrow interest rate */\n        uint borrowRateMantissa = getBorrowRateInternal(cashPrior, borrowsPrior, reservesPrior);\n        require(borrowRateMantissa <= borrowRateMaxMantissa, \"borrower rate higher\");\n\n        /* Calculate the number of blocks elapsed since the last accrual */\n        (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);\n        require(mathErr == MathError.NO_ERROR, \"calc block delta erro\");\n\n\n        /*\n         * Calculate the interest accumulated into borrows and reserves and the new index:\n         *  simpleInterestFactor = borrowRate * blockDelta\n         *  interestAccumulated = simpleInterestFactor * totalBorrows\n         *  totalBorrowsNew = interestAccumulated + totalBorrows\n         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex\n         */\n\n        Exp memory simpleInterestFactor;\n        uint interestAccumulated;\n        uint totalBorrowsNew;\n        uint borrowIndexNew;\n        uint totalReservesNew;\n\n        (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);\n        require(mathErr == MathError.NO_ERROR, 'calc interest factor error');\n\n        (mathErr, interestAccumulated) = mulScalarTruncate(simpleInterestFactor, borrowsPrior);\n        require(mathErr == MathError.NO_ERROR, 'calc interest acc error');\n\n        (mathErr, totalBorrowsNew) = addUInt(interestAccumulated, borrowsPrior);\n        require(mathErr == MathError.NO_ERROR, 'calc total borrows error');\n\n        (mathErr, totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa : reserveFactorMantissa}), interestAccumulated, reservesPrior);\n        require(mathErr == MathError.NO_ERROR, 'calc total reserves error');\n\n        (mathErr, borrowIndexNew) = mulScalarTruncateAddUInt(simpleInterestFactor, borrowIndexPrior, borrowIndexPrior);\n        require(mathErr == MathError.NO_ERROR, 'calc borrows index error');\n\n\n        /* We write the previously calculated values into storage */\n        accrualBlockNumber = currentBlockNumber;\n        borrowIndex = borrowIndexNew;\n        totalBorrows = totalBorrowsNew;\n        totalReserves = totalReservesNew;\n\n        /* We emit an AccrueInterest event */\n        emit AccrueInterest(cashPrior, interestAccumulated, borrowIndexNew, totalBorrowsNew);\n\n    }\n\n    struct MintLocalVars {\n        MathError mathErr;\n        uint exchangeRateMantissa;\n        uint mintTokens;\n        uint totalSupplyNew;\n        uint accountTokensNew;\n        uint actualMintAmount;\n    }\n\n    /**\n     * User supplies assets into the market and receives lTokens in exchange\n     * @dev Assumes interest has already been accrued up to the current block\n     * @param minter The address of the account which is supplying the assets\n     * @param mintAmount The amount of the underlying asset to supply\n     * @return uint the actual mint amount.\n     */\n    function mintFresh(address minter, uint mintAmount) internal sameBlock returns (uint) {\n        MintLocalVars memory vars;\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n        require(vars.mathErr == MathError.NO_ERROR, 'calc exchangerate error');\n\n        /*\n         *  We call `doTransferIn` for the minter and the mintAmount.\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n         *  `doTransferIn` reverts if anything goes wrong, since we can't be sure if\n         *  side-effects occurred. The function returns the amount actually transferred,\n         *  in case of a fee. On success, the cToken holds an additional `actualMintAmount`\n         *  of cash.\n         */\n        vars.actualMintAmount = doTransferIn(minter, mintAmount, true);\n\n        /*\n         * We get the current exchange rate and calculate the number of lTokens to be minted:\n         *  mintTokens = actualMintAmount / exchangeRate\n         */\n\n        (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(vars.actualMintAmount, Exp({mantissa : vars.exchangeRateMantissa}));\n        require(vars.mathErr == MathError.NO_ERROR, \"calc mint token error\");\n\n        /* Fail if mint not allowed */\n        (ControllerInterface(controller)).mintAllowed(address(this), minter, vars.mintTokens);\n        /*\n         * We calculate the new total supply of lTokens and minter token balance, checking for overflow:\n         *  totalSupplyNew = totalSupply + mintTokens\n         *  accountTokensNew = accountTokens[minter] + mintTokens\n         */\n        (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);\n        require(vars.mathErr == MathError.NO_ERROR, \"calc supply new failed\");\n\n        (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);\n        require(vars.mathErr == MathError.NO_ERROR, \"calc tokens new ailed\");\n\n        /* We write previously calculated values into storage */\n        totalSupply = vars.totalSupplyNew;\n        accountTokens[minter] = vars.accountTokensNew;\n\n        /* We emit a Mint event, and a Transfer event */\n        emit Mint(minter, vars.actualMintAmount, vars.mintTokens);\n        emit Transfer(address(this), minter, vars.mintTokens);\n\n        /* We call the defense hook */\n\n        return vars.actualMintAmount;\n    }\n\n\n    struct RedeemLocalVars {\n        MathError mathErr;\n        uint exchangeRateMantissa;\n        uint redeemTokens;\n        uint redeemAmount;\n        uint totalSupplyNew;\n        uint accountTokensNew;\n    }\n\n    /**\n     * User redeems lTokens in exchange for the underlying asset\n     * @dev Assumes interest has already been accrued up to the current block\n     * @param redeemer The address of the account which is redeeming the tokens\n     * @param redeemTokensIn The number of lTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be non-zero)\n     * @param redeemAmountIn The number of underlying tokens to receive from redeeming lTokens (only one of redeemTokensIn or redeemAmountIn may be non-zero)\n     */\n    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal sameBlock {\n        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one be zero\");\n\n        RedeemLocalVars memory vars;\n\n        /* exchangeRate = invoke Exchange Rate Stored() */\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n        require(vars.mathErr == MathError.NO_ERROR, 'calc exchangerate error');\n\n        /* If redeemTokensIn > 0: */\n        if (redeemTokensIn > 0) {\n            /*\n             * We calculate the exchange rate and the amount of underlying to be redeemed:\n             *  redeemTokens = redeemTokensIn\n             *  redeemAmount = redeemTokensIn x exchangeRateCurrent\n             */\n            vars.redeemTokens = redeemTokensIn;\n\n            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa : vars.exchangeRateMantissa}), redeemTokensIn);\n            require(vars.mathErr == MathError.NO_ERROR, 'calc redeem amount error');\n        } else {\n            /*\n             * We get the current exchange rate and calculate the amount to be redeemed:\n             *  redeemTokens = redeemAmountIn / exchangeRate\n             *  redeemAmount = redeemAmountIn\n             */\n\n            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa : vars.exchangeRateMantissa}));\n            require(vars.mathErr == MathError.NO_ERROR, 'calc redeem tokens error');\n            vars.redeemAmount = redeemAmountIn;\n        }\n\n        /* Fail if redeem not allowed */\n        (ControllerInterface(controller)).redeemAllowed(address(this), redeemer, vars.redeemTokens);\n\n        /*\n         * We calculate the new total supply and redeemer balance, checking for underflow:\n         *  totalSupplyNew = totalSupply - redeemTokens\n         *  accountTokensNew = accountTokens[redeemer] - redeemTokens\n         */\n        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);\n        require(vars.mathErr == MathError.NO_ERROR, 'calc supply new error');\n\n        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);\n        require(vars.mathErr == MathError.NO_ERROR, 'calc token new error');\n        require(getCashPrior() >= vars.redeemAmount, 'cash < redeem');\n\n        /*\n         * We invoke doTransferOut for the redeemer and the redeemAmount.\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n         *  On success, the cToken has redeemAmount less of cash.\n         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n         */\n        doTransferOut(redeemer, vars.redeemAmount, true);\n        /* We write previously calculated values into storage */\n        totalSupply = vars.totalSupplyNew;\n        accountTokens[redeemer] = vars.accountTokensNew;\n\n        /* We emit a Transfer event, and a Redeem event */\n        emit Transfer(redeemer, address(this), vars.redeemTokens);\n        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);\n\n        /* We call the defense hook */\n    }\n\n    struct BorrowLocalVars {\n        MathError mathErr;\n        uint accountBorrows;\n        uint accountBorrowsNew;\n        uint totalBorrowsNew;\n    }\n\n    /**\n      * Users borrow assets from the protocol to their own address\n      * @param borrowAmount The amount of the underlying asset to borrow\n      */\n    //SWC-107-Reentrancy: L845-L885\n    function borrowFresh(address payable borrower, address payable payee, uint borrowAmount) internal sameBlock {\n        /* Fail if borrow not allowed */\n        (ControllerInterface(controller)).borrowAllowed(address(this), borrower, payee, borrowAmount);\n\n        /* Fail gracefully if protocol has insufficient underlying cash */\n        require(getCashPrior() >= borrowAmount, 'cash<borrow');\n\n        BorrowLocalVars memory vars;\n\n        /*\n         * We calculate the new borrower and total borrow balances, failing on overflow:\n         *  accountBorrowsNew = accountBorrows + borrowAmount\n         *  totalBorrowsNew = totalBorrows + borrowAmount\n         */\n        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);\n        require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrows error');\n\n        (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);\n        require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrows error');\n\n        (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);\n        require(vars.mathErr == MathError.NO_ERROR, 'calc total borrows error');\n\n        /*\n         * We invoke doTransferOut for the borrower and the borrowAmount.\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n         *  On success, the cToken borrowAmount less of cash.\n         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n         */\n        doTransferOut(payee, borrowAmount, false);\n\n        /* We write the previously calculated values into storage */\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\n        accountBorrows[borrower].interestIndex = borrowIndex;\n        totalBorrows = vars.totalBorrowsNew;\n\n        /* We emit a Borrow event */\n        emit Borrow(borrower, payee, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\n\n        /* We call the defense hook */\n    }\n\n    struct RepayBorrowLocalVars {\n        MathError mathErr;\n        uint repayAmount;\n        uint borrowerIndex;\n        uint accountBorrows;\n        uint accountBorrowsNew;\n        uint totalBorrowsNew;\n        uint actualRepayAmount;\n    }\n\n    /**\n     * Borrows are repaid by another user (possibly the borrower).\n     * @param payer the account paying off the borrow\n     * @param borrower the account with the debt being payed off\n     * @param repayAmount the amount of undelrying tokens being returned\n     */\n    function repayBorrowFresh(address payer, address borrower, uint repayAmount, bool isEnd) internal sameBlock returns (uint) {\n        /* Fail if repayBorrow not allowed */\n        (ControllerInterface(controller)).repayBorrowAllowed(address(this), payer, borrower, repayAmount, isEnd);\n\n        RepayBorrowLocalVars memory vars;\n\n        /* We remember the original borrowerIndex for verification purposes */\n        vars.borrowerIndex = accountBorrows[borrower].interestIndex;\n\n        /* We fetch the amount the borrower owes, with accumulated interest */\n        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);\n        require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrow error');\n\n        /* If repayAmount == -1, repayAmount = accountBorrows */\n        if (repayAmount == uint(- 1)) {\n            vars.repayAmount = vars.accountBorrows;\n        } else {\n            vars.repayAmount = repayAmount;\n        }\n\n        /*\n         * We call doTransferIn for the payer and the repayAmount\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n         *  On success, the cToken holds an additional repayAmount of cash.\n         *  doTransferIn reverts if anything goes wrong, since we can't be sure if side effects occurred.\n         *   it returns the amount actually transferred, in case of a fee.\n         */\n        vars.actualRepayAmount = doTransferIn(payer, vars.repayAmount, false);\n\n        if (isEnd) {\n            vars.actualRepayAmount = vars.accountBorrows;\n        }\n        /*\n         * We calculate the new borrower and total borrow balances, failing on underflow:\n         *  accountBorrowsNew = accountBorrows - actualRepayAmount\n         *  totalBorrowsNew = totalBorrows - actualRepayAmount\n         */\n        (vars.mathErr, vars.accountBorrowsNew) = subUInt(vars.accountBorrows, vars.actualRepayAmount);\n\n        require(vars.mathErr == MathError.NO_ERROR, \"calc acc borrows error\");\n        //Avoid mantissa errors\n        if (vars.actualRepayAmount > totalBorrows) {\n            vars.totalBorrowsNew = 0;\n        } else {\n            vars.totalBorrowsNew = totalBorrows - vars.actualRepayAmount;\n        }\n\n        /* We write the previously calculated values into storage */\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\n        accountBorrows[borrower].interestIndex = borrowIndex;\n        totalBorrows = vars.totalBorrowsNew;\n\n        /* We emit a RepayBorrow event */\n        emit RepayBorrow(payer, borrower, vars.actualRepayAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\n\n        /* We call the defense hook */\n\n        return vars.actualRepayAmount;\n    }\n\n    /*** Admin Functions ***/\n\n    /**\n      * Sets a new CONTROLLER for the market\n      * @dev Admin function to set a new controller\n      */\n    function setController(address newController) external override onlyAdmin {\n        address oldController = controller;\n\n        controller = newController;\n        // Emit NewController(oldController, newController)\n        emit NewController(oldController, newController);\n    }\n\n    function setBorrowCapFactorMantissa(uint newBorrowCapFactorMantissa) external override onlyAdmin {\n        borrowCapFactorMantissa = newBorrowCapFactorMantissa;\n    }\n\n    function setInterestParams(uint baseRatePerBlock_, uint multiplierPerBlock_, uint jumpMultiplierPerBlock_, uint kink_) external override onlyAdmin {\n        //accrueInterest except first\n        if (baseRatePerBlock != 0) {\n            accrueInterest();\n        }\n        baseRatePerBlock = baseRatePerBlock_;\n        multiplierPerBlock = multiplierPerBlock_;\n        jumpMultiplierPerBlock = jumpMultiplierPerBlock_;\n        kink = kink_;\n        emit NewInterestParam(baseRatePerBlock_, multiplierPerBlock_, jumpMultiplierPerBlock_, kink_);\n    }\n\n    function setReserveFactor(uint newReserveFactorMantissa) external override onlyAdmin {\n        accrueInterest();\n        uint oldReserveFactorMantissa = reserveFactorMantissa;\n        reserveFactorMantissa = newReserveFactorMantissa;\n        emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);\n    }\n\n    function addReserves(uint addAmount) external override {\n        accrueInterest();\n        uint totalReservesNew;\n        uint actualAddAmount;\n        actualAddAmount = doTransferIn(msg.sender, addAmount, true);\n        totalReservesNew = totalReserves.add(actualAddAmount);\n        totalReserves = totalReservesNew;\n        emit ReservesAdded(msg.sender, actualAddAmount, totalReservesNew);\n    }\n\n    function reduceReserves(address payable to, uint reduceAmount) external override onlyAdmin {\n        accrueInterest();\n        uint totalReservesNew;\n        totalReservesNew = totalReserves.sub(reduceAmount);\n        totalReserves = totalReservesNew;\n        doTransferOut(to, reduceAmount, true);\n        emit ReservesReduced(to, reduceAmount, totalReservesNew);\n    }\n\n    modifier sameBlock() {\n        require(accrualBlockNumber == getBlockNumber(), 'not same block');\n        _;\n    }\n\n}",
        "function": "totalBorrowsCurrent()",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/PeckShield-OpenLeverage1.0/openleverage-contracts-e31d971bcb38ec8737cf1942b8fdf6a9452e5834/contracts/liquidity/LPool.sol",
        "vulnerability": "Dependence on predictable environment variable (SWC 120)",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract LPool is DelegateInterface, Adminable, LPoolInterface, Exponential, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint;\n\n    constructor() {\n\n    }\n    /**\n     * Initialize the money market\n     * @param controller_ The address of the Controller\n     * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18\n     * @param name_ EIP-20 name of this token\n     * @param symbol_ EIP-20 symbol of this token\n     * @param decimals_ EIP-20 decimal precision of this token\n     */\n    function initialize(\n        address underlying_,\n        bool isWethPool_,\n        address controller_,\n        uint256 baseRatePerBlock_,\n        uint256 multiplierPerBlock_,\n        uint256 jumpMultiplierPerBlock_,\n        uint256 kink_,\n        uint initialExchangeRateMantissa_,\n        string memory name_,\n        string memory symbol_,\n        uint8 decimals_) public {\n        require(underlying_ != address(0), \"underlying_ address cannot be 0\");\n        require(controller_ != address(0), \"controller_ address cannot be 0\");\n        require(msg.sender == admin, \"Only allow to be called by admin\");\n        require(accrualBlockNumber == 0 && borrowIndex == 0, \"inited once\");\n\n        // Set initial exchange rate\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\n        require(initialExchangeRateMantissa > 0, \"Initial Exchange Rate Mantissa should be greater zero\");\n        //set controller\n        controller = controller_;\n        isWethPool = isWethPool_;\n        //set interestRateModel\n        baseRatePerBlock = baseRatePerBlock_;\n        multiplierPerBlock = multiplierPerBlock_;\n        jumpMultiplierPerBlock = jumpMultiplierPerBlock_;\n        kink = kink_;\n\n        // Initialize block number and borrow index (block number mocks depend on controller being set)\n        accrualBlockNumber = getBlockNumber();\n        borrowIndex = 1e25;\n        //80%\n        borrowCapFactorMantissa = 0.8e18;\n        //20%\n        reserveFactorMantissa = 0.2e18;\n\n\n        name = name_;\n        symbol = symbol_;\n        decimals = decimals_;\n\n        _notEntered = true;\n\n        // Set underlying and sanity check it\n        underlying = underlying_;\n        IERC20(underlying).totalSupply();\n    }\n\n    /**\n     * Transfer `tokens` tokens from `src` to `dst` by `spender`\n     * @dev Called by both `transfer` and `transferFrom` internally\n     * @param spender The address of the account performing the transfer\n     * @param src The address of the source account\n     * @param dst The address of the destination account\n     * @param tokens The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     */\n    function transferTokens(address spender, address src, address dst, uint tokens) internal returns (bool) {\n        require(dst != address(0), \"dst address cannot be 0\");\n        /* Do not allow self-transfers */\n        require(src != dst, \"src = dst\");\n        /* Fail if transfer not allowed */\n        (ControllerInterface(controller)).transferAllowed(address(this), src, dst, tokens);\n\n        /* Get the allowance, infinite for the account owner */\n        uint startingAllowance = 0;\n        if (spender == src) {\n            startingAllowance = uint(- 1);\n        } else {\n            startingAllowance = transferAllowances[src][spender];\n        }\n\n        /* Do the calculations, checking for {under,over}flow */\n        MathError mathErr;\n        uint allowanceNew;\n        uint srcTokensNew;\n        uint dstTokensNew;\n\n        (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);\n        require(mathErr == MathError.NO_ERROR, 'not allowed');\n\n        (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);\n        require(mathErr == MathError.NO_ERROR, 'not enough');\n\n        (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);\n        require(mathErr == MathError.NO_ERROR, 'too much');\n\n        accountTokens[src] = srcTokensNew;\n        accountTokens[dst] = dstTokensNew;\n\n        /* Eat some of the allowance (if necessary) */\n        if (startingAllowance != uint(- 1)) {\n            transferAllowances[src][spender] = allowanceNew;\n        }\n        /* We emit a Transfer event */\n        emit Transfer(src, dst, tokens);\n        return true;\n    }\n\n    /**\n     * Transfer `amount` tokens from `msg.sender` to `dst`\n     * @param dst The address of the destination account\n     * @param amount The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     */\n    function transfer(address dst, uint256 amount) external override nonReentrant returns (bool) {\n        return transferTokens(msg.sender, msg.sender, dst, amount);\n    }\n\n    /**\n     * Transfer `amount` tokens from `src` to `dst`\n     * @param src The address of the source account\n     * @param dst The address of the destination account\n     * @param amount The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     */\n    function transferFrom(address src, address dst, uint256 amount) external override nonReentrant returns (bool) {\n        return transferTokens(msg.sender, src, dst, amount);\n    }\n\n    /**\n     * Approve `spender` to transfer up to `amount` from `src`\n     * @dev This will overwrite the approval amount for `spender`\n     *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n     * @param spender The address of the account which may transfer tokens\n     * @param amount The number of tokens that are approved (-1 means infinite)\n     * @return Whether or not the approval succeeded\n     */\n    function approve(address spender, uint256 amount) external override returns (bool) {\n        address src = msg.sender;\n        transferAllowances[src][spender] = amount;\n        emit Approval(src, spender, amount);\n        return true;\n    }\n\n    /**\n     * Get the current allowance from `owner` for `spender`\n     * @param owner The address of the account which owns the tokens to be spent\n     * @param spender The address of the account which may transfer tokens\n     * @return The number of tokens allowed to be spent (-1 means infinite)\n     */\n    function allowance(address owner, address spender) external override view returns (uint256) {\n        return transferAllowances[owner][spender];\n    }\n\n    /**\n     * Get the token balance of the `owner`\n     * @param owner The address of the account to query\n     * @return The number of tokens owned by `owner`\n     */\n    function balanceOf(address owner) external override view returns (uint256) {\n        return accountTokens[owner];\n    }\n\n    /**\n     * Get the underlying balance of the `owner`\n     * @dev This also accrues interest in a transaction\n     * @param owner The address of the account to query\n     * @return The amount of underlying owned by `owner`\n     */\n    function balanceOfUnderlying(address owner) external override returns (uint) {\n        Exp memory exchangeRate = Exp({mantissa : exchangeRateCurrent()});\n        (MathError mErr, uint balance) = mulScalarTruncate(exchangeRate, accountTokens[owner]);\n        require(mErr == MathError.NO_ERROR, \"calc failed\");\n        return balance;\n    }\n\n    /*** User Interface ***/\n\n    /**\n     * Sender supplies assets into the market and receives lTokens in exchange\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param mintAmount The amount of the underlying asset to supply\n     */\n    function mint(uint mintAmount) external override nonReentrant {\n        accrueInterest();\n        // mintFresh emits the actual Mint event if successful and logs on errors, so we don't need to\n        mintFresh(msg.sender, mintAmount);\n    }\n\n    function mintEth() external payable override nonReentrant {\n        require(isWethPool, \"not eth pool\");\n        accrueInterest();\n        mintFresh(msg.sender, msg.value);\n    }\n\n    /**\n     * Sender redeems lTokens in exchange for the underlying asset\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param redeemTokens The number of lTokens to redeem into underlying\n     */\n    function redeem(uint redeemTokens) external override nonReentrant {\n        accrueInterest();\n        // redeemFresh emits redeem-specific logs on errors, so we don't need to\n        redeemFresh(msg.sender, redeemTokens, 0);\n    }\n\n    /**\n     * Sender redeems lTokens in exchange for a specified amount of underlying asset\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param redeemAmount The amount of underlying to redeem\n     */\n    function redeemUnderlying(uint redeemAmount) external override nonReentrant {\n        accrueInterest();\n        // redeemFresh emits redeem-specific logs on errors, so we don't need to\n        redeemFresh(msg.sender, 0, redeemAmount);\n    }\n\n    function borrowBehalf(address borrower, uint borrowAmount) external override nonReentrant {\n        accrueInterest();\n        // borrowFresh emits borrow-specific logs on errors, so we don't need to\n        borrowFresh(payable(borrower), msg.sender, borrowAmount);\n    }\n\n    /**\n     * Sender repays a borrow belonging to borrower\n     * @param borrower the account with the debt being payed off\n     * @param repayAmount The amount to repay\n     */\n    function repayBorrowBehalf(address borrower, uint repayAmount) external override nonReentrant {\n        accrueInterest();\n        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\n        repayBorrowFresh(msg.sender, borrower, repayAmount, false);\n    }\n\n    function repayBorrowEndByOpenLev(address borrower, uint repayAmount) external override nonReentrant {\n        accrueInterest();\n        repayBorrowFresh(msg.sender, borrower, repayAmount, true);\n    }\n\n\n\n    /*** Safe Token ***/\n\n    /**\n     * Gets balance of this contract in terms of the underlying\n     * @dev This excludes the value of the current message, if any\n     * @return The quantity of underlying tokens owned by this contract\n     */\n    function getCashPrior() internal view returns (uint) {\n        IERC20 token = IERC20(underlying);\n        return token.balanceOf(address(this));\n    }\n\n    /**\n     * @dev Similar to EIP20 transfer, except it handles a False result from `transferFrom` and reverts in that case.\n     *      This will revert due to insufficient balance or insufficient allowance.\n     *      This function returns the actual amount received,\n     *      which may be less than `amount` if there is a fee attached to the transfer.\n     *\n     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.\n     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\n     */\n    function doTransferIn(address from, uint amount, bool convertWeth) internal returns (uint) {\n        uint balanceBefore = IERC20(underlying).balanceOf(address(this));\n        if (isWethPool && convertWeth) {\n            IWETH(underlying).deposit{value : msg.value}();\n        } else {\n            IERC20(underlying).transferFrom(from, address(this), amount);\n        }\n        // Calculate the amount that was *actually* transferred\n        uint balanceAfter = IERC20(underlying).balanceOf(address(this));\n        require(balanceAfter >= balanceBefore, \"transfer overflow\");\n        return balanceAfter - balanceBefore;\n    }\n\n    /**\n     * @dev Similar to EIP20 transfer, except it handles a False success from `transfer` and returns an explanatory\n     *      error code rather than reverting. If caller has not called checked protocol's balance, this may revert due to\n     *      insufficient cash held in this contract. If caller has checked protocol's balance prior to this call, and verified\n     *      it is >= amount, this should not revert in normal conditions.\n     *\n     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.\n     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\n     */\n    function doTransferOut(address payable to, uint amount, bool convertWeth) internal {\n        if (isWethPool && convertWeth) {\n            IWETH(underlying).withdraw(amount);\n            to.transfer(amount);\n        } else {\n            IERC20(underlying).safeTransfer(to, amount);\n        }\n    }\n\n    function availableForBorrow() external view override returns (uint){\n        uint cash = getCashPrior();\n        (MathError err0, uint sum) = addThenSubUInt(cash, totalBorrows, totalReserves);\n        if (err0 != MathError.NO_ERROR) {\n            return 0;\n        }\n        (MathError err1, uint maxAvailable) = mulScalarTruncate(Exp({mantissa : sum}), borrowCapFactorMantissa);\n        if (err1 != MathError.NO_ERROR) {\n            return 0;\n        }\n        if (totalBorrows > maxAvailable) {\n            return 0;\n        }\n        return maxAvailable - totalBorrows;\n    }\n\n\n    /**\n     * Get a snapshot of the account's balances, and the cached exchange rate\n     * @dev This is used by controller to more efficiently perform liquidity checks.\n     * @param account Address of the account to snapshot\n     * @return ( token balance, borrow balance, exchange rate mantissa)\n     */\n    function getAccountSnapshot(address account) external override view returns (uint, uint, uint) {\n        uint cTokenBalance = accountTokens[account];\n        uint borrowBalance;\n        uint exchangeRateMantissa;\n\n        MathError mErr;\n\n        (mErr, borrowBalance) = borrowBalanceStoredInternal(account);\n        if (mErr != MathError.NO_ERROR) {\n            return (0, 0, 0);\n        }\n\n        (mErr, exchangeRateMantissa) = exchangeRateStoredInternal();\n        if (mErr != MathError.NO_ERROR) {\n            return (0, 0, 0);\n        }\n\n        return (cTokenBalance, borrowBalance, exchangeRateMantissa);\n    }\n\n    /**\n     * @dev Function to simply retrieve block number\n     *  This exists mainly for inheriting test contracts to stub this result.\n     */\n    function getBlockNumber() internal view returns (uint) {\n        return block.number;\n    }\n\n    /**\n     * Returns the current per-block borrow interest rate for this cToken\n     * @return The borrow interest rate per block, scaled by 1e18\n     */\n    function borrowRatePerBlock() external override view returns (uint) {\n        return getBorrowRateInternal(getCashPrior(), totalBorrows, totalReserves);\n    }\n\n    /**\n     * Returns the current per-block supply interest rate for this cToken\n     * @return The supply interest rate per block, scaled by 1e18\n     */\n    function supplyRatePerBlock() external override view returns (uint) {\n        return getSupplyRateInternal(getCashPrior(), totalBorrows, totalReserves, reserveFactorMantissa);\n    }\n\n    function utilizationRate(uint cash, uint borrows, uint reserves) internal pure returns (uint) {\n        // Utilization rate is 0 when there are no borrows\n        if (borrows == 0) {\n            return 0;\n        }\n        return borrows.mul(1e18).div(cash.add(borrows).sub(reserves));\n    }\n\n    /**\n     * Calculates the current borrow rate per block, with the error code expected by the market\n     * @param cash The amount of cash in the market\n     * @param borrows The amount of borrows in the market\n     * @return The borrow rate percentage per block as a mantissa (scaled by 1e18)\n     */\n    function getBorrowRateInternal(uint cash, uint borrows, uint reserves) internal view returns (uint) {\n        uint util = utilizationRate(cash, borrows, reserves);\n        if (util <= kink) {\n            return util.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);\n        } else {\n            uint normalRate = kink.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);\n            uint excessUtil = util.sub(kink);\n            return excessUtil.mul(jumpMultiplierPerBlock).div(1e18).add(normalRate);\n        }\n    }\n\n    /**\n     * Calculates the current supply rate per block\n     * @param cash The amount of cash in the market\n     * @param borrows The amount of borrows in the market\n     * @return The supply rate percentage per block as a mantissa (scaled by 1e18)\n     */\n    function getSupplyRateInternal(uint cash, uint borrows, uint reserves, uint reserveFactor) internal view returns (uint) {\n        uint oneMinusReserveFactor = uint(1e18).sub(reserveFactor);\n        uint borrowRate = getBorrowRateInternal(cash, borrows, reserves);\n        uint rateToPool = borrowRate.mul(oneMinusReserveFactor).div(1e18);\n        return utilizationRate(cash, borrows, reserves).mul(rateToPool).div(1e18);\n    }\n    /**\n     * Returns the current total borrows plus accrued interest\n     * @return The total borrows with interest\n     */\n    function totalBorrowsCurrent() external override view returns (uint) {\n        /* Remember the initial block number */\n        uint currentBlockNumber = getBlockNumber();\n        uint accrualBlockNumberPrior = accrualBlockNumber;\n\n        /* Short-circuit accumulating 0 interest */\n        if (accrualBlockNumberPrior == currentBlockNumber) {\n            return totalBorrows;\n        }\n\n        /* Read the previous values out of storage */\n        uint cashPrior = getCashPrior();\n        uint borrowsPrior = totalBorrows;\n        uint reservesPrior = totalReserves;\n\n        /* Calculate the current borrow interest rate */\n        uint borrowRateMantissa = getBorrowRateInternal(cashPrior, borrowsPrior, reservesPrior);\n        require(borrowRateMantissa <= borrowRateMaxMantissa, \"borrower rate higher\");\n\n        /* Calculate the number of blocks elapsed since the last accrual */\n        (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);\n        require(mathErr == MathError.NO_ERROR, \"calc block delta erro\");\n\n        Exp memory simpleInterestFactor;\n        uint interestAccumulated;\n        uint totalBorrowsNew;\n\n        (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);\n        require(mathErr == MathError.NO_ERROR, 'calc interest factor error');\n\n        (mathErr, interestAccumulated) = mulScalarTruncate(simpleInterestFactor, borrowsPrior);\n        require(mathErr == MathError.NO_ERROR, 'calc interest acc error');\n\n        (mathErr, totalBorrowsNew) = addUInt(interestAccumulated, borrowsPrior);\n        require(mathErr == MathError.NO_ERROR, 'calc total borrows error');\n\n        return totalBorrowsNew;\n    }\n    /**\n     * Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex\n     * @param account The address whose balance should be calculated after updating borrowIndex\n     * @return The calculated balance\n     */\n    function borrowBalanceCurrent(address account) external view override returns (uint) {\n        (MathError err0, uint borrowIndex) = calCurrentBorrowIndex();\n        require(err0 == MathError.NO_ERROR, \"calc borrow index fail\");\n        (MathError err1, uint result) = borrowBalanceStoredInternalWithBorrowerIndex(account, borrowIndex);\n        require(err1 == MathError.NO_ERROR, \"calc fail\");\n        return result;\n    }\n\n    function borrowBalanceStored(address account) external override view returns (uint){\n        return accountBorrows[account].principal;\n    }\n\n\n    /**\n     * Return the borrow balance of account based on stored data\n     * @param account The address whose balance should be calculated\n     * @return (error code, the calculated balance or 0 if error code is non-zero)\n     */\n    function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {\n        return borrowBalanceStoredInternalWithBorrowerIndex(account, borrowIndex);\n    }\n    /**\n     * Return the borrow balance of account based on stored data\n     * @param account The address whose balance should be calculated\n     * @return (error code, the calculated balance or 0 if error code is non-zero)\n     */\n    function borrowBalanceStoredInternalWithBorrowerIndex(address account, uint borrowIndex) internal view returns (MathError, uint) {\n        /* Note: we do not assert that the market is up to date */\n        MathError mathErr;\n        uint principalTimesIndex;\n        uint result;\n\n        /* Get borrowBalance and borrowIndex */\n        BorrowSnapshot storage borrowSnapshot = accountBorrows[account];\n\n        /* If borrowBalance = 0 then borrowIndex is likely also 0.\n         * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.\n         */\n        if (borrowSnapshot.principal == 0) {\n            return (MathError.NO_ERROR, 0);\n        }\n\n        /* Calculate new borrow balance using the interest index:\n         *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex\n         */\n        (mathErr, principalTimesIndex) = mulUInt(borrowSnapshot.principal, borrowIndex);\n        if (mathErr != MathError.NO_ERROR) {\n            return (mathErr, 0);\n        }\n\n        (mathErr, result) = divUInt(principalTimesIndex, borrowSnapshot.interestIndex);\n        if (mathErr != MathError.NO_ERROR) {\n            return (mathErr, 0);\n        }\n\n        return (MathError.NO_ERROR, result);\n    }\n    /**\n     * Accrue interest then return the up-to-date exchange rate\n     * @return Calculated exchange rate scaled by 1e18\n     */\n    function exchangeRateCurrent() public override nonReentrant returns (uint) {\n        accrueInterest();\n        return exchangeRateStored();\n    }\n\n    /**\n     * Calculates the exchange rate from the underlying to the LToken\n     * @dev This function does not accrue interest before calculating the exchange rate\n     * @return Calculated exchange rate scaled by 1e18\n     */\n    function exchangeRateStored() public override view returns (uint) {\n        (MathError err, uint result) = exchangeRateStoredInternal();\n        require(err == MathError.NO_ERROR, \"calc fail\");\n        return result;\n    }\n\n    /**\n     * Calculates the exchange rate from the underlying to the LToken\n     * @dev This function does not accrue interest before calculating the exchange rate\n     * @return (error code, calculated exchange rate scaled by 1e18)\n     */\n    function exchangeRateStoredInternal() internal view returns (MathError, uint) {\n        uint _totalSupply = totalSupply;\n        if (_totalSupply == 0) {\n            /*\n             * If there are no tokens minted:\n             *  exchangeRate = initialExchangeRate\n             */\n            return (MathError.NO_ERROR, initialExchangeRateMantissa);\n        } else {\n            /*\n             * Otherwise:\n             *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply\n             */\n            uint totalCash = getCashPrior();\n            uint cashPlusBorrowsMinusReserves;\n            Exp memory exchangeRate;\n            MathError mathErr;\n\n            (mathErr, cashPlusBorrowsMinusReserves) = addThenSubUInt(totalCash, totalBorrows, totalReserves);\n            if (mathErr != MathError.NO_ERROR) {\n                return (mathErr, 0);\n            }\n\n            (mathErr, exchangeRate) = getExp(cashPlusBorrowsMinusReserves, _totalSupply);\n            if (mathErr != MathError.NO_ERROR) {\n                return (mathErr, 0);\n            }\n\n            return (MathError.NO_ERROR, exchangeRate.mantissa);\n        }\n    }\n\n    /**\n     * Get cash balance of this cToken in the underlying asset\n     * @return The quantity of underlying asset owned by this contract\n     */\n    function getCash() external override view returns (uint) {\n        return getCashPrior();\n    }\n\n    function calCurrentBorrowIndex() internal view returns (MathError, uint) {\n        /* Remember the initial block number */\n        uint currentBlockNumber = getBlockNumber();\n        uint accrualBlockNumberPrior = accrualBlockNumber;\n        uint borrowIndexNew;\n        /* Short-circuit accumulating 0 interest */\n        if (accrualBlockNumberPrior == currentBlockNumber) {\n            return (MathError.NO_ERROR, borrowIndex);\n        }\n        uint borrowRateMantissa = getBorrowRateInternal(getCashPrior(), totalBorrows, totalReserves);\n        (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);\n\n        Exp memory simpleInterestFactor;\n        (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);\n        if (mathErr != MathError.NO_ERROR) {\n            return (mathErr, 0);\n        }\n        (mathErr, borrowIndexNew) = mulScalarTruncateAddUInt(simpleInterestFactor, borrowIndex, borrowIndex);\n        return (mathErr, borrowIndexNew);\n    }\n\n    /**\n     * Applies accrued interest to total borrows and reserves\n     * @dev This calculates interest accrued from the last checkpointed block\n     *   up to the current block and writes new checkpoint to storage.\n     */\n    function accrueInterest() public override {\n        /* Remember the initial block number */\n        uint currentBlockNumber = getBlockNumber();\n        uint accrualBlockNumberPrior = accrualBlockNumber;\n\n        /* Short-circuit accumulating 0 interest */\n        if (accrualBlockNumberPrior == currentBlockNumber) {\n            return;\n        }\n\n        /* Read the previous values out of storage */\n        uint cashPrior = getCashPrior();\n        uint borrowsPrior = totalBorrows;\n        uint borrowIndexPrior = borrowIndex;\n        uint reservesPrior = totalReserves;\n\n        /* Calculate the current borrow interest rate */\n        uint borrowRateMantissa = getBorrowRateInternal(cashPrior, borrowsPrior, reservesPrior);\n        require(borrowRateMantissa <= borrowRateMaxMantissa, \"borrower rate higher\");\n\n        /* Calculate the number of blocks elapsed since the last accrual */\n        (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);\n        require(mathErr == MathError.NO_ERROR, \"calc block delta erro\");\n\n\n        /*\n         * Calculate the interest accumulated into borrows and reserves and the new index:\n         *  simpleInterestFactor = borrowRate * blockDelta\n         *  interestAccumulated = simpleInterestFactor * totalBorrows\n         *  totalBorrowsNew = interestAccumulated + totalBorrows\n         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex\n         */\n\n        Exp memory simpleInterestFactor;\n        uint interestAccumulated;\n        uint totalBorrowsNew;\n        uint borrowIndexNew;\n        uint totalReservesNew;\n\n        (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);\n        require(mathErr == MathError.NO_ERROR, 'calc interest factor error');\n\n        (mathErr, interestAccumulated) = mulScalarTruncate(simpleInterestFactor, borrowsPrior);\n        require(mathErr == MathError.NO_ERROR, 'calc interest acc error');\n\n        (mathErr, totalBorrowsNew) = addUInt(interestAccumulated, borrowsPrior);\n        require(mathErr == MathError.NO_ERROR, 'calc total borrows error');\n\n        (mathErr, totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa : reserveFactorMantissa}), interestAccumulated, reservesPrior);\n        require(mathErr == MathError.NO_ERROR, 'calc total reserves error');\n\n        (mathErr, borrowIndexNew) = mulScalarTruncateAddUInt(simpleInterestFactor, borrowIndexPrior, borrowIndexPrior);\n        require(mathErr == MathError.NO_ERROR, 'calc borrows index error');\n\n\n        /* We write the previously calculated values into storage */\n        accrualBlockNumber = currentBlockNumber;\n        borrowIndex = borrowIndexNew;\n        totalBorrows = totalBorrowsNew;\n        totalReserves = totalReservesNew;\n\n        /* We emit an AccrueInterest event */\n        emit AccrueInterest(cashPrior, interestAccumulated, borrowIndexNew, totalBorrowsNew);\n\n    }\n\n    struct MintLocalVars {\n        MathError mathErr;\n        uint exchangeRateMantissa;\n        uint mintTokens;\n        uint totalSupplyNew;\n        uint accountTokensNew;\n        uint actualMintAmount;\n    }\n\n    /**\n     * User supplies assets into the market and receives lTokens in exchange\n     * @dev Assumes interest has already been accrued up to the current block\n     * @param minter The address of the account which is supplying the assets\n     * @param mintAmount The amount of the underlying asset to supply\n     * @return uint the actual mint amount.\n     */\n    function mintFresh(address minter, uint mintAmount) internal sameBlock returns (uint) {\n        MintLocalVars memory vars;\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n        require(vars.mathErr == MathError.NO_ERROR, 'calc exchangerate error');\n\n        /*\n         *  We call `doTransferIn` for the minter and the mintAmount.\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n         *  `doTransferIn` reverts if anything goes wrong, since we can't be sure if\n         *  side-effects occurred. The function returns the amount actually transferred,\n         *  in case of a fee. On success, the cToken holds an additional `actualMintAmount`\n         *  of cash.\n         */\n        vars.actualMintAmount = doTransferIn(minter, mintAmount, true);\n\n        /*\n         * We get the current exchange rate and calculate the number of lTokens to be minted:\n         *  mintTokens = actualMintAmount / exchangeRate\n         */\n\n        (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(vars.actualMintAmount, Exp({mantissa : vars.exchangeRateMantissa}));\n        require(vars.mathErr == MathError.NO_ERROR, \"calc mint token error\");\n\n        /* Fail if mint not allowed */\n        (ControllerInterface(controller)).mintAllowed(address(this), minter, vars.mintTokens);\n        /*\n         * We calculate the new total supply of lTokens and minter token balance, checking for overflow:\n         *  totalSupplyNew = totalSupply + mintTokens\n         *  accountTokensNew = accountTokens[minter] + mintTokens\n         */\n        (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);\n        require(vars.mathErr == MathError.NO_ERROR, \"calc supply new failed\");\n\n        (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);\n        require(vars.mathErr == MathError.NO_ERROR, \"calc tokens new ailed\");\n\n        /* We write previously calculated values into storage */\n        totalSupply = vars.totalSupplyNew;\n        accountTokens[minter] = vars.accountTokensNew;\n\n        /* We emit a Mint event, and a Transfer event */\n        emit Mint(minter, vars.actualMintAmount, vars.mintTokens);\n        emit Transfer(address(this), minter, vars.mintTokens);\n\n        /* We call the defense hook */\n\n        return vars.actualMintAmount;\n    }\n\n\n    struct RedeemLocalVars {\n        MathError mathErr;\n        uint exchangeRateMantissa;\n        uint redeemTokens;\n        uint redeemAmount;\n        uint totalSupplyNew;\n        uint accountTokensNew;\n    }\n\n    /**\n     * User redeems lTokens in exchange for the underlying asset\n     * @dev Assumes interest has already been accrued up to the current block\n     * @param redeemer The address of the account which is redeeming the tokens\n     * @param redeemTokensIn The number of lTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be non-zero)\n     * @param redeemAmountIn The number of underlying tokens to receive from redeeming lTokens (only one of redeemTokensIn or redeemAmountIn may be non-zero)\n     */\n    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal sameBlock {\n        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one be zero\");\n\n        RedeemLocalVars memory vars;\n\n        /* exchangeRate = invoke Exchange Rate Stored() */\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n        require(vars.mathErr == MathError.NO_ERROR, 'calc exchangerate error');\n\n        /* If redeemTokensIn > 0: */\n        if (redeemTokensIn > 0) {\n            /*\n             * We calculate the exchange rate and the amount of underlying to be redeemed:\n             *  redeemTokens = redeemTokensIn\n             *  redeemAmount = redeemTokensIn x exchangeRateCurrent\n             */\n            vars.redeemTokens = redeemTokensIn;\n\n            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa : vars.exchangeRateMantissa}), redeemTokensIn);\n            require(vars.mathErr == MathError.NO_ERROR, 'calc redeem amount error');\n        } else {\n            /*\n             * We get the current exchange rate and calculate the amount to be redeemed:\n             *  redeemTokens = redeemAmountIn / exchangeRate\n             *  redeemAmount = redeemAmountIn\n             */\n\n            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa : vars.exchangeRateMantissa}));\n            require(vars.mathErr == MathError.NO_ERROR, 'calc redeem tokens error');\n            vars.redeemAmount = redeemAmountIn;\n        }\n\n        /* Fail if redeem not allowed */\n        (ControllerInterface(controller)).redeemAllowed(address(this), redeemer, vars.redeemTokens);\n\n        /*\n         * We calculate the new total supply and redeemer balance, checking for underflow:\n         *  totalSupplyNew = totalSupply - redeemTokens\n         *  accountTokensNew = accountTokens[redeemer] - redeemTokens\n         */\n        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);\n        require(vars.mathErr == MathError.NO_ERROR, 'calc supply new error');\n\n        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);\n        require(vars.mathErr == MathError.NO_ERROR, 'calc token new error');\n        require(getCashPrior() >= vars.redeemAmount, 'cash < redeem');\n\n        /*\n         * We invoke doTransferOut for the redeemer and the redeemAmount.\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n         *  On success, the cToken has redeemAmount less of cash.\n         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n         */\n        doTransferOut(redeemer, vars.redeemAmount, true);\n        /* We write previously calculated values into storage */\n        totalSupply = vars.totalSupplyNew;\n        accountTokens[redeemer] = vars.accountTokensNew;\n\n        /* We emit a Transfer event, and a Redeem event */\n        emit Transfer(redeemer, address(this), vars.redeemTokens);\n        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);\n\n        /* We call the defense hook */\n    }\n\n    struct BorrowLocalVars {\n        MathError mathErr;\n        uint accountBorrows;\n        uint accountBorrowsNew;\n        uint totalBorrowsNew;\n    }\n\n    /**\n      * Users borrow assets from the protocol to their own address\n      * @param borrowAmount The amount of the underlying asset to borrow\n      */\n    //SWC-107-Reentrancy: L845-L885\n    function borrowFresh(address payable borrower, address payable payee, uint borrowAmount) internal sameBlock {\n        /* Fail if borrow not allowed */\n        (ControllerInterface(controller)).borrowAllowed(address(this), borrower, payee, borrowAmount);\n\n        /* Fail gracefully if protocol has insufficient underlying cash */\n        require(getCashPrior() >= borrowAmount, 'cash<borrow');\n\n        BorrowLocalVars memory vars;\n\n        /*\n         * We calculate the new borrower and total borrow balances, failing on overflow:\n         *  accountBorrowsNew = accountBorrows + borrowAmount\n         *  totalBorrowsNew = totalBorrows + borrowAmount\n         */\n        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);\n        require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrows error');\n\n        (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);\n        require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrows error');\n\n        (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);\n        require(vars.mathErr == MathError.NO_ERROR, 'calc total borrows error');\n\n        /*\n         * We invoke doTransferOut for the borrower and the borrowAmount.\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n         *  On success, the cToken borrowAmount less of cash.\n         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n         */\n        doTransferOut(payee, borrowAmount, false);\n\n        /* We write the previously calculated values into storage */\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\n        accountBorrows[borrower].interestIndex = borrowIndex;\n        totalBorrows = vars.totalBorrowsNew;\n\n        /* We emit a Borrow event */\n        emit Borrow(borrower, payee, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\n\n        /* We call the defense hook */\n    }\n\n    struct RepayBorrowLocalVars {\n        MathError mathErr;\n        uint repayAmount;\n        uint borrowerIndex;\n        uint accountBorrows;\n        uint accountBorrowsNew;\n        uint totalBorrowsNew;\n        uint actualRepayAmount;\n    }\n\n    /**\n     * Borrows are repaid by another user (possibly the borrower).\n     * @param payer the account paying off the borrow\n     * @param borrower the account with the debt being payed off\n     * @param repayAmount the amount of undelrying tokens being returned\n     */\n    function repayBorrowFresh(address payer, address borrower, uint repayAmount, bool isEnd) internal sameBlock returns (uint) {\n        /* Fail if repayBorrow not allowed */\n        (ControllerInterface(controller)).repayBorrowAllowed(address(this), payer, borrower, repayAmount, isEnd);\n\n        RepayBorrowLocalVars memory vars;\n\n        /* We remember the original borrowerIndex for verification purposes */\n        vars.borrowerIndex = accountBorrows[borrower].interestIndex;\n\n        /* We fetch the amount the borrower owes, with accumulated interest */\n        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);\n        require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrow error');\n\n        /* If repayAmount == -1, repayAmount = accountBorrows */\n        if (repayAmount == uint(- 1)) {\n            vars.repayAmount = vars.accountBorrows;\n        } else {\n            vars.repayAmount = repayAmount;\n        }\n\n        /*\n         * We call doTransferIn for the payer and the repayAmount\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n         *  On success, the cToken holds an additional repayAmount of cash.\n         *  doTransferIn reverts if anything goes wrong, since we can't be sure if side effects occurred.\n         *   it returns the amount actually transferred, in case of a fee.\n         */\n        vars.actualRepayAmount = doTransferIn(payer, vars.repayAmount, false);\n\n        if (isEnd) {\n            vars.actualRepayAmount = vars.accountBorrows;\n        }\n        /*\n         * We calculate the new borrower and total borrow balances, failing on underflow:\n         *  accountBorrowsNew = accountBorrows - actualRepayAmount\n         *  totalBorrowsNew = totalBorrows - actualRepayAmount\n         */\n        (vars.mathErr, vars.accountBorrowsNew) = subUInt(vars.accountBorrows, vars.actualRepayAmount);\n\n        require(vars.mathErr == MathError.NO_ERROR, \"calc acc borrows error\");\n        //Avoid mantissa errors\n        if (vars.actualRepayAmount > totalBorrows) {\n            vars.totalBorrowsNew = 0;\n        } else {\n            vars.totalBorrowsNew = totalBorrows - vars.actualRepayAmount;\n        }\n\n        /* We write the previously calculated values into storage */\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\n        accountBorrows[borrower].interestIndex = borrowIndex;\n        totalBorrows = vars.totalBorrowsNew;\n\n        /* We emit a RepayBorrow event */\n        emit RepayBorrow(payer, borrower, vars.actualRepayAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\n\n        /* We call the defense hook */\n\n        return vars.actualRepayAmount;\n    }\n\n    /*** Admin Functions ***/\n\n    /**\n      * Sets a new CONTROLLER for the market\n      * @dev Admin function to set a new controller\n      */\n    function setController(address newController) external override onlyAdmin {\n        address oldController = controller;\n\n        controller = newController;\n        // Emit NewController(oldController, newController)\n        emit NewController(oldController, newController);\n    }\n\n    function setBorrowCapFactorMantissa(uint newBorrowCapFactorMantissa) external override onlyAdmin {\n        borrowCapFactorMantissa = newBorrowCapFactorMantissa;\n    }\n\n    function setInterestParams(uint baseRatePerBlock_, uint multiplierPerBlock_, uint jumpMultiplierPerBlock_, uint kink_) external override onlyAdmin {\n        //accrueInterest except first\n        if (baseRatePerBlock != 0) {\n            accrueInterest();\n        }\n        baseRatePerBlock = baseRatePerBlock_;\n        multiplierPerBlock = multiplierPerBlock_;\n        jumpMultiplierPerBlock = jumpMultiplierPerBlock_;\n        kink = kink_;\n        emit NewInterestParam(baseRatePerBlock_, multiplierPerBlock_, jumpMultiplierPerBlock_, kink_);\n    }\n\n    function setReserveFactor(uint newReserveFactorMantissa) external override onlyAdmin {\n        accrueInterest();\n        uint oldReserveFactorMantissa = reserveFactorMantissa;\n        reserveFactorMantissa = newReserveFactorMantissa;\n        emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);\n    }\n\n    function addReserves(uint addAmount) external override {\n        accrueInterest();\n        uint totalReservesNew;\n        uint actualAddAmount;\n        actualAddAmount = doTransferIn(msg.sender, addAmount, true);\n        totalReservesNew = totalReserves.add(actualAddAmount);\n        totalReserves = totalReservesNew;\n        emit ReservesAdded(msg.sender, actualAddAmount, totalReservesNew);\n    }\n\n    function reduceReserves(address payable to, uint reduceAmount) external override onlyAdmin {\n        accrueInterest();\n        uint totalReservesNew;\n        totalReservesNew = totalReserves.sub(reduceAmount);\n        totalReserves = totalReservesNew;\n        doTransferOut(to, reduceAmount, true);\n        emit ReservesReduced(to, reduceAmount, totalReservesNew);\n    }\n\n    modifier sameBlock() {\n        require(accrualBlockNumber == getBlockNumber(), 'not same block');\n        _;\n    }\n\n}",
        "function": "accrueInterest()",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/PeckShield-OpenLeverage1.0/openleverage-contracts-e31d971bcb38ec8737cf1942b8fdf6a9452e5834/contracts/liquidity/LPool.sol",
        "vulnerability": "Dependence on predictable environment variable (SWC 120)",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract LPool is DelegateInterface, Adminable, LPoolInterface, Exponential, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint;\n\n    constructor() {\n\n    }\n    /**\n     * Initialize the money market\n     * @param controller_ The address of the Controller\n     * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18\n     * @param name_ EIP-20 name of this token\n     * @param symbol_ EIP-20 symbol of this token\n     * @param decimals_ EIP-20 decimal precision of this token\n     */\n    function initialize(\n        address underlying_,\n        bool isWethPool_,\n        address controller_,\n        uint256 baseRatePerBlock_,\n        uint256 multiplierPerBlock_,\n        uint256 jumpMultiplierPerBlock_,\n        uint256 kink_,\n        uint initialExchangeRateMantissa_,\n        string memory name_,\n        string memory symbol_,\n        uint8 decimals_) public {\n        require(underlying_ != address(0), \"underlying_ address cannot be 0\");\n        require(controller_ != address(0), \"controller_ address cannot be 0\");\n        require(msg.sender == admin, \"Only allow to be called by admin\");\n        require(accrualBlockNumber == 0 && borrowIndex == 0, \"inited once\");\n\n        // Set initial exchange rate\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\n        require(initialExchangeRateMantissa > 0, \"Initial Exchange Rate Mantissa should be greater zero\");\n        //set controller\n        controller = controller_;\n        isWethPool = isWethPool_;\n        //set interestRateModel\n        baseRatePerBlock = baseRatePerBlock_;\n        multiplierPerBlock = multiplierPerBlock_;\n        jumpMultiplierPerBlock = jumpMultiplierPerBlock_;\n        kink = kink_;\n\n        // Initialize block number and borrow index (block number mocks depend on controller being set)\n        accrualBlockNumber = getBlockNumber();\n        borrowIndex = 1e25;\n        //80%\n        borrowCapFactorMantissa = 0.8e18;\n        //20%\n        reserveFactorMantissa = 0.2e18;\n\n\n        name = name_;\n        symbol = symbol_;\n        decimals = decimals_;\n\n        _notEntered = true;\n\n        // Set underlying and sanity check it\n        underlying = underlying_;\n        IERC20(underlying).totalSupply();\n    }\n\n    /**\n     * Transfer `tokens` tokens from `src` to `dst` by `spender`\n     * @dev Called by both `transfer` and `transferFrom` internally\n     * @param spender The address of the account performing the transfer\n     * @param src The address of the source account\n     * @param dst The address of the destination account\n     * @param tokens The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     */\n    function transferTokens(address spender, address src, address dst, uint tokens) internal returns (bool) {\n        require(dst != address(0), \"dst address cannot be 0\");\n        /* Do not allow self-transfers */\n        require(src != dst, \"src = dst\");\n        /* Fail if transfer not allowed */\n        (ControllerInterface(controller)).transferAllowed(address(this), src, dst, tokens);\n\n        /* Get the allowance, infinite for the account owner */\n        uint startingAllowance = 0;\n        if (spender == src) {\n            startingAllowance = uint(- 1);\n        } else {\n            startingAllowance = transferAllowances[src][spender];\n        }\n\n        /* Do the calculations, checking for {under,over}flow */\n        MathError mathErr;\n        uint allowanceNew;\n        uint srcTokensNew;\n        uint dstTokensNew;\n\n        (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);\n        require(mathErr == MathError.NO_ERROR, 'not allowed');\n\n        (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);\n        require(mathErr == MathError.NO_ERROR, 'not enough');\n\n        (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);\n        require(mathErr == MathError.NO_ERROR, 'too much');\n\n        accountTokens[src] = srcTokensNew;\n        accountTokens[dst] = dstTokensNew;\n\n        /* Eat some of the allowance (if necessary) */\n        if (startingAllowance != uint(- 1)) {\n            transferAllowances[src][spender] = allowanceNew;\n        }\n        /* We emit a Transfer event */\n        emit Transfer(src, dst, tokens);\n        return true;\n    }\n\n    /**\n     * Transfer `amount` tokens from `msg.sender` to `dst`\n     * @param dst The address of the destination account\n     * @param amount The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     */\n    function transfer(address dst, uint256 amount) external override nonReentrant returns (bool) {\n        return transferTokens(msg.sender, msg.sender, dst, amount);\n    }\n\n    /**\n     * Transfer `amount` tokens from `src` to `dst`\n     * @param src The address of the source account\n     * @param dst The address of the destination account\n     * @param amount The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     */\n    function transferFrom(address src, address dst, uint256 amount) external override nonReentrant returns (bool) {\n        return transferTokens(msg.sender, src, dst, amount);\n    }\n\n    /**\n     * Approve `spender` to transfer up to `amount` from `src`\n     * @dev This will overwrite the approval amount for `spender`\n     *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n     * @param spender The address of the account which may transfer tokens\n     * @param amount The number of tokens that are approved (-1 means infinite)\n     * @return Whether or not the approval succeeded\n     */\n    function approve(address spender, uint256 amount) external override returns (bool) {\n        address src = msg.sender;\n        transferAllowances[src][spender] = amount;\n        emit Approval(src, spender, amount);\n        return true;\n    }\n\n    /**\n     * Get the current allowance from `owner` for `spender`\n     * @param owner The address of the account which owns the tokens to be spent\n     * @param spender The address of the account which may transfer tokens\n     * @return The number of tokens allowed to be spent (-1 means infinite)\n     */\n    function allowance(address owner, address spender) external override view returns (uint256) {\n        return transferAllowances[owner][spender];\n    }\n\n    /**\n     * Get the token balance of the `owner`\n     * @param owner The address of the account to query\n     * @return The number of tokens owned by `owner`\n     */\n    function balanceOf(address owner) external override view returns (uint256) {\n        return accountTokens[owner];\n    }\n\n    /**\n     * Get the underlying balance of the `owner`\n     * @dev This also accrues interest in a transaction\n     * @param owner The address of the account to query\n     * @return The amount of underlying owned by `owner`\n     */\n    function balanceOfUnderlying(address owner) external override returns (uint) {\n        Exp memory exchangeRate = Exp({mantissa : exchangeRateCurrent()});\n        (MathError mErr, uint balance) = mulScalarTruncate(exchangeRate, accountTokens[owner]);\n        require(mErr == MathError.NO_ERROR, \"calc failed\");\n        return balance;\n    }\n\n    /*** User Interface ***/\n\n    /**\n     * Sender supplies assets into the market and receives lTokens in exchange\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param mintAmount The amount of the underlying asset to supply\n     */\n    function mint(uint mintAmount) external override nonReentrant {\n        accrueInterest();\n        // mintFresh emits the actual Mint event if successful and logs on errors, so we don't need to\n        mintFresh(msg.sender, mintAmount);\n    }\n\n    function mintEth() external payable override nonReentrant {\n        require(isWethPool, \"not eth pool\");\n        accrueInterest();\n        mintFresh(msg.sender, msg.value);\n    }\n\n    /**\n     * Sender redeems lTokens in exchange for the underlying asset\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param redeemTokens The number of lTokens to redeem into underlying\n     */\n    function redeem(uint redeemTokens) external override nonReentrant {\n        accrueInterest();\n        // redeemFresh emits redeem-specific logs on errors, so we don't need to\n        redeemFresh(msg.sender, redeemTokens, 0);\n    }\n\n    /**\n     * Sender redeems lTokens in exchange for a specified amount of underlying asset\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param redeemAmount The amount of underlying to redeem\n     */\n    function redeemUnderlying(uint redeemAmount) external override nonReentrant {\n        accrueInterest();\n        // redeemFresh emits redeem-specific logs on errors, so we don't need to\n        redeemFresh(msg.sender, 0, redeemAmount);\n    }\n\n    function borrowBehalf(address borrower, uint borrowAmount) external override nonReentrant {\n        accrueInterest();\n        // borrowFresh emits borrow-specific logs on errors, so we don't need to\n        borrowFresh(payable(borrower), msg.sender, borrowAmount);\n    }\n\n    /**\n     * Sender repays a borrow belonging to borrower\n     * @param borrower the account with the debt being payed off\n     * @param repayAmount The amount to repay\n     */\n    function repayBorrowBehalf(address borrower, uint repayAmount) external override nonReentrant {\n        accrueInterest();\n        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\n        repayBorrowFresh(msg.sender, borrower, repayAmount, false);\n    }\n\n    function repayBorrowEndByOpenLev(address borrower, uint repayAmount) external override nonReentrant {\n        accrueInterest();\n        repayBorrowFresh(msg.sender, borrower, repayAmount, true);\n    }\n\n\n\n    /*** Safe Token ***/\n\n    /**\n     * Gets balance of this contract in terms of the underlying\n     * @dev This excludes the value of the current message, if any\n     * @return The quantity of underlying tokens owned by this contract\n     */\n    function getCashPrior() internal view returns (uint) {\n        IERC20 token = IERC20(underlying);\n        return token.balanceOf(address(this));\n    }\n\n    /**\n     * @dev Similar to EIP20 transfer, except it handles a False result from `transferFrom` and reverts in that case.\n     *      This will revert due to insufficient balance or insufficient allowance.\n     *      This function returns the actual amount received,\n     *      which may be less than `amount` if there is a fee attached to the transfer.\n     *\n     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.\n     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\n     */\n    function doTransferIn(address from, uint amount, bool convertWeth) internal returns (uint) {\n        uint balanceBefore = IERC20(underlying).balanceOf(address(this));\n        if (isWethPool && convertWeth) {\n            IWETH(underlying).deposit{value : msg.value}();\n        } else {\n            IERC20(underlying).transferFrom(from, address(this), amount);\n        }\n        // Calculate the amount that was *actually* transferred\n        uint balanceAfter = IERC20(underlying).balanceOf(address(this));\n        require(balanceAfter >= balanceBefore, \"transfer overflow\");\n        return balanceAfter - balanceBefore;\n    }\n\n    /**\n     * @dev Similar to EIP20 transfer, except it handles a False success from `transfer` and returns an explanatory\n     *      error code rather than reverting. If caller has not called checked protocol's balance, this may revert due to\n     *      insufficient cash held in this contract. If caller has checked protocol's balance prior to this call, and verified\n     *      it is >= amount, this should not revert in normal conditions.\n     *\n     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.\n     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\n     */\n    function doTransferOut(address payable to, uint amount, bool convertWeth) internal {\n        if (isWethPool && convertWeth) {\n            IWETH(underlying).withdraw(amount);\n            to.transfer(amount);\n        } else {\n            IERC20(underlying).safeTransfer(to, amount);\n        }\n    }\n\n    function availableForBorrow() external view override returns (uint){\n        uint cash = getCashPrior();\n        (MathError err0, uint sum) = addThenSubUInt(cash, totalBorrows, totalReserves);\n        if (err0 != MathError.NO_ERROR) {\n            return 0;\n        }\n        (MathError err1, uint maxAvailable) = mulScalarTruncate(Exp({mantissa : sum}), borrowCapFactorMantissa);\n        if (err1 != MathError.NO_ERROR) {\n            return 0;\n        }\n        if (totalBorrows > maxAvailable) {\n            return 0;\n        }\n        return maxAvailable - totalBorrows;\n    }\n\n\n    /**\n     * Get a snapshot of the account's balances, and the cached exchange rate\n     * @dev This is used by controller to more efficiently perform liquidity checks.\n     * @param account Address of the account to snapshot\n     * @return ( token balance, borrow balance, exchange rate mantissa)\n     */\n    function getAccountSnapshot(address account) external override view returns (uint, uint, uint) {\n        uint cTokenBalance = accountTokens[account];\n        uint borrowBalance;\n        uint exchangeRateMantissa;\n\n        MathError mErr;\n\n        (mErr, borrowBalance) = borrowBalanceStoredInternal(account);\n        if (mErr != MathError.NO_ERROR) {\n            return (0, 0, 0);\n        }\n\n        (mErr, exchangeRateMantissa) = exchangeRateStoredInternal();\n        if (mErr != MathError.NO_ERROR) {\n            return (0, 0, 0);\n        }\n\n        return (cTokenBalance, borrowBalance, exchangeRateMantissa);\n    }\n\n    /**\n     * @dev Function to simply retrieve block number\n     *  This exists mainly for inheriting test contracts to stub this result.\n     */\n    function getBlockNumber() internal view returns (uint) {\n        return block.number;\n    }\n\n    /**\n     * Returns the current per-block borrow interest rate for this cToken\n     * @return The borrow interest rate per block, scaled by 1e18\n     */\n    function borrowRatePerBlock() external override view returns (uint) {\n        return getBorrowRateInternal(getCashPrior(), totalBorrows, totalReserves);\n    }\n\n    /**\n     * Returns the current per-block supply interest rate for this cToken\n     * @return The supply interest rate per block, scaled by 1e18\n     */\n    function supplyRatePerBlock() external override view returns (uint) {\n        return getSupplyRateInternal(getCashPrior(), totalBorrows, totalReserves, reserveFactorMantissa);\n    }\n\n    function utilizationRate(uint cash, uint borrows, uint reserves) internal pure returns (uint) {\n        // Utilization rate is 0 when there are no borrows\n        if (borrows == 0) {\n            return 0;\n        }\n        return borrows.mul(1e18).div(cash.add(borrows).sub(reserves));\n    }\n\n    /**\n     * Calculates the current borrow rate per block, with the error code expected by the market\n     * @param cash The amount of cash in the market\n     * @param borrows The amount of borrows in the market\n     * @return The borrow rate percentage per block as a mantissa (scaled by 1e18)\n     */\n    function getBorrowRateInternal(uint cash, uint borrows, uint reserves) internal view returns (uint) {\n        uint util = utilizationRate(cash, borrows, reserves);\n        if (util <= kink) {\n            return util.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);\n        } else {\n            uint normalRate = kink.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);\n            uint excessUtil = util.sub(kink);\n            return excessUtil.mul(jumpMultiplierPerBlock).div(1e18).add(normalRate);\n        }\n    }\n\n    /**\n     * Calculates the current supply rate per block\n     * @param cash The amount of cash in the market\n     * @param borrows The amount of borrows in the market\n     * @return The supply rate percentage per block as a mantissa (scaled by 1e18)\n     */\n    function getSupplyRateInternal(uint cash, uint borrows, uint reserves, uint reserveFactor) internal view returns (uint) {\n        uint oneMinusReserveFactor = uint(1e18).sub(reserveFactor);\n        uint borrowRate = getBorrowRateInternal(cash, borrows, reserves);\n        uint rateToPool = borrowRate.mul(oneMinusReserveFactor).div(1e18);\n        return utilizationRate(cash, borrows, reserves).mul(rateToPool).div(1e18);\n    }\n    /**\n     * Returns the current total borrows plus accrued interest\n     * @return The total borrows with interest\n     */\n    function totalBorrowsCurrent() external override view returns (uint) {\n        /* Remember the initial block number */\n        uint currentBlockNumber = getBlockNumber();\n        uint accrualBlockNumberPrior = accrualBlockNumber;\n\n        /* Short-circuit accumulating 0 interest */\n        if (accrualBlockNumberPrior == currentBlockNumber) {\n            return totalBorrows;\n        }\n\n        /* Read the previous values out of storage */\n        uint cashPrior = getCashPrior();\n        uint borrowsPrior = totalBorrows;\n        uint reservesPrior = totalReserves;\n\n        /* Calculate the current borrow interest rate */\n        uint borrowRateMantissa = getBorrowRateInternal(cashPrior, borrowsPrior, reservesPrior);\n        require(borrowRateMantissa <= borrowRateMaxMantissa, \"borrower rate higher\");\n\n        /* Calculate the number of blocks elapsed since the last accrual */\n        (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);\n        require(mathErr == MathError.NO_ERROR, \"calc block delta erro\");\n\n        Exp memory simpleInterestFactor;\n        uint interestAccumulated;\n        uint totalBorrowsNew;\n\n        (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);\n        require(mathErr == MathError.NO_ERROR, 'calc interest factor error');\n\n        (mathErr, interestAccumulated) = mulScalarTruncate(simpleInterestFactor, borrowsPrior);\n        require(mathErr == MathError.NO_ERROR, 'calc interest acc error');\n\n        (mathErr, totalBorrowsNew) = addUInt(interestAccumulated, borrowsPrior);\n        require(mathErr == MathError.NO_ERROR, 'calc total borrows error');\n\n        return totalBorrowsNew;\n    }\n    /**\n     * Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex\n     * @param account The address whose balance should be calculated after updating borrowIndex\n     * @return The calculated balance\n     */\n    function borrowBalanceCurrent(address account) external view override returns (uint) {\n        (MathError err0, uint borrowIndex) = calCurrentBorrowIndex();\n        require(err0 == MathError.NO_ERROR, \"calc borrow index fail\");\n        (MathError err1, uint result) = borrowBalanceStoredInternalWithBorrowerIndex(account, borrowIndex);\n        require(err1 == MathError.NO_ERROR, \"calc fail\");\n        return result;\n    }\n\n    function borrowBalanceStored(address account) external override view returns (uint){\n        return accountBorrows[account].principal;\n    }\n\n\n    /**\n     * Return the borrow balance of account based on stored data\n     * @param account The address whose balance should be calculated\n     * @return (error code, the calculated balance or 0 if error code is non-zero)\n     */\n    function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {\n        return borrowBalanceStoredInternalWithBorrowerIndex(account, borrowIndex);\n    }\n    /**\n     * Return the borrow balance of account based on stored data\n     * @param account The address whose balance should be calculated\n     * @return (error code, the calculated balance or 0 if error code is non-zero)\n     */\n    function borrowBalanceStoredInternalWithBorrowerIndex(address account, uint borrowIndex) internal view returns (MathError, uint) {\n        /* Note: we do not assert that the market is up to date */\n        MathError mathErr;\n        uint principalTimesIndex;\n        uint result;\n\n        /* Get borrowBalance and borrowIndex */\n        BorrowSnapshot storage borrowSnapshot = accountBorrows[account];\n\n        /* If borrowBalance = 0 then borrowIndex is likely also 0.\n         * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.\n         */\n        if (borrowSnapshot.principal == 0) {\n            return (MathError.NO_ERROR, 0);\n        }\n\n        /* Calculate new borrow balance using the interest index:\n         *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex\n         */\n        (mathErr, principalTimesIndex) = mulUInt(borrowSnapshot.principal, borrowIndex);\n        if (mathErr != MathError.NO_ERROR) {\n            return (mathErr, 0);\n        }\n\n        (mathErr, result) = divUInt(principalTimesIndex, borrowSnapshot.interestIndex);\n        if (mathErr != MathError.NO_ERROR) {\n            return (mathErr, 0);\n        }\n\n        return (MathError.NO_ERROR, result);\n    }\n    /**\n     * Accrue interest then return the up-to-date exchange rate\n     * @return Calculated exchange rate scaled by 1e18\n     */\n    function exchangeRateCurrent() public override nonReentrant returns (uint) {\n        accrueInterest();\n        return exchangeRateStored();\n    }\n\n    /**\n     * Calculates the exchange rate from the underlying to the LToken\n     * @dev This function does not accrue interest before calculating the exchange rate\n     * @return Calculated exchange rate scaled by 1e18\n     */\n    function exchangeRateStored() public override view returns (uint) {\n        (MathError err, uint result) = exchangeRateStoredInternal();\n        require(err == MathError.NO_ERROR, \"calc fail\");\n        return result;\n    }\n\n    /**\n     * Calculates the exchange rate from the underlying to the LToken\n     * @dev This function does not accrue interest before calculating the exchange rate\n     * @return (error code, calculated exchange rate scaled by 1e18)\n     */\n    function exchangeRateStoredInternal() internal view returns (MathError, uint) {\n        uint _totalSupply = totalSupply;\n        if (_totalSupply == 0) {\n            /*\n             * If there are no tokens minted:\n             *  exchangeRate = initialExchangeRate\n             */\n            return (MathError.NO_ERROR, initialExchangeRateMantissa);\n        } else {\n            /*\n             * Otherwise:\n             *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply\n             */\n            uint totalCash = getCashPrior();\n            uint cashPlusBorrowsMinusReserves;\n            Exp memory exchangeRate;\n            MathError mathErr;\n\n            (mathErr, cashPlusBorrowsMinusReserves) = addThenSubUInt(totalCash, totalBorrows, totalReserves);\n            if (mathErr != MathError.NO_ERROR) {\n                return (mathErr, 0);\n            }\n\n            (mathErr, exchangeRate) = getExp(cashPlusBorrowsMinusReserves, _totalSupply);\n            if (mathErr != MathError.NO_ERROR) {\n                return (mathErr, 0);\n            }\n\n            return (MathError.NO_ERROR, exchangeRate.mantissa);\n        }\n    }\n\n    /**\n     * Get cash balance of this cToken in the underlying asset\n     * @return The quantity of underlying asset owned by this contract\n     */\n    function getCash() external override view returns (uint) {\n        return getCashPrior();\n    }\n\n    function calCurrentBorrowIndex() internal view returns (MathError, uint) {\n        /* Remember the initial block number */\n        uint currentBlockNumber = getBlockNumber();\n        uint accrualBlockNumberPrior = accrualBlockNumber;\n        uint borrowIndexNew;\n        /* Short-circuit accumulating 0 interest */\n        if (accrualBlockNumberPrior == currentBlockNumber) {\n            return (MathError.NO_ERROR, borrowIndex);\n        }\n        uint borrowRateMantissa = getBorrowRateInternal(getCashPrior(), totalBorrows, totalReserves);\n        (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);\n\n        Exp memory simpleInterestFactor;\n        (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);\n        if (mathErr != MathError.NO_ERROR) {\n            return (mathErr, 0);\n        }\n        (mathErr, borrowIndexNew) = mulScalarTruncateAddUInt(simpleInterestFactor, borrowIndex, borrowIndex);\n        return (mathErr, borrowIndexNew);\n    }\n\n    /**\n     * Applies accrued interest to total borrows and reserves\n     * @dev This calculates interest accrued from the last checkpointed block\n     *   up to the current block and writes new checkpoint to storage.\n     */\n    function accrueInterest() public override {\n        /* Remember the initial block number */\n        uint currentBlockNumber = getBlockNumber();\n        uint accrualBlockNumberPrior = accrualBlockNumber;\n\n        /* Short-circuit accumulating 0 interest */\n        if (accrualBlockNumberPrior == currentBlockNumber) {\n            return;\n        }\n\n        /* Read the previous values out of storage */\n        uint cashPrior = getCashPrior();\n        uint borrowsPrior = totalBorrows;\n        uint borrowIndexPrior = borrowIndex;\n        uint reservesPrior = totalReserves;\n\n        /* Calculate the current borrow interest rate */\n        uint borrowRateMantissa = getBorrowRateInternal(cashPrior, borrowsPrior, reservesPrior);\n        require(borrowRateMantissa <= borrowRateMaxMantissa, \"borrower rate higher\");\n\n        /* Calculate the number of blocks elapsed since the last accrual */\n        (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);\n        require(mathErr == MathError.NO_ERROR, \"calc block delta erro\");\n\n\n        /*\n         * Calculate the interest accumulated into borrows and reserves and the new index:\n         *  simpleInterestFactor = borrowRate * blockDelta\n         *  interestAccumulated = simpleInterestFactor * totalBorrows\n         *  totalBorrowsNew = interestAccumulated + totalBorrows\n         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex\n         */\n\n        Exp memory simpleInterestFactor;\n        uint interestAccumulated;\n        uint totalBorrowsNew;\n        uint borrowIndexNew;\n        uint totalReservesNew;\n\n        (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);\n        require(mathErr == MathError.NO_ERROR, 'calc interest factor error');\n\n        (mathErr, interestAccumulated) = mulScalarTruncate(simpleInterestFactor, borrowsPrior);\n        require(mathErr == MathError.NO_ERROR, 'calc interest acc error');\n\n        (mathErr, totalBorrowsNew) = addUInt(interestAccumulated, borrowsPrior);\n        require(mathErr == MathError.NO_ERROR, 'calc total borrows error');\n\n        (mathErr, totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa : reserveFactorMantissa}), interestAccumulated, reservesPrior);\n        require(mathErr == MathError.NO_ERROR, 'calc total reserves error');\n\n        (mathErr, borrowIndexNew) = mulScalarTruncateAddUInt(simpleInterestFactor, borrowIndexPrior, borrowIndexPrior);\n        require(mathErr == MathError.NO_ERROR, 'calc borrows index error');\n\n\n        /* We write the previously calculated values into storage */\n        accrualBlockNumber = currentBlockNumber;\n        borrowIndex = borrowIndexNew;\n        totalBorrows = totalBorrowsNew;\n        totalReserves = totalReservesNew;\n\n        /* We emit an AccrueInterest event */\n        emit AccrueInterest(cashPrior, interestAccumulated, borrowIndexNew, totalBorrowsNew);\n\n    }\n\n    struct MintLocalVars {\n        MathError mathErr;\n        uint exchangeRateMantissa;\n        uint mintTokens;\n        uint totalSupplyNew;\n        uint accountTokensNew;\n        uint actualMintAmount;\n    }\n\n    /**\n     * User supplies assets into the market and receives lTokens in exchange\n     * @dev Assumes interest has already been accrued up to the current block\n     * @param minter The address of the account which is supplying the assets\n     * @param mintAmount The amount of the underlying asset to supply\n     * @return uint the actual mint amount.\n     */\n    function mintFresh(address minter, uint mintAmount) internal sameBlock returns (uint) {\n        MintLocalVars memory vars;\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n        require(vars.mathErr == MathError.NO_ERROR, 'calc exchangerate error');\n\n        /*\n         *  We call `doTransferIn` for the minter and the mintAmount.\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n         *  `doTransferIn` reverts if anything goes wrong, since we can't be sure if\n         *  side-effects occurred. The function returns the amount actually transferred,\n         *  in case of a fee. On success, the cToken holds an additional `actualMintAmount`\n         *  of cash.\n         */\n        vars.actualMintAmount = doTransferIn(minter, mintAmount, true);\n\n        /*\n         * We get the current exchange rate and calculate the number of lTokens to be minted:\n         *  mintTokens = actualMintAmount / exchangeRate\n         */\n\n        (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(vars.actualMintAmount, Exp({mantissa : vars.exchangeRateMantissa}));\n        require(vars.mathErr == MathError.NO_ERROR, \"calc mint token error\");\n\n        /* Fail if mint not allowed */\n        (ControllerInterface(controller)).mintAllowed(address(this), minter, vars.mintTokens);\n        /*\n         * We calculate the new total supply of lTokens and minter token balance, checking for overflow:\n         *  totalSupplyNew = totalSupply + mintTokens\n         *  accountTokensNew = accountTokens[minter] + mintTokens\n         */\n        (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);\n        require(vars.mathErr == MathError.NO_ERROR, \"calc supply new failed\");\n\n        (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);\n        require(vars.mathErr == MathError.NO_ERROR, \"calc tokens new ailed\");\n\n        /* We write previously calculated values into storage */\n        totalSupply = vars.totalSupplyNew;\n        accountTokens[minter] = vars.accountTokensNew;\n\n        /* We emit a Mint event, and a Transfer event */\n        emit Mint(minter, vars.actualMintAmount, vars.mintTokens);\n        emit Transfer(address(this), minter, vars.mintTokens);\n\n        /* We call the defense hook */\n\n        return vars.actualMintAmount;\n    }\n\n\n    struct RedeemLocalVars {\n        MathError mathErr;\n        uint exchangeRateMantissa;\n        uint redeemTokens;\n        uint redeemAmount;\n        uint totalSupplyNew;\n        uint accountTokensNew;\n    }\n\n    /**\n     * User redeems lTokens in exchange for the underlying asset\n     * @dev Assumes interest has already been accrued up to the current block\n     * @param redeemer The address of the account which is redeeming the tokens\n     * @param redeemTokensIn The number of lTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be non-zero)\n     * @param redeemAmountIn The number of underlying tokens to receive from redeeming lTokens (only one of redeemTokensIn or redeemAmountIn may be non-zero)\n     */\n    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal sameBlock {\n        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one be zero\");\n\n        RedeemLocalVars memory vars;\n\n        /* exchangeRate = invoke Exchange Rate Stored() */\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n        require(vars.mathErr == MathError.NO_ERROR, 'calc exchangerate error');\n\n        /* If redeemTokensIn > 0: */\n        if (redeemTokensIn > 0) {\n            /*\n             * We calculate the exchange rate and the amount of underlying to be redeemed:\n             *  redeemTokens = redeemTokensIn\n             *  redeemAmount = redeemTokensIn x exchangeRateCurrent\n             */\n            vars.redeemTokens = redeemTokensIn;\n\n            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa : vars.exchangeRateMantissa}), redeemTokensIn);\n            require(vars.mathErr == MathError.NO_ERROR, 'calc redeem amount error');\n        } else {\n            /*\n             * We get the current exchange rate and calculate the amount to be redeemed:\n             *  redeemTokens = redeemAmountIn / exchangeRate\n             *  redeemAmount = redeemAmountIn\n             */\n\n            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa : vars.exchangeRateMantissa}));\n            require(vars.mathErr == MathError.NO_ERROR, 'calc redeem tokens error');\n            vars.redeemAmount = redeemAmountIn;\n        }\n\n        /* Fail if redeem not allowed */\n        (ControllerInterface(controller)).redeemAllowed(address(this), redeemer, vars.redeemTokens);\n\n        /*\n         * We calculate the new total supply and redeemer balance, checking for underflow:\n         *  totalSupplyNew = totalSupply - redeemTokens\n         *  accountTokensNew = accountTokens[redeemer] - redeemTokens\n         */\n        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);\n        require(vars.mathErr == MathError.NO_ERROR, 'calc supply new error');\n\n        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);\n        require(vars.mathErr == MathError.NO_ERROR, 'calc token new error');\n        require(getCashPrior() >= vars.redeemAmount, 'cash < redeem');\n\n        /*\n         * We invoke doTransferOut for the redeemer and the redeemAmount.\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n         *  On success, the cToken has redeemAmount less of cash.\n         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n         */\n        doTransferOut(redeemer, vars.redeemAmount, true);\n        /* We write previously calculated values into storage */\n        totalSupply = vars.totalSupplyNew;\n        accountTokens[redeemer] = vars.accountTokensNew;\n\n        /* We emit a Transfer event, and a Redeem event */\n        emit Transfer(redeemer, address(this), vars.redeemTokens);\n        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);\n\n        /* We call the defense hook */\n    }\n\n    struct BorrowLocalVars {\n        MathError mathErr;\n        uint accountBorrows;\n        uint accountBorrowsNew;\n        uint totalBorrowsNew;\n    }\n\n    /**\n      * Users borrow assets from the protocol to their own address\n      * @param borrowAmount The amount of the underlying asset to borrow\n      */\n    //SWC-107-Reentrancy: L845-L885\n    function borrowFresh(address payable borrower, address payable payee, uint borrowAmount) internal sameBlock {\n        /* Fail if borrow not allowed */\n        (ControllerInterface(controller)).borrowAllowed(address(this), borrower, payee, borrowAmount);\n\n        /* Fail gracefully if protocol has insufficient underlying cash */\n        require(getCashPrior() >= borrowAmount, 'cash<borrow');\n\n        BorrowLocalVars memory vars;\n\n        /*\n         * We calculate the new borrower and total borrow balances, failing on overflow:\n         *  accountBorrowsNew = accountBorrows + borrowAmount\n         *  totalBorrowsNew = totalBorrows + borrowAmount\n         */\n        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);\n        require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrows error');\n\n        (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);\n        require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrows error');\n\n        (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);\n        require(vars.mathErr == MathError.NO_ERROR, 'calc total borrows error');\n\n        /*\n         * We invoke doTransferOut for the borrower and the borrowAmount.\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n         *  On success, the cToken borrowAmount less of cash.\n         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n         */\n        doTransferOut(payee, borrowAmount, false);\n\n        /* We write the previously calculated values into storage */\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\n        accountBorrows[borrower].interestIndex = borrowIndex;\n        totalBorrows = vars.totalBorrowsNew;\n\n        /* We emit a Borrow event */\n        emit Borrow(borrower, payee, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\n\n        /* We call the defense hook */\n    }\n\n    struct RepayBorrowLocalVars {\n        MathError mathErr;\n        uint repayAmount;\n        uint borrowerIndex;\n        uint accountBorrows;\n        uint accountBorrowsNew;\n        uint totalBorrowsNew;\n        uint actualRepayAmount;\n    }\n\n    /**\n     * Borrows are repaid by another user (possibly the borrower).\n     * @param payer the account paying off the borrow\n     * @param borrower the account with the debt being payed off\n     * @param repayAmount the amount of undelrying tokens being returned\n     */\n    function repayBorrowFresh(address payer, address borrower, uint repayAmount, bool isEnd) internal sameBlock returns (uint) {\n        /* Fail if repayBorrow not allowed */\n        (ControllerInterface(controller)).repayBorrowAllowed(address(this), payer, borrower, repayAmount, isEnd);\n\n        RepayBorrowLocalVars memory vars;\n\n        /* We remember the original borrowerIndex for verification purposes */\n        vars.borrowerIndex = accountBorrows[borrower].interestIndex;\n\n        /* We fetch the amount the borrower owes, with accumulated interest */\n        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);\n        require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrow error');\n\n        /* If repayAmount == -1, repayAmount = accountBorrows */\n        if (repayAmount == uint(- 1)) {\n            vars.repayAmount = vars.accountBorrows;\n        } else {\n            vars.repayAmount = repayAmount;\n        }\n\n        /*\n         * We call doTransferIn for the payer and the repayAmount\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n         *  On success, the cToken holds an additional repayAmount of cash.\n         *  doTransferIn reverts if anything goes wrong, since we can't be sure if side effects occurred.\n         *   it returns the amount actually transferred, in case of a fee.\n         */\n        vars.actualRepayAmount = doTransferIn(payer, vars.repayAmount, false);\n\n        if (isEnd) {\n            vars.actualRepayAmount = vars.accountBorrows;\n        }\n        /*\n         * We calculate the new borrower and total borrow balances, failing on underflow:\n         *  accountBorrowsNew = accountBorrows - actualRepayAmount\n         *  totalBorrowsNew = totalBorrows - actualRepayAmount\n         */\n        (vars.mathErr, vars.accountBorrowsNew) = subUInt(vars.accountBorrows, vars.actualRepayAmount);\n\n        require(vars.mathErr == MathError.NO_ERROR, \"calc acc borrows error\");\n        //Avoid mantissa errors\n        if (vars.actualRepayAmount > totalBorrows) {\n            vars.totalBorrowsNew = 0;\n        } else {\n            vars.totalBorrowsNew = totalBorrows - vars.actualRepayAmount;\n        }\n\n        /* We write the previously calculated values into storage */\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\n        accountBorrows[borrower].interestIndex = borrowIndex;\n        totalBorrows = vars.totalBorrowsNew;\n\n        /* We emit a RepayBorrow event */\n        emit RepayBorrow(payer, borrower, vars.actualRepayAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\n\n        /* We call the defense hook */\n\n        return vars.actualRepayAmount;\n    }\n\n    /*** Admin Functions ***/\n\n    /**\n      * Sets a new CONTROLLER for the market\n      * @dev Admin function to set a new controller\n      */\n    function setController(address newController) external override onlyAdmin {\n        address oldController = controller;\n\n        controller = newController;\n        // Emit NewController(oldController, newController)\n        emit NewController(oldController, newController);\n    }\n\n    function setBorrowCapFactorMantissa(uint newBorrowCapFactorMantissa) external override onlyAdmin {\n        borrowCapFactorMantissa = newBorrowCapFactorMantissa;\n    }\n\n    function setInterestParams(uint baseRatePerBlock_, uint multiplierPerBlock_, uint jumpMultiplierPerBlock_, uint kink_) external override onlyAdmin {\n        //accrueInterest except first\n        if (baseRatePerBlock != 0) {\n            accrueInterest();\n        }\n        baseRatePerBlock = baseRatePerBlock_;\n        multiplierPerBlock = multiplierPerBlock_;\n        jumpMultiplierPerBlock = jumpMultiplierPerBlock_;\n        kink = kink_;\n        emit NewInterestParam(baseRatePerBlock_, multiplierPerBlock_, jumpMultiplierPerBlock_, kink_);\n    }\n\n    function setReserveFactor(uint newReserveFactorMantissa) external override onlyAdmin {\n        accrueInterest();\n        uint oldReserveFactorMantissa = reserveFactorMantissa;\n        reserveFactorMantissa = newReserveFactorMantissa;\n        emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);\n    }\n\n    function addReserves(uint addAmount) external override {\n        accrueInterest();\n        uint totalReservesNew;\n        uint actualAddAmount;\n        actualAddAmount = doTransferIn(msg.sender, addAmount, true);\n        totalReservesNew = totalReserves.add(actualAddAmount);\n        totalReserves = totalReservesNew;\n        emit ReservesAdded(msg.sender, actualAddAmount, totalReservesNew);\n    }\n\n    function reduceReserves(address payable to, uint reduceAmount) external override onlyAdmin {\n        accrueInterest();\n        uint totalReservesNew;\n        totalReservesNew = totalReserves.sub(reduceAmount);\n        totalReserves = totalReservesNew;\n        doTransferOut(to, reduceAmount, true);\n        emit ReservesReduced(to, reduceAmount, totalReservesNew);\n    }\n\n    modifier sameBlock() {\n        require(accrualBlockNumber == getBlockNumber(), 'not same block');\n        _;\n    }\n\n}",
        "function": "repayBorrowBehalf(address,uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/PeckShield-OpenLeverage1.0/openleverage-contracts-e31d971bcb38ec8737cf1942b8fdf6a9452e5834/contracts/liquidity/LPool.sol",
        "vulnerability": "Dependence on predictable environment variable (SWC 120)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract LPool is DelegateInterface, Adminable, LPoolInterface, Exponential, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint;\n\n    constructor() {\n\n    }\n    /**\n     * Initialize the money market\n     * @param controller_ The address of the Controller\n     * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18\n     * @param name_ EIP-20 name of this token\n     * @param symbol_ EIP-20 symbol of this token\n     * @param decimals_ EIP-20 decimal precision of this token\n     */\n    function initialize(\n        address underlying_,\n        bool isWethPool_,\n        address controller_,\n        uint256 baseRatePerBlock_,\n        uint256 multiplierPerBlock_,\n        uint256 jumpMultiplierPerBlock_,\n        uint256 kink_,\n        uint initialExchangeRateMantissa_,\n        string memory name_,\n        string memory symbol_,\n        uint8 decimals_) public {\n        require(underlying_ != address(0), \"underlying_ address cannot be 0\");\n        require(controller_ != address(0), \"controller_ address cannot be 0\");\n        require(msg.sender == admin, \"Only allow to be called by admin\");\n        require(accrualBlockNumber == 0 && borrowIndex == 0, \"inited once\");\n\n        // Set initial exchange rate\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\n        require(initialExchangeRateMantissa > 0, \"Initial Exchange Rate Mantissa should be greater zero\");\n        //set controller\n        controller = controller_;\n        isWethPool = isWethPool_;\n        //set interestRateModel\n        baseRatePerBlock = baseRatePerBlock_;\n        multiplierPerBlock = multiplierPerBlock_;\n        jumpMultiplierPerBlock = jumpMultiplierPerBlock_;\n        kink = kink_;\n\n        // Initialize block number and borrow index (block number mocks depend on controller being set)\n        accrualBlockNumber = getBlockNumber();\n        borrowIndex = 1e25;\n        //80%\n        borrowCapFactorMantissa = 0.8e18;\n        //20%\n        reserveFactorMantissa = 0.2e18;\n\n\n        name = name_;\n        symbol = symbol_;\n        decimals = decimals_;\n\n        _notEntered = true;\n\n        // Set underlying and sanity check it\n        underlying = underlying_;\n        IERC20(underlying).totalSupply();\n    }\n\n    /**\n     * Transfer `tokens` tokens from `src` to `dst` by `spender`\n     * @dev Called by both `transfer` and `transferFrom` internally\n     * @param spender The address of the account performing the transfer\n     * @param src The address of the source account\n     * @param dst The address of the destination account\n     * @param tokens The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     */\n    function transferTokens(address spender, address src, address dst, uint tokens) internal returns (bool) {\n        require(dst != address(0), \"dst address cannot be 0\");\n        /* Do not allow self-transfers */\n        require(src != dst, \"src = dst\");\n        /* Fail if transfer not allowed */\n        (ControllerInterface(controller)).transferAllowed(address(this), src, dst, tokens);\n\n        /* Get the allowance, infinite for the account owner */\n        uint startingAllowance = 0;\n        if (spender == src) {\n            startingAllowance = uint(- 1);\n        } else {\n            startingAllowance = transferAllowances[src][spender];\n        }\n\n        /* Do the calculations, checking for {under,over}flow */\n        MathError mathErr;\n        uint allowanceNew;\n        uint srcTokensNew;\n        uint dstTokensNew;\n\n        (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);\n        require(mathErr == MathError.NO_ERROR, 'not allowed');\n\n        (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);\n        require(mathErr == MathError.NO_ERROR, 'not enough');\n\n        (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);\n        require(mathErr == MathError.NO_ERROR, 'too much');\n\n        accountTokens[src] = srcTokensNew;\n        accountTokens[dst] = dstTokensNew;\n\n        /* Eat some of the allowance (if necessary) */\n        if (startingAllowance != uint(- 1)) {\n            transferAllowances[src][spender] = allowanceNew;\n        }\n        /* We emit a Transfer event */\n        emit Transfer(src, dst, tokens);\n        return true;\n    }\n\n    /**\n     * Transfer `amount` tokens from `msg.sender` to `dst`\n     * @param dst The address of the destination account\n     * @param amount The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     */\n    function transfer(address dst, uint256 amount) external override nonReentrant returns (bool) {\n        return transferTokens(msg.sender, msg.sender, dst, amount);\n    }\n\n    /**\n     * Transfer `amount` tokens from `src` to `dst`\n     * @param src The address of the source account\n     * @param dst The address of the destination account\n     * @param amount The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     */\n    function transferFrom(address src, address dst, uint256 amount) external override nonReentrant returns (bool) {\n        return transferTokens(msg.sender, src, dst, amount);\n    }\n\n    /**\n     * Approve `spender` to transfer up to `amount` from `src`\n     * @dev This will overwrite the approval amount for `spender`\n     *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n     * @param spender The address of the account which may transfer tokens\n     * @param amount The number of tokens that are approved (-1 means infinite)\n     * @return Whether or not the approval succeeded\n     */\n    function approve(address spender, uint256 amount) external override returns (bool) {\n        address src = msg.sender;\n        transferAllowances[src][spender] = amount;\n        emit Approval(src, spender, amount);\n        return true;\n    }\n\n    /**\n     * Get the current allowance from `owner` for `spender`\n     * @param owner The address of the account which owns the tokens to be spent\n     * @param spender The address of the account which may transfer tokens\n     * @return The number of tokens allowed to be spent (-1 means infinite)\n     */\n    function allowance(address owner, address spender) external override view returns (uint256) {\n        return transferAllowances[owner][spender];\n    }\n\n    /**\n     * Get the token balance of the `owner`\n     * @param owner The address of the account to query\n     * @return The number of tokens owned by `owner`\n     */\n    function balanceOf(address owner) external override view returns (uint256) {\n        return accountTokens[owner];\n    }\n\n    /**\n     * Get the underlying balance of the `owner`\n     * @dev This also accrues interest in a transaction\n     * @param owner The address of the account to query\n     * @return The amount of underlying owned by `owner`\n     */\n    function balanceOfUnderlying(address owner) external override returns (uint) {\n        Exp memory exchangeRate = Exp({mantissa : exchangeRateCurrent()});\n        (MathError mErr, uint balance) = mulScalarTruncate(exchangeRate, accountTokens[owner]);\n        require(mErr == MathError.NO_ERROR, \"calc failed\");\n        return balance;\n    }\n\n    /*** User Interface ***/\n\n    /**\n     * Sender supplies assets into the market and receives lTokens in exchange\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param mintAmount The amount of the underlying asset to supply\n     */\n    function mint(uint mintAmount) external override nonReentrant {\n        accrueInterest();\n        // mintFresh emits the actual Mint event if successful and logs on errors, so we don't need to\n        mintFresh(msg.sender, mintAmount);\n    }\n\n    function mintEth() external payable override nonReentrant {\n        require(isWethPool, \"not eth pool\");\n        accrueInterest();\n        mintFresh(msg.sender, msg.value);\n    }\n\n    /**\n     * Sender redeems lTokens in exchange for the underlying asset\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param redeemTokens The number of lTokens to redeem into underlying\n     */\n    function redeem(uint redeemTokens) external override nonReentrant {\n        accrueInterest();\n        // redeemFresh emits redeem-specific logs on errors, so we don't need to\n        redeemFresh(msg.sender, redeemTokens, 0);\n    }\n\n    /**\n     * Sender redeems lTokens in exchange for a specified amount of underlying asset\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param redeemAmount The amount of underlying to redeem\n     */\n    function redeemUnderlying(uint redeemAmount) external override nonReentrant {\n        accrueInterest();\n        // redeemFresh emits redeem-specific logs on errors, so we don't need to\n        redeemFresh(msg.sender, 0, redeemAmount);\n    }\n\n    function borrowBehalf(address borrower, uint borrowAmount) external override nonReentrant {\n        accrueInterest();\n        // borrowFresh emits borrow-specific logs on errors, so we don't need to\n        borrowFresh(payable(borrower), msg.sender, borrowAmount);\n    }\n\n    /**\n     * Sender repays a borrow belonging to borrower\n     * @param borrower the account with the debt being payed off\n     * @param repayAmount The amount to repay\n     */\n    function repayBorrowBehalf(address borrower, uint repayAmount) external override nonReentrant {\n        accrueInterest();\n        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\n        repayBorrowFresh(msg.sender, borrower, repayAmount, false);\n    }\n\n    function repayBorrowEndByOpenLev(address borrower, uint repayAmount) external override nonReentrant {\n        accrueInterest();\n        repayBorrowFresh(msg.sender, borrower, repayAmount, true);\n    }\n\n\n\n    /*** Safe Token ***/\n\n    /**\n     * Gets balance of this contract in terms of the underlying\n     * @dev This excludes the value of the current message, if any\n     * @return The quantity of underlying tokens owned by this contract\n     */\n    function getCashPrior() internal view returns (uint) {\n        IERC20 token = IERC20(underlying);\n        return token.balanceOf(address(this));\n    }\n\n    /**\n     * @dev Similar to EIP20 transfer, except it handles a False result from `transferFrom` and reverts in that case.\n     *      This will revert due to insufficient balance or insufficient allowance.\n     *      This function returns the actual amount received,\n     *      which may be less than `amount` if there is a fee attached to the transfer.\n     *\n     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.\n     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\n     */\n    function doTransferIn(address from, uint amount, bool convertWeth) internal returns (uint) {\n        uint balanceBefore = IERC20(underlying).balanceOf(address(this));\n        if (isWethPool && convertWeth) {\n            IWETH(underlying).deposit{value : msg.value}();\n        } else {\n            IERC20(underlying).transferFrom(from, address(this), amount);\n        }\n        // Calculate the amount that was *actually* transferred\n        uint balanceAfter = IERC20(underlying).balanceOf(address(this));\n        require(balanceAfter >= balanceBefore, \"transfer overflow\");\n        return balanceAfter - balanceBefore;\n    }\n\n    /**\n     * @dev Similar to EIP20 transfer, except it handles a False success from `transfer` and returns an explanatory\n     *      error code rather than reverting. If caller has not called checked protocol's balance, this may revert due to\n     *      insufficient cash held in this contract. If caller has checked protocol's balance prior to this call, and verified\n     *      it is >= amount, this should not revert in normal conditions.\n     *\n     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.\n     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\n     */\n    function doTransferOut(address payable to, uint amount, bool convertWeth) internal {\n        if (isWethPool && convertWeth) {\n            IWETH(underlying).withdraw(amount);\n            to.transfer(amount);\n        } else {\n            IERC20(underlying).safeTransfer(to, amount);\n        }\n    }\n\n    function availableForBorrow() external view override returns (uint){\n        uint cash = getCashPrior();\n        (MathError err0, uint sum) = addThenSubUInt(cash, totalBorrows, totalReserves);\n        if (err0 != MathError.NO_ERROR) {\n            return 0;\n        }\n        (MathError err1, uint maxAvailable) = mulScalarTruncate(Exp({mantissa : sum}), borrowCapFactorMantissa);\n        if (err1 != MathError.NO_ERROR) {\n            return 0;\n        }\n        if (totalBorrows > maxAvailable) {\n            return 0;\n        }\n        return maxAvailable - totalBorrows;\n    }\n\n\n    /**\n     * Get a snapshot of the account's balances, and the cached exchange rate\n     * @dev This is used by controller to more efficiently perform liquidity checks.\n     * @param account Address of the account to snapshot\n     * @return ( token balance, borrow balance, exchange rate mantissa)\n     */\n    function getAccountSnapshot(address account) external override view returns (uint, uint, uint) {\n        uint cTokenBalance = accountTokens[account];\n        uint borrowBalance;\n        uint exchangeRateMantissa;\n\n        MathError mErr;\n\n        (mErr, borrowBalance) = borrowBalanceStoredInternal(account);\n        if (mErr != MathError.NO_ERROR) {\n            return (0, 0, 0);\n        }\n\n        (mErr, exchangeRateMantissa) = exchangeRateStoredInternal();\n        if (mErr != MathError.NO_ERROR) {\n            return (0, 0, 0);\n        }\n\n        return (cTokenBalance, borrowBalance, exchangeRateMantissa);\n    }\n\n    /**\n     * @dev Function to simply retrieve block number\n     *  This exists mainly for inheriting test contracts to stub this result.\n     */\n    function getBlockNumber() internal view returns (uint) {\n        return block.number;\n    }\n\n    /**\n     * Returns the current per-block borrow interest rate for this cToken\n     * @return The borrow interest rate per block, scaled by 1e18\n     */\n    function borrowRatePerBlock() external override view returns (uint) {\n        return getBorrowRateInternal(getCashPrior(), totalBorrows, totalReserves);\n    }\n\n    /**\n     * Returns the current per-block supply interest rate for this cToken\n     * @return The supply interest rate per block, scaled by 1e18\n     */\n    function supplyRatePerBlock() external override view returns (uint) {\n        return getSupplyRateInternal(getCashPrior(), totalBorrows, totalReserves, reserveFactorMantissa);\n    }\n\n    function utilizationRate(uint cash, uint borrows, uint reserves) internal pure returns (uint) {\n        // Utilization rate is 0 when there are no borrows\n        if (borrows == 0) {\n            return 0;\n        }\n        return borrows.mul(1e18).div(cash.add(borrows).sub(reserves));\n    }\n\n    /**\n     * Calculates the current borrow rate per block, with the error code expected by the market\n     * @param cash The amount of cash in the market\n     * @param borrows The amount of borrows in the market\n     * @return The borrow rate percentage per block as a mantissa (scaled by 1e18)\n     */\n    function getBorrowRateInternal(uint cash, uint borrows, uint reserves) internal view returns (uint) {\n        uint util = utilizationRate(cash, borrows, reserves);\n        if (util <= kink) {\n            return util.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);\n        } else {\n            uint normalRate = kink.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);\n            uint excessUtil = util.sub(kink);\n            return excessUtil.mul(jumpMultiplierPerBlock).div(1e18).add(normalRate);\n        }\n    }\n\n    /**\n     * Calculates the current supply rate per block\n     * @param cash The amount of cash in the market\n     * @param borrows The amount of borrows in the market\n     * @return The supply rate percentage per block as a mantissa (scaled by 1e18)\n     */\n    function getSupplyRateInternal(uint cash, uint borrows, uint reserves, uint reserveFactor) internal view returns (uint) {\n        uint oneMinusReserveFactor = uint(1e18).sub(reserveFactor);\n        uint borrowRate = getBorrowRateInternal(cash, borrows, reserves);\n        uint rateToPool = borrowRate.mul(oneMinusReserveFactor).div(1e18);\n        return utilizationRate(cash, borrows, reserves).mul(rateToPool).div(1e18);\n    }\n    /**\n     * Returns the current total borrows plus accrued interest\n     * @return The total borrows with interest\n     */\n    function totalBorrowsCurrent() external override view returns (uint) {\n        /* Remember the initial block number */\n        uint currentBlockNumber = getBlockNumber();\n        uint accrualBlockNumberPrior = accrualBlockNumber;\n\n        /* Short-circuit accumulating 0 interest */\n        if (accrualBlockNumberPrior == currentBlockNumber) {\n            return totalBorrows;\n        }\n\n        /* Read the previous values out of storage */\n        uint cashPrior = getCashPrior();\n        uint borrowsPrior = totalBorrows;\n        uint reservesPrior = totalReserves;\n\n        /* Calculate the current borrow interest rate */\n        uint borrowRateMantissa = getBorrowRateInternal(cashPrior, borrowsPrior, reservesPrior);\n        require(borrowRateMantissa <= borrowRateMaxMantissa, \"borrower rate higher\");\n\n        /* Calculate the number of blocks elapsed since the last accrual */\n        (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);\n        require(mathErr == MathError.NO_ERROR, \"calc block delta erro\");\n\n        Exp memory simpleInterestFactor;\n        uint interestAccumulated;\n        uint totalBorrowsNew;\n\n        (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);\n        require(mathErr == MathError.NO_ERROR, 'calc interest factor error');\n\n        (mathErr, interestAccumulated) = mulScalarTruncate(simpleInterestFactor, borrowsPrior);\n        require(mathErr == MathError.NO_ERROR, 'calc interest acc error');\n\n        (mathErr, totalBorrowsNew) = addUInt(interestAccumulated, borrowsPrior);\n        require(mathErr == MathError.NO_ERROR, 'calc total borrows error');\n\n        return totalBorrowsNew;\n    }\n    /**\n     * Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex\n     * @param account The address whose balance should be calculated after updating borrowIndex\n     * @return The calculated balance\n     */\n    function borrowBalanceCurrent(address account) external view override returns (uint) {\n        (MathError err0, uint borrowIndex) = calCurrentBorrowIndex();\n        require(err0 == MathError.NO_ERROR, \"calc borrow index fail\");\n        (MathError err1, uint result) = borrowBalanceStoredInternalWithBorrowerIndex(account, borrowIndex);\n        require(err1 == MathError.NO_ERROR, \"calc fail\");\n        return result;\n    }\n\n    function borrowBalanceStored(address account) external override view returns (uint){\n        return accountBorrows[account].principal;\n    }\n\n\n    /**\n     * Return the borrow balance of account based on stored data\n     * @param account The address whose balance should be calculated\n     * @return (error code, the calculated balance or 0 if error code is non-zero)\n     */\n    function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {\n        return borrowBalanceStoredInternalWithBorrowerIndex(account, borrowIndex);\n    }\n    /**\n     * Return the borrow balance of account based on stored data\n     * @param account The address whose balance should be calculated\n     * @return (error code, the calculated balance or 0 if error code is non-zero)\n     */\n    function borrowBalanceStoredInternalWithBorrowerIndex(address account, uint borrowIndex) internal view returns (MathError, uint) {\n        /* Note: we do not assert that the market is up to date */\n        MathError mathErr;\n        uint principalTimesIndex;\n        uint result;\n\n        /* Get borrowBalance and borrowIndex */\n        BorrowSnapshot storage borrowSnapshot = accountBorrows[account];\n\n        /* If borrowBalance = 0 then borrowIndex is likely also 0.\n         * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.\n         */\n        if (borrowSnapshot.principal == 0) {\n            return (MathError.NO_ERROR, 0);\n        }\n\n        /* Calculate new borrow balance using the interest index:\n         *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex\n         */\n        (mathErr, principalTimesIndex) = mulUInt(borrowSnapshot.principal, borrowIndex);\n        if (mathErr != MathError.NO_ERROR) {\n            return (mathErr, 0);\n        }\n\n        (mathErr, result) = divUInt(principalTimesIndex, borrowSnapshot.interestIndex);\n        if (mathErr != MathError.NO_ERROR) {\n            return (mathErr, 0);\n        }\n\n        return (MathError.NO_ERROR, result);\n    }\n    /**\n     * Accrue interest then return the up-to-date exchange rate\n     * @return Calculated exchange rate scaled by 1e18\n     */\n    function exchangeRateCurrent() public override nonReentrant returns (uint) {\n        accrueInterest();\n        return exchangeRateStored();\n    }\n\n    /**\n     * Calculates the exchange rate from the underlying to the LToken\n     * @dev This function does not accrue interest before calculating the exchange rate\n     * @return Calculated exchange rate scaled by 1e18\n     */\n    function exchangeRateStored() public override view returns (uint) {\n        (MathError err, uint result) = exchangeRateStoredInternal();\n        require(err == MathError.NO_ERROR, \"calc fail\");\n        return result;\n    }\n\n    /**\n     * Calculates the exchange rate from the underlying to the LToken\n     * @dev This function does not accrue interest before calculating the exchange rate\n     * @return (error code, calculated exchange rate scaled by 1e18)\n     */\n    function exchangeRateStoredInternal() internal view returns (MathError, uint) {\n        uint _totalSupply = totalSupply;\n        if (_totalSupply == 0) {\n            /*\n             * If there are no tokens minted:\n             *  exchangeRate = initialExchangeRate\n             */\n            return (MathError.NO_ERROR, initialExchangeRateMantissa);\n        } else {\n            /*\n             * Otherwise:\n             *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply\n             */\n            uint totalCash = getCashPrior();\n            uint cashPlusBorrowsMinusReserves;\n            Exp memory exchangeRate;\n            MathError mathErr;\n\n            (mathErr, cashPlusBorrowsMinusReserves) = addThenSubUInt(totalCash, totalBorrows, totalReserves);\n            if (mathErr != MathError.NO_ERROR) {\n                return (mathErr, 0);\n            }\n\n            (mathErr, exchangeRate) = getExp(cashPlusBorrowsMinusReserves, _totalSupply);\n            if (mathErr != MathError.NO_ERROR) {\n                return (mathErr, 0);\n            }\n\n            return (MathError.NO_ERROR, exchangeRate.mantissa);\n        }\n    }\n\n    /**\n     * Get cash balance of this cToken in the underlying asset\n     * @return The quantity of underlying asset owned by this contract\n     */\n    function getCash() external override view returns (uint) {\n        return getCashPrior();\n    }\n\n    function calCurrentBorrowIndex() internal view returns (MathError, uint) {\n        /* Remember the initial block number */\n        uint currentBlockNumber = getBlockNumber();\n        uint accrualBlockNumberPrior = accrualBlockNumber;\n        uint borrowIndexNew;\n        /* Short-circuit accumulating 0 interest */\n        if (accrualBlockNumberPrior == currentBlockNumber) {\n            return (MathError.NO_ERROR, borrowIndex);\n        }\n        uint borrowRateMantissa = getBorrowRateInternal(getCashPrior(), totalBorrows, totalReserves);\n        (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);\n\n        Exp memory simpleInterestFactor;\n        (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);\n        if (mathErr != MathError.NO_ERROR) {\n            return (mathErr, 0);\n        }\n        (mathErr, borrowIndexNew) = mulScalarTruncateAddUInt(simpleInterestFactor, borrowIndex, borrowIndex);\n        return (mathErr, borrowIndexNew);\n    }\n\n    /**\n     * Applies accrued interest to total borrows and reserves\n     * @dev This calculates interest accrued from the last checkpointed block\n     *   up to the current block and writes new checkpoint to storage.\n     */\n    function accrueInterest() public override {\n        /* Remember the initial block number */\n        uint currentBlockNumber = getBlockNumber();\n        uint accrualBlockNumberPrior = accrualBlockNumber;\n\n        /* Short-circuit accumulating 0 interest */\n        if (accrualBlockNumberPrior == currentBlockNumber) {\n            return;\n        }\n\n        /* Read the previous values out of storage */\n        uint cashPrior = getCashPrior();\n        uint borrowsPrior = totalBorrows;\n        uint borrowIndexPrior = borrowIndex;\n        uint reservesPrior = totalReserves;\n\n        /* Calculate the current borrow interest rate */\n        uint borrowRateMantissa = getBorrowRateInternal(cashPrior, borrowsPrior, reservesPrior);\n        require(borrowRateMantissa <= borrowRateMaxMantissa, \"borrower rate higher\");\n\n        /* Calculate the number of blocks elapsed since the last accrual */\n        (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);\n        require(mathErr == MathError.NO_ERROR, \"calc block delta erro\");\n\n\n        /*\n         * Calculate the interest accumulated into borrows and reserves and the new index:\n         *  simpleInterestFactor = borrowRate * blockDelta\n         *  interestAccumulated = simpleInterestFactor * totalBorrows\n         *  totalBorrowsNew = interestAccumulated + totalBorrows\n         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex\n         */\n\n        Exp memory simpleInterestFactor;\n        uint interestAccumulated;\n        uint totalBorrowsNew;\n        uint borrowIndexNew;\n        uint totalReservesNew;\n\n        (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);\n        require(mathErr == MathError.NO_ERROR, 'calc interest factor error');\n\n        (mathErr, interestAccumulated) = mulScalarTruncate(simpleInterestFactor, borrowsPrior);\n        require(mathErr == MathError.NO_ERROR, 'calc interest acc error');\n\n        (mathErr, totalBorrowsNew) = addUInt(interestAccumulated, borrowsPrior);\n        require(mathErr == MathError.NO_ERROR, 'calc total borrows error');\n\n        (mathErr, totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa : reserveFactorMantissa}), interestAccumulated, reservesPrior);\n        require(mathErr == MathError.NO_ERROR, 'calc total reserves error');\n\n        (mathErr, borrowIndexNew) = mulScalarTruncateAddUInt(simpleInterestFactor, borrowIndexPrior, borrowIndexPrior);\n        require(mathErr == MathError.NO_ERROR, 'calc borrows index error');\n\n\n        /* We write the previously calculated values into storage */\n        accrualBlockNumber = currentBlockNumber;\n        borrowIndex = borrowIndexNew;\n        totalBorrows = totalBorrowsNew;\n        totalReserves = totalReservesNew;\n\n        /* We emit an AccrueInterest event */\n        emit AccrueInterest(cashPrior, interestAccumulated, borrowIndexNew, totalBorrowsNew);\n\n    }\n\n    struct MintLocalVars {\n        MathError mathErr;\n        uint exchangeRateMantissa;\n        uint mintTokens;\n        uint totalSupplyNew;\n        uint accountTokensNew;\n        uint actualMintAmount;\n    }\n\n    /**\n     * User supplies assets into the market and receives lTokens in exchange\n     * @dev Assumes interest has already been accrued up to the current block\n     * @param minter The address of the account which is supplying the assets\n     * @param mintAmount The amount of the underlying asset to supply\n     * @return uint the actual mint amount.\n     */\n    function mintFresh(address minter, uint mintAmount) internal sameBlock returns (uint) {\n        MintLocalVars memory vars;\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n        require(vars.mathErr == MathError.NO_ERROR, 'calc exchangerate error');\n\n        /*\n         *  We call `doTransferIn` for the minter and the mintAmount.\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n         *  `doTransferIn` reverts if anything goes wrong, since we can't be sure if\n         *  side-effects occurred. The function returns the amount actually transferred,\n         *  in case of a fee. On success, the cToken holds an additional `actualMintAmount`\n         *  of cash.\n         */\n        vars.actualMintAmount = doTransferIn(minter, mintAmount, true);\n\n        /*\n         * We get the current exchange rate and calculate the number of lTokens to be minted:\n         *  mintTokens = actualMintAmount / exchangeRate\n         */\n\n        (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(vars.actualMintAmount, Exp({mantissa : vars.exchangeRateMantissa}));\n        require(vars.mathErr == MathError.NO_ERROR, \"calc mint token error\");\n\n        /* Fail if mint not allowed */\n        (ControllerInterface(controller)).mintAllowed(address(this), minter, vars.mintTokens);\n        /*\n         * We calculate the new total supply of lTokens and minter token balance, checking for overflow:\n         *  totalSupplyNew = totalSupply + mintTokens\n         *  accountTokensNew = accountTokens[minter] + mintTokens\n         */\n        (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);\n        require(vars.mathErr == MathError.NO_ERROR, \"calc supply new failed\");\n\n        (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);\n        require(vars.mathErr == MathError.NO_ERROR, \"calc tokens new ailed\");\n\n        /* We write previously calculated values into storage */\n        totalSupply = vars.totalSupplyNew;\n        accountTokens[minter] = vars.accountTokensNew;\n\n        /* We emit a Mint event, and a Transfer event */\n        emit Mint(minter, vars.actualMintAmount, vars.mintTokens);\n        emit Transfer(address(this), minter, vars.mintTokens);\n\n        /* We call the defense hook */\n\n        return vars.actualMintAmount;\n    }\n\n\n    struct RedeemLocalVars {\n        MathError mathErr;\n        uint exchangeRateMantissa;\n        uint redeemTokens;\n        uint redeemAmount;\n        uint totalSupplyNew;\n        uint accountTokensNew;\n    }\n\n    /**\n     * User redeems lTokens in exchange for the underlying asset\n     * @dev Assumes interest has already been accrued up to the current block\n     * @param redeemer The address of the account which is redeeming the tokens\n     * @param redeemTokensIn The number of lTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be non-zero)\n     * @param redeemAmountIn The number of underlying tokens to receive from redeeming lTokens (only one of redeemTokensIn or redeemAmountIn may be non-zero)\n     */\n    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal sameBlock {\n        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one be zero\");\n\n        RedeemLocalVars memory vars;\n\n        /* exchangeRate = invoke Exchange Rate Stored() */\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n        require(vars.mathErr == MathError.NO_ERROR, 'calc exchangerate error');\n\n        /* If redeemTokensIn > 0: */\n        if (redeemTokensIn > 0) {\n            /*\n             * We calculate the exchange rate and the amount of underlying to be redeemed:\n             *  redeemTokens = redeemTokensIn\n             *  redeemAmount = redeemTokensIn x exchangeRateCurrent\n             */\n            vars.redeemTokens = redeemTokensIn;\n\n            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa : vars.exchangeRateMantissa}), redeemTokensIn);\n            require(vars.mathErr == MathError.NO_ERROR, 'calc redeem amount error');\n        } else {\n            /*\n             * We get the current exchange rate and calculate the amount to be redeemed:\n             *  redeemTokens = redeemAmountIn / exchangeRate\n             *  redeemAmount = redeemAmountIn\n             */\n\n            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa : vars.exchangeRateMantissa}));\n            require(vars.mathErr == MathError.NO_ERROR, 'calc redeem tokens error');\n            vars.redeemAmount = redeemAmountIn;\n        }\n\n        /* Fail if redeem not allowed */\n        (ControllerInterface(controller)).redeemAllowed(address(this), redeemer, vars.redeemTokens);\n\n        /*\n         * We calculate the new total supply and redeemer balance, checking for underflow:\n         *  totalSupplyNew = totalSupply - redeemTokens\n         *  accountTokensNew = accountTokens[redeemer] - redeemTokens\n         */\n        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);\n        require(vars.mathErr == MathError.NO_ERROR, 'calc supply new error');\n\n        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);\n        require(vars.mathErr == MathError.NO_ERROR, 'calc token new error');\n        require(getCashPrior() >= vars.redeemAmount, 'cash < redeem');\n\n        /*\n         * We invoke doTransferOut for the redeemer and the redeemAmount.\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n         *  On success, the cToken has redeemAmount less of cash.\n         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n         */\n        doTransferOut(redeemer, vars.redeemAmount, true);\n        /* We write previously calculated values into storage */\n        totalSupply = vars.totalSupplyNew;\n        accountTokens[redeemer] = vars.accountTokensNew;\n\n        /* We emit a Transfer event, and a Redeem event */\n        emit Transfer(redeemer, address(this), vars.redeemTokens);\n        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);\n\n        /* We call the defense hook */\n    }\n\n    struct BorrowLocalVars {\n        MathError mathErr;\n        uint accountBorrows;\n        uint accountBorrowsNew;\n        uint totalBorrowsNew;\n    }\n\n    /**\n      * Users borrow assets from the protocol to their own address\n      * @param borrowAmount The amount of the underlying asset to borrow\n      */\n    //SWC-107-Reentrancy: L845-L885\n    function borrowFresh(address payable borrower, address payable payee, uint borrowAmount) internal sameBlock {\n        /* Fail if borrow not allowed */\n        (ControllerInterface(controller)).borrowAllowed(address(this), borrower, payee, borrowAmount);\n\n        /* Fail gracefully if protocol has insufficient underlying cash */\n        require(getCashPrior() >= borrowAmount, 'cash<borrow');\n\n        BorrowLocalVars memory vars;\n\n        /*\n         * We calculate the new borrower and total borrow balances, failing on overflow:\n         *  accountBorrowsNew = accountBorrows + borrowAmount\n         *  totalBorrowsNew = totalBorrows + borrowAmount\n         */\n        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);\n        require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrows error');\n\n        (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);\n        require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrows error');\n\n        (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);\n        require(vars.mathErr == MathError.NO_ERROR, 'calc total borrows error');\n\n        /*\n         * We invoke doTransferOut for the borrower and the borrowAmount.\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n         *  On success, the cToken borrowAmount less of cash.\n         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n         */\n        doTransferOut(payee, borrowAmount, false);\n\n        /* We write the previously calculated values into storage */\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\n        accountBorrows[borrower].interestIndex = borrowIndex;\n        totalBorrows = vars.totalBorrowsNew;\n\n        /* We emit a Borrow event */\n        emit Borrow(borrower, payee, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\n\n        /* We call the defense hook */\n    }\n\n    struct RepayBorrowLocalVars {\n        MathError mathErr;\n        uint repayAmount;\n        uint borrowerIndex;\n        uint accountBorrows;\n        uint accountBorrowsNew;\n        uint totalBorrowsNew;\n        uint actualRepayAmount;\n    }\n\n    /**\n     * Borrows are repaid by another user (possibly the borrower).\n     * @param payer the account paying off the borrow\n     * @param borrower the account with the debt being payed off\n     * @param repayAmount the amount of undelrying tokens being returned\n     */\n    function repayBorrowFresh(address payer, address borrower, uint repayAmount, bool isEnd) internal sameBlock returns (uint) {\n        /* Fail if repayBorrow not allowed */\n        (ControllerInterface(controller)).repayBorrowAllowed(address(this), payer, borrower, repayAmount, isEnd);\n\n        RepayBorrowLocalVars memory vars;\n\n        /* We remember the original borrowerIndex for verification purposes */\n        vars.borrowerIndex = accountBorrows[borrower].interestIndex;\n\n        /* We fetch the amount the borrower owes, with accumulated interest */\n        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);\n        require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrow error');\n\n        /* If repayAmount == -1, repayAmount = accountBorrows */\n        if (repayAmount == uint(- 1)) {\n            vars.repayAmount = vars.accountBorrows;\n        } else {\n            vars.repayAmount = repayAmount;\n        }\n\n        /*\n         * We call doTransferIn for the payer and the repayAmount\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n         *  On success, the cToken holds an additional repayAmount of cash.\n         *  doTransferIn reverts if anything goes wrong, since we can't be sure if side effects occurred.\n         *   it returns the amount actually transferred, in case of a fee.\n         */\n        vars.actualRepayAmount = doTransferIn(payer, vars.repayAmount, false);\n\n        if (isEnd) {\n            vars.actualRepayAmount = vars.accountBorrows;\n        }\n        /*\n         * We calculate the new borrower and total borrow balances, failing on underflow:\n         *  accountBorrowsNew = accountBorrows - actualRepayAmount\n         *  totalBorrowsNew = totalBorrows - actualRepayAmount\n         */\n        (vars.mathErr, vars.accountBorrowsNew) = subUInt(vars.accountBorrows, vars.actualRepayAmount);\n\n        require(vars.mathErr == MathError.NO_ERROR, \"calc acc borrows error\");\n        //Avoid mantissa errors\n        if (vars.actualRepayAmount > totalBorrows) {\n            vars.totalBorrowsNew = 0;\n        } else {\n            vars.totalBorrowsNew = totalBorrows - vars.actualRepayAmount;\n        }\n\n        /* We write the previously calculated values into storage */\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\n        accountBorrows[borrower].interestIndex = borrowIndex;\n        totalBorrows = vars.totalBorrowsNew;\n\n        /* We emit a RepayBorrow event */\n        emit RepayBorrow(payer, borrower, vars.actualRepayAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\n\n        /* We call the defense hook */\n\n        return vars.actualRepayAmount;\n    }\n\n    /*** Admin Functions ***/\n\n    /**\n      * Sets a new CONTROLLER for the market\n      * @dev Admin function to set a new controller\n      */\n    function setController(address newController) external override onlyAdmin {\n        address oldController = controller;\n\n        controller = newController;\n        // Emit NewController(oldController, newController)\n        emit NewController(oldController, newController);\n    }\n\n    function setBorrowCapFactorMantissa(uint newBorrowCapFactorMantissa) external override onlyAdmin {\n        borrowCapFactorMantissa = newBorrowCapFactorMantissa;\n    }\n\n    function setInterestParams(uint baseRatePerBlock_, uint multiplierPerBlock_, uint jumpMultiplierPerBlock_, uint kink_) external override onlyAdmin {\n        //accrueInterest except first\n        if (baseRatePerBlock != 0) {\n            accrueInterest();\n        }\n        baseRatePerBlock = baseRatePerBlock_;\n        multiplierPerBlock = multiplierPerBlock_;\n        jumpMultiplierPerBlock = jumpMultiplierPerBlock_;\n        kink = kink_;\n        emit NewInterestParam(baseRatePerBlock_, multiplierPerBlock_, jumpMultiplierPerBlock_, kink_);\n    }\n\n    function setReserveFactor(uint newReserveFactorMantissa) external override onlyAdmin {\n        accrueInterest();\n        uint oldReserveFactorMantissa = reserveFactorMantissa;\n        reserveFactorMantissa = newReserveFactorMantissa;\n        emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);\n    }\n\n    function addReserves(uint addAmount) external override {\n        accrueInterest();\n        uint totalReservesNew;\n        uint actualAddAmount;\n        actualAddAmount = doTransferIn(msg.sender, addAmount, true);\n        totalReservesNew = totalReserves.add(actualAddAmount);\n        totalReserves = totalReservesNew;\n        emit ReservesAdded(msg.sender, actualAddAmount, totalReservesNew);\n    }\n\n    function reduceReserves(address payable to, uint reduceAmount) external override onlyAdmin {\n        accrueInterest();\n        uint totalReservesNew;\n        totalReservesNew = totalReserves.sub(reduceAmount);\n        totalReserves = totalReservesNew;\n        doTransferOut(to, reduceAmount, true);\n        emit ReservesReduced(to, reduceAmount, totalReservesNew);\n    }\n\n    modifier sameBlock() {\n        require(accrualBlockNumber == getBlockNumber(), 'not same block');\n        _;\n    }\n\n}",
        "function": "borrowBalanceCurrent(address)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/PeckShield-OpenLeverage1.0/openleverage-contracts-e31d971bcb38ec8737cf1942b8fdf6a9452e5834/contracts/liquidity/LPool.sol",
        "vulnerability": "Dependence on predictable environment variable (SWC 120)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract LPool is DelegateInterface, Adminable, LPoolInterface, Exponential, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint;\n\n    constructor() {\n\n    }\n    /**\n     * Initialize the money market\n     * @param controller_ The address of the Controller\n     * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18\n     * @param name_ EIP-20 name of this token\n     * @param symbol_ EIP-20 symbol of this token\n     * @param decimals_ EIP-20 decimal precision of this token\n     */\n    function initialize(\n        address underlying_,\n        bool isWethPool_,\n        address controller_,\n        uint256 baseRatePerBlock_,\n        uint256 multiplierPerBlock_,\n        uint256 jumpMultiplierPerBlock_,\n        uint256 kink_,\n        uint initialExchangeRateMantissa_,\n        string memory name_,\n        string memory symbol_,\n        uint8 decimals_) public {\n        require(underlying_ != address(0), \"underlying_ address cannot be 0\");\n        require(controller_ != address(0), \"controller_ address cannot be 0\");\n        require(msg.sender == admin, \"Only allow to be called by admin\");\n        require(accrualBlockNumber == 0 && borrowIndex == 0, \"inited once\");\n\n        // Set initial exchange rate\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\n        require(initialExchangeRateMantissa > 0, \"Initial Exchange Rate Mantissa should be greater zero\");\n        //set controller\n        controller = controller_;\n        isWethPool = isWethPool_;\n        //set interestRateModel\n        baseRatePerBlock = baseRatePerBlock_;\n        multiplierPerBlock = multiplierPerBlock_;\n        jumpMultiplierPerBlock = jumpMultiplierPerBlock_;\n        kink = kink_;\n\n        // Initialize block number and borrow index (block number mocks depend on controller being set)\n        accrualBlockNumber = getBlockNumber();\n        borrowIndex = 1e25;\n        //80%\n        borrowCapFactorMantissa = 0.8e18;\n        //20%\n        reserveFactorMantissa = 0.2e18;\n\n\n        name = name_;\n        symbol = symbol_;\n        decimals = decimals_;\n\n        _notEntered = true;\n\n        // Set underlying and sanity check it\n        underlying = underlying_;\n        IERC20(underlying).totalSupply();\n    }\n\n    /**\n     * Transfer `tokens` tokens from `src` to `dst` by `spender`\n     * @dev Called by both `transfer` and `transferFrom` internally\n     * @param spender The address of the account performing the transfer\n     * @param src The address of the source account\n     * @param dst The address of the destination account\n     * @param tokens The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     */\n    function transferTokens(address spender, address src, address dst, uint tokens) internal returns (bool) {\n        require(dst != address(0), \"dst address cannot be 0\");\n        /* Do not allow self-transfers */\n        require(src != dst, \"src = dst\");\n        /* Fail if transfer not allowed */\n        (ControllerInterface(controller)).transferAllowed(address(this), src, dst, tokens);\n\n        /* Get the allowance, infinite for the account owner */\n        uint startingAllowance = 0;\n        if (spender == src) {\n            startingAllowance = uint(- 1);\n        } else {\n            startingAllowance = transferAllowances[src][spender];\n        }\n\n        /* Do the calculations, checking for {under,over}flow */\n        MathError mathErr;\n        uint allowanceNew;\n        uint srcTokensNew;\n        uint dstTokensNew;\n\n        (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);\n        require(mathErr == MathError.NO_ERROR, 'not allowed');\n\n        (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);\n        require(mathErr == MathError.NO_ERROR, 'not enough');\n\n        (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);\n        require(mathErr == MathError.NO_ERROR, 'too much');\n\n        accountTokens[src] = srcTokensNew;\n        accountTokens[dst] = dstTokensNew;\n\n        /* Eat some of the allowance (if necessary) */\n        if (startingAllowance != uint(- 1)) {\n            transferAllowances[src][spender] = allowanceNew;\n        }\n        /* We emit a Transfer event */\n        emit Transfer(src, dst, tokens);\n        return true;\n    }\n\n    /**\n     * Transfer `amount` tokens from `msg.sender` to `dst`\n     * @param dst The address of the destination account\n     * @param amount The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     */\n    function transfer(address dst, uint256 amount) external override nonReentrant returns (bool) {\n        return transferTokens(msg.sender, msg.sender, dst, amount);\n    }\n\n    /**\n     * Transfer `amount` tokens from `src` to `dst`\n     * @param src The address of the source account\n     * @param dst The address of the destination account\n     * @param amount The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     */\n    function transferFrom(address src, address dst, uint256 amount) external override nonReentrant returns (bool) {\n        return transferTokens(msg.sender, src, dst, amount);\n    }\n\n    /**\n     * Approve `spender` to transfer up to `amount` from `src`\n     * @dev This will overwrite the approval amount for `spender`\n     *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n     * @param spender The address of the account which may transfer tokens\n     * @param amount The number of tokens that are approved (-1 means infinite)\n     * @return Whether or not the approval succeeded\n     */\n    function approve(address spender, uint256 amount) external override returns (bool) {\n        address src = msg.sender;\n        transferAllowances[src][spender] = amount;\n        emit Approval(src, spender, amount);\n        return true;\n    }\n\n    /**\n     * Get the current allowance from `owner` for `spender`\n     * @param owner The address of the account which owns the tokens to be spent\n     * @param spender The address of the account which may transfer tokens\n     * @return The number of tokens allowed to be spent (-1 means infinite)\n     */\n    function allowance(address owner, address spender) external override view returns (uint256) {\n        return transferAllowances[owner][spender];\n    }\n\n    /**\n     * Get the token balance of the `owner`\n     * @param owner The address of the account to query\n     * @return The number of tokens owned by `owner`\n     */\n    function balanceOf(address owner) external override view returns (uint256) {\n        return accountTokens[owner];\n    }\n\n    /**\n     * Get the underlying balance of the `owner`\n     * @dev This also accrues interest in a transaction\n     * @param owner The address of the account to query\n     * @return The amount of underlying owned by `owner`\n     */\n    function balanceOfUnderlying(address owner) external override returns (uint) {\n        Exp memory exchangeRate = Exp({mantissa : exchangeRateCurrent()});\n        (MathError mErr, uint balance) = mulScalarTruncate(exchangeRate, accountTokens[owner]);\n        require(mErr == MathError.NO_ERROR, \"calc failed\");\n        return balance;\n    }\n\n    /*** User Interface ***/\n\n    /**\n     * Sender supplies assets into the market and receives lTokens in exchange\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param mintAmount The amount of the underlying asset to supply\n     */\n    function mint(uint mintAmount) external override nonReentrant {\n        accrueInterest();\n        // mintFresh emits the actual Mint event if successful and logs on errors, so we don't need to\n        mintFresh(msg.sender, mintAmount);\n    }\n\n    function mintEth() external payable override nonReentrant {\n        require(isWethPool, \"not eth pool\");\n        accrueInterest();\n        mintFresh(msg.sender, msg.value);\n    }\n\n    /**\n     * Sender redeems lTokens in exchange for the underlying asset\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param redeemTokens The number of lTokens to redeem into underlying\n     */\n    function redeem(uint redeemTokens) external override nonReentrant {\n        accrueInterest();\n        // redeemFresh emits redeem-specific logs on errors, so we don't need to\n        redeemFresh(msg.sender, redeemTokens, 0);\n    }\n\n    /**\n     * Sender redeems lTokens in exchange for a specified amount of underlying asset\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param redeemAmount The amount of underlying to redeem\n     */\n    function redeemUnderlying(uint redeemAmount) external override nonReentrant {\n        accrueInterest();\n        // redeemFresh emits redeem-specific logs on errors, so we don't need to\n        redeemFresh(msg.sender, 0, redeemAmount);\n    }\n\n    function borrowBehalf(address borrower, uint borrowAmount) external override nonReentrant {\n        accrueInterest();\n        // borrowFresh emits borrow-specific logs on errors, so we don't need to\n        borrowFresh(payable(borrower), msg.sender, borrowAmount);\n    }\n\n    /**\n     * Sender repays a borrow belonging to borrower\n     * @param borrower the account with the debt being payed off\n     * @param repayAmount The amount to repay\n     */\n    function repayBorrowBehalf(address borrower, uint repayAmount) external override nonReentrant {\n        accrueInterest();\n        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\n        repayBorrowFresh(msg.sender, borrower, repayAmount, false);\n    }\n\n    function repayBorrowEndByOpenLev(address borrower, uint repayAmount) external override nonReentrant {\n        accrueInterest();\n        repayBorrowFresh(msg.sender, borrower, repayAmount, true);\n    }\n\n\n\n    /*** Safe Token ***/\n\n    /**\n     * Gets balance of this contract in terms of the underlying\n     * @dev This excludes the value of the current message, if any\n     * @return The quantity of underlying tokens owned by this contract\n     */\n    function getCashPrior() internal view returns (uint) {\n        IERC20 token = IERC20(underlying);\n        return token.balanceOf(address(this));\n    }\n\n    /**\n     * @dev Similar to EIP20 transfer, except it handles a False result from `transferFrom` and reverts in that case.\n     *      This will revert due to insufficient balance or insufficient allowance.\n     *      This function returns the actual amount received,\n     *      which may be less than `amount` if there is a fee attached to the transfer.\n     *\n     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.\n     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\n     */\n    function doTransferIn(address from, uint amount, bool convertWeth) internal returns (uint) {\n        uint balanceBefore = IERC20(underlying).balanceOf(address(this));\n        if (isWethPool && convertWeth) {\n            IWETH(underlying).deposit{value : msg.value}();\n        } else {\n            IERC20(underlying).transferFrom(from, address(this), amount);\n        }\n        // Calculate the amount that was *actually* transferred\n        uint balanceAfter = IERC20(underlying).balanceOf(address(this));\n        require(balanceAfter >= balanceBefore, \"transfer overflow\");\n        return balanceAfter - balanceBefore;\n    }\n\n    /**\n     * @dev Similar to EIP20 transfer, except it handles a False success from `transfer` and returns an explanatory\n     *      error code rather than reverting. If caller has not called checked protocol's balance, this may revert due to\n     *      insufficient cash held in this contract. If caller has checked protocol's balance prior to this call, and verified\n     *      it is >= amount, this should not revert in normal conditions.\n     *\n     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.\n     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\n     */\n    function doTransferOut(address payable to, uint amount, bool convertWeth) internal {\n        if (isWethPool && convertWeth) {\n            IWETH(underlying).withdraw(amount);\n            to.transfer(amount);\n        } else {\n            IERC20(underlying).safeTransfer(to, amount);\n        }\n    }\n\n    function availableForBorrow() external view override returns (uint){\n        uint cash = getCashPrior();\n        (MathError err0, uint sum) = addThenSubUInt(cash, totalBorrows, totalReserves);\n        if (err0 != MathError.NO_ERROR) {\n            return 0;\n        }\n        (MathError err1, uint maxAvailable) = mulScalarTruncate(Exp({mantissa : sum}), borrowCapFactorMantissa);\n        if (err1 != MathError.NO_ERROR) {\n            return 0;\n        }\n        if (totalBorrows > maxAvailable) {\n            return 0;\n        }\n        return maxAvailable - totalBorrows;\n    }\n\n\n    /**\n     * Get a snapshot of the account's balances, and the cached exchange rate\n     * @dev This is used by controller to more efficiently perform liquidity checks.\n     * @param account Address of the account to snapshot\n     * @return ( token balance, borrow balance, exchange rate mantissa)\n     */\n    function getAccountSnapshot(address account) external override view returns (uint, uint, uint) {\n        uint cTokenBalance = accountTokens[account];\n        uint borrowBalance;\n        uint exchangeRateMantissa;\n\n        MathError mErr;\n\n        (mErr, borrowBalance) = borrowBalanceStoredInternal(account);\n        if (mErr != MathError.NO_ERROR) {\n            return (0, 0, 0);\n        }\n\n        (mErr, exchangeRateMantissa) = exchangeRateStoredInternal();\n        if (mErr != MathError.NO_ERROR) {\n            return (0, 0, 0);\n        }\n\n        return (cTokenBalance, borrowBalance, exchangeRateMantissa);\n    }\n\n    /**\n     * @dev Function to simply retrieve block number\n     *  This exists mainly for inheriting test contracts to stub this result.\n     */\n    function getBlockNumber() internal view returns (uint) {\n        return block.number;\n    }\n\n    /**\n     * Returns the current per-block borrow interest rate for this cToken\n     * @return The borrow interest rate per block, scaled by 1e18\n     */\n    function borrowRatePerBlock() external override view returns (uint) {\n        return getBorrowRateInternal(getCashPrior(), totalBorrows, totalReserves);\n    }\n\n    /**\n     * Returns the current per-block supply interest rate for this cToken\n     * @return The supply interest rate per block, scaled by 1e18\n     */\n    function supplyRatePerBlock() external override view returns (uint) {\n        return getSupplyRateInternal(getCashPrior(), totalBorrows, totalReserves, reserveFactorMantissa);\n    }\n\n    function utilizationRate(uint cash, uint borrows, uint reserves) internal pure returns (uint) {\n        // Utilization rate is 0 when there are no borrows\n        if (borrows == 0) {\n            return 0;\n        }\n        return borrows.mul(1e18).div(cash.add(borrows).sub(reserves));\n    }\n\n    /**\n     * Calculates the current borrow rate per block, with the error code expected by the market\n     * @param cash The amount of cash in the market\n     * @param borrows The amount of borrows in the market\n     * @return The borrow rate percentage per block as a mantissa (scaled by 1e18)\n     */\n    function getBorrowRateInternal(uint cash, uint borrows, uint reserves) internal view returns (uint) {\n        uint util = utilizationRate(cash, borrows, reserves);\n        if (util <= kink) {\n            return util.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);\n        } else {\n            uint normalRate = kink.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);\n            uint excessUtil = util.sub(kink);\n            return excessUtil.mul(jumpMultiplierPerBlock).div(1e18).add(normalRate);\n        }\n    }\n\n    /**\n     * Calculates the current supply rate per block\n     * @param cash The amount of cash in the market\n     * @param borrows The amount of borrows in the market\n     * @return The supply rate percentage per block as a mantissa (scaled by 1e18)\n     */\n    function getSupplyRateInternal(uint cash, uint borrows, uint reserves, uint reserveFactor) internal view returns (uint) {\n        uint oneMinusReserveFactor = uint(1e18).sub(reserveFactor);\n        uint borrowRate = getBorrowRateInternal(cash, borrows, reserves);\n        uint rateToPool = borrowRate.mul(oneMinusReserveFactor).div(1e18);\n        return utilizationRate(cash, borrows, reserves).mul(rateToPool).div(1e18);\n    }\n    /**\n     * Returns the current total borrows plus accrued interest\n     * @return The total borrows with interest\n     */\n    function totalBorrowsCurrent() external override view returns (uint) {\n        /* Remember the initial block number */\n        uint currentBlockNumber = getBlockNumber();\n        uint accrualBlockNumberPrior = accrualBlockNumber;\n\n        /* Short-circuit accumulating 0 interest */\n        if (accrualBlockNumberPrior == currentBlockNumber) {\n            return totalBorrows;\n        }\n\n        /* Read the previous values out of storage */\n        uint cashPrior = getCashPrior();\n        uint borrowsPrior = totalBorrows;\n        uint reservesPrior = totalReserves;\n\n        /* Calculate the current borrow interest rate */\n        uint borrowRateMantissa = getBorrowRateInternal(cashPrior, borrowsPrior, reservesPrior);\n        require(borrowRateMantissa <= borrowRateMaxMantissa, \"borrower rate higher\");\n\n        /* Calculate the number of blocks elapsed since the last accrual */\n        (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);\n        require(mathErr == MathError.NO_ERROR, \"calc block delta erro\");\n\n        Exp memory simpleInterestFactor;\n        uint interestAccumulated;\n        uint totalBorrowsNew;\n\n        (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);\n        require(mathErr == MathError.NO_ERROR, 'calc interest factor error');\n\n        (mathErr, interestAccumulated) = mulScalarTruncate(simpleInterestFactor, borrowsPrior);\n        require(mathErr == MathError.NO_ERROR, 'calc interest acc error');\n\n        (mathErr, totalBorrowsNew) = addUInt(interestAccumulated, borrowsPrior);\n        require(mathErr == MathError.NO_ERROR, 'calc total borrows error');\n\n        return totalBorrowsNew;\n    }\n    /**\n     * Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex\n     * @param account The address whose balance should be calculated after updating borrowIndex\n     * @return The calculated balance\n     */\n    function borrowBalanceCurrent(address account) external view override returns (uint) {\n        (MathError err0, uint borrowIndex) = calCurrentBorrowIndex();\n        require(err0 == MathError.NO_ERROR, \"calc borrow index fail\");\n        (MathError err1, uint result) = borrowBalanceStoredInternalWithBorrowerIndex(account, borrowIndex);\n        require(err1 == MathError.NO_ERROR, \"calc fail\");\n        return result;\n    }\n\n    function borrowBalanceStored(address account) external override view returns (uint){\n        return accountBorrows[account].principal;\n    }\n\n\n    /**\n     * Return the borrow balance of account based on stored data\n     * @param account The address whose balance should be calculated\n     * @return (error code, the calculated balance or 0 if error code is non-zero)\n     */\n    function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {\n        return borrowBalanceStoredInternalWithBorrowerIndex(account, borrowIndex);\n    }\n    /**\n     * Return the borrow balance of account based on stored data\n     * @param account The address whose balance should be calculated\n     * @return (error code, the calculated balance or 0 if error code is non-zero)\n     */\n    function borrowBalanceStoredInternalWithBorrowerIndex(address account, uint borrowIndex) internal view returns (MathError, uint) {\n        /* Note: we do not assert that the market is up to date */\n        MathError mathErr;\n        uint principalTimesIndex;\n        uint result;\n\n        /* Get borrowBalance and borrowIndex */\n        BorrowSnapshot storage borrowSnapshot = accountBorrows[account];\n\n        /* If borrowBalance = 0 then borrowIndex is likely also 0.\n         * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.\n         */\n        if (borrowSnapshot.principal == 0) {\n            return (MathError.NO_ERROR, 0);\n        }\n\n        /* Calculate new borrow balance using the interest index:\n         *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex\n         */\n        (mathErr, principalTimesIndex) = mulUInt(borrowSnapshot.principal, borrowIndex);\n        if (mathErr != MathError.NO_ERROR) {\n            return (mathErr, 0);\n        }\n\n        (mathErr, result) = divUInt(principalTimesIndex, borrowSnapshot.interestIndex);\n        if (mathErr != MathError.NO_ERROR) {\n            return (mathErr, 0);\n        }\n\n        return (MathError.NO_ERROR, result);\n    }\n    /**\n     * Accrue interest then return the up-to-date exchange rate\n     * @return Calculated exchange rate scaled by 1e18\n     */\n    function exchangeRateCurrent() public override nonReentrant returns (uint) {\n        accrueInterest();\n        return exchangeRateStored();\n    }\n\n    /**\n     * Calculates the exchange rate from the underlying to the LToken\n     * @dev This function does not accrue interest before calculating the exchange rate\n     * @return Calculated exchange rate scaled by 1e18\n     */\n    function exchangeRateStored() public override view returns (uint) {\n        (MathError err, uint result) = exchangeRateStoredInternal();\n        require(err == MathError.NO_ERROR, \"calc fail\");\n        return result;\n    }\n\n    /**\n     * Calculates the exchange rate from the underlying to the LToken\n     * @dev This function does not accrue interest before calculating the exchange rate\n     * @return (error code, calculated exchange rate scaled by 1e18)\n     */\n    function exchangeRateStoredInternal() internal view returns (MathError, uint) {\n        uint _totalSupply = totalSupply;\n        if (_totalSupply == 0) {\n            /*\n             * If there are no tokens minted:\n             *  exchangeRate = initialExchangeRate\n             */\n            return (MathError.NO_ERROR, initialExchangeRateMantissa);\n        } else {\n            /*\n             * Otherwise:\n             *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply\n             */\n            uint totalCash = getCashPrior();\n            uint cashPlusBorrowsMinusReserves;\n            Exp memory exchangeRate;\n            MathError mathErr;\n\n            (mathErr, cashPlusBorrowsMinusReserves) = addThenSubUInt(totalCash, totalBorrows, totalReserves);\n            if (mathErr != MathError.NO_ERROR) {\n                return (mathErr, 0);\n            }\n\n            (mathErr, exchangeRate) = getExp(cashPlusBorrowsMinusReserves, _totalSupply);\n            if (mathErr != MathError.NO_ERROR) {\n                return (mathErr, 0);\n            }\n\n            return (MathError.NO_ERROR, exchangeRate.mantissa);\n        }\n    }\n\n    /**\n     * Get cash balance of this cToken in the underlying asset\n     * @return The quantity of underlying asset owned by this contract\n     */\n    function getCash() external override view returns (uint) {\n        return getCashPrior();\n    }\n\n    function calCurrentBorrowIndex() internal view returns (MathError, uint) {\n        /* Remember the initial block number */\n        uint currentBlockNumber = getBlockNumber();\n        uint accrualBlockNumberPrior = accrualBlockNumber;\n        uint borrowIndexNew;\n        /* Short-circuit accumulating 0 interest */\n        if (accrualBlockNumberPrior == currentBlockNumber) {\n            return (MathError.NO_ERROR, borrowIndex);\n        }\n        uint borrowRateMantissa = getBorrowRateInternal(getCashPrior(), totalBorrows, totalReserves);\n        (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);\n\n        Exp memory simpleInterestFactor;\n        (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);\n        if (mathErr != MathError.NO_ERROR) {\n            return (mathErr, 0);\n        }\n        (mathErr, borrowIndexNew) = mulScalarTruncateAddUInt(simpleInterestFactor, borrowIndex, borrowIndex);\n        return (mathErr, borrowIndexNew);\n    }\n\n    /**\n     * Applies accrued interest to total borrows and reserves\n     * @dev This calculates interest accrued from the last checkpointed block\n     *   up to the current block and writes new checkpoint to storage.\n     */\n    function accrueInterest() public override {\n        /* Remember the initial block number */\n        uint currentBlockNumber = getBlockNumber();\n        uint accrualBlockNumberPrior = accrualBlockNumber;\n\n        /* Short-circuit accumulating 0 interest */\n        if (accrualBlockNumberPrior == currentBlockNumber) {\n            return;\n        }\n\n        /* Read the previous values out of storage */\n        uint cashPrior = getCashPrior();\n        uint borrowsPrior = totalBorrows;\n        uint borrowIndexPrior = borrowIndex;\n        uint reservesPrior = totalReserves;\n\n        /* Calculate the current borrow interest rate */\n        uint borrowRateMantissa = getBorrowRateInternal(cashPrior, borrowsPrior, reservesPrior);\n        require(borrowRateMantissa <= borrowRateMaxMantissa, \"borrower rate higher\");\n\n        /* Calculate the number of blocks elapsed since the last accrual */\n        (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);\n        require(mathErr == MathError.NO_ERROR, \"calc block delta erro\");\n\n\n        /*\n         * Calculate the interest accumulated into borrows and reserves and the new index:\n         *  simpleInterestFactor = borrowRate * blockDelta\n         *  interestAccumulated = simpleInterestFactor * totalBorrows\n         *  totalBorrowsNew = interestAccumulated + totalBorrows\n         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex\n         */\n\n        Exp memory simpleInterestFactor;\n        uint interestAccumulated;\n        uint totalBorrowsNew;\n        uint borrowIndexNew;\n        uint totalReservesNew;\n\n        (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);\n        require(mathErr == MathError.NO_ERROR, 'calc interest factor error');\n\n        (mathErr, interestAccumulated) = mulScalarTruncate(simpleInterestFactor, borrowsPrior);\n        require(mathErr == MathError.NO_ERROR, 'calc interest acc error');\n\n        (mathErr, totalBorrowsNew) = addUInt(interestAccumulated, borrowsPrior);\n        require(mathErr == MathError.NO_ERROR, 'calc total borrows error');\n\n        (mathErr, totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa : reserveFactorMantissa}), interestAccumulated, reservesPrior);\n        require(mathErr == MathError.NO_ERROR, 'calc total reserves error');\n\n        (mathErr, borrowIndexNew) = mulScalarTruncateAddUInt(simpleInterestFactor, borrowIndexPrior, borrowIndexPrior);\n        require(mathErr == MathError.NO_ERROR, 'calc borrows index error');\n\n\n        /* We write the previously calculated values into storage */\n        accrualBlockNumber = currentBlockNumber;\n        borrowIndex = borrowIndexNew;\n        totalBorrows = totalBorrowsNew;\n        totalReserves = totalReservesNew;\n\n        /* We emit an AccrueInterest event */\n        emit AccrueInterest(cashPrior, interestAccumulated, borrowIndexNew, totalBorrowsNew);\n\n    }\n\n    struct MintLocalVars {\n        MathError mathErr;\n        uint exchangeRateMantissa;\n        uint mintTokens;\n        uint totalSupplyNew;\n        uint accountTokensNew;\n        uint actualMintAmount;\n    }\n\n    /**\n     * User supplies assets into the market and receives lTokens in exchange\n     * @dev Assumes interest has already been accrued up to the current block\n     * @param minter The address of the account which is supplying the assets\n     * @param mintAmount The amount of the underlying asset to supply\n     * @return uint the actual mint amount.\n     */\n    function mintFresh(address minter, uint mintAmount) internal sameBlock returns (uint) {\n        MintLocalVars memory vars;\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n        require(vars.mathErr == MathError.NO_ERROR, 'calc exchangerate error');\n\n        /*\n         *  We call `doTransferIn` for the minter and the mintAmount.\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n         *  `doTransferIn` reverts if anything goes wrong, since we can't be sure if\n         *  side-effects occurred. The function returns the amount actually transferred,\n         *  in case of a fee. On success, the cToken holds an additional `actualMintAmount`\n         *  of cash.\n         */\n        vars.actualMintAmount = doTransferIn(minter, mintAmount, true);\n\n        /*\n         * We get the current exchange rate and calculate the number of lTokens to be minted:\n         *  mintTokens = actualMintAmount / exchangeRate\n         */\n\n        (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(vars.actualMintAmount, Exp({mantissa : vars.exchangeRateMantissa}));\n        require(vars.mathErr == MathError.NO_ERROR, \"calc mint token error\");\n\n        /* Fail if mint not allowed */\n        (ControllerInterface(controller)).mintAllowed(address(this), minter, vars.mintTokens);\n        /*\n         * We calculate the new total supply of lTokens and minter token balance, checking for overflow:\n         *  totalSupplyNew = totalSupply + mintTokens\n         *  accountTokensNew = accountTokens[minter] + mintTokens\n         */\n        (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);\n        require(vars.mathErr == MathError.NO_ERROR, \"calc supply new failed\");\n\n        (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);\n        require(vars.mathErr == MathError.NO_ERROR, \"calc tokens new ailed\");\n\n        /* We write previously calculated values into storage */\n        totalSupply = vars.totalSupplyNew;\n        accountTokens[minter] = vars.accountTokensNew;\n\n        /* We emit a Mint event, and a Transfer event */\n        emit Mint(minter, vars.actualMintAmount, vars.mintTokens);\n        emit Transfer(address(this), minter, vars.mintTokens);\n\n        /* We call the defense hook */\n\n        return vars.actualMintAmount;\n    }\n\n\n    struct RedeemLocalVars {\n        MathError mathErr;\n        uint exchangeRateMantissa;\n        uint redeemTokens;\n        uint redeemAmount;\n        uint totalSupplyNew;\n        uint accountTokensNew;\n    }\n\n    /**\n     * User redeems lTokens in exchange for the underlying asset\n     * @dev Assumes interest has already been accrued up to the current block\n     * @param redeemer The address of the account which is redeeming the tokens\n     * @param redeemTokensIn The number of lTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be non-zero)\n     * @param redeemAmountIn The number of underlying tokens to receive from redeeming lTokens (only one of redeemTokensIn or redeemAmountIn may be non-zero)\n     */\n    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal sameBlock {\n        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one be zero\");\n\n        RedeemLocalVars memory vars;\n\n        /* exchangeRate = invoke Exchange Rate Stored() */\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n        require(vars.mathErr == MathError.NO_ERROR, 'calc exchangerate error');\n\n        /* If redeemTokensIn > 0: */\n        if (redeemTokensIn > 0) {\n            /*\n             * We calculate the exchange rate and the amount of underlying to be redeemed:\n             *  redeemTokens = redeemTokensIn\n             *  redeemAmount = redeemTokensIn x exchangeRateCurrent\n             */\n            vars.redeemTokens = redeemTokensIn;\n\n            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa : vars.exchangeRateMantissa}), redeemTokensIn);\n            require(vars.mathErr == MathError.NO_ERROR, 'calc redeem amount error');\n        } else {\n            /*\n             * We get the current exchange rate and calculate the amount to be redeemed:\n             *  redeemTokens = redeemAmountIn / exchangeRate\n             *  redeemAmount = redeemAmountIn\n             */\n\n            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa : vars.exchangeRateMantissa}));\n            require(vars.mathErr == MathError.NO_ERROR, 'calc redeem tokens error');\n            vars.redeemAmount = redeemAmountIn;\n        }\n\n        /* Fail if redeem not allowed */\n        (ControllerInterface(controller)).redeemAllowed(address(this), redeemer, vars.redeemTokens);\n\n        /*\n         * We calculate the new total supply and redeemer balance, checking for underflow:\n         *  totalSupplyNew = totalSupply - redeemTokens\n         *  accountTokensNew = accountTokens[redeemer] - redeemTokens\n         */\n        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);\n        require(vars.mathErr == MathError.NO_ERROR, 'calc supply new error');\n\n        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);\n        require(vars.mathErr == MathError.NO_ERROR, 'calc token new error');\n        require(getCashPrior() >= vars.redeemAmount, 'cash < redeem');\n\n        /*\n         * We invoke doTransferOut for the redeemer and the redeemAmount.\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n         *  On success, the cToken has redeemAmount less of cash.\n         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n         */\n        doTransferOut(redeemer, vars.redeemAmount, true);\n        /* We write previously calculated values into storage */\n        totalSupply = vars.totalSupplyNew;\n        accountTokens[redeemer] = vars.accountTokensNew;\n\n        /* We emit a Transfer event, and a Redeem event */\n        emit Transfer(redeemer, address(this), vars.redeemTokens);\n        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);\n\n        /* We call the defense hook */\n    }\n\n    struct BorrowLocalVars {\n        MathError mathErr;\n        uint accountBorrows;\n        uint accountBorrowsNew;\n        uint totalBorrowsNew;\n    }\n\n    /**\n      * Users borrow assets from the protocol to their own address\n      * @param borrowAmount The amount of the underlying asset to borrow\n      */\n    //SWC-107-Reentrancy: L845-L885\n    function borrowFresh(address payable borrower, address payable payee, uint borrowAmount) internal sameBlock {\n        /* Fail if borrow not allowed */\n        (ControllerInterface(controller)).borrowAllowed(address(this), borrower, payee, borrowAmount);\n\n        /* Fail gracefully if protocol has insufficient underlying cash */\n        require(getCashPrior() >= borrowAmount, 'cash<borrow');\n\n        BorrowLocalVars memory vars;\n\n        /*\n         * We calculate the new borrower and total borrow balances, failing on overflow:\n         *  accountBorrowsNew = accountBorrows + borrowAmount\n         *  totalBorrowsNew = totalBorrows + borrowAmount\n         */\n        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);\n        require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrows error');\n\n        (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);\n        require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrows error');\n\n        (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);\n        require(vars.mathErr == MathError.NO_ERROR, 'calc total borrows error');\n\n        /*\n         * We invoke doTransferOut for the borrower and the borrowAmount.\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n         *  On success, the cToken borrowAmount less of cash.\n         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n         */\n        doTransferOut(payee, borrowAmount, false);\n\n        /* We write the previously calculated values into storage */\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\n        accountBorrows[borrower].interestIndex = borrowIndex;\n        totalBorrows = vars.totalBorrowsNew;\n\n        /* We emit a Borrow event */\n        emit Borrow(borrower, payee, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\n\n        /* We call the defense hook */\n    }\n\n    struct RepayBorrowLocalVars {\n        MathError mathErr;\n        uint repayAmount;\n        uint borrowerIndex;\n        uint accountBorrows;\n        uint accountBorrowsNew;\n        uint totalBorrowsNew;\n        uint actualRepayAmount;\n    }\n\n    /**\n     * Borrows are repaid by another user (possibly the borrower).\n     * @param payer the account paying off the borrow\n     * @param borrower the account with the debt being payed off\n     * @param repayAmount the amount of undelrying tokens being returned\n     */\n    function repayBorrowFresh(address payer, address borrower, uint repayAmount, bool isEnd) internal sameBlock returns (uint) {\n        /* Fail if repayBorrow not allowed */\n        (ControllerInterface(controller)).repayBorrowAllowed(address(this), payer, borrower, repayAmount, isEnd);\n\n        RepayBorrowLocalVars memory vars;\n\n        /* We remember the original borrowerIndex for verification purposes */\n        vars.borrowerIndex = accountBorrows[borrower].interestIndex;\n\n        /* We fetch the amount the borrower owes, with accumulated interest */\n        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);\n        require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrow error');\n\n        /* If repayAmount == -1, repayAmount = accountBorrows */\n        if (repayAmount == uint(- 1)) {\n            vars.repayAmount = vars.accountBorrows;\n        } else {\n            vars.repayAmount = repayAmount;\n        }\n\n        /*\n         * We call doTransferIn for the payer and the repayAmount\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n         *  On success, the cToken holds an additional repayAmount of cash.\n         *  doTransferIn reverts if anything goes wrong, since we can't be sure if side effects occurred.\n         *   it returns the amount actually transferred, in case of a fee.\n         */\n        vars.actualRepayAmount = doTransferIn(payer, vars.repayAmount, false);\n\n        if (isEnd) {\n            vars.actualRepayAmount = vars.accountBorrows;\n        }\n        /*\n         * We calculate the new borrower and total borrow balances, failing on underflow:\n         *  accountBorrowsNew = accountBorrows - actualRepayAmount\n         *  totalBorrowsNew = totalBorrows - actualRepayAmount\n         */\n        (vars.mathErr, vars.accountBorrowsNew) = subUInt(vars.accountBorrows, vars.actualRepayAmount);\n\n        require(vars.mathErr == MathError.NO_ERROR, \"calc acc borrows error\");\n        //Avoid mantissa errors\n        if (vars.actualRepayAmount > totalBorrows) {\n            vars.totalBorrowsNew = 0;\n        } else {\n            vars.totalBorrowsNew = totalBorrows - vars.actualRepayAmount;\n        }\n\n        /* We write the previously calculated values into storage */\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\n        accountBorrows[borrower].interestIndex = borrowIndex;\n        totalBorrows = vars.totalBorrowsNew;\n\n        /* We emit a RepayBorrow event */\n        emit RepayBorrow(payer, borrower, vars.actualRepayAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\n\n        /* We call the defense hook */\n\n        return vars.actualRepayAmount;\n    }\n\n    /*** Admin Functions ***/\n\n    /**\n      * Sets a new CONTROLLER for the market\n      * @dev Admin function to set a new controller\n      */\n    function setController(address newController) external override onlyAdmin {\n        address oldController = controller;\n\n        controller = newController;\n        // Emit NewController(oldController, newController)\n        emit NewController(oldController, newController);\n    }\n\n    function setBorrowCapFactorMantissa(uint newBorrowCapFactorMantissa) external override onlyAdmin {\n        borrowCapFactorMantissa = newBorrowCapFactorMantissa;\n    }\n\n    function setInterestParams(uint baseRatePerBlock_, uint multiplierPerBlock_, uint jumpMultiplierPerBlock_, uint kink_) external override onlyAdmin {\n        //accrueInterest except first\n        if (baseRatePerBlock != 0) {\n            accrueInterest();\n        }\n        baseRatePerBlock = baseRatePerBlock_;\n        multiplierPerBlock = multiplierPerBlock_;\n        jumpMultiplierPerBlock = jumpMultiplierPerBlock_;\n        kink = kink_;\n        emit NewInterestParam(baseRatePerBlock_, multiplierPerBlock_, jumpMultiplierPerBlock_, kink_);\n    }\n\n    function setReserveFactor(uint newReserveFactorMantissa) external override onlyAdmin {\n        accrueInterest();\n        uint oldReserveFactorMantissa = reserveFactorMantissa;\n        reserveFactorMantissa = newReserveFactorMantissa;\n        emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);\n    }\n\n    function addReserves(uint addAmount) external override {\n        accrueInterest();\n        uint totalReservesNew;\n        uint actualAddAmount;\n        actualAddAmount = doTransferIn(msg.sender, addAmount, true);\n        totalReservesNew = totalReserves.add(actualAddAmount);\n        totalReserves = totalReservesNew;\n        emit ReservesAdded(msg.sender, actualAddAmount, totalReservesNew);\n    }\n\n    function reduceReserves(address payable to, uint reduceAmount) external override onlyAdmin {\n        accrueInterest();\n        uint totalReservesNew;\n        totalReservesNew = totalReserves.sub(reduceAmount);\n        totalReserves = totalReservesNew;\n        doTransferOut(to, reduceAmount, true);\n        emit ReservesReduced(to, reduceAmount, totalReservesNew);\n    }\n\n    modifier sameBlock() {\n        require(accrualBlockNumber == getBlockNumber(), 'not same block');\n        _;\n    }\n\n}",
        "function": "redeem(uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/PeckShield-OpenLeverage1.0/openleverage-contracts-e31d971bcb38ec8737cf1942b8fdf6a9452e5834/contracts/liquidity/LPool.sol",
        "vulnerability": "Dependence on predictable environment variable (SWC 120)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract LPool is DelegateInterface, Adminable, LPoolInterface, Exponential, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint;\n\n    constructor() {\n\n    }\n    /**\n     * Initialize the money market\n     * @param controller_ The address of the Controller\n     * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18\n     * @param name_ EIP-20 name of this token\n     * @param symbol_ EIP-20 symbol of this token\n     * @param decimals_ EIP-20 decimal precision of this token\n     */\n    function initialize(\n        address underlying_,\n        bool isWethPool_,\n        address controller_,\n        uint256 baseRatePerBlock_,\n        uint256 multiplierPerBlock_,\n        uint256 jumpMultiplierPerBlock_,\n        uint256 kink_,\n        uint initialExchangeRateMantissa_,\n        string memory name_,\n        string memory symbol_,\n        uint8 decimals_) public {\n        require(underlying_ != address(0), \"underlying_ address cannot be 0\");\n        require(controller_ != address(0), \"controller_ address cannot be 0\");\n        require(msg.sender == admin, \"Only allow to be called by admin\");\n        require(accrualBlockNumber == 0 && borrowIndex == 0, \"inited once\");\n\n        // Set initial exchange rate\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\n        require(initialExchangeRateMantissa > 0, \"Initial Exchange Rate Mantissa should be greater zero\");\n        //set controller\n        controller = controller_;\n        isWethPool = isWethPool_;\n        //set interestRateModel\n        baseRatePerBlock = baseRatePerBlock_;\n        multiplierPerBlock = multiplierPerBlock_;\n        jumpMultiplierPerBlock = jumpMultiplierPerBlock_;\n        kink = kink_;\n\n        // Initialize block number and borrow index (block number mocks depend on controller being set)\n        accrualBlockNumber = getBlockNumber();\n        borrowIndex = 1e25;\n        //80%\n        borrowCapFactorMantissa = 0.8e18;\n        //20%\n        reserveFactorMantissa = 0.2e18;\n\n\n        name = name_;\n        symbol = symbol_;\n        decimals = decimals_;\n\n        _notEntered = true;\n\n        // Set underlying and sanity check it\n        underlying = underlying_;\n        IERC20(underlying).totalSupply();\n    }\n\n    /**\n     * Transfer `tokens` tokens from `src` to `dst` by `spender`\n     * @dev Called by both `transfer` and `transferFrom` internally\n     * @param spender The address of the account performing the transfer\n     * @param src The address of the source account\n     * @param dst The address of the destination account\n     * @param tokens The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     */\n    function transferTokens(address spender, address src, address dst, uint tokens) internal returns (bool) {\n        require(dst != address(0), \"dst address cannot be 0\");\n        /* Do not allow self-transfers */\n        require(src != dst, \"src = dst\");\n        /* Fail if transfer not allowed */\n        (ControllerInterface(controller)).transferAllowed(address(this), src, dst, tokens);\n\n        /* Get the allowance, infinite for the account owner */\n        uint startingAllowance = 0;\n        if (spender == src) {\n            startingAllowance = uint(- 1);\n        } else {\n            startingAllowance = transferAllowances[src][spender];\n        }\n\n        /* Do the calculations, checking for {under,over}flow */\n        MathError mathErr;\n        uint allowanceNew;\n        uint srcTokensNew;\n        uint dstTokensNew;\n\n        (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);\n        require(mathErr == MathError.NO_ERROR, 'not allowed');\n\n        (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);\n        require(mathErr == MathError.NO_ERROR, 'not enough');\n\n        (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);\n        require(mathErr == MathError.NO_ERROR, 'too much');\n\n        accountTokens[src] = srcTokensNew;\n        accountTokens[dst] = dstTokensNew;\n\n        /* Eat some of the allowance (if necessary) */\n        if (startingAllowance != uint(- 1)) {\n            transferAllowances[src][spender] = allowanceNew;\n        }\n        /* We emit a Transfer event */\n        emit Transfer(src, dst, tokens);\n        return true;\n    }\n\n    /**\n     * Transfer `amount` tokens from `msg.sender` to `dst`\n     * @param dst The address of the destination account\n     * @param amount The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     */\n    function transfer(address dst, uint256 amount) external override nonReentrant returns (bool) {\n        return transferTokens(msg.sender, msg.sender, dst, amount);\n    }\n\n    /**\n     * Transfer `amount` tokens from `src` to `dst`\n     * @param src The address of the source account\n     * @param dst The address of the destination account\n     * @param amount The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     */\n    function transferFrom(address src, address dst, uint256 amount) external override nonReentrant returns (bool) {\n        return transferTokens(msg.sender, src, dst, amount);\n    }\n\n    /**\n     * Approve `spender` to transfer up to `amount` from `src`\n     * @dev This will overwrite the approval amount for `spender`\n     *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n     * @param spender The address of the account which may transfer tokens\n     * @param amount The number of tokens that are approved (-1 means infinite)\n     * @return Whether or not the approval succeeded\n     */\n    function approve(address spender, uint256 amount) external override returns (bool) {\n        address src = msg.sender;\n        transferAllowances[src][spender] = amount;\n        emit Approval(src, spender, amount);\n        return true;\n    }\n\n    /**\n     * Get the current allowance from `owner` for `spender`\n     * @param owner The address of the account which owns the tokens to be spent\n     * @param spender The address of the account which may transfer tokens\n     * @return The number of tokens allowed to be spent (-1 means infinite)\n     */\n    function allowance(address owner, address spender) external override view returns (uint256) {\n        return transferAllowances[owner][spender];\n    }\n\n    /**\n     * Get the token balance of the `owner`\n     * @param owner The address of the account to query\n     * @return The number of tokens owned by `owner`\n     */\n    function balanceOf(address owner) external override view returns (uint256) {\n        return accountTokens[owner];\n    }\n\n    /**\n     * Get the underlying balance of the `owner`\n     * @dev This also accrues interest in a transaction\n     * @param owner The address of the account to query\n     * @return The amount of underlying owned by `owner`\n     */\n    function balanceOfUnderlying(address owner) external override returns (uint) {\n        Exp memory exchangeRate = Exp({mantissa : exchangeRateCurrent()});\n        (MathError mErr, uint balance) = mulScalarTruncate(exchangeRate, accountTokens[owner]);\n        require(mErr == MathError.NO_ERROR, \"calc failed\");\n        return balance;\n    }\n\n    /*** User Interface ***/\n\n    /**\n     * Sender supplies assets into the market and receives lTokens in exchange\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param mintAmount The amount of the underlying asset to supply\n     */\n    function mint(uint mintAmount) external override nonReentrant {\n        accrueInterest();\n        // mintFresh emits the actual Mint event if successful and logs on errors, so we don't need to\n        mintFresh(msg.sender, mintAmount);\n    }\n\n    function mintEth() external payable override nonReentrant {\n        require(isWethPool, \"not eth pool\");\n        accrueInterest();\n        mintFresh(msg.sender, msg.value);\n    }\n\n    /**\n     * Sender redeems lTokens in exchange for the underlying asset\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param redeemTokens The number of lTokens to redeem into underlying\n     */\n    function redeem(uint redeemTokens) external override nonReentrant {\n        accrueInterest();\n        // redeemFresh emits redeem-specific logs on errors, so we don't need to\n        redeemFresh(msg.sender, redeemTokens, 0);\n    }\n\n    /**\n     * Sender redeems lTokens in exchange for a specified amount of underlying asset\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param redeemAmount The amount of underlying to redeem\n     */\n    function redeemUnderlying(uint redeemAmount) external override nonReentrant {\n        accrueInterest();\n        // redeemFresh emits redeem-specific logs on errors, so we don't need to\n        redeemFresh(msg.sender, 0, redeemAmount);\n    }\n\n    function borrowBehalf(address borrower, uint borrowAmount) external override nonReentrant {\n        accrueInterest();\n        // borrowFresh emits borrow-specific logs on errors, so we don't need to\n        borrowFresh(payable(borrower), msg.sender, borrowAmount);\n    }\n\n    /**\n     * Sender repays a borrow belonging to borrower\n     * @param borrower the account with the debt being payed off\n     * @param repayAmount The amount to repay\n     */\n    function repayBorrowBehalf(address borrower, uint repayAmount) external override nonReentrant {\n        accrueInterest();\n        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\n        repayBorrowFresh(msg.sender, borrower, repayAmount, false);\n    }\n\n    function repayBorrowEndByOpenLev(address borrower, uint repayAmount) external override nonReentrant {\n        accrueInterest();\n        repayBorrowFresh(msg.sender, borrower, repayAmount, true);\n    }\n\n\n\n    /*** Safe Token ***/\n\n    /**\n     * Gets balance of this contract in terms of the underlying\n     * @dev This excludes the value of the current message, if any\n     * @return The quantity of underlying tokens owned by this contract\n     */\n    function getCashPrior() internal view returns (uint) {\n        IERC20 token = IERC20(underlying);\n        return token.balanceOf(address(this));\n    }\n\n    /**\n     * @dev Similar to EIP20 transfer, except it handles a False result from `transferFrom` and reverts in that case.\n     *      This will revert due to insufficient balance or insufficient allowance.\n     *      This function returns the actual amount received,\n     *      which may be less than `amount` if there is a fee attached to the transfer.\n     *\n     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.\n     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\n     */\n    function doTransferIn(address from, uint amount, bool convertWeth) internal returns (uint) {\n        uint balanceBefore = IERC20(underlying).balanceOf(address(this));\n        if (isWethPool && convertWeth) {\n            IWETH(underlying).deposit{value : msg.value}();\n        } else {\n            IERC20(underlying).transferFrom(from, address(this), amount);\n        }\n        // Calculate the amount that was *actually* transferred\n        uint balanceAfter = IERC20(underlying).balanceOf(address(this));\n        require(balanceAfter >= balanceBefore, \"transfer overflow\");\n        return balanceAfter - balanceBefore;\n    }\n\n    /**\n     * @dev Similar to EIP20 transfer, except it handles a False success from `transfer` and returns an explanatory\n     *      error code rather than reverting. If caller has not called checked protocol's balance, this may revert due to\n     *      insufficient cash held in this contract. If caller has checked protocol's balance prior to this call, and verified\n     *      it is >= amount, this should not revert in normal conditions.\n     *\n     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.\n     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\n     */\n    function doTransferOut(address payable to, uint amount, bool convertWeth) internal {\n        if (isWethPool && convertWeth) {\n            IWETH(underlying).withdraw(amount);\n            to.transfer(amount);\n        } else {\n            IERC20(underlying).safeTransfer(to, amount);\n        }\n    }\n\n    function availableForBorrow() external view override returns (uint){\n        uint cash = getCashPrior();\n        (MathError err0, uint sum) = addThenSubUInt(cash, totalBorrows, totalReserves);\n        if (err0 != MathError.NO_ERROR) {\n            return 0;\n        }\n        (MathError err1, uint maxAvailable) = mulScalarTruncate(Exp({mantissa : sum}), borrowCapFactorMantissa);\n        if (err1 != MathError.NO_ERROR) {\n            return 0;\n        }\n        if (totalBorrows > maxAvailable) {\n            return 0;\n        }\n        return maxAvailable - totalBorrows;\n    }\n\n\n    /**\n     * Get a snapshot of the account's balances, and the cached exchange rate\n     * @dev This is used by controller to more efficiently perform liquidity checks.\n     * @param account Address of the account to snapshot\n     * @return ( token balance, borrow balance, exchange rate mantissa)\n     */\n    function getAccountSnapshot(address account) external override view returns (uint, uint, uint) {\n        uint cTokenBalance = accountTokens[account];\n        uint borrowBalance;\n        uint exchangeRateMantissa;\n\n        MathError mErr;\n\n        (mErr, borrowBalance) = borrowBalanceStoredInternal(account);\n        if (mErr != MathError.NO_ERROR) {\n            return (0, 0, 0);\n        }\n\n        (mErr, exchangeRateMantissa) = exchangeRateStoredInternal();\n        if (mErr != MathError.NO_ERROR) {\n            return (0, 0, 0);\n        }\n\n        return (cTokenBalance, borrowBalance, exchangeRateMantissa);\n    }\n\n    /**\n     * @dev Function to simply retrieve block number\n     *  This exists mainly for inheriting test contracts to stub this result.\n     */\n    function getBlockNumber() internal view returns (uint) {\n        return block.number;\n    }\n\n    /**\n     * Returns the current per-block borrow interest rate for this cToken\n     * @return The borrow interest rate per block, scaled by 1e18\n     */\n    function borrowRatePerBlock() external override view returns (uint) {\n        return getBorrowRateInternal(getCashPrior(), totalBorrows, totalReserves);\n    }\n\n    /**\n     * Returns the current per-block supply interest rate for this cToken\n     * @return The supply interest rate per block, scaled by 1e18\n     */\n    function supplyRatePerBlock() external override view returns (uint) {\n        return getSupplyRateInternal(getCashPrior(), totalBorrows, totalReserves, reserveFactorMantissa);\n    }\n\n    function utilizationRate(uint cash, uint borrows, uint reserves) internal pure returns (uint) {\n        // Utilization rate is 0 when there are no borrows\n        if (borrows == 0) {\n            return 0;\n        }\n        return borrows.mul(1e18).div(cash.add(borrows).sub(reserves));\n    }\n\n    /**\n     * Calculates the current borrow rate per block, with the error code expected by the market\n     * @param cash The amount of cash in the market\n     * @param borrows The amount of borrows in the market\n     * @return The borrow rate percentage per block as a mantissa (scaled by 1e18)\n     */\n    function getBorrowRateInternal(uint cash, uint borrows, uint reserves) internal view returns (uint) {\n        uint util = utilizationRate(cash, borrows, reserves);\n        if (util <= kink) {\n            return util.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);\n        } else {\n            uint normalRate = kink.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);\n            uint excessUtil = util.sub(kink);\n            return excessUtil.mul(jumpMultiplierPerBlock).div(1e18).add(normalRate);\n        }\n    }\n\n    /**\n     * Calculates the current supply rate per block\n     * @param cash The amount of cash in the market\n     * @param borrows The amount of borrows in the market\n     * @return The supply rate percentage per block as a mantissa (scaled by 1e18)\n     */\n    function getSupplyRateInternal(uint cash, uint borrows, uint reserves, uint reserveFactor) internal view returns (uint) {\n        uint oneMinusReserveFactor = uint(1e18).sub(reserveFactor);\n        uint borrowRate = getBorrowRateInternal(cash, borrows, reserves);\n        uint rateToPool = borrowRate.mul(oneMinusReserveFactor).div(1e18);\n        return utilizationRate(cash, borrows, reserves).mul(rateToPool).div(1e18);\n    }\n    /**\n     * Returns the current total borrows plus accrued interest\n     * @return The total borrows with interest\n     */\n    function totalBorrowsCurrent() external override view returns (uint) {\n        /* Remember the initial block number */\n        uint currentBlockNumber = getBlockNumber();\n        uint accrualBlockNumberPrior = accrualBlockNumber;\n\n        /* Short-circuit accumulating 0 interest */\n        if (accrualBlockNumberPrior == currentBlockNumber) {\n            return totalBorrows;\n        }\n\n        /* Read the previous values out of storage */\n        uint cashPrior = getCashPrior();\n        uint borrowsPrior = totalBorrows;\n        uint reservesPrior = totalReserves;\n\n        /* Calculate the current borrow interest rate */\n        uint borrowRateMantissa = getBorrowRateInternal(cashPrior, borrowsPrior, reservesPrior);\n        require(borrowRateMantissa <= borrowRateMaxMantissa, \"borrower rate higher\");\n\n        /* Calculate the number of blocks elapsed since the last accrual */\n        (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);\n        require(mathErr == MathError.NO_ERROR, \"calc block delta erro\");\n\n        Exp memory simpleInterestFactor;\n        uint interestAccumulated;\n        uint totalBorrowsNew;\n\n        (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);\n        require(mathErr == MathError.NO_ERROR, 'calc interest factor error');\n\n        (mathErr, interestAccumulated) = mulScalarTruncate(simpleInterestFactor, borrowsPrior);\n        require(mathErr == MathError.NO_ERROR, 'calc interest acc error');\n\n        (mathErr, totalBorrowsNew) = addUInt(interestAccumulated, borrowsPrior);\n        require(mathErr == MathError.NO_ERROR, 'calc total borrows error');\n\n        return totalBorrowsNew;\n    }\n    /**\n     * Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex\n     * @param account The address whose balance should be calculated after updating borrowIndex\n     * @return The calculated balance\n     */\n    function borrowBalanceCurrent(address account) external view override returns (uint) {\n        (MathError err0, uint borrowIndex) = calCurrentBorrowIndex();\n        require(err0 == MathError.NO_ERROR, \"calc borrow index fail\");\n        (MathError err1, uint result) = borrowBalanceStoredInternalWithBorrowerIndex(account, borrowIndex);\n        require(err1 == MathError.NO_ERROR, \"calc fail\");\n        return result;\n    }\n\n    function borrowBalanceStored(address account) external override view returns (uint){\n        return accountBorrows[account].principal;\n    }\n\n\n    /**\n     * Return the borrow balance of account based on stored data\n     * @param account The address whose balance should be calculated\n     * @return (error code, the calculated balance or 0 if error code is non-zero)\n     */\n    function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {\n        return borrowBalanceStoredInternalWithBorrowerIndex(account, borrowIndex);\n    }\n    /**\n     * Return the borrow balance of account based on stored data\n     * @param account The address whose balance should be calculated\n     * @return (error code, the calculated balance or 0 if error code is non-zero)\n     */\n    function borrowBalanceStoredInternalWithBorrowerIndex(address account, uint borrowIndex) internal view returns (MathError, uint) {\n        /* Note: we do not assert that the market is up to date */\n        MathError mathErr;\n        uint principalTimesIndex;\n        uint result;\n\n        /* Get borrowBalance and borrowIndex */\n        BorrowSnapshot storage borrowSnapshot = accountBorrows[account];\n\n        /* If borrowBalance = 0 then borrowIndex is likely also 0.\n         * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.\n         */\n        if (borrowSnapshot.principal == 0) {\n            return (MathError.NO_ERROR, 0);\n        }\n\n        /* Calculate new borrow balance using the interest index:\n         *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex\n         */\n        (mathErr, principalTimesIndex) = mulUInt(borrowSnapshot.principal, borrowIndex);\n        if (mathErr != MathError.NO_ERROR) {\n            return (mathErr, 0);\n        }\n\n        (mathErr, result) = divUInt(principalTimesIndex, borrowSnapshot.interestIndex);\n        if (mathErr != MathError.NO_ERROR) {\n            return (mathErr, 0);\n        }\n\n        return (MathError.NO_ERROR, result);\n    }\n    /**\n     * Accrue interest then return the up-to-date exchange rate\n     * @return Calculated exchange rate scaled by 1e18\n     */\n    function exchangeRateCurrent() public override nonReentrant returns (uint) {\n        accrueInterest();\n        return exchangeRateStored();\n    }\n\n    /**\n     * Calculates the exchange rate from the underlying to the LToken\n     * @dev This function does not accrue interest before calculating the exchange rate\n     * @return Calculated exchange rate scaled by 1e18\n     */\n    function exchangeRateStored() public override view returns (uint) {\n        (MathError err, uint result) = exchangeRateStoredInternal();\n        require(err == MathError.NO_ERROR, \"calc fail\");\n        return result;\n    }\n\n    /**\n     * Calculates the exchange rate from the underlying to the LToken\n     * @dev This function does not accrue interest before calculating the exchange rate\n     * @return (error code, calculated exchange rate scaled by 1e18)\n     */\n    function exchangeRateStoredInternal() internal view returns (MathError, uint) {\n        uint _totalSupply = totalSupply;\n        if (_totalSupply == 0) {\n            /*\n             * If there are no tokens minted:\n             *  exchangeRate = initialExchangeRate\n             */\n            return (MathError.NO_ERROR, initialExchangeRateMantissa);\n        } else {\n            /*\n             * Otherwise:\n             *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply\n             */\n            uint totalCash = getCashPrior();\n            uint cashPlusBorrowsMinusReserves;\n            Exp memory exchangeRate;\n            MathError mathErr;\n\n            (mathErr, cashPlusBorrowsMinusReserves) = addThenSubUInt(totalCash, totalBorrows, totalReserves);\n            if (mathErr != MathError.NO_ERROR) {\n                return (mathErr, 0);\n            }\n\n            (mathErr, exchangeRate) = getExp(cashPlusBorrowsMinusReserves, _totalSupply);\n            if (mathErr != MathError.NO_ERROR) {\n                return (mathErr, 0);\n            }\n\n            return (MathError.NO_ERROR, exchangeRate.mantissa);\n        }\n    }\n\n    /**\n     * Get cash balance of this cToken in the underlying asset\n     * @return The quantity of underlying asset owned by this contract\n     */\n    function getCash() external override view returns (uint) {\n        return getCashPrior();\n    }\n\n    function calCurrentBorrowIndex() internal view returns (MathError, uint) {\n        /* Remember the initial block number */\n        uint currentBlockNumber = getBlockNumber();\n        uint accrualBlockNumberPrior = accrualBlockNumber;\n        uint borrowIndexNew;\n        /* Short-circuit accumulating 0 interest */\n        if (accrualBlockNumberPrior == currentBlockNumber) {\n            return (MathError.NO_ERROR, borrowIndex);\n        }\n        uint borrowRateMantissa = getBorrowRateInternal(getCashPrior(), totalBorrows, totalReserves);\n        (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);\n\n        Exp memory simpleInterestFactor;\n        (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);\n        if (mathErr != MathError.NO_ERROR) {\n            return (mathErr, 0);\n        }\n        (mathErr, borrowIndexNew) = mulScalarTruncateAddUInt(simpleInterestFactor, borrowIndex, borrowIndex);\n        return (mathErr, borrowIndexNew);\n    }\n\n    /**\n     * Applies accrued interest to total borrows and reserves\n     * @dev This calculates interest accrued from the last checkpointed block\n     *   up to the current block and writes new checkpoint to storage.\n     */\n    function accrueInterest() public override {\n        /* Remember the initial block number */\n        uint currentBlockNumber = getBlockNumber();\n        uint accrualBlockNumberPrior = accrualBlockNumber;\n\n        /* Short-circuit accumulating 0 interest */\n        if (accrualBlockNumberPrior == currentBlockNumber) {\n            return;\n        }\n\n        /* Read the previous values out of storage */\n        uint cashPrior = getCashPrior();\n        uint borrowsPrior = totalBorrows;\n        uint borrowIndexPrior = borrowIndex;\n        uint reservesPrior = totalReserves;\n\n        /* Calculate the current borrow interest rate */\n        uint borrowRateMantissa = getBorrowRateInternal(cashPrior, borrowsPrior, reservesPrior);\n        require(borrowRateMantissa <= borrowRateMaxMantissa, \"borrower rate higher\");\n\n        /* Calculate the number of blocks elapsed since the last accrual */\n        (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);\n        require(mathErr == MathError.NO_ERROR, \"calc block delta erro\");\n\n\n        /*\n         * Calculate the interest accumulated into borrows and reserves and the new index:\n         *  simpleInterestFactor = borrowRate * blockDelta\n         *  interestAccumulated = simpleInterestFactor * totalBorrows\n         *  totalBorrowsNew = interestAccumulated + totalBorrows\n         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex\n         */\n\n        Exp memory simpleInterestFactor;\n        uint interestAccumulated;\n        uint totalBorrowsNew;\n        uint borrowIndexNew;\n        uint totalReservesNew;\n\n        (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);\n        require(mathErr == MathError.NO_ERROR, 'calc interest factor error');\n\n        (mathErr, interestAccumulated) = mulScalarTruncate(simpleInterestFactor, borrowsPrior);\n        require(mathErr == MathError.NO_ERROR, 'calc interest acc error');\n\n        (mathErr, totalBorrowsNew) = addUInt(interestAccumulated, borrowsPrior);\n        require(mathErr == MathError.NO_ERROR, 'calc total borrows error');\n\n        (mathErr, totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa : reserveFactorMantissa}), interestAccumulated, reservesPrior);\n        require(mathErr == MathError.NO_ERROR, 'calc total reserves error');\n\n        (mathErr, borrowIndexNew) = mulScalarTruncateAddUInt(simpleInterestFactor, borrowIndexPrior, borrowIndexPrior);\n        require(mathErr == MathError.NO_ERROR, 'calc borrows index error');\n\n\n        /* We write the previously calculated values into storage */\n        accrualBlockNumber = currentBlockNumber;\n        borrowIndex = borrowIndexNew;\n        totalBorrows = totalBorrowsNew;\n        totalReserves = totalReservesNew;\n\n        /* We emit an AccrueInterest event */\n        emit AccrueInterest(cashPrior, interestAccumulated, borrowIndexNew, totalBorrowsNew);\n\n    }\n\n    struct MintLocalVars {\n        MathError mathErr;\n        uint exchangeRateMantissa;\n        uint mintTokens;\n        uint totalSupplyNew;\n        uint accountTokensNew;\n        uint actualMintAmount;\n    }\n\n    /**\n     * User supplies assets into the market and receives lTokens in exchange\n     * @dev Assumes interest has already been accrued up to the current block\n     * @param minter The address of the account which is supplying the assets\n     * @param mintAmount The amount of the underlying asset to supply\n     * @return uint the actual mint amount.\n     */\n    function mintFresh(address minter, uint mintAmount) internal sameBlock returns (uint) {\n        MintLocalVars memory vars;\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n        require(vars.mathErr == MathError.NO_ERROR, 'calc exchangerate error');\n\n        /*\n         *  We call `doTransferIn` for the minter and the mintAmount.\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n         *  `doTransferIn` reverts if anything goes wrong, since we can't be sure if\n         *  side-effects occurred. The function returns the amount actually transferred,\n         *  in case of a fee. On success, the cToken holds an additional `actualMintAmount`\n         *  of cash.\n         */\n        vars.actualMintAmount = doTransferIn(minter, mintAmount, true);\n\n        /*\n         * We get the current exchange rate and calculate the number of lTokens to be minted:\n         *  mintTokens = actualMintAmount / exchangeRate\n         */\n\n        (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(vars.actualMintAmount, Exp({mantissa : vars.exchangeRateMantissa}));\n        require(vars.mathErr == MathError.NO_ERROR, \"calc mint token error\");\n\n        /* Fail if mint not allowed */\n        (ControllerInterface(controller)).mintAllowed(address(this), minter, vars.mintTokens);\n        /*\n         * We calculate the new total supply of lTokens and minter token balance, checking for overflow:\n         *  totalSupplyNew = totalSupply + mintTokens\n         *  accountTokensNew = accountTokens[minter] + mintTokens\n         */\n        (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);\n        require(vars.mathErr == MathError.NO_ERROR, \"calc supply new failed\");\n\n        (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);\n        require(vars.mathErr == MathError.NO_ERROR, \"calc tokens new ailed\");\n\n        /* We write previously calculated values into storage */\n        totalSupply = vars.totalSupplyNew;\n        accountTokens[minter] = vars.accountTokensNew;\n\n        /* We emit a Mint event, and a Transfer event */\n        emit Mint(minter, vars.actualMintAmount, vars.mintTokens);\n        emit Transfer(address(this), minter, vars.mintTokens);\n\n        /* We call the defense hook */\n\n        return vars.actualMintAmount;\n    }\n\n\n    struct RedeemLocalVars {\n        MathError mathErr;\n        uint exchangeRateMantissa;\n        uint redeemTokens;\n        uint redeemAmount;\n        uint totalSupplyNew;\n        uint accountTokensNew;\n    }\n\n    /**\n     * User redeems lTokens in exchange for the underlying asset\n     * @dev Assumes interest has already been accrued up to the current block\n     * @param redeemer The address of the account which is redeeming the tokens\n     * @param redeemTokensIn The number of lTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be non-zero)\n     * @param redeemAmountIn The number of underlying tokens to receive from redeeming lTokens (only one of redeemTokensIn or redeemAmountIn may be non-zero)\n     */\n    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal sameBlock {\n        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one be zero\");\n\n        RedeemLocalVars memory vars;\n\n        /* exchangeRate = invoke Exchange Rate Stored() */\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n        require(vars.mathErr == MathError.NO_ERROR, 'calc exchangerate error');\n\n        /* If redeemTokensIn > 0: */\n        if (redeemTokensIn > 0) {\n            /*\n             * We calculate the exchange rate and the amount of underlying to be redeemed:\n             *  redeemTokens = redeemTokensIn\n             *  redeemAmount = redeemTokensIn x exchangeRateCurrent\n             */\n            vars.redeemTokens = redeemTokensIn;\n\n            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa : vars.exchangeRateMantissa}), redeemTokensIn);\n            require(vars.mathErr == MathError.NO_ERROR, 'calc redeem amount error');\n        } else {\n            /*\n             * We get the current exchange rate and calculate the amount to be redeemed:\n             *  redeemTokens = redeemAmountIn / exchangeRate\n             *  redeemAmount = redeemAmountIn\n             */\n\n            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa : vars.exchangeRateMantissa}));\n            require(vars.mathErr == MathError.NO_ERROR, 'calc redeem tokens error');\n            vars.redeemAmount = redeemAmountIn;\n        }\n\n        /* Fail if redeem not allowed */\n        (ControllerInterface(controller)).redeemAllowed(address(this), redeemer, vars.redeemTokens);\n\n        /*\n         * We calculate the new total supply and redeemer balance, checking for underflow:\n         *  totalSupplyNew = totalSupply - redeemTokens\n         *  accountTokensNew = accountTokens[redeemer] - redeemTokens\n         */\n        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);\n        require(vars.mathErr == MathError.NO_ERROR, 'calc supply new error');\n\n        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);\n        require(vars.mathErr == MathError.NO_ERROR, 'calc token new error');\n        require(getCashPrior() >= vars.redeemAmount, 'cash < redeem');\n\n        /*\n         * We invoke doTransferOut for the redeemer and the redeemAmount.\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n         *  On success, the cToken has redeemAmount less of cash.\n         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n         */\n        doTransferOut(redeemer, vars.redeemAmount, true);\n        /* We write previously calculated values into storage */\n        totalSupply = vars.totalSupplyNew;\n        accountTokens[redeemer] = vars.accountTokensNew;\n\n        /* We emit a Transfer event, and a Redeem event */\n        emit Transfer(redeemer, address(this), vars.redeemTokens);\n        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);\n\n        /* We call the defense hook */\n    }\n\n    struct BorrowLocalVars {\n        MathError mathErr;\n        uint accountBorrows;\n        uint accountBorrowsNew;\n        uint totalBorrowsNew;\n    }\n\n    /**\n      * Users borrow assets from the protocol to their own address\n      * @param borrowAmount The amount of the underlying asset to borrow\n      */\n    //SWC-107-Reentrancy: L845-L885\n    function borrowFresh(address payable borrower, address payable payee, uint borrowAmount) internal sameBlock {\n        /* Fail if borrow not allowed */\n        (ControllerInterface(controller)).borrowAllowed(address(this), borrower, payee, borrowAmount);\n\n        /* Fail gracefully if protocol has insufficient underlying cash */\n        require(getCashPrior() >= borrowAmount, 'cash<borrow');\n\n        BorrowLocalVars memory vars;\n\n        /*\n         * We calculate the new borrower and total borrow balances, failing on overflow:\n         *  accountBorrowsNew = accountBorrows + borrowAmount\n         *  totalBorrowsNew = totalBorrows + borrowAmount\n         */\n        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);\n        require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrows error');\n\n        (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);\n        require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrows error');\n\n        (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);\n        require(vars.mathErr == MathError.NO_ERROR, 'calc total borrows error');\n\n        /*\n         * We invoke doTransferOut for the borrower and the borrowAmount.\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n         *  On success, the cToken borrowAmount less of cash.\n         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n         */\n        doTransferOut(payee, borrowAmount, false);\n\n        /* We write the previously calculated values into storage */\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\n        accountBorrows[borrower].interestIndex = borrowIndex;\n        totalBorrows = vars.totalBorrowsNew;\n\n        /* We emit a Borrow event */\n        emit Borrow(borrower, payee, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\n\n        /* We call the defense hook */\n    }\n\n    struct RepayBorrowLocalVars {\n        MathError mathErr;\n        uint repayAmount;\n        uint borrowerIndex;\n        uint accountBorrows;\n        uint accountBorrowsNew;\n        uint totalBorrowsNew;\n        uint actualRepayAmount;\n    }\n\n    /**\n     * Borrows are repaid by another user (possibly the borrower).\n     * @param payer the account paying off the borrow\n     * @param borrower the account with the debt being payed off\n     * @param repayAmount the amount of undelrying tokens being returned\n     */\n    function repayBorrowFresh(address payer, address borrower, uint repayAmount, bool isEnd) internal sameBlock returns (uint) {\n        /* Fail if repayBorrow not allowed */\n        (ControllerInterface(controller)).repayBorrowAllowed(address(this), payer, borrower, repayAmount, isEnd);\n\n        RepayBorrowLocalVars memory vars;\n\n        /* We remember the original borrowerIndex for verification purposes */\n        vars.borrowerIndex = accountBorrows[borrower].interestIndex;\n\n        /* We fetch the amount the borrower owes, with accumulated interest */\n        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);\n        require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrow error');\n\n        /* If repayAmount == -1, repayAmount = accountBorrows */\n        if (repayAmount == uint(- 1)) {\n            vars.repayAmount = vars.accountBorrows;\n        } else {\n            vars.repayAmount = repayAmount;\n        }\n\n        /*\n         * We call doTransferIn for the payer and the repayAmount\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n         *  On success, the cToken holds an additional repayAmount of cash.\n         *  doTransferIn reverts if anything goes wrong, since we can't be sure if side effects occurred.\n         *   it returns the amount actually transferred, in case of a fee.\n         */\n        vars.actualRepayAmount = doTransferIn(payer, vars.repayAmount, false);\n\n        if (isEnd) {\n            vars.actualRepayAmount = vars.accountBorrows;\n        }\n        /*\n         * We calculate the new borrower and total borrow balances, failing on underflow:\n         *  accountBorrowsNew = accountBorrows - actualRepayAmount\n         *  totalBorrowsNew = totalBorrows - actualRepayAmount\n         */\n        (vars.mathErr, vars.accountBorrowsNew) = subUInt(vars.accountBorrows, vars.actualRepayAmount);\n\n        require(vars.mathErr == MathError.NO_ERROR, \"calc acc borrows error\");\n        //Avoid mantissa errors\n        if (vars.actualRepayAmount > totalBorrows) {\n            vars.totalBorrowsNew = 0;\n        } else {\n            vars.totalBorrowsNew = totalBorrows - vars.actualRepayAmount;\n        }\n\n        /* We write the previously calculated values into storage */\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\n        accountBorrows[borrower].interestIndex = borrowIndex;\n        totalBorrows = vars.totalBorrowsNew;\n\n        /* We emit a RepayBorrow event */\n        emit RepayBorrow(payer, borrower, vars.actualRepayAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\n\n        /* We call the defense hook */\n\n        return vars.actualRepayAmount;\n    }\n\n    /*** Admin Functions ***/\n\n    /**\n      * Sets a new CONTROLLER for the market\n      * @dev Admin function to set a new controller\n      */\n    function setController(address newController) external override onlyAdmin {\n        address oldController = controller;\n\n        controller = newController;\n        // Emit NewController(oldController, newController)\n        emit NewController(oldController, newController);\n    }\n\n    function setBorrowCapFactorMantissa(uint newBorrowCapFactorMantissa) external override onlyAdmin {\n        borrowCapFactorMantissa = newBorrowCapFactorMantissa;\n    }\n\n    function setInterestParams(uint baseRatePerBlock_, uint multiplierPerBlock_, uint jumpMultiplierPerBlock_, uint kink_) external override onlyAdmin {\n        //accrueInterest except first\n        if (baseRatePerBlock != 0) {\n            accrueInterest();\n        }\n        baseRatePerBlock = baseRatePerBlock_;\n        multiplierPerBlock = multiplierPerBlock_;\n        jumpMultiplierPerBlock = jumpMultiplierPerBlock_;\n        kink = kink_;\n        emit NewInterestParam(baseRatePerBlock_, multiplierPerBlock_, jumpMultiplierPerBlock_, kink_);\n    }\n\n    function setReserveFactor(uint newReserveFactorMantissa) external override onlyAdmin {\n        accrueInterest();\n        uint oldReserveFactorMantissa = reserveFactorMantissa;\n        reserveFactorMantissa = newReserveFactorMantissa;\n        emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);\n    }\n\n    function addReserves(uint addAmount) external override {\n        accrueInterest();\n        uint totalReservesNew;\n        uint actualAddAmount;\n        actualAddAmount = doTransferIn(msg.sender, addAmount, true);\n        totalReservesNew = totalReserves.add(actualAddAmount);\n        totalReserves = totalReservesNew;\n        emit ReservesAdded(msg.sender, actualAddAmount, totalReservesNew);\n    }\n\n    function reduceReserves(address payable to, uint reduceAmount) external override onlyAdmin {\n        accrueInterest();\n        uint totalReservesNew;\n        totalReservesNew = totalReserves.sub(reduceAmount);\n        totalReserves = totalReservesNew;\n        doTransferOut(to, reduceAmount, true);\n        emit ReservesReduced(to, reduceAmount, totalReservesNew);\n    }\n\n    modifier sameBlock() {\n        require(accrualBlockNumber == getBlockNumber(), 'not same block');\n        _;\n    }\n\n}",
        "function": "borrowBehalf(address,uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/PeckShield-OpenLeverage1.0/openleverage-contracts-e31d971bcb38ec8737cf1942b8fdf6a9452e5834/contracts/liquidity/LPool.sol",
        "vulnerability": "Dependence on predictable environment variable (SWC 120)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract LPool is DelegateInterface, Adminable, LPoolInterface, Exponential, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint;\n\n    constructor() {\n\n    }\n    /**\n     * Initialize the money market\n     * @param controller_ The address of the Controller\n     * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18\n     * @param name_ EIP-20 name of this token\n     * @param symbol_ EIP-20 symbol of this token\n     * @param decimals_ EIP-20 decimal precision of this token\n     */\n    function initialize(\n        address underlying_,\n        bool isWethPool_,\n        address controller_,\n        uint256 baseRatePerBlock_,\n        uint256 multiplierPerBlock_,\n        uint256 jumpMultiplierPerBlock_,\n        uint256 kink_,\n        uint initialExchangeRateMantissa_,\n        string memory name_,\n        string memory symbol_,\n        uint8 decimals_) public {\n        require(underlying_ != address(0), \"underlying_ address cannot be 0\");\n        require(controller_ != address(0), \"controller_ address cannot be 0\");\n        require(msg.sender == admin, \"Only allow to be called by admin\");\n        require(accrualBlockNumber == 0 && borrowIndex == 0, \"inited once\");\n\n        // Set initial exchange rate\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\n        require(initialExchangeRateMantissa > 0, \"Initial Exchange Rate Mantissa should be greater zero\");\n        //set controller\n        controller = controller_;\n        isWethPool = isWethPool_;\n        //set interestRateModel\n        baseRatePerBlock = baseRatePerBlock_;\n        multiplierPerBlock = multiplierPerBlock_;\n        jumpMultiplierPerBlock = jumpMultiplierPerBlock_;\n        kink = kink_;\n\n        // Initialize block number and borrow index (block number mocks depend on controller being set)\n        accrualBlockNumber = getBlockNumber();\n        borrowIndex = 1e25;\n        //80%\n        borrowCapFactorMantissa = 0.8e18;\n        //20%\n        reserveFactorMantissa = 0.2e18;\n\n\n        name = name_;\n        symbol = symbol_;\n        decimals = decimals_;\n\n        _notEntered = true;\n\n        // Set underlying and sanity check it\n        underlying = underlying_;\n        IERC20(underlying).totalSupply();\n    }\n\n    /**\n     * Transfer `tokens` tokens from `src` to `dst` by `spender`\n     * @dev Called by both `transfer` and `transferFrom` internally\n     * @param spender The address of the account performing the transfer\n     * @param src The address of the source account\n     * @param dst The address of the destination account\n     * @param tokens The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     */\n    function transferTokens(address spender, address src, address dst, uint tokens) internal returns (bool) {\n        require(dst != address(0), \"dst address cannot be 0\");\n        /* Do not allow self-transfers */\n        require(src != dst, \"src = dst\");\n        /* Fail if transfer not allowed */\n        (ControllerInterface(controller)).transferAllowed(address(this), src, dst, tokens);\n\n        /* Get the allowance, infinite for the account owner */\n        uint startingAllowance = 0;\n        if (spender == src) {\n            startingAllowance = uint(- 1);\n        } else {\n            startingAllowance = transferAllowances[src][spender];\n        }\n\n        /* Do the calculations, checking for {under,over}flow */\n        MathError mathErr;\n        uint allowanceNew;\n        uint srcTokensNew;\n        uint dstTokensNew;\n\n        (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);\n        require(mathErr == MathError.NO_ERROR, 'not allowed');\n\n        (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);\n        require(mathErr == MathError.NO_ERROR, 'not enough');\n\n        (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);\n        require(mathErr == MathError.NO_ERROR, 'too much');\n\n        accountTokens[src] = srcTokensNew;\n        accountTokens[dst] = dstTokensNew;\n\n        /* Eat some of the allowance (if necessary) */\n        if (startingAllowance != uint(- 1)) {\n            transferAllowances[src][spender] = allowanceNew;\n        }\n        /* We emit a Transfer event */\n        emit Transfer(src, dst, tokens);\n        return true;\n    }\n\n    /**\n     * Transfer `amount` tokens from `msg.sender` to `dst`\n     * @param dst The address of the destination account\n     * @param amount The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     */\n    function transfer(address dst, uint256 amount) external override nonReentrant returns (bool) {\n        return transferTokens(msg.sender, msg.sender, dst, amount);\n    }\n\n    /**\n     * Transfer `amount` tokens from `src` to `dst`\n     * @param src The address of the source account\n     * @param dst The address of the destination account\n     * @param amount The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     */\n    function transferFrom(address src, address dst, uint256 amount) external override nonReentrant returns (bool) {\n        return transferTokens(msg.sender, src, dst, amount);\n    }\n\n    /**\n     * Approve `spender` to transfer up to `amount` from `src`\n     * @dev This will overwrite the approval amount for `spender`\n     *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n     * @param spender The address of the account which may transfer tokens\n     * @param amount The number of tokens that are approved (-1 means infinite)\n     * @return Whether or not the approval succeeded\n     */\n    function approve(address spender, uint256 amount) external override returns (bool) {\n        address src = msg.sender;\n        transferAllowances[src][spender] = amount;\n        emit Approval(src, spender, amount);\n        return true;\n    }\n\n    /**\n     * Get the current allowance from `owner` for `spender`\n     * @param owner The address of the account which owns the tokens to be spent\n     * @param spender The address of the account which may transfer tokens\n     * @return The number of tokens allowed to be spent (-1 means infinite)\n     */\n    function allowance(address owner, address spender) external override view returns (uint256) {\n        return transferAllowances[owner][spender];\n    }\n\n    /**\n     * Get the token balance of the `owner`\n     * @param owner The address of the account to query\n     * @return The number of tokens owned by `owner`\n     */\n    function balanceOf(address owner) external override view returns (uint256) {\n        return accountTokens[owner];\n    }\n\n    /**\n     * Get the underlying balance of the `owner`\n     * @dev This also accrues interest in a transaction\n     * @param owner The address of the account to query\n     * @return The amount of underlying owned by `owner`\n     */\n    function balanceOfUnderlying(address owner) external override returns (uint) {\n        Exp memory exchangeRate = Exp({mantissa : exchangeRateCurrent()});\n        (MathError mErr, uint balance) = mulScalarTruncate(exchangeRate, accountTokens[owner]);\n        require(mErr == MathError.NO_ERROR, \"calc failed\");\n        return balance;\n    }\n\n    /*** User Interface ***/\n\n    /**\n     * Sender supplies assets into the market and receives lTokens in exchange\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param mintAmount The amount of the underlying asset to supply\n     */\n    function mint(uint mintAmount) external override nonReentrant {\n        accrueInterest();\n        // mintFresh emits the actual Mint event if successful and logs on errors, so we don't need to\n        mintFresh(msg.sender, mintAmount);\n    }\n\n    function mintEth() external payable override nonReentrant {\n        require(isWethPool, \"not eth pool\");\n        accrueInterest();\n        mintFresh(msg.sender, msg.value);\n    }\n\n    /**\n     * Sender redeems lTokens in exchange for the underlying asset\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param redeemTokens The number of lTokens to redeem into underlying\n     */\n    function redeem(uint redeemTokens) external override nonReentrant {\n        accrueInterest();\n        // redeemFresh emits redeem-specific logs on errors, so we don't need to\n        redeemFresh(msg.sender, redeemTokens, 0);\n    }\n\n    /**\n     * Sender redeems lTokens in exchange for a specified amount of underlying asset\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param redeemAmount The amount of underlying to redeem\n     */\n    function redeemUnderlying(uint redeemAmount) external override nonReentrant {\n        accrueInterest();\n        // redeemFresh emits redeem-specific logs on errors, so we don't need to\n        redeemFresh(msg.sender, 0, redeemAmount);\n    }\n\n    function borrowBehalf(address borrower, uint borrowAmount) external override nonReentrant {\n        accrueInterest();\n        // borrowFresh emits borrow-specific logs on errors, so we don't need to\n        borrowFresh(payable(borrower), msg.sender, borrowAmount);\n    }\n\n    /**\n     * Sender repays a borrow belonging to borrower\n     * @param borrower the account with the debt being payed off\n     * @param repayAmount The amount to repay\n     */\n    function repayBorrowBehalf(address borrower, uint repayAmount) external override nonReentrant {\n        accrueInterest();\n        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\n        repayBorrowFresh(msg.sender, borrower, repayAmount, false);\n    }\n\n    function repayBorrowEndByOpenLev(address borrower, uint repayAmount) external override nonReentrant {\n        accrueInterest();\n        repayBorrowFresh(msg.sender, borrower, repayAmount, true);\n    }\n\n\n\n    /*** Safe Token ***/\n\n    /**\n     * Gets balance of this contract in terms of the underlying\n     * @dev This excludes the value of the current message, if any\n     * @return The quantity of underlying tokens owned by this contract\n     */\n    function getCashPrior() internal view returns (uint) {\n        IERC20 token = IERC20(underlying);\n        return token.balanceOf(address(this));\n    }\n\n    /**\n     * @dev Similar to EIP20 transfer, except it handles a False result from `transferFrom` and reverts in that case.\n     *      This will revert due to insufficient balance or insufficient allowance.\n     *      This function returns the actual amount received,\n     *      which may be less than `amount` if there is a fee attached to the transfer.\n     *\n     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.\n     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\n     */\n    function doTransferIn(address from, uint amount, bool convertWeth) internal returns (uint) {\n        uint balanceBefore = IERC20(underlying).balanceOf(address(this));\n        if (isWethPool && convertWeth) {\n            IWETH(underlying).deposit{value : msg.value}();\n        } else {\n            IERC20(underlying).transferFrom(from, address(this), amount);\n        }\n        // Calculate the amount that was *actually* transferred\n        uint balanceAfter = IERC20(underlying).balanceOf(address(this));\n        require(balanceAfter >= balanceBefore, \"transfer overflow\");\n        return balanceAfter - balanceBefore;\n    }\n\n    /**\n     * @dev Similar to EIP20 transfer, except it handles a False success from `transfer` and returns an explanatory\n     *      error code rather than reverting. If caller has not called checked protocol's balance, this may revert due to\n     *      insufficient cash held in this contract. If caller has checked protocol's balance prior to this call, and verified\n     *      it is >= amount, this should not revert in normal conditions.\n     *\n     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.\n     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\n     */\n    function doTransferOut(address payable to, uint amount, bool convertWeth) internal {\n        if (isWethPool && convertWeth) {\n            IWETH(underlying).withdraw(amount);\n            to.transfer(amount);\n        } else {\n            IERC20(underlying).safeTransfer(to, amount);\n        }\n    }\n\n    function availableForBorrow() external view override returns (uint){\n        uint cash = getCashPrior();\n        (MathError err0, uint sum) = addThenSubUInt(cash, totalBorrows, totalReserves);\n        if (err0 != MathError.NO_ERROR) {\n            return 0;\n        }\n        (MathError err1, uint maxAvailable) = mulScalarTruncate(Exp({mantissa : sum}), borrowCapFactorMantissa);\n        if (err1 != MathError.NO_ERROR) {\n            return 0;\n        }\n        if (totalBorrows > maxAvailable) {\n            return 0;\n        }\n        return maxAvailable - totalBorrows;\n    }\n\n\n    /**\n     * Get a snapshot of the account's balances, and the cached exchange rate\n     * @dev This is used by controller to more efficiently perform liquidity checks.\n     * @param account Address of the account to snapshot\n     * @return ( token balance, borrow balance, exchange rate mantissa)\n     */\n    function getAccountSnapshot(address account) external override view returns (uint, uint, uint) {\n        uint cTokenBalance = accountTokens[account];\n        uint borrowBalance;\n        uint exchangeRateMantissa;\n\n        MathError mErr;\n\n        (mErr, borrowBalance) = borrowBalanceStoredInternal(account);\n        if (mErr != MathError.NO_ERROR) {\n            return (0, 0, 0);\n        }\n\n        (mErr, exchangeRateMantissa) = exchangeRateStoredInternal();\n        if (mErr != MathError.NO_ERROR) {\n            return (0, 0, 0);\n        }\n\n        return (cTokenBalance, borrowBalance, exchangeRateMantissa);\n    }\n\n    /**\n     * @dev Function to simply retrieve block number\n     *  This exists mainly for inheriting test contracts to stub this result.\n     */\n    function getBlockNumber() internal view returns (uint) {\n        return block.number;\n    }\n\n    /**\n     * Returns the current per-block borrow interest rate for this cToken\n     * @return The borrow interest rate per block, scaled by 1e18\n     */\n    function borrowRatePerBlock() external override view returns (uint) {\n        return getBorrowRateInternal(getCashPrior(), totalBorrows, totalReserves);\n    }\n\n    /**\n     * Returns the current per-block supply interest rate for this cToken\n     * @return The supply interest rate per block, scaled by 1e18\n     */\n    function supplyRatePerBlock() external override view returns (uint) {\n        return getSupplyRateInternal(getCashPrior(), totalBorrows, totalReserves, reserveFactorMantissa);\n    }\n\n    function utilizationRate(uint cash, uint borrows, uint reserves) internal pure returns (uint) {\n        // Utilization rate is 0 when there are no borrows\n        if (borrows == 0) {\n            return 0;\n        }\n        return borrows.mul(1e18).div(cash.add(borrows).sub(reserves));\n    }\n\n    /**\n     * Calculates the current borrow rate per block, with the error code expected by the market\n     * @param cash The amount of cash in the market\n     * @param borrows The amount of borrows in the market\n     * @return The borrow rate percentage per block as a mantissa (scaled by 1e18)\n     */\n    function getBorrowRateInternal(uint cash, uint borrows, uint reserves) internal view returns (uint) {\n        uint util = utilizationRate(cash, borrows, reserves);\n        if (util <= kink) {\n            return util.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);\n        } else {\n            uint normalRate = kink.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);\n            uint excessUtil = util.sub(kink);\n            return excessUtil.mul(jumpMultiplierPerBlock).div(1e18).add(normalRate);\n        }\n    }\n\n    /**\n     * Calculates the current supply rate per block\n     * @param cash The amount of cash in the market\n     * @param borrows The amount of borrows in the market\n     * @return The supply rate percentage per block as a mantissa (scaled by 1e18)\n     */\n    function getSupplyRateInternal(uint cash, uint borrows, uint reserves, uint reserveFactor) internal view returns (uint) {\n        uint oneMinusReserveFactor = uint(1e18).sub(reserveFactor);\n        uint borrowRate = getBorrowRateInternal(cash, borrows, reserves);\n        uint rateToPool = borrowRate.mul(oneMinusReserveFactor).div(1e18);\n        return utilizationRate(cash, borrows, reserves).mul(rateToPool).div(1e18);\n    }\n    /**\n     * Returns the current total borrows plus accrued interest\n     * @return The total borrows with interest\n     */\n    function totalBorrowsCurrent() external override view returns (uint) {\n        /* Remember the initial block number */\n        uint currentBlockNumber = getBlockNumber();\n        uint accrualBlockNumberPrior = accrualBlockNumber;\n\n        /* Short-circuit accumulating 0 interest */\n        if (accrualBlockNumberPrior == currentBlockNumber) {\n            return totalBorrows;\n        }\n\n        /* Read the previous values out of storage */\n        uint cashPrior = getCashPrior();\n        uint borrowsPrior = totalBorrows;\n        uint reservesPrior = totalReserves;\n\n        /* Calculate the current borrow interest rate */\n        uint borrowRateMantissa = getBorrowRateInternal(cashPrior, borrowsPrior, reservesPrior);\n        require(borrowRateMantissa <= borrowRateMaxMantissa, \"borrower rate higher\");\n\n        /* Calculate the number of blocks elapsed since the last accrual */\n        (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);\n        require(mathErr == MathError.NO_ERROR, \"calc block delta erro\");\n\n        Exp memory simpleInterestFactor;\n        uint interestAccumulated;\n        uint totalBorrowsNew;\n\n        (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);\n        require(mathErr == MathError.NO_ERROR, 'calc interest factor error');\n\n        (mathErr, interestAccumulated) = mulScalarTruncate(simpleInterestFactor, borrowsPrior);\n        require(mathErr == MathError.NO_ERROR, 'calc interest acc error');\n\n        (mathErr, totalBorrowsNew) = addUInt(interestAccumulated, borrowsPrior);\n        require(mathErr == MathError.NO_ERROR, 'calc total borrows error');\n\n        return totalBorrowsNew;\n    }\n    /**\n     * Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex\n     * @param account The address whose balance should be calculated after updating borrowIndex\n     * @return The calculated balance\n     */\n    function borrowBalanceCurrent(address account) external view override returns (uint) {\n        (MathError err0, uint borrowIndex) = calCurrentBorrowIndex();\n        require(err0 == MathError.NO_ERROR, \"calc borrow index fail\");\n        (MathError err1, uint result) = borrowBalanceStoredInternalWithBorrowerIndex(account, borrowIndex);\n        require(err1 == MathError.NO_ERROR, \"calc fail\");\n        return result;\n    }\n\n    function borrowBalanceStored(address account) external override view returns (uint){\n        return accountBorrows[account].principal;\n    }\n\n\n    /**\n     * Return the borrow balance of account based on stored data\n     * @param account The address whose balance should be calculated\n     * @return (error code, the calculated balance or 0 if error code is non-zero)\n     */\n    function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {\n        return borrowBalanceStoredInternalWithBorrowerIndex(account, borrowIndex);\n    }\n    /**\n     * Return the borrow balance of account based on stored data\n     * @param account The address whose balance should be calculated\n     * @return (error code, the calculated balance or 0 if error code is non-zero)\n     */\n    function borrowBalanceStoredInternalWithBorrowerIndex(address account, uint borrowIndex) internal view returns (MathError, uint) {\n        /* Note: we do not assert that the market is up to date */\n        MathError mathErr;\n        uint principalTimesIndex;\n        uint result;\n\n        /* Get borrowBalance and borrowIndex */\n        BorrowSnapshot storage borrowSnapshot = accountBorrows[account];\n\n        /* If borrowBalance = 0 then borrowIndex is likely also 0.\n         * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.\n         */\n        if (borrowSnapshot.principal == 0) {\n            return (MathError.NO_ERROR, 0);\n        }\n\n        /* Calculate new borrow balance using the interest index:\n         *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex\n         */\n        (mathErr, principalTimesIndex) = mulUInt(borrowSnapshot.principal, borrowIndex);\n        if (mathErr != MathError.NO_ERROR) {\n            return (mathErr, 0);\n        }\n\n        (mathErr, result) = divUInt(principalTimesIndex, borrowSnapshot.interestIndex);\n        if (mathErr != MathError.NO_ERROR) {\n            return (mathErr, 0);\n        }\n\n        return (MathError.NO_ERROR, result);\n    }\n    /**\n     * Accrue interest then return the up-to-date exchange rate\n     * @return Calculated exchange rate scaled by 1e18\n     */\n    function exchangeRateCurrent() public override nonReentrant returns (uint) {\n        accrueInterest();\n        return exchangeRateStored();\n    }\n\n    /**\n     * Calculates the exchange rate from the underlying to the LToken\n     * @dev This function does not accrue interest before calculating the exchange rate\n     * @return Calculated exchange rate scaled by 1e18\n     */\n    function exchangeRateStored() public override view returns (uint) {\n        (MathError err, uint result) = exchangeRateStoredInternal();\n        require(err == MathError.NO_ERROR, \"calc fail\");\n        return result;\n    }\n\n    /**\n     * Calculates the exchange rate from the underlying to the LToken\n     * @dev This function does not accrue interest before calculating the exchange rate\n     * @return (error code, calculated exchange rate scaled by 1e18)\n     */\n    function exchangeRateStoredInternal() internal view returns (MathError, uint) {\n        uint _totalSupply = totalSupply;\n        if (_totalSupply == 0) {\n            /*\n             * If there are no tokens minted:\n             *  exchangeRate = initialExchangeRate\n             */\n            return (MathError.NO_ERROR, initialExchangeRateMantissa);\n        } else {\n            /*\n             * Otherwise:\n             *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply\n             */\n            uint totalCash = getCashPrior();\n            uint cashPlusBorrowsMinusReserves;\n            Exp memory exchangeRate;\n            MathError mathErr;\n\n            (mathErr, cashPlusBorrowsMinusReserves) = addThenSubUInt(totalCash, totalBorrows, totalReserves);\n            if (mathErr != MathError.NO_ERROR) {\n                return (mathErr, 0);\n            }\n\n            (mathErr, exchangeRate) = getExp(cashPlusBorrowsMinusReserves, _totalSupply);\n            if (mathErr != MathError.NO_ERROR) {\n                return (mathErr, 0);\n            }\n\n            return (MathError.NO_ERROR, exchangeRate.mantissa);\n        }\n    }\n\n    /**\n     * Get cash balance of this cToken in the underlying asset\n     * @return The quantity of underlying asset owned by this contract\n     */\n    function getCash() external override view returns (uint) {\n        return getCashPrior();\n    }\n\n    function calCurrentBorrowIndex() internal view returns (MathError, uint) {\n        /* Remember the initial block number */\n        uint currentBlockNumber = getBlockNumber();\n        uint accrualBlockNumberPrior = accrualBlockNumber;\n        uint borrowIndexNew;\n        /* Short-circuit accumulating 0 interest */\n        if (accrualBlockNumberPrior == currentBlockNumber) {\n            return (MathError.NO_ERROR, borrowIndex);\n        }\n        uint borrowRateMantissa = getBorrowRateInternal(getCashPrior(), totalBorrows, totalReserves);\n        (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);\n\n        Exp memory simpleInterestFactor;\n        (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);\n        if (mathErr != MathError.NO_ERROR) {\n            return (mathErr, 0);\n        }\n        (mathErr, borrowIndexNew) = mulScalarTruncateAddUInt(simpleInterestFactor, borrowIndex, borrowIndex);\n        return (mathErr, borrowIndexNew);\n    }\n\n    /**\n     * Applies accrued interest to total borrows and reserves\n     * @dev This calculates interest accrued from the last checkpointed block\n     *   up to the current block and writes new checkpoint to storage.\n     */\n    function accrueInterest() public override {\n        /* Remember the initial block number */\n        uint currentBlockNumber = getBlockNumber();\n        uint accrualBlockNumberPrior = accrualBlockNumber;\n\n        /* Short-circuit accumulating 0 interest */\n        if (accrualBlockNumberPrior == currentBlockNumber) {\n            return;\n        }\n\n        /* Read the previous values out of storage */\n        uint cashPrior = getCashPrior();\n        uint borrowsPrior = totalBorrows;\n        uint borrowIndexPrior = borrowIndex;\n        uint reservesPrior = totalReserves;\n\n        /* Calculate the current borrow interest rate */\n        uint borrowRateMantissa = getBorrowRateInternal(cashPrior, borrowsPrior, reservesPrior);\n        require(borrowRateMantissa <= borrowRateMaxMantissa, \"borrower rate higher\");\n\n        /* Calculate the number of blocks elapsed since the last accrual */\n        (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);\n        require(mathErr == MathError.NO_ERROR, \"calc block delta erro\");\n\n\n        /*\n         * Calculate the interest accumulated into borrows and reserves and the new index:\n         *  simpleInterestFactor = borrowRate * blockDelta\n         *  interestAccumulated = simpleInterestFactor * totalBorrows\n         *  totalBorrowsNew = interestAccumulated + totalBorrows\n         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex\n         */\n\n        Exp memory simpleInterestFactor;\n        uint interestAccumulated;\n        uint totalBorrowsNew;\n        uint borrowIndexNew;\n        uint totalReservesNew;\n\n        (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);\n        require(mathErr == MathError.NO_ERROR, 'calc interest factor error');\n\n        (mathErr, interestAccumulated) = mulScalarTruncate(simpleInterestFactor, borrowsPrior);\n        require(mathErr == MathError.NO_ERROR, 'calc interest acc error');\n\n        (mathErr, totalBorrowsNew) = addUInt(interestAccumulated, borrowsPrior);\n        require(mathErr == MathError.NO_ERROR, 'calc total borrows error');\n\n        (mathErr, totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa : reserveFactorMantissa}), interestAccumulated, reservesPrior);\n        require(mathErr == MathError.NO_ERROR, 'calc total reserves error');\n\n        (mathErr, borrowIndexNew) = mulScalarTruncateAddUInt(simpleInterestFactor, borrowIndexPrior, borrowIndexPrior);\n        require(mathErr == MathError.NO_ERROR, 'calc borrows index error');\n\n\n        /* We write the previously calculated values into storage */\n        accrualBlockNumber = currentBlockNumber;\n        borrowIndex = borrowIndexNew;\n        totalBorrows = totalBorrowsNew;\n        totalReserves = totalReservesNew;\n\n        /* We emit an AccrueInterest event */\n        emit AccrueInterest(cashPrior, interestAccumulated, borrowIndexNew, totalBorrowsNew);\n\n    }\n\n    struct MintLocalVars {\n        MathError mathErr;\n        uint exchangeRateMantissa;\n        uint mintTokens;\n        uint totalSupplyNew;\n        uint accountTokensNew;\n        uint actualMintAmount;\n    }\n\n    /**\n     * User supplies assets into the market and receives lTokens in exchange\n     * @dev Assumes interest has already been accrued up to the current block\n     * @param minter The address of the account which is supplying the assets\n     * @param mintAmount The amount of the underlying asset to supply\n     * @return uint the actual mint amount.\n     */\n    function mintFresh(address minter, uint mintAmount) internal sameBlock returns (uint) {\n        MintLocalVars memory vars;\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n        require(vars.mathErr == MathError.NO_ERROR, 'calc exchangerate error');\n\n        /*\n         *  We call `doTransferIn` for the minter and the mintAmount.\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n         *  `doTransferIn` reverts if anything goes wrong, since we can't be sure if\n         *  side-effects occurred. The function returns the amount actually transferred,\n         *  in case of a fee. On success, the cToken holds an additional `actualMintAmount`\n         *  of cash.\n         */\n        vars.actualMintAmount = doTransferIn(minter, mintAmount, true);\n\n        /*\n         * We get the current exchange rate and calculate the number of lTokens to be minted:\n         *  mintTokens = actualMintAmount / exchangeRate\n         */\n\n        (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(vars.actualMintAmount, Exp({mantissa : vars.exchangeRateMantissa}));\n        require(vars.mathErr == MathError.NO_ERROR, \"calc mint token error\");\n\n        /* Fail if mint not allowed */\n        (ControllerInterface(controller)).mintAllowed(address(this), minter, vars.mintTokens);\n        /*\n         * We calculate the new total supply of lTokens and minter token balance, checking for overflow:\n         *  totalSupplyNew = totalSupply + mintTokens\n         *  accountTokensNew = accountTokens[minter] + mintTokens\n         */\n        (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);\n        require(vars.mathErr == MathError.NO_ERROR, \"calc supply new failed\");\n\n        (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);\n        require(vars.mathErr == MathError.NO_ERROR, \"calc tokens new ailed\");\n\n        /* We write previously calculated values into storage */\n        totalSupply = vars.totalSupplyNew;\n        accountTokens[minter] = vars.accountTokensNew;\n\n        /* We emit a Mint event, and a Transfer event */\n        emit Mint(minter, vars.actualMintAmount, vars.mintTokens);\n        emit Transfer(address(this), minter, vars.mintTokens);\n\n        /* We call the defense hook */\n\n        return vars.actualMintAmount;\n    }\n\n\n    struct RedeemLocalVars {\n        MathError mathErr;\n        uint exchangeRateMantissa;\n        uint redeemTokens;\n        uint redeemAmount;\n        uint totalSupplyNew;\n        uint accountTokensNew;\n    }\n\n    /**\n     * User redeems lTokens in exchange for the underlying asset\n     * @dev Assumes interest has already been accrued up to the current block\n     * @param redeemer The address of the account which is redeeming the tokens\n     * @param redeemTokensIn The number of lTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be non-zero)\n     * @param redeemAmountIn The number of underlying tokens to receive from redeeming lTokens (only one of redeemTokensIn or redeemAmountIn may be non-zero)\n     */\n    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal sameBlock {\n        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one be zero\");\n\n        RedeemLocalVars memory vars;\n\n        /* exchangeRate = invoke Exchange Rate Stored() */\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n        require(vars.mathErr == MathError.NO_ERROR, 'calc exchangerate error');\n\n        /* If redeemTokensIn > 0: */\n        if (redeemTokensIn > 0) {\n            /*\n             * We calculate the exchange rate and the amount of underlying to be redeemed:\n             *  redeemTokens = redeemTokensIn\n             *  redeemAmount = redeemTokensIn x exchangeRateCurrent\n             */\n            vars.redeemTokens = redeemTokensIn;\n\n            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa : vars.exchangeRateMantissa}), redeemTokensIn);\n            require(vars.mathErr == MathError.NO_ERROR, 'calc redeem amount error');\n        } else {\n            /*\n             * We get the current exchange rate and calculate the amount to be redeemed:\n             *  redeemTokens = redeemAmountIn / exchangeRate\n             *  redeemAmount = redeemAmountIn\n             */\n\n            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa : vars.exchangeRateMantissa}));\n            require(vars.mathErr == MathError.NO_ERROR, 'calc redeem tokens error');\n            vars.redeemAmount = redeemAmountIn;\n        }\n\n        /* Fail if redeem not allowed */\n        (ControllerInterface(controller)).redeemAllowed(address(this), redeemer, vars.redeemTokens);\n\n        /*\n         * We calculate the new total supply and redeemer balance, checking for underflow:\n         *  totalSupplyNew = totalSupply - redeemTokens\n         *  accountTokensNew = accountTokens[redeemer] - redeemTokens\n         */\n        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);\n        require(vars.mathErr == MathError.NO_ERROR, 'calc supply new error');\n\n        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);\n        require(vars.mathErr == MathError.NO_ERROR, 'calc token new error');\n        require(getCashPrior() >= vars.redeemAmount, 'cash < redeem');\n\n        /*\n         * We invoke doTransferOut for the redeemer and the redeemAmount.\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n         *  On success, the cToken has redeemAmount less of cash.\n         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n         */\n        doTransferOut(redeemer, vars.redeemAmount, true);\n        /* We write previously calculated values into storage */\n        totalSupply = vars.totalSupplyNew;\n        accountTokens[redeemer] = vars.accountTokensNew;\n\n        /* We emit a Transfer event, and a Redeem event */\n        emit Transfer(redeemer, address(this), vars.redeemTokens);\n        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);\n\n        /* We call the defense hook */\n    }\n\n    struct BorrowLocalVars {\n        MathError mathErr;\n        uint accountBorrows;\n        uint accountBorrowsNew;\n        uint totalBorrowsNew;\n    }\n\n    /**\n      * Users borrow assets from the protocol to their own address\n      * @param borrowAmount The amount of the underlying asset to borrow\n      */\n    //SWC-107-Reentrancy: L845-L885\n    function borrowFresh(address payable borrower, address payable payee, uint borrowAmount) internal sameBlock {\n        /* Fail if borrow not allowed */\n        (ControllerInterface(controller)).borrowAllowed(address(this), borrower, payee, borrowAmount);\n\n        /* Fail gracefully if protocol has insufficient underlying cash */\n        require(getCashPrior() >= borrowAmount, 'cash<borrow');\n\n        BorrowLocalVars memory vars;\n\n        /*\n         * We calculate the new borrower and total borrow balances, failing on overflow:\n         *  accountBorrowsNew = accountBorrows + borrowAmount\n         *  totalBorrowsNew = totalBorrows + borrowAmount\n         */\n        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);\n        require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrows error');\n\n        (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);\n        require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrows error');\n\n        (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);\n        require(vars.mathErr == MathError.NO_ERROR, 'calc total borrows error');\n\n        /*\n         * We invoke doTransferOut for the borrower and the borrowAmount.\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n         *  On success, the cToken borrowAmount less of cash.\n         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n         */\n        doTransferOut(payee, borrowAmount, false);\n\n        /* We write the previously calculated values into storage */\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\n        accountBorrows[borrower].interestIndex = borrowIndex;\n        totalBorrows = vars.totalBorrowsNew;\n\n        /* We emit a Borrow event */\n        emit Borrow(borrower, payee, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\n\n        /* We call the defense hook */\n    }\n\n    struct RepayBorrowLocalVars {\n        MathError mathErr;\n        uint repayAmount;\n        uint borrowerIndex;\n        uint accountBorrows;\n        uint accountBorrowsNew;\n        uint totalBorrowsNew;\n        uint actualRepayAmount;\n    }\n\n    /**\n     * Borrows are repaid by another user (possibly the borrower).\n     * @param payer the account paying off the borrow\n     * @param borrower the account with the debt being payed off\n     * @param repayAmount the amount of undelrying tokens being returned\n     */\n    function repayBorrowFresh(address payer, address borrower, uint repayAmount, bool isEnd) internal sameBlock returns (uint) {\n        /* Fail if repayBorrow not allowed */\n        (ControllerInterface(controller)).repayBorrowAllowed(address(this), payer, borrower, repayAmount, isEnd);\n\n        RepayBorrowLocalVars memory vars;\n\n        /* We remember the original borrowerIndex for verification purposes */\n        vars.borrowerIndex = accountBorrows[borrower].interestIndex;\n\n        /* We fetch the amount the borrower owes, with accumulated interest */\n        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);\n        require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrow error');\n\n        /* If repayAmount == -1, repayAmount = accountBorrows */\n        if (repayAmount == uint(- 1)) {\n            vars.repayAmount = vars.accountBorrows;\n        } else {\n            vars.repayAmount = repayAmount;\n        }\n\n        /*\n         * We call doTransferIn for the payer and the repayAmount\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n         *  On success, the cToken holds an additional repayAmount of cash.\n         *  doTransferIn reverts if anything goes wrong, since we can't be sure if side effects occurred.\n         *   it returns the amount actually transferred, in case of a fee.\n         */\n        vars.actualRepayAmount = doTransferIn(payer, vars.repayAmount, false);\n\n        if (isEnd) {\n            vars.actualRepayAmount = vars.accountBorrows;\n        }\n        /*\n         * We calculate the new borrower and total borrow balances, failing on underflow:\n         *  accountBorrowsNew = accountBorrows - actualRepayAmount\n         *  totalBorrowsNew = totalBorrows - actualRepayAmount\n         */\n        (vars.mathErr, vars.accountBorrowsNew) = subUInt(vars.accountBorrows, vars.actualRepayAmount);\n\n        require(vars.mathErr == MathError.NO_ERROR, \"calc acc borrows error\");\n        //Avoid mantissa errors\n        if (vars.actualRepayAmount > totalBorrows) {\n            vars.totalBorrowsNew = 0;\n        } else {\n            vars.totalBorrowsNew = totalBorrows - vars.actualRepayAmount;\n        }\n\n        /* We write the previously calculated values into storage */\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\n        accountBorrows[borrower].interestIndex = borrowIndex;\n        totalBorrows = vars.totalBorrowsNew;\n\n        /* We emit a RepayBorrow event */\n        emit RepayBorrow(payer, borrower, vars.actualRepayAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\n\n        /* We call the defense hook */\n\n        return vars.actualRepayAmount;\n    }\n\n    /*** Admin Functions ***/\n\n    /**\n      * Sets a new CONTROLLER for the market\n      * @dev Admin function to set a new controller\n      */\n    function setController(address newController) external override onlyAdmin {\n        address oldController = controller;\n\n        controller = newController;\n        // Emit NewController(oldController, newController)\n        emit NewController(oldController, newController);\n    }\n\n    function setBorrowCapFactorMantissa(uint newBorrowCapFactorMantissa) external override onlyAdmin {\n        borrowCapFactorMantissa = newBorrowCapFactorMantissa;\n    }\n\n    function setInterestParams(uint baseRatePerBlock_, uint multiplierPerBlock_, uint jumpMultiplierPerBlock_, uint kink_) external override onlyAdmin {\n        //accrueInterest except first\n        if (baseRatePerBlock != 0) {\n            accrueInterest();\n        }\n        baseRatePerBlock = baseRatePerBlock_;\n        multiplierPerBlock = multiplierPerBlock_;\n        jumpMultiplierPerBlock = jumpMultiplierPerBlock_;\n        kink = kink_;\n        emit NewInterestParam(baseRatePerBlock_, multiplierPerBlock_, jumpMultiplierPerBlock_, kink_);\n    }\n\n    function setReserveFactor(uint newReserveFactorMantissa) external override onlyAdmin {\n        accrueInterest();\n        uint oldReserveFactorMantissa = reserveFactorMantissa;\n        reserveFactorMantissa = newReserveFactorMantissa;\n        emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);\n    }\n\n    function addReserves(uint addAmount) external override {\n        accrueInterest();\n        uint totalReservesNew;\n        uint actualAddAmount;\n        actualAddAmount = doTransferIn(msg.sender, addAmount, true);\n        totalReservesNew = totalReserves.add(actualAddAmount);\n        totalReserves = totalReservesNew;\n        emit ReservesAdded(msg.sender, actualAddAmount, totalReservesNew);\n    }\n\n    function reduceReserves(address payable to, uint reduceAmount) external override onlyAdmin {\n        accrueInterest();\n        uint totalReservesNew;\n        totalReservesNew = totalReserves.sub(reduceAmount);\n        totalReserves = totalReservesNew;\n        doTransferOut(to, reduceAmount, true);\n        emit ReservesReduced(to, reduceAmount, totalReservesNew);\n    }\n\n    modifier sameBlock() {\n        require(accrualBlockNumber == getBlockNumber(), 'not same block');\n        _;\n    }\n\n}",
        "function": "mint(uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/PeckShield-OpenLeverage1.0/openleverage-contracts-e31d971bcb38ec8737cf1942b8fdf6a9452e5834/contracts/liquidity/LPool.sol",
        "vulnerability": "Dependence on predictable environment variable (SWC 120)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract owned {\n    address public owner; //the contract owner\n\n    function owned() {\n        owner = msg.sender; //constructor initializes the creator as the owner on initialization\n    }\n\n    modifier onlyOwner {\n        if (msg.sender != owner) throw; // functions with onlyOwner will throw and exception if not the contract owner\n        _;\n    }\n\n    function transferOwnership(address newOwner) onlyOwner { // transfer contract owner to new owner\n        owner = newOwner;\n    }\n}",
        "function": "constructor",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Blockchain Labs NZ-Earth/Back-to-Earth-audit-master/contracts/GTKT_GoldTickets.sol",
        "vulnerability": "Exception State (SWC 110)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract owned {\n    address public owner; //the contract owner\n\n    function owned() {\n        owner = msg.sender; //constructor initializes the creator as the owner on initialization\n    }\n\n    modifier onlyOwner {\n        if (msg.sender != owner) throw; // functions with onlyOwner will throw and exception if not the contract owner\n        _;\n    }\n\n    function transferOwnership(address newOwner) onlyOwner { // transfer contract owner to new owner\n        owner = newOwner;\n    }\n}",
        "function": "owner()",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Blockchain Labs NZ-Earth/Back-to-Earth-audit-master/contracts/GTKT_GoldTickets.sol",
        "vulnerability": "Exception State (SWC 110)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract StandardMintableToken is owned { \n    /* Public variables of the token */\n    string public standard = 'Token 0.1';\n    string public name;                     // the token name \n    string public symbol;                   // the ticker symbol\n    uint8 public decimals;                  // amount of decimal places in the token\n    uint256 public totalSupply;             // total tokens\n    \n    /* This creates an array with all balances */\n    mapping (address => uint256) public balanceOf;\n    mapping (address => mapping (address => uint256)) public allowance;\n    \n    /* This creates an array with all frozen accounts */\n    mapping (address => bool) public frozenAccount;\n\n    /* This generates a public event on the blockchain that will notify clients */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    \n    /* This generates a public event on the blockchain that will notify clients */\n    event FrozenFunds(address target, bool frozen);\n    \n    /* This generates a public event on the blockchain that will notify clients */\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n    /* Initializes contract with initial supply tokens to the creator of the contract */\n    function StandardMintableToken(\n        string tokenName,               // the token name\n        uint8 decimalUnits,             // amount of decimal places in the token\n        string tokenSymbol,             // the token symbol\n        uint256 initialSupply            // the initial distro amount\n        ) {\n\n        balanceOf[msg.sender] = initialSupply;                   // Give the creator all initial tokens\n        totalSupply = initialSupply;                             // Update total supply\n        name = tokenName;                                        // Set the name for display purposes\n        symbol = tokenSymbol;                                    // Set the symbol for display purposes\n        decimals = decimalUnits;                                 // Amount of decimals for display purposes\n    }\n\n    /* Send tokens */\n    function transfer(address _to, uint256 _value) returns (bool success){\n        if (_value == 0) return false; \t\t\t\t             // Don't waste gas on zero-value transaction\n        if (balanceOf[msg.sender] < _value) return false;    // Check if the sender has enough\n        if (balanceOf[_to] + _value < balanceOf[_to]) throw; // Check for overflows\n        if (frozenAccount[msg.sender]) throw;                // Check if sender frozen\n        if (frozenAccount[_to]) throw;                       // Check if recipient frozen                 \n        balanceOf[msg.sender] -= _value;                     // Subtract from the sender\n        balanceOf[_to] += _value;                            // Add the same to the recipient\n        Transfer(msg.sender, _to, _value);                   // Notify anyone listening that this transfer took place\n        return true;\n    }\n\n    /* Allow another contract to spend some tokens on your behalf */\n    function approve(address _spender, uint256 _value)\n        returns (bool success) {\n        allowance[msg.sender][_spender] = _value;            // Update allowance first\n        Approval(msg.sender, _spender, _value);              // Notify of new Approval\n        return true;\n    }\n\n    /* Approve and then communicate the approved contract in a single tx */\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData)\n        returns (bool success) {\n        tokenRecipient spender = tokenRecipient(_spender);\n        if (approve(_spender, _value)) {\n            spender.receiveApproval(msg.sender, _value, this, _extraData);\n            return true;\n        }\n    }        \n\n    /* A contract attempts to get the coins */\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n        if (frozenAccount[_from]) throw;                        // Check if sender frozen       \n        if (frozenAccount[_to]) throw;                          // Check if recipient frozen                 \n        if (balanceOf[_from] < _value) return false;          \t// Check if the sender has enough\n        if (balanceOf[_to] + _value < balanceOf[_to]) throw;    // Check for overflows\n        if (_value > allowance[_from][msg.sender]) throw;       // Check allowance\n        balanceOf[_from] -= _value;                             // Subtract from the sender\n        balanceOf[_to] += _value;                               // Add the same to the recipient\n        allowance[_from][msg.sender] -= _value;                 // Update sender's allowance \n        Transfer(_from, _to, _value);                           // Perform the transfer\n        return true;\n    }\n    \n    /* A function to freeze or un-freeze accounts, to and from */\n    \n    function freezeAccount(address target, bool freeze ) onlyOwner {    \n        frozenAccount[target] = freeze;                       // set the array object to the value of bool freeze\n        FrozenFunds(target, freeze);                          // notify event\n    }\n    \n\n    /* A function to burn tokens and remove from supply */\n    \n    function burn(uint256 _value) returns (bool success) {\n        if (frozenAccount[msg.sender]) throw;                 // Check if sender frozen       \n        if (_value == 0) return false; \t\t\t\t          // Don't waste gas on zero-value transaction\n        if (balanceOf[msg.sender] < _value) return false;     // Check if the sender has enough\n        balanceOf[msg.sender] -= _value;                      // Subtract from the sender\n        totalSupply -= _value;                                // Updates totalSupply\n        Transfer(msg.sender,0, _value);\t                      // Burn _value tokens\n        return true;\n    }\n\n    function burnFrom(address _from, uint256 _value) onlyOwner returns (bool success) {\n        if (frozenAccount[msg.sender]) throw;                // Check if sender frozen       \n        if (frozenAccount[_from]) throw;                     // Check if recipient frozen \n        if (_value == 0) return false; \t\t\t             // Don't waste gas on zero-value transaction\n        if (balanceOf[_from] < _value) return false;         // Check if the sender has enough\n        if (_value > allowance[_from][msg.sender]) throw;    // Check allowance\n        balanceOf[_from] -= _value;                          // Subtract from the sender\n        totalSupply -= _value;                               // Updates totalSupply\n        allowance[_from][msg.sender] -= _value;\t\t\t\t // Updates allowance\n        Transfer(_from, 0, _value);                          // Burn tokens by Transfer to incinerator\n        return true;\n    }\n    \n    /* A function to add more tokens to the total supply, accessible only to owner*/\n    // SWC-101-Integer Overflow and Underflow\n    function mintToken(address target, uint256 mintedAmount) onlyOwner {\n        if (balanceOf[target] + mintedAmount < balanceOf[target]) throw; // Check for overflows\n        balanceOf[target] += mintedAmount;\n        totalSupply += mintedAmount;\n        Transfer(0, target, mintedAmount);\n\n    }\n    \n}",
        "function": "constructor",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Blockchain Labs NZ-Earth/Back-to-Earth-audit-master/contracts/GTKT_GoldTickets.sol",
        "vulnerability": "Exception State (SWC 110)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract CHAINSQUARE is ERC20Interface, Owned {\n\tstring public constant symbol = \"CHS\";\n\tstring public constant name = \"CHAINSQUARE\";\n\tuint8 public constant decimals = 18;\n\tuint256 public constant totalSupply = 100000000000000000000000000;\n\n\tbool public stopped;\n\n\tmapping (address => int8) public blackList;\n\n\tmapping (address => uint256) public balances;\n\tmapping (address => mapping (address => uint256)) public allowed;\n\n\n    event Blacklisted(address indexed target);\n    event DeleteFromBlacklist(address indexed target);\n    event RejectedPaymentToBlacklistedAddr(address indexed from, address indexed to, uint256 value);\n    event RejectedPaymentFromBlacklistedAddr(address indexed from, address indexed to, uint256 value);\n\n\n\tmodifier notStopped {\n        require(!stopped);\n        _;\n    }\n\n// constructor\n\tfunction CHAINSQUARE() public {\n\t\tbalances[msg.sender] = totalSupply;\n\t}\n\t\n// function made for airdrop\n\tfunction airdrop(address[] _to, uint256[] _value) onlyOwner notStopped public {\n\t    for(uint256 i = 0; i < _to.length; i++){\n\t        if(balances[_to[i]] > 0){\n\t            continue;\n\t        }\n\t        transfer(_to[i], _value[i]);\n\t    }\n\t}\n\n// blacklist management\n    function blacklisting(address _addr) onlyOwner public {\n        blackList[_addr] = 1;\n        emit Blacklisted(_addr);\n    }\n    function deleteFromBlacklist(address _addr) onlyOwner public {\n        blackList[_addr] = -1;\n        emit DeleteFromBlacklist(_addr);\n    }\n\n// stop the contract\n// SWC-100-Function Default Visibility: L90\n\tfunction stop() onlyOwner {\n        stopped = true;\n    }\n// SWC-100-Function Default Visibility: L94\n    function start() onlyOwner {\n        stopped = false;\n    }\n\t\n// ERC20 functions\n\tfunction balanceOf(address _owner) public constant returns (uint256 balance){\n\t\treturn balances[_owner];\n\t}\n\tfunction transfer(address _to, uint256 _value) notStopped public returns (bool success){\n\t\trequire(balances[msg.sender] >= _value);\n\n\t\tif(blackList[msg.sender] > 0){\n\t\t\temit RejectedPaymentFromBlacklistedAddr(msg.sender, _to, _value);\n\t\t\treturn false;\n\t\t}\n\t\tif(blackList[_to] > 0){\n\t\t\temit RejectedPaymentToBlacklistedAddr(msg.sender, _to, _value);\n\t\t\treturn false;\n\t\t}\n\n\t\tbalances[msg.sender] -= _value;\n\t\tbalances[_to] += _value;\n\t\temit Transfer(msg.sender, _to, _value);\n\t\treturn true;\n\t}\n\tfunction transferFrom(address _from, address _to, uint256 _value) notStopped public returns (bool success){\n\t\trequire(balances[_from] >= _value\n\t\t\t&& allowed[_from][msg.sender] >= _value);\n\n\t\tif(blackList[_from] > 0){\n\t\t\temit RejectedPaymentFromBlacklistedAddr(_from, _to, _value);\n\t\t\treturn false;\n\t\t}\n\t\tif(blackList[_to] > 0){\n\t\t\temit RejectedPaymentToBlacklistedAddr(_from, _to, _value);\n\t\t\treturn false;\n\t\t}\n\n\t\tbalances[_from] -= _value;\n\t\tallowed[_from][msg.sender] -= _value;\n\t\tbalances[_to] += _value;\n\t\temit Transfer(_from, _to, _value);\n\t\treturn true;\n\t}\n\tfunction approve(address _spender, uint256 _value) notStopped public returns (bool success){\n\t\tallowed[msg.sender][_spender] = _value;\n\t\temit Approval(msg.sender, _spender, _value);\n\t\treturn true;\n\t}\n\tfunction allowance(address _owner, address _spender) public constant returns (uint256 remaining){\n\t\treturn allowed[_owner][_spender];\n\t}\n}",
        "function": "airdrop(address[],uint256[])",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Iosiro-CHAINSQUARE Smart Contract Audit/code/Etherscan-0xb41380174d0B06181513A5677b60200b93b5Efb4.sol",
        "vulnerability": "Integer Arithmetic Bugs (SWC 101)",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract CHAINSQUARE is ERC20Interface, Owned {\n\tstring public constant symbol = \"CHS\";\n\tstring public constant name = \"CHAINSQUARE\";\n\tuint8 public constant decimals = 18;\n\tuint256 public constant totalSupply = 100000000000000000000000000;\n\n\tbool public stopped;\n\n\tmapping (address => int8) public blackList;\n\n\tmapping (address => uint256) public balances;\n\tmapping (address => mapping (address => uint256)) public allowed;\n\n\n    event Blacklisted(address indexed target);\n    event DeleteFromBlacklist(address indexed target);\n    event RejectedPaymentToBlacklistedAddr(address indexed from, address indexed to, uint256 value);\n    event RejectedPaymentFromBlacklistedAddr(address indexed from, address indexed to, uint256 value);\n\n\n\tmodifier notStopped {\n        require(!stopped);\n        _;\n    }\n\n// constructor\n\tfunction CHAINSQUARE() public {\n\t\tbalances[msg.sender] = totalSupply;\n\t}\n\t\n// function made for airdrop\n\tfunction airdrop(address[] _to, uint256[] _value) onlyOwner notStopped public {\n\t    for(uint256 i = 0; i < _to.length; i++){\n\t        if(balances[_to[i]] > 0){\n\t            continue;\n\t        }\n\t        transfer(_to[i], _value[i]);\n\t    }\n\t}\n\n// blacklist management\n    function blacklisting(address _addr) onlyOwner public {\n        blackList[_addr] = 1;\n        emit Blacklisted(_addr);\n    }\n    function deleteFromBlacklist(address _addr) onlyOwner public {\n        blackList[_addr] = -1;\n        emit DeleteFromBlacklist(_addr);\n    }\n\n// stop the contract\n// SWC-100-Function Default Visibility: L90\n\tfunction stop() onlyOwner {\n        stopped = true;\n    }\n// SWC-100-Function Default Visibility: L94\n    function start() onlyOwner {\n        stopped = false;\n    }\n\t\n// ERC20 functions\n\tfunction balanceOf(address _owner) public constant returns (uint256 balance){\n\t\treturn balances[_owner];\n\t}\n\tfunction transfer(address _to, uint256 _value) notStopped public returns (bool success){\n\t\trequire(balances[msg.sender] >= _value);\n\n\t\tif(blackList[msg.sender] > 0){\n\t\t\temit RejectedPaymentFromBlacklistedAddr(msg.sender, _to, _value);\n\t\t\treturn false;\n\t\t}\n\t\tif(blackList[_to] > 0){\n\t\t\temit RejectedPaymentToBlacklistedAddr(msg.sender, _to, _value);\n\t\t\treturn false;\n\t\t}\n\n\t\tbalances[msg.sender] -= _value;\n\t\tbalances[_to] += _value;\n\t\temit Transfer(msg.sender, _to, _value);\n\t\treturn true;\n\t}\n\tfunction transferFrom(address _from, address _to, uint256 _value) notStopped public returns (bool success){\n\t\trequire(balances[_from] >= _value\n\t\t\t&& allowed[_from][msg.sender] >= _value);\n\n\t\tif(blackList[_from] > 0){\n\t\t\temit RejectedPaymentFromBlacklistedAddr(_from, _to, _value);\n\t\t\treturn false;\n\t\t}\n\t\tif(blackList[_to] > 0){\n\t\t\temit RejectedPaymentToBlacklistedAddr(_from, _to, _value);\n\t\t\treturn false;\n\t\t}\n\n\t\tbalances[_from] -= _value;\n\t\tallowed[_from][msg.sender] -= _value;\n\t\tbalances[_to] += _value;\n\t\temit Transfer(_from, _to, _value);\n\t\treturn true;\n\t}\n\tfunction approve(address _spender, uint256 _value) notStopped public returns (bool success){\n\t\tallowed[msg.sender][_spender] = _value;\n\t\temit Approval(msg.sender, _spender, _value);\n\t\treturn true;\n\t}\n\tfunction allowance(address _owner, address _spender) public constant returns (uint256 remaining){\n\t\treturn allowed[_owner][_spender];\n\t}\n}",
        "function": "airdrop(address[],uint256[])",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Iosiro-CHAINSQUARE Smart Contract Audit/code/Etherscan-0xb41380174d0B06181513A5677b60200b93b5Efb4.sol",
        "vulnerability": "Exception State (SWC 110)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "library Utils {\n    using SafeMath for uint256;\n\n    function random(uint256 from, uint256 to, uint256 salty) private view returns (uint256) {\n        uint256 seed = uint256(\n            keccak256(\n                abi.encodePacked(\n                    block.timestamp + block.difficulty +\n                    ((uint256(keccak256(abi.encodePacked(block.coinbase)))) / (now)) +\n                    block.gaslimit +\n                    ((uint256(keccak256(abi.encodePacked(msg.sender)))) / (now)) +\n                    block.number +\n                    salty\n                )\n            )\n        );\n        return seed.mod(to - from) + from;\n    }\n\n    function isLotteryWon(uint256 salty, uint256 winningDoubleRewardPercentage) private view returns (bool) {\n        uint256 luckyNumber = random(0, 100, salty);\n        uint256 winPercentage = winningDoubleRewardPercentage;\n        return luckyNumber <= winPercentage;\n    }\n\n    function calculateBNBReward(\n        uint256 _tTotal,\n        uint256 currentBalance,\n        uint256 currentBNBPool,\n        uint256 winningDoubleRewardPercentage,\n        uint256 totalSupply,\n        address ofAddress\n    ) public view returns (uint256) {\n        uint256 bnbPool = currentBNBPool;\n\n        // calculate reward to send\n        bool isLotteryWonOnClaim = isLotteryWon(currentBalance, winningDoubleRewardPercentage);\n        uint256 multiplier = 100;\n\n        if (isLotteryWonOnClaim) {\n            multiplier = random(150, 200, currentBalance);\n        }\n\n        // now calculate reward\n        uint256 reward = bnbPool.mul(multiplier).mul(currentBalance).div(100).div(totalSupply);\n        \n        // disable warning\n        _tTotal;\n        ofAddress;\n\n        return reward;\n    }\n\n    function calculateTopUpClaim(\n        uint256 currentRecipientBalance,\n        uint256 basedRewardCycleBlock,\n        uint256 threshHoldTopUpRate,\n        uint256 amount\n    ) public view returns (uint256) {\n        if (currentRecipientBalance == 0) {\n            return block.timestamp + basedRewardCycleBlock;\n        }\n        else {\n            uint256 rate = amount.mul(100).div(currentRecipientBalance);\n\n            if (uint256(rate) >= threshHoldTopUpRate) {\n                uint256 incurCycleBlock = basedRewardCycleBlock.mul(uint256(rate)).div(100);\n\n                if (incurCycleBlock >= basedRewardCycleBlock) {\n                    incurCycleBlock = basedRewardCycleBlock;\n                }\n\n                return incurCycleBlock;\n            }\n\n            return 0;\n        }\n    }\n\n    function swapTokensForEth(\n        address routerAddress,\n        uint256 tokenAmount\n    ) public {\n        InutRouter02 nutRouter = InutRouter02(routerAddress);\n\n        // generate the pancake pair path of token -> weth\n        address[] memory path = new address[](2);\n        path[0] = address(this);\n        path[1] = nutRouter.WETH();\n\n        // make the swap\n        nutRouter.swapExactTokensForETHSupportingFeeOnTransferTokens(\n            tokenAmount,\n            0, // accept any amount of BNB\n            path,\n            address(this),\n            block.timestamp\n        );\n    }\n\n    function swapETHForTokens(\n        address routerAddress,\n        address recipient,\n        uint256 ethAmount\n    ) public {\n        InutRouter02 nutRouter = InutRouter02(routerAddress);\n\n        // generate the pancake pair path of token -> weth\n        address[] memory path = new address[](2);\n        path[0] = nutRouter.WETH();\n        path[1] = address(this);\n\n        // make the swap\n        nutRouter.swapExactETHForTokensSupportingFeeOnTransferTokens{value: ethAmount}(\n            0, // accept any amount of BNB\n            path,\n            address(recipient),\n            block.timestamp + 360\n        );\n    }\n\n    function addLiquidity(\n        address routerAddress,\n        address owner,\n        uint256 tokenAmount,\n        uint256 ethAmount\n    ) public {\n        InutRouter02 nutRouter = InutRouter02(routerAddress);\n\n        // add the liquidity\n        nutRouter.addLiquidityETH{value : ethAmount}(\n            address(this),\n            tokenAmount,\n            0, // slippage is unavoidable\n            0, // slippage is unavoidable\n            owner,\n            block.timestamp + 360\n        );\n    }\n}",
        "function": "calculateTopUpClaim(uint256,uint256,uint256,uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/QuillAudits-Moonship Smart Contract/contracts-74658f327c56d66dae8e9c96bffa3f98e806c831/moonship.sol",
        "vulnerability": "Integer Arithmetic Bugs (SWC 101)",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "library Utils {\n    using SafeMath for uint256;\n\n    function random(uint256 from, uint256 to, uint256 salty) private view returns (uint256) {\n        uint256 seed = uint256(\n            keccak256(\n                abi.encodePacked(\n                    block.timestamp + block.difficulty +\n                    ((uint256(keccak256(abi.encodePacked(block.coinbase)))) / (now)) +\n                    block.gaslimit +\n                    ((uint256(keccak256(abi.encodePacked(msg.sender)))) / (now)) +\n                    block.number +\n                    salty\n                )\n            )\n        );\n        return seed.mod(to - from) + from;\n    }\n\n    function isLotteryWon(uint256 salty, uint256 winningDoubleRewardPercentage) private view returns (bool) {\n        uint256 luckyNumber = random(0, 100, salty);\n        uint256 winPercentage = winningDoubleRewardPercentage;\n        return luckyNumber <= winPercentage;\n    }\n\n    function calculateBNBReward(\n        uint256 _tTotal,\n        uint256 currentBalance,\n        uint256 currentBNBPool,\n        uint256 winningDoubleRewardPercentage,\n        uint256 totalSupply,\n        address ofAddress\n    ) public view returns (uint256) {\n        uint256 bnbPool = currentBNBPool;\n\n        // calculate reward to send\n        bool isLotteryWonOnClaim = isLotteryWon(currentBalance, winningDoubleRewardPercentage);\n        uint256 multiplier = 100;\n\n        if (isLotteryWonOnClaim) {\n            multiplier = random(150, 200, currentBalance);\n        }\n\n        // now calculate reward\n        uint256 reward = bnbPool.mul(multiplier).mul(currentBalance).div(100).div(totalSupply);\n        \n        // disable warning\n        _tTotal;\n        ofAddress;\n\n        return reward;\n    }\n\n    function calculateTopUpClaim(\n        uint256 currentRecipientBalance,\n        uint256 basedRewardCycleBlock,\n        uint256 threshHoldTopUpRate,\n        uint256 amount\n    ) public view returns (uint256) {\n        if (currentRecipientBalance == 0) {\n            return block.timestamp + basedRewardCycleBlock;\n        }\n        else {\n            uint256 rate = amount.mul(100).div(currentRecipientBalance);\n\n            if (uint256(rate) >= threshHoldTopUpRate) {\n                uint256 incurCycleBlock = basedRewardCycleBlock.mul(uint256(rate)).div(100);\n\n                if (incurCycleBlock >= basedRewardCycleBlock) {\n                    incurCycleBlock = basedRewardCycleBlock;\n                }\n\n                return incurCycleBlock;\n            }\n\n            return 0;\n        }\n    }\n\n    function swapTokensForEth(\n        address routerAddress,\n        uint256 tokenAmount\n    ) public {\n        InutRouter02 nutRouter = InutRouter02(routerAddress);\n\n        // generate the pancake pair path of token -> weth\n        address[] memory path = new address[](2);\n        path[0] = address(this);\n        path[1] = nutRouter.WETH();\n\n        // make the swap\n        nutRouter.swapExactTokensForETHSupportingFeeOnTransferTokens(\n            tokenAmount,\n            0, // accept any amount of BNB\n            path,\n            address(this),\n            block.timestamp\n        );\n    }\n\n    function swapETHForTokens(\n        address routerAddress,\n        address recipient,\n        uint256 ethAmount\n    ) public {\n        InutRouter02 nutRouter = InutRouter02(routerAddress);\n\n        // generate the pancake pair path of token -> weth\n        address[] memory path = new address[](2);\n        path[0] = nutRouter.WETH();\n        path[1] = address(this);\n\n        // make the swap\n        nutRouter.swapExactETHForTokensSupportingFeeOnTransferTokens{value: ethAmount}(\n            0, // accept any amount of BNB\n            path,\n            address(recipient),\n            block.timestamp + 360\n        );\n    }\n\n    function addLiquidity(\n        address routerAddress,\n        address owner,\n        uint256 tokenAmount,\n        uint256 ethAmount\n    ) public {\n        InutRouter02 nutRouter = InutRouter02(routerAddress);\n\n        // add the liquidity\n        nutRouter.addLiquidityETH{value : ethAmount}(\n            address(this),\n            tokenAmount,\n            0, // slippage is unavoidable\n            0, // slippage is unavoidable\n            owner,\n            block.timestamp + 360\n        );\n    }\n}",
        "function": "calculateBNBReward(uint256,uint256,uint256,uint256,uint256,address)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/QuillAudits-Moonship Smart Contract/contracts-74658f327c56d66dae8e9c96bffa3f98e806c831/moonship.sol",
        "vulnerability": "Dependence on predictable environment variable (SWC 116)",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "library Utils {\n    using SafeMath for uint256;\n\n    function random(uint256 from, uint256 to, uint256 salty) private view returns (uint256) {\n        uint256 seed = uint256(\n            keccak256(\n                abi.encodePacked(\n                    block.timestamp + block.difficulty +\n                    ((uint256(keccak256(abi.encodePacked(block.coinbase)))) / (now)) +\n                    block.gaslimit +\n                    ((uint256(keccak256(abi.encodePacked(msg.sender)))) / (now)) +\n                    block.number +\n                    salty\n                )\n            )\n        );\n        return seed.mod(to - from) + from;\n    }\n\n    function isLotteryWon(uint256 salty, uint256 winningDoubleRewardPercentage) private view returns (bool) {\n        uint256 luckyNumber = random(0, 100, salty);\n        uint256 winPercentage = winningDoubleRewardPercentage;\n        return luckyNumber <= winPercentage;\n    }\n\n    function calculateBNBReward(\n        uint256 _tTotal,\n        uint256 currentBalance,\n        uint256 currentBNBPool,\n        uint256 winningDoubleRewardPercentage,\n        uint256 totalSupply,\n        address ofAddress\n    ) public view returns (uint256) {\n        uint256 bnbPool = currentBNBPool;\n\n        // calculate reward to send\n        bool isLotteryWonOnClaim = isLotteryWon(currentBalance, winningDoubleRewardPercentage);\n        uint256 multiplier = 100;\n\n        if (isLotteryWonOnClaim) {\n            multiplier = random(150, 200, currentBalance);\n        }\n\n        // now calculate reward\n        uint256 reward = bnbPool.mul(multiplier).mul(currentBalance).div(100).div(totalSupply);\n        \n        // disable warning\n        _tTotal;\n        ofAddress;\n\n        return reward;\n    }\n\n    function calculateTopUpClaim(\n        uint256 currentRecipientBalance,\n        uint256 basedRewardCycleBlock,\n        uint256 threshHoldTopUpRate,\n        uint256 amount\n    ) public view returns (uint256) {\n        if (currentRecipientBalance == 0) {\n            return block.timestamp + basedRewardCycleBlock;\n        }\n        else {\n            uint256 rate = amount.mul(100).div(currentRecipientBalance);\n\n            if (uint256(rate) >= threshHoldTopUpRate) {\n                uint256 incurCycleBlock = basedRewardCycleBlock.mul(uint256(rate)).div(100);\n\n                if (incurCycleBlock >= basedRewardCycleBlock) {\n                    incurCycleBlock = basedRewardCycleBlock;\n                }\n\n                return incurCycleBlock;\n            }\n\n            return 0;\n        }\n    }\n\n    function swapTokensForEth(\n        address routerAddress,\n        uint256 tokenAmount\n    ) public {\n        InutRouter02 nutRouter = InutRouter02(routerAddress);\n\n        // generate the pancake pair path of token -> weth\n        address[] memory path = new address[](2);\n        path[0] = address(this);\n        path[1] = nutRouter.WETH();\n\n        // make the swap\n        nutRouter.swapExactTokensForETHSupportingFeeOnTransferTokens(\n            tokenAmount,\n            0, // accept any amount of BNB\n            path,\n            address(this),\n            block.timestamp\n        );\n    }\n\n    function swapETHForTokens(\n        address routerAddress,\n        address recipient,\n        uint256 ethAmount\n    ) public {\n        InutRouter02 nutRouter = InutRouter02(routerAddress);\n\n        // generate the pancake pair path of token -> weth\n        address[] memory path = new address[](2);\n        path[0] = nutRouter.WETH();\n        path[1] = address(this);\n\n        // make the swap\n        nutRouter.swapExactETHForTokensSupportingFeeOnTransferTokens{value: ethAmount}(\n            0, // accept any amount of BNB\n            path,\n            address(recipient),\n            block.timestamp + 360\n        );\n    }\n\n    function addLiquidity(\n        address routerAddress,\n        address owner,\n        uint256 tokenAmount,\n        uint256 ethAmount\n    ) public {\n        InutRouter02 nutRouter = InutRouter02(routerAddress);\n\n        // add the liquidity\n        nutRouter.addLiquidityETH{value : ethAmount}(\n            address(this),\n            tokenAmount,\n            0, // slippage is unavoidable\n            0, // slippage is unavoidable\n            owner,\n            block.timestamp + 360\n        );\n    }\n}",
        "function": "calculateBNBReward(uint256,uint256,uint256,uint256,uint256,address)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/QuillAudits-Moonship Smart Contract/contracts-74658f327c56d66dae8e9c96bffa3f98e806c831/moonship.sol",
        "vulnerability": "Exception State (SWC 110)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "library Utils {\n    using SafeMath for uint256;\n\n    function random(uint256 from, uint256 to, uint256 salty) private view returns (uint256) {\n        uint256 seed = uint256(\n            keccak256(\n                abi.encodePacked(\n                    block.timestamp + block.difficulty +\n                    ((uint256(keccak256(abi.encodePacked(block.coinbase)))) / (now)) +\n                    block.gaslimit +\n                    ((uint256(keccak256(abi.encodePacked(msg.sender)))) / (now)) +\n                    block.number +\n                    salty\n                )\n            )\n        );\n        return seed.mod(to - from) + from;\n    }\n\n    function isLotteryWon(uint256 salty, uint256 winningDoubleRewardPercentage) private view returns (bool) {\n        uint256 luckyNumber = random(0, 100, salty);\n        uint256 winPercentage = winningDoubleRewardPercentage;\n        return luckyNumber <= winPercentage;\n    }\n\n    function calculateBNBReward(\n        uint256 _tTotal,\n        uint256 currentBalance,\n        uint256 currentBNBPool,\n        uint256 winningDoubleRewardPercentage,\n        uint256 totalSupply,\n        address ofAddress\n    ) public view returns (uint256) {\n        uint256 bnbPool = currentBNBPool;\n\n        // calculate reward to send\n        bool isLotteryWonOnClaim = isLotteryWon(currentBalance, winningDoubleRewardPercentage);\n        uint256 multiplier = 100;\n\n        if (isLotteryWonOnClaim) {\n            multiplier = random(150, 200, currentBalance);\n        }\n\n        // now calculate reward\n        uint256 reward = bnbPool.mul(multiplier).mul(currentBalance).div(100).div(totalSupply);\n        \n        // disable warning\n        _tTotal;\n        ofAddress;\n\n        return reward;\n    }\n\n    function calculateTopUpClaim(\n        uint256 currentRecipientBalance,\n        uint256 basedRewardCycleBlock,\n        uint256 threshHoldTopUpRate,\n        uint256 amount\n    ) public view returns (uint256) {\n        if (currentRecipientBalance == 0) {\n            return block.timestamp + basedRewardCycleBlock;\n        }\n        else {\n            uint256 rate = amount.mul(100).div(currentRecipientBalance);\n\n            if (uint256(rate) >= threshHoldTopUpRate) {\n                uint256 incurCycleBlock = basedRewardCycleBlock.mul(uint256(rate)).div(100);\n\n                if (incurCycleBlock >= basedRewardCycleBlock) {\n                    incurCycleBlock = basedRewardCycleBlock;\n                }\n\n                return incurCycleBlock;\n            }\n\n            return 0;\n        }\n    }\n\n    function swapTokensForEth(\n        address routerAddress,\n        uint256 tokenAmount\n    ) public {\n        InutRouter02 nutRouter = InutRouter02(routerAddress);\n\n        // generate the pancake pair path of token -> weth\n        address[] memory path = new address[](2);\n        path[0] = address(this);\n        path[1] = nutRouter.WETH();\n\n        // make the swap\n        nutRouter.swapExactTokensForETHSupportingFeeOnTransferTokens(\n            tokenAmount,\n            0, // accept any amount of BNB\n            path,\n            address(this),\n            block.timestamp\n        );\n    }\n\n    function swapETHForTokens(\n        address routerAddress,\n        address recipient,\n        uint256 ethAmount\n    ) public {\n        InutRouter02 nutRouter = InutRouter02(routerAddress);\n\n        // generate the pancake pair path of token -> weth\n        address[] memory path = new address[](2);\n        path[0] = nutRouter.WETH();\n        path[1] = address(this);\n\n        // make the swap\n        nutRouter.swapExactETHForTokensSupportingFeeOnTransferTokens{value: ethAmount}(\n            0, // accept any amount of BNB\n            path,\n            address(recipient),\n            block.timestamp + 360\n        );\n    }\n\n    function addLiquidity(\n        address routerAddress,\n        address owner,\n        uint256 tokenAmount,\n        uint256 ethAmount\n    ) public {\n        InutRouter02 nutRouter = InutRouter02(routerAddress);\n\n        // add the liquidity\n        nutRouter.addLiquidityETH{value : ethAmount}(\n            address(this),\n            tokenAmount,\n            0, // slippage is unavoidable\n            0, // slippage is unavoidable\n            owner,\n            block.timestamp + 360\n        );\n    }\n}",
        "function": "calculateBNBReward(uint256,uint256,uint256,uint256,uint256,address)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/QuillAudits-Moonship Smart Contract/contracts-74658f327c56d66dae8e9c96bffa3f98e806c831/moonship.sol",
        "vulnerability": "Dependence on predictable environment variable (SWC 116)",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract BorrowerOperations is LiquityBase, Ownable, CheckContract, IBorrowerOperations {\n\n    // --- Connected contract declarations ---\n\n    ITroveManager public troveManager;\n\n    address stabilityPoolAddress;\n\n    address gasPoolAddress;\n\n    ICollSurplusPool collSurplusPool;\n\n    ILQTYStaking public lqtyStaking;\n    address public lqtyStakingAddress;\n\n    ILUSDToken public lusdToken;\n\n    // A doubly linked list of Troves, sorted by their sorted by their collateral ratios\n    ISortedTroves public sortedTroves;\n\n    /* --- Variable container structs  ---\n\n    Used to hold, return and assign variables inside a function, in order to avoid the error:\n    \"CompilerError: Stack too deep\". */\n\n     struct LocalVariables_adjustTrove {\n        uint price;\n        uint collChange;\n        uint netDebtChange;\n        bool isCollIncrease;\n        uint debt;\n        uint coll;\n        uint oldICR;\n        uint newICR;\n        uint newTCR;\n        uint LUSDFee;\n        uint newDebt;\n        uint newColl;\n        uint stake;\n    }\n\n    struct LocalVariables_openTrove {\n        uint price;\n        uint LUSDFee;\n        uint netDebt;\n        uint compositeDebt;\n        uint ICR;\n        uint NICR;\n        uint stake;\n        uint arrayIndex;\n    }\n\n    struct ContractsCache {\n        ITroveManager troveManager;\n        IActivePool activePool;\n        ILUSDToken lusdToken;\n    }\n\n    enum BorrowerOperation {\n        openTrove,\n        closeTrove,\n        adjustTrove\n    }\n\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\n    event ActivePoolAddressChanged(address _activePoolAddress);\n    event DefaultPoolAddressChanged(address _defaultPoolAddress);\n    event StabilityPoolAddressChanged(address _stabilityPoolAddress);\n    event GasPoolAddressChanged(address _gasPoolAddress);\n    event CollSurplusPoolAddressChanged(address _collSurplusPoolAddress);\n    event PriceFeedAddressChanged(address  _newPriceFeedAddress);\n    event SortedTrovesAddressChanged(address _sortedTrovesAddress);\n    event LUSDTokenAddressChanged(address _lusdTokenAddress);\n    event LQTYStakingAddressChanged(address _lqtyStakingAddress);\n\n    event TroveCreated(address indexed _borrower, uint arrayIndex);\n    event TroveUpdated(address indexed _borrower, uint _debt, uint _coll, uint stake, BorrowerOperation operation);\n    event LUSDBorrowingFeePaid(address indexed _borrower, uint _LUSDFee);\n    \n    // --- Dependency setters ---\n\n    function setAddresses(\n        address _troveManagerAddress,\n        address _activePoolAddress,\n        address _defaultPoolAddress,\n        address _stabilityPoolAddress,\n        address _gasPoolAddress,\n        address _collSurplusPoolAddress,\n        address _priceFeedAddress,\n        address _sortedTrovesAddress,\n        address _lusdTokenAddress,\n        address _lqtyStakingAddress\n    )\n        external\n        override\n        onlyOwner\n    {\n        // This makes impossible to open a trove with zero withdrawn LUSD\n        assert(MIN_NET_DEBT > 0);\n\n        checkContract(_troveManagerAddress);\n        checkContract(_activePoolAddress);\n        checkContract(_defaultPoolAddress);\n        checkContract(_stabilityPoolAddress);\n        checkContract(_gasPoolAddress);\n        checkContract(_collSurplusPoolAddress);\n        checkContract(_priceFeedAddress);\n        checkContract(_sortedTrovesAddress);\n        checkContract(_lusdTokenAddress);\n        checkContract(_lqtyStakingAddress);\n\n        troveManager = ITroveManager(_troveManagerAddress);\n        activePool = IActivePool(_activePoolAddress);\n        defaultPool = IDefaultPool(_defaultPoolAddress);\n        stabilityPoolAddress = _stabilityPoolAddress;\n        gasPoolAddress = _gasPoolAddress;\n        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);\n        priceFeed = IPriceFeed(_priceFeedAddress);\n        sortedTroves = ISortedTroves(_sortedTrovesAddress);\n        lusdToken = ILUSDToken(_lusdTokenAddress);\n        lqtyStakingAddress = _lqtyStakingAddress;\n        lqtyStaking = ILQTYStaking(_lqtyStakingAddress);\n\n        emit TroveManagerAddressChanged(_troveManagerAddress);\n        emit ActivePoolAddressChanged(_activePoolAddress);\n        emit DefaultPoolAddressChanged(_defaultPoolAddress);\n        emit StabilityPoolAddressChanged(_stabilityPoolAddress);\n        emit GasPoolAddressChanged(_gasPoolAddress);\n        emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);\n        emit PriceFeedAddressChanged(_priceFeedAddress);\n        emit SortedTrovesAddressChanged(_sortedTrovesAddress);\n        emit LUSDTokenAddressChanged(_lusdTokenAddress);\n        emit LQTYStakingAddressChanged(_lqtyStakingAddress);\n\n        _renounceOwnership();\n    }\n\n    // --- Borrower Trove Operations ---\n\n    function openTrove(uint _maxFeePercentage, uint _LUSDAmount, address _upperHint, address _lowerHint) external payable override {\n        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, lusdToken);\n        LocalVariables_openTrove memory vars;\n\n        vars.price = priceFeed.fetchPrice();\n        bool isRecoveryMode = _checkRecoveryMode(vars.price);\n\n        _requireValidMaxFeePercentage(_maxFeePercentage, isRecoveryMode);\n        _requireTroveisNotActive(contractsCache.troveManager, msg.sender);\n\n        vars.LUSDFee;\n        vars.netDebt = _LUSDAmount;\n\n        if (!isRecoveryMode) {\n            vars.LUSDFee = _triggerBorrowingFee(contractsCache.troveManager, contractsCache.lusdToken, _LUSDAmount, _maxFeePercentage);\n            vars.netDebt = vars.netDebt.add(vars.LUSDFee);\n        }\n        _requireAtLeastMinNetDebt(vars.netDebt);\n\n        // ICR is based on the composite debt, i.e. the requested LUSD amount + LUSD borrowing fee + LUSD gas comp.\n        vars.compositeDebt = _getCompositeDebt(vars.netDebt);\n        assert(vars.compositeDebt > 0);\n        \n        vars.ICR = LiquityMath._computeCR(msg.value, vars.compositeDebt, vars.price);\n        vars.NICR = LiquityMath._computeNominalCR(msg.value, vars.compositeDebt);\n\n        if (isRecoveryMode) {\n            _requireICRisAboveCCR(vars.ICR);\n        } else {\n            _requireICRisAboveMCR(vars.ICR);\n            uint newTCR = _getNewTCRFromTroveChange(msg.value, true, vars.compositeDebt, true, vars.price);  // bools: coll increase, debt increase\n            _requireNewTCRisAboveCCR(newTCR); \n        }\n\n        // Set the trove struct's properties\n        contractsCache.troveManager.setTroveStatus(msg.sender, 1);\n        contractsCache.troveManager.increaseTroveColl(msg.sender, msg.value);\n        contractsCache.troveManager.increaseTroveDebt(msg.sender, vars.compositeDebt);\n\n        contractsCache.troveManager.updateTroveRewardSnapshots(msg.sender);\n        vars.stake = contractsCache.troveManager.updateStakeAndTotalStakes(msg.sender);\n\n        sortedTroves.insert(msg.sender, vars.NICR, _upperHint, _lowerHint);\n        vars.arrayIndex = contractsCache.troveManager.addTroveOwnerToArray(msg.sender);\n        emit TroveCreated(msg.sender, vars.arrayIndex);\n\n        // Move the ether to the Active Pool, and mint the LUSDAmount to the borrower\n        _activePoolAddColl(contractsCache.activePool, msg.value);\n        _withdrawLUSD(contractsCache.activePool, contractsCache.lusdToken, msg.sender, _LUSDAmount, vars.netDebt);\n        // Move the LUSD gas compensation to the Gas Pool\n        _withdrawLUSD(contractsCache.activePool, contractsCache.lusdToken, gasPoolAddress, LUSD_GAS_COMPENSATION, LUSD_GAS_COMPENSATION);\n\n        emit TroveUpdated(msg.sender, vars.compositeDebt, msg.value, vars.stake, BorrowerOperation.openTrove);\n        emit LUSDBorrowingFeePaid(msg.sender, vars.LUSDFee);\n    }\n\n    // Send ETH as collateral to a trove\n    function addColl(address _upperHint, address _lowerHint) external payable override {\n        _adjustTrove(msg.sender, 0, 0, false, _upperHint, _lowerHint, 0);\n    }\n\n    // Send ETH as collateral to a trove. Called by only the Stability Pool.\n    function moveETHGainToTrove(address _borrower, address _upperHint, address _lowerHint) external payable override {\n        _requireCallerIsStabilityPool();\n        _adjustTrove(_borrower, 0, 0, false, _upperHint, _lowerHint, 0);\n    }\n\n    // Withdraw ETH collateral from a trove\n    function withdrawColl(uint _collWithdrawal, address _upperHint, address _lowerHint) external override {\n        _adjustTrove(msg.sender, _collWithdrawal, 0, false, _upperHint, _lowerHint, 0);\n    }\n\n    // Withdraw LUSD tokens from a trove: mint new LUSD tokens to the owner, and increase the trove's debt accordingly\n    function withdrawLUSD(uint _maxFeePercentage, uint _LUSDAmount, address _upperHint, address _lowerHint) external override {\n        _adjustTrove(msg.sender, 0, _LUSDAmount, true, _upperHint, _lowerHint, _maxFeePercentage);\n    }\n\n    // Repay LUSD tokens to a Trove: Burn the repaid LUSD tokens, and reduce the trove's debt accordingly\n    function repayLUSD(uint _LUSDAmount, address _upperHint, address _lowerHint) external override {\n        _adjustTrove(msg.sender, 0, _LUSDAmount, false, _upperHint, _lowerHint, 0);\n    }\n\n    function adjustTrove(uint _maxFeePercentage, uint _collWithdrawal, uint _LUSDChange, bool _isDebtIncrease, address _upperHint, address _lowerHint) external payable override {\n        _adjustTrove(msg.sender, _collWithdrawal, _LUSDChange, _isDebtIncrease, _upperHint, _lowerHint, _maxFeePercentage);\n    }\n\n    /*\n    * _adjustTrove(): Alongside a debt change, this function can perform either a collateral top-up or a collateral withdrawal. \n    *\n    * It therefore expects either a positive msg.value, or a positive _collWithdrawal argument.\n    *\n    * If both are positive, it will revert.\n    */\n    function _adjustTrove(address _borrower, uint _collWithdrawal, uint _LUSDChange, bool _isDebtIncrease, address _upperHint, address _lowerHint, uint _maxFeePercentage) internal {\n        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, lusdToken);\n        LocalVariables_adjustTrove memory vars;\n\n        vars.price = priceFeed.fetchPrice();\n        bool isRecoveryMode = _checkRecoveryMode(vars.price);\n\n        if (_isDebtIncrease) {\n            _requireValidMaxFeePercentage(_maxFeePercentage, isRecoveryMode);\n            _requireNonZeroDebtChange(_LUSDChange);\n        }\n        _requireSingularCollChange(_collWithdrawal);\n        _requireNonZeroAdjustment(_collWithdrawal, _LUSDChange);\n        _requireTroveisActive(contractsCache.troveManager, _borrower);\n        \n        // Confirm the operation is either a borrower adjusting their own trove, or a pure ETH transfer from the Stability Pool to a trove\n        assert(msg.sender == _borrower || (msg.sender == stabilityPoolAddress && msg.value > 0 && _LUSDChange == 0));\n\n        contractsCache.troveManager.applyPendingRewards(_borrower);\n\n        // Get the collChange based on whether or not ETH was sent in the transaction\n        (vars.collChange, vars.isCollIncrease) = _getCollChange(msg.value, _collWithdrawal);\n\n        vars.netDebtChange = _LUSDChange;\n\n        // If the adjustment incorporates a debt increase and system is in Normal Mode, then trigger a borrowing fee\n        if (_isDebtIncrease && !isRecoveryMode) { \n            vars.LUSDFee = _triggerBorrowingFee(contractsCache.troveManager, contractsCache.lusdToken, _LUSDChange, _maxFeePercentage);\n            vars.netDebtChange = vars.netDebtChange.add(vars.LUSDFee); // The raw debt change includes the fee\n        }\n\n        vars.debt = contractsCache.troveManager.getTroveDebt(_borrower);\n        vars.coll = contractsCache.troveManager.getTroveColl(_borrower);\n        \n        // Get the trove's old ICR before the adjustment, and what its new ICR will be after the adjustment\n        vars.oldICR = LiquityMath._computeCR(vars.coll, vars.debt, vars.price);\n        vars.newICR = _getNewICRFromTroveChange(vars.coll, vars.debt, vars.collChange, vars.isCollIncrease, vars.netDebtChange, _isDebtIncrease, vars.price);\n        assert(_collWithdrawal <= vars.coll); \n\n        // Check the adjustment satisfies all conditions for the current system mode\n        _requireValidAdjustmentInCurrentMode(isRecoveryMode, _collWithdrawal, _isDebtIncrease, vars);\n            \n        // When the adjustment is a debt repayment, check it's a valid amount and that the caller has enough LUSD\n        if (!_isDebtIncrease && _LUSDChange > 0) {\n            _requireAtLeastMinNetDebt(_getNetDebt(vars.debt).sub(vars.netDebtChange));\n            _requireValidLUSDRepayment(vars.debt, vars.netDebtChange);\n            _requireSufficientLUSDBalance(contractsCache.lusdToken, _borrower, vars.netDebtChange);\n        }\n\n        (vars.newColl, vars.newDebt) = _updateTroveFromAdjustment(contractsCache.troveManager, _borrower, vars.collChange, vars.isCollIncrease, vars.netDebtChange, _isDebtIncrease);\n        vars.stake = contractsCache.troveManager.updateStakeAndTotalStakes(_borrower);\n\n        // Re-insert trove in to the sorted list\n        uint newNICR = _getNewNominalICRFromTroveChange(vars.coll, vars.debt, vars.collChange, vars.isCollIncrease, vars.netDebtChange, _isDebtIncrease);\n        sortedTroves.reInsert(_borrower, newNICR, _upperHint, _lowerHint);\n\n        emit TroveUpdated(_borrower, vars.newDebt, vars.newColl, vars.stake, BorrowerOperation.adjustTrove);\n        emit LUSDBorrowingFeePaid(msg.sender,  vars.LUSDFee);\n\n        // Use the unmodified _LUSDChange here, as we don't send the fee to the user\n        _moveTokensAndETHfromAdjustment(\n            contractsCache.activePool,\n            contractsCache.lusdToken,\n            msg.sender,\n            vars.collChange,\n            vars.isCollIncrease,\n            _LUSDChange,\n            _isDebtIncrease,\n            vars.netDebtChange\n        );\n    }\n\n// SWC-105-Unprotected Ether Withdrawal: L321 - L351\n    function closeTrove() external override {\n        ITroveManager troveManagerCached = troveManager;\n        IActivePool activePoolCached = activePool;\n        ILUSDToken lusdTokenCached = lusdToken;\n\n        _requireTroveisActive(troveManagerCached, msg.sender);\n        uint price = priceFeed.fetchPrice();\n        _requireNotInRecoveryMode(price);\n\n        troveManagerCached.applyPendingRewards(msg.sender);\n\n        uint coll = troveManagerCached.getTroveColl(msg.sender);\n        uint debt = troveManagerCached.getTroveDebt(msg.sender);\n\n        _requireSufficientLUSDBalance(lusdTokenCached, msg.sender, debt.sub(LUSD_GAS_COMPENSATION));\n\n        uint newTCR = _getNewTCRFromTroveChange(coll, false, debt, false, price);\n        _requireNewTCRisAboveCCR(newTCR);\n\n        troveManagerCached.removeStake(msg.sender);\n        troveManagerCached.closeTrove(msg.sender);\n\n        emit TroveUpdated(msg.sender, 0, 0, 0, BorrowerOperation.closeTrove);\n\n        // Burn the repaid LUSD from the user's balance and the gas compensation from the Gas Pool\n        _repayLUSD(activePoolCached, lusdTokenCached, msg.sender, debt.sub(LUSD_GAS_COMPENSATION));\n        _repayLUSD(activePoolCached, lusdTokenCached, gasPoolAddress, LUSD_GAS_COMPENSATION);\n\n        // Send the collateral back to the user\n        activePoolCached.sendETH(msg.sender, coll);\n    }\n\n    /**\n     * Claim remaining collateral from a redemption or from a liquidation with ICR > MCR in Recovery Mode\n     */\n    function claimCollateral() external override {\n        // send ETH from CollSurplus Pool to owner\n        collSurplusPool.claimColl(msg.sender);\n    }\n\n    // --- Helper functions ---\n\n    function _triggerBorrowingFee(ITroveManager _troveManager, ILUSDToken _lusdToken, uint _LUSDAmount, uint _maxFeePercentage) internal returns (uint) {\n        _troveManager.decayBaseRateFromBorrowing(); // decay the baseRate state variable\n        uint LUSDFee = _troveManager.getBorrowingFee(_LUSDAmount);\n\n        _requireUserAcceptsFee(LUSDFee, _LUSDAmount, _maxFeePercentage);\n        \n        // Send fee to LQTY staking contract\n        lqtyStaking.increaseF_LUSD(LUSDFee);\n        _lusdToken.mint(lqtyStakingAddress, LUSDFee);\n\n        return LUSDFee;\n    }\n\n    function _getUSDValue(uint _coll, uint _price) internal pure returns (uint) {\n        uint usdValue = _price.mul(_coll).div(DECIMAL_PRECISION);\n\n        return usdValue;\n    }\n\n    function _getCollChange(\n        uint _collReceived,\n        uint _requestedCollWithdrawal\n    )\n        internal\n        pure\n        returns(uint collChange, bool isCollIncrease)\n    {\n        if (_collReceived != 0) {\n            collChange = _collReceived;\n            isCollIncrease = true;\n        } else {\n            collChange = _requestedCollWithdrawal;\n        }\n    }\n\n    // Update trove's coll and debt based on whether they increase or decrease\n    function _updateTroveFromAdjustment\n    (\n        ITroveManager _troveManager,\n        address _borrower,\n        uint _collChange,\n        bool _isCollIncrease,\n        uint _debtChange,\n        bool _isDebtIncrease\n    )\n        internal\n        returns (uint, uint)\n    {\n        uint newColl = (_isCollIncrease) ? _troveManager.increaseTroveColl(_borrower, _collChange)\n                                        : _troveManager.decreaseTroveColl(_borrower, _collChange);\n        uint newDebt = (_isDebtIncrease) ? _troveManager.increaseTroveDebt(_borrower, _debtChange)\n                                        : _troveManager.decreaseTroveDebt(_borrower, _debtChange);\n\n        return (newColl, newDebt);\n    }\n\n    function _moveTokensAndETHfromAdjustment\n    (\n        IActivePool _activePool,\n        ILUSDToken _lusdToken,\n        address _borrower,\n        uint _collChange,\n        bool _isCollIncrease,\n        uint _LUSDChange,\n        bool _isDebtIncrease,\n        uint _netDebtChange\n    )\n        internal\n    {\n        if (_isDebtIncrease) {\n            _withdrawLUSD(_activePool, _lusdToken, _borrower, _LUSDChange, _netDebtChange);\n        } else {\n            _repayLUSD(_activePool, _lusdToken, _borrower, _LUSDChange);\n        }\n\n        if (_isCollIncrease) {\n            _activePoolAddColl(_activePool, _collChange);\n        } else {\n            _activePool.sendETH(_borrower, _collChange);\n        }\n    }\n\n    // Send ETH to Active Pool and increase its recorded ETH balance\n    function _activePoolAddColl(IActivePool _activePool, uint _amount) internal {\n        (bool success, ) = address(_activePool).call{value: _amount}(\"\");\n        require(success, \"BorrowerOps: Sending ETH to ActivePool failed\");\n    }\n\n    // Issue the specified amount of LUSD to _account and increases the total active debt (_netDebtIncrease potentially includes a LUSDFee)\n    function _withdrawLUSD(IActivePool _activePool, ILUSDToken _lusdToken, address _account, uint _LUSDAmount, uint _netDebtIncrease) internal {\n        _activePool.increaseLUSDDebt(_netDebtIncrease);\n        _lusdToken.mint(_account, _LUSDAmount);\n    }\n\n    // Burn the specified amount of LUSD from _account and decreases the total active debt\n    function _repayLUSD(IActivePool _activePool, ILUSDToken _lusdToken, address _account, uint _LUSD) internal {\n        _activePool.decreaseLUSDDebt(_LUSD);\n        _lusdToken.burn(_account, _LUSD);\n    }\n\n    // --- 'Require' wrapper functions ---\n\n    function _requireSingularCollChange(uint _collWithdrawal) internal view {\n        require(msg.value == 0 || _collWithdrawal == 0, \"BorrowerOperations: Cannot withdraw and add coll\");\n    }\n\n    function _requireCallerIsBorrower(address _borrower) internal view {\n        require(msg.sender == _borrower, \"BorrowerOps: Caller must be the borrower for a withdrawal\");\n    }\n\n    function _requireNonZeroAdjustment(uint _collWithdrawal, uint _LUSDChange) internal view {\n        require(msg.value != 0 || _collWithdrawal != 0 || _LUSDChange != 0, \"BorrowerOps: There must be either a collateral change or a debt change\");\n    }\n\n    function _requireTroveisActive(ITroveManager _troveManager, address _borrower) internal view {\n        uint status = _troveManager.getTroveStatus(_borrower);\n        require(status == 1, \"BorrowerOps: Trove does not exist or is closed\");\n    }\n\n    function _requireTroveisNotActive(ITroveManager _troveManager, address _borrower) internal view {\n        uint status = _troveManager.getTroveStatus(_borrower);\n        require(status != 1, \"BorrowerOps: Trove is active\");\n    }\n\n    function _requireNonZeroDebtChange(uint _LUSDChange) internal pure {\n        require(_LUSDChange > 0, \"BorrowerOps: Debt increase requires non-zero debtChange\");\n    }\n   \n    function _requireNotInRecoveryMode(uint _price) internal view {\n        require(!_checkRecoveryMode(_price), \"BorrowerOps: Operation not permitted during Recovery Mode\");\n    }\n\n    function _requireNoCollWithdrawal(uint _collWithdrawal) internal pure {\n        require(_collWithdrawal == 0, \"BorrowerOps: Collateral withdrawal not permitted Recovery Mode\");\n    }\n\n    function _requireValidAdjustmentInCurrentMode \n    (\n        bool _isRecoveryMode,\n        uint _collWithdrawal,\n        bool _isDebtIncrease, \n        LocalVariables_adjustTrove memory _vars\n    ) \n        internal \n        view \n    {\n        /* \n        *In Recovery Mode, only allow:\n        *\n        * - Pure collateral top-up\n        * - Pure debt repayment\n        * - Collateral top-up with debt repayment\n        * - A debt increase combined with a collateral top-up which makes the ICR >= 150% and improves the ICR (and by extension improves the TCR).\n        *\n        * In Normal Mode, ensure:\n        *\n        * - The new ICR is above MCR\n        * - The adjustment won't pull the TCR below CCR\n        */\n        if (_isRecoveryMode) {\n            _requireNoCollWithdrawal(_collWithdrawal);\n            if (_isDebtIncrease) {\n                _requireICRisAboveCCR(_vars.newICR);\n                _requireNewICRisAboveOldICR(_vars.newICR, _vars.oldICR);\n            }       \n        } else { // if Normal Mode\n            _requireICRisAboveMCR(_vars.newICR);\n            _vars.newTCR = _getNewTCRFromTroveChange(_vars.collChange, _vars.isCollIncrease, _vars.netDebtChange, _isDebtIncrease, _vars.price);\n            _requireNewTCRisAboveCCR(_vars.newTCR);  \n        }\n    }\n\n    function _requireICRisAboveMCR(uint _newICR) internal pure {\n        require(_newICR >= MCR, \"BorrowerOps: An operation that would result in ICR < MCR is not permitted\");\n    }\n\n    function _requireICRisAboveCCR(uint _newICR) internal pure {\n        require(_newICR >= CCR, \"BorrowerOps: Operation must leave trove with ICR >= CCR\");\n    }\n\n    function _requireNewICRisAboveOldICR(uint _newICR, uint _oldICR) internal pure {\n        require(_newICR >= _oldICR, \"BorrowerOps: Cannot decrease your Trove's ICR in Recovery Mode\");\n    }\n\n    function _requireNewTCRisAboveCCR(uint _newTCR) internal pure {\n        require(_newTCR >= CCR, \"BorrowerOps: An operation that would result in TCR < CCR is not permitted\");\n    }\n\n    function _requireAtLeastMinNetDebt(uint _netDebt) internal pure {\n        require (_netDebt >= MIN_NET_DEBT, \"BorrowerOps: Trove's net debt must be greater than minimum\");\n    }\n\n    function _requireValidLUSDRepayment(uint _currentDebt, uint _debtRepayment) internal pure {\n        require(_debtRepayment <= _currentDebt.sub(LUSD_GAS_COMPENSATION), \"BorrowerOps: Amount repaid must not be larger than the Trove's debt\");\n    }\n\n    function _requireCallerIsStabilityPool() internal view {\n        require(msg.sender == stabilityPoolAddress, \"BorrowerOps: Caller is not Stability Pool\");\n    }\n\n     function _requireSufficientLUSDBalance(ILUSDToken _lusdToken, address _borrower, uint _debtRepayment) internal view {\n        require(_lusdToken.balanceOf(_borrower) >= _debtRepayment, \"BorrowerOps: Caller doesnt have enough LUSD to make repayment\");\n    }\n\n    function _requireValidMaxFeePercentage(uint _maxFeePercentage, bool _isRecoveryMode) internal pure {\n        if (_isRecoveryMode) {\n            require(_maxFeePercentage <= DECIMAL_PRECISION,\n                \"Max fee percentage must less than or equal to 100%\");\n        } else {\n            require(_maxFeePercentage >= BORROWING_FEE_FLOOR && _maxFeePercentage <= DECIMAL_PRECISION,\n                \"Max fee percentage must be between 0.5% and 100%\");\n        }\n    }\n\n    // --- ICR and TCR getters ---\n\n    // Compute the new collateral ratio, considering the change in coll and debt. Assumes 0 pending rewards.\n    function _getNewNominalICRFromTroveChange\n    (\n        uint _coll,\n        uint _debt,\n        uint _collChange,\n        bool _isCollIncrease,\n        uint _debtChange,\n        bool _isDebtIncrease\n    )\n        pure\n        internal\n        returns (uint)\n    {\n        (uint newColl, uint newDebt) = _getNewTroveAmounts(_coll, _debt, _collChange, _isCollIncrease, _debtChange, _isDebtIncrease);\n\n        uint newNICR = LiquityMath._computeNominalCR(newColl, newDebt);\n        return newNICR;\n    }\n\n    // Compute the new collateral ratio, considering the change in coll and debt. Assumes 0 pending rewards.\n    function _getNewICRFromTroveChange\n    (\n        uint _coll,\n        uint _debt,\n        uint _collChange,\n        bool _isCollIncrease,\n        uint _debtChange,\n        bool _isDebtIncrease,\n        uint _price\n    )\n        pure\n        internal\n        returns (uint)\n    {\n        (uint newColl, uint newDebt) = _getNewTroveAmounts(_coll, _debt, _collChange, _isCollIncrease, _debtChange, _isDebtIncrease);\n\n        uint newICR = LiquityMath._computeCR(newColl, newDebt, _price);\n        return newICR;\n    }\n\n    function _getNewTroveAmounts(\n        uint _coll,\n        uint _debt,\n        uint _collChange,\n        bool _isCollIncrease,\n        uint _debtChange,\n        bool _isDebtIncrease\n    )\n        internal\n        pure\n        returns (uint, uint)\n    {\n        uint newColl = _coll;\n        uint newDebt = _debt;\n\n        newColl = _isCollIncrease ? _coll.add(_collChange) :  _coll.sub(_collChange);\n        newDebt = _isDebtIncrease ? _debt.add(_debtChange) : _debt.sub(_debtChange);\n\n        return (newColl, newDebt);\n    }\n\n    function _getNewTCRFromTroveChange\n    (\n        uint _collChange,\n        bool _isCollIncrease,\n        uint _debtChange,\n        bool _isDebtIncrease,\n        uint _price\n    )\n        internal\n        view\n        returns (uint)\n    {\n        uint totalColl = getEntireSystemColl();\n        uint totalDebt = getEntireSystemDebt();\n\n        totalColl = _isCollIncrease ? totalColl.add(_collChange) : totalColl.sub(_collChange);\n        totalDebt = _isDebtIncrease ? totalDebt.add(_debtChange) : totalDebt.sub(_debtChange);\n\n        uint newTCR = LiquityMath._computeCR(totalColl, totalDebt, _price);\n        return newTCR;\n    }\n\n    function getCompositeDebt(uint _debt) external pure override returns (uint) {\n        return _getCompositeDebt(_debt);\n    }\n}",
        "function": "claimCollateral()",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinspect-Liquity Audit/dev-dd7f59b980e7dab1cebc84c017db3a2c4caa522c/packages/contracts/contracts/BorrowerOperations.sol",
        "vulnerability": "External Call To User-Supplied Address (SWC 107)",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract BorrowerOperations is LiquityBase, Ownable, CheckContract, IBorrowerOperations {\n\n    // --- Connected contract declarations ---\n\n    ITroveManager public troveManager;\n\n    address stabilityPoolAddress;\n\n    address gasPoolAddress;\n\n    ICollSurplusPool collSurplusPool;\n\n    ILQTYStaking public lqtyStaking;\n    address public lqtyStakingAddress;\n\n    ILUSDToken public lusdToken;\n\n    // A doubly linked list of Troves, sorted by their sorted by their collateral ratios\n    ISortedTroves public sortedTroves;\n\n    /* --- Variable container structs  ---\n\n    Used to hold, return and assign variables inside a function, in order to avoid the error:\n    \"CompilerError: Stack too deep\". */\n\n     struct LocalVariables_adjustTrove {\n        uint price;\n        uint collChange;\n        uint netDebtChange;\n        bool isCollIncrease;\n        uint debt;\n        uint coll;\n        uint oldICR;\n        uint newICR;\n        uint newTCR;\n        uint LUSDFee;\n        uint newDebt;\n        uint newColl;\n        uint stake;\n    }\n\n    struct LocalVariables_openTrove {\n        uint price;\n        uint LUSDFee;\n        uint netDebt;\n        uint compositeDebt;\n        uint ICR;\n        uint NICR;\n        uint stake;\n        uint arrayIndex;\n    }\n\n    struct ContractsCache {\n        ITroveManager troveManager;\n        IActivePool activePool;\n        ILUSDToken lusdToken;\n    }\n\n    enum BorrowerOperation {\n        openTrove,\n        closeTrove,\n        adjustTrove\n    }\n\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\n    event ActivePoolAddressChanged(address _activePoolAddress);\n    event DefaultPoolAddressChanged(address _defaultPoolAddress);\n    event StabilityPoolAddressChanged(address _stabilityPoolAddress);\n    event GasPoolAddressChanged(address _gasPoolAddress);\n    event CollSurplusPoolAddressChanged(address _collSurplusPoolAddress);\n    event PriceFeedAddressChanged(address  _newPriceFeedAddress);\n    event SortedTrovesAddressChanged(address _sortedTrovesAddress);\n    event LUSDTokenAddressChanged(address _lusdTokenAddress);\n    event LQTYStakingAddressChanged(address _lqtyStakingAddress);\n\n    event TroveCreated(address indexed _borrower, uint arrayIndex);\n    event TroveUpdated(address indexed _borrower, uint _debt, uint _coll, uint stake, BorrowerOperation operation);\n    event LUSDBorrowingFeePaid(address indexed _borrower, uint _LUSDFee);\n    \n    // --- Dependency setters ---\n\n    function setAddresses(\n        address _troveManagerAddress,\n        address _activePoolAddress,\n        address _defaultPoolAddress,\n        address _stabilityPoolAddress,\n        address _gasPoolAddress,\n        address _collSurplusPoolAddress,\n        address _priceFeedAddress,\n        address _sortedTrovesAddress,\n        address _lusdTokenAddress,\n        address _lqtyStakingAddress\n    )\n        external\n        override\n        onlyOwner\n    {\n        // This makes impossible to open a trove with zero withdrawn LUSD\n        assert(MIN_NET_DEBT > 0);\n\n        checkContract(_troveManagerAddress);\n        checkContract(_activePoolAddress);\n        checkContract(_defaultPoolAddress);\n        checkContract(_stabilityPoolAddress);\n        checkContract(_gasPoolAddress);\n        checkContract(_collSurplusPoolAddress);\n        checkContract(_priceFeedAddress);\n        checkContract(_sortedTrovesAddress);\n        checkContract(_lusdTokenAddress);\n        checkContract(_lqtyStakingAddress);\n\n        troveManager = ITroveManager(_troveManagerAddress);\n        activePool = IActivePool(_activePoolAddress);\n        defaultPool = IDefaultPool(_defaultPoolAddress);\n        stabilityPoolAddress = _stabilityPoolAddress;\n        gasPoolAddress = _gasPoolAddress;\n        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);\n        priceFeed = IPriceFeed(_priceFeedAddress);\n        sortedTroves = ISortedTroves(_sortedTrovesAddress);\n        lusdToken = ILUSDToken(_lusdTokenAddress);\n        lqtyStakingAddress = _lqtyStakingAddress;\n        lqtyStaking = ILQTYStaking(_lqtyStakingAddress);\n\n        emit TroveManagerAddressChanged(_troveManagerAddress);\n        emit ActivePoolAddressChanged(_activePoolAddress);\n        emit DefaultPoolAddressChanged(_defaultPoolAddress);\n        emit StabilityPoolAddressChanged(_stabilityPoolAddress);\n        emit GasPoolAddressChanged(_gasPoolAddress);\n        emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);\n        emit PriceFeedAddressChanged(_priceFeedAddress);\n        emit SortedTrovesAddressChanged(_sortedTrovesAddress);\n        emit LUSDTokenAddressChanged(_lusdTokenAddress);\n        emit LQTYStakingAddressChanged(_lqtyStakingAddress);\n\n        _renounceOwnership();\n    }\n\n    // --- Borrower Trove Operations ---\n\n    function openTrove(uint _maxFeePercentage, uint _LUSDAmount, address _upperHint, address _lowerHint) external payable override {\n        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, lusdToken);\n        LocalVariables_openTrove memory vars;\n\n        vars.price = priceFeed.fetchPrice();\n        bool isRecoveryMode = _checkRecoveryMode(vars.price);\n\n        _requireValidMaxFeePercentage(_maxFeePercentage, isRecoveryMode);\n        _requireTroveisNotActive(contractsCache.troveManager, msg.sender);\n\n        vars.LUSDFee;\n        vars.netDebt = _LUSDAmount;\n\n        if (!isRecoveryMode) {\n            vars.LUSDFee = _triggerBorrowingFee(contractsCache.troveManager, contractsCache.lusdToken, _LUSDAmount, _maxFeePercentage);\n            vars.netDebt = vars.netDebt.add(vars.LUSDFee);\n        }\n        _requireAtLeastMinNetDebt(vars.netDebt);\n\n        // ICR is based on the composite debt, i.e. the requested LUSD amount + LUSD borrowing fee + LUSD gas comp.\n        vars.compositeDebt = _getCompositeDebt(vars.netDebt);\n        assert(vars.compositeDebt > 0);\n        \n        vars.ICR = LiquityMath._computeCR(msg.value, vars.compositeDebt, vars.price);\n        vars.NICR = LiquityMath._computeNominalCR(msg.value, vars.compositeDebt);\n\n        if (isRecoveryMode) {\n            _requireICRisAboveCCR(vars.ICR);\n        } else {\n            _requireICRisAboveMCR(vars.ICR);\n            uint newTCR = _getNewTCRFromTroveChange(msg.value, true, vars.compositeDebt, true, vars.price);  // bools: coll increase, debt increase\n            _requireNewTCRisAboveCCR(newTCR); \n        }\n\n        // Set the trove struct's properties\n        contractsCache.troveManager.setTroveStatus(msg.sender, 1);\n        contractsCache.troveManager.increaseTroveColl(msg.sender, msg.value);\n        contractsCache.troveManager.increaseTroveDebt(msg.sender, vars.compositeDebt);\n\n        contractsCache.troveManager.updateTroveRewardSnapshots(msg.sender);\n        vars.stake = contractsCache.troveManager.updateStakeAndTotalStakes(msg.sender);\n\n        sortedTroves.insert(msg.sender, vars.NICR, _upperHint, _lowerHint);\n        vars.arrayIndex = contractsCache.troveManager.addTroveOwnerToArray(msg.sender);\n        emit TroveCreated(msg.sender, vars.arrayIndex);\n\n        // Move the ether to the Active Pool, and mint the LUSDAmount to the borrower\n        _activePoolAddColl(contractsCache.activePool, msg.value);\n        _withdrawLUSD(contractsCache.activePool, contractsCache.lusdToken, msg.sender, _LUSDAmount, vars.netDebt);\n        // Move the LUSD gas compensation to the Gas Pool\n        _withdrawLUSD(contractsCache.activePool, contractsCache.lusdToken, gasPoolAddress, LUSD_GAS_COMPENSATION, LUSD_GAS_COMPENSATION);\n\n        emit TroveUpdated(msg.sender, vars.compositeDebt, msg.value, vars.stake, BorrowerOperation.openTrove);\n        emit LUSDBorrowingFeePaid(msg.sender, vars.LUSDFee);\n    }\n\n    // Send ETH as collateral to a trove\n    function addColl(address _upperHint, address _lowerHint) external payable override {\n        _adjustTrove(msg.sender, 0, 0, false, _upperHint, _lowerHint, 0);\n    }\n\n    // Send ETH as collateral to a trove. Called by only the Stability Pool.\n    function moveETHGainToTrove(address _borrower, address _upperHint, address _lowerHint) external payable override {\n        _requireCallerIsStabilityPool();\n        _adjustTrove(_borrower, 0, 0, false, _upperHint, _lowerHint, 0);\n    }\n\n    // Withdraw ETH collateral from a trove\n    function withdrawColl(uint _collWithdrawal, address _upperHint, address _lowerHint) external override {\n        _adjustTrove(msg.sender, _collWithdrawal, 0, false, _upperHint, _lowerHint, 0);\n    }\n\n    // Withdraw LUSD tokens from a trove: mint new LUSD tokens to the owner, and increase the trove's debt accordingly\n    function withdrawLUSD(uint _maxFeePercentage, uint _LUSDAmount, address _upperHint, address _lowerHint) external override {\n        _adjustTrove(msg.sender, 0, _LUSDAmount, true, _upperHint, _lowerHint, _maxFeePercentage);\n    }\n\n    // Repay LUSD tokens to a Trove: Burn the repaid LUSD tokens, and reduce the trove's debt accordingly\n    function repayLUSD(uint _LUSDAmount, address _upperHint, address _lowerHint) external override {\n        _adjustTrove(msg.sender, 0, _LUSDAmount, false, _upperHint, _lowerHint, 0);\n    }\n\n    function adjustTrove(uint _maxFeePercentage, uint _collWithdrawal, uint _LUSDChange, bool _isDebtIncrease, address _upperHint, address _lowerHint) external payable override {\n        _adjustTrove(msg.sender, _collWithdrawal, _LUSDChange, _isDebtIncrease, _upperHint, _lowerHint, _maxFeePercentage);\n    }\n\n    /*\n    * _adjustTrove(): Alongside a debt change, this function can perform either a collateral top-up or a collateral withdrawal. \n    *\n    * It therefore expects either a positive msg.value, or a positive _collWithdrawal argument.\n    *\n    * If both are positive, it will revert.\n    */\n    function _adjustTrove(address _borrower, uint _collWithdrawal, uint _LUSDChange, bool _isDebtIncrease, address _upperHint, address _lowerHint, uint _maxFeePercentage) internal {\n        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, lusdToken);\n        LocalVariables_adjustTrove memory vars;\n\n        vars.price = priceFeed.fetchPrice();\n        bool isRecoveryMode = _checkRecoveryMode(vars.price);\n\n        if (_isDebtIncrease) {\n            _requireValidMaxFeePercentage(_maxFeePercentage, isRecoveryMode);\n            _requireNonZeroDebtChange(_LUSDChange);\n        }\n        _requireSingularCollChange(_collWithdrawal);\n        _requireNonZeroAdjustment(_collWithdrawal, _LUSDChange);\n        _requireTroveisActive(contractsCache.troveManager, _borrower);\n        \n        // Confirm the operation is either a borrower adjusting their own trove, or a pure ETH transfer from the Stability Pool to a trove\n        assert(msg.sender == _borrower || (msg.sender == stabilityPoolAddress && msg.value > 0 && _LUSDChange == 0));\n\n        contractsCache.troveManager.applyPendingRewards(_borrower);\n\n        // Get the collChange based on whether or not ETH was sent in the transaction\n        (vars.collChange, vars.isCollIncrease) = _getCollChange(msg.value, _collWithdrawal);\n\n        vars.netDebtChange = _LUSDChange;\n\n        // If the adjustment incorporates a debt increase and system is in Normal Mode, then trigger a borrowing fee\n        if (_isDebtIncrease && !isRecoveryMode) { \n            vars.LUSDFee = _triggerBorrowingFee(contractsCache.troveManager, contractsCache.lusdToken, _LUSDChange, _maxFeePercentage);\n            vars.netDebtChange = vars.netDebtChange.add(vars.LUSDFee); // The raw debt change includes the fee\n        }\n\n        vars.debt = contractsCache.troveManager.getTroveDebt(_borrower);\n        vars.coll = contractsCache.troveManager.getTroveColl(_borrower);\n        \n        // Get the trove's old ICR before the adjustment, and what its new ICR will be after the adjustment\n        vars.oldICR = LiquityMath._computeCR(vars.coll, vars.debt, vars.price);\n        vars.newICR = _getNewICRFromTroveChange(vars.coll, vars.debt, vars.collChange, vars.isCollIncrease, vars.netDebtChange, _isDebtIncrease, vars.price);\n        assert(_collWithdrawal <= vars.coll); \n\n        // Check the adjustment satisfies all conditions for the current system mode\n        _requireValidAdjustmentInCurrentMode(isRecoveryMode, _collWithdrawal, _isDebtIncrease, vars);\n            \n        // When the adjustment is a debt repayment, check it's a valid amount and that the caller has enough LUSD\n        if (!_isDebtIncrease && _LUSDChange > 0) {\n            _requireAtLeastMinNetDebt(_getNetDebt(vars.debt).sub(vars.netDebtChange));\n            _requireValidLUSDRepayment(vars.debt, vars.netDebtChange);\n            _requireSufficientLUSDBalance(contractsCache.lusdToken, _borrower, vars.netDebtChange);\n        }\n\n        (vars.newColl, vars.newDebt) = _updateTroveFromAdjustment(contractsCache.troveManager, _borrower, vars.collChange, vars.isCollIncrease, vars.netDebtChange, _isDebtIncrease);\n        vars.stake = contractsCache.troveManager.updateStakeAndTotalStakes(_borrower);\n\n        // Re-insert trove in to the sorted list\n        uint newNICR = _getNewNominalICRFromTroveChange(vars.coll, vars.debt, vars.collChange, vars.isCollIncrease, vars.netDebtChange, _isDebtIncrease);\n        sortedTroves.reInsert(_borrower, newNICR, _upperHint, _lowerHint);\n\n        emit TroveUpdated(_borrower, vars.newDebt, vars.newColl, vars.stake, BorrowerOperation.adjustTrove);\n        emit LUSDBorrowingFeePaid(msg.sender,  vars.LUSDFee);\n\n        // Use the unmodified _LUSDChange here, as we don't send the fee to the user\n        _moveTokensAndETHfromAdjustment(\n            contractsCache.activePool,\n            contractsCache.lusdToken,\n            msg.sender,\n            vars.collChange,\n            vars.isCollIncrease,\n            _LUSDChange,\n            _isDebtIncrease,\n            vars.netDebtChange\n        );\n    }\n\n// SWC-105-Unprotected Ether Withdrawal: L321 - L351\n    function closeTrove() external override {\n        ITroveManager troveManagerCached = troveManager;\n        IActivePool activePoolCached = activePool;\n        ILUSDToken lusdTokenCached = lusdToken;\n\n        _requireTroveisActive(troveManagerCached, msg.sender);\n        uint price = priceFeed.fetchPrice();\n        _requireNotInRecoveryMode(price);\n\n        troveManagerCached.applyPendingRewards(msg.sender);\n\n        uint coll = troveManagerCached.getTroveColl(msg.sender);\n        uint debt = troveManagerCached.getTroveDebt(msg.sender);\n\n        _requireSufficientLUSDBalance(lusdTokenCached, msg.sender, debt.sub(LUSD_GAS_COMPENSATION));\n\n        uint newTCR = _getNewTCRFromTroveChange(coll, false, debt, false, price);\n        _requireNewTCRisAboveCCR(newTCR);\n\n        troveManagerCached.removeStake(msg.sender);\n        troveManagerCached.closeTrove(msg.sender);\n\n        emit TroveUpdated(msg.sender, 0, 0, 0, BorrowerOperation.closeTrove);\n\n        // Burn the repaid LUSD from the user's balance and the gas compensation from the Gas Pool\n        _repayLUSD(activePoolCached, lusdTokenCached, msg.sender, debt.sub(LUSD_GAS_COMPENSATION));\n        _repayLUSD(activePoolCached, lusdTokenCached, gasPoolAddress, LUSD_GAS_COMPENSATION);\n\n        // Send the collateral back to the user\n        activePoolCached.sendETH(msg.sender, coll);\n    }\n\n    /**\n     * Claim remaining collateral from a redemption or from a liquidation with ICR > MCR in Recovery Mode\n     */\n    function claimCollateral() external override {\n        // send ETH from CollSurplus Pool to owner\n        collSurplusPool.claimColl(msg.sender);\n    }\n\n    // --- Helper functions ---\n\n    function _triggerBorrowingFee(ITroveManager _troveManager, ILUSDToken _lusdToken, uint _LUSDAmount, uint _maxFeePercentage) internal returns (uint) {\n        _troveManager.decayBaseRateFromBorrowing(); // decay the baseRate state variable\n        uint LUSDFee = _troveManager.getBorrowingFee(_LUSDAmount);\n\n        _requireUserAcceptsFee(LUSDFee, _LUSDAmount, _maxFeePercentage);\n        \n        // Send fee to LQTY staking contract\n        lqtyStaking.increaseF_LUSD(LUSDFee);\n        _lusdToken.mint(lqtyStakingAddress, LUSDFee);\n\n        return LUSDFee;\n    }\n\n    function _getUSDValue(uint _coll, uint _price) internal pure returns (uint) {\n        uint usdValue = _price.mul(_coll).div(DECIMAL_PRECISION);\n\n        return usdValue;\n    }\n\n    function _getCollChange(\n        uint _collReceived,\n        uint _requestedCollWithdrawal\n    )\n        internal\n        pure\n        returns(uint collChange, bool isCollIncrease)\n    {\n        if (_collReceived != 0) {\n            collChange = _collReceived;\n            isCollIncrease = true;\n        } else {\n            collChange = _requestedCollWithdrawal;\n        }\n    }\n\n    // Update trove's coll and debt based on whether they increase or decrease\n    function _updateTroveFromAdjustment\n    (\n        ITroveManager _troveManager,\n        address _borrower,\n        uint _collChange,\n        bool _isCollIncrease,\n        uint _debtChange,\n        bool _isDebtIncrease\n    )\n        internal\n        returns (uint, uint)\n    {\n        uint newColl = (_isCollIncrease) ? _troveManager.increaseTroveColl(_borrower, _collChange)\n                                        : _troveManager.decreaseTroveColl(_borrower, _collChange);\n        uint newDebt = (_isDebtIncrease) ? _troveManager.increaseTroveDebt(_borrower, _debtChange)\n                                        : _troveManager.decreaseTroveDebt(_borrower, _debtChange);\n\n        return (newColl, newDebt);\n    }\n\n    function _moveTokensAndETHfromAdjustment\n    (\n        IActivePool _activePool,\n        ILUSDToken _lusdToken,\n        address _borrower,\n        uint _collChange,\n        bool _isCollIncrease,\n        uint _LUSDChange,\n        bool _isDebtIncrease,\n        uint _netDebtChange\n    )\n        internal\n    {\n        if (_isDebtIncrease) {\n            _withdrawLUSD(_activePool, _lusdToken, _borrower, _LUSDChange, _netDebtChange);\n        } else {\n            _repayLUSD(_activePool, _lusdToken, _borrower, _LUSDChange);\n        }\n\n        if (_isCollIncrease) {\n            _activePoolAddColl(_activePool, _collChange);\n        } else {\n            _activePool.sendETH(_borrower, _collChange);\n        }\n    }\n\n    // Send ETH to Active Pool and increase its recorded ETH balance\n    function _activePoolAddColl(IActivePool _activePool, uint _amount) internal {\n        (bool success, ) = address(_activePool).call{value: _amount}(\"\");\n        require(success, \"BorrowerOps: Sending ETH to ActivePool failed\");\n    }\n\n    // Issue the specified amount of LUSD to _account and increases the total active debt (_netDebtIncrease potentially includes a LUSDFee)\n    function _withdrawLUSD(IActivePool _activePool, ILUSDToken _lusdToken, address _account, uint _LUSDAmount, uint _netDebtIncrease) internal {\n        _activePool.increaseLUSDDebt(_netDebtIncrease);\n        _lusdToken.mint(_account, _LUSDAmount);\n    }\n\n    // Burn the specified amount of LUSD from _account and decreases the total active debt\n    function _repayLUSD(IActivePool _activePool, ILUSDToken _lusdToken, address _account, uint _LUSD) internal {\n        _activePool.decreaseLUSDDebt(_LUSD);\n        _lusdToken.burn(_account, _LUSD);\n    }\n\n    // --- 'Require' wrapper functions ---\n\n    function _requireSingularCollChange(uint _collWithdrawal) internal view {\n        require(msg.value == 0 || _collWithdrawal == 0, \"BorrowerOperations: Cannot withdraw and add coll\");\n    }\n\n    function _requireCallerIsBorrower(address _borrower) internal view {\n        require(msg.sender == _borrower, \"BorrowerOps: Caller must be the borrower for a withdrawal\");\n    }\n\n    function _requireNonZeroAdjustment(uint _collWithdrawal, uint _LUSDChange) internal view {\n        require(msg.value != 0 || _collWithdrawal != 0 || _LUSDChange != 0, \"BorrowerOps: There must be either a collateral change or a debt change\");\n    }\n\n    function _requireTroveisActive(ITroveManager _troveManager, address _borrower) internal view {\n        uint status = _troveManager.getTroveStatus(_borrower);\n        require(status == 1, \"BorrowerOps: Trove does not exist or is closed\");\n    }\n\n    function _requireTroveisNotActive(ITroveManager _troveManager, address _borrower) internal view {\n        uint status = _troveManager.getTroveStatus(_borrower);\n        require(status != 1, \"BorrowerOps: Trove is active\");\n    }\n\n    function _requireNonZeroDebtChange(uint _LUSDChange) internal pure {\n        require(_LUSDChange > 0, \"BorrowerOps: Debt increase requires non-zero debtChange\");\n    }\n   \n    function _requireNotInRecoveryMode(uint _price) internal view {\n        require(!_checkRecoveryMode(_price), \"BorrowerOps: Operation not permitted during Recovery Mode\");\n    }\n\n    function _requireNoCollWithdrawal(uint _collWithdrawal) internal pure {\n        require(_collWithdrawal == 0, \"BorrowerOps: Collateral withdrawal not permitted Recovery Mode\");\n    }\n\n    function _requireValidAdjustmentInCurrentMode \n    (\n        bool _isRecoveryMode,\n        uint _collWithdrawal,\n        bool _isDebtIncrease, \n        LocalVariables_adjustTrove memory _vars\n    ) \n        internal \n        view \n    {\n        /* \n        *In Recovery Mode, only allow:\n        *\n        * - Pure collateral top-up\n        * - Pure debt repayment\n        * - Collateral top-up with debt repayment\n        * - A debt increase combined with a collateral top-up which makes the ICR >= 150% and improves the ICR (and by extension improves the TCR).\n        *\n        * In Normal Mode, ensure:\n        *\n        * - The new ICR is above MCR\n        * - The adjustment won't pull the TCR below CCR\n        */\n        if (_isRecoveryMode) {\n            _requireNoCollWithdrawal(_collWithdrawal);\n            if (_isDebtIncrease) {\n                _requireICRisAboveCCR(_vars.newICR);\n                _requireNewICRisAboveOldICR(_vars.newICR, _vars.oldICR);\n            }       \n        } else { // if Normal Mode\n            _requireICRisAboveMCR(_vars.newICR);\n            _vars.newTCR = _getNewTCRFromTroveChange(_vars.collChange, _vars.isCollIncrease, _vars.netDebtChange, _isDebtIncrease, _vars.price);\n            _requireNewTCRisAboveCCR(_vars.newTCR);  \n        }\n    }\n\n    function _requireICRisAboveMCR(uint _newICR) internal pure {\n        require(_newICR >= MCR, \"BorrowerOps: An operation that would result in ICR < MCR is not permitted\");\n    }\n\n    function _requireICRisAboveCCR(uint _newICR) internal pure {\n        require(_newICR >= CCR, \"BorrowerOps: Operation must leave trove with ICR >= CCR\");\n    }\n\n    function _requireNewICRisAboveOldICR(uint _newICR, uint _oldICR) internal pure {\n        require(_newICR >= _oldICR, \"BorrowerOps: Cannot decrease your Trove's ICR in Recovery Mode\");\n    }\n\n    function _requireNewTCRisAboveCCR(uint _newTCR) internal pure {\n        require(_newTCR >= CCR, \"BorrowerOps: An operation that would result in TCR < CCR is not permitted\");\n    }\n\n    function _requireAtLeastMinNetDebt(uint _netDebt) internal pure {\n        require (_netDebt >= MIN_NET_DEBT, \"BorrowerOps: Trove's net debt must be greater than minimum\");\n    }\n\n    function _requireValidLUSDRepayment(uint _currentDebt, uint _debtRepayment) internal pure {\n        require(_debtRepayment <= _currentDebt.sub(LUSD_GAS_COMPENSATION), \"BorrowerOps: Amount repaid must not be larger than the Trove's debt\");\n    }\n\n    function _requireCallerIsStabilityPool() internal view {\n        require(msg.sender == stabilityPoolAddress, \"BorrowerOps: Caller is not Stability Pool\");\n    }\n\n     function _requireSufficientLUSDBalance(ILUSDToken _lusdToken, address _borrower, uint _debtRepayment) internal view {\n        require(_lusdToken.balanceOf(_borrower) >= _debtRepayment, \"BorrowerOps: Caller doesnt have enough LUSD to make repayment\");\n    }\n\n    function _requireValidMaxFeePercentage(uint _maxFeePercentage, bool _isRecoveryMode) internal pure {\n        if (_isRecoveryMode) {\n            require(_maxFeePercentage <= DECIMAL_PRECISION,\n                \"Max fee percentage must less than or equal to 100%\");\n        } else {\n            require(_maxFeePercentage >= BORROWING_FEE_FLOOR && _maxFeePercentage <= DECIMAL_PRECISION,\n                \"Max fee percentage must be between 0.5% and 100%\");\n        }\n    }\n\n    // --- ICR and TCR getters ---\n\n    // Compute the new collateral ratio, considering the change in coll and debt. Assumes 0 pending rewards.\n    function _getNewNominalICRFromTroveChange\n    (\n        uint _coll,\n        uint _debt,\n        uint _collChange,\n        bool _isCollIncrease,\n        uint _debtChange,\n        bool _isDebtIncrease\n    )\n        pure\n        internal\n        returns (uint)\n    {\n        (uint newColl, uint newDebt) = _getNewTroveAmounts(_coll, _debt, _collChange, _isCollIncrease, _debtChange, _isDebtIncrease);\n\n        uint newNICR = LiquityMath._computeNominalCR(newColl, newDebt);\n        return newNICR;\n    }\n\n    // Compute the new collateral ratio, considering the change in coll and debt. Assumes 0 pending rewards.\n    function _getNewICRFromTroveChange\n    (\n        uint _coll,\n        uint _debt,\n        uint _collChange,\n        bool _isCollIncrease,\n        uint _debtChange,\n        bool _isDebtIncrease,\n        uint _price\n    )\n        pure\n        internal\n        returns (uint)\n    {\n        (uint newColl, uint newDebt) = _getNewTroveAmounts(_coll, _debt, _collChange, _isCollIncrease, _debtChange, _isDebtIncrease);\n\n        uint newICR = LiquityMath._computeCR(newColl, newDebt, _price);\n        return newICR;\n    }\n\n    function _getNewTroveAmounts(\n        uint _coll,\n        uint _debt,\n        uint _collChange,\n        bool _isCollIncrease,\n        uint _debtChange,\n        bool _isDebtIncrease\n    )\n        internal\n        pure\n        returns (uint, uint)\n    {\n        uint newColl = _coll;\n        uint newDebt = _debt;\n\n        newColl = _isCollIncrease ? _coll.add(_collChange) :  _coll.sub(_collChange);\n        newDebt = _isDebtIncrease ? _debt.add(_debtChange) : _debt.sub(_debtChange);\n\n        return (newColl, newDebt);\n    }\n\n    function _getNewTCRFromTroveChange\n    (\n        uint _collChange,\n        bool _isCollIncrease,\n        uint _debtChange,\n        bool _isDebtIncrease,\n        uint _price\n    )\n        internal\n        view\n        returns (uint)\n    {\n        uint totalColl = getEntireSystemColl();\n        uint totalDebt = getEntireSystemDebt();\n\n        totalColl = _isCollIncrease ? totalColl.add(_collChange) : totalColl.sub(_collChange);\n        totalDebt = _isDebtIncrease ? totalDebt.add(_debtChange) : totalDebt.sub(_debtChange);\n\n        uint newTCR = LiquityMath._computeCR(totalColl, totalDebt, _price);\n        return newTCR;\n    }\n\n    function getCompositeDebt(uint _debt) external pure override returns (uint) {\n        return _getCompositeDebt(_debt);\n    }\n}",
        "function": "getEntireSystemDebt()",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinspect-Liquity Audit/dev-dd7f59b980e7dab1cebc84c017db3a2c4caa522c/packages/contracts/contracts/BorrowerOperations.sol",
        "vulnerability": "Multiple Calls in a Single Transaction (SWC 113)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract BorrowerOperations is LiquityBase, Ownable, CheckContract, IBorrowerOperations {\n\n    // --- Connected contract declarations ---\n\n    ITroveManager public troveManager;\n\n    address stabilityPoolAddress;\n\n    address gasPoolAddress;\n\n    ICollSurplusPool collSurplusPool;\n\n    ILQTYStaking public lqtyStaking;\n    address public lqtyStakingAddress;\n\n    ILUSDToken public lusdToken;\n\n    // A doubly linked list of Troves, sorted by their sorted by their collateral ratios\n    ISortedTroves public sortedTroves;\n\n    /* --- Variable container structs  ---\n\n    Used to hold, return and assign variables inside a function, in order to avoid the error:\n    \"CompilerError: Stack too deep\". */\n\n     struct LocalVariables_adjustTrove {\n        uint price;\n        uint collChange;\n        uint netDebtChange;\n        bool isCollIncrease;\n        uint debt;\n        uint coll;\n        uint oldICR;\n        uint newICR;\n        uint newTCR;\n        uint LUSDFee;\n        uint newDebt;\n        uint newColl;\n        uint stake;\n    }\n\n    struct LocalVariables_openTrove {\n        uint price;\n        uint LUSDFee;\n        uint netDebt;\n        uint compositeDebt;\n        uint ICR;\n        uint NICR;\n        uint stake;\n        uint arrayIndex;\n    }\n\n    struct ContractsCache {\n        ITroveManager troveManager;\n        IActivePool activePool;\n        ILUSDToken lusdToken;\n    }\n\n    enum BorrowerOperation {\n        openTrove,\n        closeTrove,\n        adjustTrove\n    }\n\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\n    event ActivePoolAddressChanged(address _activePoolAddress);\n    event DefaultPoolAddressChanged(address _defaultPoolAddress);\n    event StabilityPoolAddressChanged(address _stabilityPoolAddress);\n    event GasPoolAddressChanged(address _gasPoolAddress);\n    event CollSurplusPoolAddressChanged(address _collSurplusPoolAddress);\n    event PriceFeedAddressChanged(address  _newPriceFeedAddress);\n    event SortedTrovesAddressChanged(address _sortedTrovesAddress);\n    event LUSDTokenAddressChanged(address _lusdTokenAddress);\n    event LQTYStakingAddressChanged(address _lqtyStakingAddress);\n\n    event TroveCreated(address indexed _borrower, uint arrayIndex);\n    event TroveUpdated(address indexed _borrower, uint _debt, uint _coll, uint stake, BorrowerOperation operation);\n    event LUSDBorrowingFeePaid(address indexed _borrower, uint _LUSDFee);\n    \n    // --- Dependency setters ---\n\n    function setAddresses(\n        address _troveManagerAddress,\n        address _activePoolAddress,\n        address _defaultPoolAddress,\n        address _stabilityPoolAddress,\n        address _gasPoolAddress,\n        address _collSurplusPoolAddress,\n        address _priceFeedAddress,\n        address _sortedTrovesAddress,\n        address _lusdTokenAddress,\n        address _lqtyStakingAddress\n    )\n        external\n        override\n        onlyOwner\n    {\n        // This makes impossible to open a trove with zero withdrawn LUSD\n        assert(MIN_NET_DEBT > 0);\n\n        checkContract(_troveManagerAddress);\n        checkContract(_activePoolAddress);\n        checkContract(_defaultPoolAddress);\n        checkContract(_stabilityPoolAddress);\n        checkContract(_gasPoolAddress);\n        checkContract(_collSurplusPoolAddress);\n        checkContract(_priceFeedAddress);\n        checkContract(_sortedTrovesAddress);\n        checkContract(_lusdTokenAddress);\n        checkContract(_lqtyStakingAddress);\n\n        troveManager = ITroveManager(_troveManagerAddress);\n        activePool = IActivePool(_activePoolAddress);\n        defaultPool = IDefaultPool(_defaultPoolAddress);\n        stabilityPoolAddress = _stabilityPoolAddress;\n        gasPoolAddress = _gasPoolAddress;\n        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);\n        priceFeed = IPriceFeed(_priceFeedAddress);\n        sortedTroves = ISortedTroves(_sortedTrovesAddress);\n        lusdToken = ILUSDToken(_lusdTokenAddress);\n        lqtyStakingAddress = _lqtyStakingAddress;\n        lqtyStaking = ILQTYStaking(_lqtyStakingAddress);\n\n        emit TroveManagerAddressChanged(_troveManagerAddress);\n        emit ActivePoolAddressChanged(_activePoolAddress);\n        emit DefaultPoolAddressChanged(_defaultPoolAddress);\n        emit StabilityPoolAddressChanged(_stabilityPoolAddress);\n        emit GasPoolAddressChanged(_gasPoolAddress);\n        emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);\n        emit PriceFeedAddressChanged(_priceFeedAddress);\n        emit SortedTrovesAddressChanged(_sortedTrovesAddress);\n        emit LUSDTokenAddressChanged(_lusdTokenAddress);\n        emit LQTYStakingAddressChanged(_lqtyStakingAddress);\n\n        _renounceOwnership();\n    }\n\n    // --- Borrower Trove Operations ---\n\n    function openTrove(uint _maxFeePercentage, uint _LUSDAmount, address _upperHint, address _lowerHint) external payable override {\n        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, lusdToken);\n        LocalVariables_openTrove memory vars;\n\n        vars.price = priceFeed.fetchPrice();\n        bool isRecoveryMode = _checkRecoveryMode(vars.price);\n\n        _requireValidMaxFeePercentage(_maxFeePercentage, isRecoveryMode);\n        _requireTroveisNotActive(contractsCache.troveManager, msg.sender);\n\n        vars.LUSDFee;\n        vars.netDebt = _LUSDAmount;\n\n        if (!isRecoveryMode) {\n            vars.LUSDFee = _triggerBorrowingFee(contractsCache.troveManager, contractsCache.lusdToken, _LUSDAmount, _maxFeePercentage);\n            vars.netDebt = vars.netDebt.add(vars.LUSDFee);\n        }\n        _requireAtLeastMinNetDebt(vars.netDebt);\n\n        // ICR is based on the composite debt, i.e. the requested LUSD amount + LUSD borrowing fee + LUSD gas comp.\n        vars.compositeDebt = _getCompositeDebt(vars.netDebt);\n        assert(vars.compositeDebt > 0);\n        \n        vars.ICR = LiquityMath._computeCR(msg.value, vars.compositeDebt, vars.price);\n        vars.NICR = LiquityMath._computeNominalCR(msg.value, vars.compositeDebt);\n\n        if (isRecoveryMode) {\n            _requireICRisAboveCCR(vars.ICR);\n        } else {\n            _requireICRisAboveMCR(vars.ICR);\n            uint newTCR = _getNewTCRFromTroveChange(msg.value, true, vars.compositeDebt, true, vars.price);  // bools: coll increase, debt increase\n            _requireNewTCRisAboveCCR(newTCR); \n        }\n\n        // Set the trove struct's properties\n        contractsCache.troveManager.setTroveStatus(msg.sender, 1);\n        contractsCache.troveManager.increaseTroveColl(msg.sender, msg.value);\n        contractsCache.troveManager.increaseTroveDebt(msg.sender, vars.compositeDebt);\n\n        contractsCache.troveManager.updateTroveRewardSnapshots(msg.sender);\n        vars.stake = contractsCache.troveManager.updateStakeAndTotalStakes(msg.sender);\n\n        sortedTroves.insert(msg.sender, vars.NICR, _upperHint, _lowerHint);\n        vars.arrayIndex = contractsCache.troveManager.addTroveOwnerToArray(msg.sender);\n        emit TroveCreated(msg.sender, vars.arrayIndex);\n\n        // Move the ether to the Active Pool, and mint the LUSDAmount to the borrower\n        _activePoolAddColl(contractsCache.activePool, msg.value);\n        _withdrawLUSD(contractsCache.activePool, contractsCache.lusdToken, msg.sender, _LUSDAmount, vars.netDebt);\n        // Move the LUSD gas compensation to the Gas Pool\n        _withdrawLUSD(contractsCache.activePool, contractsCache.lusdToken, gasPoolAddress, LUSD_GAS_COMPENSATION, LUSD_GAS_COMPENSATION);\n\n        emit TroveUpdated(msg.sender, vars.compositeDebt, msg.value, vars.stake, BorrowerOperation.openTrove);\n        emit LUSDBorrowingFeePaid(msg.sender, vars.LUSDFee);\n    }\n\n    // Send ETH as collateral to a trove\n    function addColl(address _upperHint, address _lowerHint) external payable override {\n        _adjustTrove(msg.sender, 0, 0, false, _upperHint, _lowerHint, 0);\n    }\n\n    // Send ETH as collateral to a trove. Called by only the Stability Pool.\n    function moveETHGainToTrove(address _borrower, address _upperHint, address _lowerHint) external payable override {\n        _requireCallerIsStabilityPool();\n        _adjustTrove(_borrower, 0, 0, false, _upperHint, _lowerHint, 0);\n    }\n\n    // Withdraw ETH collateral from a trove\n    function withdrawColl(uint _collWithdrawal, address _upperHint, address _lowerHint) external override {\n        _adjustTrove(msg.sender, _collWithdrawal, 0, false, _upperHint, _lowerHint, 0);\n    }\n\n    // Withdraw LUSD tokens from a trove: mint new LUSD tokens to the owner, and increase the trove's debt accordingly\n    function withdrawLUSD(uint _maxFeePercentage, uint _LUSDAmount, address _upperHint, address _lowerHint) external override {\n        _adjustTrove(msg.sender, 0, _LUSDAmount, true, _upperHint, _lowerHint, _maxFeePercentage);\n    }\n\n    // Repay LUSD tokens to a Trove: Burn the repaid LUSD tokens, and reduce the trove's debt accordingly\n    function repayLUSD(uint _LUSDAmount, address _upperHint, address _lowerHint) external override {\n        _adjustTrove(msg.sender, 0, _LUSDAmount, false, _upperHint, _lowerHint, 0);\n    }\n\n    function adjustTrove(uint _maxFeePercentage, uint _collWithdrawal, uint _LUSDChange, bool _isDebtIncrease, address _upperHint, address _lowerHint) external payable override {\n        _adjustTrove(msg.sender, _collWithdrawal, _LUSDChange, _isDebtIncrease, _upperHint, _lowerHint, _maxFeePercentage);\n    }\n\n    /*\n    * _adjustTrove(): Alongside a debt change, this function can perform either a collateral top-up or a collateral withdrawal. \n    *\n    * It therefore expects either a positive msg.value, or a positive _collWithdrawal argument.\n    *\n    * If both are positive, it will revert.\n    */\n    function _adjustTrove(address _borrower, uint _collWithdrawal, uint _LUSDChange, bool _isDebtIncrease, address _upperHint, address _lowerHint, uint _maxFeePercentage) internal {\n        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, lusdToken);\n        LocalVariables_adjustTrove memory vars;\n\n        vars.price = priceFeed.fetchPrice();\n        bool isRecoveryMode = _checkRecoveryMode(vars.price);\n\n        if (_isDebtIncrease) {\n            _requireValidMaxFeePercentage(_maxFeePercentage, isRecoveryMode);\n            _requireNonZeroDebtChange(_LUSDChange);\n        }\n        _requireSingularCollChange(_collWithdrawal);\n        _requireNonZeroAdjustment(_collWithdrawal, _LUSDChange);\n        _requireTroveisActive(contractsCache.troveManager, _borrower);\n        \n        // Confirm the operation is either a borrower adjusting their own trove, or a pure ETH transfer from the Stability Pool to a trove\n        assert(msg.sender == _borrower || (msg.sender == stabilityPoolAddress && msg.value > 0 && _LUSDChange == 0));\n\n        contractsCache.troveManager.applyPendingRewards(_borrower);\n\n        // Get the collChange based on whether or not ETH was sent in the transaction\n        (vars.collChange, vars.isCollIncrease) = _getCollChange(msg.value, _collWithdrawal);\n\n        vars.netDebtChange = _LUSDChange;\n\n        // If the adjustment incorporates a debt increase and system is in Normal Mode, then trigger a borrowing fee\n        if (_isDebtIncrease && !isRecoveryMode) { \n            vars.LUSDFee = _triggerBorrowingFee(contractsCache.troveManager, contractsCache.lusdToken, _LUSDChange, _maxFeePercentage);\n            vars.netDebtChange = vars.netDebtChange.add(vars.LUSDFee); // The raw debt change includes the fee\n        }\n\n        vars.debt = contractsCache.troveManager.getTroveDebt(_borrower);\n        vars.coll = contractsCache.troveManager.getTroveColl(_borrower);\n        \n        // Get the trove's old ICR before the adjustment, and what its new ICR will be after the adjustment\n        vars.oldICR = LiquityMath._computeCR(vars.coll, vars.debt, vars.price);\n        vars.newICR = _getNewICRFromTroveChange(vars.coll, vars.debt, vars.collChange, vars.isCollIncrease, vars.netDebtChange, _isDebtIncrease, vars.price);\n        assert(_collWithdrawal <= vars.coll); \n\n        // Check the adjustment satisfies all conditions for the current system mode\n        _requireValidAdjustmentInCurrentMode(isRecoveryMode, _collWithdrawal, _isDebtIncrease, vars);\n            \n        // When the adjustment is a debt repayment, check it's a valid amount and that the caller has enough LUSD\n        if (!_isDebtIncrease && _LUSDChange > 0) {\n            _requireAtLeastMinNetDebt(_getNetDebt(vars.debt).sub(vars.netDebtChange));\n            _requireValidLUSDRepayment(vars.debt, vars.netDebtChange);\n            _requireSufficientLUSDBalance(contractsCache.lusdToken, _borrower, vars.netDebtChange);\n        }\n\n        (vars.newColl, vars.newDebt) = _updateTroveFromAdjustment(contractsCache.troveManager, _borrower, vars.collChange, vars.isCollIncrease, vars.netDebtChange, _isDebtIncrease);\n        vars.stake = contractsCache.troveManager.updateStakeAndTotalStakes(_borrower);\n\n        // Re-insert trove in to the sorted list\n        uint newNICR = _getNewNominalICRFromTroveChange(vars.coll, vars.debt, vars.collChange, vars.isCollIncrease, vars.netDebtChange, _isDebtIncrease);\n        sortedTroves.reInsert(_borrower, newNICR, _upperHint, _lowerHint);\n\n        emit TroveUpdated(_borrower, vars.newDebt, vars.newColl, vars.stake, BorrowerOperation.adjustTrove);\n        emit LUSDBorrowingFeePaid(msg.sender,  vars.LUSDFee);\n\n        // Use the unmodified _LUSDChange here, as we don't send the fee to the user\n        _moveTokensAndETHfromAdjustment(\n            contractsCache.activePool,\n            contractsCache.lusdToken,\n            msg.sender,\n            vars.collChange,\n            vars.isCollIncrease,\n            _LUSDChange,\n            _isDebtIncrease,\n            vars.netDebtChange\n        );\n    }\n\n// SWC-105-Unprotected Ether Withdrawal: L321 - L351\n    function closeTrove() external override {\n        ITroveManager troveManagerCached = troveManager;\n        IActivePool activePoolCached = activePool;\n        ILUSDToken lusdTokenCached = lusdToken;\n\n        _requireTroveisActive(troveManagerCached, msg.sender);\n        uint price = priceFeed.fetchPrice();\n        _requireNotInRecoveryMode(price);\n\n        troveManagerCached.applyPendingRewards(msg.sender);\n\n        uint coll = troveManagerCached.getTroveColl(msg.sender);\n        uint debt = troveManagerCached.getTroveDebt(msg.sender);\n\n        _requireSufficientLUSDBalance(lusdTokenCached, msg.sender, debt.sub(LUSD_GAS_COMPENSATION));\n\n        uint newTCR = _getNewTCRFromTroveChange(coll, false, debt, false, price);\n        _requireNewTCRisAboveCCR(newTCR);\n\n        troveManagerCached.removeStake(msg.sender);\n        troveManagerCached.closeTrove(msg.sender);\n\n        emit TroveUpdated(msg.sender, 0, 0, 0, BorrowerOperation.closeTrove);\n\n        // Burn the repaid LUSD from the user's balance and the gas compensation from the Gas Pool\n        _repayLUSD(activePoolCached, lusdTokenCached, msg.sender, debt.sub(LUSD_GAS_COMPENSATION));\n        _repayLUSD(activePoolCached, lusdTokenCached, gasPoolAddress, LUSD_GAS_COMPENSATION);\n\n        // Send the collateral back to the user\n        activePoolCached.sendETH(msg.sender, coll);\n    }\n\n    /**\n     * Claim remaining collateral from a redemption or from a liquidation with ICR > MCR in Recovery Mode\n     */\n    function claimCollateral() external override {\n        // send ETH from CollSurplus Pool to owner\n        collSurplusPool.claimColl(msg.sender);\n    }\n\n    // --- Helper functions ---\n\n    function _triggerBorrowingFee(ITroveManager _troveManager, ILUSDToken _lusdToken, uint _LUSDAmount, uint _maxFeePercentage) internal returns (uint) {\n        _troveManager.decayBaseRateFromBorrowing(); // decay the baseRate state variable\n        uint LUSDFee = _troveManager.getBorrowingFee(_LUSDAmount);\n\n        _requireUserAcceptsFee(LUSDFee, _LUSDAmount, _maxFeePercentage);\n        \n        // Send fee to LQTY staking contract\n        lqtyStaking.increaseF_LUSD(LUSDFee);\n        _lusdToken.mint(lqtyStakingAddress, LUSDFee);\n\n        return LUSDFee;\n    }\n\n    function _getUSDValue(uint _coll, uint _price) internal pure returns (uint) {\n        uint usdValue = _price.mul(_coll).div(DECIMAL_PRECISION);\n\n        return usdValue;\n    }\n\n    function _getCollChange(\n        uint _collReceived,\n        uint _requestedCollWithdrawal\n    )\n        internal\n        pure\n        returns(uint collChange, bool isCollIncrease)\n    {\n        if (_collReceived != 0) {\n            collChange = _collReceived;\n            isCollIncrease = true;\n        } else {\n            collChange = _requestedCollWithdrawal;\n        }\n    }\n\n    // Update trove's coll and debt based on whether they increase or decrease\n    function _updateTroveFromAdjustment\n    (\n        ITroveManager _troveManager,\n        address _borrower,\n        uint _collChange,\n        bool _isCollIncrease,\n        uint _debtChange,\n        bool _isDebtIncrease\n    )\n        internal\n        returns (uint, uint)\n    {\n        uint newColl = (_isCollIncrease) ? _troveManager.increaseTroveColl(_borrower, _collChange)\n                                        : _troveManager.decreaseTroveColl(_borrower, _collChange);\n        uint newDebt = (_isDebtIncrease) ? _troveManager.increaseTroveDebt(_borrower, _debtChange)\n                                        : _troveManager.decreaseTroveDebt(_borrower, _debtChange);\n\n        return (newColl, newDebt);\n    }\n\n    function _moveTokensAndETHfromAdjustment\n    (\n        IActivePool _activePool,\n        ILUSDToken _lusdToken,\n        address _borrower,\n        uint _collChange,\n        bool _isCollIncrease,\n        uint _LUSDChange,\n        bool _isDebtIncrease,\n        uint _netDebtChange\n    )\n        internal\n    {\n        if (_isDebtIncrease) {\n            _withdrawLUSD(_activePool, _lusdToken, _borrower, _LUSDChange, _netDebtChange);\n        } else {\n            _repayLUSD(_activePool, _lusdToken, _borrower, _LUSDChange);\n        }\n\n        if (_isCollIncrease) {\n            _activePoolAddColl(_activePool, _collChange);\n        } else {\n            _activePool.sendETH(_borrower, _collChange);\n        }\n    }\n\n    // Send ETH to Active Pool and increase its recorded ETH balance\n    function _activePoolAddColl(IActivePool _activePool, uint _amount) internal {\n        (bool success, ) = address(_activePool).call{value: _amount}(\"\");\n        require(success, \"BorrowerOps: Sending ETH to ActivePool failed\");\n    }\n\n    // Issue the specified amount of LUSD to _account and increases the total active debt (_netDebtIncrease potentially includes a LUSDFee)\n    function _withdrawLUSD(IActivePool _activePool, ILUSDToken _lusdToken, address _account, uint _LUSDAmount, uint _netDebtIncrease) internal {\n        _activePool.increaseLUSDDebt(_netDebtIncrease);\n        _lusdToken.mint(_account, _LUSDAmount);\n    }\n\n    // Burn the specified amount of LUSD from _account and decreases the total active debt\n    function _repayLUSD(IActivePool _activePool, ILUSDToken _lusdToken, address _account, uint _LUSD) internal {\n        _activePool.decreaseLUSDDebt(_LUSD);\n        _lusdToken.burn(_account, _LUSD);\n    }\n\n    // --- 'Require' wrapper functions ---\n\n    function _requireSingularCollChange(uint _collWithdrawal) internal view {\n        require(msg.value == 0 || _collWithdrawal == 0, \"BorrowerOperations: Cannot withdraw and add coll\");\n    }\n\n    function _requireCallerIsBorrower(address _borrower) internal view {\n        require(msg.sender == _borrower, \"BorrowerOps: Caller must be the borrower for a withdrawal\");\n    }\n\n    function _requireNonZeroAdjustment(uint _collWithdrawal, uint _LUSDChange) internal view {\n        require(msg.value != 0 || _collWithdrawal != 0 || _LUSDChange != 0, \"BorrowerOps: There must be either a collateral change or a debt change\");\n    }\n\n    function _requireTroveisActive(ITroveManager _troveManager, address _borrower) internal view {\n        uint status = _troveManager.getTroveStatus(_borrower);\n        require(status == 1, \"BorrowerOps: Trove does not exist or is closed\");\n    }\n\n    function _requireTroveisNotActive(ITroveManager _troveManager, address _borrower) internal view {\n        uint status = _troveManager.getTroveStatus(_borrower);\n        require(status != 1, \"BorrowerOps: Trove is active\");\n    }\n\n    function _requireNonZeroDebtChange(uint _LUSDChange) internal pure {\n        require(_LUSDChange > 0, \"BorrowerOps: Debt increase requires non-zero debtChange\");\n    }\n   \n    function _requireNotInRecoveryMode(uint _price) internal view {\n        require(!_checkRecoveryMode(_price), \"BorrowerOps: Operation not permitted during Recovery Mode\");\n    }\n\n    function _requireNoCollWithdrawal(uint _collWithdrawal) internal pure {\n        require(_collWithdrawal == 0, \"BorrowerOps: Collateral withdrawal not permitted Recovery Mode\");\n    }\n\n    function _requireValidAdjustmentInCurrentMode \n    (\n        bool _isRecoveryMode,\n        uint _collWithdrawal,\n        bool _isDebtIncrease, \n        LocalVariables_adjustTrove memory _vars\n    ) \n        internal \n        view \n    {\n        /* \n        *In Recovery Mode, only allow:\n        *\n        * - Pure collateral top-up\n        * - Pure debt repayment\n        * - Collateral top-up with debt repayment\n        * - A debt increase combined with a collateral top-up which makes the ICR >= 150% and improves the ICR (and by extension improves the TCR).\n        *\n        * In Normal Mode, ensure:\n        *\n        * - The new ICR is above MCR\n        * - The adjustment won't pull the TCR below CCR\n        */\n        if (_isRecoveryMode) {\n            _requireNoCollWithdrawal(_collWithdrawal);\n            if (_isDebtIncrease) {\n                _requireICRisAboveCCR(_vars.newICR);\n                _requireNewICRisAboveOldICR(_vars.newICR, _vars.oldICR);\n            }       \n        } else { // if Normal Mode\n            _requireICRisAboveMCR(_vars.newICR);\n            _vars.newTCR = _getNewTCRFromTroveChange(_vars.collChange, _vars.isCollIncrease, _vars.netDebtChange, _isDebtIncrease, _vars.price);\n            _requireNewTCRisAboveCCR(_vars.newTCR);  \n        }\n    }\n\n    function _requireICRisAboveMCR(uint _newICR) internal pure {\n        require(_newICR >= MCR, \"BorrowerOps: An operation that would result in ICR < MCR is not permitted\");\n    }\n\n    function _requireICRisAboveCCR(uint _newICR) internal pure {\n        require(_newICR >= CCR, \"BorrowerOps: Operation must leave trove with ICR >= CCR\");\n    }\n\n    function _requireNewICRisAboveOldICR(uint _newICR, uint _oldICR) internal pure {\n        require(_newICR >= _oldICR, \"BorrowerOps: Cannot decrease your Trove's ICR in Recovery Mode\");\n    }\n\n    function _requireNewTCRisAboveCCR(uint _newTCR) internal pure {\n        require(_newTCR >= CCR, \"BorrowerOps: An operation that would result in TCR < CCR is not permitted\");\n    }\n\n    function _requireAtLeastMinNetDebt(uint _netDebt) internal pure {\n        require (_netDebt >= MIN_NET_DEBT, \"BorrowerOps: Trove's net debt must be greater than minimum\");\n    }\n\n    function _requireValidLUSDRepayment(uint _currentDebt, uint _debtRepayment) internal pure {\n        require(_debtRepayment <= _currentDebt.sub(LUSD_GAS_COMPENSATION), \"BorrowerOps: Amount repaid must not be larger than the Trove's debt\");\n    }\n\n    function _requireCallerIsStabilityPool() internal view {\n        require(msg.sender == stabilityPoolAddress, \"BorrowerOps: Caller is not Stability Pool\");\n    }\n\n     function _requireSufficientLUSDBalance(ILUSDToken _lusdToken, address _borrower, uint _debtRepayment) internal view {\n        require(_lusdToken.balanceOf(_borrower) >= _debtRepayment, \"BorrowerOps: Caller doesnt have enough LUSD to make repayment\");\n    }\n\n    function _requireValidMaxFeePercentage(uint _maxFeePercentage, bool _isRecoveryMode) internal pure {\n        if (_isRecoveryMode) {\n            require(_maxFeePercentage <= DECIMAL_PRECISION,\n                \"Max fee percentage must less than or equal to 100%\");\n        } else {\n            require(_maxFeePercentage >= BORROWING_FEE_FLOOR && _maxFeePercentage <= DECIMAL_PRECISION,\n                \"Max fee percentage must be between 0.5% and 100%\");\n        }\n    }\n\n    // --- ICR and TCR getters ---\n\n    // Compute the new collateral ratio, considering the change in coll and debt. Assumes 0 pending rewards.\n    function _getNewNominalICRFromTroveChange\n    (\n        uint _coll,\n        uint _debt,\n        uint _collChange,\n        bool _isCollIncrease,\n        uint _debtChange,\n        bool _isDebtIncrease\n    )\n        pure\n        internal\n        returns (uint)\n    {\n        (uint newColl, uint newDebt) = _getNewTroveAmounts(_coll, _debt, _collChange, _isCollIncrease, _debtChange, _isDebtIncrease);\n\n        uint newNICR = LiquityMath._computeNominalCR(newColl, newDebt);\n        return newNICR;\n    }\n\n    // Compute the new collateral ratio, considering the change in coll and debt. Assumes 0 pending rewards.\n    function _getNewICRFromTroveChange\n    (\n        uint _coll,\n        uint _debt,\n        uint _collChange,\n        bool _isCollIncrease,\n        uint _debtChange,\n        bool _isDebtIncrease,\n        uint _price\n    )\n        pure\n        internal\n        returns (uint)\n    {\n        (uint newColl, uint newDebt) = _getNewTroveAmounts(_coll, _debt, _collChange, _isCollIncrease, _debtChange, _isDebtIncrease);\n\n        uint newICR = LiquityMath._computeCR(newColl, newDebt, _price);\n        return newICR;\n    }\n\n    function _getNewTroveAmounts(\n        uint _coll,\n        uint _debt,\n        uint _collChange,\n        bool _isCollIncrease,\n        uint _debtChange,\n        bool _isDebtIncrease\n    )\n        internal\n        pure\n        returns (uint, uint)\n    {\n        uint newColl = _coll;\n        uint newDebt = _debt;\n\n        newColl = _isCollIncrease ? _coll.add(_collChange) :  _coll.sub(_collChange);\n        newDebt = _isDebtIncrease ? _debt.add(_debtChange) : _debt.sub(_debtChange);\n\n        return (newColl, newDebt);\n    }\n\n    function _getNewTCRFromTroveChange\n    (\n        uint _collChange,\n        bool _isCollIncrease,\n        uint _debtChange,\n        bool _isDebtIncrease,\n        uint _price\n    )\n        internal\n        view\n        returns (uint)\n    {\n        uint totalColl = getEntireSystemColl();\n        uint totalDebt = getEntireSystemDebt();\n\n        totalColl = _isCollIncrease ? totalColl.add(_collChange) : totalColl.sub(_collChange);\n        totalDebt = _isDebtIncrease ? totalDebt.add(_debtChange) : totalDebt.sub(_debtChange);\n\n        uint newTCR = LiquityMath._computeCR(totalColl, totalDebt, _price);\n        return newTCR;\n    }\n\n    function getCompositeDebt(uint _debt) external pure override returns (uint) {\n        return _getCompositeDebt(_debt);\n    }\n}",
        "function": "getEntireSystemColl()",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinspect-Liquity Audit/dev-dd7f59b980e7dab1cebc84c017db3a2c4caa522c/packages/contracts/contracts/BorrowerOperations.sol",
        "vulnerability": "Multiple Calls in a Single Transaction (SWC 113)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "library ProPoolLib {    \n    using QuotaLib for QuotaLib.Storage;\n    // We could use SafeMath to catch errors in the logic, \n    // but if there are no such errors we can skip it.\n    // using SafeMath for uint;    \n\n    /**\n     * @dev Pool possible states.\n     */\n    enum State {\n        Open,\n        PaidToPresale,\n        Distribution,        \n        FullRefund,\n        Canceled\n    }\n\n    /**\n     * @dev Pool participation group structure. \n     * Every participation group of the pool is represented by a copy of this structure. \n     * This structure holds information about the group settings and its current state.\n     */\n    struct Group {\n\n        // Total contribution balance of the group. Every time participant \n        // contributes to the group the value of this field will be increased \n        // by the amount of participant contribution.\n        uint contribution;            \n\n        // Total remaining balance of the group. Group settings can be changed \n        // by pool administrator during the pooling period. For example, the max balance\n        // of the group or max contribution per address can be decreased. Because of this,\n        // the contribution amount of the participants that have made their contribution \n        // before this changes can be moved from the contribution balance of the group\n        // to remainig balance of the group, partially or completely.\n        uint remaining;                   \n\n        // The total contribution balance of the group cannot be greater than this value.\n        uint maxBalance;\n\n        // The min contribution per address must be equal or greater than this value.\n        uint minContribution; \n\n        // The max contribution per address must be equal or less than this value.\n        uint maxContribution;        \n\n        // Administrator's commission in terms of \"Fee per Ether\".\n        uint ctorFeePerEther;          \n\n        // Indicates when the group is public or private. Public group means that \n        // any address can contribute to it. In case of a private group, only \n        // whitelisted addresses can contribute to the group.\n        bool isRestricted;\n\n        // Group existence indicator.\n        bool exists;\n    }\n\n    /**\n     * @dev Pool participant structrure.\n     * Every participant in the pool is represented by a copy of this structure.\n     * This structure holds information about participant and his contributions.\n     */\n    struct Participant {\n\n        // Describes the participant's contribution balance in the each of the groups.\n        uint[8] contribution;\n\n        // Describes the participant's remaining balance in the each of the groups.\n        uint[8] remaining;\n\n        // Indicates when the participant is whitelisted in the certain group.\n        bool[8] whitelist;  \n\n        // Indicates when the participant is an administrator.\n        bool isAdmin;\n\n        // Participant existence indicator.\n        bool exists;\n    }    \n\n    /**\n     * @dev Pool structure.\n     * Every pool is represented by a copy of this structure. Holds information \n     * about current state of the pool, its participation groups and participants.\n     */\n    struct Pool {\n\n        // Current state of the pool.\n        State state;\n\n        // EasyPool commission in terms of \"Fee per Ether\".\n        // Is set only once, during pool creation transaction.\n        uint svcFeePerEther;\n\n        // Refund sender address. \n        // The pool refund transactions must be sent from this address.        \n        address refundAddress;\n\n        // Pool funds destionation address.\n        // If locked the pool funds can only be sent to this address. \n        // Can be set only once by pool admin and can't be changed later.\n        address presaleAddress;\n\n        // Presale address can be locked.\n        // SWC-114-Transaction Order Dependence: L120\n        bool lockPresale;\n\n        // FeeService contract interface.\n        IFeeService feeService;\n\n        // When paying to the presale \"Fee-to-Token\" mode can be chosen by admin. \n        // In this mode, the pool creator commission will be sent to the presale\n        // as a part of creator contribution. \n        address feeToTokenAddress;        \n        bool feeToTokenMode;\n                  \n        // Pool administrators array.\n        address[] admins;\n\n        // Pool participatnts array.\n        address[] participants;     \n\n        // Confirmed tokens array.\n        address[] tokenAddresses;\n\n        // Pool groups array.\n        Group[8] groups;         \n\n        // Mapping from participant address to the corresponding structure.\n        mapping(address => Participant) participantToData;   \n\n        // Mapping from token address to the corresponding quota storage.     \n        mapping(address => QuotaLib.Storage) tokenQuota;  \n\n        // Quota storage for pool refund balace.\n        QuotaLib.Storage refundQuota;\n    }                     \n\n    /**\n     * @dev Access modifier for admin-only functionality.\n     */\n    modifier onlyAdmin(Pool storage pool) {\n        require(pool.participantToData[msg.sender].isAdmin);\n        _;\n    }\n\n    /**\n     * @dev Access modifier for in-state-only functionality.\n     */\n    modifier onlyInState(Pool storage pool, State state) {\n        require(pool.state == state);\n        _;\n    }      \n\n    /**\n     * @dev Access modifier for in-state-only functionality.\n     */\n    modifier onlyInStates2(Pool storage pool, State state1, State state2) {\n        require(pool.state == state1 || pool.state == state2);\n        _;\n    }  \n\n    /**\n     * @dev Access modifier for in-state-only functionality.\n     */\n    modifier onlyInStates3(Pool storage pool, State state1, State state2, State state3) {\n        require(pool.state == state1 || pool.state == state2 || pool.state == state3);\n        _;\n    }    \n\n    /**\n     * @dev Setting new pool instance. Called when new pool is created.     \n     */\n    function init(\n        Pool storage pool,           \n        uint maxBalance,\n        uint minContribution,\n        uint maxContribution,\n        uint ctorFeePerEther,\n        bool isRestricted,                \n        address creatorAddress,        \n        address presaleAddress,        \n        address feeServiceAddr,\n        address[] whitelist,\n        address[] admins\n    )\n        public \n    {\n\n        // Set presale address.\n        if(presaleAddress != address(0)) {\n            require(presaleAddress != address(this)); \n            pool.presaleAddress = presaleAddress;           \n            emit PresaleAddressLocked(presaleAddress);            \n        }\n                \n        // Set fee service contract.\n        pool.feeService = IFeeService(feeServiceAddr);        \n        pool.svcFeePerEther = pool.feeService.getFeePerEther();\n        require(pool.svcFeePerEther <= (1 ether / 4));\n        emit FeeServiceAttached(\n            feeServiceAddr,\n            pool.svcFeePerEther\n        );  \n        \n        // Set pool administrators.\n        require(creatorAddress != address(0));\n        addAdmin(pool, creatorAddress);\n        for(uint i = 0; i < admins.length; i++) {\n            addAdmin(pool, admins[i]);\n        }\n        \n        // Create first group.\n        setGroupSettingsCore(\n            pool,\n            0,\n            maxBalance,\n            minContribution,\n            maxContribution,\n            ctorFeePerEther,\n            isRestricted            \n        );\n        \n        // Set whitelist.\n        if(whitelist.length > 0) {\n            require(isRestricted);\n            modifyWhitelistCore(pool, 0, whitelist, new address[](0));\n        }\n    }\n\n    /**\n     * @dev Creates new participation group in case it doesn't exist \n     * or updates participation group settings in case the group exists.\n     */\n    function setGroupSettings(\n        Pool storage pool,        \n        uint idx,\n        uint maxBalance,\n        uint minContribution,\n        uint maxContribution,\n        uint ctorFeePerEther,         \n        bool isRestricted\n    )\n        public     \n        onlyAdmin(pool)\n        onlyInState(pool, State.Open)      \n    {\n        // Group existence state.\n        bool exists = pool.groups[idx].exists;\n\n        // Set or update group settings.\n        setGroupSettingsCore(\n            pool,\n            idx,\n            maxBalance,\n            minContribution,\n            maxContribution,\n            ctorFeePerEther,\n            isRestricted            \n        );\n                \n        if(exists) {            \n            // Execute rebalancing.\n            groupRebalance(pool, idx);\n        }\n    }\n\n    /**\n     * @dev Modify group whitelist.\n     */\n    function modifyWhitelist(Pool storage pool, uint idx, address[] include, address[] exclude)\n        public \n        onlyAdmin(pool)\n        onlyInState(pool, State.Open)\n    {\n        // Modify whitelist (without relabancing).\n        modifyWhitelistCore(pool, idx, include, exclude); \n        // Execute group rebalancing.\n        groupRebalance(pool, idx);\n    }     \n\n    /**\n     * @dev Lock presale address.\n     */\n    function lockPresaleAddress(Pool storage pool, address presaleAddress, bool lock)\n        public \n        onlyAdmin(pool) \n        onlyInState(pool, State.Open) \n    {        \n        require(presaleAddress != address(0));\n        require(presaleAddress != address(this));\n        require(pool.presaleAddress == address(0));\n        require(!pool.lockPresale);\n\n        // Set presale address.\n        pool.presaleAddress = presaleAddress;\n\n        // Lock presale address.\n        if(lock) {\n            pool.lockPresale = true;\n        }\n\n        emit PresaleAddressLocked(presaleAddress);\n    }   \n\n    /**\n     * @dev Confirm token address.\n     */\n    function confirmTokenAddress(Pool storage pool, address tokenAddress)\n        public\n        onlyAdmin(pool)\n        onlyInStates2(pool, State.PaidToPresale, State.Distribution)         \n    {        \n        require(tokenAddress != address(0));\n        require(pool.tokenAddresses.length <= 4);\n        require(!contains(pool.tokenAddresses, tokenAddress));\n\n        // Get token balance for the pool address.\n        IERC20Base ERC20 = IERC20Base(tokenAddress);\n        uint balance = ERC20.balanceOf(address(this));  \n\n        // When confirming the token balance must be greater than zero.      \n        require(balance > 0);\n\n        // Change state of the pool if this is the first token confirmation.\n        if(pool.state == State.PaidToPresale) {\n            changeState(pool, State.Distribution);            \n            sendFees(pool);\n        } \n                        \n        // Save token address.\n        pool.tokenAddresses.push(tokenAddress);\n\n        emit TokenAddressConfirmed(\n            tokenAddress,\n            balance\n        );\n    }\n\n    /**\n     * @dev Set refund sender address.\n     */\n    function setRefundAddress(Pool storage pool, address refundAddress)\n        public\n        onlyAdmin(pool)\n        onlyInStates3(pool, State.PaidToPresale, State.Distribution, State.FullRefund)\n    {        \n        require(refundAddress != address(0));\n        require(pool.refundAddress != refundAddress);\n\n        // Set refund sender address.\n        pool.refundAddress = refundAddress;\n        emit RefundAddressChanged(refundAddress);\n\n        // This is full refund scenario.\n        if(pool.state == State.PaidToPresale) {\n            changeState(pool, State.FullRefund);\n        }\n    }   \n\n    /**\n     * @dev Send pool balance to presale address.\n     */\n    function payToPresale(\n        Pool storage pool,\n        address presaleAddress,\n        uint minPoolBalance,\n        bool feeToToken,\n        bytes data\n    )\n        public\n        onlyAdmin(pool) \n        onlyInState(pool, State.Open) \n    {\n        require(presaleAddress != address(0));\n                        \n        // Check if presale address is locked.\n        if(pool.presaleAddress == address(0)) {\n            pool.presaleAddress = presaleAddress;\n            emit PresaleAddressLocked(presaleAddress);\n        } else { \n            // If locked then destination address must be same.\n            require(pool.presaleAddress == presaleAddress);\n        }\n        \n        uint ctorFee;\n        uint poolRemaining;\n        uint poolContribution;      \n        // Calculate pool summaries.          \n        (poolContribution, poolRemaining, ctorFee) = calcPoolSummary(pool);        \n        require(poolContribution > 0 && poolContribution >= minPoolBalance);\n\n        // Set fee-to-token mode.\n        if(feeToToken) {\n            pool.feeToTokenMode = true;            \n            pool.feeToTokenAddress = msg.sender;\n            ctorFee = 0;\n        }\n\n        changeState(pool, State.PaidToPresale);\n\n        // Transafer funds.\n        addressCall(\n            pool.presaleAddress,\n            poolContribution - ctorFee - calcFee(poolContribution, pool.svcFeePerEther),\n            data\n        );        \n    }\n\n    /**\n     * @dev Cancel pool.\n     */\n    function cancel(Pool storage pool)\n        public\n        onlyAdmin(pool) \n        onlyInState(pool, State.Open)\n    {\n        changeState(pool, State.Canceled);\n    }  \n\n    /**\n     * @dev Contribute to the group.\n     */\n    function deposit(Pool storage pool, uint idx)\n        public        \n        onlyInState(pool, State.Open)  \n    {\n        require(msg.value > 0);\n        require(pool.groups.length > idx);\n        require(pool.groups[idx].exists);\n\n        // Get group and participant instances.\n        Participant storage participant = pool.participantToData[msg.sender];\n        Group storage group = pool.groups[idx];        \n\n        // Calculate contribution and remaining balance.\n        uint remaining;\n        uint contribution;                \n        (contribution, remaining) = calcContribution(\n            idx, \n            msg.value, \n            group.maxBalance, \n            group.contribution - participant.contribution[idx], \n            group.minContribution, \n            group.maxContribution, \n            group.isRestricted,            \n            participant\n        );\n\n        // Remaining balance must be equal to zero.\n        require(remaining == 0);\n\n        // Set the participant existence state.\n        if (!participant.exists) {\n            participant.exists = true;   \n            pool.participants.push(msg.sender);\n        }        \n\n        // Mark participant as whitelisted.\n        if(!participant.whitelist[idx]) {\n            participant.whitelist[idx] = true;         \n        }\n\n        // Update contribution and remaining balance.\n        group.contribution = group.contribution - participant.contribution[idx] + contribution;\n        group.remaining = group.remaining - participant.remaining[idx] + remaining;\n        participant.contribution[idx] = contribution;\n        participant.remaining[idx] = remaining;\n\n        emit Contribution(\n            msg.sender,\n            idx,\n            msg.value,\n            contribution,\n            group.contribution\n        );        \n    }\n\n    /**\n     * @dev Withdraw from the group.\n     */     \n    function withdrawAmount(Pool storage pool, uint amount, uint idx)\n        public\n        onlyInState(pool, State.Open)\n    {\n        // Get participant instance.\n        Participant storage participant = pool.participantToData[msg.sender];                        \n        uint finalAmount;\n        \n        if(amount == 0) {\n            // If withdrawal amount is equal to zero then withdraw entire contribution.\n            finalAmount = participant.contribution[idx] + participant.remaining[idx];\n        } else {\n            // Requested withdrawal amount must be equal or greater than participant \n            // remaining balance, but less or equal than his total contribution.\n            require(amount >= participant.remaining[idx]);\n            require(amount <= participant.contribution[idx] + participant.remaining[idx]);\n            finalAmount = amount;\n        }\n\n        require(finalAmount > 0);\n        \n        // Get group instance.\n        Group storage group = pool.groups[idx];\n\n        // Update group remaining balance.\n        group.remaining -= participant.remaining[idx];        \n\n        // Check if withdrawal amount is greater than remaining balance.\n        uint extra = finalAmount - participant.remaining[idx];        \n\n        // Update participant remaining balance. At this point always zero.\n        participant.remaining[idx] = 0;        \n\n        if(extra > 0) {\n            // Update group and participant contribution balance.\n            participant.contribution[idx] -= extra;\n            group.contribution -= extra;            \n\n            if(!participant.isAdmin) {\n                // Make sure that requested withdrawal amount won't break group settings.\n                require(participant.contribution[idx] >= group.minContribution);\n            }\n        }\n\n        // Transfer funds.\n        addressTransfer(msg.sender, finalAmount);\n\n        emit Withdrawal(\n            msg.sender,\n            finalAmount,\n            participant.contribution[idx],\n            0,\n            group.contribution,\n            group.remaining,\n            idx\n        );                        \n    } \n\n    /**\n     * @dev Wihdraw 'All-in-One' function (public wrapper).     \n     */ \n    function withdrawAll(Pool storage pool) public {\n\n        // Withdraw refund share and tokens share.\n        if (pool.state == State.FullRefund || pool.state == State.Distribution) {\n            withdrawRefundAndTokens(pool);\n            return;\n        }\n        \n        // Withdraw entire contribution balance.\n        if(pool.state == State.Canceled || pool.state == State.Open) {\n            withdrawAllContribution(pool);\n            return;\n        }            \n        \n        // Withdraw remaining balance.\n        if (pool.state == State.PaidToPresale) {\n            withdrawAllRemaining1(pool);\n            return;\n        } \n\n        // Revert transaction.\n        revert();\n    }\n\n    /**\n     * @dev ERC223 fallback.\n     */\n    function tokenFallback(Pool storage pool, address from, uint value, bytes data)\n        public \n        onlyInStates2(pool, State.PaidToPresale, State.Distribution)\n    {\n        emit ERC223Fallback(\n            msg.sender,\n            from,\n            value,\n            data\n        );\n    }    \n\n    /**\n     * @dev Accept refund transfer.     \n     */\n    function acceptRefundTransfer(Pool storage pool)\n        public \n        onlyInStates2(pool, State.Distribution, State.FullRefund)  \n    {\n        require(msg.value > 0);\n        require(msg.sender == pool.refundAddress);\n\n        emit RefundReceived(\n            msg.sender, \n            msg.value\n        );\n    }  \n\n    /**\n     * @dev Returns pool details (part #1).\n     */\n    function getPoolDetails1(Pool storage pool) \n        public view \n        returns (     \n            uint libVersion,\n            uint groupsCount,\n            uint currentState,\n            uint svcFeePerEther,\n            bool feeToTokenMode,            \n            address presaleAddress,\n            address feeToTokenAddress,            \n            address[] participants,\n            address[] admins\n        )\n    {\n        libVersion = version();\n        currentState = uint(pool.state);\n        groupsCount = pool.groups.length;\n        svcFeePerEther = pool.svcFeePerEther;\n        feeToTokenMode = pool.feeToTokenMode;        \n        presaleAddress = pool.presaleAddress;\n        feeToTokenAddress = pool.feeToTokenAddress;        \n        participants = pool.participants;\n        admins = pool.admins;\n    }  \n\n    /**\n     * @dev Returns pool details (part #2).\n     */\n    function getPoolDetails2(Pool storage pool) \n        public view \n        returns (      \n            uint refundBalance,\n            address refundAddress,\n            address[] tokenAddresses,\n            uint[] tokenBalances\n        )\n    {                                                \n        if(pool.state == State.Distribution || pool.state == State.FullRefund) {                 \n            uint poolRemaining;\n            (,poolRemaining,) = calcPoolSummary(pool);\n            refundBalance = address(this).balance - poolRemaining;\n            refundAddress = pool.refundAddress;\n            \n            tokenAddresses = pool.tokenAddresses;\n            tokenBalances = new uint[](tokenAddresses.length);\n            for(uint i = 0; i < tokenAddresses.length; i++) {\n                tokenBalances[i] = IERC20Base(tokenAddresses[i]).balanceOf(address(this));\n            }\n        }\n    }\n\n    /**\n     * @dev Returns participant details.\n     */\n    function getParticipantDetails(Pool storage pool, address addr)\n        public view \n        returns (\n            uint[] contribution,\n            uint[] remaining,\n            bool[] whitelist,\n            bool isAdmin,\n            bool exists\n        ) \n    {\n        Participant storage part = pool.participantToData[addr];\n        isAdmin = part.isAdmin;                \n        exists = part.exists;\n\n        uint length = pool.groups.length;\n        contribution = new uint[](length);\n        remaining = new uint[](length);\n        whitelist = new bool[](length);        \n\n        for(uint i = 0; i < length; i++) {\n            contribution[i] = part.contribution[i];\n            remaining[i] = part.remaining[i];\n            whitelist[i] = part.whitelist[i];\n        }                      \n    }        \n\n    /**\n     * @dev Returns participant shares.\n     */\n    function getParticipantShares(Pool storage pool, address addr) public view returns (uint[] tokenShare, uint refundShare) {       \n        if(pool.state == State.Distribution || pool.state == State.FullRefund) {\n            uint netPoolContribution;\n            uint netPartContribution;\n            uint poolRemaining;\n            uint poolCtorFee;   \n\n            (netPoolContribution, netPartContribution, poolRemaining, poolCtorFee) = calcPoolSummary3(pool, addr);\n            tokenShare = new uint[](pool.tokenAddresses.length);\n\n            if(netPartContribution > 0) {\n                refundShare = pool.refundQuota.calcShare(\n                    addr, \n                    address(this).balance - poolRemaining,\n                    [netPartContribution, netPoolContribution]\n                );        \n            }     \n\n            if(pool.feeToTokenMode) {\n                netPoolContribution += poolCtorFee;\n                if(pool.feeToTokenAddress == addr) {\n                    netPartContribution += poolCtorFee;\n                }\n            }  \n\n            if(netPartContribution > 0) {\n                for(uint i = 0; i < pool.tokenAddresses.length; i++) {\n                    tokenShare[i] = pool.tokenQuota[pool.tokenAddresses[i]].calcShare(\n                        addr,\n                        IERC20Base(pool.tokenAddresses[i]).balanceOf(address(this)),\n                        [netPartContribution, netPoolContribution]\n                    );                \n                }      \n            }\n        }  \n    }    \n\n    /**\n     * @dev Returns group details.\n     */\n    function getGroupDetails(Pool storage pool, uint idx)\n        public view \n        returns (\n            uint contributionBalance,\n            uint remainingBalance,\n            uint maxBalance,\n            uint minContribution,                 \n            uint maxContribution,\n            uint ctorFeePerEther,\n            bool isRestricted,\n            bool exists\n        ) \n    {\n        Group storage group = pool.groups[idx];                                                \n        contributionBalance = group.contribution;\n        remainingBalance = group.remaining;\n        maxBalance = group.maxBalance;\n        minContribution = group.minContribution;\n        maxContribution = group.maxContribution;\n        ctorFeePerEther = group.ctorFeePerEther;\n        isRestricted = group.isRestricted;\n        exists = group.exists;\n    }       \n\n    /**\n     * @dev Returns library version.\n     */\n    function version() public pure returns (uint) {\n        // type: 100 \n        // major: 100\n        // minor: 100        \n        return 100100101;\n    }    \n\n    /**\n     * @dev Withdraw entire contribution balance.\n     */     \n    function withdrawAllContribution(Pool storage pool) private {        \n        Participant storage participant = pool.participantToData[msg.sender];\n        Group storage group;\n        uint contribution;  \n        uint remaining;\n        uint amount;\n        uint sum;\n\n        // Iterate through the groups.\n        uint length = pool.groups.length;\n        for(uint idx = 0; idx < length; idx++) {\n\n            // Read contribution and remaining balance.\n            contribution = participant.contribution[idx];\n            remaining = participant.remaining[idx];\n            sum = contribution + remaining;\n\n            if(sum > 0) {\n                amount += sum;\n                group = pool.groups[idx];\n\n                // Reset contribution balance.\n                if(contribution > 0) {                    \n                    group.contribution -= contribution;\n                    participant.contribution[idx] = 0;\n                }\n\n                // Reset remaining balance.\n                if(remaining > 0) {\n                    group.remaining -= remaining;\n                    participant.remaining[idx] = 0;\n                }\n                                       \n                emit Withdrawal(\n                    msg.sender,\n                    idx,\n                    sum,\n                    0,\n                    0,\n                    group.contribution,\n                    group.remaining                    \n                );\n            }\n        }\n\n        // Transfer funds.\n        require(amount > 0);\n        addressTransfer(\n            msg.sender, \n            amount\n        );\n    }\n\n    /**\n     * @dev Wihdraw remaining balance (simple).\n     */  \n    function withdrawAllRemaining1(Pool storage pool) private {\n        Participant storage participant = pool.participantToData[msg.sender];        \n        Group storage group;\n        uint remaining;\n        uint amount;\n        \n        // Iterate through the groups.\n        uint length = pool.groups.length;\n        for(uint idx = 0; idx < length; idx++) {            \n            remaining = participant.remaining[idx];\n\n            // Reset remaining balance.\n            if(remaining > 0) {\n                amount += remaining;\n                group = pool.groups[idx];\n                group.remaining -= remaining;        \n                participant.remaining[idx] = 0;                                \n\n                emit Withdrawal(\n                    msg.sender,\n                    idx,\n                    remaining,\n                    participant.contribution[idx],\n                    0,\n                    group.contribution,\n                    group.remaining\n                );\n            }\n        }\n\n        // Transfer funds.\n        require(amount > 0);\n        addressTransfer(\n            msg.sender, \n            amount\n        );\n    }\n\n    /**\n     * @dev Wihdraw remaining balance and calculate.\n     */  \n    function withdrawAllRemaining2(Pool storage pool) \n        private \n        returns\n    (\n        uint poolContribution,\n        uint poolRemaining,\n        uint poolCtorFee,\n        uint partContribution,        \n        uint partCtorFee\n    ) \n    {\n        Participant storage participant = pool.participantToData[msg.sender];\n        Group storage group;\n        uint sumRemaining; \n        uint remaining;     \n\n        // Iterate through the groups.\n        uint length = pool.groups.length;\n        for(uint idx = 0; idx < length; idx++) {                        \n            group = pool.groups[idx];\n\n            // Make required calculations.\n            poolRemaining += group.remaining;\n            poolContribution += group.contribution;\n            poolCtorFee += calcFee(group.contribution, group.ctorFeePerEther);\n            \n            // Make required calculations.\n            remaining = participant.remaining[idx];\n            partContribution += participant.contribution[idx];\n            partCtorFee += calcFee(participant.contribution[idx], group.ctorFeePerEther);\n\n            // Reset remaining balance.\n            if(remaining > 0) {              \n                sumRemaining += remaining;                            \n                group.remaining -= remaining;\n                participant.remaining[idx] = 0;  \n\n                emit Withdrawal(\n                    msg.sender,\n                    idx,\n                    remaining,\n                    participant.contribution[idx],\n                    0,\n                    group.contribution,\n                    group.remaining                    \n                );\n            }\n        }\n\n        // Transfer funds.\n        if(sumRemaining > 0) {\n            poolRemaining -= sumRemaining;\n            addressTransfer(msg.sender, sumRemaining);\n        }\n    }    \n    \n    /**\n     * @dev Withdarw refund share and tokens share.\n     */  \n    function withdrawRefundAndTokens(Pool storage pool) private {\n        uint poolContribution;\n        uint poolRemaining;\n        uint poolCtorFee;\n        uint partContribution;        \n        uint partCtorFee;\n\n        // Withdraw remaining balance.\n        (poolContribution, \n            poolRemaining, \n            poolCtorFee, \n            partContribution,             \n            partCtorFee\n        ) = withdrawAllRemaining2(pool);\n\n        // Calculate net contribution values.        \n        uint netPoolContribution = poolContribution - poolCtorFee - calcFee(poolContribution, pool.svcFeePerEther);\n        uint netPartContribution = partContribution - partCtorFee - calcFee(partContribution, pool.svcFeePerEther);\n        \n        if(netPartContribution > 0) {\n            // Withdraw refund share based on net contribution.\n            withdrawRefundShare(pool, poolRemaining, netPoolContribution, netPartContribution);\n        }\n\n        // 'Fee-to-Token' mode.\n        if(pool.feeToTokenMode) {\n            netPoolContribution += poolCtorFee;\n            if(pool.feeToTokenAddress == msg.sender) {\n                netPartContribution += poolCtorFee;\n            }\n        }\n\n        if(netPartContribution > 0) {\n            // Withdraw tokens share based on net contribution.\n            withdrawTokens(pool, netPoolContribution, netPartContribution);\n        }\n    }\n\n    /**\n     * @dev Withdarw refund share.\n     */\n    function withdrawRefundShare(\n        Pool storage pool, \n        uint poolRemaining,\n        uint netPoolContribution, \n        uint netPartContribution\n    )\n        private \n    {\n        if(address(this).balance > poolRemaining) {\n            // Calculate and claim refund share.\n            uint amount = pool.refundQuota.claimShare(\n                msg.sender, \n                address(this).balance - poolRemaining,\n                [netPartContribution, netPoolContribution]\n            );\n\n            if(amount > 0) {          \n                // Trunsfer funds.                      \n                addressTransfer(msg.sender, amount);\n                emit RefundWithdrawal(\n                    msg.sender,\n                    address(this).balance,\n                    poolRemaining,\n                    amount\n                );                \n            }\n        }\n    }\n\n    /**\n     * @dev Withdraw tokens share.\n     */\n    function withdrawTokens(\n        Pool storage pool,        \n        uint netPoolContribution,\n        uint netPartContribution\n    )\n        private \n    {\n        bool succeeded;\n        uint tokenAmount;\n        uint tokenBalance;\n        address tokenAddress;\n        IERC20Base tokenContract;\n        QuotaLib.Storage storage quota;\n\n        // Iterate through the token addresses.\n        uint length = pool.tokenAddresses.length;\n        for(uint i = 0; i < length; i++) {             \n\n            tokenAddress = pool.tokenAddresses[i];            \n            tokenContract = IERC20Base(tokenAddress); \n            // Get token balance for the pool address.\n            tokenBalance = tokenContract.balanceOf(address(this));\n\n            if(tokenBalance > 0) {    \n                // Calculate and claim the token share.                                    \n                quota = pool.tokenQuota[tokenAddress];\n                tokenAmount = quota.claimShare(\n                    msg.sender,\n                    tokenBalance, \n                    [netPartContribution, netPoolContribution]\n                ); \n\n                if(tokenAmount > 0) {\n                    // Try to transfer tokens.\n                    succeeded = tokenContract.transfer(msg.sender, tokenAmount);\n                    if (!succeeded) {                        \n                        quota.undoClaimShare(msg.sender, tokenAmount);\n                    }\n                    emit TokenWithdrawal(\n                        tokenAddress,\n                        msg.sender,\n                        tokenBalance,\n                        tokenAmount,\n                        succeeded\n                    );\n                }\n            }\n        } \n    }   \n\n    /**\n     * @dev Create new participation group in case it doesn't exist otherwise update its settings.     \n     */\n    function setGroupSettingsCore(\n        Pool storage pool,        \n        uint idx,\n        uint maxBalance,\n        uint minContribution,\n        uint maxContribution,\n        uint ctorFeePerEther,         \n        bool isRestricted\n    )\n        private             \n    {\n        require(pool.groups.length > idx);\n        Group storage group = pool.groups[idx];        \n        \n        if(!group.exists) {\n            // Create new group. Pool groups should be created one-by-one.\n            require(idx == 0 || pool.groups[idx - 1].exists);\n            group.exists = true;\n        }\n        \n        validateGroupSettings(\n            maxBalance, \n            minContribution, \n            maxContribution\n        );        \n        \n        if(group.maxBalance != maxBalance) {\n            group.maxBalance = maxBalance;  \n        }          \n        \n        if(group.minContribution != minContribution) {\n            group.minContribution = minContribution;\n        }\n\n        if(group.maxContribution != maxContribution) {\n            group.maxContribution = maxContribution;\n        }\n        \n        if(group.ctorFeePerEther != ctorFeePerEther) {\n            require(ctorFeePerEther <= (1 ether / 2));\n            group.ctorFeePerEther = ctorFeePerEther;\n        }\n        \n        if(group.isRestricted != isRestricted) {\n            group.isRestricted = isRestricted;  \n        }      \n\n        emit GroupSettingsChanged(\n            idx,\n            maxBalance,\n            minContribution,\n            maxContribution,\n            ctorFeePerEther,\n            isRestricted\n        );                             \n    }    \n\n    /**\n     * @dev Modify group whitelist.\n     */\n    function modifyWhitelistCore(Pool storage pool, uint idx, address[] include, address[] exclude) private {\n        require(include.length > 0 || exclude.length > 0);\n        require(pool.groups.length > idx && pool.groups[idx].exists);\n\n        // Get group and participant instances.\n        Group storage group = pool.groups[idx];\n        Participant storage participant;        \n        uint i;\n\n        // Mark group as restricted.\n        if(!group.isRestricted) {\n            group.isRestricted = true;\n            emit WhitelistEnabled(idx);\n        }    \n\n        // Exclude participants.\n        for(i = 0; i < exclude.length; i++) {\n            participant = pool.participantToData[exclude[i]];            \n            if(participant.whitelist[idx]) {\n                participant.whitelist[idx] = false;\n                emit ExcludedFromWhitelist(\n                    exclude[i],\n                    idx\n                );                \n            }\n        }\n\n        // Include participants.\n        for(i = 0; i < include.length; i++) {\n            participant = pool.participantToData[include[i]];  \n\n            if(!participant.whitelist[idx]) { \n                // Create new participant.\n                if (!participant.exists) {                    \n                    pool.participants.push(include[i]);\n                    participant.exists = true;                                        \n                }                        \n\n                // Set as whitelisted.\n                participant.whitelist[idx] = true;               \n                emit IncludedInWhitelist(\n                    include[i],\n                    idx\n                );\n            }                \n        }\n    }        \n\n    /**\n     * @dev Distribute fees. When calling this function, contract balance should\n     *  consist of participants remaining balance, creator commission and service commission.\n     */\n    function sendFees(Pool storage pool) private {\n        uint ctorFee;\n        uint poolRemaining;\n        uint poolContribution;\n        // Calculate and transfer creator fee.\n        (poolContribution, poolRemaining, ctorFee) = calcPoolSummary(pool);\n        if(ctorFee > 0 && !pool.feeToTokenMode) {\n            addressTransfer(msg.sender, ctorFee);            \n        }\n        \n        // Calculate and transfer service fee.\n        uint svcFee = address(this).balance - poolRemaining;        \n        if(svcFee > 0) {\n            address creator = getPoolCreator(pool);\n            pool.feeService.sendFee.value(svcFee)(creator);\n        }\n\n        emit FeesDistributed(\n            ctorFee,\n            svcFee\n        );\n    }   \n\n    /**\n     * @dev Rebalance group contributions.\n     */\n    function groupRebalance(Pool storage pool, uint idx) private {\n        Group storage group = pool.groups[idx];          \n        uint maxBalance = group.maxBalance;\n        uint minContribution = group.minContribution;    \n        uint maxContribution = group.maxContribution;            \n        bool isRestricted = group.isRestricted;        \n        Participant storage participant;         \n        uint groupContribution;\n        uint groupRemaining;\n        uint contribution;\n        uint remaining;     \n        uint x = idx;   \n\n        // TODO: Getting stack too deep here..\n        // uint length = pool.participants.length;\n        for(uint i = 0; i < pool.participants.length; i++) {           \n            participant = pool.participantToData[pool.participants[i]];                \n            \n            // Calculate contribution and remaining balance.\n            (contribution, remaining) = calcContribution(       \n                x,\n                0,\n                maxBalance,\n                groupContribution,\n                minContribution,\n                maxContribution,\n                isRestricted,\n                participant\n            );        \n\n            // Save changes if some available.\n            if(contribution != participant.contribution[x]) {\n                participant.contribution[x] = contribution;\n                participant.remaining[x] = remaining;\n            }            \n            \n            groupContribution += contribution;            \n            groupRemaining += remaining;\n\n            emit ContributionAdjusted(\n                pool.participants[i], \n                contribution,\n                remaining,\n                groupContribution,\n                groupRemaining,\n                x\n            );\n        }\n        \n        // Update group contribution and remaining balance.\n        if(group.contribution != groupContribution) {\n            group.contribution = groupContribution;             \n            group.remaining = groupRemaining;           \n        }  \n    } \n\n    /**\n     * @dev Change pool state.\n     */\n    function changeState(Pool storage pool, State state) private {\n        assert(pool.state != state);\n        emit StateChanged(\n            uint(pool.state), \n            uint(state)\n        );\n        pool.state = state;        \n    }\n\n    /**\n     * @dev Add pool admin.\n     */\n    function addAdmin(Pool storage pool, address admin) private {\n        require(admin != address(0));\n        Participant storage participant = pool.participantToData[admin];\n        require(!participant.exists && !participant.isAdmin);\n\n        participant.exists = true;\n        participant.isAdmin = true;\n        pool.participants.push(admin);\n        pool.admins.push(admin);             \n        \n        emit AdminAdded(admin);                  \n    }  \n\n    /**\n     * @dev Trusted transfer.\n     */\n    function addressTransfer(address destination, uint etherAmount) private {\n        emit AddressTransfer(\n            destination,\n            etherAmount\n        );\n        destination.transfer(etherAmount);        \n    }\n\n    /**\n     * @dev Untrasted call.\n     */\n    function addressCall(address destination, uint etherAmount, bytes data) private {\n        addressCall(destination, 0, etherAmount, data);\n    }\n\n    /**\n     * @dev Untrasted call.\n     */\n    function addressCall(address destination, uint gasAmount,  uint etherAmount, bytes data) private {\n        emit AddressCall(\n            destination,\n            etherAmount,\n            gasAmount > 0 ? gasAmount : gasleft(),\n            data\n        );\n        require(\n            destination.call\n            .gas(gasAmount > 0 ? gasAmount : gasleft())\n            .value(etherAmount)\n            (data)            \n        );\n    }\n\n    /**\n     * @dev Calculate participant contribution.\n     */\n    function calcContribution(\n        uint idx,\n        uint amount,\n        uint maxBalance,\n        uint currentBalance,\n        uint minContribution, \n        uint maxContribution,\n        bool isRestricted,        \n        Participant storage participant\n    )\n        private view \n        returns(uint contribution, uint remaining)\n    {\n        // Total contribution amount.\n        uint totalAmount = participant.contribution[idx]\n            + participant.remaining[idx]\n            + amount;\n\n        // There are no limitations for admins.\n        if(participant.isAdmin) {\n            contribution = totalAmount;\n            return;\n        }                \n\n        // Limitations on group max balance & whitelist.\n        if(currentBalance >= maxBalance || (isRestricted && !participant.whitelist[idx])) {\n            remaining = totalAmount;            \n            return;\n        }        \n                        \n        contribution = Math.min(maxContribution, totalAmount);        \n        contribution = Math.min(maxBalance - currentBalance, contribution);\n        \n        // Limitation on group min contribution.\n        if(contribution < minContribution) {\n            remaining = totalAmount;\n            contribution = 0;\n            return;\n        }\n                \n        remaining = totalAmount - contribution;\n    }\n\n    /**\n     * @dev Calculate pool summaries.\n     */\n    function calcPoolSummary(Pool storage pool) \n        private view \n        returns\n    (\n        uint poolContribution, \n        uint poolRemaining, \n        uint ctorFee\n    ) \n    {\n        Group storage group;\n        uint length = pool.groups.length;\n\n        for(uint idx = 0; idx < length; idx++) {\n            group = pool.groups[idx];\n            if(!group.exists) {\n                break;\n            }\n            \n            poolRemaining += group.remaining;\n            poolContribution += group.contribution;            \n            ctorFee += calcFee(group.contribution, group.ctorFeePerEther);\n        }\n    }  \n\n    /**\n     * @dev Calculate pool & participant summaries.\n     */  \n    function calcPoolSummary2(Pool storage pool, address addr) \n        private view\n        returns\n    (\n        uint poolContribution,\n        uint poolRemaining,\n        uint poolCtorFee,\n        uint partContribution,        \n        uint partCtorFee\n    ) \n    {\n        Group storage group;\n        Participant storage participant = pool.participantToData[addr];        \n        uint length = pool.groups.length;\n        \n        for(uint idx = 0; idx < length; idx++) {            \n            group = pool.groups[idx];\n            if(!group.exists) {\n                break;\n            }\n\n            poolRemaining += group.remaining;\n            poolContribution += group.contribution;\n            poolCtorFee += calcFee(group.contribution, group.ctorFeePerEther);\n                        \n            partContribution += participant.contribution[idx];\n            partCtorFee += calcFee(participant.contribution[idx], group.ctorFeePerEther);\n        }\n    }     \n\n    /**\n     * @dev Calculate pool & participant net summaries.\n     */   \n    function calcPoolSummary3(Pool storage pool, address addr) \n        private view\n        returns\n    (\n        uint netPoolContribution,\n        uint netPartContribution,\n        uint poolRemaining,\n        uint poolCtorFee\n    ) \n    {\n        uint poolContribution;        \n        uint partContribution;\n        uint partCtorFee;\n\n        (poolContribution, \n            poolRemaining, \n            poolCtorFee, \n            partContribution,             \n            partCtorFee\n        ) = calcPoolSummary2(pool, addr);\n\n        netPoolContribution = poolContribution - poolCtorFee - calcFee(poolContribution, pool.svcFeePerEther);\n        netPartContribution = partContribution - partCtorFee - calcFee(partContribution, pool.svcFeePerEther);\n    }          \n  \n    /**\n     * @dev Function for validating group settings.\n     */\n    function validateGroupSettings(uint maxBalance, uint minContribution, uint maxContribution) private pure {\n        require(\n            minContribution > 0 &&\n            minContribution <= maxContribution &&\n            maxContribution <= maxBalance &&\n            maxBalance <= 1e9 ether            \n        );\n    }\n\n    /**\n     * @dev Check if an array contains provided value.\n     */\n    function contains(address[] storage array, address addr) private view returns (bool) {\n        for (uint i = 0; i < array.length; i++) {\n            if (array[i] == addr) {\n                return true;\n            }\n        }\n        return false;\n    } \n\n    /**\n     * @dev Returns pool creator address.\n     */\n    function getPoolCreator(Pool storage pool) private view returns(address) {\n        return pool.admins[0];\n    }     \n\n    /**\n     * @dev Fee calculator.\n     */\n    function calcFee(uint etherAmount, uint feePerEther) private pure returns(uint fee) {\n        fee = (etherAmount * feePerEther) / 1 ether;\n    }    \n\n\n    event StateChanged(\n        uint fromState,\n        uint toState\n    ); \n\n    event AdminAdded(\n        address adminAddress\n    );\n\n    event WhitelistEnabled(\n        uint groupIndex\n    );\n\n    event PresaleAddressLocked(\n        address presaleAddress\n    );  \n\n    event RefundAddressChanged(\n        address refundAddress\n    );    \n\n    event FeesDistributed(\n        uint creatorFeeAmount,\n        uint serviceFeeAmount\n    );\n\n    event IncludedInWhitelist(\n        address participantAddress,\n        uint groupIndex\n    );\n\n    event ExcludedFromWhitelist(\n        address participantAddress,\n        uint groupIndex\n    );  \n\n    event FeeServiceAttached(\n        address serviceAddress,\n        uint feePerEther\n    );    \n\n    event TokenAddressConfirmed(\n        address tokenAddress,\n        uint tokenBalance\n    ); \n\n    event RefundReceived(\n        address senderAddress,\n        uint etherAmount\n    );    \n \n    event Contribution(\n        address participantAddress,\n        uint groupIndex,\n        uint etherAmount,\n        uint participantContribution,\n        uint groupContribution        \n    );\n\n    event Withdrawal(\n        address participantAddress,\n        uint groupIndex,\n        uint etherAmount,\n        uint participantContribution,\n        uint participantRemaining,        \n        uint groupContribution,\n        uint groupRemaining\n    );\n\n    event TokenWithdrawal(\n        address tokenAddress,\n        address participantAddress,\n        uint poolTokenBalance,\n        uint tokenAmount,\n        bool succeeded    \n    );   \n\n    event RefundWithdrawal(\n        address participantAddress,\n        uint contractBalance,\n        uint poolRemaining,\n        uint etherAmount\n    );  \n\n    event ContributionAdjusted(\n        address participantAddress,\n        uint participantContribution,\n        uint participantRemaining,\n        uint groupContribution,\n        uint groupRemaining,\n        uint groupIndex\n    );\n  \n    event GroupSettingsChanged(\n        uint index,\n        uint maxBalance,                               \n        uint minContribution,\n        uint maxContribution,                        \n        uint ctorFeePerEther,\n        bool isRestricted                            \n    );       \n\n    event AddressTransfer(\n        address destinationAddress,\n        uint etherValue\n    );\n\n    event AddressCall(\n        address destinationAddress,\n        uint etherAmount,\n        uint gasAmount,\n        bytes data      \n    );   \n\n    event TransactionForwarded(\n        address destinationAddress,\n        uint etherAmount,\n        uint gasAmount,\n        bytes data\n    );\n\n    event ERC223Fallback(\n        address tokenAddress,\n        address senderAddress,\n        uint tokenAmount,\n        bytes data\n    );   \n}",
        "function": "getGroupDetails(ProPoolLib.Pool storage,uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinfabrik-EasyPool Smart Contract Security Audit v2/EasyPool-master/contracts/library/ProPoolLib.sol",
        "vulnerability": "Exception State (SWC 110)",
        "check": "FP",
        "response": "Answer: No"
    }
]