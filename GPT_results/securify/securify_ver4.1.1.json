[
    {
        "code_segment": "pragma solidity >=0.4.24;\n\n\n// SWC-102-Outdated Compiler Version: L2\ncontract Migrations {\n  address public owner;\n  uint public last_completed_migration;\n\n  constructor() public {\n    owner = msg.sender;\n  }\n\n  modifier restricted() {\n    if (msg.sender == owner) _;\n  }\n\n  function setCompleted(uint completed) public restricted {\n    last_completed_migration = completed;\n  }\n\n  function upgrade(address new_address) public restricted {\n    Migrations upgraded = Migrations(new_address);\n    upgraded.setCompleted(last_completed_migration);\n  }\n}\n",
        "function": null,
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/QuillAudits-Akropolis-Vesting/AkropolisToken-28a415392489a1a88073c3d0fd22b141f4d3170e/contracts/Migrations.sol",
        "vulnerability": "MissingInputValidation",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity >=0.4.21 <0.6.0;\n\n\n// SWC-102-Outdated Compiler Version: L2\ncontract Migrations {\n  address public owner;\n  uint public last_completed_migration;\n\n  constructor() public {\n    owner = msg.sender;\n  }\n\n  modifier restricted() {\n    if (msg.sender == owner) _;\n  }\n\n  function setCompleted(uint completed) public restricted {\n    last_completed_migration = completed;\n  }\n\n  function upgrade(address new_address) public restricted {\n    Migrations upgraded = Migrations(new_address);\n    upgraded.setCompleted(last_completed_migration);\n  }\n}\n",
        "function": null,
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/QuillAudits-Akropolis-Vesting/akropolis-vesting-7f4f4543b08d3749b92839c85e1d77a33d917a37/contracts/Migrations.sol",
        "vulnerability": "MissingInputValidation",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity ^0.4.23;\n\n\n// SWC-102-Outdated Compiler Version: L2\ncontract Migrations {\n  address public owner;\n  uint public last_completed_migration;\n\n  constructor() public {\n    owner = msg.sender;\n  }\n\n  modifier restricted() {\n    if (msg.sender == owner) _;\n  }\n\n  function setCompleted(uint completed) public restricted {\n    last_completed_migration = completed;\n  }\n\n  function upgrade(address new_address) public restricted {\n    Migrations upgraded = Migrations(new_address);\n    upgraded.setCompleted(last_completed_migration);\n  }\n}\n",
        "function": null,
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinfabrik-EasyPool Smart Contract Security Audit/EasyPool-master/contracts/Migrations.sol",
        "vulnerability": "MissingInputValidation",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity ^0.4.18;\n\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a * b;\n    assert(a == 0 || c / a == b);\n    return c;\n  }\n\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return c;\n  }\n\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n\ncontract Owned {\n  event OwnerAddition(address indexed owner);\n\n  event OwnerRemoval(address indexed owner);\n\n  // owner address to enable admin functions\n  mapping (address => bool) public isOwner;\n\n  address[] public owners;\n\n  address public operator;\n\n  modifier onlyOwner {\n\n    require(isOwner[msg.sender]);\n    _;\n  }\n\n  modifier onlyOperator {\n    require(msg.sender == operator);\n    _;\n  }\n\n  function setOperator(address _operator) external onlyOwner {\n    require(_operator != address(0));\n    operator = _operator;\n  }\n\n  function removeOwner(address _owner) public onlyOwner {\n    require(owners.length > 1);\n    isOwner[_owner] = false;\n    for (uint i = 0; i < owners.length - 1; i++) {\n      if (owners[i] == _owner) {\n        owners[i] = owners[SafeMath.sub(owners.length, 1)];\n        break;\n      }\n    }\n    owners.length = SafeMath.sub(owners.length, 1);\n    OwnerRemoval(_owner);\n  }\n\n  function addOwner(address _owner) external onlyOwner {\n    require(_owner != address(0));\n    if(isOwner[_owner]) return;\n    isOwner[_owner] = true;\n    owners.push(_owner);\n    OwnerAddition(_owner);\n  }\n\n  function setOwners(address[] _owners) internal {\n    for (uint i = 0; i < _owners.length; i++) {\n      require(_owners[i] != address(0));\n      isOwner[_owners[i]] = true;\n      OwnerAddition(_owners[i]);\n    }\n    owners = _owners;\n  }\n\n  function getOwners() public constant returns (address[])  {\n    return owners;\n  }\n\n}\n\ncontract Validating {\n\n  modifier validAddress(address _address) {\n    require(_address != address(0x0));\n    _;\n  }\n\n  modifier notZero(uint _number) {\n    require(_number != 0);\n    _;\n  }\n\n  modifier notEmpty(string _string) {\n    require(bytes(_string).length != 0);\n    _;\n  }\n\n}\n\n// Abstract contract for the full ERC 20 Token standard\n// https://github.com/ethereum/EIPs/issues/20\ncontract Token {\n    /* This is a slight change to the ERC20 base standard.\n    function totalSupply() constant returns (uint256 supply);\n    is replaced with:\n    uint256 public totalSupply;\n    This automatically creates a getter function for the totalSupply.\n    This is moved to the base contract since public getter functions are not\n    currently recognised as an implementation of the matching abstract\n    function by the compiler.\n    */\n    \n    uint256 public totalSupply;\n\n    \n    \n    function balanceOf(address _owner) public constant returns (uint256 balance);\n\n    \n    \n    \n    \n    function transfer(address _to, uint256 _value) public returns (bool success);\n\n    \n    \n    \n    \n    \n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n\n    \n    \n    \n    \n    function approve(address _spender, uint256 _value) public returns (bool success);\n\n    \n    \n    \n    function allowance(address _owner, address _spender) public constant returns (uint256 remaining);\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\n\n/*\nYou should inherit from StandardToken or, for a token like you would want to\ndeploy in something like Mist, see HumanStandardToken.sol.\n(This implements ONLY the standard functions and NOTHING else.\nIf you deploy this, you won't have anything useful.)\n\nImplements ERC 20 Token standard: https://github.com/ethereum/EIPs/issues/20\n.*/\ncontract StandardToken is Token {\n\n    function transfer(address _to, uint256 _value) public returns (bool success) {\n        //Default assumes totalSupply can't be over max (2^256 - 1).\n        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n        //Replace the if with this one instead.\n        //require(balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]);\n        require(balances[msg.sender] >= _value);\n        balances[msg.sender] -= _value;\n        balances[_to] += _value;\n        Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n        //same as above. Replace this line with the following if you want to protect against wrapping uints.\n        //require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]);\n        require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value);\n        balances[_to] += _value;\n        balances[_from] -= _value;\n        allowed[_from][msg.sender] -= _value;\n        Transfer(_from, _to, _value);\n        return true;\n    }\n\n    function balanceOf(address _owner) public constant returns (uint256 balance) {\n        return balances[_owner];\n    }\n\n    function approve(address _spender, uint256 _value) public returns (bool success) {\n        allowed[msg.sender][_spender] = _value;\n        Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\n      return allowed[_owner][_spender];\n    }\n\n    mapping (address => uint256) balances;\n    mapping (address => mapping (address => uint256)) allowed;\n}\n\n// SWC-102-Outdated Compiler Version: L2\n/**\n  * @title FEE is an ERC20 token used to pay for trading on the exchange.\n  * For deeper rational read https://leverj.io/whitepaper.pdf.\n  * FEE tokens do not have limit. A new token can be generated by owner.\n  */\ncontract Fee is Owned, Validating, StandardToken {\n\n  /* This notifies clients about the amount burnt */\n  event Burn(address indexed from, uint256 value);\n\n  string public name;                   //fancy name: eg Simon Bucks\n  uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\n  string public symbol;                 //An identifier: eg SBX\n  uint256 public feeInCirculation;      //total fee in circulation\n  string public version = 'F0.1';       //human 0.1 standard. Just an arbitrary versioning scheme.\n  address public minter;\n\n  modifier onlyMinter {\n    require(msg.sender == minter);\n    _;\n  }\n\n  \n  function Fee(\n  address[] _owners,\n  string _tokenName,\n  uint8 _decimalUnits,\n  string _tokenSymbol\n  )\n  public\n  notEmpty(_tokenName)\n  notEmpty(_tokenSymbol)\n  {\n    setOwners(_owners);\n    name = _tokenName;\n    decimals = _decimalUnits;\n    symbol = _tokenSymbol;\n  }\n\n  \n  \n  function setMinter(address _minter) external onlyOwner validAddress(_minter) {\n    minter = _minter;\n  }\n\n  \n  \n  function burnTokens(uint _value) public notZero(_value) {\n    require(balances[msg.sender] >= _value);\n\n    balances[msg.sender] = SafeMath.sub(balances[msg.sender], _value);\n    feeInCirculation = SafeMath.sub(feeInCirculation, _value);\n    Burn(msg.sender, _value);\n  }\n\n  \n  \n  \n  \n  function sendTokens(address _to, uint _value) public onlyMinter validAddress(_to) notZero(_value) {\n    balances[_to] = SafeMath.add(balances[_to], _value);\n    feeInCirculation = SafeMath.add(feeInCirculation, _value);\n    Transfer(msg.sender, _to, _value);\n  }\n}\n",
        "function": null,
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Blockchain Labs NZ-Leverj/staking-e8716e4a11881fad181b5330206d8b0c27a58510/contracts/Fee.sol",
        "vulnerability": "MissingInputValidation",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity ^0.4.21;\n\n\n// smart contract for KOK coin\n// ownership contract\ncontract Owned {\n    address public owner;\n\n    event TransferOwnership(address oldaddr, address newaddr);\n\n    modifier onlyOwner() { if (msg.sender != owner) return; _; }\n\n    function Owned() public {\n        owner = msg.sender;\n    }\n    \n    function transferOwnership(address _new) onlyOwner public {\n        address oldaddr = owner;\n        owner = _new;\n        emit TransferOwnership(oldaddr, owner);\n    }\n}\n\n// erc20\ncontract ERC20Interface {\n\tuint256 public totalSupply;\n\tfunction balanceOf(address _owner) public constant returns (uint256 balance);\n\tfunction transfer(address _to, uint256 _value) public returns (bool success);\n\tfunction transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n\tfunction approve(address _spender, uint256 _value) public returns (bool success);\n\tfunction allowance(address _owner, address _spender) public constant returns (uint256 remaining);\n\tevent Transfer(address indexed _from, address indexed _to, uint256 _value);\n\tevent Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\n\ncontract KOK_Contract is ERC20Interface, Owned {\n\tstring public constant symbol = \"KOK\";\n\tstring public constant name = \"KOK Coin\";\n\tuint8 public constant decimals = 18;\n\tuint256 public constant totalSupply = 5000000000000000000000000000;\n\n\tbool public stopped;\n\n\tmapping (address => int8) public blackList;\n\n\tmapping (address => uint256) public balances;\n\tmapping (address => mapping (address => uint256)) public allowed;\n\n\n    event Blacklisted(address indexed target);\n    event DeleteFromBlacklist(address indexed target);\n    event RejectedPaymentToBlacklistedAddr(address indexed from, address indexed to, uint256 value);\n    event RejectedPaymentFromBlacklistedAddr(address indexed from, address indexed to, uint256 value);\n\n\n\tmodifier notStopped {\n        require(!stopped);\n        _;\n    }\n\n// constructor\n// SWC-118-Incorrect Constructor Name: L63\n\tfunction KOKContract() public {\n\t\tbalances[msg.sender] = totalSupply;\n\t}\n\t\n// function made for airdrop\n\tfunction airdrop(address[] _to, uint256[] _value) onlyOwner notStopped public {\n\t    for(uint256 i = 0; i < _to.length; i++){\n\t        if(balances[_to[i]] > 0){\n\t            continue;\n\t        }\n\t        transfer(_to[i], _value[i]);\n\t    }\n\t}\n\n// blacklist management\n    function blacklisting(address _addr) onlyOwner public {\n        blackList[_addr] = 1;\n        emit Blacklisted(_addr);\n    }\n    function deleteFromBlacklist(address _addr) onlyOwner public {\n        blackList[_addr] = -1;\n        emit DeleteFromBlacklist(_addr);\n    }\n\n// stop the contract\n// SWC-100-Function Default Visibility: L88\n\tfunction stop() onlyOwner {\n        stopped = true;\n    }\n// SWC-100-Function Default Visibility: L92\n    function start() onlyOwner {\n        stopped = false;\n    }\n\t\n// ERC20 functions\n\tfunction balanceOf(address _owner) public constant returns (uint256 balance){\n\t\treturn balances[_owner];\n\t}\n\tfunction transfer(address _to, uint256 _value) notStopped public returns (bool success){\n\t\trequire(balances[msg.sender] >= _value);\n\n\t\tif(blackList[msg.sender] > 0){\n\t\t\temit RejectedPaymentFromBlacklistedAddr(msg.sender, _to, _value);\n\t\t\treturn false;\n\t\t}\n\t\tif(blackList[_to] > 0){\n\t\t\temit RejectedPaymentToBlacklistedAddr(msg.sender, _to, _value);\n\t\t\treturn false;\n\t\t}\n\n\t\tbalances[msg.sender] -= _value;\n\t\tbalances[_to] += _value;\n\t\temit Transfer(msg.sender, _to, _value);\n\t\treturn true;\n\t}\n\tfunction transferFrom(address _from, address _to, uint256 _value) notStopped public returns (bool success){\n\t\trequire(balances[_from] >= _value\n\t\t\t&& allowed[_from][msg.sender] >= _value);\n\n\t\tif(blackList[_from] > 0){\n\t\t\temit RejectedPaymentFromBlacklistedAddr(_from, _to, _value);\n\t\t\treturn false;\n\t\t}\n\t\tif(blackList[_to] > 0){\n\t\t\temit RejectedPaymentToBlacklistedAddr(_from, _to, _value);\n\t\t\treturn false;\n\t\t}\n\n\t\tbalances[_from] -= _value;\n\t\tallowed[_from][msg.sender] -= _value;\n\t\tbalances[_to] += _value;\n\t\temit Transfer(_from, _to, _value);\n\t\treturn true;\n\t}\n\tfunction approve(address _spender, uint256 _value) notStopped public returns (bool success){\n\t\tallowed[msg.sender][_spender] = _value;\n\t\temit Approval(msg.sender, _spender, _value);\n\t\treturn true;\n\t}\n\tfunction allowance(address _owner, address _spender) public constant returns (uint256 remaining){\n\t\treturn allowed[_owner][_spender];\n\t}\n}\n",
        "function": null,
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Iosiro-KOK Token Smart Contract Audit/ERC-20-55a501fde12e782b99fe9d5756388c0de82f45ba/contract.sol",
        "vulnerability": "MissingInputValidation",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity ^0.4.4;\n\n\n// SWC-100-Function Default Visibility: L2-24\ncontract Migrations {\n  address public owner;\n  uint public last_completed_migration;\n\n  modifier restricted() {\n    if (msg.sender == owner) _;\n  }\n\n  function Migrations() {\n    owner = msg.sender;\n  }\n\n  function setCompleted(uint completed) restricted {\n    last_completed_migration = completed;\n  }\n\n  function upgrade(address new_address) restricted {\n    Migrations upgraded = Migrations(new_address);\n    upgraded.setCompleted(last_completed_migration);\n  }\n}\n",
        "function": null,
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Blockchain Labs NZ-SynchroLife/synchrocoin-contracts-master/contracts/Migrations.sol",
        "vulnerability": "MissingInputValidation",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity ^0.4.21;\n\n\n// ownership contract\ncontract Owned {\n    address public owner;\n\n    event TransferOwnership(address oldaddr, address newaddr);\n\n    modifier onlyOwner() { if (msg.sender != owner) return; _; }\n\n    function Owned() public {\n        owner = msg.sender;\n    }\n    \n    function transferOwnership(address _new) onlyOwner public {\n        address oldaddr = owner;\n        owner = _new;\n        emit TransferOwnership(oldaddr, owner);\n    }\n}\n\n// erc20\ncontract ERC20Interface {\n\tuint256 public totalSupply;\n\tfunction balanceOf(address _owner) public constant returns (uint256 balance);\n\tfunction transfer(address _to, uint256 _value) public returns (bool success);\n\tfunction transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n\tfunction approve(address _spender, uint256 _value) public returns (bool success);\n\tfunction allowance(address _owner, address _spender) public constant returns (uint256 remaining);\n\tevent Transfer(address indexed _from, address indexed _to, uint256 _value);\n\tevent Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\n\ncontract TMC_Contract is ERC20Interface, Owned {\n\tstring public constant symbol = \"TMC\";\n\tstring public constant name = \"TMC Token\";\n\tuint8 public constant decimals = 18;\n\tuint256 public constant totalSupply = 500000000000000000000000000;\n\n\tbool public stopped;\n\n\tmapping (address => int8) public blackList;\n\n\tmapping (address => uint256) public balances;\n\tmapping (address => mapping (address => uint256)) public allowed;\n\n\n    event Blacklisted(address indexed target);\n    event DeleteFromBlacklist(address indexed target);\n    event RejectedPaymentToBlacklistedAddr(address indexed from, address indexed to, uint256 value);\n    event RejectedPaymentFromBlacklistedAddr(address indexed from, address indexed to, uint256 value);\n\n\n\tmodifier notStopped {\n        require(!stopped);\n        _;\n    }\n\n// constructor\n\tfunction TMC_Contract() public {\n\t\tbalances[msg.sender] = totalSupply;\n\t}\n\t\n// function made for airdrop\n\tfunction airdrop(address[] _to, uint256[] _value) onlyOwner notStopped public {\n\t    for(uint256 i = 0; i < _to.length; i++){\n\t        if(balances[_to[i]] > 0){\n\t            continue;\n\t        }\n\t        transfer(_to[i], _value[i]);\n\t    }\n\t}\n\n// blacklist management\n    function blacklisting(address _addr) onlyOwner public {\n        blackList[_addr] = 1;\n        emit Blacklisted(_addr);\n    }\n    function deleteFromBlacklist(address _addr) onlyOwner public {\n        blackList[_addr] = -1;\n        emit DeleteFromBlacklist(_addr);\n    }\n\n// stop the contract\n// SWC-100-Function Default Visibility: L86\n\tfunction stop() onlyOwner {\n        stopped = true;\n    }\n// SWC-100-Function Default Visibility: L90\n    function start() onlyOwner {\n        stopped = false;\n    }\n\t\n// ERC20 functions\n\tfunction balanceOf(address _owner) public constant returns (uint256 balance){\n\t\treturn balances[_owner];\n\t}\n\tfunction transfer(address _to, uint256 _value) notStopped public returns (bool success){\n\t\trequire(balances[msg.sender] >= _value);\n\n\t\tif(blackList[msg.sender] > 0){\n\t\t\temit RejectedPaymentFromBlacklistedAddr(msg.sender, _to, _value);\n\t\t\treturn false;\n\t\t}\n\t\tif(blackList[_to] > 0){\n\t\t\temit RejectedPaymentToBlacklistedAddr(msg.sender, _to, _value);\n\t\t\treturn false;\n\t\t}\n\n\t\tbalances[msg.sender] -= _value;\n\t\tbalances[_to] += _value;\n\t\temit Transfer(msg.sender, _to, _value);\n\t\treturn true;\n\t}\n\tfunction transferFrom(address _from, address _to, uint256 _value) notStopped public returns (bool success){\n\t\trequire(balances[_from] >= _value\n\t\t\t&& allowed[_from][msg.sender] >= _value);\n\n\t\tif(blackList[_from] > 0){\n\t\t\temit RejectedPaymentFromBlacklistedAddr(_from, _to, _value);\n\t\t\treturn false;\n\t\t}\n\t\tif(blackList[_to] > 0){\n\t\t\temit RejectedPaymentToBlacklistedAddr(_from, _to, _value);\n\t\t\treturn false;\n\t\t}\n\n\t\tbalances[_from] -= _value;\n\t\tallowed[_from][msg.sender] -= _value;\n\t\tbalances[_to] += _value;\n\t\temit Transfer(_from, _to, _value);\n\t\treturn true;\n\t}\n\tfunction approve(address _spender, uint256 _value) notStopped public returns (bool success){\n\t\tallowed[msg.sender][_spender] = _value;\n\t\temit Approval(msg.sender, _spender, _value);\n\t\treturn true;\n\t}\n\tfunction allowance(address _owner, address _spender) public constant returns (uint256 remaining){\n\t\treturn allowed[_owner][_spender];\n\t}\n}\n",
        "function": null,
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Iosiro-TMC Token Smart Contract Audit/ERC20-Contract-b923cde02d2fd928760cc1e810410c2064fe1530/ERC20_Contract.sol",
        "vulnerability": "MissingInputValidation",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity ^0.4.23;\n\n\n//SWC-114-Transaction Order Dependence:L1-492\n// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\n//SWC-114-Transaction Order Dependence:L1-482\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n  address public owner;\n\n\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n\n  /**\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n   * account.\n   */\n  function Ownable() public {\n    owner = msg.sender;\n  }\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n   */\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n\n  /**\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n   * @param newOwner The address to transfer ownership to.\n   */\n  function transferOwnership(address newOwner) public onlyOwner {\n    require(newOwner != address(0));\n    emit OwnershipTransferred(owner, newOwner);\n    owner = newOwner;\n  }\n\n}\n\n// File: openzeppelin-solidity/contracts/lifecycle/Pausable.sol\n/**\n * @title Pausable\n * @dev Base contract which allows children to implement an emergency stop mechanism.\n */\ncontract Pausable is Ownable {\n  event Pause();\n  event Unpause();\n\n  bool public paused = false;\n\n\n  /**\n   * @dev Modifier to make a function callable only when the contract is not paused.\n   */\n  modifier whenNotPaused() {\n    require(!paused);\n    _;\n  }\n\n  /**\n   * @dev Modifier to make a function callable only when the contract is paused.\n   */\n  modifier whenPaused() {\n    require(paused);\n    _;\n  }\n\n  /**\n   * @dev called by the owner to pause, triggers stopped state\n   */\n  function pause() onlyOwner whenNotPaused public {\n    paused = true;\n    emit Pause();\n  }\n\n  /**\n   * @dev called by the owner to unpause, returns to normal state\n   */\n  function unpause() onlyOwner whenPaused public {\n    paused = false;\n    emit Unpause();\n  }\n}\n\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, throws on overflow.\n  */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    if (a == 0) {\n      return 0;\n    }\n    c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers, truncating the quotient.\n  */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    // uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return a / b;\n  }\n\n  /**\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  /**\n  * @dev Adds two numbers, throws on overflow.\n  */\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n\n// File: contracts/AuctionComponents/AuctionBase.sol\n/**\n * @title AuctionBase\n *\n * @author The AUX Team\n * @notice Base contract for single contract auctions. Assumes a single seller per auction.\n *\n */\ncontract AuctionBase is Pausable {\n  using SafeMath for uint256;\n\n  mapping(uint256 => address) public auctionIdToSeller;\n\n  //Start at 1 to avoid use of 0 which should be reserved for a 'null' auction value;\n  uint256 public nextAuctionId = 1;\n\n  /**\n   * @dev Throws if called by any account other than the seller for a given auction.\n   */\n  modifier onlySeller(uint256 auctionId) {\n    require(msg.sender == auctionIdToSeller[auctionId]);\n    _;\n  }\n\n  event AuctionCreated(address indexed createdBy, uint256 indexed auctionId);\n\n  /**\n   * @notice Creates an auction with an ID equivalent ot the value of nextAuctionId, then puts the caller's address in the auctionIdToSeller mapping.\n   */\n  function createEmptyAuction() internal returns (uint256) {\n    uint256 thisAuctionId = nextAuctionId;\n    nextAuctionId = nextAuctionId.add(1);\n\n    auctionIdToSeller[thisAuctionId] = msg.sender;\n\n    emit AuctionCreated(msg.sender, thisAuctionId);\n    return thisAuctionId;\n  }\n\n  function transferWinnings(address recipient, uint256 auctionId) internal;\n}\n\n// File: contracts/AuctionComponents/FeeCollector.sol\n/**\n * @title FeeCollector\n *\n * @author The AUX Team\n * @notice Adds modifiers for requiring fees on function calls\n *\n */\ncontract FeeCollector is Ownable {\n  using SafeMath for uint256;\n  uint256 feeBalance = 0;\n  /**\n   * @dev Throws if called by any account other than the seller for a given auction.\n   */\n  modifier requiresFee(uint256 feeAmount) {\n    require(msg.value >= feeAmount);\n    feeBalance = feeBalance.add(feeAmount);\n    msg.sender.transfer(msg.value.sub(feeAmount));\n    _;\n  }\n\n  event FeesWithdrawn(address indexed owner, uint256 indexed withdrawalAmount);\n\n  function withdrawFees() external onlyOwner {\n    uint256 feeAmountWithdrawn = feeBalance;\n    feeBalance = 0;\n    owner.transfer(feeAmountWithdrawn);\n    emit FeesWithdrawn(owner, feeAmountWithdrawn);\n  }\n}\n\n// File: contracts/AuctionComponents/DescendingPriceAuction.sol\n/**\n * @title DescendingPriceAuction\n *\n * @author The AUX Team\n * @notice Contract for a single contract \"Descending Price\" auction.\n */\ncontract DescendingPriceAuction is AuctionBase, FeeCollector {\n  using SafeMath for uint256;\n\n  mapping(uint256 => uint256) public auctionIdToStartPrice;\n  mapping(uint256 => uint256) public auctionIdToPriceFloor;\n  mapping(uint256 => uint256) public auctionIdToStartBlock;\n  mapping(uint256 => uint256) public auctionIdToPriceFloorBlock;\n  mapping(uint256 => bool) public auctionIdToAcceptingBids;\n\n  modifier onlyAcceptingBids(uint256 auctionId) {\n    require(auctionIdToAcceptingBids[auctionId]);\n    _;\n  }\n\n  /**\n   * @notice Should immediately end the auction by transferring the winnings to the bidder, as long as the bid is valid.\n   */\n  function bid(uint256 auctionId) whenNotPaused onlyAcceptingBids(auctionId) whenNotPaused external payable {\n    // Bidder must exist\n    require(msg.sender != 0x0);\n\n    uint256 currentPrice = getCurrentPrice(auctionId);\n    // Bidder must bid the correct amount or greater\n    require(msg.value >= currentPrice);\n\n    auctionIdToAcceptingBids[auctionId] = false;\n    transferWinnings(msg.sender, auctionId);\n//SWC-135-Code With No Effects:L245\n    //Check for overbid.\n    uint256 overbidAmount = msg.value.sub(currentPrice);\n    if (overbidAmount > 0) {\n      //Transfer any overbid amount back to the msg sender\n      msg.sender.transfer(overbidAmount);\n    }\n    auctionIdToSeller[auctionId].transfer(currentPrice);\n  }\n\n  function cancel(uint256 auctionId) whenNotPaused public onlySeller(auctionId) {\n    transferWinnings(auctionIdToSeller[auctionId], auctionId);\n    auctionIdToAcceptingBids[auctionId] = false;\n  }\n\n  function getCurrentPrice(uint256 auctionId) public view returns (uint256) {\n    //Only grab information necessary to check for whether we're in the middle of the price descent, before possibly returning priceFloor.\n    uint256 priceFloorBlock = auctionIdToPriceFloorBlock[auctionId];\n    uint256 priceFloor = auctionIdToPriceFloor[auctionId];\n\n    if (block.number >= priceFloorBlock) {\n      return priceFloor;\n    }\n\n    uint256 startBlock = auctionIdToStartBlock[auctionId];\n    uint256 startPrice = auctionIdToStartPrice[auctionId];\n\n    uint256 priceDifference = startPrice.sub(priceFloor);\n    uint256 blockDifference = priceFloorBlock.sub(startBlock);\n\n    uint256 numberOfBlocksElapsed = block.number.sub(startBlock);\n\n    uint256 priceDecrease = numberOfBlocksElapsed.mul(priceDifference.div(blockDifference));\n\n    return startPrice.sub(priceDecrease);\n  }\n\n  /**\n   * @notice Stores the requisite pricing information for a descending price auction.\n     Takes a 2% cut of the start price\n   */\n  function setAuctionPricing(uint256 startPrice, uint256 priceFloor, uint256 duration, uint256 auctionId) requiresFee(startPrice.div(50)) internal {\n    require(startPrice > 0 && priceFloor < startPrice && priceFloor >= 0 && duration > 0);\n\n    /*TODO: These mappings might be a good case for struct packing (auction info), from both a readability/optimization standpoint;\n            i.e. CryptoKitty source uses uint128 to rep money. A uint128 could be used to represent something like 10^33 ETH, which seems like more than enough.*/\n    auctionIdToStartBlock[auctionId] = block.number;\n    auctionIdToStartPrice[auctionId] = startPrice;\n    auctionIdToPriceFloor[auctionId] = priceFloor;\n    auctionIdToPriceFloorBlock[auctionId] = block.number.add(duration);\n    auctionIdToAcceptingBids[auctionId] = true;\n  }\n}\n\n// File: contracts/AuctionComponents/Whitelistable.sol\ncontract Whitelistable is Ownable {\n  mapping(address => bool) public whitelist;\n\n  event AddToWhitelist(address _address);\n  event RemoveFromWhitelist(address _address);\n\n  modifier isWhitelisted(address _addr) {\n    require(inWhitelist(_addr));\n    _;\n  }\n\n  /**\n   * @notice Checks the whitelist for a given address.\n   *\n   * @param _address The address to check against the whitelist.\n   * @return The list of whitelisted addresses.\n   */\n  function inWhitelist(address _address) public view returns (bool) {\n    return whitelist[_address];\n  }\n\n  /**\n   * @notice Adds an address to the whitelist.\n   *\n   * @param _address The address to whitelist.\n   * @return True on success, false on failure.\n   */\n  function addToWhitelist(address _address) public onlyOwner returns (bool) {\n    if (whitelist[_address]) {\n      // Already in the mapping\n      return false;\n    }\n\n    whitelist[_address] = true;\n    emit AddToWhitelist(_address);\n    return true;\n  }\n\n  /**\n   * @dev Removes an address from the whitelist.\n   *\n   * @param _address The addres to remove from the whitelist.\n   * @return True on success, false on failure.\n   */\n  function removeFromWhitelist(address _address) public onlyOwner returns (bool) {\n    if (!whitelist[_address]) {\n      // Not currently in the mapping\n      return false;\n    }\n\n    whitelist[_address] = false;\n    emit RemoveFromWhitelist(_address);\n    return true;\n  }\n}\n\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol\n/**\n * @title ERC20Basic\n * @dev Simpler version of ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/179\n */\ncontract ERC20Basic {\n  function totalSupply() public view returns (uint256);\n  function balanceOf(address who) public view returns (uint256);\n  function transfer(address to, uint256 value) public returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract ERC20 is ERC20Basic {\n  function allowance(address owner, address spender) public view returns (uint256);\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\n  function approve(address spender, uint256 value) public returns (bool);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n// File: contracts/AuctionComponents/ERC20Auction.sol\n/**\n * @title ERC20Auction\n *\n * @author The AUX Team\n * @notice Contract for an auction for a lot of ERC20 tokens - one bidder take all.\n */\ncontract ERC20Auction is AuctionBase, Whitelistable {\n  mapping(uint256 => address) public auctionIdToERC20Address;\n  mapping(uint256 => uint256) public auctionIdToAmount;\n\n  /**\n  * @notice Stores the given information for an auction for the given tokens, then attempts to transfer the tokens from the auction seller to this contract to start the auction.\n  */\n  function setAuctionAsset(address tokenAddress, uint256 tokenAmount, uint256 auctionId) isWhitelisted(tokenAddress) internal {\n    //NOTE: auctionId check requirement might not be necessary.\n    require(tokenAmount > 0 && auctionId != 0);\n    auctionIdToERC20Address[auctionId] = tokenAddress;\n    auctionIdToAmount[auctionId] = tokenAmount;\n    escrowERC20Tokens(msg.sender, tokenAddress, tokenAmount);\n  }\n\n  function transferWinnings(address recipient, uint256 auctionId) internal {\n    require(auctionId != 0);\n    require(auctionHasAssets(auctionId));\n    ERC20 erc20Contract = ERC20(auctionIdToERC20Address[auctionId]);\n    /*NOTE: Error should be thrown by transfer if unapproved, this require is unnecessary gas.\n    require(token.getApproved(kittyId) == address(this));*/\n    uint256 tokenAmount = auctionIdToAmount[auctionId];\n    auctionIdToAmount[auctionId] = 0;\n    erc20Contract.transfer(recipient, tokenAmount);\n  }\n\n  /**\n   * @dev Transfers tokens from an auction seller to the auction contract. This requires the auction to have been approved for taking control of the ERC20 tokens.\n   */\n  function escrowERC20Tokens(address auctionSeller, address tokenAddress, uint256 tokenAmount) private {\n    ERC20 erc20Contract = ERC20(tokenAddress);\n    /*NOTE: Error should be thrown by transferFrom if unapproved, this require is unnecessary gas.\n    require(token.getApproved(kittyId) == address(this));*/\n    erc20Contract.transferFrom(auctionSeller, this, tokenAmount);\n  }\n\n  function auctionHasAssets(uint256 auctionId) private view returns (bool) {\n    return (auctionIdToAmount[auctionId] != 0);\n  }\n}\n\n// File: contracts/Auctions/DescendingPriceERC20Auction.sol\n/**\n * @title AscendingPriceERC20Auction\n *\n * @author The AUX Team\n * @notice Contract for a descending price (Dutch) auction of an ERC20 token.\n */\ncontract DescendingPriceERC20Auction is DescendingPriceAuction, ERC20Auction {\n\n  /*TODO: Account for entry via ERC223 payment fallback function with data (ERC827 should work out of the box)\n\n  We should implement:\n    function tokenFallback(address _from, uint _value, bytes _data) { ... }\n\n  So that our Web3 interface can create an auction with one Web3 step by calling:\n    function transfer(address _to, uint _value, bytes _data) returns (bool)\n  */\n\n  /**\n  * @notice Creates and starts an auction with the given pricing and asset information.\n  * @dev Composes the setup for the DescendingPriceAuction, ERC20Auction and AuctionBase.\n  */\n  function createAuction(\n    uint256 startPrice,\n    uint256 priceFloor,\n    uint256 duration,\n    address tokenAddress,\n    uint256 tokenAmount) whenNotPaused public payable returns (uint256)\n  {\n    uint256 auctionId = createEmptyAuction();\n    setAuctionPricing(startPrice, priceFloor, duration, auctionId);\n    setAuctionAsset(tokenAddress, tokenAmount, auctionId);\n    return auctionId;\n  }\n}\n",
        "function": null,
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/New_Alchemy_Security_Audit-AUX Platform Security Audit/auction-contracts-0da231969b7f791cb1c131956b3f8886f860617b/DescendingPriceERC20Auction.sol",
        "vulnerability": "TODAmount",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity ^0.4.23;\n\n\n//SWC-114-Transaction Order Dependence:L1-492\n// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\n//SWC-114-Transaction Order Dependence:L1-482\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n  address public owner;\n\n\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n\n  /**\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n   * account.\n   */\n  function Ownable() public {\n    owner = msg.sender;\n  }\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n   */\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n\n  /**\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n   * @param newOwner The address to transfer ownership to.\n   */\n  function transferOwnership(address newOwner) public onlyOwner {\n    require(newOwner != address(0));\n    emit OwnershipTransferred(owner, newOwner);\n    owner = newOwner;\n  }\n\n}\n\n// File: openzeppelin-solidity/contracts/lifecycle/Pausable.sol\n/**\n * @title Pausable\n * @dev Base contract which allows children to implement an emergency stop mechanism.\n */\ncontract Pausable is Ownable {\n  event Pause();\n  event Unpause();\n\n  bool public paused = false;\n\n\n  /**\n   * @dev Modifier to make a function callable only when the contract is not paused.\n   */\n  modifier whenNotPaused() {\n    require(!paused);\n    _;\n  }\n\n  /**\n   * @dev Modifier to make a function callable only when the contract is paused.\n   */\n  modifier whenPaused() {\n    require(paused);\n    _;\n  }\n\n  /**\n   * @dev called by the owner to pause, triggers stopped state\n   */\n  function pause() onlyOwner whenNotPaused public {\n    paused = true;\n    emit Pause();\n  }\n\n  /**\n   * @dev called by the owner to unpause, returns to normal state\n   */\n  function unpause() onlyOwner whenPaused public {\n    paused = false;\n    emit Unpause();\n  }\n}\n\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, throws on overflow.\n  */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    if (a == 0) {\n      return 0;\n    }\n    c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers, truncating the quotient.\n  */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    // uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return a / b;\n  }\n\n  /**\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  /**\n  * @dev Adds two numbers, throws on overflow.\n  */\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n\n// File: contracts/AuctionComponents/AuctionBase.sol\n/**\n * @title AuctionBase\n *\n * @author The AUX Team\n * @notice Base contract for single contract auctions. Assumes a single seller per auction.\n *\n */\ncontract AuctionBase is Pausable {\n  using SafeMath for uint256;\n\n  mapping(uint256 => address) public auctionIdToSeller;\n\n  //Start at 1 to avoid use of 0 which should be reserved for a 'null' auction value;\n  uint256 public nextAuctionId = 1;\n\n  /**\n   * @dev Throws if called by any account other than the seller for a given auction.\n   */\n  modifier onlySeller(uint256 auctionId) {\n    require(msg.sender == auctionIdToSeller[auctionId]);\n    _;\n  }\n\n  event AuctionCreated(address indexed createdBy, uint256 indexed auctionId);\n\n  /**\n   * @notice Creates an auction with an ID equivalent ot the value of nextAuctionId, then puts the caller's address in the auctionIdToSeller mapping.\n   */\n  function createEmptyAuction() internal returns (uint256) {\n    uint256 thisAuctionId = nextAuctionId;\n    nextAuctionId = nextAuctionId.add(1);\n\n    auctionIdToSeller[thisAuctionId] = msg.sender;\n\n    emit AuctionCreated(msg.sender, thisAuctionId);\n    return thisAuctionId;\n  }\n\n  function transferWinnings(address recipient, uint256 auctionId) internal;\n}\n\n// File: contracts/AuctionComponents/FeeCollector.sol\n/**\n * @title FeeCollector\n *\n * @author The AUX Team\n * @notice Adds modifiers for requiring fees on function calls\n *\n */\ncontract FeeCollector is Ownable {\n  using SafeMath for uint256;\n  uint256 feeBalance = 0;\n  /**\n   * @dev Throws if called by any account other than the seller for a given auction.\n   */\n  modifier requiresFee(uint256 feeAmount) {\n    require(msg.value >= feeAmount);\n    feeBalance = feeBalance.add(feeAmount);\n    msg.sender.transfer(msg.value.sub(feeAmount));\n    _;\n  }\n\n  event FeesWithdrawn(address indexed owner, uint256 indexed withdrawalAmount);\n\n  function withdrawFees() external onlyOwner {\n    uint256 feeAmountWithdrawn = feeBalance;\n    feeBalance = 0;\n    owner.transfer(feeAmountWithdrawn);\n    emit FeesWithdrawn(owner, feeAmountWithdrawn);\n  }\n}\n\n// File: contracts/AuctionComponents/DescendingPriceAuction.sol\n/**\n * @title DescendingPriceAuction\n *\n * @author The AUX Team\n * @notice Contract for a single contract \"Descending Price\" auction.\n */\ncontract DescendingPriceAuction is AuctionBase, FeeCollector {\n  using SafeMath for uint256;\n\n  mapping(uint256 => uint256) public auctionIdToStartPrice;\n  mapping(uint256 => uint256) public auctionIdToPriceFloor;\n  mapping(uint256 => uint256) public auctionIdToStartBlock;\n  mapping(uint256 => uint256) public auctionIdToPriceFloorBlock;\n  mapping(uint256 => bool) public auctionIdToAcceptingBids;\n\n  modifier onlyAcceptingBids(uint256 auctionId) {\n    require(auctionIdToAcceptingBids[auctionId]);\n    _;\n  }\n\n  /**\n   * @notice Should immediately end the auction by transferring the winnings to the bidder, as long as the bid is valid.\n   */\n  function bid(uint256 auctionId) whenNotPaused onlyAcceptingBids(auctionId) whenNotPaused external payable {\n    // Bidder must exist\n    require(msg.sender != 0x0);\n\n    uint256 currentPrice = getCurrentPrice(auctionId);\n    // Bidder must bid the correct amount or greater\n    require(msg.value >= currentPrice);\n\n    auctionIdToAcceptingBids[auctionId] = false;\n    transferWinnings(msg.sender, auctionId);\n//SWC-135-Code With No Effects:L245\n    //Check for overbid.\n    uint256 overbidAmount = msg.value.sub(currentPrice);\n    if (overbidAmount > 0) {\n      //Transfer any overbid amount back to the msg sender\n      msg.sender.transfer(overbidAmount);\n    }\n    auctionIdToSeller[auctionId].transfer(currentPrice);\n  }\n\n  function cancel(uint256 auctionId) whenNotPaused public onlySeller(auctionId) {\n    transferWinnings(auctionIdToSeller[auctionId], auctionId);\n    auctionIdToAcceptingBids[auctionId] = false;\n  }\n\n  function getCurrentPrice(uint256 auctionId) public view returns (uint256) {\n    //Only grab information necessary to check for whether we're in the middle of the price descent, before possibly returning priceFloor.\n    uint256 priceFloorBlock = auctionIdToPriceFloorBlock[auctionId];\n    uint256 priceFloor = auctionIdToPriceFloor[auctionId];\n\n    if (block.number >= priceFloorBlock) {\n      return priceFloor;\n    }\n\n    uint256 startBlock = auctionIdToStartBlock[auctionId];\n    uint256 startPrice = auctionIdToStartPrice[auctionId];\n\n    uint256 priceDifference = startPrice.sub(priceFloor);\n    uint256 blockDifference = priceFloorBlock.sub(startBlock);\n\n    uint256 numberOfBlocksElapsed = block.number.sub(startBlock);\n\n    uint256 priceDecrease = numberOfBlocksElapsed.mul(priceDifference.div(blockDifference));\n\n    return startPrice.sub(priceDecrease);\n  }\n\n  /**\n   * @notice Stores the requisite pricing information for a descending price auction.\n     Takes a 2% cut of the start price\n   */\n  function setAuctionPricing(uint256 startPrice, uint256 priceFloor, uint256 duration, uint256 auctionId) requiresFee(startPrice.div(50)) internal {\n    require(startPrice > 0 && priceFloor < startPrice && priceFloor >= 0 && duration > 0);\n\n    /*TODO: These mappings might be a good case for struct packing (auction info), from both a readability/optimization standpoint;\n            i.e. CryptoKitty source uses uint128 to rep money. A uint128 could be used to represent something like 10^33 ETH, which seems like more than enough.*/\n    auctionIdToStartBlock[auctionId] = block.number;\n    auctionIdToStartPrice[auctionId] = startPrice;\n    auctionIdToPriceFloor[auctionId] = priceFloor;\n    auctionIdToPriceFloorBlock[auctionId] = block.number.add(duration);\n    auctionIdToAcceptingBids[auctionId] = true;\n  }\n}\n\n// File: contracts/AuctionComponents/Whitelistable.sol\ncontract Whitelistable is Ownable {\n  mapping(address => bool) public whitelist;\n\n  event AddToWhitelist(address _address);\n  event RemoveFromWhitelist(address _address);\n\n  modifier isWhitelisted(address _addr) {\n    require(inWhitelist(_addr));\n    _;\n  }\n\n  /**\n   * @notice Checks the whitelist for a given address.\n   *\n   * @param _address The address to check against the whitelist.\n   * @return The list of whitelisted addresses.\n   */\n  function inWhitelist(address _address) public view returns (bool) {\n    return whitelist[_address];\n  }\n\n  /**\n   * @notice Adds an address to the whitelist.\n   *\n   * @param _address The address to whitelist.\n   * @return True on success, false on failure.\n   */\n  function addToWhitelist(address _address) public onlyOwner returns (bool) {\n    if (whitelist[_address]) {\n      // Already in the mapping\n      return false;\n    }\n\n    whitelist[_address] = true;\n    emit AddToWhitelist(_address);\n    return true;\n  }\n\n  /**\n   * @dev Removes an address from the whitelist.\n   *\n   * @param _address The addres to remove from the whitelist.\n   * @return True on success, false on failure.\n   */\n  function removeFromWhitelist(address _address) public onlyOwner returns (bool) {\n    if (!whitelist[_address]) {\n      // Not currently in the mapping\n      return false;\n    }\n\n    whitelist[_address] = false;\n    emit RemoveFromWhitelist(_address);\n    return true;\n  }\n}\n\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol\n/**\n * @title ERC20Basic\n * @dev Simpler version of ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/179\n */\ncontract ERC20Basic {\n  function totalSupply() public view returns (uint256);\n  function balanceOf(address who) public view returns (uint256);\n  function transfer(address to, uint256 value) public returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract ERC20 is ERC20Basic {\n  function allowance(address owner, address spender) public view returns (uint256);\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\n  function approve(address spender, uint256 value) public returns (bool);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n// File: contracts/AuctionComponents/ERC20Auction.sol\n/**\n * @title ERC20Auction\n *\n * @author The AUX Team\n * @notice Contract for an auction for a lot of ERC20 tokens - one bidder take all.\n */\ncontract ERC20Auction is AuctionBase, Whitelistable {\n  mapping(uint256 => address) public auctionIdToERC20Address;\n  mapping(uint256 => uint256) public auctionIdToAmount;\n\n  /**\n  * @notice Stores the given information for an auction for the given tokens, then attempts to transfer the tokens from the auction seller to this contract to start the auction.\n  */\n  function setAuctionAsset(address tokenAddress, uint256 tokenAmount, uint256 auctionId) isWhitelisted(tokenAddress) internal {\n    //NOTE: auctionId check requirement might not be necessary.\n    require(tokenAmount > 0 && auctionId != 0);\n    auctionIdToERC20Address[auctionId] = tokenAddress;\n    auctionIdToAmount[auctionId] = tokenAmount;\n    escrowERC20Tokens(msg.sender, tokenAddress, tokenAmount);\n  }\n\n  function transferWinnings(address recipient, uint256 auctionId) internal {\n    require(auctionId != 0);\n    require(auctionHasAssets(auctionId));\n    ERC20 erc20Contract = ERC20(auctionIdToERC20Address[auctionId]);\n    /*NOTE: Error should be thrown by transfer if unapproved, this require is unnecessary gas.\n    require(token.getApproved(kittyId) == address(this));*/\n    uint256 tokenAmount = auctionIdToAmount[auctionId];\n    auctionIdToAmount[auctionId] = 0;\n    erc20Contract.transfer(recipient, tokenAmount);\n  }\n\n  /**\n   * @dev Transfers tokens from an auction seller to the auction contract. This requires the auction to have been approved for taking control of the ERC20 tokens.\n   */\n  function escrowERC20Tokens(address auctionSeller, address tokenAddress, uint256 tokenAmount) private {\n    ERC20 erc20Contract = ERC20(tokenAddress);\n    /*NOTE: Error should be thrown by transferFrom if unapproved, this require is unnecessary gas.\n    require(token.getApproved(kittyId) == address(this));*/\n    erc20Contract.transferFrom(auctionSeller, this, tokenAmount);\n  }\n\n  function auctionHasAssets(uint256 auctionId) private view returns (bool) {\n    return (auctionIdToAmount[auctionId] != 0);\n  }\n}\n\n// File: contracts/Auctions/DescendingPriceERC20Auction.sol\n/**\n * @title AscendingPriceERC20Auction\n *\n * @author The AUX Team\n * @notice Contract for a descending price (Dutch) auction of an ERC20 token.\n */\ncontract DescendingPriceERC20Auction is DescendingPriceAuction, ERC20Auction {\n\n  /*TODO: Account for entry via ERC223 payment fallback function with data (ERC827 should work out of the box)\n\n  We should implement:\n    function tokenFallback(address _from, uint _value, bytes _data) { ... }\n\n  So that our Web3 interface can create an auction with one Web3 step by calling:\n    function transfer(address _to, uint _value, bytes _data) returns (bool)\n  */\n\n  /**\n  * @notice Creates and starts an auction with the given pricing and asset information.\n  * @dev Composes the setup for the DescendingPriceAuction, ERC20Auction and AuctionBase.\n  */\n  function createAuction(\n    uint256 startPrice,\n    uint256 priceFloor,\n    uint256 duration,\n    address tokenAddress,\n    uint256 tokenAmount) whenNotPaused public payable returns (uint256)\n  {\n    uint256 auctionId = createEmptyAuction();\n    setAuctionPricing(startPrice, priceFloor, duration, auctionId);\n    setAuctionAsset(tokenAddress, tokenAmount, auctionId);\n    return auctionId;\n  }\n}\n",
        "function": null,
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/New_Alchemy_Security_Audit-AUX Platform Security Audit/auction-contracts-0da231969b7f791cb1c131956b3f8886f860617b/DescendingPriceERC20Auction.sol",
        "vulnerability": "MissingInputValidation",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity ^0.4.23;\n\n\n//SWC-114-Transaction Order Dependence:L1-492\n// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\n//SWC-114-Transaction Order Dependence:L1-482\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n  address public owner;\n\n\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n\n  /**\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n   * account.\n   */\n  function Ownable() public {\n    owner = msg.sender;\n  }\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n   */\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n\n  /**\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n   * @param newOwner The address to transfer ownership to.\n   */\n  function transferOwnership(address newOwner) public onlyOwner {\n    require(newOwner != address(0));\n    emit OwnershipTransferred(owner, newOwner);\n    owner = newOwner;\n  }\n\n}\n\n// File: openzeppelin-solidity/contracts/lifecycle/Pausable.sol\n/**\n * @title Pausable\n * @dev Base contract which allows children to implement an emergency stop mechanism.\n */\ncontract Pausable is Ownable {\n  event Pause();\n  event Unpause();\n\n  bool public paused = false;\n\n\n  /**\n   * @dev Modifier to make a function callable only when the contract is not paused.\n   */\n  modifier whenNotPaused() {\n    require(!paused);\n    _;\n  }\n\n  /**\n   * @dev Modifier to make a function callable only when the contract is paused.\n   */\n  modifier whenPaused() {\n    require(paused);\n    _;\n  }\n\n  /**\n   * @dev called by the owner to pause, triggers stopped state\n   */\n  function pause() onlyOwner whenNotPaused public {\n    paused = true;\n    emit Pause();\n  }\n\n  /**\n   * @dev called by the owner to unpause, returns to normal state\n   */\n  function unpause() onlyOwner whenPaused public {\n    paused = false;\n    emit Unpause();\n  }\n}\n\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, throws on overflow.\n  */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    if (a == 0) {\n      return 0;\n    }\n    c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers, truncating the quotient.\n  */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    // uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return a / b;\n  }\n\n  /**\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  /**\n  * @dev Adds two numbers, throws on overflow.\n  */\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n\n// File: contracts/AuctionComponents/AuctionBase.sol\n/**\n * @title AuctionBase\n *\n * @author The AUX Team\n * @notice Base contract for single contract auctions. Assumes a single seller per auction.\n *\n */\ncontract AuctionBase is Pausable {\n  using SafeMath for uint256;\n\n  mapping(uint256 => address) public auctionIdToSeller;\n\n  //Start at 1 to avoid use of 0 which should be reserved for a 'null' auction value;\n  uint256 public nextAuctionId = 1;\n\n  /**\n   * @dev Throws if called by any account other than the seller for a given auction.\n   */\n  modifier onlySeller(uint256 auctionId) {\n    require(msg.sender == auctionIdToSeller[auctionId]);\n    _;\n  }\n\n  event AuctionCreated(address indexed createdBy, uint256 indexed auctionId);\n\n  /**\n   * @notice Creates an auction with an ID equivalent ot the value of nextAuctionId, then puts the caller's address in the auctionIdToSeller mapping.\n   */\n  function createEmptyAuction() internal returns (uint256) {\n    uint256 thisAuctionId = nextAuctionId;\n    nextAuctionId = nextAuctionId.add(1);\n\n    auctionIdToSeller[thisAuctionId] = msg.sender;\n\n    emit AuctionCreated(msg.sender, thisAuctionId);\n    return thisAuctionId;\n  }\n\n  function transferWinnings(address recipient, uint256 auctionId) internal;\n}\n\n// File: contracts/AuctionComponents/FeeCollector.sol\n/**\n * @title FeeCollector\n *\n * @author The AUX Team\n * @notice Adds modifiers for requiring fees on function calls\n *\n */\ncontract FeeCollector is Ownable {\n  using SafeMath for uint256;\n  uint256 feeBalance = 0;\n  /**\n   * @dev Throws if called by any account other than the seller for a given auction.\n   */\n  modifier requiresFee(uint256 feeAmount) {\n    require(msg.value >= feeAmount);\n    feeBalance = feeBalance.add(feeAmount);\n    msg.sender.transfer(msg.value.sub(feeAmount));\n    _;\n  }\n\n  event FeesWithdrawn(address indexed owner, uint256 indexed withdrawalAmount);\n\n  function withdrawFees() external onlyOwner {\n    uint256 feeAmountWithdrawn = feeBalance;\n    feeBalance = 0;\n    owner.transfer(feeAmountWithdrawn);\n    emit FeesWithdrawn(owner, feeAmountWithdrawn);\n  }\n}\n\n// File: contracts/AuctionComponents/DescendingPriceAuction.sol\n/**\n * @title DescendingPriceAuction\n *\n * @author The AUX Team\n * @notice Contract for a single contract \"Descending Price\" auction.\n */\ncontract DescendingPriceAuction is AuctionBase, FeeCollector {\n  using SafeMath for uint256;\n\n  mapping(uint256 => uint256) public auctionIdToStartPrice;\n  mapping(uint256 => uint256) public auctionIdToPriceFloor;\n  mapping(uint256 => uint256) public auctionIdToStartBlock;\n  mapping(uint256 => uint256) public auctionIdToPriceFloorBlock;\n  mapping(uint256 => bool) public auctionIdToAcceptingBids;\n\n  modifier onlyAcceptingBids(uint256 auctionId) {\n    require(auctionIdToAcceptingBids[auctionId]);\n    _;\n  }\n\n  /**\n   * @notice Should immediately end the auction by transferring the winnings to the bidder, as long as the bid is valid.\n   */\n  function bid(uint256 auctionId) whenNotPaused onlyAcceptingBids(auctionId) whenNotPaused external payable {\n    // Bidder must exist\n    require(msg.sender != 0x0);\n\n    uint256 currentPrice = getCurrentPrice(auctionId);\n    // Bidder must bid the correct amount or greater\n    require(msg.value >= currentPrice);\n\n    auctionIdToAcceptingBids[auctionId] = false;\n    transferWinnings(msg.sender, auctionId);\n//SWC-135-Code With No Effects:L245\n    //Check for overbid.\n    uint256 overbidAmount = msg.value.sub(currentPrice);\n    if (overbidAmount > 0) {\n      //Transfer any overbid amount back to the msg sender\n      msg.sender.transfer(overbidAmount);\n    }\n    auctionIdToSeller[auctionId].transfer(currentPrice);\n  }\n\n  function cancel(uint256 auctionId) whenNotPaused public onlySeller(auctionId) {\n    transferWinnings(auctionIdToSeller[auctionId], auctionId);\n    auctionIdToAcceptingBids[auctionId] = false;\n  }\n\n  function getCurrentPrice(uint256 auctionId) public view returns (uint256) {\n    //Only grab information necessary to check for whether we're in the middle of the price descent, before possibly returning priceFloor.\n    uint256 priceFloorBlock = auctionIdToPriceFloorBlock[auctionId];\n    uint256 priceFloor = auctionIdToPriceFloor[auctionId];\n\n    if (block.number >= priceFloorBlock) {\n      return priceFloor;\n    }\n\n    uint256 startBlock = auctionIdToStartBlock[auctionId];\n    uint256 startPrice = auctionIdToStartPrice[auctionId];\n\n    uint256 priceDifference = startPrice.sub(priceFloor);\n    uint256 blockDifference = priceFloorBlock.sub(startBlock);\n\n    uint256 numberOfBlocksElapsed = block.number.sub(startBlock);\n\n    uint256 priceDecrease = numberOfBlocksElapsed.mul(priceDifference.div(blockDifference));\n\n    return startPrice.sub(priceDecrease);\n  }\n\n  /**\n   * @notice Stores the requisite pricing information for a descending price auction.\n     Takes a 2% cut of the start price\n   */\n  function setAuctionPricing(uint256 startPrice, uint256 priceFloor, uint256 duration, uint256 auctionId) requiresFee(startPrice.div(50)) internal {\n    require(startPrice > 0 && priceFloor < startPrice && priceFloor >= 0 && duration > 0);\n\n    /*TODO: These mappings might be a good case for struct packing (auction info), from both a readability/optimization standpoint;\n            i.e. CryptoKitty source uses uint128 to rep money. A uint128 could be used to represent something like 10^33 ETH, which seems like more than enough.*/\n    auctionIdToStartBlock[auctionId] = block.number;\n    auctionIdToStartPrice[auctionId] = startPrice;\n    auctionIdToPriceFloor[auctionId] = priceFloor;\n    auctionIdToPriceFloorBlock[auctionId] = block.number.add(duration);\n    auctionIdToAcceptingBids[auctionId] = true;\n  }\n}\n\n// File: contracts/AuctionComponents/Whitelistable.sol\ncontract Whitelistable is Ownable {\n  mapping(address => bool) public whitelist;\n\n  event AddToWhitelist(address _address);\n  event RemoveFromWhitelist(address _address);\n\n  modifier isWhitelisted(address _addr) {\n    require(inWhitelist(_addr));\n    _;\n  }\n\n  /**\n   * @notice Checks the whitelist for a given address.\n   *\n   * @param _address The address to check against the whitelist.\n   * @return The list of whitelisted addresses.\n   */\n  function inWhitelist(address _address) public view returns (bool) {\n    return whitelist[_address];\n  }\n\n  /**\n   * @notice Adds an address to the whitelist.\n   *\n   * @param _address The address to whitelist.\n   * @return True on success, false on failure.\n   */\n  function addToWhitelist(address _address) public onlyOwner returns (bool) {\n    if (whitelist[_address]) {\n      // Already in the mapping\n      return false;\n    }\n\n    whitelist[_address] = true;\n    emit AddToWhitelist(_address);\n    return true;\n  }\n\n  /**\n   * @dev Removes an address from the whitelist.\n   *\n   * @param _address The addres to remove from the whitelist.\n   * @return True on success, false on failure.\n   */\n  function removeFromWhitelist(address _address) public onlyOwner returns (bool) {\n    if (!whitelist[_address]) {\n      // Not currently in the mapping\n      return false;\n    }\n\n    whitelist[_address] = false;\n    emit RemoveFromWhitelist(_address);\n    return true;\n  }\n}\n\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol\n/**\n * @title ERC20Basic\n * @dev Simpler version of ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/179\n */\ncontract ERC20Basic {\n  function totalSupply() public view returns (uint256);\n  function balanceOf(address who) public view returns (uint256);\n  function transfer(address to, uint256 value) public returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract ERC20 is ERC20Basic {\n  function allowance(address owner, address spender) public view returns (uint256);\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\n  function approve(address spender, uint256 value) public returns (bool);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n// File: contracts/AuctionComponents/ERC20Auction.sol\n/**\n * @title ERC20Auction\n *\n * @author The AUX Team\n * @notice Contract for an auction for a lot of ERC20 tokens - one bidder take all.\n */\ncontract ERC20Auction is AuctionBase, Whitelistable {\n  mapping(uint256 => address) public auctionIdToERC20Address;\n  mapping(uint256 => uint256) public auctionIdToAmount;\n\n  /**\n  * @notice Stores the given information for an auction for the given tokens, then attempts to transfer the tokens from the auction seller to this contract to start the auction.\n  */\n  function setAuctionAsset(address tokenAddress, uint256 tokenAmount, uint256 auctionId) isWhitelisted(tokenAddress) internal {\n    //NOTE: auctionId check requirement might not be necessary.\n    require(tokenAmount > 0 && auctionId != 0);\n    auctionIdToERC20Address[auctionId] = tokenAddress;\n    auctionIdToAmount[auctionId] = tokenAmount;\n    escrowERC20Tokens(msg.sender, tokenAddress, tokenAmount);\n  }\n\n  function transferWinnings(address recipient, uint256 auctionId) internal {\n    require(auctionId != 0);\n    require(auctionHasAssets(auctionId));\n    ERC20 erc20Contract = ERC20(auctionIdToERC20Address[auctionId]);\n    /*NOTE: Error should be thrown by transfer if unapproved, this require is unnecessary gas.\n    require(token.getApproved(kittyId) == address(this));*/\n    uint256 tokenAmount = auctionIdToAmount[auctionId];\n    auctionIdToAmount[auctionId] = 0;\n    erc20Contract.transfer(recipient, tokenAmount);\n  }\n\n  /**\n   * @dev Transfers tokens from an auction seller to the auction contract. This requires the auction to have been approved for taking control of the ERC20 tokens.\n   */\n  function escrowERC20Tokens(address auctionSeller, address tokenAddress, uint256 tokenAmount) private {\n    ERC20 erc20Contract = ERC20(tokenAddress);\n    /*NOTE: Error should be thrown by transferFrom if unapproved, this require is unnecessary gas.\n    require(token.getApproved(kittyId) == address(this));*/\n    erc20Contract.transferFrom(auctionSeller, this, tokenAmount);\n  }\n\n  function auctionHasAssets(uint256 auctionId) private view returns (bool) {\n    return (auctionIdToAmount[auctionId] != 0);\n  }\n}\n\n// File: contracts/Auctions/DescendingPriceERC20Auction.sol\n/**\n * @title AscendingPriceERC20Auction\n *\n * @author The AUX Team\n * @notice Contract for a descending price (Dutch) auction of an ERC20 token.\n */\ncontract DescendingPriceERC20Auction is DescendingPriceAuction, ERC20Auction {\n\n  /*TODO: Account for entry via ERC223 payment fallback function with data (ERC827 should work out of the box)\n\n  We should implement:\n    function tokenFallback(address _from, uint _value, bytes _data) { ... }\n\n  So that our Web3 interface can create an auction with one Web3 step by calling:\n    function transfer(address _to, uint _value, bytes _data) returns (bool)\n  */\n\n  /**\n  * @notice Creates and starts an auction with the given pricing and asset information.\n  * @dev Composes the setup for the DescendingPriceAuction, ERC20Auction and AuctionBase.\n  */\n  function createAuction(\n    uint256 startPrice,\n    uint256 priceFloor,\n    uint256 duration,\n    address tokenAddress,\n    uint256 tokenAmount) whenNotPaused public payable returns (uint256)\n  {\n    uint256 auctionId = createEmptyAuction();\n    setAuctionPricing(startPrice, priceFloor, duration, auctionId);\n    setAuctionAsset(tokenAddress, tokenAmount, auctionId);\n    return auctionId;\n  }\n}\n",
        "function": null,
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/New_Alchemy_Security_Audit-AUX Platform Security Audit/auction-contracts-0da231969b7f791cb1c131956b3f8886f860617b/DescendingPriceERC20Auction.sol",
        "vulnerability": "TODReceiver",
        "check": "TP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity ^0.4.23;\n\n\n//SWC-114-Transaction Order Dependence:L1-492\n// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\n//SWC-114-Transaction Order Dependence:L1-482\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n  address public owner;\n\n\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n\n  /**\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n   * account.\n   */\n  function Ownable() public {\n    owner = msg.sender;\n  }\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n   */\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n\n  /**\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n   * @param newOwner The address to transfer ownership to.\n   */\n  function transferOwnership(address newOwner) public onlyOwner {\n    require(newOwner != address(0));\n    emit OwnershipTransferred(owner, newOwner);\n    owner = newOwner;\n  }\n\n}\n\n// File: openzeppelin-solidity/contracts/lifecycle/Pausable.sol\n/**\n * @title Pausable\n * @dev Base contract which allows children to implement an emergency stop mechanism.\n */\ncontract Pausable is Ownable {\n  event Pause();\n  event Unpause();\n\n  bool public paused = false;\n\n\n  /**\n   * @dev Modifier to make a function callable only when the contract is not paused.\n   */\n  modifier whenNotPaused() {\n    require(!paused);\n    _;\n  }\n\n  /**\n   * @dev Modifier to make a function callable only when the contract is paused.\n   */\n  modifier whenPaused() {\n    require(paused);\n    _;\n  }\n\n  /**\n   * @dev called by the owner to pause, triggers stopped state\n   */\n  function pause() onlyOwner whenNotPaused public {\n    paused = true;\n    emit Pause();\n  }\n\n  /**\n   * @dev called by the owner to unpause, returns to normal state\n   */\n  function unpause() onlyOwner whenPaused public {\n    paused = false;\n    emit Unpause();\n  }\n}\n\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, throws on overflow.\n  */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    if (a == 0) {\n      return 0;\n    }\n    c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers, truncating the quotient.\n  */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    // uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return a / b;\n  }\n\n  /**\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  /**\n  * @dev Adds two numbers, throws on overflow.\n  */\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n\n// File: contracts/AuctionComponents/AuctionBase.sol\n/**\n * @title AuctionBase\n *\n * @author The AUX Team\n * @notice Base contract for single contract auctions. Assumes a single seller per auction.\n *\n */\ncontract AuctionBase is Pausable {\n  using SafeMath for uint256;\n\n  mapping(uint256 => address) public auctionIdToSeller;\n\n  //Start at 1 to avoid use of 0 which should be reserved for a 'null' auction value;\n  uint256 public nextAuctionId = 1;\n\n  /**\n   * @dev Throws if called by any account other than the seller for a given auction.\n   */\n  modifier onlySeller(uint256 auctionId) {\n    require(msg.sender == auctionIdToSeller[auctionId]);\n    _;\n  }\n\n  event AuctionCreated(address indexed createdBy, uint256 indexed auctionId);\n\n  /**\n   * @notice Creates an auction with an ID equivalent ot the value of nextAuctionId, then puts the caller's address in the auctionIdToSeller mapping.\n   */\n  function createEmptyAuction() internal returns (uint256) {\n    uint256 thisAuctionId = nextAuctionId;\n    nextAuctionId = nextAuctionId.add(1);\n\n    auctionIdToSeller[thisAuctionId] = msg.sender;\n\n    emit AuctionCreated(msg.sender, thisAuctionId);\n    return thisAuctionId;\n  }\n\n  function transferWinnings(address recipient, uint256 auctionId) internal;\n}\n\n// File: contracts/AuctionComponents/FeeCollector.sol\n/**\n * @title FeeCollector\n *\n * @author The AUX Team\n * @notice Adds modifiers for requiring fees on function calls\n *\n */\ncontract FeeCollector is Ownable {\n  using SafeMath for uint256;\n  uint256 feeBalance = 0;\n  /**\n   * @dev Throws if called by any account other than the seller for a given auction.\n   */\n  modifier requiresFee(uint256 feeAmount) {\n    require(msg.value >= feeAmount);\n    feeBalance = feeBalance.add(feeAmount);\n    msg.sender.transfer(msg.value.sub(feeAmount));\n    _;\n  }\n\n  event FeesWithdrawn(address indexed owner, uint256 indexed withdrawalAmount);\n\n  function withdrawFees() external onlyOwner {\n    uint256 feeAmountWithdrawn = feeBalance;\n    feeBalance = 0;\n    owner.transfer(feeAmountWithdrawn);\n    emit FeesWithdrawn(owner, feeAmountWithdrawn);\n  }\n}\n\n// File: contracts/AuctionComponents/DescendingPriceAuction.sol\n/**\n * @title DescendingPriceAuction\n *\n * @author The AUX Team\n * @notice Contract for a single contract \"Descending Price\" auction.\n */\ncontract DescendingPriceAuction is AuctionBase, FeeCollector {\n  using SafeMath for uint256;\n\n  mapping(uint256 => uint256) public auctionIdToStartPrice;\n  mapping(uint256 => uint256) public auctionIdToPriceFloor;\n  mapping(uint256 => uint256) public auctionIdToStartBlock;\n  mapping(uint256 => uint256) public auctionIdToPriceFloorBlock;\n  mapping(uint256 => bool) public auctionIdToAcceptingBids;\n\n  modifier onlyAcceptingBids(uint256 auctionId) {\n    require(auctionIdToAcceptingBids[auctionId]);\n    _;\n  }\n\n  /**\n   * @notice Should immediately end the auction by transferring the winnings to the bidder, as long as the bid is valid.\n   */\n  function bid(uint256 auctionId) whenNotPaused onlyAcceptingBids(auctionId) whenNotPaused external payable {\n    // Bidder must exist\n    require(msg.sender != 0x0);\n\n    uint256 currentPrice = getCurrentPrice(auctionId);\n    // Bidder must bid the correct amount or greater\n    require(msg.value >= currentPrice);\n\n    auctionIdToAcceptingBids[auctionId] = false;\n    transferWinnings(msg.sender, auctionId);\n//SWC-135-Code With No Effects:L245\n    //Check for overbid.\n    uint256 overbidAmount = msg.value.sub(currentPrice);\n    if (overbidAmount > 0) {\n      //Transfer any overbid amount back to the msg sender\n      msg.sender.transfer(overbidAmount);\n    }\n    auctionIdToSeller[auctionId].transfer(currentPrice);\n  }\n\n  function cancel(uint256 auctionId) whenNotPaused public onlySeller(auctionId) {\n    transferWinnings(auctionIdToSeller[auctionId], auctionId);\n    auctionIdToAcceptingBids[auctionId] = false;\n  }\n\n  function getCurrentPrice(uint256 auctionId) public view returns (uint256) {\n    //Only grab information necessary to check for whether we're in the middle of the price descent, before possibly returning priceFloor.\n    uint256 priceFloorBlock = auctionIdToPriceFloorBlock[auctionId];\n    uint256 priceFloor = auctionIdToPriceFloor[auctionId];\n\n    if (block.number >= priceFloorBlock) {\n      return priceFloor;\n    }\n\n    uint256 startBlock = auctionIdToStartBlock[auctionId];\n    uint256 startPrice = auctionIdToStartPrice[auctionId];\n\n    uint256 priceDifference = startPrice.sub(priceFloor);\n    uint256 blockDifference = priceFloorBlock.sub(startBlock);\n\n    uint256 numberOfBlocksElapsed = block.number.sub(startBlock);\n\n    uint256 priceDecrease = numberOfBlocksElapsed.mul(priceDifference.div(blockDifference));\n\n    return startPrice.sub(priceDecrease);\n  }\n\n  /**\n   * @notice Stores the requisite pricing information for a descending price auction.\n     Takes a 2% cut of the start price\n   */\n  function setAuctionPricing(uint256 startPrice, uint256 priceFloor, uint256 duration, uint256 auctionId) requiresFee(startPrice.div(50)) internal {\n    require(startPrice > 0 && priceFloor < startPrice && priceFloor >= 0 && duration > 0);\n\n    /*TODO: These mappings might be a good case for struct packing (auction info), from both a readability/optimization standpoint;\n            i.e. CryptoKitty source uses uint128 to rep money. A uint128 could be used to represent something like 10^33 ETH, which seems like more than enough.*/\n    auctionIdToStartBlock[auctionId] = block.number;\n    auctionIdToStartPrice[auctionId] = startPrice;\n    auctionIdToPriceFloor[auctionId] = priceFloor;\n    auctionIdToPriceFloorBlock[auctionId] = block.number.add(duration);\n    auctionIdToAcceptingBids[auctionId] = true;\n  }\n}\n\n// File: contracts/AuctionComponents/Whitelistable.sol\ncontract Whitelistable is Ownable {\n  mapping(address => bool) public whitelist;\n\n  event AddToWhitelist(address _address);\n  event RemoveFromWhitelist(address _address);\n\n  modifier isWhitelisted(address _addr) {\n    require(inWhitelist(_addr));\n    _;\n  }\n\n  /**\n   * @notice Checks the whitelist for a given address.\n   *\n   * @param _address The address to check against the whitelist.\n   * @return The list of whitelisted addresses.\n   */\n  function inWhitelist(address _address) public view returns (bool) {\n    return whitelist[_address];\n  }\n\n  /**\n   * @notice Adds an address to the whitelist.\n   *\n   * @param _address The address to whitelist.\n   * @return True on success, false on failure.\n   */\n  function addToWhitelist(address _address) public onlyOwner returns (bool) {\n    if (whitelist[_address]) {\n      // Already in the mapping\n      return false;\n    }\n\n    whitelist[_address] = true;\n    emit AddToWhitelist(_address);\n    return true;\n  }\n\n  /**\n   * @dev Removes an address from the whitelist.\n   *\n   * @param _address The addres to remove from the whitelist.\n   * @return True on success, false on failure.\n   */\n  function removeFromWhitelist(address _address) public onlyOwner returns (bool) {\n    if (!whitelist[_address]) {\n      // Not currently in the mapping\n      return false;\n    }\n\n    whitelist[_address] = false;\n    emit RemoveFromWhitelist(_address);\n    return true;\n  }\n}\n\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol\n/**\n * @title ERC20Basic\n * @dev Simpler version of ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/179\n */\ncontract ERC20Basic {\n  function totalSupply() public view returns (uint256);\n  function balanceOf(address who) public view returns (uint256);\n  function transfer(address to, uint256 value) public returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract ERC20 is ERC20Basic {\n  function allowance(address owner, address spender) public view returns (uint256);\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\n  function approve(address spender, uint256 value) public returns (bool);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n// File: contracts/AuctionComponents/ERC20Auction.sol\n/**\n * @title ERC20Auction\n *\n * @author The AUX Team\n * @notice Contract for an auction for a lot of ERC20 tokens - one bidder take all.\n */\ncontract ERC20Auction is AuctionBase, Whitelistable {\n  mapping(uint256 => address) public auctionIdToERC20Address;\n  mapping(uint256 => uint256) public auctionIdToAmount;\n\n  /**\n  * @notice Stores the given information for an auction for the given tokens, then attempts to transfer the tokens from the auction seller to this contract to start the auction.\n  */\n  function setAuctionAsset(address tokenAddress, uint256 tokenAmount, uint256 auctionId) isWhitelisted(tokenAddress) internal {\n    //NOTE: auctionId check requirement might not be necessary.\n    require(tokenAmount > 0 && auctionId != 0);\n    auctionIdToERC20Address[auctionId] = tokenAddress;\n    auctionIdToAmount[auctionId] = tokenAmount;\n    escrowERC20Tokens(msg.sender, tokenAddress, tokenAmount);\n  }\n\n  function transferWinnings(address recipient, uint256 auctionId) internal {\n    require(auctionId != 0);\n    require(auctionHasAssets(auctionId));\n    ERC20 erc20Contract = ERC20(auctionIdToERC20Address[auctionId]);\n    /*NOTE: Error should be thrown by transfer if unapproved, this require is unnecessary gas.\n    require(token.getApproved(kittyId) == address(this));*/\n    uint256 tokenAmount = auctionIdToAmount[auctionId];\n    auctionIdToAmount[auctionId] = 0;\n    erc20Contract.transfer(recipient, tokenAmount);\n  }\n\n  /**\n   * @dev Transfers tokens from an auction seller to the auction contract. This requires the auction to have been approved for taking control of the ERC20 tokens.\n   */\n  function escrowERC20Tokens(address auctionSeller, address tokenAddress, uint256 tokenAmount) private {\n    ERC20 erc20Contract = ERC20(tokenAddress);\n    /*NOTE: Error should be thrown by transferFrom if unapproved, this require is unnecessary gas.\n    require(token.getApproved(kittyId) == address(this));*/\n    erc20Contract.transferFrom(auctionSeller, this, tokenAmount);\n  }\n\n  function auctionHasAssets(uint256 auctionId) private view returns (bool) {\n    return (auctionIdToAmount[auctionId] != 0);\n  }\n}\n\n// File: contracts/Auctions/DescendingPriceERC20Auction.sol\n/**\n * @title AscendingPriceERC20Auction\n *\n * @author The AUX Team\n * @notice Contract for a descending price (Dutch) auction of an ERC20 token.\n */\ncontract DescendingPriceERC20Auction is DescendingPriceAuction, ERC20Auction {\n\n  /*TODO: Account for entry via ERC223 payment fallback function with data (ERC827 should work out of the box)\n\n  We should implement:\n    function tokenFallback(address _from, uint _value, bytes _data) { ... }\n\n  So that our Web3 interface can create an auction with one Web3 step by calling:\n    function transfer(address _to, uint _value, bytes _data) returns (bool)\n  */\n\n  /**\n  * @notice Creates and starts an auction with the given pricing and asset information.\n  * @dev Composes the setup for the DescendingPriceAuction, ERC20Auction and AuctionBase.\n  */\n  function createAuction(\n    uint256 startPrice,\n    uint256 priceFloor,\n    uint256 duration,\n    address tokenAddress,\n    uint256 tokenAmount) whenNotPaused public payable returns (uint256)\n  {\n    uint256 auctionId = createEmptyAuction();\n    setAuctionPricing(startPrice, priceFloor, duration, auctionId);\n    setAuctionAsset(tokenAddress, tokenAmount, auctionId);\n    return auctionId;\n  }\n}\n",
        "function": null,
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/New_Alchemy_Security_Audit-AUX Platform Security Audit/auction-contracts-0da231969b7f791cb1c131956b3f8886f860617b/DescendingPriceERC20Auction.sol",
        "vulnerability": "DAOConstantGas",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity ^0.4.23;\n\n\n//SWC-114-Transaction Order Dependence:L1-492\n// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\n//SWC-114-Transaction Order Dependence:L1-482\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n  address public owner;\n\n\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n\n  /**\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n   * account.\n   */\n  function Ownable() public {\n    owner = msg.sender;\n  }\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n   */\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n\n  /**\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n   * @param newOwner The address to transfer ownership to.\n   */\n  function transferOwnership(address newOwner) public onlyOwner {\n    require(newOwner != address(0));\n    emit OwnershipTransferred(owner, newOwner);\n    owner = newOwner;\n  }\n\n}\n\n// File: openzeppelin-solidity/contracts/lifecycle/Pausable.sol\n/**\n * @title Pausable\n * @dev Base contract which allows children to implement an emergency stop mechanism.\n */\ncontract Pausable is Ownable {\n  event Pause();\n  event Unpause();\n\n  bool public paused = false;\n\n\n  /**\n   * @dev Modifier to make a function callable only when the contract is not paused.\n   */\n  modifier whenNotPaused() {\n    require(!paused);\n    _;\n  }\n\n  /**\n   * @dev Modifier to make a function callable only when the contract is paused.\n   */\n  modifier whenPaused() {\n    require(paused);\n    _;\n  }\n\n  /**\n   * @dev called by the owner to pause, triggers stopped state\n   */\n  function pause() onlyOwner whenNotPaused public {\n    paused = true;\n    emit Pause();\n  }\n\n  /**\n   * @dev called by the owner to unpause, returns to normal state\n   */\n  function unpause() onlyOwner whenPaused public {\n    paused = false;\n    emit Unpause();\n  }\n}\n\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, throws on overflow.\n  */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    if (a == 0) {\n      return 0;\n    }\n    c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers, truncating the quotient.\n  */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    // uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return a / b;\n  }\n\n  /**\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  /**\n  * @dev Adds two numbers, throws on overflow.\n  */\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n\n// File: contracts/AuctionComponents/AuctionBase.sol\n/**\n * @title AuctionBase\n *\n * @author The AUX Team\n * @notice Base contract for single contract auctions. Assumes a single seller per auction.\n *\n */\ncontract AuctionBase is Pausable {\n  using SafeMath for uint256;\n\n  mapping(uint256 => address) public auctionIdToSeller;\n\n  //Start at 1 to avoid use of 0 which should be reserved for a 'null' auction value;\n  uint256 public nextAuctionId = 1;\n\n  /**\n   * @dev Throws if called by any account other than the seller for a given auction.\n   */\n  modifier onlySeller(uint256 auctionId) {\n    require(msg.sender == auctionIdToSeller[auctionId]);\n    _;\n  }\n\n  event AuctionCreated(address indexed createdBy, uint256 indexed auctionId);\n\n  /**\n   * @notice Creates an auction with an ID equivalent ot the value of nextAuctionId, then puts the caller's address in the auctionIdToSeller mapping.\n   */\n  function createEmptyAuction() internal returns (uint256) {\n    uint256 thisAuctionId = nextAuctionId;\n    nextAuctionId = nextAuctionId.add(1);\n\n    auctionIdToSeller[thisAuctionId] = msg.sender;\n\n    emit AuctionCreated(msg.sender, thisAuctionId);\n    return thisAuctionId;\n  }\n\n  function transferWinnings(address recipient, uint256 auctionId) internal;\n}\n\n// File: contracts/AuctionComponents/FeeCollector.sol\n/**\n * @title FeeCollector\n *\n * @author The AUX Team\n * @notice Adds modifiers for requiring fees on function calls\n *\n */\ncontract FeeCollector is Ownable {\n  using SafeMath for uint256;\n  uint256 feeBalance = 0;\n  /**\n   * @dev Throws if called by any account other than the seller for a given auction.\n   */\n  modifier requiresFee(uint256 feeAmount) {\n    require(msg.value >= feeAmount);\n    feeBalance = feeBalance.add(feeAmount);\n    msg.sender.transfer(msg.value.sub(feeAmount));\n    _;\n  }\n\n  event FeesWithdrawn(address indexed owner, uint256 indexed withdrawalAmount);\n\n  function withdrawFees() external onlyOwner {\n    uint256 feeAmountWithdrawn = feeBalance;\n    feeBalance = 0;\n    owner.transfer(feeAmountWithdrawn);\n    emit FeesWithdrawn(owner, feeAmountWithdrawn);\n  }\n}\n\n// File: contracts/AuctionComponents/DescendingPriceAuction.sol\n/**\n * @title DescendingPriceAuction\n *\n * @author The AUX Team\n * @notice Contract for a single contract \"Descending Price\" auction.\n */\ncontract DescendingPriceAuction is AuctionBase, FeeCollector {\n  using SafeMath for uint256;\n\n  mapping(uint256 => uint256) public auctionIdToStartPrice;\n  mapping(uint256 => uint256) public auctionIdToPriceFloor;\n  mapping(uint256 => uint256) public auctionIdToStartBlock;\n  mapping(uint256 => uint256) public auctionIdToPriceFloorBlock;\n  mapping(uint256 => bool) public auctionIdToAcceptingBids;\n\n  modifier onlyAcceptingBids(uint256 auctionId) {\n    require(auctionIdToAcceptingBids[auctionId]);\n    _;\n  }\n\n  /**\n   * @notice Should immediately end the auction by transferring the winnings to the bidder, as long as the bid is valid.\n   */\n  function bid(uint256 auctionId) whenNotPaused onlyAcceptingBids(auctionId) whenNotPaused external payable {\n    // Bidder must exist\n    require(msg.sender != 0x0);\n\n    uint256 currentPrice = getCurrentPrice(auctionId);\n    // Bidder must bid the correct amount or greater\n    require(msg.value >= currentPrice);\n\n    auctionIdToAcceptingBids[auctionId] = false;\n    transferWinnings(msg.sender, auctionId);\n//SWC-135-Code With No Effects:L245\n    //Check for overbid.\n    uint256 overbidAmount = msg.value.sub(currentPrice);\n    if (overbidAmount > 0) {\n      //Transfer any overbid amount back to the msg sender\n      msg.sender.transfer(overbidAmount);\n    }\n    auctionIdToSeller[auctionId].transfer(currentPrice);\n  }\n\n  function cancel(uint256 auctionId) whenNotPaused public onlySeller(auctionId) {\n    transferWinnings(auctionIdToSeller[auctionId], auctionId);\n    auctionIdToAcceptingBids[auctionId] = false;\n  }\n\n  function getCurrentPrice(uint256 auctionId) public view returns (uint256) {\n    //Only grab information necessary to check for whether we're in the middle of the price descent, before possibly returning priceFloor.\n    uint256 priceFloorBlock = auctionIdToPriceFloorBlock[auctionId];\n    uint256 priceFloor = auctionIdToPriceFloor[auctionId];\n\n    if (block.number >= priceFloorBlock) {\n      return priceFloor;\n    }\n\n    uint256 startBlock = auctionIdToStartBlock[auctionId];\n    uint256 startPrice = auctionIdToStartPrice[auctionId];\n\n    uint256 priceDifference = startPrice.sub(priceFloor);\n    uint256 blockDifference = priceFloorBlock.sub(startBlock);\n\n    uint256 numberOfBlocksElapsed = block.number.sub(startBlock);\n\n    uint256 priceDecrease = numberOfBlocksElapsed.mul(priceDifference.div(blockDifference));\n\n    return startPrice.sub(priceDecrease);\n  }\n\n  /**\n   * @notice Stores the requisite pricing information for a descending price auction.\n     Takes a 2% cut of the start price\n   */\n  function setAuctionPricing(uint256 startPrice, uint256 priceFloor, uint256 duration, uint256 auctionId) requiresFee(startPrice.div(50)) internal {\n    require(startPrice > 0 && priceFloor < startPrice && priceFloor >= 0 && duration > 0);\n\n    /*TODO: These mappings might be a good case for struct packing (auction info), from both a readability/optimization standpoint;\n            i.e. CryptoKitty source uses uint128 to rep money. A uint128 could be used to represent something like 10^33 ETH, which seems like more than enough.*/\n    auctionIdToStartBlock[auctionId] = block.number;\n    auctionIdToStartPrice[auctionId] = startPrice;\n    auctionIdToPriceFloor[auctionId] = priceFloor;\n    auctionIdToPriceFloorBlock[auctionId] = block.number.add(duration);\n    auctionIdToAcceptingBids[auctionId] = true;\n  }\n}\n\n// File: contracts/AuctionComponents/Whitelistable.sol\ncontract Whitelistable is Ownable {\n  mapping(address => bool) public whitelist;\n\n  event AddToWhitelist(address _address);\n  event RemoveFromWhitelist(address _address);\n\n  modifier isWhitelisted(address _addr) {\n    require(inWhitelist(_addr));\n    _;\n  }\n\n  /**\n   * @notice Checks the whitelist for a given address.\n   *\n   * @param _address The address to check against the whitelist.\n   * @return The list of whitelisted addresses.\n   */\n  function inWhitelist(address _address) public view returns (bool) {\n    return whitelist[_address];\n  }\n\n  /**\n   * @notice Adds an address to the whitelist.\n   *\n   * @param _address The address to whitelist.\n   * @return True on success, false on failure.\n   */\n  function addToWhitelist(address _address) public onlyOwner returns (bool) {\n    if (whitelist[_address]) {\n      // Already in the mapping\n      return false;\n    }\n\n    whitelist[_address] = true;\n    emit AddToWhitelist(_address);\n    return true;\n  }\n\n  /**\n   * @dev Removes an address from the whitelist.\n   *\n   * @param _address The addres to remove from the whitelist.\n   * @return True on success, false on failure.\n   */\n  function removeFromWhitelist(address _address) public onlyOwner returns (bool) {\n    if (!whitelist[_address]) {\n      // Not currently in the mapping\n      return false;\n    }\n\n    whitelist[_address] = false;\n    emit RemoveFromWhitelist(_address);\n    return true;\n  }\n}\n\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol\n/**\n * @title ERC20Basic\n * @dev Simpler version of ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/179\n */\ncontract ERC20Basic {\n  function totalSupply() public view returns (uint256);\n  function balanceOf(address who) public view returns (uint256);\n  function transfer(address to, uint256 value) public returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract ERC20 is ERC20Basic {\n  function allowance(address owner, address spender) public view returns (uint256);\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\n  function approve(address spender, uint256 value) public returns (bool);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n// File: contracts/AuctionComponents/ERC20Auction.sol\n/**\n * @title ERC20Auction\n *\n * @author The AUX Team\n * @notice Contract for an auction for a lot of ERC20 tokens - one bidder take all.\n */\ncontract ERC20Auction is AuctionBase, Whitelistable {\n  mapping(uint256 => address) public auctionIdToERC20Address;\n  mapping(uint256 => uint256) public auctionIdToAmount;\n\n  /**\n  * @notice Stores the given information for an auction for the given tokens, then attempts to transfer the tokens from the auction seller to this contract to start the auction.\n  */\n  function setAuctionAsset(address tokenAddress, uint256 tokenAmount, uint256 auctionId) isWhitelisted(tokenAddress) internal {\n    //NOTE: auctionId check requirement might not be necessary.\n    require(tokenAmount > 0 && auctionId != 0);\n    auctionIdToERC20Address[auctionId] = tokenAddress;\n    auctionIdToAmount[auctionId] = tokenAmount;\n    escrowERC20Tokens(msg.sender, tokenAddress, tokenAmount);\n  }\n\n  function transferWinnings(address recipient, uint256 auctionId) internal {\n    require(auctionId != 0);\n    require(auctionHasAssets(auctionId));\n    ERC20 erc20Contract = ERC20(auctionIdToERC20Address[auctionId]);\n    /*NOTE: Error should be thrown by transfer if unapproved, this require is unnecessary gas.\n    require(token.getApproved(kittyId) == address(this));*/\n    uint256 tokenAmount = auctionIdToAmount[auctionId];\n    auctionIdToAmount[auctionId] = 0;\n    erc20Contract.transfer(recipient, tokenAmount);\n  }\n\n  /**\n   * @dev Transfers tokens from an auction seller to the auction contract. This requires the auction to have been approved for taking control of the ERC20 tokens.\n   */\n  function escrowERC20Tokens(address auctionSeller, address tokenAddress, uint256 tokenAmount) private {\n    ERC20 erc20Contract = ERC20(tokenAddress);\n    /*NOTE: Error should be thrown by transferFrom if unapproved, this require is unnecessary gas.\n    require(token.getApproved(kittyId) == address(this));*/\n    erc20Contract.transferFrom(auctionSeller, this, tokenAmount);\n  }\n\n  function auctionHasAssets(uint256 auctionId) private view returns (bool) {\n    return (auctionIdToAmount[auctionId] != 0);\n  }\n}\n\n// File: contracts/Auctions/DescendingPriceERC20Auction.sol\n/**\n * @title AscendingPriceERC20Auction\n *\n * @author The AUX Team\n * @notice Contract for a descending price (Dutch) auction of an ERC20 token.\n */\ncontract DescendingPriceERC20Auction is DescendingPriceAuction, ERC20Auction {\n\n  /*TODO: Account for entry via ERC223 payment fallback function with data (ERC827 should work out of the box)\n\n  We should implement:\n    function tokenFallback(address _from, uint _value, bytes _data) { ... }\n\n  So that our Web3 interface can create an auction with one Web3 step by calling:\n    function transfer(address _to, uint _value, bytes _data) returns (bool)\n  */\n\n  /**\n  * @notice Creates and starts an auction with the given pricing and asset information.\n  * @dev Composes the setup for the DescendingPriceAuction, ERC20Auction and AuctionBase.\n  */\n  function createAuction(\n    uint256 startPrice,\n    uint256 priceFloor,\n    uint256 duration,\n    address tokenAddress,\n    uint256 tokenAmount) whenNotPaused public payable returns (uint256)\n  {\n    uint256 auctionId = createEmptyAuction();\n    setAuctionPricing(startPrice, priceFloor, duration, auctionId);\n    setAuctionAsset(tokenAddress, tokenAmount, auctionId);\n    return auctionId;\n  }\n}\n",
        "function": null,
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/New_Alchemy_Security_Audit-AUX Platform Security Audit/auction-contracts-0da231969b7f791cb1c131956b3f8886f860617b/DescendingPriceERC20Auction.sol",
        "vulnerability": "TODTransfer",
        "check": "TP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity ^0.4.23;\npragma solidity ^0.4.11;\n\n\n// File: contracts/CryptoKitty/CKERC721.sol\n/* solium-disable */\n//NOTE: Intentional, older version of Solidity to keep in line with deployed CK contracts.\n\n\ncontract CKERC721 {\n    // Required methods\n    function totalSupply() public view returns (uint256 total);\n    function balanceOf(address _owner) public view returns (uint256 balance);\n    function ownerOf(uint256 _tokenId) external view returns (address owner);\n    function approve(address _to, uint256 _tokenId) external;\n    function transfer(address _to, uint256 _tokenId) external;\n    function transferFrom(address _from, address _to, uint256 _tokenId) external;\n\n    // Events\n    event Transfer(address from, address to, uint256 tokenId);\n    event Approval(address owner, address approved, uint256 tokenId);\n\n    // Optional\n    // function name() public view returns (string name);\n    // function symbol() public view returns (string symbol);\n    // function tokensOfOwner(address _owner) external view returns (uint256[] tokenIds);\n    // function tokenMetadata(uint256 _tokenId, string _preferredTransport) public view returns (string infoUrl);\n\n    // ERC-165 Compatibility (https://github.com/ethereum/EIPs/issues/165)\n    function supportsInterface(bytes4 _interfaceID) external view returns (bool);\n}\n\n// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n  address public owner;\n\n\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n\n  /**\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n   * account.\n   */\n  function Ownable() public {\n    owner = msg.sender;\n  }\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n   */\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n\n  /**\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n   * @param newOwner The address to transfer ownership to.\n   */\n  function transferOwnership(address newOwner) public onlyOwner {\n    require(newOwner != address(0));\n    emit OwnershipTransferred(owner, newOwner);\n    owner = newOwner;\n  }\n\n}\n\n// File: openzeppelin-solidity/contracts/lifecycle/Pausable.sol\n/**\n * @title Pausable\n * @dev Base contract which allows children to implement an emergency stop mechanism.\n */\ncontract Pausable is Ownable {\n  event Pause();\n  event Unpause();\n\n  bool public paused = false;\n\n\n  /**\n   * @dev Modifier to make a function callable only when the contract is not paused.\n   */\n  modifier whenNotPaused() {\n    require(!paused);\n    _;\n  }\n\n  /**\n   * @dev Modifier to make a function callable only when the contract is paused.\n   */\n  modifier whenPaused() {\n    require(paused);\n    _;\n  }\n\n  /**\n   * @dev called by the owner to pause, triggers stopped state\n   */\n  function pause() onlyOwner whenNotPaused public {\n    paused = true;\n    emit Pause();\n  }\n\n  /**\n   * @dev called by the owner to unpause, returns to normal state\n   */\n  function unpause() onlyOwner whenPaused public {\n    paused = false;\n    emit Unpause();\n  }\n}\n\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, throws on overflow.\n  */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    if (a == 0) {\n      return 0;\n    }\n    c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers, truncating the quotient.\n  */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    // uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return a / b;\n  }\n\n  /**\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  /**\n  * @dev Adds two numbers, throws on overflow.\n  */\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n\n// File: contracts/AuctionComponents/AuctionBase.sol\n/**\n * @title AuctionBase\n *\n * @author The AUX Team\n * @notice Base contract for single contract auctions. Assumes a single seller per auction.\n *\n */\ncontract AuctionBase is Pausable {\n  using SafeMath for uint256;\n\n  mapping(uint256 => address) public auctionIdToSeller;\n\n  //Start at 1 to avoid use of 0 which should be reserved for a 'null' auction value;\n  uint256 public nextAuctionId = 1;\n\n  /**\n   * @dev Throws if called by any account other than the seller for a given auction.\n   */\n  modifier onlySeller(uint256 auctionId) {\n    require(msg.sender == auctionIdToSeller[auctionId]);\n    _;\n  }\n\n  event AuctionCreated(address indexed createdBy, uint256 indexed auctionId);\n\n  /**\n   * @notice Creates an auction with an ID equivalent ot the value of nextAuctionId, then puts the caller's address in the auctionIdToSeller mapping.\n   */\n  function createEmptyAuction() internal returns (uint256) {\n    uint256 thisAuctionId = nextAuctionId;\n    nextAuctionId = nextAuctionId.add(1);\n\n    auctionIdToSeller[thisAuctionId] = msg.sender;\n\n    emit AuctionCreated(msg.sender, thisAuctionId);\n    return thisAuctionId;\n  }\n\n  function transferWinnings(address recipient, uint256 auctionId) internal;\n}\n\n// File: contracts/AuctionComponents/CryptoKittyAuction.sol\n/**\n * @title CryptoKittyAuction\n *\n * @author The AUX Team\n * @notice Contract for an auction of a CryptoKitty.\n */\ncontract CryptoKittyAuction is AuctionBase {\n  using SafeMath for uint256;\n\n  //Reverse mapping to find auctions based on cats, also acts as a source of truth for whether the cat is still in auction or not.\n  mapping(uint256 => uint256) public kittyIdToAuctionId;\n\n  mapping(uint256 => uint256) public auctionIdToKittyId;\n\n  address public cryptoKittyAddress;\n\n  constructor(address _cryptoKittyAddress) public {\n    cryptoKittyAddress = _cryptoKittyAddress;\n  }\n\n  function setAuctionAsset(uint256 kittyId, uint256 auctionId) internal {\n    require(auctionId != 0);\n    //Make sure there isn't an existing auction for this asset.\n    require(kittyIdToAuctionId[kittyId] == 0);\n\n    auctionIdToKittyId[auctionId] = kittyId;\n\n    kittyIdToAuctionId[kittyId] = auctionId;\n\n    escrowKitty(msg.sender, kittyId);\n  }\n\n  function transferWinnings(address recipient, uint256 auctionId) internal {\n    require(auctionId != 0);\n    require(auctionHasKitty(auctionId));\n    CKERC721 catContract = CKERC721(cryptoKittyAddress);\n    /*NOTE: Error should be thrown by transfer if unapproved, this require is unnecessary gas.\n    require(token.getApproved(kittyId) == address(this));*/\n    uint256 kittyId = auctionIdToKittyId[auctionId];\n    kittyIdToAuctionId[kittyId] = 0;\n    catContract.transfer(recipient, kittyId);\n  }\n\n  /**\n   * @dev Transfers cat from an auction seller to the auction contract. This requires the auction to have been approved for taking control of the cat.\n   */\n  function escrowKitty(address seller, uint256 kittyId) private {\n    CKERC721 catContract = CKERC721(cryptoKittyAddress);\n    /*NOTE: Error should be thrown by transferFrom if unapproved.\n    require(token.getApproved(kittyId) == address(this));*/\n    catContract.transferFrom(seller, this, kittyId);\n  }\n\n  function auctionHasKitty(uint256 auctionId) private view returns (bool) {\n    uint256 kittyId = auctionIdToKittyId[auctionId];\n\n    //An auctionId of 0 represents a non-existent auction, which means the kitty isn't in any auction managed by this contract.\n    uint256 auctionThatCurrentlyOwnsKitty = kittyIdToAuctionId[kittyId];\n\n    return(auctionThatCurrentlyOwnsKitty == auctionId);\n  }\n}\n\n// File: contracts/AuctionComponents/FeeCollector.sol\n/**\n * @title FeeCollector\n *\n * @author The AUX Team\n * @notice Adds modifiers for requiring fees on function calls\n *\n */\ncontract FeeCollector is Ownable {\n  using SafeMath for uint256;\n  uint256 feeBalance = 0;\n  /**\n   * @dev Throws if called by any account other than the seller for a given auction.\n   */\n  modifier requiresFee(uint256 feeAmount) {\n    require(msg.value >= feeAmount);\n    feeBalance = feeBalance.add(feeAmount);\n    msg.sender.transfer(msg.value.sub(feeAmount));\n    _;\n  }\n\n  event FeesWithdrawn(address indexed owner, uint256 indexed withdrawalAmount);\n\n  function withdrawFees() external onlyOwner {\n    uint256 feeAmountWithdrawn = feeBalance;\n    feeBalance = 0;\n    owner.transfer(feeAmountWithdrawn);\n    emit FeesWithdrawn(owner, feeAmountWithdrawn);\n  }\n}\n\n// File: contracts/AuctionComponents/DescendingPriceAuction.sol\n/**\n * @title DescendingPriceAuction\n *\n * @author The AUX Team\n * @notice Contract for a single contract \"Descending Price\" auction.\n */\ncontract DescendingPriceAuction is AuctionBase, FeeCollector {\n  using SafeMath for uint256;\n\n  mapping(uint256 => uint256) public auctionIdToStartPrice;\n  mapping(uint256 => uint256) public auctionIdToPriceFloor;\n  mapping(uint256 => uint256) public auctionIdToStartBlock;\n  mapping(uint256 => uint256) public auctionIdToPriceFloorBlock;\n  mapping(uint256 => bool) public auctionIdToAcceptingBids;\n\n  modifier onlyAcceptingBids(uint256 auctionId) {\n    require(auctionIdToAcceptingBids[auctionId]);\n    _;\n  }\n\n  /**\n   * @notice Should immediately end the auction by transferring the winnings to the bidder, as long as the bid is valid.\n   */\n  function bid(uint256 auctionId) whenNotPaused onlyAcceptingBids(auctionId) whenNotPaused external payable {\n    // Bidder must exist\n    require(msg.sender != 0x0);\n//SWC-135-Code With No Effects:L344\n    uint256 currentPrice = getCurrentPrice(auctionId);\n    // Bidder must bid the correct amount or greater\n    require(msg.value >= currentPrice);\n\n    auctionIdToAcceptingBids[auctionId] = false;\n    transferWinnings(msg.sender, auctionId);\n\n    //Check for overbid.\n    uint256 overbidAmount = msg.value.sub(currentPrice);\n    if (overbidAmount > 0) {\n      //Transfer any overbid amount back to the msg sender\n      msg.sender.transfer(overbidAmount);\n    }\n    auctionIdToSeller[auctionId].transfer(currentPrice);\n  }\n\n  function cancel(uint256 auctionId) whenNotPaused public onlySeller(auctionId) {\n    transferWinnings(auctionIdToSeller[auctionId], auctionId);\n    auctionIdToAcceptingBids[auctionId] = false;\n  }\n\n  function getCurrentPrice(uint256 auctionId) public view returns (uint256) {\n    //Only grab information necessary to check for whether we're in the middle of the price descent, before possibly returning priceFloor.\n    uint256 priceFloorBlock = auctionIdToPriceFloorBlock[auctionId];\n    uint256 priceFloor = auctionIdToPriceFloor[auctionId];\n\n    if (block.number >= priceFloorBlock) {\n      return priceFloor;\n    }\n\n    uint256 startBlock = auctionIdToStartBlock[auctionId];\n    uint256 startPrice = auctionIdToStartPrice[auctionId];\n\n    uint256 priceDifference = startPrice.sub(priceFloor);\n    uint256 blockDifference = priceFloorBlock.sub(startBlock);\n\n    uint256 numberOfBlocksElapsed = block.number.sub(startBlock);\n\n    uint256 priceDecrease = numberOfBlocksElapsed.mul(priceDifference.div(blockDifference));\n\n    return startPrice.sub(priceDecrease);\n  }\n\n  /**\n   * @notice Stores the requisite pricing information for a descending price auction.\n     Takes a 2% cut of the start price\n   */\n  function setAuctionPricing(uint256 startPrice, uint256 priceFloor, uint256 duration, uint256 auctionId) requiresFee(startPrice.div(50)) internal {\n    require(startPrice > 0 && priceFloor < startPrice && priceFloor >= 0 && duration > 0);\n\n    /*TODO: These mappings might be a good case for struct packing (auction info), from both a readability/optimization standpoint;\n            i.e. CryptoKitty source uses uint128 to rep money. A uint128 could be used to represent something like 10^33 ETH, which seems like more than enough.*/\n    auctionIdToStartBlock[auctionId] = block.number;\n    auctionIdToStartPrice[auctionId] = startPrice;\n    auctionIdToPriceFloor[auctionId] = priceFloor;\n    auctionIdToPriceFloorBlock[auctionId] = block.number.add(duration);\n    auctionIdToAcceptingBids[auctionId] = true;\n  }\n}\n\n// File: contracts/Auctions/DescendingPriceCryptoKittyAuction.sol\n/**\n * @title DescendingPriceCryptoKittyAuction\n *\n * @author The AUX Team\n * @notice Contract for a descending price (Dutch) auction of a CryptoKitty token.\n */\ncontract DescendingPriceCryptoKittyAuction is DescendingPriceAuction, CryptoKittyAuction {\n  constructor(address _cryptoKittyAddress) CryptoKittyAuction(_cryptoKittyAddress) public { }\n\n  /**\n  * @notice Creates and starts an auction with the given pricing and asset information.\n  * @dev Composes the setup for the DescendingPriceAuction, CryptoKittyAuction and AuctionBase.\n  */\n  function createAuction(uint256 startPrice, uint256 priceFloor, uint256 duration, uint256 kittyId) whenNotPaused public payable returns (uint256) {\n    uint256 auctionId = createEmptyAuction();\n    setAuctionPricing(startPrice, priceFloor, duration, auctionId);\n    setAuctionAsset(kittyId, auctionId);\n    return auctionId;\n  }\n}\n",
        "function": null,
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/New_Alchemy_Security_Audit-AUX Platform Security Audit/auction-contracts-0da231969b7f791cb1c131956b3f8886f860617b/DescendingPriceCryptoKitty.sol",
        "vulnerability": "DAOConstantGas",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity 0.4.24;\n\n\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n    address public owner;\n    address public pendingOwner;\n    address public manager;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    // SWC-129-Typographical Error: L17\n    event ManagerUpdated(address newManager);\n\n   /**\n   * @dev Throws if called by any account other than the owner.\n   */\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    /**\n     * @dev Modifier throws if called by any account other than the manager.\n     */\n    modifier onlyManager() {\n        require(msg.sender == manager);\n        _;\n    }\n\n    /**\n    * @dev Modifier throws if called by any account other than the pendingOwner.\n    */\n    modifier onlyPendingOwner() {\n        require(msg.sender == pendingOwner);\n        _;\n    }\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    /**\n    * @dev Allows the current owner to set the pendingOwner address.\n    * @param newOwner The address to transfer ownership to.\n    */\n    function transferOwnership(address newOwner) public onlyOwner {\n        pendingOwner = newOwner;\n    }\n\n    /**\n    * @dev Allows the pendingOwner address to finalize the transfer.\n    */\n    function claimOwnership() public onlyPendingOwner {\n        emit OwnershipTransferred(owner, pendingOwner);\n        owner = pendingOwner;\n        pendingOwner = address(0);\n    }\n\n    /**\n    * @dev Sets the manager address.\n    * @param _manager The manager address.\n    */\n    function setManager(address _manager) public onlyOwner {\n        require(_manager != address(0));\n        manager = _manager;\n        // SWC-129-Typographical Error: L72\n        emit ManagerUpdated(manager);\n    }\n\n}\n\n/**\n * @title Whitelist\n * @dev The Whitelist contract has a whitelist of addresses, and provides basic authorization control functions.\n * @dev This simplifies the implementation of \"user permissions\".\n */\ncontract Whitelist is Ownable {\n    mapping(address => bool) public whitelist;\n\n    event WhitelistedAddressAdded(address addr);\n    event WhitelistedAddressRemoved(address addr);\n\n    /**\n     * @dev Throws if called by any account that's not whitelisted.\n     */\n    modifier onlyWhitelisted() {\n        require(whitelist[msg.sender]);\n        _;\n    }\n\n    /**\n     * @dev add an address to the whitelist\n     * @param addr address\n     * @return true if the address was added to the whitelist, false if the address was already in the whitelist\n     */\n    function addAddressToWhitelist(address addr) public onlyOwner returns(bool success) {\n        if (!whitelist[addr]) {\n            whitelist[addr] = true;\n            emit WhitelistedAddressAdded(addr);\n            success = true;\n        }\n    }\n\n    /**\n     * @dev add addresses to the whitelist\n     * @param addrs addresses\n     * @return true if at least one address was added to the whitelist,\n     * false if all addresses were already in the whitelist\n     */\n    function addAddressesToWhitelist(address[] addrs) public onlyOwner returns(bool success) {\n        for (uint256 i = 0; i < addrs.length; i++) {\n            if (addAddressToWhitelist(addrs[i])) {\n                success = true;\n            }\n        }\n    }\n\n    /**\n     * @dev remove an address from the whitelist\n     * @param addr address\n     * @return true if the address was removed from the whitelist,\n     * false if the address wasn't in the whitelist in the first place\n     */\n    function removeAddressFromWhitelist(address addr) public onlyOwner returns(bool success) {\n        if (whitelist[addr]) {\n            whitelist[addr] = false;\n            emit WhitelistedAddressRemoved(addr);\n            success = true;\n        }\n    }\n\n    /**\n     * @dev remove addresses from the whitelist\n     * @param addrs addresses\n     * @return true if at least one address was removed from the whitelist,\n     * false if all addresses weren't in the whitelist in the first place\n     */\n    function removeAddressesFromWhitelist(address[] addrs) public onlyOwner returns(bool success) {\n        for (uint256 i = 0; i < addrs.length; i++) {\n            if (removeAddressFromWhitelist(addrs[i])) {\n                success = true;\n            }\n        }\n    }\n\n}\n\n/**\n * @title Pausable\n * @dev Base contract which allows children to implement an emergency stop mechanism.\n */\ncontract Pausable is Whitelist {\n    event Pause();\n    event Unpause();\n\n    bool public paused = false;\n\n  /**\n   * @dev Modifier to make a function callable only when the contract is not paused.\n   */\n    modifier whenNotPaused() {\n        require((!paused) || (whitelist[msg.sender]));\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     */\n    modifier whenPaused() {\n        require(paused);\n        _;\n    }\n\n    /**\n     * @dev called by the owner to pause, triggers stopped state\n     */\n    function pause() public onlyOwner whenNotPaused {\n        paused = true;\n        emit Pause();\n    }\n\n    /**\n     * @dev called by the owner to unpause, returns to normal state\n     */\n    function unpause() public onlyOwner whenPaused {\n        paused = false;\n        emit Unpause();\n    }\n}\n\n/**\n * @title ERC20Basic\n * @dev Simpler version of ERC20 interface\n * See https://github.com/ethereum/EIPs/issues/179\n */\ncontract ERC20Basic {\n    function totalSupply() public view returns (uint256);\n    function balanceOf(address who) public view returns (uint256);\n    function transfer(address to, uint256 value) public returns (bool);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract ERC20 is ERC20Basic {\n    function allowance(address owner, address spender)\n        public view returns (uint256);\n\n    function transferFrom(address from, address to, uint256 value)\n        public returns (bool);\n\n    function approve(address spender, uint256 value) public returns (bool);\n\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n}\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n\n    /**\n    * @dev Multiplies two numbers, throws on overflow.\n    */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n        // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        c = a * b;\n        assert(c / a == b);\n        return c;\n    }\n\n    /**\n    * @dev Integer division of two numbers, truncating the quotient.\n    */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\n        // uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n        return a / b;\n    }\n\n    /**\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n    */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        assert(b <= a);\n        return a - b;\n    }\n\n    /**\n    * @dev Adds two numbers, throws on overflow.\n    */\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n        c = a + b;\n        assert(c >= a);\n        return c;\n    }\n}\n\n/**\n * @title Basic token\n * @dev Basic version of StandardToken, with no allowances.\n */\ncontract BasicToken is ERC20Basic {\n    using SafeMath for uint256;\n\n    mapping(address => uint256) public balances;\n\n    uint256 public totalSupply_;\n\n    /**\n    * @dev Total number of tokens in existence\n    */\n    function totalSupply() public view returns (uint256) {\n        return totalSupply_;\n    }\n\n    /**\n    * @dev Transfer token for a specified address\n    * @param _to The address to transfer to.\n    * @param _value The amount to be transferred.\n    */\n    function transfer(address _to, uint256 _value) public returns (bool) {\n        require(_to != address(0));\n        require(_value <= balances[msg.sender]);\n\n        balances[msg.sender] = balances[msg.sender].sub(_value);\n        balances[_to] = balances[_to].add(_value);\n        emit Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    /**\n    * @dev Gets the balance of the specified address.\n    * @param _owner The address to query the the balance of.\n    * @return An uint256 representing the amount owned by the passed address.\n    */\n    function balanceOf(address _owner) public view returns (uint256) {\n        return balances[_owner];\n    }\n\n}\n\n/**\n * @title Standard ERC20 token\n *\n * @dev Implementation of the basic standard token.\n * https://github.com/ethereum/EIPs/issues/20\n * Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n */\ncontract StandardToken is ERC20, BasicToken {\n\n    mapping (address => mapping (address => uint256)) internal allowed;\n\n    /**\n     * @dev Transfer tokens from one address to another\n     * @param _from address The address which you want to send tokens from\n     * @param _to address The address which you want to transfer to\n     * @param _value uint256 the amount of tokens to be transferred\n     */\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _value\n    )\n        public\n        returns (bool)\n    {\n        require(_to != address(0));\n        require(_value <= balances[_from]);\n        require(_value <= allowed[_from][msg.sender]);\n\n        balances[_from] = balances[_from].sub(_value);\n        balances[_to] = balances[_to].add(_value);\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n        emit Transfer(_from, _to, _value);\n        return true;\n    }\n\n    /**\n    * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n    * Beware that changing an allowance with this method brings the risk that someone may use both the old\n    * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n    * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n    * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n    * @param _spender The address which will spend the funds.\n    * @param _value The amount of tokens to be spent.\n    */\n    function approve(address _spender, uint256 _value) public returns (bool) {\n        allowed[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    /**\n    * @dev Function to check the amount of tokens that an owner allowed to a spender.\n    * @param _owner address The address which owns the funds.\n    * @param _spender address The address which will spend the funds.\n    * @return A uint256 specifying the amount of tokens still available for the spender.\n    */\n    function allowance(\n        address _owner,\n        address _spender\n    )\n        public\n        view\n        returns (uint256)\n    {\n        return allowed[_owner][_spender];\n    }\n\n    /**\n    * @dev Increase the amount of tokens that an owner allowed to a spender.\n    * approve should be called when allowed[_spender] == 0. To increment\n    * allowed value is better to use this function to avoid 2 calls (and wait until\n    * the first transaction is mined)\n    * From MonolithDAO Token.sol\n    * @param _spender The address which will spend the funds.\n    * @param _addedValue The amount of tokens to increase the allowance by.\n    */\n    function increaseApproval(\n        address _spender,\n        uint256 _addedValue\n    )\n        public\n        returns (bool)\n    {\n        allowed[msg.sender][_spender] = (\n        allowed[msg.sender][_spender].add(_addedValue));\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n        return true;\n    }\n\n    /**\n    * @dev Decrease the amount of tokens that an owner allowed to a spender.\n    * approve should be called when allowed[_spender] == 0. To decrement\n    * allowed value is better to use this function to avoid 2 calls (and wait until\n    * the first transaction is mined)\n    * From MonolithDAO Token.sol\n    * @param _spender The address which will spend the funds.\n    * @param _subtractedValue The amount of tokens to decrease the allowance by.\n    */\n    function decreaseApproval(\n        address _spender,\n        uint256 _subtractedValue\n    )\n        public\n        returns (bool)\n    {\n        uint256 oldValue = allowed[msg.sender][_spender];\n        if (_subtractedValue > oldValue) {\n            allowed[msg.sender][_spender] = 0;\n        } else {\n            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n        }\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n        return true;\n    }\n\n}\n\n/**\n * @title Pausable token\n * @dev StandardToken modified with pausable transfers.\n **/\ncontract PausableToken is StandardToken, Pausable {\n\n    function transfer(\n        address _to,\n        uint256 _value\n    )\n        public\n        whenNotPaused\n        returns (bool)\n    {\n        return super.transfer(_to, _value);\n    }\n\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _value\n    )\n        public\n        whenNotPaused\n        returns (bool)\n    {\n        return super.transferFrom(_from, _to, _value);\n    }\n\n    function approve(\n        address _spender,\n        uint256 _value\n    )\n        public\n        whenNotPaused\n        returns (bool)\n    {\n        return super.approve(_spender, _value);\n    }\n\n    function increaseApproval(\n        address _spender,\n        uint256 _addedValue\n    )\n        public\n        whenNotPaused\n        returns (bool success)\n    {\n        return super.increaseApproval(_spender, _addedValue);\n    }\n\n    function decreaseApproval(\n        address _spender,\n        uint256 _subtractedValue\n    )\n        public\n        whenNotPaused\n        returns (bool success)\n    {\n        return super.decreaseApproval(_spender, _subtractedValue);\n    }\n}\n\n/**\n * @title Mintable token\n * @dev Simple ERC20 Token example, with mintable token creation\n * Based on code by TokenMarketNet: https://github.com/TokenMarketNet/ico/blob/master/contracts/MintableToken.sol\n */\ncontract MintableToken is PausableToken {\n    event Mint(address indexed to, uint256 amount);\n    event MintFinished();\n\n    bool public mintingFinished = false;\n\n    modifier canMint() {\n        require(!mintingFinished);\n        _;\n    }\n\n    /**\n     * @dev Function to mint tokens\n     * @param _to The address that will receive the minted tokens.\n     * @param _amount The amount of tokens to mint.\n     * @return A boolean that indicates if the operation was successful.\n     */\n    function mint(\n        address _to,\n        uint256 _amount\n    )\n        public\n        onlyManager\n        canMint\n        returns (bool)\n    {\n        totalSupply_ = totalSupply_.add(_amount);\n        balances[_to] = balances[_to].add(_amount);\n        emit Mint(_to, _amount);\n        emit Transfer(address(0), _to, _amount);\n        return true;\n    }\n\n  /**\n   * @dev Function to stop minting new tokens.\n   * @return True if the operation was successful.\n   */\n    function finishMinting() public onlyOwner canMint  returns (bool) {\n        mintingFinished = true;\n        emit MintFinished();\n        return true;\n    }\n}\n\n/**\n * @title SimpleToken\n * @dev Very simple ERC20 Token example, where all tokens are pre-assigned to the creator.\n * Note they can later distribute these tokens as they wish using `transfer` and other\n * `StandardToken` functions.\n */\ncontract BeamToken is MintableToken {\n\n    string public constant name = \"Beams\"; // solium-disable-line uppercase\n    string public constant symbol = \"BEAM\"; // solBeamCrowdsaleContractium-disable-line uppercase\n    uint8 public constant decimals = 18; // solium-disable-line uppercase\n\n    mapping (address => bool) public isLocked;\n\n    uint256 public constant INITIAL_SUPPLY = 0;\n\n    constructor() public {\n        totalSupply_ = INITIAL_SUPPLY;\n    }\n\n    function setLock(address _who, bool _lock) public onlyOwner {\n        require(isLocked[_who] != _lock);\n        isLocked[_who] = _lock;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the caller is not in locklist.\n     */\n    modifier whenNotLocked() {\n        require(!isLocked[msg.sender]);\n        _;\n    }\n\n    function transfer(\n        address _to,\n        uint256 _value\n    )\n        public\n        whenNotLocked\n        returns (bool)\n    {\n        return super.transfer(_to, _value);\n    }\n\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _value\n    )\n        public\n        whenNotLocked\n        returns (bool)\n    {\n        return super.transferFrom(_from, _to, _value);\n    }\n\n    function approve(\n        address _spender,\n        uint256 _value\n    )\n        public\n        whenNotLocked\n        returns (bool)\n    {\n        return super.approve(_spender, _value);\n    }\n\n    function increaseApproval(\n        address _spender,\n        uint256 _addedValue\n    )\n        public\n        whenNotLocked\n        returns (bool success)\n    {\n        return super.increaseApproval(_spender, _addedValue);\n    }\n\n    function decreaseApproval(\n        address _spender,\n        uint256 _subtractedValue\n    )\n        public\n        whenNotLocked\n        returns (bool success)\n    {\n        return super.decreaseApproval(_spender, _subtractedValue);\n    }\n}\n",
        "function": null,
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Blockchain Labs NZ-Beam/beam-11b086ca757f1612cd67c1bf6d7ab470591676b1/contracts/BeamToken.sol",
        "vulnerability": "MissingInputValidation",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity ^0.4.21;\n\n\n/**\n * @title ICrowdsaleFund\n * @dev Fund methods used by crowdsale contract\n */\ninterface ICrowdsaleFund {\n    /**\n    * @dev Function accepts user`s contributed ether and logs contribution\n    * @param contributor Contributor wallet address.\n    */\n    function processContribution(address contributor) external payable;\n    /**\n    * @dev Function is called on the end of successful crowdsale\n    */\n    function onCrowdsaleEnd() external;\n    /**\n    * @dev Function is called if crowdsale failed to reach soft cap\n    */\n    function enableCrowdsaleRefund() external;\n}\n\n/**\n * @title ICrowdsaleReservationFund\n * @dev ReservationFund methods used by crowdsale contract\n */\ninterface ICrowdsaleReservationFund {\n    /**\n     * @dev Check if contributor has transactions\n     */\n    function canCompleteContribution(address contributor) external returns(bool);\n    /**\n     * @dev Complete contribution\n     * @param contributor Contributor`s address\n     */\n    function completeContribution(address contributor) external;\n    /**\n     * @dev Function accepts user`s contributed ether and amount of tokens to issue\n     * @param contributor Contributor wallet address.\n     * @param _tokensToIssue Token amount to issue\n     * @param _bonusTokensToIssue Bonus token amount to issue\n     */\n    function processContribution(address contributor, uint256 _tokensToIssue, uint256 _bonusTokensToIssue) external payable;\n\n    /**\n     * @dev Function returns current user`s contributed ether amount\n     */\n    function contributionsOf(address contributor) external returns(uint256);\n\n    /**\n     * @dev Function is called on the end of successful crowdsale\n     */\n    function onCrowdsaleEnd() external;\n}\n\n/**\n * @title IERC20Token - ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract IERC20Token {\n    string public name;\n    string public symbol;\n    uint8 public decimals;\n    uint256 public totalSupply;\n\n    function balanceOf(address _owner) public constant returns (uint256 balance);\n    function transfer(address _to, uint256 _value)  public returns (bool success);\n    function transferFrom(address _from, address _to, uint256 _value)  public returns (bool success);\n    function approve(address _spender, uint256 _value)  public returns (bool success);\n    function allowance(address _owner, address _spender)  public constant returns (uint256 remaining);\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\n\n/**\n * @title MultiOwnable\n * @dev The MultiOwnable contract has owners addresses and provides basic authorization control\n * functions, this simplifies the implementation of \"users permissions\".\n */\ncontract MultiOwnable {\n    address public manager; // address used to set owners\n    address[] public owners;\n    mapping(address => bool) public ownerByAddress;\n\n    event SetOwners(address[] owners);\n\n    modifier onlyOwner() {\n        require(ownerByAddress[msg.sender] == true);\n        _;\n    }\n\n    /**\n     * @dev MultiOwnable constructor sets the manager\n     */\n    function MultiOwnable() public {\n        manager = msg.sender;\n    }\n\n    /**\n     * @dev Function to set owners addresses\n     */\n    function setOwners(address[] _owners) public {\n        require(msg.sender == manager);\n        _setOwners(_owners);\n\n    }\n\n    function _setOwners(address[] _owners) internal {\n        for(uint256 i = 0; i < owners.length; i++) {\n            ownerByAddress[owners[i]] = false;\n        }\n\n\n        for(uint256 j = 0; j < _owners.length; j++) {\n            ownerByAddress[_owners[j]] = true;\n        }\n        owners = _owners;\n        SetOwners(_owners);\n    }\n\n    function getOwners() public constant returns (address[]) {\n        return owners;\n    }\n}\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\ncontract SafeMath {\n    /**\n    * @dev constructor\n    */\n    function SafeMath() public {\n    }\n\n    function safeMul(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a * b;\n        assert(a == 0 || c / a == b);\n        return c;\n    }\n\n    function safeDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a / b;\n        return c;\n    }\n\n    function safeSub(uint256 a, uint256 b) internal pure returns (uint256) {\n        assert(a >= b);\n        return a - b;\n    }\n\n    function safeAdd(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        assert(c >= a);\n        return c;\n    }\n}\n\n/**\n * @title ERC20Token - ERC20 base implementation\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract ERC20Token is IERC20Token, SafeMath {\n    mapping (address => uint256) public balances;\n    mapping (address => mapping (address => uint256)) public allowed;\n\n    function transfer(address _to, uint256 _value) public returns (bool) {\n        require(_to != address(0));\n        require(balances[msg.sender] >= _value);\n\n        balances[msg.sender] = safeSub(balances[msg.sender], _value);\n        balances[_to] = safeAdd(balances[_to], _value);\n        Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n        require(_to != address(0));\n        require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value);\n\n        balances[_to] = safeAdd(balances[_to], _value);\n        balances[_from] = safeSub(balances[_from], _value);\n        allowed[_from][msg.sender] = safeSub(allowed[_from][msg.sender], _value);\n        Transfer(_from, _to, _value);\n        return true;\n    }\n\n    function balanceOf(address _owner) public constant returns (uint256) {\n        return balances[_owner];\n    }\n\n    function approve(address _spender, uint256 _value) public returns (bool) {\n        allowed[msg.sender][_spender] = _value;\n        Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    function allowance(address _owner, address _spender) public constant returns (uint256) {\n      return allowed[_owner][_spender];\n    }\n}\n\n/**\n * @title ITokenEventListener\n * @dev Interface which should be implemented by token listener\n */\ninterface ITokenEventListener {\n    /**\n     * @dev Function is called after token transfer/transferFrom\n     * @param _from Sender address\n     * @param _to Receiver address\n     * @param _value Amount of tokens\n     */\n    function onTokenTransfer(address _from, address _to, uint256 _value) public;\n}\n\n/**\n * @title ManagedToken\n * @dev ERC20 compatible token with issue and destroy facilities\n * @dev All transfers can be monitored by token event listener\n */\ncontract ManagedToken is ERC20Token, MultiOwnable {\n    bool public allowTransfers = false;\n    bool public issuanceFinished = false;\n\n    ITokenEventListener public eventListener;\n\n    event AllowTransfersChanged(bool _newState);\n    event Issue(address indexed _to, uint256 _value);\n    event Destroy(address indexed _from, uint256 _value);\n    event IssuanceFinished();\n\n    modifier transfersAllowed() {\n        require(allowTransfers);\n        _;\n    }\n\n    modifier canIssue() {\n        require(!issuanceFinished);\n        _;\n    }\n\n    /**\n     * @dev ManagedToken constructor\n     * @param _listener Token listener(address can be 0x0)\n     * @param _owners Owners list\n     */\n    function ManagedToken(address _listener, address[] _owners) public {\n        if(_listener != address(0)) {\n            eventListener = ITokenEventListener(_listener);\n        }\n        _setOwners(_owners);\n    }\n\n    /**\n     * @dev Enable/disable token transfers. Can be called only by owners\n     * @param _allowTransfers True - allow False - disable\n     */\n    function setAllowTransfers(bool _allowTransfers) external onlyOwner {\n        allowTransfers = _allowTransfers;\n        AllowTransfersChanged(_allowTransfers);\n    }\n\n    /**\n     * @dev Set/remove token event listener\n     * @param _listener Listener address (Contract must implement ITokenEventListener interface)\n     */\n    function setListener(address _listener) public onlyOwner {\n        if(_listener != address(0)) {\n            eventListener = ITokenEventListener(_listener);\n        } else {\n            delete eventListener;\n        }\n    }\n\n    function transfer(address _to, uint256 _value) public transfersAllowed returns (bool) {\n        bool success = super.transfer(_to, _value);\n        if(hasListener() && success) {\n            eventListener.onTokenTransfer(msg.sender, _to, _value);\n        }\n        return success;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) public transfersAllowed returns (bool) {\n        bool success = super.transferFrom(_from, _to, _value);\n        if(hasListener() && success) {\n            eventListener.onTokenTransfer(_from, _to, _value);\n        }\n        return success;\n    }\n\n    function hasListener() internal view returns(bool) {\n        if(eventListener == address(0)) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * @dev Issue tokens to specified wallet\n     * @param _to Wallet address\n     * @param _value Amount of tokens\n     */\n    function issue(address _to, uint256 _value) external onlyOwner canIssue {\n        totalSupply = safeAdd(totalSupply, _value);\n        balances[_to] = safeAdd(balances[_to], _value);\n        Issue(_to, _value);\n        Transfer(address(0), _to, _value);\n    }\n\n    /**\n     * @dev Destroy tokens on specified address (Called by owner or token holder)\n     * @dev Fund contract address must be in the list of owners to burn token during refund\n     * @param _from Wallet address\n     * @param _value Amount of tokens to destroy\n     */\n    function destroy(address _from, uint256 _value) external {\n        require(ownerByAddress[msg.sender] || msg.sender == _from);\n        require(balances[_from] >= _value);\n        totalSupply = safeSub(totalSupply, _value);\n        balances[_from] = safeSub(balances[_from], _value);\n        Transfer(_from, address(0), _value);\n        Destroy(_from, _value);\n    }\n\n    /**\n     * @dev Increase the amount of tokens that an owner allowed to a spender.\n     *\n     * approve should be called when allowed[_spender] == 0. To increment\n     * allowed value is better to use this function to avoid 2 calls (and wait until\n     * the first transaction is mined)\n     * From OpenZeppelin StandardToken.sol\n     * @param _spender The address which will spend the funds.\n     * @param _addedValue The amount of tokens to increase the allowance by.\n     */\n    function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n        allowed[msg.sender][_spender] = safeAdd(allowed[msg.sender][_spender], _addedValue);\n        Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n        return true;\n    }\n\n    /**\n     * @dev Decrease the amount of tokens that an owner allowed to a spender.\n     *\n     * approve should be called when allowed[_spender] == 0. To decrement\n     * allowed value is better to use this function to avoid 2 calls (and wait until\n     * the first transaction is mined)\n     * From OpenZeppelin StandardToken.sol\n     * @param _spender The address which will spend the funds.\n     * @param _subtractedValue The amount of tokens to decrease the allowance by.\n     */\n    function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n        uint oldValue = allowed[msg.sender][_spender];\n        if (_subtractedValue > oldValue) {\n            allowed[msg.sender][_spender] = 0;\n        } else {\n            allowed[msg.sender][_spender] = safeSub(oldValue, _subtractedValue);\n        }\n        Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n        return true;\n    }\n\n    /**\n     * @dev Finish token issuance\n     * @return True if success\n     */\n    function finishIssuance() public onlyOwner returns (bool) {\n        issuanceFinished = true;\n        IssuanceFinished();\n        return true;\n    }\n}\n\n/**\n * @title TransferLimitedToken\n * @dev Token with ability to limit transfers within wallets included in limitedWallets list for certain period of time\n */\ncontract TransferLimitedToken is ManagedToken {\n    uint256 public constant LIMIT_TRANSFERS_PERIOD = 365 days;\n\n    mapping(address => bool) public limitedWallets;\n    uint256 public limitEndDate;\n    address public limitedWalletsManager;\n    bool public isLimitEnabled;\n\n    modifier onlyManager() {\n        require(msg.sender == limitedWalletsManager);\n        _;\n    }\n\n    /**\n     * @dev Check if transfer between addresses is available\n     * @param _from From address\n     * @param _to To address\n     */\n    modifier canTransfer(address _from, address _to)  {\n        require(now >= limitEndDate || !isLimitEnabled || (!limitedWallets[_from] && !limitedWallets[_to]));\n        _;\n    }\n\n    /**\n     * @dev TransferLimitedToken constructor\n     * @param _limitStartDate Limit start date\n     * @param _listener Token listener(address can be 0x0)\n     * @param _owners Owners list\n     * @param _limitedWalletsManager Address used to add/del wallets from limitedWallets\n     */\n    function TransferLimitedToken(\n        uint256 _limitStartDate,\n        address _listener,\n        address[] _owners,\n        address _limitedWalletsManager\n    ) public ManagedToken(_listener, _owners)\n    {\n        limitEndDate = _limitStartDate + LIMIT_TRANSFERS_PERIOD;\n        isLimitEnabled = true;\n        limitedWalletsManager = _limitedWalletsManager;\n    }\n\n    /**\n     * @dev Add address to limitedWallets\n     * @dev Can be called only by manager\n     */\n    function addLimitedWalletAddress(address _wallet) public {\n        require(msg.sender == limitedWalletsManager || ownerByAddress[msg.sender]);\n        limitedWallets[_wallet] = true;\n    }\n\n    /**\n     * @dev Del address from limitedWallets\n     * @dev Can be called only by manager\n     */\n    function delLimitedWalletAddress(address _wallet) public onlyManager {\n        limitedWallets[_wallet] = false;\n    }\n\n    /**\n     * @dev Disable transfer limit manually. Can be called only by manager\n     */\n    function disableLimit() public onlyManager {\n        isLimitEnabled = false;\n    }\n\n    function transfer(address _to, uint256 _value) public canTransfer(msg.sender, _to) returns (bool) {\n        return super.transfer(_to, _value);\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) public canTransfer(_from, _to) returns (bool) {\n        return super.transferFrom(_from, _to, _value);\n    }\n\n    function approve(address _spender, uint256 _value) public canTransfer(msg.sender, _spender) returns (bool) {\n        return super.approve(_spender,_value);\n    }\n}\n\n/**\n * @title LockedTokens\n * @dev Lock tokens for certain period of time\n */\ncontract LockedTokens is SafeMath {\n    struct Tokens {\n        uint256 amount;\n        uint256 lockEndTime;\n        bool released;\n    }\n\n    event TokensUnlocked(address _to, uint256 _value);\n\n    IERC20Token public token;\n    address public crowdsaleAddress;\n    mapping(address => Tokens[]) public walletTokens;\n\n    /**\n     * @dev LockedTokens constructor\n     * @param _token ERC20 compatible token contract\n     * @param _crowdsaleAddress Crowdsale contract address\n     */\n    function LockedTokens(IERC20Token _token, address _crowdsaleAddress) public {\n        token = _token;\n        crowdsaleAddress = _crowdsaleAddress;\n    }\n\n    /**\n     * @dev Functions locks tokens\n     * @param _to Wallet address to transfer tokens after _lockEndTime\n     * @param _amount Amount of tokens to lock\n     * @param _lockEndTime End of lock period\n     */\n    function addTokens(address _to, uint256 _amount, uint256 _lockEndTime) external {\n        require(msg.sender == crowdsaleAddress);\n        walletTokens[_to].push(Tokens({amount: _amount, lockEndTime: _lockEndTime, released: false}));\n    }\n\n    /**\n     * @dev Called by owner of locked tokens to release them\n     */\n    function releaseTokens() public {\n        require(walletTokens[msg.sender].length > 0);\n\n        for(uint256 i = 0; i < walletTokens[msg.sender].length; i++) {\n            if(!walletTokens[msg.sender][i].released && now >= walletTokens[msg.sender][i].lockEndTime) {\n                walletTokens[msg.sender][i].released = true;\n                token.transfer(msg.sender, walletTokens[msg.sender][i].amount);\n                TokensUnlocked(msg.sender, walletTokens[msg.sender][i].amount);\n            }\n        }\n    }\n}\n\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n    address public owner;\n    address public newOwner;\n\n    event OwnershipTransferred(address previousOwner, address newOwner);\n\n    /**\n    * @dev The Ownable constructor sets the original `owner` of the contract.\n    */\n    function Ownable(address _owner) public {\n        owner = _owner == address(0) ? msg.sender : _owner;\n    }\n\n    /**\n    * @dev Throws if called by any account other than the owner.\n    */\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    /**\n    * @dev Allows the current owner to transfer control of the contract to a newOwner.\n    * @param _newOwner The address to transfer ownership to.\n    */\n    function transferOwnership(address _newOwner) public onlyOwner {\n        require(_newOwner != owner);\n        newOwner = _newOwner;\n    }\n\n    /**\n    * @dev confirm ownership by a new owner\n    */\n    function confirmOwnership() public {\n        require(msg.sender == newOwner);\n        OwnershipTransferred(owner, newOwner);\n        owner = newOwner;\n        newOwner = 0x0;\n    }\n}\n\n/**\n * @title Pausable\n * @dev Base contract which allows children to implement an emergency stop mechanism.\n */\ncontract Pausable is Ownable {\n    event Pause();\n    event Unpause();\n\n    bool public paused = false;\n\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     */\n    modifier whenNotPaused() {\n        require(!paused);\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     */\n    modifier whenPaused() {\n        require(paused);\n        _;\n    }\n\n    /**\n     * @dev called by the owner to pause, triggers stopped state\n     */\n    function pause() onlyOwner whenNotPaused public {\n        paused = true;\n        Pause();\n    }\n\n    /**\n     * @dev called by the owner to unpause, returns to normal state\n     */\n    function unpause() onlyOwner whenPaused public {\n        paused = false;\n        Unpause();\n    }\n}\n\ninterface ISimpleCrowdsale {\n    function getSoftCap() external view returns(uint256);\n    function isContributorInLists(address contributorAddress) external view returns(bool);\n    function processReservationFundContribution(\n        address contributor,\n        uint256 tokenAmount,\n        uint256 tokenBonusAmount\n    ) external payable;\n}\n",
        "function": null,
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/New_Alchemy_Security_Audit-The Abyss DAICO Smart Contract Audit (New)/abyss-daico-21d6232a802cd966b86629cadeac0b7f3816f719/Crowdsale.sol",
        "vulnerability": "MissingInputValidation",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity >0.5.0 <0.8.0;\n\n\nlibrary Lib_RLPReader {\n\n    /*************\n     * Constants *\n     *************/\n\n    uint256 constant internal MAX_LIST_LENGTH = 32;\n\n\n    /*********\n     * Enums *\n     *********/\n\n    enum RLPItemType {\n        DATA_ITEM,\n        LIST_ITEM\n    }\n\n    \n    /***********\n     * Structs *\n     ***********/\n\n    struct RLPItem {\n        uint256 length;\n        uint256 ptr;\n    }\n    \n\n    /**********************\n     * Internal Functions *\n     **********************/\n    \n    /**\n     * Converts bytes to a reference to memory position and length.\n     * @param _in Input bytes to convert.\n     * @return Output memory reference.\n     */\n    function toRLPItem(\n        bytes memory _in\n    )\n        internal\n        pure\n        returns (\n            RLPItem memory\n        )\n    {\n        uint256 ptr;\n        assembly {\n            ptr := add(_in, 32)\n        }\n\n        return RLPItem({\n            length: _in.length,\n            ptr: ptr\n        });\n    }\n\n    /**\n     * Reads an RLP list value into a list of RLP items.\n     * @param _in RLP list value.\n     * @return Decoded RLP list items.\n     */\n    function readList(\n        RLPItem memory _in\n    )\n        internal\n        pure\n        returns (\n            RLPItem[] memory\n        )\n    {\n        (\n            uint256 listOffset,\n            ,\n            RLPItemType itemType\n        ) = _decodeLength(_in);\n\n        require(\n            itemType == RLPItemType.LIST_ITEM,\n            \"Invalid RLP list value.\"\n        );\n\n        // Solidity in-memory arrays can't be increased in size, but *can* be decreased in size by\n        // writing to the length. Since we can't know the number of RLP items without looping over\n        // the entire input, we'd have to loop twice to accurately size this array. It's easier to\n        // simply set a reasonable maximum list length and decrease the size before we finish.\n        RLPItem[] memory out = new RLPItem[](MAX_LIST_LENGTH);\n\n        uint256 itemCount = 0;\n        uint256 offset = listOffset;\n        while (offset < _in.length) {\n            require(\n                itemCount < MAX_LIST_LENGTH,\n                \"Provided RLP list exceeds max list length.\"\n            );\n\n            (\n                uint256 itemOffset,\n                uint256 itemLength,\n            ) = _decodeLength(RLPItem({\n                length: _in.length - offset,\n                ptr: _in.ptr + offset\n            }));\n\n            out[itemCount] = RLPItem({\n                length: itemLength + itemOffset,\n                ptr: _in.ptr + offset\n            });\n\n            itemCount += 1;\n            offset += itemOffset + itemLength;\n        }\n\n        // Decrease the array size to match the actual item count.\n        assembly {\n            mstore(out, itemCount)\n        }\n\n        return out;\n    }\n\n    /**\n     * Reads an RLP list value into a list of RLP items.\n     * @param _in RLP list value.\n     * @return Decoded RLP list items.\n     */\n    function readList(\n        bytes memory _in\n    )\n        internal\n        pure\n        returns (\n            RLPItem[] memory\n        )\n    {\n        return readList(\n            toRLPItem(_in)\n        );\n    }\n\n    /**\n     * Reads an RLP bytes value into bytes.\n     * @param _in RLP bytes value.\n     * @return Decoded bytes.\n     */\n    function readBytes(\n        RLPItem memory _in\n    )\n        internal\n        pure\n        returns (\n            bytes memory\n        )\n    {\n        (\n            uint256 itemOffset,\n            uint256 itemLength,\n            RLPItemType itemType\n        ) = _decodeLength(_in);\n\n        require(\n            itemType == RLPItemType.DATA_ITEM,\n            \"Invalid RLP bytes value.\"\n        );\n\n        return _copy(_in.ptr, itemOffset, itemLength);\n    }\n\n    /**\n     * Reads an RLP bytes value into bytes.\n     * @param _in RLP bytes value.\n     * @return Decoded bytes.\n     */\n    function readBytes(\n        bytes memory _in\n    )\n        internal\n        pure\n        returns (\n            bytes memory\n        )\n    {\n        return readBytes(\n            toRLPItem(_in)\n        );\n    }\n\n    /**\n     * Reads an RLP string value into a string.\n     * @param _in RLP string value.\n     * @return Decoded string.\n     */\n    function readString(\n        RLPItem memory _in\n    )\n        internal\n        pure\n        returns (\n            string memory\n        )\n    {\n        return string(readBytes(_in));\n    }\n\n    /**\n     * Reads an RLP string value into a string.\n     * @param _in RLP string value.\n     * @return Decoded string.\n     */\n    function readString(\n        bytes memory _in\n    )\n        internal\n        pure\n        returns (\n            string memory\n        )\n    {\n        return readString(\n            toRLPItem(_in)\n        );\n    }\n\n    /**\n     * Reads an RLP bytes32 value into a bytes32.\n     * @param _in RLP bytes32 value.\n     * @return Decoded bytes32.\n     */\n    function readBytes32(\n        RLPItem memory _in\n    )\n        internal\n        pure\n        returns (\n            bytes32\n        )\n    {\n        require(\n            _in.length <= 33,\n            \"Invalid RLP bytes32 value.\"\n        );\n\n        (\n            uint256 itemOffset,\n            uint256 itemLength,\n            RLPItemType itemType\n        ) = _decodeLength(_in);\n\n        require(\n            itemType == RLPItemType.DATA_ITEM,\n            \"Invalid RLP bytes32 value.\"\n        );\n\n        uint256 ptr = _in.ptr + itemOffset;\n        bytes32 out;\n        assembly {\n            out := mload(ptr)\n\n            // Shift the bytes over to match the item size.\n            if lt(itemLength, 32) {\n                out := div(out, exp(256, sub(32, itemLength)))\n            }\n        }\n\n        return out;\n    }\n\n    /**\n     * Reads an RLP bytes32 value into a bytes32.\n     * @param _in RLP bytes32 value.\n     * @return Decoded bytes32.\n     */\n    function readBytes32(\n        bytes memory _in\n    )\n        internal\n        pure\n        returns (\n            bytes32\n        )\n    {\n        return readBytes32(\n            toRLPItem(_in)\n        );\n    }\n\n    /**\n     * Reads an RLP uint256 value into a uint256.\n     * @param _in RLP uint256 value.\n     * @return Decoded uint256.\n     */\n    function readUint256(\n        RLPItem memory _in\n    )\n        internal\n        pure\n        returns (\n            uint256\n        )\n    {\n        return uint256(readBytes32(_in));\n    }\n\n    /**\n     * Reads an RLP uint256 value into a uint256.\n     * @param _in RLP uint256 value.\n     * @return Decoded uint256.\n     */\n    function readUint256(\n        bytes memory _in\n    )\n        internal\n        pure\n        returns (\n            uint256\n        )\n    {\n        return readUint256(\n            toRLPItem(_in)\n        );\n    }\n\n    /**\n     * Reads an RLP bool value into a bool.\n     * @param _in RLP bool value.\n     * @return Decoded bool.\n     */\n    function readBool(\n        RLPItem memory _in\n    )\n        internal\n        pure\n        returns (\n            bool\n        )\n    {\n        require(\n            _in.length == 1,\n            \"Invalid RLP boolean value.\"\n        );\n\n        uint256 ptr = _in.ptr;\n        uint256 out;\n        assembly {\n            out := byte(0, mload(ptr))\n        }\n\n        return out != 0;\n    }\n\n    /**\n     * Reads an RLP bool value into a bool.\n     * @param _in RLP bool value.\n     * @return Decoded bool.\n     */\n    function readBool(\n        bytes memory _in\n    )\n        internal\n        pure\n        returns (\n            bool\n        )\n    {\n        return readBool(\n            toRLPItem(_in)\n        );\n    }\n\n    /**\n     * Reads an RLP address value into a address.\n     * @param _in RLP address value.\n     * @return Decoded address.\n     */\n    function readAddress(\n        RLPItem memory _in\n    )\n        internal\n        pure\n        returns (\n            address\n        )\n    {\n        if (_in.length == 1) {\n            return address(0);\n        }\n\n        require(\n            _in.length == 21,\n            \"Invalid RLP address value.\"\n        );\n\n        return address(readUint256(_in));\n    }\n\n    /**\n     * Reads an RLP address value into a address.\n     * @param _in RLP address value.\n     * @return Decoded address.\n     */\n    function readAddress(\n        bytes memory _in\n    )\n        internal\n        pure\n        returns (\n            address\n        )\n    {\n        return readAddress(\n            toRLPItem(_in)\n        );\n    }\n\n    /**\n     * Reads an RLP Uint64 value into a uint64.\n     * @param _in RLP uint64 value.\n     * @return Decoded uint64.\n     */\n    function readUint64(\n        RLPItem memory _in\n    )\n        internal\n        pure\n        returns (\n            uint64\n        )\n    {\n        require(\n            _in.length <= 9,\n            \"Invalid RLP uint64 value.\"\n        );\n\n        return uint64(readUint256(_in));\n    }\n\n    /**\n     * Reads the raw bytes of an RLP item.\n     * @param _in RLP item to read.\n     * @return Raw RLP bytes.\n     */\n    function readRawBytes(\n        RLPItem memory _in\n    )\n        internal\n        pure\n        returns (\n            bytes memory\n        )\n    {\n        return _copy(_in);\n    }\n\n\n    /*********************\n     * Private Functions *\n     *********************/\n\n    /**\n     * Decodes the length of an RLP item.\n     * @param _in RLP item to decode.\n     * @return Offset of the encoded data.\n     * @return Length of the encoded data.\n     * @return RLP item type (LIST_ITEM or DATA_ITEM).\n     */\n    function _decodeLength(\n        RLPItem memory _in\n    )\n        private\n        pure\n        returns (\n            uint256,\n            uint256,\n            RLPItemType\n        )\n    {\n        require(\n            _in.length > 0,\n            \"RLP item cannot be null.\"\n        );\n\n        uint256 ptr = _in.ptr;\n        uint256 prefix;\n        assembly {\n            prefix := byte(0, mload(ptr))\n        }\n\n        if (prefix <= 0x7f) {\n            // Single byte.\n\n            return (0, 1, RLPItemType.DATA_ITEM);\n        } else if (prefix <= 0xb7) {\n            // Short string.\n\n            uint256 strLen = prefix - 0x80;\n            \n            require(\n                _in.length > strLen,\n                \"Invalid RLP short string.\"\n            );\n\n            return (1, strLen, RLPItemType.DATA_ITEM);\n        } else if (prefix <= 0xbf) {\n            // Long string.\n            uint256 lenOfStrLen = prefix - 0xb7;\n\n            require(\n                _in.length > lenOfStrLen,\n                \"Invalid RLP long string length.\"\n            );\n\n            uint256 strLen;\n            assembly {\n                // Pick out the string length.\n                strLen := div(\n                    mload(add(ptr, 1)),\n                    exp(256, sub(32, lenOfStrLen))\n                )\n            }\n\n            require(\n                _in.length > lenOfStrLen + strLen,\n                \"Invalid RLP long string.\"\n            );\n\n            return (1 + lenOfStrLen, strLen, RLPItemType.DATA_ITEM);\n        } else if (prefix <= 0xf7) {\n            // Short list.\n            uint256 listLen = prefix - 0xc0;\n\n            require(\n                _in.length > listLen,\n                \"Invalid RLP short list.\"\n            );\n\n            return (1, listLen, RLPItemType.LIST_ITEM);\n        } else {\n            // Long list.\n            uint256 lenOfListLen = prefix - 0xf7;\n\n            require(\n                _in.length > lenOfListLen,\n                \"Invalid RLP long list length.\"\n            );\n\n            uint256 listLen;\n            assembly {\n                // Pick out the list length.\n                listLen := div(\n                    mload(add(ptr, 1)),\n                    exp(256, sub(32, lenOfListLen))\n                )\n            }\n\n            require(\n                _in.length > lenOfListLen + listLen,\n                \"Invalid RLP long list.\"\n            );\n\n            return (1 + lenOfListLen, listLen, RLPItemType.LIST_ITEM);\n        }\n    }\n\n    /**\n     * Copies the bytes from a memory location.\n     * @param _src Pointer to the location to read from.\n     * @param _offset Offset to start reading from.\n     * @param _length Number of bytes to read.\n     * @return Copied bytes.\n     */\n    function _copy(\n        uint256 _src,\n        uint256 _offset,\n        uint256 _length\n    )\n        private\n        pure\n        returns (\n            bytes memory\n        )\n    {\n        bytes memory out = new bytes(_length);\n        if (out.length == 0) {\n            return out;\n        }\n\n        uint256 src = _src + _offset;\n        uint256 dest;\n        assembly {\n            dest := add(out, 32)\n        }\n\n        // Copy over as many complete words as we can.\n        for (uint256 i = 0; i < _length / 32; i++) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n\n            src += 32;\n            dest += 32;\n        }\n\n        // Pick out the remaining bytes.\n        uint256 mask = 256 ** (32 - (_length % 32)) - 1;\n        assembly {\n            mstore(\n                dest,\n                or(\n                    and(mload(src), not(mask)),\n                    and(mload(dest), mask)\n                )\n            )\n        }\n\n        return out;\n    }\n\n    /**\n     * Copies an RLP item into bytes.\n     * @param _in RLP item to copy.\n     * @return Copied bytes.\n     */\n    function _copy(\n        RLPItem memory _in\n    )\n        private\n        pure\n        returns (\n            bytes memory\n        )\n    {\n        return _copy(_in.ptr, 0, _in.length);\n    }\n}\n\nlibrary Lib_BytesUtils {\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    function slice(\n        bytes memory _bytes,\n        uint256 _start,\n        uint256 _length\n    )\n        internal\n        pure\n        returns (bytes memory)\n    {\n        require(_length + 31 >= _length, \"slice_overflow\");\n        require(_start + _length >= _start, \"slice_overflow\");\n        require(_bytes.length >= _start + _length, \"slice_outOfBounds\");\n\n        bytes memory tempBytes;\n\n        assembly {\n            switch iszero(_length)\n            case 0 {\n                // Get a location of some free memory and store it in tempBytes as\n                // Solidity does for memory variables.\n                tempBytes := mload(0x40)\n\n                // The first word of the slice result is potentially a partial\n                // word read from the original array. To read it, we calculate\n                // the length of that partial word and start copying that many\n                // bytes into the array. The first word we copy will start with\n                // data we don't care about, but the last `lengthmod` bytes will\n                // land at the beginning of the contents of the new array. When\n                // we're done copying, we overwrite the full first word with\n                // the actual length of the slice.\n                let lengthmod := and(_length, 31)\n\n                // The multiplication in the next line is necessary\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\n                // the following copy loop was copying the origin's length\n                // and then ending prematurely not copying everything it should.\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n                let end := add(mc, _length)\n\n                for {\n                    // The multiplication in the next line has the same exact purpose\n                    // as the one above.\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n                } lt(mc, end) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    mstore(mc, mload(cc))\n                }\n\n                mstore(tempBytes, _length)\n\n                //update free-memory pointer\n                //allocating the array padded to 32 bytes like the compiler does now\n                mstore(0x40, and(add(mc, 31), not(31)))\n            }\n            //if we want a zero-length slice let's just return a zero-length array\n            default {\n                tempBytes := mload(0x40)\n\n                //zero out the 32 bytes slice we are about to return\n                //we need to do it because Solidity does not garbage collect\n                mstore(tempBytes, 0)\n\n                mstore(0x40, add(tempBytes, 0x20))\n            }\n        }\n\n        return tempBytes;\n    }\n\n    function slice(\n        bytes memory _bytes,\n        uint256 _start\n    )\n        internal\n        pure\n        returns (bytes memory)\n    {\n        if (_bytes.length - _start == 0) {\n            return bytes('');\n        }\n\n        return slice(_bytes, _start, _bytes.length - _start);\n    }\n\n    function toBytes32PadLeft(\n        bytes memory _bytes\n    )\n        internal\n        pure\n        returns (bytes32)\n    {\n        bytes32 ret;\n        uint256 len = _bytes.length <= 32 ? _bytes.length : 32;\n        assembly {\n            ret := shr(mul(sub(32, len), 8), mload(add(_bytes, 32)))\n        }\n        return ret;\n    }\n\n    function toBytes32(\n        bytes memory _bytes\n    )\n        internal\n        pure\n        returns (bytes32)\n    {\n        if (_bytes.length < 32) {\n            bytes32 ret;\n            assembly {\n                ret := mload(add(_bytes, 32))\n            }\n            return ret;\n        }\n\n        return abi.decode(_bytes,(bytes32)); // will truncate if input length > 32 bytes\n    }\n\n    function toUint256(\n        bytes memory _bytes\n    )\n        internal\n        pure\n        returns (uint256)\n    {\n        return uint256(toBytes32(_bytes));\n    }\n\n    function toUint24(bytes memory _bytes, uint256 _start) internal pure returns (uint24) {\n        require(_start + 3 >= _start, \"toUint24_overflow\");\n        require(_bytes.length >= _start + 3 , \"toUint24_outOfBounds\");\n        uint24 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x3), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint8(bytes memory _bytes, uint256 _start) internal pure returns (uint8) {\n        require(_start + 1 >= _start, \"toUint8_overflow\");\n        require(_bytes.length >= _start + 1 , \"toUint8_outOfBounds\");\n        uint8 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x1), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {\n        require(_start + 20 >= _start, \"toAddress_overflow\");\n        require(_bytes.length >= _start + 20, \"toAddress_outOfBounds\");\n        address tempAddress;\n\n        assembly {\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\n        }\n\n        return tempAddress;\n    }\n\n    function toNibbles(\n        bytes memory _bytes\n    )\n        internal\n        pure\n        returns (bytes memory)\n    {\n        bytes memory nibbles = new bytes(_bytes.length * 2);\n\n        for (uint256 i = 0; i < _bytes.length; i++) {\n            nibbles[i * 2] = _bytes[i] >> 4;\n            nibbles[i * 2 + 1] = bytes1(uint8(_bytes[i]) % 16);\n        }\n\n        return nibbles;\n    }\n\n    function fromNibbles(\n        bytes memory _bytes\n    )\n        internal\n        pure\n        returns (bytes memory)\n    {\n        bytes memory ret = new bytes(_bytes.length / 2);\n\n        for (uint256 i = 0; i < ret.length; i++) {\n            ret[i] = (_bytes[i * 2] << 4) | (_bytes[i * 2 + 1]);\n        }\n\n        return ret;\n    }\n\n    function equal(\n        bytes memory _bytes,\n        bytes memory _other\n    )\n        internal\n        pure\n        returns (bool)\n    {\n        return keccak256(_bytes) == keccak256(_other);\n    }\n}\n\nlibrary Lib_RLPWriter {\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    /**\n     * RLP encodes a byte string.\n     * @param _in The byte string to encode.\n     * @return _out The RLP encoded string in bytes.\n     */\n    function writeBytes(\n        bytes memory _in\n    )\n        internal\n        pure\n        returns (\n            bytes memory _out\n        )\n    {\n        bytes memory encoded;\n\n        if (_in.length == 1 && uint8(_in[0]) < 128) {\n            encoded = _in;\n        } else {\n            encoded = abi.encodePacked(_writeLength(_in.length, 128), _in);\n        }\n\n        return encoded;\n    }\n\n    /**\n     * RLP encodes a list of RLP encoded byte byte strings.\n     * @param _in The list of RLP encoded byte strings.\n     * @return _out The RLP encoded list of items in bytes.\n     */\n    function writeList(\n        bytes[] memory _in\n    )\n        internal\n        pure\n        returns (\n            bytes memory _out\n        )\n    {\n        bytes memory list = _flatten(_in);\n        return abi.encodePacked(_writeLength(list.length, 192), list);\n    }\n\n    /**\n     * RLP encodes a string.\n     * @param _in The string to encode.\n     * @return _out The RLP encoded string in bytes.\n     */\n    function writeString(\n        string memory _in\n    )\n        internal\n        pure\n        returns (\n            bytes memory _out\n        )\n    {\n        return writeBytes(bytes(_in));\n    }\n\n    /**\n     * RLP encodes an address.\n     * @param _in The address to encode.\n     * @return _out The RLP encoded address in bytes.\n     */\n    function writeAddress(\n        address _in\n    )\n        internal\n        pure\n        returns (\n            bytes memory _out\n        )\n    {\n        return writeBytes(abi.encodePacked(_in));\n    }\n\n    /**\n     * RLP encodes a bytes32 value.\n     * @param _in The bytes32 to encode.\n     * @return _out The RLP encoded bytes32 in bytes.\n     */\n    function writeBytes32(\n        bytes32 _in\n    )\n        internal\n        pure\n        returns (\n            bytes memory _out\n        )\n    {\n        return writeBytes(abi.encodePacked(_in));\n    }\n\n    /**\n     * RLP encodes a uint.\n     * @param _in The uint256 to encode.\n     * @return _out The RLP encoded uint256 in bytes.\n     */\n    function writeUint(\n        uint256 _in\n    )\n        internal\n        pure\n        returns (\n            bytes memory _out\n        )\n    {\n        return writeBytes(_toBinary(_in));\n    }\n\n    /**\n     * RLP encodes a bool.\n     * @param _in The bool to encode.\n     * @return _out The RLP encoded bool in bytes.\n     */\n    function writeBool(\n        bool _in\n    )\n        internal\n        pure\n        returns (\n            bytes memory _out\n        )\n    {\n        bytes memory encoded = new bytes(1);\n        encoded[0] = (_in ? bytes1(0x01) : bytes1(0x80));\n        return encoded;\n    }\n\n\n    /*********************\n     * Private Functions *\n     *********************/\n\n    /**\n     * Encode the first byte, followed by the `len` in binary form if `length` is more than 55.\n     * @param _len The length of the string or the payload.\n     * @param _offset 128 if item is string, 192 if item is list.\n     * @return _encoded RLP encoded bytes.\n     */\n    function _writeLength(\n        uint256 _len,\n        uint256 _offset\n    )\n        private\n        pure\n        returns (\n            bytes memory _encoded\n        )\n    {\n        bytes memory encoded;\n\n        if (_len < 56) {\n            encoded = new bytes(1);\n            encoded[0] = byte(uint8(_len) + uint8(_offset));\n        } else {\n            uint256 lenLen;\n            uint256 i = 1;\n            while (_len / i != 0) {\n                lenLen++;\n                i *= 256;\n            }\n\n            encoded = new bytes(lenLen + 1);\n            encoded[0] = byte(uint8(lenLen) + uint8(_offset) + 55);\n            for(i = 1; i <= lenLen; i++) {\n                encoded[i] = byte(uint8((_len / (256**(lenLen-i))) % 256));\n            }\n        }\n\n        return encoded;\n    }\n\n    /**\n     * Encode integer in big endian binary form with no leading zeroes.\n     * @notice TODO: This should be optimized with assembly to save gas costs.\n     * @param _x The integer to encode.\n     * @return _binary RLP encoded bytes.\n     */\n    function _toBinary(\n        uint256 _x\n    )\n        private\n        pure\n        returns (\n            bytes memory _binary\n        )\n    {\n        bytes memory b = abi.encodePacked(_x);\n\n        uint256 i = 0;\n        for (; i < 32; i++) {\n            if (b[i] != 0) {\n                break;\n            }\n        }\n\n        bytes memory res = new bytes(32 - i);\n        for (uint256 j = 0; j < res.length; j++) {\n            res[j] = b[i++];\n        }\n\n        return res;\n    }\n\n    /**\n     * Copies a piece of memory to another location.\n     * @notice From: https://github.com/Arachnid/solidity-stringutils/blob/master/src/strings.sol.\n     * @param _dest Destination location.\n     * @param _src Source location.\n     * @param _len Length of memory to copy.\n     */\n    function _memcpy(\n        uint256 _dest,\n        uint256 _src,\n        uint256 _len\n    )\n        private\n        pure\n    {\n        uint256 dest = _dest;\n        uint256 src = _src;\n        uint256 len = _len;\n\n        for(; len >= 32; len -= 32) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n            dest += 32;\n            src += 32;\n        }\n\n        uint256 mask = 256 ** (32 - len) - 1;\n        assembly {\n            let srcpart := and(mload(src), not(mask))\n            let destpart := and(mload(dest), mask)\n            mstore(dest, or(destpart, srcpart))\n        }\n    }\n\n    /**\n     * Flattens a list of byte strings into one byte string.\n     * @notice From: https://github.com/sammayo/solidity-rlp-encoder/blob/master/RLPEncode.sol.\n     * @param _list List of byte strings to flatten.\n     * @return _flattened The flattened byte string.\n     */\n    function _flatten(\n        bytes[] memory _list\n    )\n        private\n        pure\n        returns (\n            bytes memory _flattened\n        )\n    {\n        if (_list.length == 0) {\n            return new bytes(0);\n        }\n\n        uint256 len;\n        uint256 i = 0;\n        for (; i < _list.length; i++) {\n            len += _list[i].length;\n        }\n\n        bytes memory flattened = new bytes(len);\n        uint256 flattenedPtr;\n        assembly { flattenedPtr := add(flattened, 0x20) }\n\n        for(i = 0; i < _list.length; i++) {\n            bytes memory item = _list[i];\n\n            uint256 listPtr;\n            assembly { listPtr := add(item, 0x20)}\n\n            _memcpy(flattenedPtr, listPtr, item.length);\n            flattenedPtr += _list[i].length;\n        }\n\n        return flattened;\n    }\n}\n\nlibrary Lib_EIP155Tx {\n\n    /***********\n     * Structs *\n     ***********/\n\n    // Struct representing an EIP155 transaction. See EIP link above for more information.\n    struct EIP155Tx {\n        // These fields correspond to the actual RLP-encoded fields specified by EIP155.\n        uint64 nonce;\n        uint256 gasPrice;\n        uint256 gasLimit;\n        address to;\n        uint256 value;\n        bytes data;\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n\n        // Chain ID to associate this transaction with. Used all over the place, seemed easier to\n        // set this once when we create the transaction rather than providing it as an input to\n        // each function. I don't see a strong need to have a transaction with a mutable chain ID.\n        uint256 chainId;\n\n        // The ECDSA \"recovery parameter,\" should always be 0 or 1. EIP155 specifies that:\n        // `v = {0,1} + CHAIN_ID * 2 + 35`\n        // Where `{0,1}` is a stand in for our `recovery_parameter`. Now computing our formula for\n        // the recovery parameter:\n        // 1. `v = {0,1} + CHAIN_ID * 2 + 35`\n        // 2. `v = recovery_parameter + CHAIN_ID * 2 + 35`\n        // 3. `v - CHAIN_ID * 2 - 35 = recovery_parameter`\n        // So we're left with the final formula:\n        // `recovery_parameter = v - CHAIN_ID * 2 - 35`\n        // NOTE: This variable is a uint8 because `v` is inherently limited to a uint8. If we\n        // didn't use a uint8, then recovery_parameter would always be a negative number for chain\n        // IDs greater than 110 (`255 - 110 * 2 - 35 = 0`). So we need to wrap around to support\n        // anything larger.\n        uint8 recoveryParam; \n\n        // Whether or not the transaction is a creation. Necessary because we can't make an address\n        // \"nil\". Using the zero address creates a potential conflict if the user did actually\n        // intend to send a transaction to the zero address.\n        bool isCreate;       \n    }\n\n    // Lets us use nicer syntax.\n    using Lib_EIP155Tx for EIP155Tx;\n\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    /**\n     * Decodes an EIP155 transaction and attaches a given Chain ID.\n     * Transaction *must* be RLP-encoded.\n     * @param _encoded RLP-encoded EIP155 transaction.\n     * @param _chainId Chain ID to assocaite with this transaction.\n     * @return Parsed transaction.\n     */\n    function decode(\n        bytes memory _encoded,\n        uint256 _chainId\n    )\n        internal\n        pure\n        returns (\n            EIP155Tx memory\n        )\n    {\n        Lib_RLPReader.RLPItem[] memory decoded = Lib_RLPReader.readList(_encoded);\n\n        // Note formula above about how recoveryParam is computed.\n        uint8 v = uint8(Lib_RLPReader.readUint256(decoded[6]));\n        uint8 recoveryParam = uint8(v - 2 * _chainId - 35);\n\n        // Creations can be detected by looking at the byte length here.\n        bool isCreate = Lib_RLPReader.readBytes(decoded[3]).length == 0;\n\n        return EIP155Tx({\n            nonce: Lib_RLPReader.readUint64(decoded[0]),\n            gasPrice: Lib_RLPReader.readUint256(decoded[1]),\n            gasLimit: Lib_RLPReader.readUint256(decoded[2]),\n            to: Lib_RLPReader.readAddress(decoded[3]),\n            value: Lib_RLPReader.readUint256(decoded[4]),\n            data: Lib_RLPReader.readBytes(decoded[5]),\n            v: v,\n            r: Lib_RLPReader.readBytes32(decoded[7]),\n            s: Lib_RLPReader.readBytes32(decoded[8]),\n            chainId: _chainId,\n            recoveryParam: recoveryParam,\n            isCreate: isCreate\n        });\n    }\n\n    /**\n     * Encodes an EIP155 transaction into RLP.\n     * @param _transaction EIP155 transaction to encode.\n     * @param _includeSignature Whether or not to encode the signature.\n     * @return RLP-encoded transaction.\n     */\n    function encode(\n        EIP155Tx memory _transaction,\n        bool _includeSignature\n    )\n        internal\n        pure\n        returns (\n            bytes memory\n        )\n    {\n        bytes[] memory raw = new bytes[](9);\n\n        raw[0] = Lib_RLPWriter.writeUint(_transaction.nonce);\n        raw[1] = Lib_RLPWriter.writeUint(_transaction.gasPrice);\n        raw[2] = Lib_RLPWriter.writeUint(_transaction.gasLimit);\n\n        // We write the encoding of empty bytes when the transaction is a creation, *not* the zero\n        // address as one might assume.\n        if (_transaction.isCreate) {\n            raw[3] = Lib_RLPWriter.writeBytes('');\n        } else {\n            raw[3] = Lib_RLPWriter.writeAddress(_transaction.to);\n        }\n\n        raw[4] = Lib_RLPWriter.writeUint(_transaction.value);\n        raw[5] = Lib_RLPWriter.writeBytes(_transaction.data);\n\n        if (_includeSignature) {\n            raw[6] = Lib_RLPWriter.writeUint(_transaction.v);\n            raw[7] = Lib_RLPWriter.writeBytes32(_transaction.r);\n            raw[8] = Lib_RLPWriter.writeBytes32(_transaction.s);\n        } else {\n            // Chain ID *is* included in the unsigned transaction.\n            raw[6] = Lib_RLPWriter.writeUint(_transaction.chainId); \n            raw[7] = Lib_RLPWriter.writeBytes('');\n            raw[8] = Lib_RLPWriter.writeBytes('');\n        }\n\n        return Lib_RLPWriter.writeList(raw);\n    }\n\n    /**\n     * Computes the hash of an EIP155 transaction. Assumes that you don't want to include the\n     * signature in this hash because that's a very uncommon usecase. If you really want to include\n     * the signature, just encode with the signature and take the hash yourself.\n     */\n    function hash(\n        EIP155Tx memory _transaction\n    )\n        internal\n        pure\n        returns (\n            bytes32\n        )\n    {\n        return keccak256(\n            _transaction.encode(false)\n        );\n    }\n\n    /**\n     * Computes the sender of an EIP155 transaction.\n     * @param _transaction EIP155 transaction to get a sender for.\n     * @return Address corresponding to the private key that signed this transaction.\n     */\n    function sender(\n        EIP155Tx memory _transaction\n    )\n        internal\n        pure\n        returns (\n            address\n        )\n    {\n        return ecrecover(\n            _transaction.hash(),\n            _transaction.recoveryParam + 27,\n            _transaction.r,\n            _transaction.s\n        );\n    }\n}\n\nlibrary Lib_ErrorUtils {\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    /**\n     * Encodes an error string into raw solidity-style revert data.\n     * (i.e. ascii bytes, prefixed with bytes4(keccak(\"Error(string))\"))\n     * Ref: https://docs.soliditylang.org/en/v0.8.2/control-structures.html?highlight=Error(string)#panic-via-assert-and-error-via-require\n     * @param _reason Reason for the reversion.\n     * @return Standard solidity revert data for the given reason.\n     */\n    function encodeRevertString(\n        string memory _reason\n    )\n        internal\n        pure\n        returns (\n            bytes memory\n        )\n    {\n        return abi.encodeWithSignature(\n            \"Error(string)\",\n            _reason\n        );\n    }\n}\n\nlibrary Lib_SafeExecutionManagerWrapper {\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    /**\n     * Performs a safe ovmCALL.\n     * @param _gasLimit Gas limit for the call.\n     * @param _target Address to call.\n     * @param _calldata Data to send to the call.\n     * @return _success Whether or not the call reverted.\n     * @return _returndata Data returned by the call.\n     */\n    function safeCALL(\n        uint256 _gasLimit,\n        address _target,\n        bytes memory _calldata\n    )\n        internal\n        returns (\n            bool _success,\n            bytes memory _returndata\n        )\n    {\n        bytes memory returndata = _safeExecutionManagerInteraction(\n            abi.encodeWithSignature(\n                \"ovmCALL(uint256,address,bytes)\",\n                _gasLimit,\n                _target,\n                _calldata\n            )\n        );\n\n        return abi.decode(returndata, (bool, bytes));\n    }\n\n    /**\n     * Performs a safe ovmDELEGATECALL.\n     * @param _gasLimit Gas limit for the call.\n     * @param _target Address to call.\n     * @param _calldata Data to send to the call.\n     * @return _success Whether or not the call reverted.\n     * @return _returndata Data returned by the call.\n     */\n    function safeDELEGATECALL(\n        uint256 _gasLimit,\n        address _target,\n        bytes memory _calldata\n    )\n        internal\n        returns (\n            bool _success,\n            bytes memory _returndata\n        )\n    {\n        bytes memory returndata = _safeExecutionManagerInteraction(\n            abi.encodeWithSignature(\n                \"ovmDELEGATECALL(uint256,address,bytes)\",\n                _gasLimit,\n                _target,\n                _calldata\n            )\n        );\n\n        return abi.decode(returndata, (bool, bytes));\n    }\n\n    /**\n     * Performs a safe ovmCREATE call.\n     * @param _gasLimit Gas limit for the creation.\n     * @param _bytecode Code for the new contract.\n     * @return _contract Address of the created contract.\n     */\n    function safeCREATE(\n        uint256 _gasLimit,\n        bytes memory _bytecode\n    )\n        internal\n        returns (\n            address,\n            bytes memory\n        )\n    {\n        bytes memory returndata = _safeExecutionManagerInteraction(\n            _gasLimit,\n            abi.encodeWithSignature(\n                \"ovmCREATE(bytes)\",\n                _bytecode\n            )\n        );\n\n        return abi.decode(returndata, (address, bytes));\n    }\n\n    /**\n     * Performs a safe ovmEXTCODESIZE call.\n     * @param _contract Address of the contract to query the size of.\n     * @return _EXTCODESIZE Size of the requested contract in bytes.\n     */\n    function safeEXTCODESIZE(\n        address _contract\n    )\n        internal\n        returns (\n            uint256 _EXTCODESIZE\n        )\n    {\n        bytes memory returndata = _safeExecutionManagerInteraction(\n            abi.encodeWithSignature(\n                \"ovmEXTCODESIZE(address)\",\n                _contract\n            )\n        );\n\n        return abi.decode(returndata, (uint256));\n    }\n\n    /**\n     * Performs a safe ovmCHAINID call.\n     * @return _CHAINID Result of calling ovmCHAINID.\n     */\n    function safeCHAINID()\n        internal\n        returns (\n            uint256 _CHAINID\n        )\n    {\n        bytes memory returndata = _safeExecutionManagerInteraction(\n            abi.encodeWithSignature(\n                \"ovmCHAINID()\"\n            )\n        );\n\n        return abi.decode(returndata, (uint256));\n    }\n\n    /**\n     * Performs a safe ovmCALLER call.\n     * @return _CALLER Result of calling ovmCALLER.\n     */\n    function safeCALLER()\n        internal\n        returns (\n            address _CALLER\n        )\n    {\n        bytes memory returndata = _safeExecutionManagerInteraction(\n            abi.encodeWithSignature(\n                \"ovmCALLER()\"\n            )\n        );\n\n        return abi.decode(returndata, (address));\n    }\n\n    /**\n     * Performs a safe ovmADDRESS call.\n     * @return _ADDRESS Result of calling ovmADDRESS.\n     */\n    function safeADDRESS()\n        internal\n        returns (\n            address _ADDRESS\n        )\n    {\n        bytes memory returndata = _safeExecutionManagerInteraction(\n            abi.encodeWithSignature(\n                \"ovmADDRESS()\"\n            )\n        );\n\n        return abi.decode(returndata, (address));\n    }\n\n    /**\n     * Performs a safe ovmGETNONCE call.\n     * @return _nonce Result of calling ovmGETNONCE.\n     */\n    function safeGETNONCE()\n        internal\n        returns (\n            uint64 _nonce\n        )\n    {\n        bytes memory returndata = _safeExecutionManagerInteraction(\n            abi.encodeWithSignature(\n                \"ovmGETNONCE()\"\n            )\n        );\n\n        return abi.decode(returndata, (uint64));\n    }\n\n    /**\n     * Performs a safe ovmSETNONCE call.\n     * @param _nonce New account nonce.\n     */\n    function safeSETNONCE(\n        uint64 _nonce\n    )\n        internal\n    {\n        _safeExecutionManagerInteraction(\n            abi.encodeWithSignature(\n                \"ovmSETNONCE(uint64)\",\n                _nonce\n            )\n        );\n    }\n\n    /**\n     * Performs a safe ovmCREATEEOA call.\n     * @param _messageHash Message hash which was signed by EOA\n     * @param _v v value of signature (0 or 1)\n     * @param _r r value of signature\n     * @param _s s value of signature\n     */\n    function safeCREATEEOA(\n        bytes32 _messageHash,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    )\n        internal\n    {\n        _safeExecutionManagerInteraction(\n            abi.encodeWithSignature(\n                \"ovmCREATEEOA(bytes32,uint8,bytes32,bytes32)\",\n                _messageHash,\n                _v,\n                _r,\n                _s\n            )\n        );\n    }\n\n    /**\n     * Performs a safe REVERT.\n     * @param _reason String revert reason to pass along with the REVERT.\n     */\n    function safeREVERT(\n        string memory _reason\n    )\n        internal\n    {\n        _safeExecutionManagerInteraction(\n            abi.encodeWithSignature(\n                \"ovmREVERT(bytes)\",\n                Lib_ErrorUtils.encodeRevertString(\n                    _reason\n                )\n            )\n        );\n    }\n\n    /**\n     * Performs a safe \"require\".\n     * @param _condition Boolean condition that must be true or will revert.\n     * @param _reason String revert reason to pass along with the REVERT.\n     */\n    function safeREQUIRE(\n        bool _condition,\n        string memory _reason\n    )\n        internal\n    {\n        if (!_condition) {\n            safeREVERT(\n                _reason\n            );\n        }\n    }\n\n    /**\n     * Performs a safe ovmSLOAD call.\n     */\n    function safeSLOAD(\n        bytes32 _key\n    )\n        internal\n        returns (\n            bytes32\n        )\n    {\n        bytes memory returndata = _safeExecutionManagerInteraction(\n            abi.encodeWithSignature(\n                \"ovmSLOAD(bytes32)\",\n                _key\n            )\n        );\n\n        return abi.decode(returndata, (bytes32));\n    }\n\n    /**\n     * Performs a safe ovmSSTORE call.\n     */\n    function safeSSTORE(\n        bytes32 _key,\n        bytes32 _value\n    )\n        internal\n    {\n        _safeExecutionManagerInteraction(\n            abi.encodeWithSignature(\n                \"ovmSSTORE(bytes32,bytes32)\",\n                _key,\n                _value\n            )\n        );\n    }\n\n    /*********************\n     * Private Functions *\n     *********************/\n\n    /**\n     * Performs an ovm interaction and the necessary safety checks.\n     * @param _gasLimit Gas limit for the interaction.\n     * @param _calldata Data to send to the OVM_ExecutionManager (encoded with sighash).\n     * @return _returndata Data sent back by the OVM_ExecutionManager.\n     */\n    function _safeExecutionManagerInteraction(\n        uint256 _gasLimit,\n        bytes memory _calldata\n    )\n        private\n        returns (\n            bytes memory _returndata\n        )\n    {\n        address ovmExecutionManager = msg.sender;\n        (\n            bool success,\n            bytes memory returndata\n        ) = ovmExecutionManager.call{gas: _gasLimit}(_calldata);\n\n        if (success == false) {\n            assembly {\n                revert(add(returndata, 0x20), mload(returndata))\n            }\n        } else if (returndata.length == 1) {\n            assembly {\n                return(0, 1)\n            }\n        } else {\n            return returndata;\n        }\n    }\n\n    function _safeExecutionManagerInteraction(\n        bytes memory _calldata\n    )\n        private\n        returns (\n            bytes memory _returndata\n        )\n    {\n        return _safeExecutionManagerInteraction(\n            gasleft(),\n            _calldata\n        );\n    }\n}\n\n// SPDX-License-Identifier: MIT\n/* Library Imports */\n/**\n * @title OVM_SequencerEntrypoint\n * @dev The Sequencer Entrypoint is a predeploy which, despite its name, can in fact be called by \n * any account. It accepts a more efficient compressed calldata format, which it decompresses and \n * encodes to the standard EIP155 transaction format.\n * This contract is the implementation referenced by the Proxy Sequencer Entrypoint, thus enabling\n * the Optimism team to upgrade the decompression of calldata from the Sequencer.\n * \n * Compiler used: solc\n * Runtime target: OVM\n */\ncontract OVM_SequencerEntrypoint {\n    using Lib_EIP155Tx for Lib_EIP155Tx.EIP155Tx;\n\n\n    /*********************\n     * Fallback Function *\n     *********************/\n\n    /**\n     * Expects an RLP-encoded EIP155 transaction as input. See the EIP for a more detailed\n     * description of this transaction format:\n     * https://github.com/ethereum/EIPs/blob/master/EIPS/eip-155.md\n     */\n    fallback()\n        external\n    {\n        Lib_EIP155Tx.EIP155Tx memory transaction = Lib_EIP155Tx.decode(\n            msg.data,\n            Lib_SafeExecutionManagerWrapper.safeCHAINID()\n        );\n\n        // Recovery parameter being something other than 0 or 1 indicates that this transaction was\n        // signed using the wrong chain ID. We really should have this logic inside of the \n        Lib_SafeExecutionManagerWrapper.safeREQUIRE(\n            transaction.recoveryParam < 2,\n            \"OVM_SequencerEntrypoint: Transaction was signed with the wrong chain ID.\"\n        );\n\n        // Cache this result since we use it twice. Maybe we could move this caching into\n        // Lib_EIP155Tx but I'd rather not make optimizations like that right now.\n        address sender = transaction.sender();\n\n        // Create an EOA contract for this account if it doesn't already exist.\n        if (Lib_SafeExecutionManagerWrapper.safeEXTCODESIZE(sender) == 0) {\n            Lib_SafeExecutionManagerWrapper.safeCREATEEOA(\n                transaction.hash(),\n                transaction.recoveryParam,\n                transaction.r,\n                transaction.s\n            );\n        }\n\n        // Now call into the EOA contract (which should definitely exist).\n        //SWC-104-Unchecked Call Return Value: L63-L70\n        Lib_SafeExecutionManagerWrapper.safeCALL(\n            gasleft(),\n            sender,\n            abi.encodeWithSignature(\n                \"execute(bytes)\",\n                msg.data\n            )\n        );\n    }\n}\n",
        "function": null,
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/openzeppelin-Optimism/contracts-18e128343731b9bde23812ce932e24d81440b6b7/contracts/optimistic-ethereum/OVM/precompiles/OVM_SequencerEntrypoint.sol",
        "vulnerability": "UnhandledException",
        "check": "TP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity ^0.4.16;\n\n\n// SWC-102-Outdated Compiler Version: L2\ncontract MigrationAgent {\n    function migrateFrom(address _from, uint256 _value);\n}\n\ncontract GNTAllocation {\n    function GNTAllocation(address _golemFactory) {}\n}\n\n\ncontract GolemNetworkToken {\n    string public constant name = \"Test Golem Network Token\";\n    string public constant symbol = \"tGNT\";\n    uint8 public constant decimals = 18;  // 18 decimal places, the same as ETH.\n\n    uint256 public constant tokenCreationRate = 10000000000;\n\n    // The funding cap in weis.\n    uint256 public constant tokenCreationCap = 82 finney * tokenCreationRate;\n    uint256 public constant tokenCreationMin = 15 finney * tokenCreationRate;\n\n    uint256 public fundingStartBlock;\n    uint256 public fundingEndBlock;\n\n    // The flag indicates if the GNT contract is in Funding state.\n    bool public funding = true;\n\n    // Receives ETH and its own GNT endowment.\n    address public golemFactory;\n\n    // Has control over token migration to next version of token.\n    address public migrationMaster;\n\n    GNTAllocation lockedAllocation;\n\n    // The current total token supply.\n    uint256 public totalTokens;\n\n    mapping (address => uint256) balances;\n\n    address public migrationAgent;\n    uint256 public totalMigrated;\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Migrate(address indexed _from, address indexed _to, uint256 _value);\n    event Refund(address indexed _from, uint256 _value);\n\n    function GolemNetworkToken(address _golemFactory,\n                               address _migrationMaster,\n                               uint256 _fundingStartBlock,\n                               uint256 _fundingEndBlock) {\n\n        if (_golemFactory == 0) revert();\n        if (_migrationMaster == 0) revert();\n        if (_fundingStartBlock <= block.number) revert();\n        if (_fundingEndBlock   <= _fundingStartBlock) revert();\n\n        lockedAllocation = new GNTAllocation(_golemFactory);\n        migrationMaster = _migrationMaster;\n        golemFactory = _golemFactory;\n        fundingStartBlock = _fundingStartBlock;\n        fundingEndBlock = _fundingEndBlock;\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    function transfer(address _to, uint256 _value) returns (bool) {\n        // Abort if not in Operational state.\n        if (funding) revert();\n\n        var senderBalance = balances[msg.sender];\n        if (senderBalance >= _value && _value > 0) {\n            senderBalance -= _value;\n            balances[msg.sender] = senderBalance;\n            balances[_to] += _value;\n            Transfer(msg.sender, _to, _value);\n            return true;\n        }\n        return false;\n    }\n\n    function totalSupply() external view returns (uint256) {\n        return totalTokens;\n    }\n\n    function balanceOf(address _owner) external view returns (uint256) {\n        return balances[_owner];\n    }\n\n    // Token migration support:\n\n    \n    \n    \n    function migrate(uint256 _value) external {\n        // Abort if not in Operational Migration state.\n        if (funding) revert();\n        if (migrationAgent == 0) revert();\n\n        // Validate input value.\n        if (_value == 0) revert();\n        if (_value > balances[msg.sender]) revert();\n\n        balances[msg.sender] -= _value;\n        totalTokens -= _value;\n        totalMigrated += _value;\n        MigrationAgent(migrationAgent).migrateFrom(msg.sender, _value);\n        Migrate(msg.sender, migrationAgent, _value);\n    }\n\n    \n\t\n    \n    \n    \n    function setMigrationAgent(address _agent) external {\n        // Abort if not in Operational Normal state.\n        if (funding) revert();\n        if (migrationAgent != 0) revert();\n        if (msg.sender != migrationMaster) revert();\n        migrationAgent = _agent;\n    }\n\n    function setMigrationMaster(address _master) external {\n        if (msg.sender != migrationMaster) revert();\n        if (_master == 0) revert();\n        migrationMaster = _master;\n    }\n\n    // Crowdfunding:\n\n    \n    \n    \n    function create() payable external {\n        // Abort if not in Funding Active state.\n        // The checks are split (instead of using or operator) because it is\n        // cheaper this way.\n        if (!funding) revert();\n        if (block.number < fundingStartBlock) revert();\n        if (block.number > fundingEndBlock) revert();\n\n        // Do not allow creating 0 or more than the cap tokens.\n        if (msg.value == 0) revert();\n        if (msg.value > (tokenCreationCap - totalTokens) / tokenCreationRate)\n            revert();\n\n        var numTokens = msg.value * tokenCreationRate;\n        totalTokens += numTokens;\n\n        // Assign new tokens to the sender\n        balances[msg.sender] += numTokens;\n\n        // Log token creation event\n        Transfer(0, msg.sender, numTokens);\n    }\n\n    \n    \n    \n    \n    \n    \n    function finalize() external {\n        // Abort if not in Funding Success state.\n        if (!funding) revert();\n        if ((block.number <= fundingEndBlock ||\n             totalTokens < tokenCreationMin) &&\n            totalTokens < tokenCreationCap) revert();\n\n        // Switch to Operational state. This is the only place this can happen.\n        funding = false;\n\n        // Create additional GNT for the Golem Factory and developers as\n        // the 18% of total number of tokens.\n        // All additional tokens are transfered to the account controller by\n        // GNTAllocation contract which will not allow using them for 6 months.\n        uint256 percentOfTotal = 18;\n        uint256 additionalTokens =\n            totalTokens * percentOfTotal / (100 - percentOfTotal);\n        totalTokens += additionalTokens;\n        balances[lockedAllocation] += additionalTokens;\n        Transfer(0, lockedAllocation, additionalTokens);\n\n        // Transfer ETH to the Golem Factory address.\n        if (!golemFactory.send(this.balance)) revert();\n    }\n\n    \n    \n    \n    function refund() external {\n        // Abort if not in Funding Failure state.\n        if (!funding) revert();\n        if (block.number <= fundingEndBlock) revert();\n        if (totalTokens >= tokenCreationMin) revert();\n\n        var gntValue = balances[msg.sender];\n        if (gntValue == 0) revert();\n        balances[msg.sender] = 0;\n        totalTokens -= gntValue;\n\n        var ethValue = gntValue / tokenCreationRate;\n        Refund(msg.sender, ethValue);\n        if (!msg.sender.send(ethValue)) revert();\n    }\n}\n",
        "function": null,
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GolemNetworkToken.sol",
        "vulnerability": "TODTransfer",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity ^0.4.16;\n\n\n// SWC-102-Outdated Compiler Version: L2\ncontract MigrationAgent {\n    function migrateFrom(address _from, uint256 _value);\n}\n\ncontract GNTAllocation {\n    function GNTAllocation(address _golemFactory) {}\n}\n\n\ncontract GolemNetworkToken {\n    string public constant name = \"Test Golem Network Token\";\n    string public constant symbol = \"tGNT\";\n    uint8 public constant decimals = 18;  // 18 decimal places, the same as ETH.\n\n    uint256 public constant tokenCreationRate = 10000000000;\n\n    // The funding cap in weis.\n    uint256 public constant tokenCreationCap = 82 finney * tokenCreationRate;\n    uint256 public constant tokenCreationMin = 15 finney * tokenCreationRate;\n\n    uint256 public fundingStartBlock;\n    uint256 public fundingEndBlock;\n\n    // The flag indicates if the GNT contract is in Funding state.\n    bool public funding = true;\n\n    // Receives ETH and its own GNT endowment.\n    address public golemFactory;\n\n    // Has control over token migration to next version of token.\n    address public migrationMaster;\n\n    GNTAllocation lockedAllocation;\n\n    // The current total token supply.\n    uint256 public totalTokens;\n\n    mapping (address => uint256) balances;\n\n    address public migrationAgent;\n    uint256 public totalMigrated;\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Migrate(address indexed _from, address indexed _to, uint256 _value);\n    event Refund(address indexed _from, uint256 _value);\n\n    function GolemNetworkToken(address _golemFactory,\n                               address _migrationMaster,\n                               uint256 _fundingStartBlock,\n                               uint256 _fundingEndBlock) {\n\n        if (_golemFactory == 0) revert();\n        if (_migrationMaster == 0) revert();\n        if (_fundingStartBlock <= block.number) revert();\n        if (_fundingEndBlock   <= _fundingStartBlock) revert();\n\n        lockedAllocation = new GNTAllocation(_golemFactory);\n        migrationMaster = _migrationMaster;\n        golemFactory = _golemFactory;\n        fundingStartBlock = _fundingStartBlock;\n        fundingEndBlock = _fundingEndBlock;\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    function transfer(address _to, uint256 _value) returns (bool) {\n        // Abort if not in Operational state.\n        if (funding) revert();\n\n        var senderBalance = balances[msg.sender];\n        if (senderBalance >= _value && _value > 0) {\n            senderBalance -= _value;\n            balances[msg.sender] = senderBalance;\n            balances[_to] += _value;\n            Transfer(msg.sender, _to, _value);\n            return true;\n        }\n        return false;\n    }\n\n    function totalSupply() external view returns (uint256) {\n        return totalTokens;\n    }\n\n    function balanceOf(address _owner) external view returns (uint256) {\n        return balances[_owner];\n    }\n\n    // Token migration support:\n\n    \n    \n    \n    function migrate(uint256 _value) external {\n        // Abort if not in Operational Migration state.\n        if (funding) revert();\n        if (migrationAgent == 0) revert();\n\n        // Validate input value.\n        if (_value == 0) revert();\n        if (_value > balances[msg.sender]) revert();\n\n        balances[msg.sender] -= _value;\n        totalTokens -= _value;\n        totalMigrated += _value;\n        MigrationAgent(migrationAgent).migrateFrom(msg.sender, _value);\n        Migrate(msg.sender, migrationAgent, _value);\n    }\n\n    \n\t\n    \n    \n    \n    function setMigrationAgent(address _agent) external {\n        // Abort if not in Operational Normal state.\n        if (funding) revert();\n        if (migrationAgent != 0) revert();\n        if (msg.sender != migrationMaster) revert();\n        migrationAgent = _agent;\n    }\n\n    function setMigrationMaster(address _master) external {\n        if (msg.sender != migrationMaster) revert();\n        if (_master == 0) revert();\n        migrationMaster = _master;\n    }\n\n    // Crowdfunding:\n\n    \n    \n    \n    function create() payable external {\n        // Abort if not in Funding Active state.\n        // The checks are split (instead of using or operator) because it is\n        // cheaper this way.\n        if (!funding) revert();\n        if (block.number < fundingStartBlock) revert();\n        if (block.number > fundingEndBlock) revert();\n\n        // Do not allow creating 0 or more than the cap tokens.\n        if (msg.value == 0) revert();\n        if (msg.value > (tokenCreationCap - totalTokens) / tokenCreationRate)\n            revert();\n\n        var numTokens = msg.value * tokenCreationRate;\n        totalTokens += numTokens;\n\n        // Assign new tokens to the sender\n        balances[msg.sender] += numTokens;\n\n        // Log token creation event\n        Transfer(0, msg.sender, numTokens);\n    }\n\n    \n    \n    \n    \n    \n    \n    function finalize() external {\n        // Abort if not in Funding Success state.\n        if (!funding) revert();\n        if ((block.number <= fundingEndBlock ||\n             totalTokens < tokenCreationMin) &&\n            totalTokens < tokenCreationCap) revert();\n\n        // Switch to Operational state. This is the only place this can happen.\n        funding = false;\n\n        // Create additional GNT for the Golem Factory and developers as\n        // the 18% of total number of tokens.\n        // All additional tokens are transfered to the account controller by\n        // GNTAllocation contract which will not allow using them for 6 months.\n        uint256 percentOfTotal = 18;\n        uint256 additionalTokens =\n            totalTokens * percentOfTotal / (100 - percentOfTotal);\n        totalTokens += additionalTokens;\n        balances[lockedAllocation] += additionalTokens;\n        Transfer(0, lockedAllocation, additionalTokens);\n\n        // Transfer ETH to the Golem Factory address.\n        if (!golemFactory.send(this.balance)) revert();\n    }\n\n    \n    \n    \n    function refund() external {\n        // Abort if not in Funding Failure state.\n        if (!funding) revert();\n        if (block.number <= fundingEndBlock) revert();\n        if (totalTokens >= tokenCreationMin) revert();\n\n        var gntValue = balances[msg.sender];\n        if (gntValue == 0) revert();\n        balances[msg.sender] = 0;\n        totalTokens -= gntValue;\n\n        var ethValue = gntValue / tokenCreationRate;\n        Refund(msg.sender, ethValue);\n        if (!msg.sender.send(ethValue)) revert();\n    }\n}\n",
        "function": null,
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GolemNetworkToken.sol",
        "vulnerability": "MissingInputValidation",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity ^0.4.16;\n\n\n// SWC-102-Outdated Compiler Version: L2\ncontract MigrationAgent {\n    function migrateFrom(address _from, uint256 _value);\n}\n\ncontract GNTAllocation {\n    function GNTAllocation(address _golemFactory) {}\n}\n\n\ncontract GolemNetworkToken {\n    string public constant name = \"Test Golem Network Token\";\n    string public constant symbol = \"tGNT\";\n    uint8 public constant decimals = 18;  // 18 decimal places, the same as ETH.\n\n    uint256 public constant tokenCreationRate = 10000000000;\n\n    // The funding cap in weis.\n    uint256 public constant tokenCreationCap = 82 finney * tokenCreationRate;\n    uint256 public constant tokenCreationMin = 15 finney * tokenCreationRate;\n\n    uint256 public fundingStartBlock;\n    uint256 public fundingEndBlock;\n\n    // The flag indicates if the GNT contract is in Funding state.\n    bool public funding = true;\n\n    // Receives ETH and its own GNT endowment.\n    address public golemFactory;\n\n    // Has control over token migration to next version of token.\n    address public migrationMaster;\n\n    GNTAllocation lockedAllocation;\n\n    // The current total token supply.\n    uint256 public totalTokens;\n\n    mapping (address => uint256) balances;\n\n    address public migrationAgent;\n    uint256 public totalMigrated;\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Migrate(address indexed _from, address indexed _to, uint256 _value);\n    event Refund(address indexed _from, uint256 _value);\n\n    function GolemNetworkToken(address _golemFactory,\n                               address _migrationMaster,\n                               uint256 _fundingStartBlock,\n                               uint256 _fundingEndBlock) {\n\n        if (_golemFactory == 0) revert();\n        if (_migrationMaster == 0) revert();\n        if (_fundingStartBlock <= block.number) revert();\n        if (_fundingEndBlock   <= _fundingStartBlock) revert();\n\n        lockedAllocation = new GNTAllocation(_golemFactory);\n        migrationMaster = _migrationMaster;\n        golemFactory = _golemFactory;\n        fundingStartBlock = _fundingStartBlock;\n        fundingEndBlock = _fundingEndBlock;\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    function transfer(address _to, uint256 _value) returns (bool) {\n        // Abort if not in Operational state.\n        if (funding) revert();\n\n        var senderBalance = balances[msg.sender];\n        if (senderBalance >= _value && _value > 0) {\n            senderBalance -= _value;\n            balances[msg.sender] = senderBalance;\n            balances[_to] += _value;\n            Transfer(msg.sender, _to, _value);\n            return true;\n        }\n        return false;\n    }\n\n    function totalSupply() external view returns (uint256) {\n        return totalTokens;\n    }\n\n    function balanceOf(address _owner) external view returns (uint256) {\n        return balances[_owner];\n    }\n\n    // Token migration support:\n\n    \n    \n    \n    function migrate(uint256 _value) external {\n        // Abort if not in Operational Migration state.\n        if (funding) revert();\n        if (migrationAgent == 0) revert();\n\n        // Validate input value.\n        if (_value == 0) revert();\n        if (_value > balances[msg.sender]) revert();\n\n        balances[msg.sender] -= _value;\n        totalTokens -= _value;\n        totalMigrated += _value;\n        MigrationAgent(migrationAgent).migrateFrom(msg.sender, _value);\n        Migrate(msg.sender, migrationAgent, _value);\n    }\n\n    \n\t\n    \n    \n    \n    function setMigrationAgent(address _agent) external {\n        // Abort if not in Operational Normal state.\n        if (funding) revert();\n        if (migrationAgent != 0) revert();\n        if (msg.sender != migrationMaster) revert();\n        migrationAgent = _agent;\n    }\n\n    function setMigrationMaster(address _master) external {\n        if (msg.sender != migrationMaster) revert();\n        if (_master == 0) revert();\n        migrationMaster = _master;\n    }\n\n    // Crowdfunding:\n\n    \n    \n    \n    function create() payable external {\n        // Abort if not in Funding Active state.\n        // The checks are split (instead of using or operator) because it is\n        // cheaper this way.\n        if (!funding) revert();\n        if (block.number < fundingStartBlock) revert();\n        if (block.number > fundingEndBlock) revert();\n\n        // Do not allow creating 0 or more than the cap tokens.\n        if (msg.value == 0) revert();\n        if (msg.value > (tokenCreationCap - totalTokens) / tokenCreationRate)\n            revert();\n\n        var numTokens = msg.value * tokenCreationRate;\n        totalTokens += numTokens;\n\n        // Assign new tokens to the sender\n        balances[msg.sender] += numTokens;\n\n        // Log token creation event\n        Transfer(0, msg.sender, numTokens);\n    }\n\n    \n    \n    \n    \n    \n    \n    function finalize() external {\n        // Abort if not in Funding Success state.\n        if (!funding) revert();\n        if ((block.number <= fundingEndBlock ||\n             totalTokens < tokenCreationMin) &&\n            totalTokens < tokenCreationCap) revert();\n\n        // Switch to Operational state. This is the only place this can happen.\n        funding = false;\n\n        // Create additional GNT for the Golem Factory and developers as\n        // the 18% of total number of tokens.\n        // All additional tokens are transfered to the account controller by\n        // GNTAllocation contract which will not allow using them for 6 months.\n        uint256 percentOfTotal = 18;\n        uint256 additionalTokens =\n            totalTokens * percentOfTotal / (100 - percentOfTotal);\n        totalTokens += additionalTokens;\n        balances[lockedAllocation] += additionalTokens;\n        Transfer(0, lockedAllocation, additionalTokens);\n\n        // Transfer ETH to the Golem Factory address.\n        if (!golemFactory.send(this.balance)) revert();\n    }\n\n    \n    \n    \n    function refund() external {\n        // Abort if not in Funding Failure state.\n        if (!funding) revert();\n        if (block.number <= fundingEndBlock) revert();\n        if (totalTokens >= tokenCreationMin) revert();\n\n        var gntValue = balances[msg.sender];\n        if (gntValue == 0) revert();\n        balances[msg.sender] = 0;\n        totalTokens -= gntValue;\n\n        var ethValue = gntValue / tokenCreationRate;\n        Refund(msg.sender, ethValue);\n        if (!msg.sender.send(ethValue)) revert();\n    }\n}\n\n// SWC-102-Outdated Compiler Version: L2\n/* Holds all tGNT after simulated crowdfunding on testnet. */\n/* To receive some tGNT just call create. */\ncontract Faucet {\n    GolemNetworkToken public token;\n\n    function Faucet(address _token) {\n        token = GolemNetworkToken(_token);\n    }\n\n    // Note that this function does not actually create tGNT!\n    // Name was unchanged not to break API\n    function create() external {\n        uint256 tokens = 1000 * 10 ** uint256(token.decimals());\n        if (token.balanceOf(msg.sender) >= tokens) revert();\n        token.transfer(msg.sender, tokens);\n    }\n}\n",
        "function": null,
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/Faucet.sol",
        "vulnerability": "MissingInputValidation",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity >=0.4.25 <0.7.0;\n\n\n// SPDX-License-Identifier: MIT\n// SWC-103-Floating Pragma: L3\ncontract Migrations {\n  address public owner;\n  uint public last_completed_migration;\n\n  modifier restricted() {\n    if (msg.sender == owner) _;\n  }\n\n  constructor() public {\n    owner = msg.sender;\n  }\n\n  function setCompleted(uint completed) public restricted {\n    last_completed_migration = completed;\n  }\n}\n",
        "function": null,
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/QuillAudits-AliumSwap Smart Contract/alium-swap-periphery-6aff4c5ad4695b77358eae0627c98d72621256bc/contracts/Migrations.sol",
        "vulnerability": "MissingInputValidation",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity ^0.4.4;\n\n\n//SWC-101-Integer Overflow and Underflow: All\n//SWC-102-Outdated Compiler Version: All\n/**\n * @title ROSCA on a blockchain.\n *\n * A ROSCA (Rotating and Savings Credit Association) is an agreement between\n * trusted friends to contribute funds on a periodic basis to a \"pot\", and in\n * each round one of the participants receives the pot (termed \"winner\").\n * The winner is selected as the person who makes the lowest bid in that round\n * among those who have not won a bid before.\n * The discount (gap between bid and total round contributions) is dispersed\n * evenly between the participants.\n */\ncontract ROSCA {\n\n  \n  // CONSTANTS\n  \n  uint64 constant internal MIN_CONTRIBUTION_SIZE = 1 finney;  // 1e-3 ether\n  uint128 constant internal MAX_CONTRIBUTION_SIZE = 10 ether;\n\n  // Maximum fee (in 1/1000s) from dispersements that is shared between foreperson and other stakeholders..\n  uint16 constant internal MAX_FEE_IN_THOUSANDTHS = 20;\n\n  // Start time of the ROSCA must be at least this much time ahead of when the ROSCA is created\n  uint32 constant internal MINIMUM_TIME_BEFORE_ROSCA_START = 1 days;\n\n  uint8 constant internal MIN_ROUND_PERIOD_IN_DAYS = 1;\n  uint8 constant internal MAX_ROUND_PERIOD_IN_DAYS = 30;\n  // the winning bid must be at least this much of the maximum (aka default) pot value\n  uint8 constant internal MIN_DISTRIBUTION_PERCENT = 65;\n\n  // Every new bid has to be at most this much of the previous lowest bid\n  uint8 constant internal MAX_NEXT_BID_RATIO = 98;\n\n  // TODO: MUST change this prior to production. Currently this is accounts[9] of the testrpc config\n  // used in tests.\n  // Address from which fees can be withdrawn.\n  address constant internal FEE_ADDRESS = 0x1df62f291b2e969fb0849d99d9ce41e2f137006e;\n\n  // TODO(ron): replace this with an actual wallet. Right now this is accounts[9] of the testrpc used\n  // by tests.\n  // WeTrust's account from which Escape Hatch can be enanbled.\n  address constant internal ESCAPE_HATCH_ENABLER = 0x1df62f291b2e969fb0849d99d9ce41e2f137006e;\n\n  \n  // EVENTS\n  \n  event LogContributionMade(address user, uint256 amount);\n  event LogStartOfRound(uint256 currentRound);\n  event LogNewLowestBid(uint256 bid,address winnerAddress);\n  event LogRoundFundsReleased(address winnerAddress, uint256 amountInWei);\n  event LogRoundNoWinner(uint256 currentRound);\n  event LogFundsWithdrawal(address user, uint256 amount);\n  event LogForepersonSurplusWithdrawal(uint256 amount);\n  // Fired when withdrawer is entitled for a larger amount than the contract\n  // actually holds (excluding fees). A LogFundsWithdrawal will follow\n  // this event with the actual amount released, if send() is successful.\n  event LogCannotWithdrawFully(uint256 creditAmount);\n  event LogUnsuccessfulBid(address bidder,uint256 bidInWei,uint256 lowestBid);\n  event LogEndOfROSCA();\n\n  // Escape hatch related events.\n  event LogEscapeHatchEnabled();\n  event LogEscapeHatchActivated();\n  event LogEmergencyWithdrawalPerformed(uint256 fundsDispersed);\n\n  \n  // STORAGE VARIABLES\n  \n\n  // ROSCA parameters\n  uint16 internal roundPeriodInDays;\n  uint16 internal serviceFeeInThousandths;\n  uint16 internal currentRound;  // set to 0 when ROSCA is created, becomes 1 when ROSCA starts\n  address internal foreperson;\n  uint128 internal contributionSize;\n  uint256 internal startTime;\n\n  // ROSCA state\n  bool internal endOfROSCA = false;\n  bool internal forepersonSurplusCollected = false;\n  // A discount is the difference between a winning bid and the pot value. totalDiscounts is the amount\n  // of discounts accumulated so far, divided by the number of ROSCA participants.\n  uint256 internal totalDiscounts = 0;\n\n  // Amount of fees reserved in the contract for fees.\n  uint256 internal totalFees = 0;\n\n  // Round state variables\n  uint256 internal lowestBid = 0;\n  address internal winnerAddress = 0;  // bidder who bid the lowest so far\n\n  mapping(address => User) internal members;\n  address[] internal membersAddresses;  // for iterating through members' addresses\n\n  // Other state\n  // An escape hatch is used in case a major vulnerability is discovered in the contract code.\n  // The following procedure is then put into action:\n  // 1. WeTrust sends a transaction to make escapeHatchEnabled true.\n  // 2. foreperson is notified and can decide to activate the escapeHatch.\n  // 3. If escape hatch is activated, no contributions and/or withdrawals are allowed. The foreperson\n  //    may call withdraw() to withdraw all of the contract's funds and then disperse them offline\n  //    among the participants.\n  bool internal escapeHatchEnabled = false;\n  bool internal escapeHatchActive = false;\n\n  struct User {\n    uint256 credit;  // amount of funds user has contributed - winnings (not including discounts) so far\n    bool debt; // true if user won the pot while not in good standing and is still not in good standing\n    bool paid; // yes if the member had won a Round\n    bool alive; // needed to check if a member is indeed a member\n  }\n\n  \n  // MODIFIERS\n  \n  modifier onlyFromMember {\n    if (!members[msg.sender].alive) {\n      throw;\n    }\n    _;\n  }\n\n  modifier onlyFromForeperson {\n    if (msg.sender != foreperson) {\n      throw;\n    }\n    _;\n  }\n\n  modifier onlyFromFeeAddress {\n    if (msg.sender != FEE_ADDRESS) {\n      throw;\n    }\n    _;\n  }\n\n  modifier roscaNotEnded {\n    if (endOfROSCA) {\n      throw;\n    }\n    _;\n  }\n\n  modifier roscaEnded {\n    if (!endOfROSCA) {\n      throw;\n    }\n    _;\n  }\n\n  modifier onlyIfEscapeHatchActive {\n    if (!escapeHatchActive) {\n      throw;\n    }\n    _;\n  }\n\n  modifier onlyIfEscapeHatchInactive {\n    if (escapeHatchActive) {\n      throw;\n    }\n    _;\n  }\n\n  modifier onlyFromEscapeHatchEnabler {\n    if (msg.sender != ESCAPE_HATCH_ENABLER) {\n      throw;\n    }\n    _;\n  }\n\n  \n  // FUNCTIONS\n  \n\n  /**\n    * @dev Creates a new ROSCA and initializes the necessary variables. ROSCA starts after startTime.\n    * Creator of the contract becomes foreperson and a participant.\n    */\n  function ROSCA (\n      uint16 roundPeriodInDays_,\n      uint128 contributionSize_,\n      uint256 startTime_,\n      address[] members_,\n      uint16 serviceFeeInThousandths_) {\n    if (roundPeriodInDays_ < MIN_ROUND_PERIOD_IN_DAYS || roundPeriodInDays_ > MAX_ROUND_PERIOD_IN_DAYS) {\n      throw;\n    }\n    roundPeriodInDays = roundPeriodInDays_;\n\n    if (contributionSize_ < MIN_CONTRIBUTION_SIZE || contributionSize_ > MAX_CONTRIBUTION_SIZE) {\n      throw;\n    }\n    contributionSize = contributionSize_;\n    //SWC-116-Block values as a proxy for time: L199\n    if (startTime_ < (now + MINIMUM_TIME_BEFORE_ROSCA_START)) {\n      throw;\n    }\n    startTime = startTime_;\n    if (serviceFeeInThousandths_ > MAX_FEE_IN_THOUSANDTHS) {\n      throw;\n    }\n    serviceFeeInThousandths = serviceFeeInThousandths_;\n\n    foreperson = msg.sender;\n    addMember(msg.sender);\n\n    for (uint16 i = 0; i < members_.length; i++) {\n      addMember(members_[i]);\n    }\n  }\n\n  function addMember(address newMember) internal {\n    if (members[newMember].alive) {  // already registered\n      throw;\n    }\n    members[newMember] = User({paid: false , credit: 0, alive: true, debt: false});\n    membersAddresses.push(newMember);\n  }\n\n  /**\n    * @dev Calculates the winner of the current round's pot, and credits her.\n    * If there were no bids during the round, winner is selected semi-randomly.\n    * Priority is given to non-delinquent participants.\n    */\n  function startRound() roscaNotEnded external {\n    uint256 roundStartTime = startTime + (uint(currentRound)  * roundPeriodInDays * 1 days);\n    if (now < roundStartTime ) {  // too early to start a new round.\n      throw;\n    }\n\n    if (currentRound != 0) {\n      cleanUpPreviousRound();\n    }\n    if (currentRound < membersAddresses.length) {\n      lowestBid = 0;\n      winnerAddress = 0;\n      currentRound++;\n      LogStartOfRound(currentRound);\n    } else {\n        endOfROSCA = true;\n        LogEndOfROSCA();\n    }\n  }\n\n  function cleanUpPreviousRound() internal {\n    address delinquentWinner = 0x0;\n    uint256 winnerIndex;\n    bool winnerSelectedThroughBid = (winnerAddress != 0);\n    uint16 numUnpaidParticipants = uint16(membersAddresses.length) - (currentRound - 1);\n    if (winnerAddress == 0) {\n      // There was no bid in this round. Find an unpaid address for this epoch.\n      // Give priority to members in good standing (not delinquent).\n      // Note this randomness does not require high security, that's why we feel ok with using the block's timestamp.\n      // Everyone will be paid out eventually.\n      uint256 semi_random = now % numUnpaidParticipants;\n      for (uint16 i = 0; i < numUnpaidParticipants; i++) {\n        uint256 index = (semi_random + i) % numUnpaidParticipants;\n        address candidate = membersAddresses[index];\n        if (!members[candidate].paid) {\n          winnerIndex = index;\n          if (members[candidate].credit + totalDiscounts >= (currentRound * contributionSize)) {\n            // We found a non-delinquent winner.\n            winnerAddress = candidate;\n            break;\n          }\n          delinquentWinner = candidate;\n        }\n      }\n      if (winnerAddress == 0) {  // we did not find any non-delinquent winner.\n        // Perform some basic sanity checks.\n        if (delinquentWinner == 0 || members[delinquentWinner].paid) throw;\n        winnerAddress = delinquentWinner;\n        // Set the flag to true so we know this user cannot withdraw until debt has been paid.\n        members[winnerAddress].debt = true;\n      }\n      // Set lowestBid to the right value since there was no winning bid.\n      lowestBid = contributionSize * membersAddresses.length;\n    }\n    // We keep the unpaid participants at positions [0..num_participants - current_round) so that we can uniformly select\n    // among them (if we didn't do that and there were a few consecutive paid participants, we'll be more likely to select the\n    // next unpaid member).\n    swapWinner(winnerIndex, winnerSelectedThroughBid, numUnpaidParticipants - 1);\n    //SWC-135-Code With No Effects: L288\n    uint256 currentRoundTotalDiscounts = removeFees(contributionSize * membersAddresses.length - lowestBid);\n    totalDiscounts += currentRoundTotalDiscounts / membersAddresses.length;\n    members[winnerAddress].credit += removeFees(lowestBid);\n    members[winnerAddress].paid = true;\n    LogRoundFundsReleased(winnerAddress, lowestBid);\n    recalculateTotalFees();\n  }\n\n  // Recalculates that total fees that should be allocated in the contract.\n  function recalculateTotalFees() {\n    // Start with the max theoretical fees if no one was delinquent, and\n    // reduce funds not actually contributed because of delinquencies.\n    uint256 requiredContributions = currentRound * contributionSize;\n    uint256 grossTotalFees = requiredContributions * membersAddresses.length;\n\n    for (uint16 j = 0; j < membersAddresses.length; j++) {\n      User member = members[membersAddresses[j]];\n      uint256 credit = member.credit;\n      uint256 debit = requiredContributions;\n      if (member.debt) {\n        // As a delinquent member won, we'll reduce the funds subject to fees by the default pot they must have won (since\n        // they could not bid), to correctly calculate their delinquency.\n        debit += removeFees(membersAddresses.length * contributionSize);\n      }\n      if (credit + totalDiscounts < debit) {\n        grossTotalFees -= debit - credit - totalDiscounts;\n      }\n    }\n    //SWC-135-Code With No Effects: L316\n    totalFees = grossTotalFees * serviceFeeInThousandths / 1000;\n  }\n\n  // Swaps membersAddresses[winnerIndex] with membersAddresses[indexToSwap]. However,\n  // if winner was selected through a bid, winnerIndex was not set, and we find it first.\n  function swapWinner(\n    uint256 winnerIndex, bool winnerSelectedThroughBid, uint256 indexToSwap) internal {\n    if (winnerSelectedThroughBid) {\n      // Since winner was selected through a bid, we were not able to set winnerIndex, so search\n      // for the winner among the unpaid participants.\n      for (uint16 i = 0; i <= indexToSwap; i++) {\n        if (membersAddresses[i] == winnerAddress) {\n          winnerIndex = i;\n          break;\n        }\n      }\n    }\n    // We now want to swap winnerIndex with indexToSwap, but we already know membersAddresses[winnerIndex] == winnerAddress.\n    membersAddresses[winnerIndex] = membersAddresses[indexToSwap];\n    membersAddresses[indexToSwap] = winnerAddress;\n  }\n\n  // Calculates the specified amount net amount after fees.\n  function removeFees(uint256 amount) internal returns (uint256) {\n    // First multiply to reduce roundoff errors.\n    //SWC-135-Code With No Effects: L342\n    return amount * (1000 - serviceFeeInThousandths) / 1000;\n  }\n\n  /**\n   * Processes a periodic contribution. msg.sender must be one of the participants and will thus\n   * identify the contributor.\n   *\n   * Any excess funds are withdrawable through withdraw() without fee.\n   */\n  function contribute() payable onlyFromMember roscaNotEnded onlyIfEscapeHatchInactive external {\n    User member = members[msg.sender];\n    member.credit += msg.value;\n    if (member.debt) {\n      // Check if user comes out of debt. We know they won an entire pot as they could not bid,\n      // so we check whether their credit w/o that winning is non-delinquent.\n      // check that credit must defaultPot (when debt is set to true, defaultPot was added to credit as winnings) +\n      // currentRound in order to be out of debt\n      uint256 requiredContributions = currentRound * contributionSize;\n      if (member.credit + totalDiscounts - removeFees(membersAddresses.length * contributionSize) >= requiredContributions) {\n          member.debt = false;\n      }\n    }\n\n    LogContributionMade(msg.sender, msg.value);\n  }\n\n  /**\n   * Registers a bid from msg.sender. Participant should call this method\n   * only if all of the following holds for her:\n   * + Never won a round.\n   * + Is in good standing (i.e. actual contributions, including this round's,\n   *   plus any past earned discounts are together greater than required contributions).\n   * + New bid is lower than the lowest bid so far.\n   */\n  function bid(uint256 bidInWei) onlyFromMember roscaNotEnded onlyIfEscapeHatchInactive external {\n    if (members[msg.sender].paid  ||\n        currentRound == 0 ||  // ROSCA hasn't started yet\n        // participant not in good standing\n        members[msg.sender].credit + totalDiscounts < (currentRound * contributionSize) ||\n        // bid is less than minimum allowed\n        //SWC-135-Code With No Effects: L384\n        bidInWei < contributionSize * membersAddresses.length * MIN_DISTRIBUTION_PERCENT / 100) {\n      throw;\n    }\n\n    // If winnerAddress is 0, this is the first bid, hence allow full pot.\n    // Otherwise, make sure bid is low enough compared to previous bid.\n    //SWC-135-Code With No Effects: L391\n    uint256 maxAllowedBid = winnerAddress == 0\n        ? contributionSize * membersAddresses.length\n        : lowestBid * MAX_NEXT_BID_RATIO / 100;\n    if (bidInWei > maxAllowedBid) {\n      // We don't throw as this may be hard for the frontend to predict on the\n      // one hand because someone else might have bid at the same time,\n      // and we'd like to avoid wasting the caller's gas.\n      LogUnsuccessfulBid(msg.sender, bidInWei, lowestBid);\n      return;\n    }\n    lowestBid = bidInWei;\n    winnerAddress = msg.sender;\n    LogNewLowestBid(lowestBid, winnerAddress);\n  }\n\n  /**\n   * Withdraws available funds for msg.sender.\n   */\n  function withdraw() onlyFromMember onlyIfEscapeHatchInactive external returns(bool success) {\n    if (members[msg.sender].debt && !endOfROSCA) {  // delinquent winners need to first pay their debt\n      throw;\n    }\n    uint256 totalCredit = members[msg.sender].credit + totalDiscounts;\n\n    uint256 totalDebit = members[msg.sender].debt\n        ? removeFees(membersAddresses.length * contributionSize)  // this must be end of rosca\n        : currentRound * contributionSize;\n    if (totalDebit >= totalCredit) {  // nothing to withdraw\n        throw;\n    }\n\n    uint256 amountToWithdraw = totalCredit - totalDebit;\n    uint256 amountAvailable = this.balance - totalFees;\n\n    if (amountAvailable < amountToWithdraw) {\n      // This may happen if some participants are delinquent.\n      LogCannotWithdrawFully(amountToWithdraw);\n      amountToWithdraw = amountAvailable;\n    }\n    members[msg.sender].credit -= amountToWithdraw;\n    if (!msg.sender.send(amountToWithdraw)) {   // if the send() fails, restore the allowance\n      // No need to call throw here, just reset the amount owing. This may happen\n      // for nonmalicious reasons, e.g. the receiving contract running out of gas.\n      members[msg.sender].credit += amountToWithdraw;\n      return false;\n    }\n    LogFundsWithdrawal(msg.sender, amountToWithdraw);\n    return true;\n  }\n\n  /**\n   * Returns how much a user can withdraw (positive return value),\n   * or how much they need to contribute to be in good standing (negative return value)\n   */\n  //SWC-135-Code With No Effects: L446-L456 \n  function getParticipantBalance(address user) onlyFromMember external constant returns(int256) {\n    int256 totalCredit = int256(members[user].credit + totalDiscounts);\n\n    // if rosca have ended, we don't need to subtract as totalDebit should equal to default winnings\n    if (members[user].debt && !endOfROSCA) {\n        totalCredit -= int256(removeFees(membersAddresses.length * contributionSize));\n    }\n    int256 totalDebit = int256(currentRound * contributionSize);\n\n    return totalCredit - totalDebit;\n  }\n  \n\n  /**\n   * Returns the amount of funds this contract holds excluding fees. This is\n   * the amount withdrawable by participants.\n   */\n  function getContractNetBalance() external constant returns(uint256) {\n    return this.balance - totalFees;\n  }\n\n  /**\n   * @dev Allows the foreperson to retrieve any surplus funds, one roundPeriodInDays after\n   * the end of the ROSCA.\n   *\n   * Note that startRound() must be called first after the last round, as it\n   * does the bookeeping of that round.\n   */\n  function endOfROSCARetrieveSurplus() onlyFromForeperson roscaEnded external returns (bool) {\n    uint256 roscaCollectionTime = startTime + ((membersAddresses.length + 1) * roundPeriodInDays * 1 days);\n    if (now < roscaCollectionTime || forepersonSurplusCollected) {\n        throw;\n    }\n\n    forepersonSurplusCollected = true;\n    uint256 amountToCollect = this.balance - totalFees;\n    if (!foreperson.send(amountToCollect)) {   // if the send() fails, restore the flag\n      // No need to call throw here, just reset the amount owing. This may happen\n      // for nonmalicious reasons, e.g. the receiving contract running out of gas.\n      forepersonSurplusCollected = false;\n      return false;\n    } else {\n      LogForepersonSurplusWithdrawal(amountToCollect);\n    }\n  }\n\n  /**\n   * @dev Allows the fee collector to extract the fees in the contract. Can be called\n   * only ine roundPeriodInDays after the end of the ROSCA.\n   *\n   * Note that startRound() must be called first after the last round, as it\n   * does the bookeeping of that round.\n   */\n  function endOfROSCARetrieveFees() onlyFromFeeAddress roscaEnded external returns (bool) {\n    uint256 tempTotalFees = totalFees;  // prevent re-entry.\n    totalFees = 0;\n    if (!FEE_ADDRESS.send(tempTotalFees)) {   // if the send() fails, restore totalFees\n      // No need to call throw here, just reset the amount owing. This may happen\n      // for nonmalicious reasons, e.g. the receiving contract running out of gas.\n      totalFees = tempTotalFees;\n      return false;\n    } else {\n      //SWC-135-Code With No Effects: L507\n      LogFundsWithdrawal(FEE_ADDRESS, totalFees);\n    }\n  }\n\n  /**\n   * Allows the Escape Hatch Enabler (controlled by WeTrust) to enable the Escape Hatch in case of\n   * emergency (e.g. a major vulnerability found in the contract).\n   */\n  function enableEscapeHatch() onlyFromEscapeHatchEnabler external {\n    escapeHatchEnabled = true;\n    LogEscapeHatchEnabled();\n  }\n\n  /**\n   * Allows the foreperson to active the Escape Hatch after the Enabled enabled it. This will freeze all\n   * contributions and withdrawals, and allow the foreperson to retrieve all funds into their own account,\n   * to be dispersed offline to the other participants.\n   */\n  function activateEscapeHatch() onlyFromForeperson external {\n    if (!escapeHatchEnabled) {\n      throw;\n    }\n    escapeHatchActive = true;\n    LogEscapeHatchActivated();\n  }\n\n  /**\n   * Can only be called by the foreperson after an escape hatch is activated,\n   * this sends all the funds to the foreperson by selfdestructing this contract.\n   */\n  function emergencyWithdrawal() onlyFromForeperson onlyIfEscapeHatchActive {\n    LogEmergencyWithdrawalPerformed(this.balance);\n    // Send everything, including potential fees, to foreperson to disperse offline to participants.\n    selfdestruct(foreperson);\n  }\n}\n",
        "function": null,
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/openzeppelin-WeTrust_ROSCA_contract_code/rosca-contracts-2af29be97d529488f5488fe0592f9e6b3585254f/contracts/ROSCA.sol",
        "vulnerability": "TODReceiver",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity ^0.4.4;\n\n\n//SWC-101-Integer Overflow and Underflow: All\n//SWC-102-Outdated Compiler Version: All\n/**\n * @title ROSCA on a blockchain.\n *\n * A ROSCA (Rotating and Savings Credit Association) is an agreement between\n * trusted friends to contribute funds on a periodic basis to a \"pot\", and in\n * each round one of the participants receives the pot (termed \"winner\").\n * The winner is selected as the person who makes the lowest bid in that round\n * among those who have not won a bid before.\n * The discount (gap between bid and total round contributions) is dispersed\n * evenly between the participants.\n */\ncontract ROSCA {\n\n  \n  // CONSTANTS\n  \n  uint64 constant internal MIN_CONTRIBUTION_SIZE = 1 finney;  // 1e-3 ether\n  uint128 constant internal MAX_CONTRIBUTION_SIZE = 10 ether;\n\n  // Maximum fee (in 1/1000s) from dispersements that is shared between foreperson and other stakeholders..\n  uint16 constant internal MAX_FEE_IN_THOUSANDTHS = 20;\n\n  // Start time of the ROSCA must be at least this much time ahead of when the ROSCA is created\n  uint32 constant internal MINIMUM_TIME_BEFORE_ROSCA_START = 1 days;\n\n  uint8 constant internal MIN_ROUND_PERIOD_IN_DAYS = 1;\n  uint8 constant internal MAX_ROUND_PERIOD_IN_DAYS = 30;\n  // the winning bid must be at least this much of the maximum (aka default) pot value\n  uint8 constant internal MIN_DISTRIBUTION_PERCENT = 65;\n\n  // Every new bid has to be at most this much of the previous lowest bid\n  uint8 constant internal MAX_NEXT_BID_RATIO = 98;\n\n  // TODO: MUST change this prior to production. Currently this is accounts[9] of the testrpc config\n  // used in tests.\n  // Address from which fees can be withdrawn.\n  address constant internal FEE_ADDRESS = 0x1df62f291b2e969fb0849d99d9ce41e2f137006e;\n\n  // TODO(ron): replace this with an actual wallet. Right now this is accounts[9] of the testrpc used\n  // by tests.\n  // WeTrust's account from which Escape Hatch can be enanbled.\n  address constant internal ESCAPE_HATCH_ENABLER = 0x1df62f291b2e969fb0849d99d9ce41e2f137006e;\n\n  \n  // EVENTS\n  \n  event LogContributionMade(address user, uint256 amount);\n  event LogStartOfRound(uint256 currentRound);\n  event LogNewLowestBid(uint256 bid,address winnerAddress);\n  event LogRoundFundsReleased(address winnerAddress, uint256 amountInWei);\n  event LogRoundNoWinner(uint256 currentRound);\n  event LogFundsWithdrawal(address user, uint256 amount);\n  event LogForepersonSurplusWithdrawal(uint256 amount);\n  // Fired when withdrawer is entitled for a larger amount than the contract\n  // actually holds (excluding fees). A LogFundsWithdrawal will follow\n  // this event with the actual amount released, if send() is successful.\n  event LogCannotWithdrawFully(uint256 creditAmount);\n  event LogUnsuccessfulBid(address bidder,uint256 bidInWei,uint256 lowestBid);\n  event LogEndOfROSCA();\n\n  // Escape hatch related events.\n  event LogEscapeHatchEnabled();\n  event LogEscapeHatchActivated();\n  event LogEmergencyWithdrawalPerformed(uint256 fundsDispersed);\n\n  \n  // STORAGE VARIABLES\n  \n\n  // ROSCA parameters\n  uint16 internal roundPeriodInDays;\n  uint16 internal serviceFeeInThousandths;\n  uint16 internal currentRound;  // set to 0 when ROSCA is created, becomes 1 when ROSCA starts\n  address internal foreperson;\n  uint128 internal contributionSize;\n  uint256 internal startTime;\n\n  // ROSCA state\n  bool internal endOfROSCA = false;\n  bool internal forepersonSurplusCollected = false;\n  // A discount is the difference between a winning bid and the pot value. totalDiscounts is the amount\n  // of discounts accumulated so far, divided by the number of ROSCA participants.\n  uint256 internal totalDiscounts = 0;\n\n  // Amount of fees reserved in the contract for fees.\n  uint256 internal totalFees = 0;\n\n  // Round state variables\n  uint256 internal lowestBid = 0;\n  address internal winnerAddress = 0;  // bidder who bid the lowest so far\n\n  mapping(address => User) internal members;\n  address[] internal membersAddresses;  // for iterating through members' addresses\n\n  // Other state\n  // An escape hatch is used in case a major vulnerability is discovered in the contract code.\n  // The following procedure is then put into action:\n  // 1. WeTrust sends a transaction to make escapeHatchEnabled true.\n  // 2. foreperson is notified and can decide to activate the escapeHatch.\n  // 3. If escape hatch is activated, no contributions and/or withdrawals are allowed. The foreperson\n  //    may call withdraw() to withdraw all of the contract's funds and then disperse them offline\n  //    among the participants.\n  bool internal escapeHatchEnabled = false;\n  bool internal escapeHatchActive = false;\n\n  struct User {\n    uint256 credit;  // amount of funds user has contributed - winnings (not including discounts) so far\n    bool debt; // true if user won the pot while not in good standing and is still not in good standing\n    bool paid; // yes if the member had won a Round\n    bool alive; // needed to check if a member is indeed a member\n  }\n\n  \n  // MODIFIERS\n  \n  modifier onlyFromMember {\n    if (!members[msg.sender].alive) {\n      throw;\n    }\n    _;\n  }\n\n  modifier onlyFromForeperson {\n    if (msg.sender != foreperson) {\n      throw;\n    }\n    _;\n  }\n\n  modifier onlyFromFeeAddress {\n    if (msg.sender != FEE_ADDRESS) {\n      throw;\n    }\n    _;\n  }\n\n  modifier roscaNotEnded {\n    if (endOfROSCA) {\n      throw;\n    }\n    _;\n  }\n\n  modifier roscaEnded {\n    if (!endOfROSCA) {\n      throw;\n    }\n    _;\n  }\n\n  modifier onlyIfEscapeHatchActive {\n    if (!escapeHatchActive) {\n      throw;\n    }\n    _;\n  }\n\n  modifier onlyIfEscapeHatchInactive {\n    if (escapeHatchActive) {\n      throw;\n    }\n    _;\n  }\n\n  modifier onlyFromEscapeHatchEnabler {\n    if (msg.sender != ESCAPE_HATCH_ENABLER) {\n      throw;\n    }\n    _;\n  }\n\n  \n  // FUNCTIONS\n  \n\n  /**\n    * @dev Creates a new ROSCA and initializes the necessary variables. ROSCA starts after startTime.\n    * Creator of the contract becomes foreperson and a participant.\n    */\n  function ROSCA (\n      uint16 roundPeriodInDays_,\n      uint128 contributionSize_,\n      uint256 startTime_,\n      address[] members_,\n      uint16 serviceFeeInThousandths_) {\n    if (roundPeriodInDays_ < MIN_ROUND_PERIOD_IN_DAYS || roundPeriodInDays_ > MAX_ROUND_PERIOD_IN_DAYS) {\n      throw;\n    }\n    roundPeriodInDays = roundPeriodInDays_;\n\n    if (contributionSize_ < MIN_CONTRIBUTION_SIZE || contributionSize_ > MAX_CONTRIBUTION_SIZE) {\n      throw;\n    }\n    contributionSize = contributionSize_;\n    //SWC-116-Block values as a proxy for time: L199\n    if (startTime_ < (now + MINIMUM_TIME_BEFORE_ROSCA_START)) {\n      throw;\n    }\n    startTime = startTime_;\n    if (serviceFeeInThousandths_ > MAX_FEE_IN_THOUSANDTHS) {\n      throw;\n    }\n    serviceFeeInThousandths = serviceFeeInThousandths_;\n\n    foreperson = msg.sender;\n    addMember(msg.sender);\n\n    for (uint16 i = 0; i < members_.length; i++) {\n      addMember(members_[i]);\n    }\n  }\n\n  function addMember(address newMember) internal {\n    if (members[newMember].alive) {  // already registered\n      throw;\n    }\n    members[newMember] = User({paid: false , credit: 0, alive: true, debt: false});\n    membersAddresses.push(newMember);\n  }\n\n  /**\n    * @dev Calculates the winner of the current round's pot, and credits her.\n    * If there were no bids during the round, winner is selected semi-randomly.\n    * Priority is given to non-delinquent participants.\n    */\n  function startRound() roscaNotEnded external {\n    uint256 roundStartTime = startTime + (uint(currentRound)  * roundPeriodInDays * 1 days);\n    if (now < roundStartTime ) {  // too early to start a new round.\n      throw;\n    }\n\n    if (currentRound != 0) {\n      cleanUpPreviousRound();\n    }\n    if (currentRound < membersAddresses.length) {\n      lowestBid = 0;\n      winnerAddress = 0;\n      currentRound++;\n      LogStartOfRound(currentRound);\n    } else {\n        endOfROSCA = true;\n        LogEndOfROSCA();\n    }\n  }\n\n  function cleanUpPreviousRound() internal {\n    address delinquentWinner = 0x0;\n    uint256 winnerIndex;\n    bool winnerSelectedThroughBid = (winnerAddress != 0);\n    uint16 numUnpaidParticipants = uint16(membersAddresses.length) - (currentRound - 1);\n    if (winnerAddress == 0) {\n      // There was no bid in this round. Find an unpaid address for this epoch.\n      // Give priority to members in good standing (not delinquent).\n      // Note this randomness does not require high security, that's why we feel ok with using the block's timestamp.\n      // Everyone will be paid out eventually.\n      uint256 semi_random = now % numUnpaidParticipants;\n      for (uint16 i = 0; i < numUnpaidParticipants; i++) {\n        uint256 index = (semi_random + i) % numUnpaidParticipants;\n        address candidate = membersAddresses[index];\n        if (!members[candidate].paid) {\n          winnerIndex = index;\n          if (members[candidate].credit + totalDiscounts >= (currentRound * contributionSize)) {\n            // We found a non-delinquent winner.\n            winnerAddress = candidate;\n            break;\n          }\n          delinquentWinner = candidate;\n        }\n      }\n      if (winnerAddress == 0) {  // we did not find any non-delinquent winner.\n        // Perform some basic sanity checks.\n        if (delinquentWinner == 0 || members[delinquentWinner].paid) throw;\n        winnerAddress = delinquentWinner;\n        // Set the flag to true so we know this user cannot withdraw until debt has been paid.\n        members[winnerAddress].debt = true;\n      }\n      // Set lowestBid to the right value since there was no winning bid.\n      lowestBid = contributionSize * membersAddresses.length;\n    }\n    // We keep the unpaid participants at positions [0..num_participants - current_round) so that we can uniformly select\n    // among them (if we didn't do that and there were a few consecutive paid participants, we'll be more likely to select the\n    // next unpaid member).\n    swapWinner(winnerIndex, winnerSelectedThroughBid, numUnpaidParticipants - 1);\n    //SWC-135-Code With No Effects: L288\n    uint256 currentRoundTotalDiscounts = removeFees(contributionSize * membersAddresses.length - lowestBid);\n    totalDiscounts += currentRoundTotalDiscounts / membersAddresses.length;\n    members[winnerAddress].credit += removeFees(lowestBid);\n    members[winnerAddress].paid = true;\n    LogRoundFundsReleased(winnerAddress, lowestBid);\n    recalculateTotalFees();\n  }\n\n  // Recalculates that total fees that should be allocated in the contract.\n  function recalculateTotalFees() {\n    // Start with the max theoretical fees if no one was delinquent, and\n    // reduce funds not actually contributed because of delinquencies.\n    uint256 requiredContributions = currentRound * contributionSize;\n    uint256 grossTotalFees = requiredContributions * membersAddresses.length;\n\n    for (uint16 j = 0; j < membersAddresses.length; j++) {\n      User member = members[membersAddresses[j]];\n      uint256 credit = member.credit;\n      uint256 debit = requiredContributions;\n      if (member.debt) {\n        // As a delinquent member won, we'll reduce the funds subject to fees by the default pot they must have won (since\n        // they could not bid), to correctly calculate their delinquency.\n        debit += removeFees(membersAddresses.length * contributionSize);\n      }\n      if (credit + totalDiscounts < debit) {\n        grossTotalFees -= debit - credit - totalDiscounts;\n      }\n    }\n    //SWC-135-Code With No Effects: L316\n    totalFees = grossTotalFees * serviceFeeInThousandths / 1000;\n  }\n\n  // Swaps membersAddresses[winnerIndex] with membersAddresses[indexToSwap]. However,\n  // if winner was selected through a bid, winnerIndex was not set, and we find it first.\n  function swapWinner(\n    uint256 winnerIndex, bool winnerSelectedThroughBid, uint256 indexToSwap) internal {\n    if (winnerSelectedThroughBid) {\n      // Since winner was selected through a bid, we were not able to set winnerIndex, so search\n      // for the winner among the unpaid participants.\n      for (uint16 i = 0; i <= indexToSwap; i++) {\n        if (membersAddresses[i] == winnerAddress) {\n          winnerIndex = i;\n          break;\n        }\n      }\n    }\n    // We now want to swap winnerIndex with indexToSwap, but we already know membersAddresses[winnerIndex] == winnerAddress.\n    membersAddresses[winnerIndex] = membersAddresses[indexToSwap];\n    membersAddresses[indexToSwap] = winnerAddress;\n  }\n\n  // Calculates the specified amount net amount after fees.\n  function removeFees(uint256 amount) internal returns (uint256) {\n    // First multiply to reduce roundoff errors.\n    //SWC-135-Code With No Effects: L342\n    return amount * (1000 - serviceFeeInThousandths) / 1000;\n  }\n\n  /**\n   * Processes a periodic contribution. msg.sender must be one of the participants and will thus\n   * identify the contributor.\n   *\n   * Any excess funds are withdrawable through withdraw() without fee.\n   */\n  function contribute() payable onlyFromMember roscaNotEnded onlyIfEscapeHatchInactive external {\n    User member = members[msg.sender];\n    member.credit += msg.value;\n    if (member.debt) {\n      // Check if user comes out of debt. We know they won an entire pot as they could not bid,\n      // so we check whether their credit w/o that winning is non-delinquent.\n      // check that credit must defaultPot (when debt is set to true, defaultPot was added to credit as winnings) +\n      // currentRound in order to be out of debt\n      uint256 requiredContributions = currentRound * contributionSize;\n      if (member.credit + totalDiscounts - removeFees(membersAddresses.length * contributionSize) >= requiredContributions) {\n          member.debt = false;\n      }\n    }\n\n    LogContributionMade(msg.sender, msg.value);\n  }\n\n  /**\n   * Registers a bid from msg.sender. Participant should call this method\n   * only if all of the following holds for her:\n   * + Never won a round.\n   * + Is in good standing (i.e. actual contributions, including this round's,\n   *   plus any past earned discounts are together greater than required contributions).\n   * + New bid is lower than the lowest bid so far.\n   */\n  function bid(uint256 bidInWei) onlyFromMember roscaNotEnded onlyIfEscapeHatchInactive external {\n    if (members[msg.sender].paid  ||\n        currentRound == 0 ||  // ROSCA hasn't started yet\n        // participant not in good standing\n        members[msg.sender].credit + totalDiscounts < (currentRound * contributionSize) ||\n        // bid is less than minimum allowed\n        //SWC-135-Code With No Effects: L384\n        bidInWei < contributionSize * membersAddresses.length * MIN_DISTRIBUTION_PERCENT / 100) {\n      throw;\n    }\n\n    // If winnerAddress is 0, this is the first bid, hence allow full pot.\n    // Otherwise, make sure bid is low enough compared to previous bid.\n    //SWC-135-Code With No Effects: L391\n    uint256 maxAllowedBid = winnerAddress == 0\n        ? contributionSize * membersAddresses.length\n        : lowestBid * MAX_NEXT_BID_RATIO / 100;\n    if (bidInWei > maxAllowedBid) {\n      // We don't throw as this may be hard for the frontend to predict on the\n      // one hand because someone else might have bid at the same time,\n      // and we'd like to avoid wasting the caller's gas.\n      LogUnsuccessfulBid(msg.sender, bidInWei, lowestBid);\n      return;\n    }\n    lowestBid = bidInWei;\n    winnerAddress = msg.sender;\n    LogNewLowestBid(lowestBid, winnerAddress);\n  }\n\n  /**\n   * Withdraws available funds for msg.sender.\n   */\n  function withdraw() onlyFromMember onlyIfEscapeHatchInactive external returns(bool success) {\n    if (members[msg.sender].debt && !endOfROSCA) {  // delinquent winners need to first pay their debt\n      throw;\n    }\n    uint256 totalCredit = members[msg.sender].credit + totalDiscounts;\n\n    uint256 totalDebit = members[msg.sender].debt\n        ? removeFees(membersAddresses.length * contributionSize)  // this must be end of rosca\n        : currentRound * contributionSize;\n    if (totalDebit >= totalCredit) {  // nothing to withdraw\n        throw;\n    }\n\n    uint256 amountToWithdraw = totalCredit - totalDebit;\n    uint256 amountAvailable = this.balance - totalFees;\n\n    if (amountAvailable < amountToWithdraw) {\n      // This may happen if some participants are delinquent.\n      LogCannotWithdrawFully(amountToWithdraw);\n      amountToWithdraw = amountAvailable;\n    }\n    members[msg.sender].credit -= amountToWithdraw;\n    if (!msg.sender.send(amountToWithdraw)) {   // if the send() fails, restore the allowance\n      // No need to call throw here, just reset the amount owing. This may happen\n      // for nonmalicious reasons, e.g. the receiving contract running out of gas.\n      members[msg.sender].credit += amountToWithdraw;\n      return false;\n    }\n    LogFundsWithdrawal(msg.sender, amountToWithdraw);\n    return true;\n  }\n\n  /**\n   * Returns how much a user can withdraw (positive return value),\n   * or how much they need to contribute to be in good standing (negative return value)\n   */\n  //SWC-135-Code With No Effects: L446-L456 \n  function getParticipantBalance(address user) onlyFromMember external constant returns(int256) {\n    int256 totalCredit = int256(members[user].credit + totalDiscounts);\n\n    // if rosca have ended, we don't need to subtract as totalDebit should equal to default winnings\n    if (members[user].debt && !endOfROSCA) {\n        totalCredit -= int256(removeFees(membersAddresses.length * contributionSize));\n    }\n    int256 totalDebit = int256(currentRound * contributionSize);\n\n    return totalCredit - totalDebit;\n  }\n  \n\n  /**\n   * Returns the amount of funds this contract holds excluding fees. This is\n   * the amount withdrawable by participants.\n   */\n  function getContractNetBalance() external constant returns(uint256) {\n    return this.balance - totalFees;\n  }\n\n  /**\n   * @dev Allows the foreperson to retrieve any surplus funds, one roundPeriodInDays after\n   * the end of the ROSCA.\n   *\n   * Note that startRound() must be called first after the last round, as it\n   * does the bookeeping of that round.\n   */\n  function endOfROSCARetrieveSurplus() onlyFromForeperson roscaEnded external returns (bool) {\n    uint256 roscaCollectionTime = startTime + ((membersAddresses.length + 1) * roundPeriodInDays * 1 days);\n    if (now < roscaCollectionTime || forepersonSurplusCollected) {\n        throw;\n    }\n\n    forepersonSurplusCollected = true;\n    uint256 amountToCollect = this.balance - totalFees;\n    if (!foreperson.send(amountToCollect)) {   // if the send() fails, restore the flag\n      // No need to call throw here, just reset the amount owing. This may happen\n      // for nonmalicious reasons, e.g. the receiving contract running out of gas.\n      forepersonSurplusCollected = false;\n      return false;\n    } else {\n      LogForepersonSurplusWithdrawal(amountToCollect);\n    }\n  }\n\n  /**\n   * @dev Allows the fee collector to extract the fees in the contract. Can be called\n   * only ine roundPeriodInDays after the end of the ROSCA.\n   *\n   * Note that startRound() must be called first after the last round, as it\n   * does the bookeeping of that round.\n   */\n  function endOfROSCARetrieveFees() onlyFromFeeAddress roscaEnded external returns (bool) {\n    uint256 tempTotalFees = totalFees;  // prevent re-entry.\n    totalFees = 0;\n    if (!FEE_ADDRESS.send(tempTotalFees)) {   // if the send() fails, restore totalFees\n      // No need to call throw here, just reset the amount owing. This may happen\n      // for nonmalicious reasons, e.g. the receiving contract running out of gas.\n      totalFees = tempTotalFees;\n      return false;\n    } else {\n      //SWC-135-Code With No Effects: L507\n      LogFundsWithdrawal(FEE_ADDRESS, totalFees);\n    }\n  }\n\n  /**\n   * Allows the Escape Hatch Enabler (controlled by WeTrust) to enable the Escape Hatch in case of\n   * emergency (e.g. a major vulnerability found in the contract).\n   */\n  function enableEscapeHatch() onlyFromEscapeHatchEnabler external {\n    escapeHatchEnabled = true;\n    LogEscapeHatchEnabled();\n  }\n\n  /**\n   * Allows the foreperson to active the Escape Hatch after the Enabled enabled it. This will freeze all\n   * contributions and withdrawals, and allow the foreperson to retrieve all funds into their own account,\n   * to be dispersed offline to the other participants.\n   */\n  function activateEscapeHatch() onlyFromForeperson external {\n    if (!escapeHatchEnabled) {\n      throw;\n    }\n    escapeHatchActive = true;\n    LogEscapeHatchActivated();\n  }\n\n  /**\n   * Can only be called by the foreperson after an escape hatch is activated,\n   * this sends all the funds to the foreperson by selfdestructing this contract.\n   */\n  function emergencyWithdrawal() onlyFromForeperson onlyIfEscapeHatchActive {\n    LogEmergencyWithdrawalPerformed(this.balance);\n    // Send everything, including potential fees, to foreperson to disperse offline to participants.\n    selfdestruct(foreperson);\n  }\n}\n",
        "function": null,
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/openzeppelin-WeTrust_ROSCA_contract_code/rosca-contracts-2af29be97d529488f5488fe0592f9e6b3585254f/contracts/ROSCA.sol",
        "vulnerability": "TODAmount",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity ^0.4.4;\n\n\n//SWC-101-Integer Overflow and Underflow: All\n//SWC-102-Outdated Compiler Version: All\n/**\n * @title ROSCA on a blockchain.\n *\n * A ROSCA (Rotating and Savings Credit Association) is an agreement between\n * trusted friends to contribute funds on a periodic basis to a \"pot\", and in\n * each round one of the participants receives the pot (termed \"winner\").\n * The winner is selected as the person who makes the lowest bid in that round\n * among those who have not won a bid before.\n * The discount (gap between bid and total round contributions) is dispersed\n * evenly between the participants.\n */\ncontract ROSCA {\n\n  \n  // CONSTANTS\n  \n  uint64 constant internal MIN_CONTRIBUTION_SIZE = 1 finney;  // 1e-3 ether\n  uint128 constant internal MAX_CONTRIBUTION_SIZE = 10 ether;\n\n  // Maximum fee (in 1/1000s) from dispersements that is shared between foreperson and other stakeholders..\n  uint16 constant internal MAX_FEE_IN_THOUSANDTHS = 20;\n\n  // Start time of the ROSCA must be at least this much time ahead of when the ROSCA is created\n  uint32 constant internal MINIMUM_TIME_BEFORE_ROSCA_START = 1 days;\n\n  uint8 constant internal MIN_ROUND_PERIOD_IN_DAYS = 1;\n  uint8 constant internal MAX_ROUND_PERIOD_IN_DAYS = 30;\n  // the winning bid must be at least this much of the maximum (aka default) pot value\n  uint8 constant internal MIN_DISTRIBUTION_PERCENT = 65;\n\n  // Every new bid has to be at most this much of the previous lowest bid\n  uint8 constant internal MAX_NEXT_BID_RATIO = 98;\n\n  // TODO: MUST change this prior to production. Currently this is accounts[9] of the testrpc config\n  // used in tests.\n  // Address from which fees can be withdrawn.\n  address constant internal FEE_ADDRESS = 0x1df62f291b2e969fb0849d99d9ce41e2f137006e;\n\n  // TODO(ron): replace this with an actual wallet. Right now this is accounts[9] of the testrpc used\n  // by tests.\n  // WeTrust's account from which Escape Hatch can be enanbled.\n  address constant internal ESCAPE_HATCH_ENABLER = 0x1df62f291b2e969fb0849d99d9ce41e2f137006e;\n\n  \n  // EVENTS\n  \n  event LogContributionMade(address user, uint256 amount);\n  event LogStartOfRound(uint256 currentRound);\n  event LogNewLowestBid(uint256 bid,address winnerAddress);\n  event LogRoundFundsReleased(address winnerAddress, uint256 amountInWei);\n  event LogRoundNoWinner(uint256 currentRound);\n  event LogFundsWithdrawal(address user, uint256 amount);\n  event LogForepersonSurplusWithdrawal(uint256 amount);\n  // Fired when withdrawer is entitled for a larger amount than the contract\n  // actually holds (excluding fees). A LogFundsWithdrawal will follow\n  // this event with the actual amount released, if send() is successful.\n  event LogCannotWithdrawFully(uint256 creditAmount);\n  event LogUnsuccessfulBid(address bidder,uint256 bidInWei,uint256 lowestBid);\n  event LogEndOfROSCA();\n\n  // Escape hatch related events.\n  event LogEscapeHatchEnabled();\n  event LogEscapeHatchActivated();\n  event LogEmergencyWithdrawalPerformed(uint256 fundsDispersed);\n\n  \n  // STORAGE VARIABLES\n  \n\n  // ROSCA parameters\n  uint16 internal roundPeriodInDays;\n  uint16 internal serviceFeeInThousandths;\n  uint16 internal currentRound;  // set to 0 when ROSCA is created, becomes 1 when ROSCA starts\n  address internal foreperson;\n  uint128 internal contributionSize;\n  uint256 internal startTime;\n\n  // ROSCA state\n  bool internal endOfROSCA = false;\n  bool internal forepersonSurplusCollected = false;\n  // A discount is the difference between a winning bid and the pot value. totalDiscounts is the amount\n  // of discounts accumulated so far, divided by the number of ROSCA participants.\n  uint256 internal totalDiscounts = 0;\n\n  // Amount of fees reserved in the contract for fees.\n  uint256 internal totalFees = 0;\n\n  // Round state variables\n  uint256 internal lowestBid = 0;\n  address internal winnerAddress = 0;  // bidder who bid the lowest so far\n\n  mapping(address => User) internal members;\n  address[] internal membersAddresses;  // for iterating through members' addresses\n\n  // Other state\n  // An escape hatch is used in case a major vulnerability is discovered in the contract code.\n  // The following procedure is then put into action:\n  // 1. WeTrust sends a transaction to make escapeHatchEnabled true.\n  // 2. foreperson is notified and can decide to activate the escapeHatch.\n  // 3. If escape hatch is activated, no contributions and/or withdrawals are allowed. The foreperson\n  //    may call withdraw() to withdraw all of the contract's funds and then disperse them offline\n  //    among the participants.\n  bool internal escapeHatchEnabled = false;\n  bool internal escapeHatchActive = false;\n\n  struct User {\n    uint256 credit;  // amount of funds user has contributed - winnings (not including discounts) so far\n    bool debt; // true if user won the pot while not in good standing and is still not in good standing\n    bool paid; // yes if the member had won a Round\n    bool alive; // needed to check if a member is indeed a member\n  }\n\n  \n  // MODIFIERS\n  \n  modifier onlyFromMember {\n    if (!members[msg.sender].alive) {\n      throw;\n    }\n    _;\n  }\n\n  modifier onlyFromForeperson {\n    if (msg.sender != foreperson) {\n      throw;\n    }\n    _;\n  }\n\n  modifier onlyFromFeeAddress {\n    if (msg.sender != FEE_ADDRESS) {\n      throw;\n    }\n    _;\n  }\n\n  modifier roscaNotEnded {\n    if (endOfROSCA) {\n      throw;\n    }\n    _;\n  }\n\n  modifier roscaEnded {\n    if (!endOfROSCA) {\n      throw;\n    }\n    _;\n  }\n\n  modifier onlyIfEscapeHatchActive {\n    if (!escapeHatchActive) {\n      throw;\n    }\n    _;\n  }\n\n  modifier onlyIfEscapeHatchInactive {\n    if (escapeHatchActive) {\n      throw;\n    }\n    _;\n  }\n\n  modifier onlyFromEscapeHatchEnabler {\n    if (msg.sender != ESCAPE_HATCH_ENABLER) {\n      throw;\n    }\n    _;\n  }\n\n  \n  // FUNCTIONS\n  \n\n  /**\n    * @dev Creates a new ROSCA and initializes the necessary variables. ROSCA starts after startTime.\n    * Creator of the contract becomes foreperson and a participant.\n    */\n  function ROSCA (\n      uint16 roundPeriodInDays_,\n      uint128 contributionSize_,\n      uint256 startTime_,\n      address[] members_,\n      uint16 serviceFeeInThousandths_) {\n    if (roundPeriodInDays_ < MIN_ROUND_PERIOD_IN_DAYS || roundPeriodInDays_ > MAX_ROUND_PERIOD_IN_DAYS) {\n      throw;\n    }\n    roundPeriodInDays = roundPeriodInDays_;\n\n    if (contributionSize_ < MIN_CONTRIBUTION_SIZE || contributionSize_ > MAX_CONTRIBUTION_SIZE) {\n      throw;\n    }\n    contributionSize = contributionSize_;\n    //SWC-116-Block values as a proxy for time: L199\n    if (startTime_ < (now + MINIMUM_TIME_BEFORE_ROSCA_START)) {\n      throw;\n    }\n    startTime = startTime_;\n    if (serviceFeeInThousandths_ > MAX_FEE_IN_THOUSANDTHS) {\n      throw;\n    }\n    serviceFeeInThousandths = serviceFeeInThousandths_;\n\n    foreperson = msg.sender;\n    addMember(msg.sender);\n\n    for (uint16 i = 0; i < members_.length; i++) {\n      addMember(members_[i]);\n    }\n  }\n\n  function addMember(address newMember) internal {\n    if (members[newMember].alive) {  // already registered\n      throw;\n    }\n    members[newMember] = User({paid: false , credit: 0, alive: true, debt: false});\n    membersAddresses.push(newMember);\n  }\n\n  /**\n    * @dev Calculates the winner of the current round's pot, and credits her.\n    * If there were no bids during the round, winner is selected semi-randomly.\n    * Priority is given to non-delinquent participants.\n    */\n  function startRound() roscaNotEnded external {\n    uint256 roundStartTime = startTime + (uint(currentRound)  * roundPeriodInDays * 1 days);\n    if (now < roundStartTime ) {  // too early to start a new round.\n      throw;\n    }\n\n    if (currentRound != 0) {\n      cleanUpPreviousRound();\n    }\n    if (currentRound < membersAddresses.length) {\n      lowestBid = 0;\n      winnerAddress = 0;\n      currentRound++;\n      LogStartOfRound(currentRound);\n    } else {\n        endOfROSCA = true;\n        LogEndOfROSCA();\n    }\n  }\n\n  function cleanUpPreviousRound() internal {\n    address delinquentWinner = 0x0;\n    uint256 winnerIndex;\n    bool winnerSelectedThroughBid = (winnerAddress != 0);\n    uint16 numUnpaidParticipants = uint16(membersAddresses.length) - (currentRound - 1);\n    if (winnerAddress == 0) {\n      // There was no bid in this round. Find an unpaid address for this epoch.\n      // Give priority to members in good standing (not delinquent).\n      // Note this randomness does not require high security, that's why we feel ok with using the block's timestamp.\n      // Everyone will be paid out eventually.\n      uint256 semi_random = now % numUnpaidParticipants;\n      for (uint16 i = 0; i < numUnpaidParticipants; i++) {\n        uint256 index = (semi_random + i) % numUnpaidParticipants;\n        address candidate = membersAddresses[index];\n        if (!members[candidate].paid) {\n          winnerIndex = index;\n          if (members[candidate].credit + totalDiscounts >= (currentRound * contributionSize)) {\n            // We found a non-delinquent winner.\n            winnerAddress = candidate;\n            break;\n          }\n          delinquentWinner = candidate;\n        }\n      }\n      if (winnerAddress == 0) {  // we did not find any non-delinquent winner.\n        // Perform some basic sanity checks.\n        if (delinquentWinner == 0 || members[delinquentWinner].paid) throw;\n        winnerAddress = delinquentWinner;\n        // Set the flag to true so we know this user cannot withdraw until debt has been paid.\n        members[winnerAddress].debt = true;\n      }\n      // Set lowestBid to the right value since there was no winning bid.\n      lowestBid = contributionSize * membersAddresses.length;\n    }\n    // We keep the unpaid participants at positions [0..num_participants - current_round) so that we can uniformly select\n    // among them (if we didn't do that and there were a few consecutive paid participants, we'll be more likely to select the\n    // next unpaid member).\n    swapWinner(winnerIndex, winnerSelectedThroughBid, numUnpaidParticipants - 1);\n    //SWC-135-Code With No Effects: L288\n    uint256 currentRoundTotalDiscounts = removeFees(contributionSize * membersAddresses.length - lowestBid);\n    totalDiscounts += currentRoundTotalDiscounts / membersAddresses.length;\n    members[winnerAddress].credit += removeFees(lowestBid);\n    members[winnerAddress].paid = true;\n    LogRoundFundsReleased(winnerAddress, lowestBid);\n    recalculateTotalFees();\n  }\n\n  // Recalculates that total fees that should be allocated in the contract.\n  function recalculateTotalFees() {\n    // Start with the max theoretical fees if no one was delinquent, and\n    // reduce funds not actually contributed because of delinquencies.\n    uint256 requiredContributions = currentRound * contributionSize;\n    uint256 grossTotalFees = requiredContributions * membersAddresses.length;\n\n    for (uint16 j = 0; j < membersAddresses.length; j++) {\n      User member = members[membersAddresses[j]];\n      uint256 credit = member.credit;\n      uint256 debit = requiredContributions;\n      if (member.debt) {\n        // As a delinquent member won, we'll reduce the funds subject to fees by the default pot they must have won (since\n        // they could not bid), to correctly calculate their delinquency.\n        debit += removeFees(membersAddresses.length * contributionSize);\n      }\n      if (credit + totalDiscounts < debit) {\n        grossTotalFees -= debit - credit - totalDiscounts;\n      }\n    }\n    //SWC-135-Code With No Effects: L316\n    totalFees = grossTotalFees * serviceFeeInThousandths / 1000;\n  }\n\n  // Swaps membersAddresses[winnerIndex] with membersAddresses[indexToSwap]. However,\n  // if winner was selected through a bid, winnerIndex was not set, and we find it first.\n  function swapWinner(\n    uint256 winnerIndex, bool winnerSelectedThroughBid, uint256 indexToSwap) internal {\n    if (winnerSelectedThroughBid) {\n      // Since winner was selected through a bid, we were not able to set winnerIndex, so search\n      // for the winner among the unpaid participants.\n      for (uint16 i = 0; i <= indexToSwap; i++) {\n        if (membersAddresses[i] == winnerAddress) {\n          winnerIndex = i;\n          break;\n        }\n      }\n    }\n    // We now want to swap winnerIndex with indexToSwap, but we already know membersAddresses[winnerIndex] == winnerAddress.\n    membersAddresses[winnerIndex] = membersAddresses[indexToSwap];\n    membersAddresses[indexToSwap] = winnerAddress;\n  }\n\n  // Calculates the specified amount net amount after fees.\n  function removeFees(uint256 amount) internal returns (uint256) {\n    // First multiply to reduce roundoff errors.\n    //SWC-135-Code With No Effects: L342\n    return amount * (1000 - serviceFeeInThousandths) / 1000;\n  }\n\n  /**\n   * Processes a periodic contribution. msg.sender must be one of the participants and will thus\n   * identify the contributor.\n   *\n   * Any excess funds are withdrawable through withdraw() without fee.\n   */\n  function contribute() payable onlyFromMember roscaNotEnded onlyIfEscapeHatchInactive external {\n    User member = members[msg.sender];\n    member.credit += msg.value;\n    if (member.debt) {\n      // Check if user comes out of debt. We know they won an entire pot as they could not bid,\n      // so we check whether their credit w/o that winning is non-delinquent.\n      // check that credit must defaultPot (when debt is set to true, defaultPot was added to credit as winnings) +\n      // currentRound in order to be out of debt\n      uint256 requiredContributions = currentRound * contributionSize;\n      if (member.credit + totalDiscounts - removeFees(membersAddresses.length * contributionSize) >= requiredContributions) {\n          member.debt = false;\n      }\n    }\n\n    LogContributionMade(msg.sender, msg.value);\n  }\n\n  /**\n   * Registers a bid from msg.sender. Participant should call this method\n   * only if all of the following holds for her:\n   * + Never won a round.\n   * + Is in good standing (i.e. actual contributions, including this round's,\n   *   plus any past earned discounts are together greater than required contributions).\n   * + New bid is lower than the lowest bid so far.\n   */\n  function bid(uint256 bidInWei) onlyFromMember roscaNotEnded onlyIfEscapeHatchInactive external {\n    if (members[msg.sender].paid  ||\n        currentRound == 0 ||  // ROSCA hasn't started yet\n        // participant not in good standing\n        members[msg.sender].credit + totalDiscounts < (currentRound * contributionSize) ||\n        // bid is less than minimum allowed\n        //SWC-135-Code With No Effects: L384\n        bidInWei < contributionSize * membersAddresses.length * MIN_DISTRIBUTION_PERCENT / 100) {\n      throw;\n    }\n\n    // If winnerAddress is 0, this is the first bid, hence allow full pot.\n    // Otherwise, make sure bid is low enough compared to previous bid.\n    //SWC-135-Code With No Effects: L391\n    uint256 maxAllowedBid = winnerAddress == 0\n        ? contributionSize * membersAddresses.length\n        : lowestBid * MAX_NEXT_BID_RATIO / 100;\n    if (bidInWei > maxAllowedBid) {\n      // We don't throw as this may be hard for the frontend to predict on the\n      // one hand because someone else might have bid at the same time,\n      // and we'd like to avoid wasting the caller's gas.\n      LogUnsuccessfulBid(msg.sender, bidInWei, lowestBid);\n      return;\n    }\n    lowestBid = bidInWei;\n    winnerAddress = msg.sender;\n    LogNewLowestBid(lowestBid, winnerAddress);\n  }\n\n  /**\n   * Withdraws available funds for msg.sender.\n   */\n  function withdraw() onlyFromMember onlyIfEscapeHatchInactive external returns(bool success) {\n    if (members[msg.sender].debt && !endOfROSCA) {  // delinquent winners need to first pay their debt\n      throw;\n    }\n    uint256 totalCredit = members[msg.sender].credit + totalDiscounts;\n\n    uint256 totalDebit = members[msg.sender].debt\n        ? removeFees(membersAddresses.length * contributionSize)  // this must be end of rosca\n        : currentRound * contributionSize;\n    if (totalDebit >= totalCredit) {  // nothing to withdraw\n        throw;\n    }\n\n    uint256 amountToWithdraw = totalCredit - totalDebit;\n    uint256 amountAvailable = this.balance - totalFees;\n\n    if (amountAvailable < amountToWithdraw) {\n      // This may happen if some participants are delinquent.\n      LogCannotWithdrawFully(amountToWithdraw);\n      amountToWithdraw = amountAvailable;\n    }\n    members[msg.sender].credit -= amountToWithdraw;\n    if (!msg.sender.send(amountToWithdraw)) {   // if the send() fails, restore the allowance\n      // No need to call throw here, just reset the amount owing. This may happen\n      // for nonmalicious reasons, e.g. the receiving contract running out of gas.\n      members[msg.sender].credit += amountToWithdraw;\n      return false;\n    }\n    LogFundsWithdrawal(msg.sender, amountToWithdraw);\n    return true;\n  }\n\n  /**\n   * Returns how much a user can withdraw (positive return value),\n   * or how much they need to contribute to be in good standing (negative return value)\n   */\n  //SWC-135-Code With No Effects: L446-L456 \n  function getParticipantBalance(address user) onlyFromMember external constant returns(int256) {\n    int256 totalCredit = int256(members[user].credit + totalDiscounts);\n\n    // if rosca have ended, we don't need to subtract as totalDebit should equal to default winnings\n    if (members[user].debt && !endOfROSCA) {\n        totalCredit -= int256(removeFees(membersAddresses.length * contributionSize));\n    }\n    int256 totalDebit = int256(currentRound * contributionSize);\n\n    return totalCredit - totalDebit;\n  }\n  \n\n  /**\n   * Returns the amount of funds this contract holds excluding fees. This is\n   * the amount withdrawable by participants.\n   */\n  function getContractNetBalance() external constant returns(uint256) {\n    return this.balance - totalFees;\n  }\n\n  /**\n   * @dev Allows the foreperson to retrieve any surplus funds, one roundPeriodInDays after\n   * the end of the ROSCA.\n   *\n   * Note that startRound() must be called first after the last round, as it\n   * does the bookeeping of that round.\n   */\n  function endOfROSCARetrieveSurplus() onlyFromForeperson roscaEnded external returns (bool) {\n    uint256 roscaCollectionTime = startTime + ((membersAddresses.length + 1) * roundPeriodInDays * 1 days);\n    if (now < roscaCollectionTime || forepersonSurplusCollected) {\n        throw;\n    }\n\n    forepersonSurplusCollected = true;\n    uint256 amountToCollect = this.balance - totalFees;\n    if (!foreperson.send(amountToCollect)) {   // if the send() fails, restore the flag\n      // No need to call throw here, just reset the amount owing. This may happen\n      // for nonmalicious reasons, e.g. the receiving contract running out of gas.\n      forepersonSurplusCollected = false;\n      return false;\n    } else {\n      LogForepersonSurplusWithdrawal(amountToCollect);\n    }\n  }\n\n  /**\n   * @dev Allows the fee collector to extract the fees in the contract. Can be called\n   * only ine roundPeriodInDays after the end of the ROSCA.\n   *\n   * Note that startRound() must be called first after the last round, as it\n   * does the bookeeping of that round.\n   */\n  function endOfROSCARetrieveFees() onlyFromFeeAddress roscaEnded external returns (bool) {\n    uint256 tempTotalFees = totalFees;  // prevent re-entry.\n    totalFees = 0;\n    if (!FEE_ADDRESS.send(tempTotalFees)) {   // if the send() fails, restore totalFees\n      // No need to call throw here, just reset the amount owing. This may happen\n      // for nonmalicious reasons, e.g. the receiving contract running out of gas.\n      totalFees = tempTotalFees;\n      return false;\n    } else {\n      //SWC-135-Code With No Effects: L507\n      LogFundsWithdrawal(FEE_ADDRESS, totalFees);\n    }\n  }\n\n  /**\n   * Allows the Escape Hatch Enabler (controlled by WeTrust) to enable the Escape Hatch in case of\n   * emergency (e.g. a major vulnerability found in the contract).\n   */\n  function enableEscapeHatch() onlyFromEscapeHatchEnabler external {\n    escapeHatchEnabled = true;\n    LogEscapeHatchEnabled();\n  }\n\n  /**\n   * Allows the foreperson to active the Escape Hatch after the Enabled enabled it. This will freeze all\n   * contributions and withdrawals, and allow the foreperson to retrieve all funds into their own account,\n   * to be dispersed offline to the other participants.\n   */\n  function activateEscapeHatch() onlyFromForeperson external {\n    if (!escapeHatchEnabled) {\n      throw;\n    }\n    escapeHatchActive = true;\n    LogEscapeHatchActivated();\n  }\n\n  /**\n   * Can only be called by the foreperson after an escape hatch is activated,\n   * this sends all the funds to the foreperson by selfdestructing this contract.\n   */\n  function emergencyWithdrawal() onlyFromForeperson onlyIfEscapeHatchActive {\n    LogEmergencyWithdrawalPerformed(this.balance);\n    // Send everything, including potential fees, to foreperson to disperse offline to participants.\n    selfdestruct(foreperson);\n  }\n}\n",
        "function": null,
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/openzeppelin-WeTrust_ROSCA_contract_code/rosca-contracts-2af29be97d529488f5488fe0592f9e6b3585254f/contracts/ROSCA.sol",
        "vulnerability": "DAOConstantGas",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity ^0.4.21;\n\n\n/**\n *Submitted for verification at Etherscan.io on 2020-07-14\n*/\n// ownership contract\ncontract Owned {\n    address public owner;\n\n    event TransferOwnership(address oldaddr, address newaddr);\n\n    modifier onlyOwner() { if (msg.sender != owner) return; _; }\n\n    function Owned() public {\n        owner = msg.sender;\n    }\n    \n    function transferOwnership(address _new) onlyOwner public {\n        address oldaddr = owner;\n        owner = _new;\n        emit TransferOwnership(oldaddr, owner);\n    }\n}\n\n// erc20\ncontract ERC20Interface {\n\tuint256 public totalSupply;\n\tfunction balanceOf(address _owner) public constant returns (uint256 balance);\n\tfunction transfer(address _to, uint256 _value) public returns (bool success);\n\tfunction transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n\tfunction approve(address _spender, uint256 _value) public returns (bool success);\n\tfunction allowance(address _owner, address _spender) public constant returns (uint256 remaining);\n\tevent Transfer(address indexed _from, address indexed _to, uint256 _value);\n\tevent Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\n\ncontract FLUX is ERC20Interface, Owned {\n\tstring public constant symbol = \"FLX\";\n\tstring public constant name = \"FLUX\";\n\tuint8 public constant decimals = 18;\n\tuint256 public constant totalSupply = 1000000000000000000000000000;\n\n\tbool public stopped;\n\n\tmapping (address => int8) public blackList;\n\n\tmapping (address => uint256) public balances;\n\tmapping (address => mapping (address => uint256)) public allowed;\n\n\n    event Blacklisted(address indexed target);\n    event DeleteFromBlacklist(address indexed target);\n    event RejectedPaymentToBlacklistedAddr(address indexed from, address indexed to, uint256 value);\n    event RejectedPaymentFromBlacklistedAddr(address indexed from, address indexed to, uint256 value);\n\n\n\tmodifier notStopped {\n        require(!stopped);\n        _;\n    }\n\n// constructor\n\tfunction FLUX() public {\n\t\tbalances[msg.sender] = totalSupply;\n\t}\n\t\n// function made for airdrop\n\tfunction airdrop(address[] _to, uint256[] _value) onlyOwner notStopped public {\n\t    for(uint256 i = 0; i < _to.length; i++){\n\t        if(balances[_to[i]] > 0){\n\t            continue;\n\t        }\n\t        transfer(_to[i], _value[i]);\n\t    }\n\t}\n\n// blacklist management\n    function blacklisting(address _addr) onlyOwner public {\n        blackList[_addr] = 1;\n        emit Blacklisted(_addr);\n    }\n    function deleteFromBlacklist(address _addr) onlyOwner public {\n        blackList[_addr] = -1;\n        emit DeleteFromBlacklist(_addr);\n    }\n\n// stop the contract\n// SWC-100-Function Default Visibility: L90\n\tfunction stop() onlyOwner {\n        stopped = true;\n    }\n// SWC-100-Function Default Visibility: L94\n    function start() onlyOwner {\n        stopped = false;\n    }\n\t\n// ERC20 functions\n\tfunction balanceOf(address _owner) public constant returns (uint256 balance){\n\t\treturn balances[_owner];\n\t}\n\tfunction transfer(address _to, uint256 _value) notStopped public returns (bool success){\n\t\trequire(balances[msg.sender] >= _value);\n\n\t\tif(blackList[msg.sender] > 0){\n\t\t\temit RejectedPaymentFromBlacklistedAddr(msg.sender, _to, _value);\n\t\t\treturn false;\n\t\t}\n\t\tif(blackList[_to] > 0){\n\t\t\temit RejectedPaymentToBlacklistedAddr(msg.sender, _to, _value);\n\t\t\treturn false;\n\t\t}\n\n\t\tbalances[msg.sender] -= _value;\n\t\tbalances[_to] += _value;\n\t\temit Transfer(msg.sender, _to, _value);\n\t\treturn true;\n\t}\n\tfunction transferFrom(address _from, address _to, uint256 _value) notStopped public returns (bool success){\n\t\trequire(balances[_from] >= _value\n\t\t\t&& allowed[_from][msg.sender] >= _value);\n\n\t\tif(blackList[_from] > 0){\n\t\t\temit RejectedPaymentFromBlacklistedAddr(_from, _to, _value);\n\t\t\treturn false;\n\t\t}\n\t\tif(blackList[_to] > 0){\n\t\t\temit RejectedPaymentToBlacklistedAddr(_from, _to, _value);\n\t\t\treturn false;\n\t\t}\n\n\t\tbalances[_from] -= _value;\n\t\tallowed[_from][msg.sender] -= _value;\n\t\tbalances[_to] += _value;\n\t\temit Transfer(_from, _to, _value);\n\t\treturn true;\n\t}\n\tfunction approve(address _spender, uint256 _value) notStopped public returns (bool success){\n\t\tallowed[msg.sender][_spender] = _value;\n\t\temit Approval(msg.sender, _spender, _value);\n\t\treturn true;\n\t}\n\tfunction allowance(address _owner, address _spender) public constant returns (uint256 remaining){\n\t\treturn allowed[_owner][_spender];\n\t}\n}\n",
        "function": null,
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Iosiro-FLUX Token Smart Contract Audit/code/Etherscan-0x54735d716995071585A4f6ba341a6Ded79756F09.sol",
        "vulnerability": "MissingInputValidation",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity ^0.4.21;\n\n\n/**\n *Submitted for verification at Etherscan.io on 2020-07-22\n*/\n// ownership contract\ncontract Owned {\n    address public owner;\n\n    event TransferOwnership(address oldaddr, address newaddr);\n\n    modifier onlyOwner() { if (msg.sender != owner) return; _; }\n\n    function Owned() public {\n        owner = msg.sender;\n    }\n    \n    function transferOwnership(address _new) onlyOwner public {\n        address oldaddr = owner;\n        owner = _new;\n        emit TransferOwnership(oldaddr, owner);\n    }\n}\n\n// erc20\ncontract ERC20Interface {\n\tuint256 public totalSupply;\n\tfunction balanceOf(address _owner) public constant returns (uint256 balance);\n\tfunction transfer(address _to, uint256 _value) public returns (bool success);\n\tfunction transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n\tfunction approve(address _spender, uint256 _value) public returns (bool success);\n\tfunction allowance(address _owner, address _spender) public constant returns (uint256 remaining);\n\tevent Transfer(address indexed _from, address indexed _to, uint256 _value);\n\tevent Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\n\ncontract CHAINSQUARE is ERC20Interface, Owned {\n\tstring public constant symbol = \"CHS\";\n\tstring public constant name = \"CHAINSQUARE\";\n\tuint8 public constant decimals = 18;\n\tuint256 public constant totalSupply = 100000000000000000000000000;\n\n\tbool public stopped;\n\n\tmapping (address => int8) public blackList;\n\n\tmapping (address => uint256) public balances;\n\tmapping (address => mapping (address => uint256)) public allowed;\n\n\n    event Blacklisted(address indexed target);\n    event DeleteFromBlacklist(address indexed target);\n    event RejectedPaymentToBlacklistedAddr(address indexed from, address indexed to, uint256 value);\n    event RejectedPaymentFromBlacklistedAddr(address indexed from, address indexed to, uint256 value);\n\n\n\tmodifier notStopped {\n        require(!stopped);\n        _;\n    }\n\n// constructor\n\tfunction CHAINSQUARE() public {\n\t\tbalances[msg.sender] = totalSupply;\n\t}\n\t\n// function made for airdrop\n\tfunction airdrop(address[] _to, uint256[] _value) onlyOwner notStopped public {\n\t    for(uint256 i = 0; i < _to.length; i++){\n\t        if(balances[_to[i]] > 0){\n\t            continue;\n\t        }\n\t        transfer(_to[i], _value[i]);\n\t    }\n\t}\n\n// blacklist management\n    function blacklisting(address _addr) onlyOwner public {\n        blackList[_addr] = 1;\n        emit Blacklisted(_addr);\n    }\n    function deleteFromBlacklist(address _addr) onlyOwner public {\n        blackList[_addr] = -1;\n        emit DeleteFromBlacklist(_addr);\n    }\n\n// stop the contract\n// SWC-100-Function Default Visibility: L90\n\tfunction stop() onlyOwner {\n        stopped = true;\n    }\n// SWC-100-Function Default Visibility: L94\n    function start() onlyOwner {\n        stopped = false;\n    }\n\t\n// ERC20 functions\n\tfunction balanceOf(address _owner) public constant returns (uint256 balance){\n\t\treturn balances[_owner];\n\t}\n\tfunction transfer(address _to, uint256 _value) notStopped public returns (bool success){\n\t\trequire(balances[msg.sender] >= _value);\n\n\t\tif(blackList[msg.sender] > 0){\n\t\t\temit RejectedPaymentFromBlacklistedAddr(msg.sender, _to, _value);\n\t\t\treturn false;\n\t\t}\n\t\tif(blackList[_to] > 0){\n\t\t\temit RejectedPaymentToBlacklistedAddr(msg.sender, _to, _value);\n\t\t\treturn false;\n\t\t}\n\n\t\tbalances[msg.sender] -= _value;\n\t\tbalances[_to] += _value;\n\t\temit Transfer(msg.sender, _to, _value);\n\t\treturn true;\n\t}\n\tfunction transferFrom(address _from, address _to, uint256 _value) notStopped public returns (bool success){\n\t\trequire(balances[_from] >= _value\n\t\t\t&& allowed[_from][msg.sender] >= _value);\n\n\t\tif(blackList[_from] > 0){\n\t\t\temit RejectedPaymentFromBlacklistedAddr(_from, _to, _value);\n\t\t\treturn false;\n\t\t}\n\t\tif(blackList[_to] > 0){\n\t\t\temit RejectedPaymentToBlacklistedAddr(_from, _to, _value);\n\t\t\treturn false;\n\t\t}\n\n\t\tbalances[_from] -= _value;\n\t\tallowed[_from][msg.sender] -= _value;\n\t\tbalances[_to] += _value;\n\t\temit Transfer(_from, _to, _value);\n\t\treturn true;\n\t}\n\tfunction approve(address _spender, uint256 _value) notStopped public returns (bool success){\n\t\tallowed[msg.sender][_spender] = _value;\n\t\temit Approval(msg.sender, _spender, _value);\n\t\treturn true;\n\t}\n\tfunction allowance(address _owner, address _spender) public constant returns (uint256 remaining){\n\t\treturn allowed[_owner][_spender];\n\t}\n}\n",
        "function": null,
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Iosiro-CHAINSQUARE Smart Contract Audit/code/Etherscan-0xb41380174d0B06181513A5677b60200b93b5Efb4.sol",
        "vulnerability": "MissingInputValidation",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity ^0.4.16;\n\n\n/**\n *Submitted for verification at Etherscan.io on 2019-03-27\n*/\ninterface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public; }\n\ncontract TokenERC20 {\n    // Public variables of the token\n    string public name;\n    string public symbol;\n    uint8 public decimals = 18;\n    // 18 decimals is the strongly suggested default, avoid changing it\n    uint256 public totalSupply;\n\n    mapping (address => bool) public blacklist;\n    address admin;\n\n    // This creates an array with all balances\n    mapping (address => uint256) public balanceOf;\n    mapping (address => mapping (address => uint256)) public allowance;\n\n    // This generates a public event on the blockchain that will notify clients\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    // This notifies clients about the amount burnt\n    event Burn(address indexed from, uint256 value);\n\n    /**\n     * Constructor function\n     *\n     * Initializes contract with initial supply tokens to the creator of the contract\n     */\n    function TokenERC20(\n        uint256 initialSupply,\n        string tokenName,\n        string tokenSymbol\n    ) public {\n        totalSupply = initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount\n        balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens\n        name = tokenName;                                   // Set the name for display purposes\n        symbol = tokenSymbol;                               // Set the symbol for display purposes\n        admin = msg.sender;\n    }\n\n    /**\n     * Internal transfer, only can be called by this contract\n     */\n    function _transfer(address _from, address _to, uint _value) internal {\n        // Prevent transfer to 0x0 address. Use burn() instead\n        require(_to != 0x0);\n        // Check if the sender has enough\n        require(balanceOf[_from] >= _value);\n        // Check for overflows\n        require(balanceOf[_to] + _value > balanceOf[_to]);\n        // Save this for an assertion in the future\n        uint previousBalances = balanceOf[_from] + balanceOf[_to];\n        // Subtract from the sender\n        balanceOf[_from] -= _value;\n        // Add the same to the recipient\n        balanceOf[_to] += _value;\n        Transfer(_from, _to, _value);\n        // Asserts are used to use static analysis to find bugs in your code. They should never fail\n        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);\n    }\n\n    /**\n     * Transfer tokens\n     *\n     * Send `_value` tokens to `_to` from your account\n     *\n     * @param _to The address of the recipient\n     * @param _value the amount to send\n     */\n// SWC-104-Unchecked Call Return Value: L76\n    function transfer(address _to, uint256 _value) public {\n        require(!blacklist[msg.sender]);\n        _transfer(msg.sender, _to, _value);\n    }\n\n    /**\n     * Ban address\n     * \n     * @param addr ban addr\n     */\n    function ban(address addr) public {\n        require(msg.sender == admin);\n        blacklist[addr] = true;\n    }\n\n    /**\n     * Enable address\n     * \n     *  @param addr enable addr\n     */\n    function enable(address addr) public {\n        require(msg.sender == admin);\n        blacklist[addr] = false;\n    }\n\n    /**\n     * Transfer tokens from other address\n     *\n     * Send `_value` tokens to `_to` on behalf of `_from`\n     *\n     * @param _from The address of the sender\n     * @param _to The address of the recipient\n     * @param _value the amount to send\n     */\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n        require(!blacklist[msg.sender]);\n        require(_value <= allowance[_from][msg.sender]);     // Check allowance\n        allowance[_from][msg.sender] -= _value;\n        _transfer(_from, _to, _value);\n        return true;\n    }\n\n    /**\n     * Set allowance for other address\n     *\n     * Allows `_spender` to spend no more than `_value` tokens on your behalf\n     *\n     * @param _spender The address authorized to spend\n     * @param _value the max amount they can spend\n     */\n    function approve(address _spender, uint256 _value) public\n    returns (bool success) {\n        require(!blacklist[msg.sender]);\n        allowance[msg.sender][_spender] = _value;\n        return true;\n    }\n\n    /**\n     * Set allowance for other address and notify\n     *\n     * Allows `_spender` to spend no more than `_value` tokens on your behalf, and then ping the contract about it\n     *\n     * @param _spender The address authorized to spend\n     * @param _value the max amount they can spend\n     * @param _extraData some extra information to send to the approved contract\n     */\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData)\n    public\n    returns (bool success) {\n        require(!blacklist[msg.sender]);\n        tokenRecipient spender = tokenRecipient(_spender);\n        if (approve(_spender, _value)) {\n            spender.receiveApproval(msg.sender, _value, this, _extraData);\n            return true;\n        }\n    }\n\n    /**\n     * Destroy tokens\n     *\n     * Remove `_value` tokens from the system irreversibly\n     *\n     * @param _value the amount of money to burn\n     */\n    function burn(uint256 _value) public returns (bool success) {\n        require(!blacklist[msg.sender]);\n        require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough\n        balanceOf[msg.sender] -= _value;            // Subtract from the sender\n        totalSupply -= _value;                      // Updates totalSupply\n        Burn(msg.sender, _value);\n        return true;\n    }\n\n    /**\n     * Destroy tokens from other account\n     *\n     * Remove `_value` tokens from the system irreversibly on behalf of `_from`.\n     *\n     * @param _from the address of the sender\n     * @param _value the amount of money to burn\n     */\n    function burnFrom(address _from, uint256 _value) public returns (bool success) {\n        require(!blacklist[msg.sender]);\n        require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough\n        require(_value <= allowance[_from][msg.sender]);    // Check allowance\n        balanceOf[_from] -= _value;                         // Subtract from the targeted balance\n        allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance\n        totalSupply -= _value;                              // Update totalSupply\n        Burn(_from, _value);\n        return true;\n    }\n}\n",
        "function": null,
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Callisto_Network-MaxiMine Token (MXM) Security Audit/code/code.sol",
        "vulnerability": "MissingInputValidation",
        "check": "FP",
        "response": "Answer: No"
    }
]