[
    {
        "code_segment": "library BasicMathLib {\n  \n  \n  \n  \n  \n  \n  function times(uint256 a, uint256 b) public pure returns (bool err,uint256 res) {\n    assembly{\n      res := mul(a,b)\n      switch or(iszero(b), eq(div(res,b), a))\n      case 0 {\n        err := 1\n        res := 0\n      }\n    }\n  }\n\n  \n  \n  \n  \n  \n  \n  function dividedBy(uint256 a, uint256 b) public pure returns (bool err,uint256 i) {\n    uint256 res;\n    assembly{\n      switch iszero(b)\n      case 0 {\n        res := div(a,b)\n        let loc := mload(0x40)\n        mstore(add(loc,0x20),res)\n        i := mload(add(loc,0x20))\n      }\n      default {\n        err := 1\n        i := 0\n      }\n    }\n  }\n\n  \n  \n  \n  \n  \n  \n  function plus(uint256 a, uint256 b) public pure returns (bool err, uint256 res) {\n    assembly{\n      res := add(a,b)\n      switch and(eq(sub(res,b), a), or(gt(res,b),eq(res,b)))\n      case 0 {\n        err := 1\n        res := 0\n      }\n    }\n  }\n\n  \n  \n  \n  \n  \n  \n  function minus(uint256 a, uint256 b) public pure returns (bool err,uint256 res) {\n    assembly{\n      res := sub(a,b)\n      switch eq(and(eq(add(res,b), a), or(lt(res,a), eq(res,a))), 1)\n      case 0 {\n        err := 1\n        res := 0\n      }\n    }\n  }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/consensys-Modular_Interactive_Crowdsale/ethereum-libraries-73abc22623e0841b8ea67a5089002f4867102672/BasicMathLib/BasicMathLib.sol",
        "vulnerability": "Ether lock (Ether accepted without send)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "library Uint256Helpers {\n    uint256 public constant MAX_UINT64 = uint64(-1);\n\n    string private constant ERROR_NUMBER_TOO_BIG = \"UINT64_NUMBER_TOO_BIG\";\n\n    function toUint64(uint256 a) internal pure returns (uint64) {\n        require(a <= MAX_UINT64, ERROR_NUMBER_TOO_BIG);\n        return uint64(a);\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/consensys-AragonOS_and_Aragon_Apps/aragonOS-a68479107f564e6be98a6b877b78f635fca96dbe/contracts/common/TimeHelpers.sol",
        "vulnerability": "Ether lock (Ether accepted without send)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract StratAlpaca is UpgradeableOwnable, ReentrancyGuardPausable, ISimpleStrategy, Initializable {\n\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n    using SafeERC20 for IAlpacaVault;\n\n    bool public wantIsWBNB = false;\n    IERC20 public wantToken = IERC20(0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56);\n    address public uniRouterAddress = 0x05fF2B0DB69458A0750badebc4f9e13aDd608C7F;\n\n    address public wbnbAddress =\n        0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;\n\n    IFairLaunch public fairLaunch = IFairLaunch(0xA625AB01B08ce023B2a342Dbb12a16f2C8489A8F);\n    IERC20 public alpacaToken = IERC20(0x8F0528cE5eF7B51152A59745bEfDD91D97091d2F);\n    IAlpacaVault public alpacaVault = IAlpacaVault(0x7C9e73d4C71dae564d41F78d56439bB4ba87592f);\n\n    uint256 public lastHarvestBlock = 0;\n\n    address[] public alpacaToWantPath;\n\n    uint256 public poolId = 3;\n\n    address public vault;\n\n    mapping (address => bool) public keepers;\n\n    event KeepersSet(address[] keepers, bool[] states);\n\n    constructor() public {}\n\n    /*\n     * Parameters on BSC:\n     * poolId: 3\n     * fairLaunchAddress: 0xA625AB01B08ce023B2a342Dbb12a16f2C8489A8F\n     * alpacaToken: 0x8F0528cE5eF7B51152A59745bEfDD91D97091d2F\n     * alpacaVault: 0x7C9e73d4C71dae564d41F78d56439bB4ba87592f\n     * wantAddress: 0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56\n     * bnbAddress: 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c\n     * uniRouterAddress: 0x05fF2B0DB69458A0750badebc4f9e13aDd608C7F\n     */\n    function initialize(\n        uint256 _poolId,\n        address _fairLaunchAddress,\n        address _alpacaToken,\n        address _alpacaVault,\n        address _wantAddress,\n        address _wbnbAddress,\n        address _uniRouterAddress,\n        address _vault\n    )\n        external\n        initializer\n        onlyOwner\n    {\n        poolId = _poolId;\n        fairLaunch = IFairLaunch(_fairLaunchAddress);\n        alpacaToken = IERC20(_alpacaToken);\n        alpacaVault = IAlpacaVault(_alpacaVault);\n\n        wantToken = IERC20(_wantAddress);\n        wbnbAddress = _wbnbAddress;\n\n        if (_wantAddress == wbnbAddress) {\n            wantIsWBNB = true;\n            alpacaToWantPath = [_alpacaToken, wbnbAddress];\n        } else {\n            alpacaToWantPath = [_alpacaToken, wbnbAddress, _wantAddress];\n        }\n\n        uniRouterAddress = _uniRouterAddress;\n\n        wantToken.safeApprove(_alpacaVault, uint256(-1));\n        alpacaVault.safeApprove(_fairLaunchAddress, uint256(-1));\n        alpacaToken.safeApprove(uniRouterAddress, uint256(-1));\n        vault = _vault;\n    }\n\n    modifier onlyVault() {\n        require (msg.sender == vault, \"Must from vault\");\n        _;\n    }\n\n    modifier onlyVaultOrKeeper() {\n        require (msg.sender == vault || keepers[msg.sender], \"Must from vault/keeper\");\n        _;\n    }\n\n    function alpacaVaultTotalToken() public view returns (uint256) {\n        uint256 reservePool = alpacaVault.reservePool();\n        uint256 vaultDebtVal = alpacaVault.vaultDebtVal();\n        if (now > alpacaVault.lastAccrueTime()) {\n            uint256 interest = alpacaVault.pendingInterest(0);\n            uint256 toReserve = interest.mul(IVaultConfig(alpacaVault.config()).getReservePoolBps()).div(10000);\n            reservePool = reservePool.add(toReserve);\n            vaultDebtVal = vaultDebtVal.add(interest);\n        }\n        return wantToken.balanceOf(address(alpacaVault)).add(vaultDebtVal).sub(reservePool);\n    }\n    \n    function _ibDeposited() internal view returns (uint256) {\n        (uint256 ibBal,,,) = fairLaunch.userInfo(poolId, address(this));\n        return ibBal;\n    }\n\n    function totalBalance() external override view returns (uint256) {\n        uint256 ibBal = _ibDeposited();\n        return alpacaVaultTotalToken().mul(ibBal).div(alpacaVault.totalSupply());\n    }\n\n    function wantAmtToIbAmount(uint256 _wantAmt) public view returns (uint256) {\n        return _wantAmt.mul(alpacaVault.totalSupply()).div(alpacaVaultTotalToken());\n    }\n\n// SWC-114-Transaction Order Dependence: L191\n    function deposit(uint256 _wantAmt)\n        external\n        override\n        onlyVault\n        nonReentrantAndUnpaused\n    {\n        IERC20(wantToken).safeTransferFrom(\n            address(msg.sender),\n            address(this),\n            _wantAmt\n        );\n\n        alpacaVault.deposit(_wantAmt);\n        fairLaunch.deposit(address(this), poolId, alpacaVault.balanceOf(address(this)));\n    }\n\n    function withdraw(uint256 _wantAmt)\n        external\n        override\n        onlyVault\n        nonReentrantAndUnpaused\n    {\n        uint256 ibAmt = wantAmtToIbAmount(_wantAmt);\n        fairLaunch.withdraw(address(this), poolId, ibAmt);\n        alpacaVault.withdraw(alpacaVault.balanceOf(address(this)));\n\n        uint256 actualWantAmount = wantToken.balanceOf(address(this));\n        wantToken.safeTransfer(\n            address(msg.sender),\n            actualWantAmount\n        );\n    }\n\n    function _harvest(uint256 priceMin) internal {\n        if (lastHarvestBlock == block.number) {\n            return;\n        }\n\n        // Do not harvest if no token is deposited (otherwise, fairLaunch will fail)\n        if (_ibDeposited() == 0) {\n            return;\n        }\n\n        // Collect alpacaToken\n        fairLaunch.harvest(poolId);\n\n        uint256 earnedAlpacaBalance = alpacaToken.balanceOf(address(this));\n        if (earnedAlpacaBalance == 0) {\n            return;\n        }\n\n        if (alpacaToken != wantToken) {\n            IPancakeRouter02(uniRouterAddress).swapExactTokensForTokens(\n                earnedAlpacaBalance,\n                earnedAlpacaBalance.mul(priceMin).div(1e18),\n                alpacaToWantPath,\n                address(this),\n                now.add(600)\n            );\n        }\n\n        alpacaVault.deposit(IERC20(wantToken).balanceOf(address(this)));\n        fairLaunch.deposit(address(this), poolId, alpacaVault.balanceOf(address(this)));\n\n        lastHarvestBlock = block.number;\n    }\n\n    function harvest(uint256 minPrice) external override onlyVaultOrKeeper nonReentrantAndUnpaused {\n        _harvest(minPrice);\n    }\n\n    /**\n     * @dev Pauses the strat.\n     */\n    function pause(uint256 _flags) external onlyOwner {\n        _pause();\n\n        alpacaToken.safeApprove(uniRouterAddress, 0);\n        wantToken.safeApprove(uniRouterAddress, 0);\n    }\n\n    /**\n     * @dev Unpauses the strat.\n     */\n    function unpause(uint256 _flags) external onlyOwner {\n        _unpause();\n\n        alpacaToken.safeApprove(uniRouterAddress, uint256(-1));\n        wantToken.safeApprove(uniRouterAddress, uint256(-1));\n    }\n\n    function setVault(address _vault) external onlyOwner {\n        vault = _vault;\n    }\n\n    function setKeepers(address[] calldata _keepers, bool[] calldata _states) external onlyOwner {\n        uint256 n = _keepers.length;\n        for(uint256 i = 0; i < n; i++) {\n            keepers[_keepers[i]] = _states[i];\n        }\n        emit KeepersSet(_keepers, _states);\n    }\n\n    receive() external payable {}\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Inspex-StakingPool, Vault, Strategy & VotingEscrow/scientix-contract-main/contracts/vaults/StratAlpaca.sol",
        "vulnerability": "Ether lock",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract Vault {\n    using SafeMath for uint;\n    /**\n     * @dev Storage slot with the incognito proxy.\n     * This is the keccak-256 hash of \"eip1967.proxy.incognito.\" subtracted by 1\n     */\n    bytes32 private constant _INCOGNITO_SLOT = 0x62135fc083646fdb4e1a9d700e351b886a4a5a39da980650269edd1ade91ffd2;\n    address constant public ETH_TOKEN = 0x0000000000000000000000000000000000000000;\n    mapping(bytes32 => bool) public withdrawed;\n    mapping(bytes32 => bool) public sigDataUsed;\n    // address => token => amount\n    mapping(address => mapping(address => uint)) public withdrawRequests;\n    mapping(address => mapping(address => bool)) public migration;\n    mapping(address => uint) public totalDepositedToSCAmount;\n    Withdrawable public prevVault;\n    bool public notEntered = true;\n    bool public isInitialized = false;\n\n    struct BurnInstData {\n        uint8 meta; // type of the instruction\n        uint8 shard; // ID of the Incognito shard containing the instruction, must be 1\n        address token; // ETH address of the token contract (0x0 for ETH)\n        address payable to; // ETH address of the receiver of the token\n        uint amount; // burned amount (on Incognito)\n        bytes32 itx; // Incognito's burning tx\n    }\n\n    // error code\n    enum Errors {\n        EMPTY,\n        NO_REENTRANCE,\n        MAX_UINT_REACHED,\n        VALUE_OVER_FLOW,\n        INTERNAL_TX_ERROR,\n        ALREADY_USED,\n        INVALID_DATA,\n        TOKEN_NOT_ENOUGH,\n        WITHDRAW_REQUEST_TOKEN_NOT_ENOUGH,\n        INVALID_RETURN_DATA,\n        NOT_EQUAL,\n        NULL_VALUE,\n        ONLY_PREVAULT,\n        PREVAULT_NOT_PAUSED\n    }\n\n    event Deposit(address token, string incognitoAddress, uint amount);\n    event Withdraw(address token, address to, uint amount);\n    event UpdateTokenTotal(address[] assets, uint[] amounts);\n    event UpdateIncognitoProxy(address newIncognitoProxy);\n\n    /**\n     * modifier for contract version\n     */\n     modifier onlyPreVault(){\n        require(address(prevVault) != address(0x0) && msg.sender == address(prevVault), errorToString(Errors.ONLY_PREVAULT));\n        _;\n     }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, notEntered will be true\n        require(notEntered, errorToString(Errors.NO_REENTRANCE));\n\n        // Any calls to nonReentrant after this point will fail\n        notEntered = false;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        notEntered = true;\n    }\n\n    /**\n     * @dev Creates new Vault to hold assets for Incognito Chain\n     * @param _prevVault: previous version of the Vault to refer back if necessary\n     * After migrating all assets to a new Vault, we still need to refer\n     * back to previous Vault to make sure old withdrawals aren't being reused\n     */\n    function initialize(address _prevVault) external {\n        require(!isInitialized);\n        prevVault = Withdrawable(_prevVault);\n        isInitialized = true;\n        notEntered = true;\n    }\n\n    /**\n     * @dev Returns the current incognito proxy.\n     */\n    function _incognito() internal view returns (address icg) {\n        bytes32 slot = _INCOGNITO_SLOT;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            icg := sload(slot)\n        }\n    }\n\n    /**\n     * @dev Makes a ETH deposit to the vault to mint pETH over at Incognito Chain\n     * @notice This only works when the contract is not Paused\n     * @notice The maximum amount to deposit is capped since Incognito balance is stored as uint64\n     * @param incognitoAddress: Incognito Address to receive pETH\n     */\n    function deposit(string calldata incognitoAddress) external payable nonReentrant {\n        require(address(this).balance <= 10 ** 27, errorToString(Errors.MAX_UINT_REACHED));\n        emit Deposit(ETH_TOKEN, incognitoAddress, msg.value);\n    }\n\n    /**\n     * @dev Makes a ERC20 deposit to the vault to mint pERC20 over at Incognito Chain\n     * @notice This only works when the contract is not Paused\n     * @notice The maximum amount to deposit is capped since Incognito balance is stored as uint64\n     * @notice Before calling this function, enough ERC20 must be allowed to\n     * tranfer from msg.sender to this contract\n     * @param token: address of the ERC20 token\n     * @param amount: to deposit to the vault and mint on Incognito Chain\n     * @param incognitoAddress: Incognito Address to receive pERC20\n     */\n    function depositERC20(address token, uint amount, string calldata incognitoAddress) external payable nonReentrant {\n        IERC20 erc20Interface = IERC20(token);\n        uint8 decimals = getDecimals(address(token));\n        uint tokenBalance = erc20Interface.balanceOf(address(this));\n        uint beforeTransfer = tokenBalance;\n        uint emitAmount = amount;\n        if (decimals > 9) {\n            emitAmount = emitAmount / (10 ** (uint(decimals) - 9));\n            tokenBalance = tokenBalance / (10 ** (uint(decimals) - 9));\n        }\n        require(emitAmount <= 10 ** 18 && tokenBalance <= 10 ** 18 && emitAmount.safeAdd(tokenBalance) <= 10 ** 18, errorToString(Errors.VALUE_OVER_FLOW));\n        erc20Interface.transferFrom(msg.sender, address(this), amount);\n        require(checkSuccess(), errorToString(Errors.INTERNAL_TX_ERROR));\n        require(balanceOf(token).safeSub(beforeTransfer) == amount, errorToString(Errors.NOT_EQUAL));\n\n        emit Deposit(token, incognitoAddress, emitAmount);\n    }\n\n    /**\n     * @dev Checks if a burn proof has been used before\n     * @notice First, we check inside the storage of this contract itself. If the\n     * hash has been used before, we return the result. Otherwise, we query\n     * previous vault recursively until the first Vault (prevVault address is 0x0)\n     * @param hash: of the burn proof\n     * @return bool: whether the proof has been used or not\n     */\n    function isWithdrawed(bytes32 hash) public view returns(bool) {\n        if (withdrawed[hash]) {\n            return true;\n        } else if (address(prevVault) == address(0)) {\n            return false;\n        }\n        return prevVault.isWithdrawed(hash);\n    }\n\n    /**\n     * @dev Parses a burn instruction and returns the components\n     * @param inst: the full instruction, containing both metadata and body\n     */\n    function parseBurnInst(bytes memory inst) public pure returns (BurnInstData memory) {\n        BurnInstData memory data;\n        data.meta = uint8(inst[0]);\n        data.shard = uint8(inst[1]);\n        address token;\n        address payable to;\n        uint amount;\n        bytes32 itx;\n        assembly {\n            // skip first 0x20 bytes (stored length of inst)\n            token := mload(add(inst, 0x22)) // [3:34]\n            to := mload(add(inst, 0x42)) // [34:66]\n            amount := mload(add(inst, 0x62)) // [66:98]\n            itx := mload(add(inst, 0x82)) // [98:130]\n        }\n        data.token = token;\n        data.to = to;\n        data.amount = amount;\n        data.itx = itx;\n        return data;\n    }\n\n    /**\n     * @dev Verifies that a burn instruction is valid\n     * @notice All params except inst are the list of 2 elements corresponding to\n     * the proof on beacon and bridge\n     * @notice All params are the same as in `withdraw`\n     */\n    function verifyInst(\n        bytes memory inst,\n        uint heights,\n        bytes32[] memory instPaths,\n        bool[] memory instPathIsLefts,\n        bytes32 instRoots,\n        bytes32 blkData,\n        uint[] memory sigIdxs,\n        uint8[] memory sigVs,\n        bytes32[] memory sigRs,\n        bytes32[] memory sigSs\n    ) view internal {\n        // Each instruction can only by redeemed once\n        bytes32 beaconInstHash = keccak256(abi.encodePacked(inst, heights));\n\n        // Verify instruction on beacon\n        require(Incognito(_incognito()).instructionApproved(\n            true, // Only check instruction on beacon\n            beaconInstHash,\n            heights,\n            instPaths,\n            instPathIsLefts,\n            instRoots,\n            blkData,\n            sigIdxs,\n            sigVs,\n            sigRs,\n            sigSs\n        ), errorToString(Errors.INVALID_DATA));\n    }\n\n    /**\n     * @dev Withdraws pETH/pIERC20 by providing a burn proof over at Incognito Chain\n     * @notice This function takes a burn instruction on Incognito Chain, checks\n     * for its validity and returns the token back to ETH chain\n     * @notice This only works when the contract is not Paused\n     * @param inst: the decoded instruction as a list of bytes\n     * @param heights: the blocks containing the instruction\n     * @param instPaths: merkle path of the instruction\n     * @param instPathIsLefts: whether each node on the path is the left or right child\n     * @param instRoots: root of the merkle tree contains all instructions\n     * @param blkData: merkle has of the block body\n     * @param sigIdxs: indices of the validators who signed this block\n     * @param sigVs: part of the signatures of the validators\n     * @param sigRs: part of the signatures of the validators\n     * @param sigSs: part of the signatures of the validators\n     */\n    function withdraw(\n        bytes memory inst,\n        uint heights,\n        bytes32[] memory instPaths,\n        bool[] memory instPathIsLefts,\n        bytes32 instRoots,\n        bytes32 blkData,\n        uint[] memory sigIdxs,\n        uint8[] memory sigVs,\n        bytes32[] memory sigRs,\n        bytes32[] memory sigSs\n    ) public nonReentrant {\n        require(inst.length >= 130);\n        BurnInstData memory data = parseBurnInst(inst);\n        require(data.meta == 241 && data.shard == 1); // Check instruction type\n\n        // Not withdrawed\n        require(!isWithdrawed(data.itx), errorToString(Errors.ALREADY_USED));\n        withdrawed[data.itx] = true;\n\n        // Check if balance is enough\n        if (data.token == ETH_TOKEN) {\n            require(address(this).balance >= data.amount.safeAdd(totalDepositedToSCAmount[data.token]), errorToString(Errors.TOKEN_NOT_ENOUGH));\n        } else {\n            uint8 decimals = getDecimals(data.token);\n            if (decimals > 9) {\n                data.amount = data.amount * (10 ** (uint(decimals) - 9));\n            }\n            require(IERC20(data.token).balanceOf(address(this)) >= data.amount.safeAdd(totalDepositedToSCAmount[data.token]), errorToString(Errors.TOKEN_NOT_ENOUGH));\n        }\n\n        verifyInst(\n            inst,\n            heights,\n            instPaths,\n            instPathIsLefts,\n            instRoots,\n            blkData,\n            sigIdxs,\n            sigVs,\n            sigRs,\n            sigSs\n        );\n\n        // Send and notify\n        if (data.token == ETH_TOKEN) {\n          (bool success, ) =  data.to.call{value: data.amount}(\"\");\n          require(success, errorToString(Errors.INTERNAL_TX_ERROR));\n        } else {\n            IERC20(data.token).transfer(data.to, data.amount);\n            require(checkSuccess(), errorToString(Errors.INTERNAL_TX_ERROR));\n        }\n        emit Withdraw(data.token, data.to, data.amount);\n    }\n\n    /**\n     * @dev Burnt Proof is submited to store burnt amount of p-token/p-ETH and receiver's address\n     * Receiver then can call withdrawRequest to withdraw these token to he/she incognito address.\n     * @notice This function takes a burn instruction on Incognito Chain, checks\n     * for its validity and returns the token back to ETH chain\n     * @notice This only works when the contract is not Paused\n     * @param inst: the decoded instruction as a list of bytes\n     * @param heights: the blocks containing the instruction\n     * @param instPaths: merkle path of the instruction\n     * @param instPathIsLefts: whether each node on the path is the left or right child\n     * @param instRoots: root of the merkle tree contains all instructions\n     * @param blkData: merkle has of the block body\n     * @param sigIdxs: indices of the validators who signed this block\n     * @param sigVs: part of the signatures of the validators\n     * @param sigRs: part of the signatures of the validators\n     * @param sigSs: part of the signatures of the validators\n     */\n    function submitBurnProof(\n        bytes memory inst,\n        uint heights,\n        bytes32[] memory instPaths,\n        bool[] memory instPathIsLefts,\n        bytes32 instRoots,\n        bytes32 blkData,\n        uint[] memory sigIdxs,\n        uint8[] memory sigVs,\n        bytes32[] memory sigRs,\n        bytes32[] memory sigSs\n    ) public nonReentrant {\n        require(inst.length >= 130);\n        BurnInstData memory data = parseBurnInst(inst);\n        require(data.meta == 243 && data.shard == 1); // Check instruction type\n\n        // Not withdrawed\n        require(!isWithdrawed(data.itx), errorToString(Errors.ALREADY_USED));\n        withdrawed[data.itx] = true;\n\n        // Check if balance is enough\n        if (data.token == ETH_TOKEN) {\n            require(address(this).balance >= data.amount.safeAdd(totalDepositedToSCAmount[data.token]), errorToString(Errors.TOKEN_NOT_ENOUGH));\n        } else {\n            uint8 decimals = getDecimals(data.token);\n            if (decimals > 9) {\n                // SWC-101-Integer Overflow and Underflow: L409\n                data.amount = data.amount * (10 ** (uint(decimals) - 9));\n            }\n            require(IERC20(data.token).balanceOf(address(this)) >= data.amount.safeAdd(totalDepositedToSCAmount[data.token]), errorToString(Errors.TOKEN_NOT_ENOUGH));\n        }\n\n        verifyInst(\n            inst,\n            heights,\n            instPaths,\n            instPathIsLefts,\n            instRoots,\n            blkData,\n            sigIdxs,\n            sigVs,\n            sigRs,\n            sigSs\n        );\n\n        withdrawRequests[data.to][data.token] = withdrawRequests[data.to][data.token].safeAdd(data.amount);\n        totalDepositedToSCAmount[data.token] = totalDepositedToSCAmount[data.token].safeAdd(data.amount);\n    }\n\n    /**\n     * @dev generate address from signature data and hash.\n     */\n    function sigToAddress(bytes memory signData, bytes32 hash) public pure returns (address) {\n        bytes32 s;\n        bytes32 r;\n        uint8 v;\n        assembly {\n            r := mload(add(signData, 0x20))\n            s := mload(add(signData, 0x40))\n        }\n        v = uint8(signData[64]) + 27;\n        return ecrecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Checks if a sig data has been used before\n     * @notice First, we check inside the storage of this contract itself. If the\n     * hash has been used before, we return the result. Otherwise, we query\n     * previous vault recursively until the first Vault (prevVault address is 0x0)\n     * @param hash: of the sig data\n     * @return bool: whether the sig data has been used or not\n     */\n    function isSigDataUsed(bytes32 hash) public view returns(bool) {\n        if (sigDataUsed[hash]) {\n            return true;\n        } else if (address(prevVault) == address(0)) {\n            return false;\n        }\n        return prevVault.isSigDataUsed(hash);\n    }\n\n    /**\n     * @dev User requests withdraw token contains in withdrawRequests.\n     * Deposit event will be emitted to let incognito recognize and mint new p-tokens for the user.\n     * @param incognitoAddress: incognito's address that will receive minted p-tokens.\n     * @param token: ethereum's token address (eg., ETH, DAI, ...)\n     * @param amount: amount of the token in ethereum's denomination\n     * @param signData: signature of an unique data that is signed by an account which is generated from user's incognito privkey\n     * @param timestamp: unique data generated from client (timestamp for example)\n     */\n    function requestWithdraw(\n        string calldata incognitoAddress,\n        address token,\n        uint amount,\n        bytes calldata signData,\n        bytes calldata timestamp\n    ) external nonReentrant {\n        // verify owner signs data\n        address verifier = verifySignData(abi.encode(incognitoAddress, token, timestamp, amount), signData);\n\n        // migrate from preVault\n        migrateBalance(verifier, token);\n\n        require(withdrawRequests[verifier][token] >= amount, errorToString(Errors.WITHDRAW_REQUEST_TOKEN_NOT_ENOUGH));\n        withdrawRequests[verifier][token] = withdrawRequests[verifier][token].safeSub(amount);\n        totalDepositedToSCAmount[token] = totalDepositedToSCAmount[token].safeSub(amount);\n\n        // convert denomination from ethereum's to incognito's (pcoin)\n        uint emitAmount = amount;\n        if (token != ETH_TOKEN) {\n            uint8 decimals = getDecimals(token);\n            if (decimals > 9) {\n                emitAmount = amount / (10 ** (uint(decimals) - 9));\n            }\n        }\n\n        emit Deposit(token, incognitoAddress, emitAmount);\n    }\n\n    /**\n     * @dev execute is a general function that plays a role as proxy to interact to other smart contracts.\n     * @param token: ethereum's token address (eg., ETH, DAI, ...)\n     * @param amount: amount of the token in ethereum's denomination\n     * @param recipientToken: received token address.\n     * @param exchangeAddress: address of targeting smart contract that actually executes the desired logics like trade, invest, borrow and so on.\n     * @param callData: encoded with signature and params of function from targeting smart contract.\n     * @param timestamp: unique data generated from client (timestamp for example)\n     * @param signData: signature of an unique data that is signed by an account which is generated from user's incognito privkey\n     */\n    //  SWC-114-Transaction Order Dependence: L512 - L547\n    // SWC-105-Unprotected Ether Withdrawal: L513 - 548\n    function execute(\n        address token,\n        uint amount,\n        address recipientToken,\n        address exchangeAddress,\n        bytes calldata callData,\n        bytes calldata timestamp,\n        bytes calldata signData\n    ) external payable nonReentrant {\n        //verify ower signs data from input\n        address verifier = verifySignData(abi.encode(exchangeAddress, callData, timestamp, amount), signData);\n\n        // migrate from preVault\n        migrateBalance(verifier, token);\n        require(withdrawRequests[verifier][token] >= amount, errorToString(Errors.WITHDRAW_REQUEST_TOKEN_NOT_ENOUGH));\n\n        // update balance of verifier\n        totalDepositedToSCAmount[token] = totalDepositedToSCAmount[token].safeSub(amount);\n        withdrawRequests[verifier][token] = withdrawRequests[verifier][token].safeSub(amount);\n\n        // define number of eth spent for forwarder.\n        uint ethAmount = msg.value;\n        if (token == ETH_TOKEN) {\n            ethAmount = ethAmount.safeAdd(amount);\n        } else {\n            // transfer token to exchangeAddress.\n            require(IERC20(token).balanceOf(address(this)) >= amount, errorToString(Errors.TOKEN_NOT_ENOUGH));\n            IERC20(token).transfer(exchangeAddress, amount);\n            require(checkSuccess(), errorToString(Errors.INTERNAL_TX_ERROR));\n        }\n        uint returnedAmount = callExtFunc(recipientToken, ethAmount, callData, exchangeAddress);\n\n        // update withdrawRequests\n        withdrawRequests[verifier][recipientToken] = withdrawRequests[verifier][recipientToken].safeAdd(returnedAmount);\n        totalDepositedToSCAmount[recipientToken] = totalDepositedToSCAmount[recipientToken].safeAdd(returnedAmount);\n    }\n\n    /**\n     * @dev single trade\n     */\n    function callExtFunc(address recipientToken, uint ethAmount, bytes memory callData, address exchangeAddress) internal returns (uint) {\n         // get balance of recipient token before trade to compare after trade.\n        uint balanceBeforeTrade = balanceOf(recipientToken);\n        if (recipientToken == ETH_TOKEN) {\n            balanceBeforeTrade = balanceBeforeTrade.safeSub(msg.value);\n        }\n        require(address(this).balance >= ethAmount, errorToString(Errors.TOKEN_NOT_ENOUGH));\n        (bool success, bytes memory result) = exchangeAddress.call{value: ethAmount}(callData);\n        require(success);\n\n        (address returnedTokenAddress, uint returnedAmount) = abi.decode(result, (address, uint));\n        require(returnedTokenAddress == recipientToken && balanceOf(recipientToken).safeSub(balanceBeforeTrade) == returnedAmount, errorToString(Errors.INVALID_RETURN_DATA));\n\n        return returnedAmount;\n    }\n\n    /**\n     * @dev verify sign data\n     */\n     function verifySignData(bytes memory data, bytes memory signData) internal returns(address){\n        bytes32 hash = keccak256(data);\n        require(!isSigDataUsed(hash), errorToString(Errors.ALREADY_USED));\n        address verifier = sigToAddress(signData, hash);\n       // mark data hash of sig as used\n        sigDataUsed[hash] = true;\n\n        return verifier;\n     }\n\n    /**\n      * @dev migrate balance from previous vault\n      * Note: uncomment for next version\n      */\n    function migrateBalance(address owner, address token) internal {\n        if (address(prevVault) != address(0x0) && !migration[owner][token]) {\n            withdrawRequests[owner][token] = withdrawRequests[owner][token].safeAdd(prevVault.getDepositedBalance(token, owner));\n  \t        migration[owner][token] = true;\n  \t   }\n    }\n\n    /**\n     * @dev Get the amount of specific coin for specific wallet\n     */\n    function getDepositedBalance(\n        address token,\n        address owner\n    ) public view returns (uint) {\n        if (address(prevVault) != address(0x0) && !migration[owner][token]) {\n \t        return withdrawRequests[owner][token].safeAdd(prevVault.getDepositedBalance(token, owner));\n \t    }\n        return withdrawRequests[owner][token];\n    }\n\n    /**\n     * @dev Move total number of assets to newVault\n     * @notice This only works when the preVault is Paused\n     * @notice This can only be called by preVault\n     * @param assets: address of the ERC20 tokens to move, 0x0 for ETH\n     * @param amounts: total number of the ERC20 tokens to move, 0x0 for ETH\n     */\n    function updateAssets(address[] calldata assets, uint[] calldata amounts) external onlyPreVault returns(bool) {\n        require(assets.length == amounts.length,  errorToString(Errors.NOT_EQUAL));\n        require(Withdrawable(prevVault).paused(), errorToString(Errors.PREVAULT_NOT_PAUSED));\n        for (uint i = 0; i < assets.length; i++) {\n            totalDepositedToSCAmount[assets[i]] = totalDepositedToSCAmount[assets[i]].safeAdd(amounts[i]);\n        }\n        emit UpdateTokenTotal(assets, amounts);\n\n        return true;\n    }\n\n    /**\n     * @dev Payable receive function to receive Ether from oldVault when migrating\n     */\n    receive() external payable {}\n\n    /**\n     * @dev Check if transfer() and transferFrom() of ERC20 succeeded or not\n     * This check is needed to fix https://github.com/ethereum/solidity/issues/4116\n     * This function is copied from https://github.com/AdExNetwork/adex-protocol-eth/blob/master/contracts/libs/SafeERC20.sol\n     */\n    function checkSuccess() private pure returns (bool) {\n\t\tuint256 returnValue = 0;\n\t\tassembly {\n\t\t\t// check number of bytes returned from last function call\n\t\t\tswitch returndatasize()\n\n\t\t\t// no bytes returned: assume success\n\t\t\tcase 0x0 {\n\t\t\t\treturnValue := 1\n\t\t\t}\n\n\t\t\t// 32 bytes returned: check if non-zero\n\t\t\tcase 0x20 {\n\t\t\t\t// copy 32 bytes into scratch space\n\t\t\t\treturndatacopy(0x0, 0x0, 0x20)\n\n\t\t\t\t// load those bytes into returnValue\n\t\t\t\treturnValue := mload(0x0)\n\t\t\t}\n\n\t\t\t// not sure what was returned: don't mark as success\n\t\t\tdefault { }\n\t\t}\n\t\treturn returnValue != 0;\n\t}\n\n    /**\n     * @dev convert enum to string value\n     */\n     function errorToString(Errors error) internal pure returns(string memory) {\n        uint8 erroNum = uint8(error);\n        uint maxlength = 10;\n        bytes memory reversed = new bytes(maxlength);\n        uint i = 0;\n        while (erroNum != 0) {\n            uint8 remainder = erroNum % 10;\n            erroNum = erroNum / 10;\n            reversed[i++] = byte(48 + remainder);\n        }\n        bytes memory s = new bytes(i + 1);\n        for (uint j = 0; j <= i; j++) {\n            s[j] = reversed[i - j];\n        }\n        return string(s);\n    }\n\n    /**\n     * @dev Get the decimals of an ERC20 token, return 0 if it isn't defined\n     * We check the returndatasize to covert both cases that the token has\n     * and doesn't have the function decimals()\n     */\n    function getDecimals(address token) public view returns (uint8) {\n        IERC20 erc20 = IERC20(token);\n        return uint8(erc20.decimals());\n    }\n\n    /**\n     * @dev Get the amount of coin deposited to this smartcontract\n     */\n    function balanceOf(address token) public view returns (uint) {\n        if (token == ETH_TOKEN) {\n            return address(this).balance;\n        }\n        return IERC20(token).balanceOf(address(this));\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinspect-Incognito Audit/bridge-eth-4879219669a38d601265582f815596b6775855b6/bridge/contracts/vault.sol",
        "vulnerability": "Ether lock",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "library SafeMath {\n    function safeAdd(uint256 a, uint256 b) external pure returns (uint256 c) {\n        c = a + b;\n        require(c >= a);\n    }\n\n    function safeSub(uint256 a, uint256 b) external pure returns (uint256 c) {\n        require(b <= a);\n        c = a - b;\n    }\n\n    function safeMul(uint256 a, uint256 b) external pure returns (uint256 c) {\n        c = a * b;\n        require(a == 0 || c / a == b);\n    }\n\n    function safeDiv(uint256 a, uint256 b) external pure returns (uint256 c) {\n        require(b > 0);\n        c = a / b;\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Hacken-Argon Foundation/platform-contracts-8996d21499ede3f2eb36320ded9563f5467a0fa6/ArgonFreelancers.sol",
        "vulnerability": "Ether lock (Ether accepted without send)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract StakefishServicesContract is IStakefishServicesContract {\n    using Address for address payable;\n\n    uint256 private constant HOUR = 3600;\n    uint256 private constant DAY = 24 * HOUR;\n    uint256 private constant WEEK = 7 * DAY;\n    uint256 private constant YEAR = 365 * DAY;\n    uint256 private constant MAX_SECONDS_IN_EXIT_QUEUE = 1 * YEAR;\n    // SWC-131-Presence of unused variables: L33\n    uint256 private constant MAX_TIME_TO_WITHDRAW = 1 * YEAR;\n    uint256 private constant COMMISSION_RATE_SCALE = 1000000;\n\n    // Packed into a single slot\n    uint24 private _commissionRate;\n    address private _operatorAddress;\n    uint64 private _exitDate;\n    State private _state;\n\n    bytes32 private _operatorDataCommitment;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n    mapping(address => mapping(address => uint256)) private _allowedWithdrawals;\n    mapping(address => uint256) private _deposits;\n    uint256 private _totalDeposits;\n\n    IDepositContract public constant depositContract =\n        IDepositContract(0x00000000219ab540356cBB839Cbe05303d7705Fa);\n\n    modifier onlyOperator() {\n        require(\n            msg.sender == _operatorAddress,\n            \"Caller is not the operator\"\n        );\n        _;\n    }\n\n    modifier initializer() {\n        require(\n            _state == State.NotInitialized,\n            \"Contract is already initialized\"\n        );\n        _state = State.PreDeposit;\n        _;\n    }\n\n    function initialize(\n        uint24 commissionRate,\n        address operatorAddress,\n        bytes32 operatorDataCommitment\n    )\n        external\n        initializer\n    {\n        _commissionRate = commissionRate;\n        _operatorAddress = operatorAddress;\n        _operatorDataCommitment = operatorDataCommitment;\n    }\n\n    receive() payable external {\n        if (_state == State.PreDeposit) {\n            _handleDeposit(msg.sender);\n        }\n    }\n\n    function updateExitDate(uint64 newExitDate)\n        external\n        override\n        onlyOperator\n    {\n        require(\n            _state == State.PostDeposit,\n            \"Validator is not active\"\n        );\n\n        require(\n            newExitDate < _exitDate,\n            \"Not earlier than the original value\"\n        );\n\n        _exitDate = newExitDate;\n    }\n\n    function createValidator(\n        bytes calldata validatorPubKey, // 48 bytes\n        bytes calldata depositSignature, // 96 bytes\n        bytes32 depositDataRoot,\n        uint64 exitDate\n    )\n        external\n        override\n        onlyOperator\n    {\n\n        require(_state == State.PreDeposit, \"Validator has been created\");\n        _state = State.PostDeposit;\n\n        require(validatorPubKey.length == 48, \"Invalid validator public key\");\n        require(depositSignature.length == 96, \"Invalid deposit signature\");\n        require(_operatorDataCommitment == keccak256(\n            abi.encodePacked(\n                address(this),\n                validatorPubKey,\n                depositSignature,\n                depositDataRoot,\n                exitDate\n            )\n        ), \"Data doesn't match commitment\");\n\n        _exitDate = exitDate;\n\n        depositContract.deposit{value: 32 ether}(\n            validatorPubKey,\n            abi.encodePacked(uint96(0x010000000000000000000000), address(this)),\n            depositSignature,\n            depositDataRoot\n        );\n\n        emit ValidatorDeposited(validatorPubKey);\n    }\n\n    function deposit()\n        external\n        payable\n        override\n        returns (uint256 surplus)\n    {\n        require(\n            _state == State.PreDeposit,\n            \"Validator already created\"\n        );\n\n        return _handleDeposit(msg.sender);\n    }\n\n    function depositOnBehalfOf(address depositor)\n        external\n        payable\n        override\n        returns (uint256 surplus)\n    {\n        require(\n            _state == State.PreDeposit,\n            \"Validator already created\"\n        );\n        return _handleDeposit(depositor);\n    }\n    // SWC-113-DoS with Failed Call: L171-L189\n    function endOperatorServices()\n        external\n        override\n    {\n        require(_state == State.PostDeposit, \"Not allowed in the current state\");\n        require((msg.sender == _operatorAddress) ||\n                (_deposits[msg.sender] > 0 && block.timestamp > _exitDate + MAX_SECONDS_IN_EXIT_QUEUE), \"Not allowed at the current time\");\n\n        _state = State.Withdrawn;\n\n        uint256 balance = address(this).balance;\n        if (balance > 32 ether) {\n            uint256 profit = balance - 32 ether;\n            uint256 finalCommission = profit * _commissionRate / COMMISSION_RATE_SCALE;\n            payable(_operatorAddress).sendValue(finalCommission);\n        }\n\n        emit ServiceEnd(block.timestamp);\n    }\n\n    string private constant WITHDRAWALS_NOT_ALLOWED =\n        \"Not allowed when validator is active\";\n\n    function withdrawAll()\n        external\n        override\n        returns (uint256)\n    {\n        require(_state != State.PostDeposit, WITHDRAWALS_NOT_ALLOWED);\n        return _executeWithdrawal(msg.sender, payable(msg.sender), _deposits[msg.sender]);\n    }\n\n    function withdraw(\n        uint256 amount\n    )\n        external\n        override\n        returns (uint256)\n    {\n        require(_state != State.PostDeposit, WITHDRAWALS_NOT_ALLOWED);\n        return _executeWithdrawal(msg.sender, payable(msg.sender), amount);\n    }\n\n    function withdrawTo(\n        uint256 amount,\n        address payable beneficiary\n    )\n        external\n        override\n        returns (uint256)\n    {\n        require(_state != State.PostDeposit, WITHDRAWALS_NOT_ALLOWED);\n        return _executeWithdrawal(msg.sender, beneficiary, amount);\n    }\n    // SWC-114-Transaction Order Dependence: L226-L247\n    function approve(\n        address spender,\n        uint256 amount\n    )\n        public\n        override\n        returns (bool)\n    {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n\n    function approveWithdrawal(\n        address spender,\n        uint256 amount\n    )\n        external\n        override\n    {\n        _allowedWithdrawals[msg.sender][spender] = amount;\n        emit WithdrawalApproval(msg.sender, spender, amount);\n    }\n\n    function withdrawFrom(\n        address depositor,\n        address payable beneficiary,\n        uint256 amount\n    )\n        external\n        override\n        returns (uint256)\n    {\n        require(_state != State.PostDeposit, WITHDRAWALS_NOT_ALLOWED);\n        uint256 spenderAllowance = _allowedWithdrawals[depositor][msg.sender];\n        uint256 newAllowance = spenderAllowance - amount;\n        // Please note that there is no need to require(_deposit <= spenderAllowance)\n        // here because modern versions of Solidity insert underflow checks\n        _allowedWithdrawals[depositor][msg.sender] = newAllowance;\n        emit WithdrawalApproval(depositor, msg.sender, newAllowance);\n\n        return _executeWithdrawal(depositor, beneficiary, amount);\n    }\n\n    function transferDeposit(\n        address to,\n        uint256 amount\n    )\n        external\n        override\n        returns (bool)\n    {\n        _transfer(msg.sender, to, amount);\n        return true;\n    }\n\n    function transferDepositFrom(\n        address from,\n        address to,\n        uint256 amount\n    )\n        external\n        override\n        returns (bool)\n    {\n        uint256 currentAllowance = _allowances[from][msg.sender];\n\n        _approve(from, msg.sender, currentAllowance - amount);\n        _transfer(from, to, amount);\n\n        return true;\n    }\n\n    function withdrawalAllowance(\n        address depositor,\n        address spender\n    )\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return _allowedWithdrawals[depositor][spender];\n    }\n\n    function getCommissionRate()\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return _commissionRate;\n    }\n\n    function getExitDate()\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return _exitDate;\n    }\n\n    function getState()\n        external\n        view\n        override\n        returns(State)\n    {\n        return _state;\n    }\n\n    function getOperatorAddress()\n        external\n        view\n        override\n        returns (address)\n    {\n        return _operatorAddress;\n    }\n\n    function getDeposit(address depositor)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return _deposits[depositor];\n    }\n\n    function getTotalDeposits()\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return _totalDeposits;\n    }\n\n    function getAllowance(\n        address owner,\n        address spender\n    )\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return _allowances[owner][spender];\n    }\n\n    function getOperatorDataCommitment()\n        external\n        view\n        override\n        returns (bytes32)\n    {\n        return _operatorDataCommitment;\n    }\n\n    function _executeWithdrawal(\n        address depositor,\n        address payable beneficiary,\n        uint256 amount\n    )\n        internal\n        returns (uint256)\n    {\n        require(amount > 0, \"Amount shouldn't be zero\");\n\n        uint256 value = amount * address(this).balance / _totalDeposits;\n        // Modern versions of Solidity automatically add underflow checks,\n        // so we don't need to `require(_deposits[_depositor] < _deposit` here:\n        _deposits[depositor] -= amount;\n        _totalDeposits -= amount;\n        emit Withdrawal(depositor, beneficiary, amount, value);\n        payable(beneficiary).sendValue(value);\n\n        return value;\n    }\n\n    // NOTE: This throws (on underflow) if the contract's balance was more than\n    // 32 ether before the call\n    function _handleDeposit(address depositor)\n        internal\n        returns (uint256 surplus)\n    {\n        uint256 depositSize = msg.value;\n        surplus = (address(this).balance > 32 ether) ?\n            (address(this).balance - 32 ether) : 0;\n\n        uint256 acceptedDeposit = depositSize - surplus;\n\n        _deposits[depositor] += acceptedDeposit;\n        _totalDeposits += acceptedDeposit;\n\n        emit Deposit(depositor, acceptedDeposit);\n\n        payable(depositor).sendValue(surplus);\n    }\n\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    )\n        internal\n    {\n        require(to != address(0), \"Transfer to the zero address\");\n\n        _deposits[from] -= amount;\n        _deposits[to] += amount;\n\n        emit Transfer(from, to, amount);\n    }\n\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    )\n        internal\n    {\n        require(spender != address(0), \"Approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Runtime_VÐµrification-stakefish_ethereum_staking_audit_report/eth2-validation-services-contract-d91928f3a270f6115831fe3a21a69eb98bf57b26/contracts/StakefishServicesContract.sol",
        "vulnerability": "Ether lock",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract ZeroxWrapper is IOffchainWrapper, DFSExchangeHelper, AdminAuth, DSMath {\n\n    using TokenUtils for address;\n\n    string public constant ERR_SRC_AMOUNT = \"Not enough funds\";\n    string public constant ERR_PROTOCOL_FEE = \"Not enough eth for protcol fee\";\n    string public constant ERR_TOKENS_SWAPED_ZERO = \"Order success but amount 0\";\n\n    using SafeERC20 for IERC20;\n\n    \n    \n    \n    function takeOrder(\n        ExchangeData memory _exData,\n        ExchangeActionType _type\n    ) override public payable returns (bool success, uint256) {\n        // check that contract have enough balance for exchange and protocol fee\n        require(_exData.srcAddr.getBalance(address(this)) >= _exData.srcAmount, ERR_SRC_AMOUNT);\n        require(TokenUtils.ETH_ADDR.getBalance(address(this)) >= _exData.offchainData.protocolFee, ERR_PROTOCOL_FEE);\n\n        \n        \n        if (_type == ExchangeActionType.SELL) {\n            IERC20(_exData.srcAddr).safeApprove(_exData.offchainData.allowanceTarget, _exData.srcAmount);\n        } else {\n            uint srcAmount = wdiv(_exData.destAmount, _exData.offchainData.price) + 1; // + 1 so we round up\n            IERC20(_exData.srcAddr).safeApprove(_exData.offchainData.allowanceTarget, srcAmount);\n        }\n        // SWC-101-Integer Overflow and Underflow: L42-50\n        uint256 tokensBefore = _exData.destAddr.getBalance(address(this));\n        (success, ) = _exData.offchainData.exchangeAddr.call{value: _exData.offchainData.protocolFee}(_exData.offchainData.callData);\n        uint256 tokensSwaped = 0;\n\n        if (success) {\n            // get the current balance of the swaped tokens\n            tokensSwaped = _exData.destAddr.getBalance(address(this)) - tokensBefore;\n            require(tokensSwaped > 0, ERR_TOKENS_SWAPED_ZERO);\n        }\n\n        // returns all funds from src addr, dest addr and eth funds (protocol fee leftovers)\n        sendLeftover(_exData.srcAddr, _exData.destAddr, msg.sender);\n\n        return (success, tokensSwaped);\n    }\n\n    // solhint-disable-next-line no-empty-blocks\n    receive() external virtual payable {}\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/consensys-DeFi_Saver/defisaver-v3-contracts-cb29669a84c2d6fffaf2231c0938eb407c060919/contracts/exchangeV3/offchainWrappersV3/ZeroxWrapper.sol",
        "vulnerability": "Ether lock",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract KyberWrapperV3 is DSMath, IExchangeV3, AdminAuth {\n\n    address public constant KYBER_ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    address public constant KYBER_INTERFACE = 0x9AAb3f75489902f3a48495025729a0AF77d4b11e;\n    address payable public constant WALLET_ID = 0x322d58b9E75a6918f7e7849AEe0fF09369977e08;\n\n    using SafeERC20 for IERC20;\n\n    \n    \n    \n    \n    \n    function sell(address _srcAddr, address _destAddr, uint _srcAmount, bytes memory) external override payable returns (uint) {\n        IERC20 srcToken = IERC20(_srcAddr);\n        IERC20 destToken = IERC20(_destAddr);\n\n        KyberNetworkProxyInterface kyberNetworkProxy = KyberNetworkProxyInterface(KYBER_INTERFACE);\n\n        if (_srcAddr != KYBER_ETH_ADDRESS) {\n            srcToken.safeApprove(address(kyberNetworkProxy), _srcAmount);\n        }\n\n        uint destAmount = kyberNetworkProxy.trade{value: msg.value}(\n            srcToken,\n            _srcAmount,\n            destToken,\n            msg.sender,\n            type(uint).max,\n            0,\n            WALLET_ID\n        );\n\n        return destAmount;\n    }\n\n    \n    \n    \n    \n    \n    function buy(address _srcAddr, address _destAddr, uint _destAmount, bytes memory) external override payable returns(uint) {\n        IERC20 srcToken = IERC20(_srcAddr);\n        IERC20 destToken = IERC20(_destAddr);\n\n        uint srcAmount = 0;\n        if (_srcAddr != KYBER_ETH_ADDRESS) {\n            srcAmount = srcToken.balanceOf(address(this));\n        } else {\n            srcAmount = msg.value;\n        }\n\n        KyberNetworkProxyInterface kyberNetworkProxy = KyberNetworkProxyInterface(KYBER_INTERFACE);\n\n        if (_srcAddr != KYBER_ETH_ADDRESS) {\n            srcToken.safeApprove(address(kyberNetworkProxy), srcAmount);\n        }\n\n        uint destAmount = kyberNetworkProxy.trade{value: msg.value}(\n            srcToken,\n            srcAmount,\n            destToken,\n            msg.sender,\n            _destAmount,\n            0,\n            WALLET_ID\n        );\n\n        require(destAmount == _destAmount, \"Wrong dest amount\");\n\n        uint srcAmountAfter = 0;\n\n        if (_srcAddr != KYBER_ETH_ADDRESS) {\n            srcAmountAfter = srcToken.balanceOf(address(this));\n        } else {\n            srcAmountAfter = address(this).balance;\n        }\n\n        // Send the leftover from the source token back\n        sendLeftOver(_srcAddr);\n\n        return (srcAmount - srcAmountAfter);\n    }\n\n    \n    \n    \n    \n    \n    // SWC-101-Integer Overflow and Underflow: L101-109\n    function getSellRate(address _srcAddr, address _destAddr, uint _srcAmount, bytes memory) public override view returns (uint rate) {\n        (rate, ) = KyberNetworkProxyInterface(KYBER_INTERFACE)\n            .getExpectedRate(IERC20(_srcAddr), IERC20(_destAddr), _srcAmount);\n\n        // multiply with decimal difference in src token\n        rate = rate * (10**(18 - getDecimals(_srcAddr)));\n        // divide with decimal difference in dest token\n        rate = rate / (10**(18 - getDecimals(_destAddr)));\n    }\n\n    \n    \n    \n    \n    \n    function getBuyRate(address _srcAddr, address _destAddr, uint _destAmount, bytes memory _additionalData) public override view returns (uint rate) {\n        uint256 srcRate = getSellRate(_destAddr, _srcAddr, _destAmount, _additionalData);\n        uint256 srcAmount = wmul(srcRate, _destAmount);\n\n        rate = getSellRate(_srcAddr, _destAddr, srcAmount, _additionalData);\n\n        // increase rate by 3% too account for inaccuracy between sell/buy conversion\n        rate = rate + (rate / 30);\n    }\n\n    \n    \n    function sendLeftOver(address _srcAddr) internal {\n        msg.sender.transfer(address(this).balance);\n\n        if (_srcAddr != KYBER_ETH_ADDRESS) {\n            IERC20(_srcAddr).safeTransfer(msg.sender, IERC20(_srcAddr).balanceOf(address(this)));\n        }\n    }\n\n    // solhint-disable-next-line no-empty-blocks\n    receive() payable external {}\n\n    function getDecimals(address _token) internal view returns (uint256) {\n        if (_token == KYBER_ETH_ADDRESS) return 18;\n\n        return IERC20(_token).decimals();\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/consensys-DeFi_Saver/defisaver-v3-contracts-cb29669a84c2d6fffaf2231c0938eb407c060919/contracts/exchangeV3/wrappersV3/KyberWrapperV3.sol",
        "vulnerability": "Ether lock",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract FLAaveV2 is ActionBase, StrategyData {\n    using SafeERC20 for IERC20;\n    using TokenUtils for address;\n\n    string constant ERR_ONLY_AAVE_CALLER = \"Caller not aave pool\";\n    string constant ERR_SAME_CALLER = \"FL taker must be this contract\";\n\n    address\n        public constant AAVE_LENDING_POOL = 0x7d2768dE32b0b80b7a3454c06BdAc94A69DDc7A9;\n\n    ILendingPoolAddressesProviderV2\n        public constant addressesProvider = ILendingPoolAddressesProviderV2(\n        0xB53C1a33016B2DC2fF3653530bfF1848a515c8c5\n    );\n\n    address public constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    uint16 public constant AAVE_REFERRAL_CODE = 64;\n\n    bytes4 public constant CALLBACK_SELECTOR = 0xd6741b9e;\n\n    bytes32 constant FL_AAVE_V2_ID = keccak256(\"FLAaveV2\");\n    bytes32 constant TASK_EXECUTOR_ID = keccak256(\"TaskExecutor\");\n\n    struct FLAaveV2Data {\n        address[] tokens;\n        uint256[] amounts;\n        uint256[] modes;\n        address onBehalfOf;\n        address flParamGetterAddr;\n        bytes flParamGetterData;\n    }\n\n    \n    function executeAction(\n        bytes[] memory _callData,\n        bytes[] memory,\n        uint8[] memory,\n        bytes32[] memory\n    ) public override payable returns (bytes32) {\n        FLAaveV2Data memory flData = parseInputs(_callData);\n\n        // if we want to get on chain info about FL params\n        if (flData.flParamGetterAddr != address(0)) {\n            (flData.tokens, flData.amounts, flData.modes) =\n                IFLParamGetter(flData.flParamGetterAddr).getFlashLoanParams(flData.flParamGetterData);\n        }\n\n        bytes memory taskData = _callData[_callData.length - 1];\n        uint flAmount = _flAaveV2(flData, taskData);\n\n        return bytes32(flAmount);\n    }\n\n    // solhint-disable-next-line no-empty-blocks\n    function executeActionDirect(bytes[] memory _callData) public override payable {}\n\n    \n    function actionType() public override pure returns (uint8) {\n        return uint8(ActionType.FL_ACTION);\n    }\n\n    \n\n    \n    \n    \n    function _flAaveV2(FLAaveV2Data memory _flData, bytes memory _params) internal returns (uint) {\n\n        ILendingPoolV2(AAVE_LENDING_POOL).flashLoan(\n            payable(registry.getAddr(FL_AAVE_V2_ID)),\n            _flData.tokens,\n            _flData.amounts,\n            _flData.modes,\n            _flData.onBehalfOf,\n            _params,\n            AAVE_REFERRAL_CODE\n        );\n\n        logger.Log(\n            address(this),\n            msg.sender,\n            \"FLAaveV2\",\n            abi.encode(_flData.tokens, _flData.amounts, _flData.modes, _flData.onBehalfOf)\n        );\n\n        return _flData.amounts[0];\n    }\n\n    \n    // SWC-107-Reentrancy: L106-137\n    function executeOperation(\n        address[] memory _assets,\n        uint256[] memory _amounts,\n        uint256[] memory _fees,\n        address _initiator,\n        bytes memory _params\n    ) public returns (bool) {\n        require(msg.sender == AAVE_LENDING_POOL, ERR_ONLY_AAVE_CALLER);\n        require(_initiator == address(this), ERR_SAME_CALLER);\n\n        (Task memory currTask, address proxy) = abi.decode(_params, (Task, address));\n\n        // Send FL amounts to user proxy\n        for (uint256 i = 0; i < _assets.length; ++i) {\n            _assets[i].withdrawTokens(proxy, _amounts[i]);\n        }\n\n        address payable taskExecutor = payable(registry.getAddr(TASK_EXECUTOR_ID));\n\n        // call Action execution\n        IDSProxy(proxy).execute{value: address(this).balance}(\n            taskExecutor,\n            abi.encodeWithSelector(CALLBACK_SELECTOR, currTask, bytes32(_amounts[0] + _fees[0]))\n        );\n\n        // return FL\n        for (uint256 i = 0; i < _assets.length; i++) {\n            _assets[i].approveToken(address(AAVE_LENDING_POOL), _amounts[i] + _fees[i]);\n        }\n\n        return true;\n    }\n\n    function parseInputs(bytes[] memory _callData)\n        public\n        pure\n        returns (FLAaveV2Data memory flData)\n    {\n        flData.amounts = abi.decode(_callData[0], (uint256[]));\n        flData.tokens = abi.decode(_callData[1], (address[]));\n        flData.modes = abi.decode(_callData[2], (uint256[]));\n        flData.onBehalfOf = abi.decode(_callData[3], (address));\n        flData.flParamGetterAddr = abi.decode(_callData[4], (address));\n        flData.flParamGetterData = abi.decode(_callData[5], (bytes));\n    }\n\n    // solhint-disable-next-line no-empty-blocks\n    receive() external payable {}\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/consensys-DeFi_Saver/defisaver-v3-contracts-cb29669a84c2d6fffaf2231c0938eb407c060919/contracts/actions/flashloan/FLAaveV2.sol",
        "vulnerability": "Ether lock",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract Keep3rV1Oracle {\n    using FixedPoint for *;\n    using SafeMath for uint;\n\n    struct Observation {\n        uint timestamp;\n        uint price0Cumulative;\n        uint price1Cumulative;\n    }\n\n    uint public minKeep = 200e18;\n\n    modifier keeper() {\n        require(KP3R.isMinKeeper(msg.sender, minKeep, 0, 0), \"::isKeeper: keeper is not registered\");\n        _;\n    }\n\n    modifier upkeep() {\n        uint _gasUsed = gasleft();\n        require(KP3R.isMinKeeper(msg.sender, minKeep, 0, 0), \"::isKeeper: keeper is not registered\");\n        _;\n        uint _received = KP3R.KPRH().getQuoteLimit(_gasUsed.sub(gasleft()));\n        KP3R.receipt(address(KP3R), address(this), _received);\n        _received = _swap(_received);\n        msg.sender.transfer(_received);\n    }\n\n    address public governance;\n    address public pendingGovernance;\n\n    function setMinKeep(uint _keep) external {\n        require(msg.sender == governance, \"setGovernance: !gov\");\n        minKeep = _keep;\n    }\n\n    /**\n     * @notice Allows governance to change governance (for future upgradability)\n     * @param _governance new governance address to set\n     */\n    function setGovernance(address _governance) external {\n        require(msg.sender == governance, \"setGovernance: !gov\");\n        pendingGovernance = _governance;\n    }\n\n    /**\n     * @notice Allows pendingGovernance to accept their role as governance (protection pattern)\n     */\n    function acceptGovernance() external {\n        require(msg.sender == pendingGovernance, \"acceptGovernance: !pendingGov\");\n        governance = pendingGovernance;\n    }\n\n    IKeep3rV1 public constant KP3R = IKeep3rV1(0x1cEB5cB57C4D4E2b2433641b95Dd330A33185A44);\n    WETH9 public constant WETH = WETH9(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n    IUniswapV2Router public constant UNI = IUniswapV2Router(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\n\n    address public constant factory = 0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f;\n    // this is redundant with granularity and windowSize, but stored for gas savings & informational purposes.\n    uint public constant periodSize = 1800;\n\n    address[] internal _pairs;\n    mapping(address => bool) internal _known;\n\n    function pairs() external view returns (address[] memory) {\n        return _pairs;\n    }\n\n    mapping(address => Observation[]) public observations;\n\n    function observationLength(address pair) external view returns (uint) {\n        return observations[pair].length;\n    }\n\n    function pairFor(address tokenA, address tokenB) external pure returns (address) {\n        return UniswapV2Library.pairFor(factory, tokenA, tokenB);\n    }\n\n    function pairForWETH(address tokenA) external pure returns (address) {\n        return UniswapV2Library.pairFor(factory, tokenA, address(WETH));\n    }\n\n    constructor() public {\n        governance = msg.sender;\n    }\n\n    function updatePair(address pair) external keeper returns (bool) {\n        return _update(pair);\n    }\n\n    function update(address tokenA, address tokenB) external keeper returns (bool) {\n        address pair = UniswapV2Library.pairFor(factory, tokenA, tokenB);\n        return _update(pair);\n    }\n\n    function add(address tokenA, address tokenB) external {\n        require(msg.sender == governance, \"UniswapV2Oracle::add: !gov\");\n        address pair = UniswapV2Library.pairFor(factory, tokenA, tokenB);\n        require(!_known[pair], \"known\");\n        _known[pair] = true;\n        _pairs.push(pair);\n\n        (uint price0Cumulative, uint price1Cumulative,) = UniswapV2OracleLibrary.currentCumulativePrices(pair);\n        observations[pair].push(Observation(block.timestamp, price0Cumulative, price1Cumulative));\n    }\n\n    function work() public upkeep {\n        bool worked = _updateAll();\n        require(worked, \"UniswapV2Oracle: !work\");\n    }\n\n    function workForFree() public keeper {\n        bool worked = _updateAll();\n        require(worked, \"UniswapV2Oracle: !work\");\n    }\n\n    function lastObservation(address pair) public view returns (Observation memory) {\n        return observations[pair][observations[pair].length-1];\n    }\n\n    function _updateAll() internal returns (bool updated) {\n        // SWC-128-DoS With Block Gas Limit: L584 - L588\n        for (uint i = 0; i < _pairs.length; i++) {\n            if (_update(_pairs[i])) {\n                updated = true;\n            }\n        }\n    }\n\n    function updateFor(uint i, uint length) external keeper returns (bool updated) {\n        for (; i < length; i++) {\n            if (_update(_pairs[i])) {\n                updated = true;\n            }\n        }\n    }\n\n    function workable(address pair) public view returns (bool) {\n        return (block.timestamp - lastObservation(pair).timestamp) > periodSize;\n    }\n\n    function workable() external view returns (bool) {\n        // SWC-128-DoS With Block Gas Limit: L604 - L609\n        for (uint i = 0; i < _pairs.length; i++) {\n            if (workable(_pairs[i])) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function _update(address pair) internal returns (bool) {\n        // we only want to commit updates once per period (i.e. windowSize / granularity)\n        Observation memory _point = lastObservation(pair);\n        uint timeElapsed = block.timestamp - _point.timestamp;\n        if (timeElapsed > periodSize) {\n            (uint price0Cumulative, uint price1Cumulative,) = UniswapV2OracleLibrary.currentCumulativePrices(pair);\n            observations[pair].push(Observation(block.timestamp, price0Cumulative, price1Cumulative));\n            return true;\n        }\n        return false;\n    }\n\n    function computeAmountOut(\n        uint priceCumulativeStart, uint priceCumulativeEnd,\n        uint timeElapsed, uint amountIn\n    ) private pure returns (uint amountOut) {\n        // overflow is desired.\n        FixedPoint.uq112x112 memory priceAverage = FixedPoint.uq112x112(\n            // SWC-101-Integer Overflow and Underflow: L630\n            uint224((priceCumulativeEnd - priceCumulativeStart) / timeElapsed)\n        );\n        amountOut = priceAverage.mul(amountIn).decode144();\n    }\n\n    function _valid(address pair, uint age) internal view returns (bool) {\n        return (block.timestamp - lastObservation(pair).timestamp) <= age;\n    }\n\n    function current(address tokenIn, uint amountIn, address tokenOut) external view returns (uint amountOut) {\n        address pair = UniswapV2Library.pairFor(factory, tokenIn, tokenOut);\n        require(_valid(pair, periodSize.mul(2)), \"UniswapV2Oracle::quote: stale prices\");\n        (address token0,) = UniswapV2Library.sortTokens(tokenIn, tokenOut);\n\n        Observation memory _observation = lastObservation(pair);\n        (uint price0Cumulative, uint price1Cumulative,) = UniswapV2OracleLibrary.currentCumulativePrices(pair);\n        if (block.timestamp == _observation.timestamp) {\n            _observation = observations[pair][observations[pair].length-2];\n        }\n\n        // SWC-101-Integer Overflow and Underflow: L651\n        uint timeElapsed = block.timestamp - _observation.timestamp;\n        timeElapsed = timeElapsed == 0 ? 1 : timeElapsed;\n        if (token0 == tokenIn) {\n            return computeAmountOut(_observation.price0Cumulative, price0Cumulative, timeElapsed, amountIn);\n        } else {\n            return computeAmountOut(_observation.price1Cumulative, price1Cumulative, timeElapsed, amountIn);\n        }\n    }\n\n    function quote(address tokenIn, uint amountIn, address tokenOut, uint granularity) external view returns (uint amountOut) {\n        address pair = UniswapV2Library.pairFor(factory, tokenIn, tokenOut);\n        require(_valid(pair, periodSize.mul(granularity)), \"UniswapV2Oracle::quote: stale prices\");\n        (address token0,) = UniswapV2Library.sortTokens(tokenIn, tokenOut);\n\n        uint priceAverageCumulative = 0;\n        // SWC-124-Write to Arbitrary Storage Location: L669\n        uint length = observations[pair].length-1;\n        uint i = length.sub(granularity);\n\n\n        uint nextIndex = 0;\n        if (token0 == tokenIn) {\n            // SWC-128-DoS With Block Gas Limit: L674 - L683\n            for (; i < length; i++) {\n                // SWC-101-Integer Overflow and Underflow: L675\n                nextIndex = i+1;\n                priceAverageCumulative += computeAmountOut(\n                    observations[pair][i].price0Cumulative,\n                    observations[pair][nextIndex].price0Cumulative,\n                    // SWC-101-Integer Overflow and Underflow: L679\n                    observations[pair][nextIndex].timestamp - observations[pair][i].timestamp, amountIn);\n            }\n        } else {\n            for (; i < length; i++) {\n                // SWC-128-DoS With Block Gas Limit: L685 - L694\n                nextIndex = i+1;\n                // SWC-101-Integer Overflow and Underflow: L685\n                priceAverageCumulative += computeAmountOut(\n                    observations[pair][i].price1Cumulative,\n                    observations[pair][nextIndex].price1Cumulative,\n                    // SWC-101-Integer Overflow and Underflow: L689\n                    observations[pair][nextIndex].timestamp - observations[pair][i].timestamp, amountIn);\n            }\n        }\n        return priceAverageCumulative.div(granularity);\n    }\n\n    function prices(address tokenIn, uint amountIn, address tokenOut, uint points) external view returns (uint[] memory) {\n        return sample(tokenIn, amountIn, tokenOut, points, 1);\n    }\n\n    function sample(address tokenIn, uint amountIn, address tokenOut, uint points, uint window) public view returns (uint[] memory) {\n        address pair = UniswapV2Library.pairFor(factory, tokenIn, tokenOut);\n        (address token0,) = UniswapV2Library.sortTokens(tokenIn, tokenOut);\n        uint[] memory _prices = new uint[](points);\n\n        uint length = observations[pair].length-1;\n        uint i = length.sub(points * window);\n        uint nextIndex = 0;\n        uint index = 0;\n\n        if (token0 == tokenIn) {\n            for (; i < length; i+=window) {\n                // SWC-128-DoS With Block Gas Limit: L714 - L724\n                // SWC-101-Integer Overflow and Underflow: L712\n                nextIndex = i + window;\n                _prices[index] = computeAmountOut(\n                    // SWC-124-Write to Arbitrary Storage Location: L720, L721\n                    observations[pair][i].price0Cumulative,\n                    observations[pair][nextIndex].price0Cumulative,\n                    // SWC-101-Integer Overflow and Underflow: L717\n                    observations[pair][nextIndex].timestamp - observations[pair][i].timestamp, amountIn);\n                index = index + 1;\n            }\n        } else {\n            for (; i < length; i+=window) {\n                // SWC-128-DoS With Block Gas Limit: L726 - 736\n                // SWC-101-Integer Overflow and Underflow: L723\n                nextIndex = i + window;\n                _prices[index] = computeAmountOut(\n                    // SWC-124-Write to Arbitrary Storage Location: L733, L734\n                    observations[pair][i].price1Cumulative,\n                    observations[pair][nextIndex].price1Cumulative,\n                    // SWC-101-Integer Overflow and Underflow: L728\n                    observations[pair][nextIndex].timestamp - observations[pair][i].timestamp, amountIn);\n                index = index + 1;\n            }\n        }\n        return _prices;\n    }\n\n    function hourly(address tokenIn, uint amountIn, address tokenOut, uint points) external view returns (uint[] memory) {\n        return sample(tokenIn, amountIn, tokenOut, points, 2);\n    }\n\n    function daily(address tokenIn, uint amountIn, address tokenOut, uint points) external view returns (uint[] memory) {\n        return sample(tokenIn, amountIn, tokenOut, points, 48);\n    }\n\n    function weekly(address tokenIn, uint amountIn, address tokenOut, uint points) external view returns (uint[] memory) {\n        return sample(tokenIn, amountIn, tokenOut, points, 336);\n    }\n\n    function realizedVolatility(address tokenIn, uint amountIn, address tokenOut, uint points, uint window) external view returns (uint) {\n        return stddev(sample(tokenIn, amountIn, tokenOut, points, window));\n    }\n\n    function realizedVolatilityHourly(address tokenIn, uint amountIn, address tokenOut) external view returns (uint) {\n        return stddev(sample(tokenIn, amountIn, tokenOut, 1, 2));\n    }\n\n    function realizedVolatilityDaily(address tokenIn, uint amountIn, address tokenOut) external view returns (uint) {\n        return stddev(sample(tokenIn, amountIn, tokenOut, 1, 48));\n    }\n\n    function realizedVolatilityWeekly(address tokenIn, uint amountIn, address tokenOut) external view returns (uint) {\n        return stddev(sample(tokenIn, amountIn, tokenOut, 1, 336));\n    }\n\n    /**\n     * @dev sqrt calculates the square root of a given number x\n     * @dev for precision into decimals the number must first\n     * @dev be multiplied by the precision factor desired\n     * @param x uint256 number for the calculation of square root\n     */\n    function sqrt(uint256 x) public pure returns (uint256) {\n        // SWC-101-Integer Overflow and Underflow: L770 - L776\n        uint256 c = (x + 1) / 2;\n        uint256 b = x;\n        while (c < b) {\n            b = c;\n            c = (x / c + c) / 2;\n        }\n        return b;\n    }\n\n    /**\n     * @dev stddev calculates the standard deviation for an array of integers\n     * @dev precision is the same as sqrt above meaning for higher precision\n     * @dev the decimal place must be moved prior to passing the params\n     * @param numbers uint[] array of numbers to be used in calculation\n     */\n     // SWC-101-Integer Overflow and Underflow: L790 - L798\n    function stddev(uint[] memory numbers) public pure returns (uint256 sd) {\n        uint sum = 0;\n        for(uint i = 0; i < numbers.length; i++) {\n            sum += numbers[i];\n        }\n        uint256 mean = sum / numbers.length;        // Integral value; float not supported in Solidity\n        sum = 0;\n        uint i;\n        for(i = 0; i < numbers.length; i++) {\n            sum += (numbers[i] - mean) ** 2;\n        }\n        sd = sqrt(sum / (numbers.length - 1));      //Integral value; float not supported in Solidity\n        return sd;\n    }\n\n\n    /**\n     * @dev blackScholesEstimate calculates a rough price estimate for an ATM option\n     * @dev input parameters should be transformed prior to being passed to the function\n     * @dev so as to remove decimal places otherwise results will be far less accurate\n     * @param _vol uint256 volatility of the underlying converted to remove decimals\n     * @param _underlying uint256 price of the underlying asset\n     * @param _time uint256 days to expiration in years multiplied to remove decimals\n     */\n    function blackScholesEstimate(\n        uint256 _vol,\n        uint256 _underlying,\n        uint256 _time\n    ) public pure returns (uint256 estimate) {\n        estimate = 40 * _vol * _underlying * sqrt(_time);\n        return estimate;\n    }\n\n    /**\n     * @dev fromReturnsBSestimate first calculates the stddev of an array of price returns\n     * @dev then uses that as the volatility param for the blackScholesEstimate\n     * @param _numbers uint256[] array of price returns for volatility calculation\n     * @param _underlying uint256 price of the underlying asset\n     * @param _time uint256 days to expiration in years multiplied to remove decimals\n     */\n    function retBasedBlackScholesEstimate(\n        uint256[] memory _numbers,\n        uint256 _underlying,\n        uint256 _time\n    ) public pure {\n        uint _vol = stddev(_numbers);\n        blackScholesEstimate(_vol, _underlying, _time);\n    }\n\n    receive() external payable {}\n\n    function _swap(uint _amount) internal returns (uint) {\n        // SWC-104-Unchecked Call Return Value: L848\n        KP3R.approve(address(UNI), _amount);\n\n        address[] memory path = new address[](2);\n        path[0] = address(KP3R);\n        path[1] = address(WETH);\n\n        uint[] memory amounts = UNI.swapExactTokensForTokens(_amount, uint256(0), path, address(this), now.add(1800));\n        WETH.withdraw(amounts[1]);\n        return amounts[1];\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/QuillAudits-Yearn Finance-Yoracle.Link/yoracle.link-faf1309cbe7a05f70b338351315039eb8e5b9c09/contracts/Keep3rV1Oracle.sol",
        "vulnerability": "Ether lock",
        "check": "FP",
        "response": "Answer: No"
    }
]