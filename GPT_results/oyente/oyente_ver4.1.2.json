[
    {
        "code_segment": "library BasicMathLib {\n  \n  \n  \n  \n  \n  \n  function times(uint256 a, uint256 b) public pure returns (bool err,uint256 res) {\n    assembly{\n      res := mul(a,b)\n      switch or(iszero(b), eq(div(res,b), a))\n      case 0 {\n        err := 1\n        res := 0\n      }\n    }\n  }\n\n  \n  \n  \n  \n  \n  \n  function dividedBy(uint256 a, uint256 b) public pure returns (bool err,uint256 i) {\n    uint256 res;\n    assembly{\n      switch iszero(b)\n      case 0 {\n        res := div(a,b)\n        let loc := mload(0x40)\n        mstore(add(loc,0x20),res)\n        i := mload(add(loc,0x20))\n      }\n      default {\n        err := 1\n        i := 0\n      }\n    }\n  }\n\n  \n  \n  \n  \n  \n  \n  function plus(uint256 a, uint256 b) public pure returns (bool err, uint256 res) {\n    assembly{\n      res := add(a,b)\n      switch and(eq(sub(res,b), a), or(gt(res,b),eq(res,b)))\n      case 0 {\n        err := 1\n        res := 0\n      }\n    }\n  }\n\n  \n  \n  \n  \n  \n  \n  function minus(uint256 a, uint256 b) public pure returns (bool err,uint256 res) {\n    assembly{\n      res := sub(a,b)\n      switch eq(and(eq(add(res,b), a), or(lt(res,a), eq(res,a))), 1)\n      case 0 {\n        err := 1\n        res := 0\n      }\n    }\n  }\n}",
        "function": null,
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/consensys-Modular_Interactive_Crowdsale/ethereum-libraries-73abc22623e0841b8ea67a5089002f4867102672/BasicMathLib/BasicMathLib.sol",
        "vulnerability": "Integer Overflow",
        "check": "TP",
        "response": "Answer: No"
    },
    {
        "code_segment": "library BasicMathLib {\n  \n  \n  \n  \n  \n  \n  function times(uint256 a, uint256 b) public pure returns (bool err,uint256 res) {\n    assembly{\n      res := mul(a,b)\n      switch or(iszero(b), eq(div(res,b), a))\n      case 0 {\n        err := 1\n        res := 0\n      }\n    }\n  }\n\n  \n  \n  \n  \n  \n  \n  function dividedBy(uint256 a, uint256 b) public pure returns (bool err,uint256 i) {\n    uint256 res;\n    assembly{\n      switch iszero(b)\n      case 0 {\n        res := div(a,b)\n        let loc := mload(0x40)\n        mstore(add(loc,0x20),res)\n        i := mload(add(loc,0x20))\n      }\n      default {\n        err := 1\n        i := 0\n      }\n    }\n  }\n\n  \n  \n  \n  \n  \n  \n  function plus(uint256 a, uint256 b) public pure returns (bool err, uint256 res) {\n    assembly{\n      res := add(a,b)\n      switch and(eq(sub(res,b), a), or(gt(res,b),eq(res,b)))\n      case 0 {\n        err := 1\n        res := 0\n      }\n    }\n  }\n\n  \n  \n  \n  \n  \n  \n  function minus(uint256 a, uint256 b) public pure returns (bool err,uint256 res) {\n    assembly{\n      res := sub(a,b)\n      switch eq(and(eq(add(res,b), a), or(lt(res,a), eq(res,a))), 1)\n      case 0 {\n        err := 1\n        res := 0\n      }\n    }\n  }\n}",
        "function": null,
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/consensys-Modular_Interactive_Crowdsale/ethereum-libraries-73abc22623e0841b8ea67a5089002f4867102672/BasicMathLib/BasicMathLib.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "library Array256Lib {\n\n  \n  \n  \n  function sumElements(uint256[] storage self) public view returns(uint256 sum) {\n    assembly {\n      mstore(0x60,self_slot)\n\n      for { let i := 0 } lt(i, sload(self_slot)) { i := add(i, 1) } {\n        sum := add(sload(add(sha3(0x60,0x20),i)),sum)\n      }\n    }\n  }\n\n  \n  \n  \n  function getMax(uint256[] storage self) public view returns(uint256 maxValue) {\n    assembly {\n      mstore(0x60,self_slot)\n      maxValue := sload(sha3(0x60,0x20))\n\n      for { let i := 0 } lt(i, sload(self_slot)) { i := add(i, 1) } {\n        switch gt(sload(add(sha3(0x60,0x20),i)), maxValue)\n        case 1 {\n          maxValue := sload(add(sha3(0x60,0x20),i))\n        }\n      }\n    }\n  }\n\n  \n  \n  \n  function getMin(uint256[] storage self) public view returns(uint256 minValue) {\n    assembly {\n      mstore(0x60,self_slot)\n      minValue := sload(sha3(0x60,0x20))\n\n      for { let i := 0 } lt(i, sload(self_slot)) { i := add(i, 1) } {\n        switch gt(sload(add(sha3(0x60,0x20),i)), minValue)\n        case 0 {\n          minValue := sload(add(sha3(0x60,0x20),i))\n        }\n      }\n    }\n  }\n\n  \n  \n  \n  \n  \n  \n  function indexOf(uint256[] storage self, uint256 value, bool isSorted)\n           public\n           view\n           returns(bool found, uint256 index) {\n    assembly{\n      mstore(0x60,self_slot)\n      switch isSorted\n      case 1 {\n        let high := sub(sload(self_slot),1)\n        let mid := 0\n        let low := 0\n        for { } iszero(gt(low, high)) { } {\n          mid := div(add(low,high),2)\n\n          switch lt(sload(add(sha3(0x60,0x20),mid)),value)\n          case 1 {\n             low := add(mid,1)\n          }\n          case 0 {\n            switch gt(sload(add(sha3(0x60,0x20),mid)),value)\n            case 1 {\n              high := sub(mid,1)\n            }\n            case 0 {\n              found := 1\n              index := mid\n              low := add(high,1)\n            }\n          }\n        }\n      }\n      case 0 {\n        for { let low := 0 } lt(low, sload(self_slot)) { low := add(low, 1) } {\n          switch eq(sload(add(sha3(0x60,0x20),low)), value)\n          case 1 {\n            found := 1\n            index := low\n            low := sload(self_slot)\n          }\n        }\n      }\n    }\n  }\n\n  \n  \n  \n  function getParentI(uint256 index) private pure returns (uint256 pI) {\n    uint256 i = index - 1;\n    pI = i/2;\n  }\n\n  \n  \n  \n  function getLeftChildI(uint256 index) private pure returns (uint256 lcI) {\n    uint256 i = index * 2;\n    lcI = i + 1;\n  }\n\n  \n  \n  function heapSort(uint256[] storage self) public {\n    uint256 end = self.length - 1;\n    uint256 start = getParentI(end);\n    uint256 root = start;\n    uint256 lChild;\n    uint256 rChild;\n    uint256 swap;\n    uint256 temp;\n    while(start >= 0){\n      root = start;\n      lChild = getLeftChildI(start);\n      while(lChild <= end){\n        rChild = lChild + 1;\n        swap = root;\n        if(self[swap] < self[lChild])\n          swap = lChild;\n        if((rChild <= end) && (self[swap]<self[rChild]))\n          swap = rChild;\n        if(swap == root)\n          lChild = end+1;\n        else {\n          temp = self[swap];\n          self[swap] = self[root];\n          self[root] = temp;\n          root = swap;\n          lChild = getLeftChildI(root);\n        }\n      }\n      if(start == 0)\n        break;\n      else\n        start = start - 1;\n    }\n    while(end > 0){\n      temp = self[end];\n      self[end] = self[0];\n      self[0] = temp;\n      end = end - 1;\n      root = 0;\n      lChild = getLeftChildI(0);\n      while(lChild <= end){\n        rChild = lChild + 1;\n        swap = root;\n        if(self[swap] < self[lChild])\n          swap = lChild;\n        if((rChild <= end) && (self[swap]<self[rChild]))\n          swap = rChild;\n        if(swap == root)\n          lChild = end + 1;\n        else {\n          temp = self[swap];\n          self[swap] = self[root];\n          self[root] = temp;\n          root = swap;\n          lChild = getLeftChildI(root);\n        }\n      }\n    }\n  }\n\n  \n  \n  function uniq(uint256[] storage self) public returns (uint256 length) {\n    bool contains;\n    uint256 index;\n\n    for (uint256 i = 0; i < self.length; i++) {\n      (contains, index) = indexOf(self, self[i], false);\n\n      if (i > index) {\n        for (uint256 j = i; j < self.length - 1; j++){\n          self[j] = self[j + 1];\n        }\n\n        delete self[self.length - 1];\n        self.length--;\n        i--;\n      }\n    }\n\n    length = self.length;\n  }\n}",
        "function": null,
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/consensys-Modular_Interactive_Crowdsale/ethereum-libraries-73abc22623e0841b8ea67a5089002f4867102672/ArrayUtilsLib/Array256Lib.sol",
        "vulnerability": "Integer Underflow",
        "check": "TP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "library BasicMathLib {\n  \n  \n  \n  \n  \n  \n  function times(uint256 a, uint256 b) public pure returns (bool err,uint256 res) {\n    assembly{\n      res := mul(a,b)\n      switch or(iszero(b), eq(div(res,b), a))\n      case 0 {\n        err := 1\n        res := 0\n      }\n    }\n  }\n\n  \n  \n  \n  \n  \n  \n  function dividedBy(uint256 a, uint256 b) public pure returns (bool err,uint256 i) {\n    uint256 res;\n    assembly{\n      switch iszero(b)\n      case 0 {\n        res := div(a,b)\n        let loc := mload(0x40)\n        mstore(add(loc,0x20),res)\n        i := mload(add(loc,0x20))\n      }\n      default {\n        err := 1\n        i := 0\n      }\n    }\n  }\n\n  \n  \n  \n  \n  \n  \n  function plus(uint256 a, uint256 b) public pure returns (bool err, uint256 res) {\n    assembly{\n      res := add(a,b)\n      switch and(eq(sub(res,b), a), or(gt(res,b),eq(res,b)))\n      case 0 {\n        err := 1\n        res := 0\n      }\n    }\n  }\n\n  \n  \n  \n  \n  \n  \n  function minus(uint256 a, uint256 b) public pure returns (bool err,uint256 res) {\n    assembly{\n      res := sub(a,b)\n      switch eq(and(eq(add(res,b), a), or(lt(res,a), eq(res,a))), 1)\n      case 0 {\n        err := 1\n        res := 0\n      }\n    }\n  }\n}",
        "function": null,
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/consensys-Modular_Interactive_Crowdsale/ethereum-libraries-73abc22623e0841b8ea67a5089002f4867102672/CrowdsaleLib/IICOLib/truffle/contracts/InteractiveCrowdsaleLib.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "library BasicMathLib {\n  \n  \n  \n  \n  \n  \n  function times(uint256 a, uint256 b) public pure returns (bool err,uint256 res) {\n    assembly{\n      res := mul(a,b)\n      switch or(iszero(b), eq(div(res,b), a))\n      case 0 {\n        err := 1\n        res := 0\n      }\n    }\n  }\n\n  \n  \n  \n  \n  \n  \n  function dividedBy(uint256 a, uint256 b) public pure returns (bool err,uint256 i) {\n    uint256 res;\n    assembly{\n      switch iszero(b)\n      case 0 {\n        res := div(a,b)\n        let loc := mload(0x40)\n        mstore(add(loc,0x20),res)\n        i := mload(add(loc,0x20))\n      }\n      default {\n        err := 1\n        i := 0\n      }\n    }\n  }\n\n  \n  \n  \n  \n  \n  \n  function plus(uint256 a, uint256 b) public pure returns (bool err, uint256 res) {\n    assembly{\n      res := add(a,b)\n      switch and(eq(sub(res,b), a), or(gt(res,b),eq(res,b)))\n      case 0 {\n        err := 1\n        res := 0\n      }\n    }\n  }\n\n  \n  \n  \n  \n  \n  \n  function minus(uint256 a, uint256 b) public pure returns (bool err,uint256 res) {\n    assembly{\n      res := sub(a,b)\n      switch eq(and(eq(add(res,b), a), or(lt(res,a), eq(res,a))), 1)\n      case 0 {\n        err := 1\n        res := 0\n      }\n    }\n  }\n}",
        "function": null,
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/consensys-Modular_Interactive_Crowdsale/ethereum-libraries-73abc22623e0841b8ea67a5089002f4867102672/CrowdsaleLib/IICOLib/truffle/contracts/InteractiveCrowdsaleLib.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "library CrowdsaleLib {\n  using BasicMathLib for uint256;\n\n  struct CrowdsaleStorage {\n  \taddress owner;     //owner of the crowdsale\n\n  \tuint256 tokensPerEth;  //number of tokens received per ether\n  \tuint256 startTime; //ICO start time, timestamp\n  \tuint256 endTime; //ICO end time, timestamp automatically calculated\n    uint256 ownerBalance; //owner wei Balance\n    uint256 startingTokenBalance; //initial amount of tokens for sale\n    uint256[] milestoneTimes; //Array of timestamps when token price and address cap changes\n    uint8 currentMilestone; //Pointer to the current milestone\n    uint8 percentBurn; //percentage of extra tokens to burn\n    bool tokensSet; //true if tokens have been prepared for crowdsale\n\n    //Maps timestamp to token price and address purchase cap starting at that time\n    mapping (uint256 => uint256[2]) saleData;\n\n    //shows how much wei an address has contributed\n  \tmapping (address => uint256) hasContributed;\n\n    //For token withdraw function, maps a user address to the amount of tokens they can withdraw\n  \tmapping (address => uint256) withdrawTokensMap;\n\n    // any leftover wei that buyers contributed that didn't add up to a whole token amount\n    mapping (address => uint256) leftoverWei;\n\n  \tCrowdsaleToken token; //token being sold\n  }\n\n  // Indicates when an address has withdrawn their supply of tokens\n  event LogTokensWithdrawn(address indexed _bidder, uint256 Amount);\n\n  // Indicates when an address has withdrawn their supply of extra wei\n  event LogWeiWithdrawn(address indexed _bidder, uint256 Amount);\n\n  // Logs when owner has pulled eth\n  event LogOwnerEthWithdrawn(address indexed owner, uint256 amount, string Msg);\n\n  // Generic Notice message that includes and address and number\n  event LogNoticeMsg(address _buyer, uint256 value, string Msg);\n\n  // Indicates when an error has occurred in the execution of a function\n  event LogErrorMsg(uint256 amount, string Msg);\n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  function init(CrowdsaleStorage storage self,\n                address _owner,\n                uint256[] _saleData,\n                uint256 _endTime,\n                uint8 _percentBurn,\n                CrowdsaleToken _token)\n                public\n  {\n  \trequire(self.owner == 0);\n    require(_saleData.length > 0);\n    require((_saleData.length%3) == 0); // ensure saleData is 3-item sets\n    require(_saleData[0] > (now + 2 hours));\n    require(_endTime > _saleData[0]);\n    require(_owner > 0);\n    require(_percentBurn <= 100);\n    self.owner = _owner;\n    self.startTime = _saleData[0];\n    self.endTime = _endTime;\n    self.token = _token;\n    self.percentBurn = _percentBurn;\n\n    uint256 _tempTime;\n    for(uint256 i = 0; i < _saleData.length; i += 3){\n      require(_saleData[i] > _tempTime);\n      require(_saleData[i + 1] > 0);\n      require((_saleData[i + 2] == 0) || (_saleData[i + 2] >= 100));\n      self.milestoneTimes.push(_saleData[i]);\n      self.saleData[_saleData[i]][0] = _saleData[i + 1];\n      self.saleData[_saleData[i]][1] = _saleData[i + 2];\n      _tempTime = _saleData[i];\n    }\n    changeTokenPrice(self, _saleData[1]);\n  }\n\n  \n  \n  \n  function crowdsaleActive(CrowdsaleStorage storage self) public view returns (bool) {\n  \treturn (now >= self.startTime && now <= self.endTime);\n  }\n\n  \n  \n  \n  function crowdsaleEnded(CrowdsaleStorage storage self) public view returns (bool) {\n  \treturn now > self.endTime;\n  }\n\n  \n  \n  \n  function validPurchase(CrowdsaleStorage storage self) internal returns (bool) {\n    bool nonZeroPurchase = msg.value != 0;\n    if (crowdsaleActive(self) && nonZeroPurchase) {\n      return true;\n    } else {\n      LogErrorMsg(msg.value, \"Invalid Purchase! Check start time and amount of ether.\");\n      return false;\n    }\n  }\n\n  \n  \n  \n  function withdrawTokens(CrowdsaleStorage storage self) public returns (bool) {\n    bool ok;\n\n    if (self.withdrawTokensMap[msg.sender] == 0) {\n      LogErrorMsg(0, \"Sender has no tokens to withdraw!\");\n      return false;\n    }\n\n    if (msg.sender == self.owner) {\n      if(!crowdsaleEnded(self)){\n        LogErrorMsg(0, \"Owner cannot withdraw extra tokens until after the sale!\");\n        return false;\n      } else {\n        if(self.percentBurn > 0){\n          uint256 _burnAmount = (self.withdrawTokensMap[msg.sender] * self.percentBurn)/100;\n          self.withdrawTokensMap[msg.sender] = self.withdrawTokensMap[msg.sender] - _burnAmount;\n          ok = self.token.burnToken(_burnAmount);\n          require(ok);\n        }\n      }\n    }\n\n    var total = self.withdrawTokensMap[msg.sender];\n    self.withdrawTokensMap[msg.sender] = 0;\n    ok = self.token.transfer(msg.sender, total);\n    require(ok);\n    LogTokensWithdrawn(msg.sender, total);\n    return true;\n  }\n\n  \n  \n  \n  function withdrawLeftoverWei(CrowdsaleStorage storage self) public returns (bool) {\n    if (self.leftoverWei[msg.sender] == 0) {\n      LogErrorMsg(0, \"Sender has no extra wei to withdraw!\");\n      return false;\n    }\n\n    var total = self.leftoverWei[msg.sender];\n    self.leftoverWei[msg.sender] = 0;\n    msg.sender.transfer(total);\n    LogWeiWithdrawn(msg.sender, total);\n    return true;\n  }\n\n  \n  \n  \n  function withdrawOwnerEth(CrowdsaleStorage storage self) public returns (bool) {\n    if ((!crowdsaleEnded(self)) && (self.token.balanceOf(this)>0)) {\n      LogErrorMsg(0, \"Cannot withdraw owner ether until after the sale!\");\n      return false;\n    }\n\n    require(msg.sender == self.owner);\n    require(self.ownerBalance > 0);\n\n    uint256 amount = self.ownerBalance;\n    self.ownerBalance = 0;\n    self.owner.transfer(amount);\n    LogOwnerEthWithdrawn(msg.sender,amount,\"Crowdsale owner has withdrawn all funds!\");\n\n    return true;\n  }\n\n  \n  \n  \n  \n  function changeTokenPrice(CrowdsaleStorage storage self,\n                            uint256 _tokensPerEth)\n                            internal\n                            returns (bool)\n  {\n  \trequire(_tokensPerEth > 0);\n\n    self.tokensPerEth = _tokensPerEth;\n\n    return true;\n  }\n\n  \n  \n  \n  function setTokens(CrowdsaleStorage storage self) public returns (bool) {\n    require(msg.sender == self.owner);\n    require(!self.tokensSet);\n    require(now < self.endTime);\n\n    uint256 _tokenBalance;\n\n    _tokenBalance = self.token.balanceOf(this);\n    self.withdrawTokensMap[msg.sender] = _tokenBalance;\n    self.startingTokenBalance = _tokenBalance;\n    self.tokensSet = true;\n\n    return true;\n  }\n\n  \n  \n  \n  \n  function getSaleData(CrowdsaleStorage storage self, uint256 timestamp)\n                       public\n                       view\n                       returns (uint256[3])\n  {\n    uint256[3] memory _thisData;\n    uint256 index;\n\n    while((index < self.milestoneTimes.length) && (self.milestoneTimes[index] < timestamp)) {\n      index++;\n    }\n    if(index == 0)\n      index++;\n\n    _thisData[0] = self.milestoneTimes[index - 1];\n    _thisData[1] = self.saleData[_thisData[0]][0];\n    _thisData[2] = self.saleData[_thisData[0]][1];\n    return _thisData;\n  }\n\n  \n  \n  \n  function getTokensSold(CrowdsaleStorage storage self) public view returns (uint256) {\n    return self.startingTokenBalance - self.withdrawTokensMap[self.owner];\n  }\n}",
        "function": null,
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/consensys-Modular_Interactive_Crowdsale/ethereum-libraries-73abc22623e0841b8ea67a5089002f4867102672/CrowdsaleLib/IICOLib/truffle/contracts/InteractiveCrowdsaleLib.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "library CrowdsaleLib {\n  using BasicMathLib for uint256;\n\n  struct CrowdsaleStorage {\n  \taddress owner;     //owner of the crowdsale\n\n  \tuint256 tokensPerEth;  //number of tokens received per ether\n  \tuint256 startTime; //ICO start time, timestamp\n  \tuint256 endTime; //ICO end time, timestamp automatically calculated\n    uint256 ownerBalance; //owner wei Balance\n    uint256 startingTokenBalance; //initial amount of tokens for sale\n    uint256[] milestoneTimes; //Array of timestamps when token price and address cap changes\n    uint8 currentMilestone; //Pointer to the current milestone\n    uint8 percentBurn; //percentage of extra tokens to burn\n    bool tokensSet; //true if tokens have been prepared for crowdsale\n\n    //Maps timestamp to token price and address purchase cap starting at that time\n    mapping (uint256 => uint256[2]) saleData;\n\n    //shows how much wei an address has contributed\n  \tmapping (address => uint256) hasContributed;\n\n    //For token withdraw function, maps a user address to the amount of tokens they can withdraw\n  \tmapping (address => uint256) withdrawTokensMap;\n\n    // any leftover wei that buyers contributed that didn't add up to a whole token amount\n    mapping (address => uint256) leftoverWei;\n\n  \tCrowdsaleToken token; //token being sold\n  }\n\n  // Indicates when an address has withdrawn their supply of tokens\n  event LogTokensWithdrawn(address indexed _bidder, uint256 Amount);\n\n  // Indicates when an address has withdrawn their supply of extra wei\n  event LogWeiWithdrawn(address indexed _bidder, uint256 Amount);\n\n  // Logs when owner has pulled eth\n  event LogOwnerEthWithdrawn(address indexed owner, uint256 amount, string Msg);\n\n  // Generic Notice message that includes and address and number\n  event LogNoticeMsg(address _buyer, uint256 value, string Msg);\n\n  // Indicates when an error has occurred in the execution of a function\n  event LogErrorMsg(uint256 amount, string Msg);\n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  function init(CrowdsaleStorage storage self,\n                address _owner,\n                uint256[] _saleData,\n                uint256 _endTime,\n                uint8 _percentBurn,\n                CrowdsaleToken _token)\n                public\n  {\n  \trequire(self.owner == 0);\n    require(_saleData.length > 0);\n    require((_saleData.length%3) == 0); // ensure saleData is 3-item sets\n    require(_saleData[0] > (now + 2 hours));\n    require(_endTime > _saleData[0]);\n    require(_owner > 0);\n    require(_percentBurn <= 100);\n    self.owner = _owner;\n    self.startTime = _saleData[0];\n    self.endTime = _endTime;\n    self.token = _token;\n    self.percentBurn = _percentBurn;\n\n    uint256 _tempTime;\n    for(uint256 i = 0; i < _saleData.length; i += 3){\n      require(_saleData[i] > _tempTime);\n      require(_saleData[i + 1] > 0);\n      require((_saleData[i + 2] == 0) || (_saleData[i + 2] >= 100));\n      self.milestoneTimes.push(_saleData[i]);\n      self.saleData[_saleData[i]][0] = _saleData[i + 1];\n      self.saleData[_saleData[i]][1] = _saleData[i + 2];\n      _tempTime = _saleData[i];\n    }\n    changeTokenPrice(self, _saleData[1]);\n  }\n\n  \n  \n  \n  function crowdsaleActive(CrowdsaleStorage storage self) public view returns (bool) {\n  \treturn (now >= self.startTime && now <= self.endTime);\n  }\n\n  \n  \n  \n  function crowdsaleEnded(CrowdsaleStorage storage self) public view returns (bool) {\n  \treturn now > self.endTime;\n  }\n\n  \n  \n  \n  function validPurchase(CrowdsaleStorage storage self) internal returns (bool) {\n    bool nonZeroPurchase = msg.value != 0;\n    if (crowdsaleActive(self) && nonZeroPurchase) {\n      return true;\n    } else {\n      LogErrorMsg(msg.value, \"Invalid Purchase! Check start time and amount of ether.\");\n      return false;\n    }\n  }\n\n  \n  \n  \n  function withdrawTokens(CrowdsaleStorage storage self) public returns (bool) {\n    bool ok;\n\n    if (self.withdrawTokensMap[msg.sender] == 0) {\n      LogErrorMsg(0, \"Sender has no tokens to withdraw!\");\n      return false;\n    }\n\n    if (msg.sender == self.owner) {\n      if(!crowdsaleEnded(self)){\n        LogErrorMsg(0, \"Owner cannot withdraw extra tokens until after the sale!\");\n        return false;\n      } else {\n        if(self.percentBurn > 0){\n          uint256 _burnAmount = (self.withdrawTokensMap[msg.sender] * self.percentBurn)/100;\n          self.withdrawTokensMap[msg.sender] = self.withdrawTokensMap[msg.sender] - _burnAmount;\n          ok = self.token.burnToken(_burnAmount);\n          require(ok);\n        }\n      }\n    }\n\n    var total = self.withdrawTokensMap[msg.sender];\n    self.withdrawTokensMap[msg.sender] = 0;\n    ok = self.token.transfer(msg.sender, total);\n    require(ok);\n    LogTokensWithdrawn(msg.sender, total);\n    return true;\n  }\n\n  \n  \n  \n  function withdrawLeftoverWei(CrowdsaleStorage storage self) public returns (bool) {\n    if (self.leftoverWei[msg.sender] == 0) {\n      LogErrorMsg(0, \"Sender has no extra wei to withdraw!\");\n      return false;\n    }\n\n    var total = self.leftoverWei[msg.sender];\n    self.leftoverWei[msg.sender] = 0;\n    msg.sender.transfer(total);\n    LogWeiWithdrawn(msg.sender, total);\n    return true;\n  }\n\n  \n  \n  \n  function withdrawOwnerEth(CrowdsaleStorage storage self) public returns (bool) {\n    if ((!crowdsaleEnded(self)) && (self.token.balanceOf(this)>0)) {\n      LogErrorMsg(0, \"Cannot withdraw owner ether until after the sale!\");\n      return false;\n    }\n\n    require(msg.sender == self.owner);\n    require(self.ownerBalance > 0);\n\n    uint256 amount = self.ownerBalance;\n    self.ownerBalance = 0;\n    self.owner.transfer(amount);\n    LogOwnerEthWithdrawn(msg.sender,amount,\"Crowdsale owner has withdrawn all funds!\");\n\n    return true;\n  }\n\n  \n  \n  \n  \n  function changeTokenPrice(CrowdsaleStorage storage self,\n                            uint256 _tokensPerEth)\n                            internal\n                            returns (bool)\n  {\n  \trequire(_tokensPerEth > 0);\n\n    self.tokensPerEth = _tokensPerEth;\n\n    return true;\n  }\n\n  \n  \n  \n  function setTokens(CrowdsaleStorage storage self) public returns (bool) {\n    require(msg.sender == self.owner);\n    require(!self.tokensSet);\n    require(now < self.endTime);\n\n    uint256 _tokenBalance;\n\n    _tokenBalance = self.token.balanceOf(this);\n    self.withdrawTokensMap[msg.sender] = _tokenBalance;\n    self.startingTokenBalance = _tokenBalance;\n    self.tokensSet = true;\n\n    return true;\n  }\n\n  \n  \n  \n  \n  function getSaleData(CrowdsaleStorage storage self, uint256 timestamp)\n                       public\n                       view\n                       returns (uint256[3])\n  {\n    uint256[3] memory _thisData;\n    uint256 index;\n\n    while((index < self.milestoneTimes.length) && (self.milestoneTimes[index] < timestamp)) {\n      index++;\n    }\n    if(index == 0)\n      index++;\n\n    _thisData[0] = self.milestoneTimes[index - 1];\n    _thisData[1] = self.saleData[_thisData[0]][0];\n    _thisData[2] = self.saleData[_thisData[0]][1];\n    return _thisData;\n  }\n\n  \n  \n  \n  function getTokensSold(CrowdsaleStorage storage self) public view returns (uint256) {\n    return self.startingTokenBalance - self.withdrawTokensMap[self.owner];\n  }\n}",
        "function": null,
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/consensys-Modular_Interactive_Crowdsale/ethereum-libraries-73abc22623e0841b8ea67a5089002f4867102672/CrowdsaleLib/IICOLib/truffle/contracts/InteractiveCrowdsaleLib.sol",
        "vulnerability": "Timestamp Dependency",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "library CrowdsaleLib {\n  using BasicMathLib for uint256;\n\n  struct CrowdsaleStorage {\n  \taddress owner;     //owner of the crowdsale\n\n  \tuint256 tokensPerEth;  //number of tokens received per ether\n  \tuint256 startTime; //ICO start time, timestamp\n  \tuint256 endTime; //ICO end time, timestamp automatically calculated\n    uint256 ownerBalance; //owner wei Balance\n    uint256 startingTokenBalance; //initial amount of tokens for sale\n    uint256[] milestoneTimes; //Array of timestamps when token price and address cap changes\n    uint8 currentMilestone; //Pointer to the current milestone\n    uint8 percentBurn; //percentage of extra tokens to burn\n    bool tokensSet; //true if tokens have been prepared for crowdsale\n\n    //Maps timestamp to token price and address purchase cap starting at that time\n    mapping (uint256 => uint256[2]) saleData;\n\n    //shows how much wei an address has contributed\n  \tmapping (address => uint256) hasContributed;\n\n    //For token withdraw function, maps a user address to the amount of tokens they can withdraw\n  \tmapping (address => uint256) withdrawTokensMap;\n\n    // any leftover wei that buyers contributed that didn't add up to a whole token amount\n    mapping (address => uint256) leftoverWei;\n\n  \tCrowdsaleToken token; //token being sold\n  }\n\n  // Indicates when an address has withdrawn their supply of tokens\n  event LogTokensWithdrawn(address indexed _bidder, uint256 Amount);\n\n  // Indicates when an address has withdrawn their supply of extra wei\n  event LogWeiWithdrawn(address indexed _bidder, uint256 Amount);\n\n  // Logs when owner has pulled eth\n  event LogOwnerEthWithdrawn(address indexed owner, uint256 amount, string Msg);\n\n  // Generic Notice message that includes and address and number\n  event LogNoticeMsg(address _buyer, uint256 value, string Msg);\n\n  // Indicates when an error has occurred in the execution of a function\n  event LogErrorMsg(uint256 amount, string Msg);\n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  function init(CrowdsaleStorage storage self,\n                address _owner,\n                uint256[] _saleData,\n                uint256 _endTime,\n                uint8 _percentBurn,\n                CrowdsaleToken _token)\n                public\n  {\n  \trequire(self.owner == 0);\n    require(_saleData.length > 0);\n    require((_saleData.length%3) == 0); // ensure saleData is 3-item sets\n    require(_saleData[0] > (now + 2 hours));\n    require(_endTime > _saleData[0]);\n    require(_owner > 0);\n    require(_percentBurn <= 100);\n    self.owner = _owner;\n    self.startTime = _saleData[0];\n    self.endTime = _endTime;\n    self.token = _token;\n    self.percentBurn = _percentBurn;\n\n    uint256 _tempTime;\n    for(uint256 i = 0; i < _saleData.length; i += 3){\n      require(_saleData[i] > _tempTime);\n      require(_saleData[i + 1] > 0);\n      require((_saleData[i + 2] == 0) || (_saleData[i + 2] >= 100));\n      self.milestoneTimes.push(_saleData[i]);\n      self.saleData[_saleData[i]][0] = _saleData[i + 1];\n      self.saleData[_saleData[i]][1] = _saleData[i + 2];\n      _tempTime = _saleData[i];\n    }\n    changeTokenPrice(self, _saleData[1]);\n  }\n\n  \n  \n  \n  function crowdsaleActive(CrowdsaleStorage storage self) public view returns (bool) {\n  \treturn (now >= self.startTime && now <= self.endTime);\n  }\n\n  \n  \n  \n  function crowdsaleEnded(CrowdsaleStorage storage self) public view returns (bool) {\n  \treturn now > self.endTime;\n  }\n\n  \n  \n  \n  function validPurchase(CrowdsaleStorage storage self) internal returns (bool) {\n    bool nonZeroPurchase = msg.value != 0;\n    if (crowdsaleActive(self) && nonZeroPurchase) {\n      return true;\n    } else {\n      LogErrorMsg(msg.value, \"Invalid Purchase! Check start time and amount of ether.\");\n      return false;\n    }\n  }\n\n  \n  \n  \n  function withdrawTokens(CrowdsaleStorage storage self) public returns (bool) {\n    bool ok;\n\n    if (self.withdrawTokensMap[msg.sender] == 0) {\n      LogErrorMsg(0, \"Sender has no tokens to withdraw!\");\n      return false;\n    }\n\n    if (msg.sender == self.owner) {\n      if(!crowdsaleEnded(self)){\n        LogErrorMsg(0, \"Owner cannot withdraw extra tokens until after the sale!\");\n        return false;\n      } else {\n        if(self.percentBurn > 0){\n          uint256 _burnAmount = (self.withdrawTokensMap[msg.sender] * self.percentBurn)/100;\n          self.withdrawTokensMap[msg.sender] = self.withdrawTokensMap[msg.sender] - _burnAmount;\n          ok = self.token.burnToken(_burnAmount);\n          require(ok);\n        }\n      }\n    }\n\n    var total = self.withdrawTokensMap[msg.sender];\n    self.withdrawTokensMap[msg.sender] = 0;\n    ok = self.token.transfer(msg.sender, total);\n    require(ok);\n    LogTokensWithdrawn(msg.sender, total);\n    return true;\n  }\n\n  \n  \n  \n  function withdrawLeftoverWei(CrowdsaleStorage storage self) public returns (bool) {\n    if (self.leftoverWei[msg.sender] == 0) {\n      LogErrorMsg(0, \"Sender has no extra wei to withdraw!\");\n      return false;\n    }\n\n    var total = self.leftoverWei[msg.sender];\n    self.leftoverWei[msg.sender] = 0;\n    msg.sender.transfer(total);\n    LogWeiWithdrawn(msg.sender, total);\n    return true;\n  }\n\n  \n  \n  \n  function withdrawOwnerEth(CrowdsaleStorage storage self) public returns (bool) {\n    if ((!crowdsaleEnded(self)) && (self.token.balanceOf(this)>0)) {\n      LogErrorMsg(0, \"Cannot withdraw owner ether until after the sale!\");\n      return false;\n    }\n\n    require(msg.sender == self.owner);\n    require(self.ownerBalance > 0);\n\n    uint256 amount = self.ownerBalance;\n    self.ownerBalance = 0;\n    self.owner.transfer(amount);\n    LogOwnerEthWithdrawn(msg.sender,amount,\"Crowdsale owner has withdrawn all funds!\");\n\n    return true;\n  }\n\n  \n  \n  \n  \n  function changeTokenPrice(CrowdsaleStorage storage self,\n                            uint256 _tokensPerEth)\n                            internal\n                            returns (bool)\n  {\n  \trequire(_tokensPerEth > 0);\n\n    self.tokensPerEth = _tokensPerEth;\n\n    return true;\n  }\n\n  \n  \n  \n  function setTokens(CrowdsaleStorage storage self) public returns (bool) {\n    require(msg.sender == self.owner);\n    require(!self.tokensSet);\n    require(now < self.endTime);\n\n    uint256 _tokenBalance;\n\n    _tokenBalance = self.token.balanceOf(this);\n    self.withdrawTokensMap[msg.sender] = _tokenBalance;\n    self.startingTokenBalance = _tokenBalance;\n    self.tokensSet = true;\n\n    return true;\n  }\n\n  \n  \n  \n  \n  function getSaleData(CrowdsaleStorage storage self, uint256 timestamp)\n                       public\n                       view\n                       returns (uint256[3])\n  {\n    uint256[3] memory _thisData;\n    uint256 index;\n\n    while((index < self.milestoneTimes.length) && (self.milestoneTimes[index] < timestamp)) {\n      index++;\n    }\n    if(index == 0)\n      index++;\n\n    _thisData[0] = self.milestoneTimes[index - 1];\n    _thisData[1] = self.saleData[_thisData[0]][0];\n    _thisData[2] = self.saleData[_thisData[0]][1];\n    return _thisData;\n  }\n\n  \n  \n  \n  function getTokensSold(CrowdsaleStorage storage self) public view returns (uint256) {\n    return self.startingTokenBalance - self.withdrawTokensMap[self.owner];\n  }\n}",
        "function": null,
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/consensys-Modular_Interactive_Crowdsale/ethereum-libraries-73abc22623e0841b8ea67a5089002f4867102672/CrowdsaleLib/IICOLib/truffle/contracts/InteractiveCrowdsaleLib.sol",
        "vulnerability": "Transaction-Ordering Dependence (TOD)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract CrowdsaleToken {\n  using TokenLib for TokenLib.TokenStorage;\n\n  TokenLib.TokenStorage public token;\n\n  function CrowdsaleToken(address owner,\n                          string name,\n                          string symbol,\n                          uint8 decimals,\n                          uint256 initialSupply,\n                          bool allowMinting) public\n  {\n    token.init(owner, name, symbol, decimals, initialSupply, allowMinting);\n  }\n\n  function name() public view returns (string) {\n    return token.name;\n  }\n\n  function symbol() public view returns (string) {\n    return token.symbol;\n  }\n\n  function decimals() public view returns (uint8) {\n    return token.decimals;\n  }\n\n  function totalSupply() public view returns (uint256) {\n    return token.totalSupply;\n  }\n\n  function initialSupply() public view returns (uint256) {\n    return token.initialSupply;\n  }\n\n  function balanceOf(address who) public view returns (uint256) {\n    return token.balanceOf(who);\n  }\n\n  function allowance(address owner, address spender) public view returns (uint256) {\n    return token.allowance(owner, spender);\n  }\n\n  function transfer(address to, uint value) public returns (bool ok) {\n    return token.transfer(to, value);\n  }\n\n  function transferFrom(address from, address to, uint value) public returns (bool ok) {\n    return token.transferFrom(from, to, value);\n  }\n\n  function approve(address spender, uint value) public returns (bool ok) {\n    return token.approve(spender, value);\n  }\n\n  function approveChange(address spender, uint256 valueChange, bool increase)\n                         public returns (bool ok)\n  {\n    return token.approveChange(spender, valueChange, increase);\n  }\n\n  function changeOwner(address newOwner) public returns (bool ok) {\n    return token.changeOwner(newOwner);\n  }\n\n  function mintToken(uint256 amount) public returns (bool ok) {\n    return token.mintToken(amount);\n  }\n\n  function closeMint() public returns (bool ok) {\n    return token.closeMint();\n  }\n\n  function burnToken(uint256 amount) public returns (bool ok) {\n    return token.burnToken(amount);\n  }\n}",
        "function": null,
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/consensys-Modular_Interactive_Crowdsale/ethereum-libraries-73abc22623e0841b8ea67a5089002f4867102672/CrowdsaleLib/IICOLib/truffle/contracts/InteractiveCrowdsaleLib.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "library TokenLib {\n  using BasicMathLib for uint256;\n\n  struct TokenStorage {\n    bool initialized;\n    mapping (address => uint256) balances;\n    mapping (address => mapping (address => uint256)) allowed;\n\n    string name;\n    string symbol;\n    uint256 totalSupply;\n    uint256 initialSupply;\n    address owner;\n    uint8 decimals;\n    bool stillMinting;\n  }\n\n  event Transfer(address indexed from, address indexed to, uint256 value);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n  event OwnerChange(address from, address to);\n  event Burn(address indexed burner, uint256 value);\n  event MintingClosed(bool mintingClosed);\n\n  \n  \n  \n  \n  \n  \n  \n  function init(TokenStorage storage self,\n                address _owner,\n                string _name,\n                string _symbol,\n                uint8 _decimals,\n                uint256 _initial_supply,\n                bool _allowMinting)\n                public\n  {\n    require(!self.initialized);\n    self.initialized = true;\n    self.name = _name;\n    self.symbol = _symbol;\n    self.totalSupply = _initial_supply;\n    self.initialSupply = _initial_supply;\n    self.decimals = _decimals;\n    self.owner = _owner;\n    self.stillMinting = _allowMinting;\n    self.balances[_owner] = _initial_supply;\n  }\n\n  \n  \n  \n  \n  \n  function transfer(TokenStorage storage self, address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    bool err;\n    uint256 balance;\n\n    (err,balance) = self.balances[msg.sender].minus(_value);\n    require(!err);\n    self.balances[msg.sender] = balance;\n    //It's not possible to overflow token supply\n    self.balances[_to] = self.balances[_to] + _value;\n    Transfer(msg.sender, _to, _value);\n    return true;\n  }\n\n  \n  \n  \n  \n  \n  \n  function transferFrom(TokenStorage storage self,\n                        address _from,\n                        address _to,\n                        uint256 _value)\n                        public\n                        returns (bool)\n  {\n    var _allowance = self.allowed[_from][msg.sender];\n    bool err;\n    uint256 balanceOwner;\n    uint256 balanceSpender;\n\n    (err,balanceOwner) = self.balances[_from].minus(_value);\n    require(!err);\n\n    (err,balanceSpender) = _allowance.minus(_value);\n    require(!err);\n\n    self.balances[_from] = balanceOwner;\n    self.allowed[_from][msg.sender] = balanceSpender;\n    self.balances[_to] = self.balances[_to] + _value;\n\n    Transfer(_from, _to, _value);\n    return true;\n  }\n\n  \n  \n  \n  \n  function balanceOf(TokenStorage storage self, address _owner) public view returns (uint256 balance) {\n    return self.balances[_owner];\n  }\n\n  \n  \n  \n  \n  \n  function approve(TokenStorage storage self, address _spender, uint256 _value) public returns (bool) {\n    // must set to zero before changing approval amount in accordance with spec\n    require((_value == 0) || (self.allowed[msg.sender][_spender] == 0));\n\n    self.allowed[msg.sender][_spender] = _value;\n    Approval(msg.sender, _spender, _value);\n    return true;\n  }\n\n  \n  \n  \n  \n  \n  function allowance(TokenStorage storage self, address _owner, address _spender)\n                     public\n                     view\n                     returns (uint256 remaining) {\n    return self.allowed[_owner][_spender];\n  }\n\n  \n  \n  \n  \n  \n  \n  function approveChange (TokenStorage storage self, address _spender, uint256 _valueChange, bool _increase)\n                          public returns (bool)\n  {\n    uint256 _newAllowed;\n    bool err;\n\n    if(_increase) {\n      (err, _newAllowed) = self.allowed[msg.sender][_spender].plus(_valueChange);\n      require(!err);\n\n      self.allowed[msg.sender][_spender] = _newAllowed;\n    } else {\n      if (_valueChange > self.allowed[msg.sender][_spender]) {\n        self.allowed[msg.sender][_spender] = 0;\n      } else {\n        _newAllowed = self.allowed[msg.sender][_spender] - _valueChange;\n        self.allowed[msg.sender][_spender] = _newAllowed;\n      }\n    }\n\n    Approval(msg.sender, _spender, _newAllowed);\n    return true;\n  }\n\n  \n  \n  \n  \n  function changeOwner(TokenStorage storage self, address _newOwner) public returns (bool) {\n    require((self.owner == msg.sender) && (_newOwner > 0));\n\n    self.owner = _newOwner;\n    OwnerChange(msg.sender, _newOwner);\n    return true;\n  }\n\n  \n  \n  \n  \n  function mintToken(TokenStorage storage self, uint256 _amount) public returns (bool) {\n    require((self.owner == msg.sender) && self.stillMinting);\n    uint256 _newAmount;\n    bool err;\n\n    (err, _newAmount) = self.totalSupply.plus(_amount);\n    require(!err);\n\n    self.totalSupply =  _newAmount;\n    self.balances[self.owner] = self.balances[self.owner] + _amount;\n    Transfer(0x0, self.owner, _amount);\n    return true;\n  }\n\n  \n  \n  \n  function closeMint(TokenStorage storage self) public returns (bool) {\n    require(self.owner == msg.sender);\n\n    self.stillMinting = false;\n    MintingClosed(true);\n    return true;\n  }\n\n  \n  \n  \n  \n  function burnToken(TokenStorage storage self, uint256 _amount) public returns (bool) {\n      uint256 _newBalance;\n      bool err;\n\n      (err, _newBalance) = self.balances[msg.sender].minus(_amount);\n      require(!err);\n\n      self.balances[msg.sender] = _newBalance;\n      self.totalSupply = self.totalSupply - _amount;\n      Burn(msg.sender, _amount);\n      Transfer(msg.sender, 0x0, _amount);\n      return true;\n  }\n}",
        "function": null,
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/consensys-Modular_Interactive_Crowdsale/ethereum-libraries-73abc22623e0841b8ea67a5089002f4867102672/CrowdsaleLib/IICOLib/truffle/contracts/InteractiveCrowdsaleLib.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract Fee is Owned, Validating, StandardToken {\n\n  /* This notifies clients about the amount burnt */\n  event Burn(address indexed from, uint256 value);\n\n  string public name;                   //fancy name: eg Simon Bucks\n  uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\n  string public symbol;                 //An identifier: eg SBX\n  uint256 public feeInCirculation;      //total fee in circulation\n  string public version = 'F0.1';       //human 0.1 standard. Just an arbitrary versioning scheme.\n  address public minter;\n\n  modifier onlyMinter {\n    require(msg.sender == minter);\n    _;\n  }\n\n  \n  function Fee(\n  address[] _owners,\n  string _tokenName,\n  uint8 _decimalUnits,\n  string _tokenSymbol\n  )\n  public\n  notEmpty(_tokenName)\n  notEmpty(_tokenSymbol)\n  {\n    setOwners(_owners);\n    name = _tokenName;\n    decimals = _decimalUnits;\n    symbol = _tokenSymbol;\n  }\n\n  \n  \n  function setMinter(address _minter) external onlyOwner validAddress(_minter) {\n    minter = _minter;\n  }\n\n  \n  \n  function burnTokens(uint _value) public notZero(_value) {\n    require(balances[msg.sender] >= _value);\n\n    balances[msg.sender] = SafeMath.sub(balances[msg.sender], _value);\n    feeInCirculation = SafeMath.sub(feeInCirculation, _value);\n    Burn(msg.sender, _value);\n  }\n\n  \n  \n  \n  \n  function sendTokens(address _to, uint _value) public onlyMinter validAddress(_to) notZero(_value) {\n    balances[_to] = SafeMath.add(balances[_to], _value);\n    feeInCirculation = SafeMath.add(feeInCirculation, _value);\n    Transfer(msg.sender, _to, _value);\n  }\n}",
        "function": null,
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Blockchain Labs NZ-Leverj/staking-e8716e4a11881fad181b5330206d8b0c27a58510/contracts/Fee.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract Fee is Owned, Validating, StandardToken {\n\n  /* This notifies clients about the amount burnt */\n  event Burn(address indexed from, uint256 value);\n\n  string public name;                   //fancy name: eg Simon Bucks\n  uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\n  string public symbol;                 //An identifier: eg SBX\n  uint256 public feeInCirculation;      //total fee in circulation\n  string public version = 'F0.1';       //human 0.1 standard. Just an arbitrary versioning scheme.\n  address public minter;\n\n  modifier onlyMinter {\n    require(msg.sender == minter);\n    _;\n  }\n\n  \n  function Fee(\n  address[] _owners,\n  string _tokenName,\n  uint8 _decimalUnits,\n  string _tokenSymbol\n  )\n  public\n  notEmpty(_tokenName)\n  notEmpty(_tokenSymbol)\n  {\n    setOwners(_owners);\n    name = _tokenName;\n    decimals = _decimalUnits;\n    symbol = _tokenSymbol;\n  }\n\n  \n  \n  function setMinter(address _minter) external onlyOwner validAddress(_minter) {\n    minter = _minter;\n  }\n\n  \n  \n  function burnTokens(uint _value) public notZero(_value) {\n    require(balances[msg.sender] >= _value);\n\n    balances[msg.sender] = SafeMath.sub(balances[msg.sender], _value);\n    feeInCirculation = SafeMath.sub(feeInCirculation, _value);\n    Burn(msg.sender, _value);\n  }\n\n  \n  \n  \n  \n  function sendTokens(address _to, uint _value) public onlyMinter validAddress(_to) notZero(_value) {\n    balances[_to] = SafeMath.add(balances[_to], _value);\n    feeInCirculation = SafeMath.add(feeInCirculation, _value);\n    Transfer(msg.sender, _to, _value);\n  }\n}",
        "function": null,
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Blockchain Labs NZ-Leverj/staking-e8716e4a11881fad181b5330206d8b0c27a58510/contracts/Fee.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract Owned {\n  event OwnerAddition(address indexed owner);\n\n  event OwnerRemoval(address indexed owner);\n\n  // owner address to enable admin functions\n  mapping (address => bool) public isOwner;\n\n  address[] public owners;\n\n  address public operator;\n\n  modifier onlyOwner {\n\n    require(isOwner[msg.sender]);\n    _;\n  }\n\n  modifier onlyOperator {\n    require(msg.sender == operator);\n    _;\n  }\n\n  function setOperator(address _operator) external onlyOwner {\n    require(_operator != address(0));\n    operator = _operator;\n  }\n\n  function removeOwner(address _owner) public onlyOwner {\n    require(owners.length > 1);\n    isOwner[_owner] = false;\n    for (uint i = 0; i < owners.length - 1; i++) {\n      if (owners[i] == _owner) {\n        owners[i] = owners[SafeMath.sub(owners.length, 1)];\n        break;\n      }\n    }\n    owners.length = SafeMath.sub(owners.length, 1);\n    OwnerRemoval(_owner);\n  }\n\n  function addOwner(address _owner) external onlyOwner {\n    require(_owner != address(0));\n    if(isOwner[_owner]) return;\n    isOwner[_owner] = true;\n    owners.push(_owner);\n    OwnerAddition(_owner);\n  }\n\n  function setOwners(address[] _owners) internal {\n    for (uint i = 0; i < _owners.length; i++) {\n      require(_owners[i] != address(0));\n      isOwner[_owners[i]] = true;\n      OwnerAddition(_owners[i]);\n    }\n    owners = _owners;\n  }\n\n  function getOwners() public constant returns (address[])  {\n    return owners;\n  }\n\n}",
        "function": null,
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Blockchain Labs NZ-Leverj/staking-e8716e4a11881fad181b5330206d8b0c27a58510/contracts/Fee.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract StandardToken is Token {\n\n    function transfer(address _to, uint256 _value) public returns (bool success) {\n        //Default assumes totalSupply can't be over max (2^256 - 1).\n        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n        //Replace the if with this one instead.\n        //require(balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]);\n        require(balances[msg.sender] >= _value);\n        balances[msg.sender] -= _value;\n        balances[_to] += _value;\n        Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n        //same as above. Replace this line with the following if you want to protect against wrapping uints.\n        //require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]);\n        require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value);\n        balances[_to] += _value;\n        balances[_from] -= _value;\n        allowed[_from][msg.sender] -= _value;\n        Transfer(_from, _to, _value);\n        return true;\n    }\n\n    function balanceOf(address _owner) public constant returns (uint256 balance) {\n        return balances[_owner];\n    }\n\n    function approve(address _spender, uint256 _value) public returns (bool success) {\n        allowed[msg.sender][_spender] = _value;\n        Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\n      return allowed[_owner][_spender];\n    }\n\n    mapping (address => uint256) balances;\n    mapping (address => mapping (address => uint256)) allowed;\n}",
        "function": null,
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Blockchain Labs NZ-Leverj/staking-e8716e4a11881fad181b5330206d8b0c27a58510/contracts/Fee.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract NanoLoanEngine is ERC721, Engine, Ownable, TokenLockable {\n    uint256 public constant VERSION = 202;\n    string public constant VERSION_NAME = \"Basalt\";\n\n    uint256 private activeLoans = 0;\n    mapping(address => uint256) private lendersBalance;\n\n    function name() constant returns (string _name) {\n        _name = \"RCN - Nano loan engine - Basalt 202\";\n    }\n\n    function symbol() constant returns (string _symbol) {\n        _symbol = \"RCN-NLE-202\";\n    }\n\n    function totalSupply() constant returns (uint _totalSupply) {\n        _totalSupply = activeLoans;\n    }\n\n    function balanceOf(address _owner) constant returns (uint _balance) {\n        _balance = lendersBalance[_owner];\n    }\n\n    function tokenOfOwnerByIndex(address _owner, uint256 _index) constant returns (uint tokenId) {\n        uint256 tokenCount = balanceOf(_owner);\n\n        if (tokenCount == 0 || _index >= tokenCount) {\n            // Fail transaction\n            revert();\n        } else {\n            uint256 totalLoans = totalSupply();\n            uint256 resultIndex = 0;\n\n            uint256 loanId;\n            // SWC-128-DoS With Block Gas Limit: L46\n            for (loanId = 0; loanId <= totalLoans; loanId++) {\n                if (loans[loanId].lender == _owner && loans[loanId].status == Status.lent) {\n                    if (resultIndex == _index) {\n                        return loanId;\n                    }\n                    resultIndex++;\n                }\n            }\n\n            revert();\n        }\n    }\n\n    function tokensOfOwner(address _owner) external constant returns(uint256[] ownerTokens) {\n        uint256 tokenCount = balanceOf(_owner);\n\n        if (tokenCount == 0) {\n            // Return an empty array\n            return new uint256[](0);\n        } else {\n            uint256[] memory result = new uint256[](tokenCount);\n            uint256 totalLoans = totalSupply();\n            uint256 resultIndex = 0;\n\n            uint256 loanId;\n\n            for (loanId = 0; loanId <= totalLoans; loanId++) {\n                if (loans[loanId].lender == _owner && loans[loanId].status == Status.lent) {\n                    result[resultIndex] = loanId;\n                    resultIndex++;\n                }\n            }\n\n            return result;\n        }\n    }\n    \n    Token public rcn;\n    bool public deprecated;\n\n    event CreatedLoan(uint _index, address _borrower, address _creator);\n    event ApprovedBy(uint _index, address _address);\n    event Lent(uint _index, address _lender, address _cosigner);\n    event DestroyedBy(uint _index, address _address);\n    event PartialPayment(uint _index, address _sender, address _from, uint256 _amount);\n    event TotalPayment(uint _index);\n\n    function NanoLoanEngine(Token _rcn) public {\n        owner = msg.sender;\n        rcn = _rcn;\n    }\n\n    struct Loan {\n        Status status;\n        Oracle oracle;\n\n        address borrower;\n        address lender;\n        address creator;\n        address cosigner;\n        \n        uint256 amount;\n        uint256 interest;\n        uint256 punitoryInterest;\n        uint256 interestTimestamp;\n        uint256 paid;\n        uint256 interestRate;\n        uint256 interestRatePunitory;\n        uint256 dueTime;\n        uint256 duesIn;\n\n        bytes32 currency;\n        uint256 cancelableAt;\n        uint256 lenderBalance;\n\n        address approvedTransfer;\n        uint256 expirationRequest;\n\n        mapping(address => bool) approbations;\n    }\n\n    Loan[] private loans;\n\n    /**\n        @dev Creates a loan request, the loan can be generated with any borrower, cosigner, and conditions; if the \n        cosigner and borrower agree they must call the \"approve\" function.\n\n        The creator of the loan is the caller of this function; this is useful to track which wallet created the loan.\n\n        @param _oracleContract Address of the Oracle contract, if the loan does not use any oracle, this field should be 0x0.\n        @param _borrower Address of the borrower\n        @param _currency The currency to use with the oracle, the currency code is generated with the following formula,\n            keccak256(ticker,decimals).\n        @param _amount The requested amount; currency and unit are defined by the Oracle, if there is no Oracle present\n            the currency is RCN, and the unit is wei.\n        @param _interestRate The non-punitory interest rate by second, defined as a denominator of 10 000 000.\n        @param _interestRatePunitory The punitory interest rate by second, defined as a denominator of 10 000 000.\n            Ej: interestRate 11108571428571 = 28% Anual interest\n        @param _duesIn The time in seconds that the borrower has in order to pay the debt after the lender lends the money.\n        @param _cancelableAt Delta in seconds specifying how much interest should be added in advance, if the borrower pays \n        entirely or partially the loan before this term, no extra interest will be deducted.\n        @param _expirationRequest Timestamp of when the loan request expires, if the loan is not filled before this date, \n            the request is no longer valid.\n    */\n    function createLoan(Oracle _oracleContract, address _borrower, bytes32 _currency, uint256 _amount, uint256 _interestRate,\n        uint256 _interestRatePunitory, uint256 _duesIn, uint256 _cancelableAt, uint256 _expirationRequest) returns (uint256) {\n\n        require(!deprecated);\n        require(_cancelableAt <= _duesIn);\n        require(_oracleContract != address(0) || _currency == 0x0);\n        require(_borrower != address(0));\n        require(_amount != 0);\n        require(_interestRatePunitory != 0);\n        require(_interestRate != 0);\n        require(_expirationRequest > block.timestamp);\n\n        var loan = Loan(Status.initial, _oracleContract, _borrower, 0x0, msg.sender, 0x0, _amount, 0, 0, 0, 0, _interestRate,\n            _interestRatePunitory, 0, _duesIn, _currency, _cancelableAt, 0, 0x0, _expirationRequest);\n        uint index = loans.push(loan) - 1;\n        CreatedLoan(index, _borrower, msg.sender);\n\n        if (msg.sender == _borrower) {\n            approveLoan(index);\n        }\n\n        return index;\n    }\n    \n    function ownerOf(uint256 index) constant returns (address owner) { owner = loans[index].lender; }\n    function getTotalLoans() constant returns (uint256) { return loans.length; }\n    function getOracle(uint index) constant returns (Oracle) { return loans[index].oracle; }\n    function getBorrower(uint index) constant returns (address) { return loans[index].borrower; }\n    function getCosigner(uint index) constant returns (address) { return loans[index].cosigner; }\n    function getCreator(uint index) constant returns (address) { return loans[index].creator; }\n    function getAmount(uint index) constant returns (uint256) { return loans[index].amount; }\n    function getPunitoryInterest(uint index) constant returns (uint256) { return loans[index].punitoryInterest; }\n    function getInterestTimestamp(uint index) constant returns (uint256) { return loans[index].interestTimestamp; }\n    function getPaid(uint index) constant returns (uint256) { return loans[index].paid; }\n    function getInterestRate(uint index) constant returns (uint256) { return loans[index].interestRate; }\n    function getInterestRatePunitory(uint index) constant returns (uint256) { return loans[index].interestRatePunitory; }\n    function getDueTime(uint index) constant returns (uint256) { return loans[index].dueTime; }\n    function getDuesIn(uint index) constant returns (uint256) { return loans[index].duesIn; }\n    function getCancelableAt(uint index) constant returns (uint256) { return loans[index].cancelableAt; }\n    function getApprobation(uint index, address _address) constant returns (bool) { return loans[index].approbations[_address]; }\n    function getStatus(uint index) constant returns (Status) { return loans[index].status; }\n    function getLenderBalance(uint index) constant returns (uint256) { return loans[index].lenderBalance; }\n    function getApprovedTransfer(uint index) constant returns (address) {return loans[index].approvedTransfer; }\n    function getCurrency(uint index) constant returns (bytes32) { return loans[index].currency; }\n    function getExpirationRequest(uint index) constant returns (uint256) { return loans[index].expirationRequest; }\n    function getInterest(uint index) constant returns (uint256) { return loans[index].interest; }\n\n    /**\n        @param index Index of the loan\n\n        @return true if the loan has been approved by the borrower and cosigner.\n    */\n    function isApproved(uint index) constant returns (bool) {\n        Loan storage loan = loans[index];\n        return loan.approbations[loan.borrower];\n    }\n\n    /**\n        @dev Called by the members of the loan to show that they agree with the terms of the loan; the borrower\n        must call this method before any lender could call the method \"lend\".\n            \n        Any address can call this method to be added to the \"approbations\" mapping.\n\n        @param index Index of the loan\n\n        @return true if the approve was done successfully\n    */\n    function approveLoan(uint index) public returns(bool) {\n        Loan storage loan = loans[index];\n        require(loan.status == Status.initial);\n        loan.approbations[msg.sender] = true;\n        ApprovedBy(index, msg.sender);\n        return true;\n    }\n\n    /**\n        @dev Performs the lend of the RCN equivalent to the requested amount, and transforms the msg.sender in the new lender.\n\n        The loan must be previously approved by the borrower; before calling this function, the lender candidate must \n        call the \"approve\" function on the RCN Token, specifying an amount sufficient enough to pay the equivalent of\n        the requested amount, and the cosigner fee.\n        \n        @param index Index of the loan\n        @param oracleData Data required by the oracle to return the rate, the content of this field must be provided\n            by the url exposed in the url() method of the oracle.\n        @param cosigner Address of the cosigner, 0x0 for lending without cosigner.\n        @param cosignerData Data required by the cosigner to process the request.\n\n        @return true if the lend was done successfully\n    */\n    function lend(uint index, bytes oracleData, Cosigner cosigner, bytes cosignerData) public returns (bool) {\n        Loan storage loan = loans[index];\n\n        require(loan.status == Status.initial);\n        require(isApproved(index));\n        require(block.timestamp <= loan.expirationRequest);\n\n        loan.lender = msg.sender;\n        loan.dueTime = safeAdd(block.timestamp, loan.duesIn);\n        loan.interestTimestamp = block.timestamp;\n        loan.status = Status.lent;\n        \n        if (loan.cancelableAt > 0)\n            internalAddInterest(loan, safeAdd(block.timestamp, loan.cancelableAt));\n\n        uint256 rate = getRate(loan, oracleData);\n\n        if (cosigner != address(0)) {\n            // The cosigner it's temporary set to the next address (cosigner + 2), it's expected that the cosigner will\n            // call the method \"cosign\" to accept the conditions; that method also sets the cosigner to the right\n            // address. If that does not happen, the transaction fails.\n            loan.cosigner = address(uint256(cosigner) + 2);\n            require(cosigner.requestCosign(this, index, cosignerData, oracleData));\n            require(loan.cosigner == address(cosigner));\n        }\n        \n        require(rcn.transferFrom(msg.sender, loan.borrower, safeMult(loan.amount, rate)));\n        \n        // ERC721, create new loan and transfer it to the lender\n        Transfer(0x0, loan.lender, index);\n        activeLoans += 1;\n        lendersBalance[loan.lender] += 1;\n        Lent(index, loan.lender, cosigner);\n\n        return true;\n    }\n\n    /**\n        @dev The cosigner must call this method to accept the conditions of a loan, this method pays the cosigner his fee\n\n        @param index Index of the loan\n        @param cost Fee set by the cosigner\n\n        @return true If the cosign was successfull\n    */\n    function cosign(uint index, uint256 cost) external returns (bool) {\n        Loan storage loan = loans[index];\n        require(loan.status == Status.lent && (loan.dueTime - loan.duesIn) == block.timestamp);\n        require(loan.cosigner != address(0));\n        require(loan.cosigner == address(uint256(msg.sender) + 2));\n        loan.cosigner = msg.sender;\n        require(rcn.transferFrom(loan.lender, msg.sender, cost));\n        return true;\n    }\n\n    /**\n        @dev Destroys a loan, the borrower could call this method if they performed an accidental or regretted \n        \"approve\" of the loan, this method only works for them if the loan is in \"pending\" status.\n\n        The lender can call this method at any moment, in case of a loan with status \"lent\" the lender is pardoning \n        the debt. \n\n        @param index Index of the loan\n\n        @return true if the destroy was done successfully\n    */\n    function destroy(uint index) public returns (bool) {\n        Loan storage loan = loans[index];\n        require(loan.status != Status.destroyed);\n        require(msg.sender == loan.lender || (msg.sender == loan.borrower && loan.status == Status.initial));\n        DestroyedBy(index, msg.sender);\n\n        // ERC721, remove loan from circulation\n        if (loan.status != Status.initial) {\n            lendersBalance[loan.lender] -= 1;\n            activeLoans -= 1;\n            Transfer(loan.lender, 0x0, index);\n        }\n\n        loan.status = Status.destroyed;\n        return true;\n    }\n\n    /**\n        @dev Transfers a loan to a different lender, the caller must be the current lender or previously being\n        approved with the method \"approveTransfer\"; only loans with the Status.lent status can be transfered.\n\n        @param index Index of the loan\n        @param to New lender\n\n        @return true if the transfer was done successfully\n    */\n    function transfer(address to, uint256 index) public returns (bool) {\n        Loan storage loan = loans[index];\n        \n        require(loan.status != Status.destroyed && loan.status != Status.paid);\n        require(msg.sender == loan.lender || msg.sender == loan.approvedTransfer);\n        require(to != address(0));\n        loan.lender = to;\n        loan.approvedTransfer = address(0);\n\n        // ERC721, transfer loan to another address\n        lendersBalance[msg.sender] -= 1;\n        lendersBalance[to] += 1;\n        Transfer(loan.lender, to, index);\n\n        return true;\n    }\n\n    /**\n        @dev ERC721 method, transfers the loan to the msg.sender, the msg.sender must be approved using the \n        \"approve\" method.\n\n        @return true if the transfer was successfull\n    */\n    function takeOwnership(uint256 _index) public returns (bool) {\n        return transfer(msg.sender, _index);\n    }\n\n    /**\n        @dev Approves the transfer of a given loan in the name of the lender, the behavior of this function is similar to\n        \"approve\" in the ERC20 standard, but only one approved address is allowed at a time.\n\n        The same method can be called passing 0x0 as parameter \"to\" to erase a previously approved address.\n\n        @param to Address allowed to transfer the loan or 0x0 to delete\n        @param index Index of the loan\n\n        @return true if the approve was done successfully\n    */\n    function approve(address to, uint256 index) public returns (bool) {\n        Loan storage loan = loans[index];\n        require(msg.sender == loan.lender);\n        loan.approvedTransfer = to;\n        Approval(msg.sender, to, index);\n        return true;\n    }\n\n    /**\n        @dev Returns the pending amount to complete de payment of the loan, keep in mind that this number increases \n        every second.\n\n        @param index Index of the loan\n\n        @return Aprox pending payment amount\n    */\n    function getPendingAmount(uint index) public constant returns (uint256) {\n        Loan storage loan = loans[index];\n        addInterest(index);\n        return getRawPendingAmount(loan);\n    }\n\n    function getRawPendingAmount(Loan loan) internal returns (uint256) {\n        return safeSubtract(safeAdd(safeAdd(loan.amount, loan.interest), loan.punitoryInterest), loan.paid);\n    }\n\n    /**\n        @dev Calculates the interest of a given amount, interest rate and delta time.\n\n        @param timeDelta Elapsed time\n        @param interestRate Interest rate expressed as the denominator of 10 000 000.\n        @param amount Amount to apply interest\n\n        @return realDelta The real timeDelta applied\n        @return interest The interest gained in the realDelta time\n    */\n    function calculateInterest(uint256 timeDelta, uint256 interestRate, uint256 amount) public constant returns (uint256 realDelta, uint256 interest) {\n        if (amount == 0) {\n            interest = 0;\n            realDelta = timeDelta;\n        } else {\n            interest = safeMult(safeMult(100000, amount), timeDelta) / interestRate;\n            realDelta = safeMult(interest, interestRate) / (amount * 100000);\n        }\n    }\n\n    /**\n        @dev Computes loan interest\n\n        Computes the punitory and non-punitory interest of a given loan and only applies the change.\n        \n        @param loan Loan to compute interest\n        @param timestamp Target absolute unix time to calculate interest.\n    */\n    function internalAddInterest(Loan storage loan, uint256 timestamp) internal {\n        if (timestamp > loan.interestTimestamp) {\n            uint256 newInterest = loan.interest;\n            uint256 newPunitoryInterest = loan.punitoryInterest;\n\n            uint256 newTimestamp;\n            uint256 realDelta;\n            uint256 calculatedInterest;\n\n            uint256 deltaTime;\n            uint256 pending;\n\n            uint256 endNonPunitory = min(timestamp, loan.dueTime);\n            if (endNonPunitory > loan.interestTimestamp) {\n                deltaTime = endNonPunitory - loan.interestTimestamp;\n\n                if (loan.paid < loan.amount) {\n                    pending = loan.amount - loan.paid;\n                } else {\n                    pending = 0;\n                }\n\n                (realDelta, calculatedInterest) = calculateInterest(deltaTime, loan.interestRate, pending);\n                newInterest = safeAdd(calculatedInterest, newInterest);\n                newTimestamp = loan.interestTimestamp + realDelta;\n            }\n\n            if (timestamp > loan.dueTime) {\n                uint256 startPunitory = max(loan.dueTime, loan.interestTimestamp);\n                deltaTime = timestamp - startPunitory;\n\n                uint256 debt = safeAdd(loan.amount, newInterest);\n                pending = min(debt, safeSubtract(safeAdd(debt, newPunitoryInterest), loan.paid));\n\n                (realDelta, calculatedInterest) = calculateInterest(deltaTime, loan.interestRatePunitory, pending);\n                newPunitoryInterest = safeAdd(newPunitoryInterest, calculatedInterest);\n                newTimestamp = startPunitory + realDelta;\n            }\n            \n            if (newInterest != loan.interest || newPunitoryInterest != loan.punitoryInterest) {\n                loan.interestTimestamp = newTimestamp;\n                loan.interest = newInterest;\n                loan.punitoryInterest = newPunitoryInterest;\n            }\n        }\n    }\n\n    /**\n        @dev Computes loan interest only up to current unix time\n\n        @param timestamp Target absolute unix time to calculate interest.\n    */\n    function addInterestUpTo(Loan storage loan, uint256 timestamp) internal {\n        require(loan.status == Status.lent);\n        if (timestamp <= block.timestamp) {\n            internalAddInterest(loan, timestamp);\n        }\n    }\n\n    /**\n        @dev Updates the loan accumulated interests up to the current Unix time.\n        \n        @param index Index of the loan\n    */\n    function addInterest(uint index) public {\n        Loan storage loan = loans[index];\n        addInterestUpTo(loan, block.timestamp);\n    }\n    \n    /**\n        @dev Pay loan\n\n        Realizes a payment of a given Loan, before performing the payment the accumulated\n        interest is computed and added to the total pending amount.\n\n        Before calling this function, the msg.sender must call the \"approve\" function on the RCN Token, specifying an amount\n        sufficient enough to pay the equivalent of the desired payment and the oracle fee.\n\n        Because it is difficult or even impossible to know in advance how much RCN are going to be spent on the\n        transaction*, we recommend performing the \"approve\" using an amount 5% superior to the wallet estimated\n        spending. If the RCN spent results to be less, the extra tokens are never debited from the msg.sender.\n\n        * The RCN rate can fluctuate on the same block, and it is impossible to know in advance the exact time of the\n        confirmation of the transaction. \n\n        If the paid pending amount equals zero, the loan changes status to \"paid\" and it is considered closed.\n\n        @param index Index of the loan\n        @param _amount Amount to pay, specified in the loan currency; or in RCN if the loan has no oracle\n        @param _from The identity of the payer\n        @param oracleData Data required by the oracle to return the rate, the content of this field must be provided\n            by the url exposed in the url() method of the oracle.\n            \n        @return true if the payment was executed successfully\n    */\n    function pay(uint index, uint256 _amount, address _from, bytes oracleData) public returns (bool) {\n        Loan storage loan = loans[index];\n\n        require(loan.status == Status.lent);\n        addInterest(index);\n        uint256 toPay = min(getPendingAmount(index), _amount);\n        PartialPayment(index, msg.sender, _from, toPay);\n\n        loan.paid = safeAdd(loan.paid, toPay);\n\n        if (getRawPendingAmount(loan) == 0) {\n            TotalPayment(index);\n            loan.status = Status.paid;\n\n            // ERC721, remove loan from circulation\n            lendersBalance[loan.lender] -= 1;\n            activeLoans -= 1;\n            Transfer(loan.lender, 0x0, index);\n        }\n\n        uint256 rate = getRate(loan, oracleData);\n        uint256 transferValue = safeMult(toPay, rate);\n        lockTokens(rcn, transferValue);\n        require(rcn.transferFrom(msg.sender, this, transferValue));\n        loan.lenderBalance = safeAdd(transferValue, loan.lenderBalance);\n\n        return true;\n    }\n\n    /**\n        @dev Retrieves the rate corresponding of the loan oracle, if the loan has no oracle the rate is 1\n\n        @param loan The loan with the cosigner\n        @param data Data required by the oracle\n\n        @return The rate of the oracle\n    */\n    function getRate(Loan loan, bytes data) internal returns (uint256) {\n        if (loan.oracle == address(0)) {\n            return 1;\n        } else {\n            return loan.oracle.getRate(loan.currency, data);\n        }\n    }\n\n    /**\n        @dev Withdraw lender funds\n\n        When a loan is paid, the funds are not transferred automatically to the lender, the funds are stored on the\n        engine contract, and the lender must call this function specifying the amount desired to transfer and the \n        destination.\n\n        This behavior is defined to allow the temporary transfer of the loan to a smart contract, without worrying that\n        the contract will receive tokens that are not traceable; and it allows the development of decentralized \n        autonomous organizations.\n\n        @param index Index of the loan\n        @param to Destination of the wiwthdraw funds\n        @param amount Amount to withdraw, in RCN\n\n        @return true if the withdraw was executed successfully\n    */\n    function withdrawal(uint index, address to, uint256 amount) public returns (bool) {\n        Loan storage loan = loans[index];\n        require(msg.sender == loan.lender);\n        loan.lenderBalance = safeSubtract(loan.lenderBalance, amount);\n        require(rcn.transfer(to, amount));\n        unlockTokens(rcn, amount);\n        return true;\n    }\n\n    function withdrawalRange(uint256 fromIndex, uint256 toIndex, address to) public returns (uint256) {\n        uint256 loanId;\n        uint256 totalWithdraw = 0;\n\n        for (loanId = fromIndex; loanId <= toIndex; loanId++) {\n            Loan storage loan = loans[loanId];\n            if (loan.lender == msg.sender) {\n                totalWithdraw += loan.lenderBalance;\n                loan.lenderBalance = 0;\n            }\n        }\n\n        require(rcn.transfer(to, totalWithdraw));\n        unlockTokens(rcn, totalWithdraw);\n        \n        return totalWithdraw;\n    }\n\n    function withdrawalList(uint256[] memory loanIds, address to) public returns (uint256) {\n        uint256 inputId;\n        uint256 totalWithdraw = 0;\n\n        for (inputId = 0; inputId < loanIds.length; inputId++) {\n            Loan storage loan = loans[loanIds[inputId]];\n            if (loan.lender == msg.sender) {\n                totalWithdraw += loan.lenderBalance;\n                loan.lenderBalance = 0;\n            }\n        }\n\n        require(rcn.transfer(to, totalWithdraw));\n        unlockTokens(rcn, totalWithdraw);\n\n        return totalWithdraw;\n    }\n\n    /**\n        @dev Deprecates the engine, locks the creation of new loans.\n    */\n    function setDeprecated(bool _deprecated) public onlyOwner {\n        deprecated = _deprecated;\n    }\n}",
        "function": null,
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinfabrik-RCN Network Smart Contract Audit/rcn-network-3ded36151ad55543d16c354e70161852de4061d0/contracts/NanoLoanEngine.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract StakingPool is Owned {\n    using SafeMath for uint256;\n    \n    Ierc20 public tswap;\n    Ierc20 public rewardToken;\n    uint256 poolDuration;\n    uint256 totalRewards;\n    uint256 rewardsWithdrawn;\n    uint256 poolStartTime;\n    uint256 poolEndTime;\n    uint256 totalStaked;\n    // Represents a single stake for a user. A user may have multiple.\n    struct Stake {\n        uint256 amount;\n        uint256 stakingTime;\n        uint256 lastWithdrawTime;\n    }\n    mapping (address => Stake[]) public userStaking;\n    \n    // Represents total staking of an user\n    struct UserTotals {\n        uint256 totalStaking;\n        uint256 totalStakingTIme;\n    }\n    mapping (address => UserTotals) public userTotalStaking;\n    \n    struct Ris3Rewards {\n        uint256 totalWithdrawn;\n        uint256 lastWithdrawTime;\n    }\n    mapping(address => Ris3Rewards) public userRewardInfo;\n    \n    event OwnerSetReward(uint256 amount);\n    event Staked(address userAddress, uint256 amount);\n    event StakingWithdrawal(address userAddress, uint256 amount);\n    event RewardWithdrawal(address userAddress, uint256 amount);\n    event PoolDurationChange(uint256 poolDuration);\n    \n    /**\n     * Constrctor function\n    */\n    constructor() public {\n        tswap = Ierc20(0xf823eA01D48F7Fb36b4b319f21dae404Ac86Bb8d);\n        rewardToken = Ierc20(0xdE55ea8232e0B1615d762eFCB17Cb2D7df164727);\n        poolDuration = 1 hours;\n    }\n    \n    //Set pool rewards\n    function ownerSetPoolRewards(uint256 _rewardAmount) external onlyOwner {\n        require(poolStartTime == 0, \"Pool rewards already set\");\n        require(_rewardAmount > 0, \"Cannot create pool with zero amount\");\n        \n        //set total rewards value\n        totalRewards = _rewardAmount;\n        \n        poolStartTime = now;\n        poolEndTime = now + poolDuration;\n        \n        //transfer tokens to contract\n        // SWC-104-Unchecked Call Return Value: L132\n        rewardToken.transferFrom(msg.sender, this, _rewardAmount);\n        emit OwnerSetReward(_rewardAmount);\n    }\n    \n    //Stake function for users to stake SWAP token\n    function stake(uint256 amount) external {\n        require(amount > 0, \"Cannot stake 0\");\n        require(now < poolEndTime, \"Staking pool is closed\"); //staking pool is closed for staking\n        \n        //add value in staking\n        userTotalStaking[msg.sender].totalStaking = userTotalStaking[msg.sender].totalStaking.add(amount);\n        \n        //add new stake\n        Stake memory newStake = Stake(amount, now, 0);\n        userStaking[msg.sender].push(newStake);\n        \n        //add to total staked\n        totalStaked = totalStaked.add(amount);\n        \n        tswap.transferFrom(msg.sender, this, amount);\n        emit Staked(msg.sender, amount);\n    }\n    \n    //compute rewards\n    function computeNewReward(uint256 _rewardAmount, uint256 _stakedAmount, uint256 _stakeTimeSec) private view returns (uint256 _reward) {\n        uint256 rewardPerSecond = totalRewards.mul(1 ether);\n        if (rewardPerSecond != 0 ) {\n            rewardPerSecond = rewardPerSecond.div(poolDuration);\n        }\n        \n        if (rewardPerSecond > 0) {\n            uint256 rewardPerSecForEachTokenStaked = rewardPerSecond.div(totalStaked);\n            uint256 userRewards = rewardPerSecForEachTokenStaked.mul(_stakedAmount).mul(_stakeTimeSec);\n                    userRewards = userRewards.div(1 ether);\n            \n            return _rewardAmount.add(userRewards);\n        } else {\n            return 0;\n        }\n    }\n    \n    //calculate your rewards\n    function calculateReward(address _userAddress) public view returns (uint256 _reward) {\n        // all user stakes\n        Stake[] storage accountStakes = userStaking[_userAddress];\n        \n        // Redeem from most recent stake and go backwards in time.\n        uint256 rewardAmount = 0;\n        uint256 i = accountStakes.length;\n        while (i > 0) {\n            Stake storage userStake = accountStakes[i - 1];\n            uint256 stakeTimeSec;\n            \n            //check if current time is more than pool ending time\n            if (now > poolEndTime) {\n                stakeTimeSec = poolEndTime.sub(userStake.stakingTime);\n                if(userStake.lastWithdrawTime != 0){\n                    stakeTimeSec = poolEndTime.sub(userStake.lastWithdrawTime);\n                }\n            } else {\n                stakeTimeSec = now.sub(userStake.stakingTime);\n                if(userStake.lastWithdrawTime != 0){\n                    stakeTimeSec = now.sub(userStake.lastWithdrawTime);\n                }\n            }\n            \n            // fully redeem a past stake\n            rewardAmount = computeNewReward(rewardAmount, userStake.amount, stakeTimeSec);\n            i--;\n        }\n        \n        return rewardAmount;\n    }\n    \n    //Withdraw staking and rewards\n    function withdrawStaking(uint256 amount) external {\n        require(amount > 0, \"Amount can not be zero\");\n        require(userTotalStaking[msg.sender].totalStaking >= amount, \"You are trying to withdaw more than your stake\");\n        \n        // 1. User Accounting\n        Stake[] storage accountStakes = userStaking[msg.sender];\n        \n        // Redeem from most recent stake and go backwards in time.\n        uint256 sharesLeftToBurn = amount;\n        uint256 rewardAmount = 0;\n        while (sharesLeftToBurn > 0) {\n            Stake storage lastStake = accountStakes[accountStakes.length - 1];\n            uint256 stakeTimeSec;\n            //check if current time is more than pool ending time\n            if (now > poolEndTime) {\n                stakeTimeSec = poolEndTime.sub(lastStake.stakingTime);\n                if(lastStake.lastWithdrawTime != 0){\n                    stakeTimeSec = poolEndTime.sub(lastStake.lastWithdrawTime);\n                }\n            } else {\n                stakeTimeSec = now.sub(lastStake.stakingTime);\n                if(lastStake.lastWithdrawTime != 0){\n                    stakeTimeSec = now.sub(lastStake.lastWithdrawTime);\n                }\n            }\n            \n            if (lastStake.amount <= sharesLeftToBurn) {\n                // fully redeem a past stake\n                rewardAmount = computeNewReward(rewardAmount, lastStake.amount, stakeTimeSec);\n                sharesLeftToBurn = sharesLeftToBurn.sub(lastStake.amount);\n                accountStakes.length--;\n            } else {\n                // partially redeem a past stake\n                rewardAmount = computeNewReward(rewardAmount, sharesLeftToBurn, stakeTimeSec);\n                lastStake.amount = lastStake.amount.sub(sharesLeftToBurn);\n                lastStake.lastWithdrawTime = now;\n                sharesLeftToBurn = 0;\n            }\n        }\n        \n        //substract value in staking\n        userTotalStaking[msg.sender].totalStaking = userTotalStaking[msg.sender].totalStaking.sub(amount);\n        \n        //substract from total staked\n        totalStaked = totalStaked.sub(amount);\n        \n        //update user rewards info\n        userRewardInfo[msg.sender].totalWithdrawn = userRewardInfo[msg.sender].totalWithdrawn.add(rewardAmount);\n        userRewardInfo[msg.sender].lastWithdrawTime = now;\n        \n        //update total rewards withdrawn\n        rewardsWithdrawn = rewardsWithdrawn.add(rewardAmount);\n        \n        //transfer rewards and tokens\n        // SWC-104-Unchecked Call Return Value: L262\n        rewardToken.transfer(msg.sender, rewardAmount);\n        tswap.transfer(msg.sender, amount);\n        \n        emit RewardWithdrawal(msg.sender, rewardAmount);\n        emit StakingWithdrawal(msg.sender, amount);\n    }\n    \n    //Withdraw rewards\n    function withdrawRewardsOnly() external {\n        uint256 _rwdAmount = calculateReward(msg.sender);\n        require(_rwdAmount > 0, \"You do not have enough rewards\");\n        \n        // 1. User Accounting\n        Stake[] storage accountStakes = userStaking[msg.sender];\n        \n        // Redeem from most recent stake and go backwards in time.\n        uint256 rewardAmount = 0;\n        uint256 i = accountStakes.length;\n        while (i > 0) {\n            Stake storage userStake = accountStakes[i - 1];\n            uint256 stakeTimeSec;\n            \n            //check if current time is more than pool ending time\n            if (now > poolEndTime) {\n                stakeTimeSec = poolEndTime.sub(userStake.stakingTime);\n                if(userStake.lastWithdrawTime != 0){\n                    stakeTimeSec = poolEndTime.sub(userStake.lastWithdrawTime);\n                }\n            } else {\n                stakeTimeSec = now.sub(userStake.stakingTime);\n                if(userStake.lastWithdrawTime != 0){\n                    stakeTimeSec = now.sub(userStake.lastWithdrawTime);\n                }\n            }\n            \n            // fully redeem a past stake\n            rewardAmount = computeNewReward(rewardAmount, userStake.amount, stakeTimeSec);\n            userStake.lastWithdrawTime = now;\n            i--;\n        }\n        \n        //update user rewards info\n        userRewardInfo[msg.sender].totalWithdrawn = userRewardInfo[msg.sender].totalWithdrawn.add(rewardAmount);\n        userRewardInfo[msg.sender].lastWithdrawTime = now;\n        \n        //update total rewards withdrawn\n        rewardsWithdrawn = rewardsWithdrawn.add(rewardAmount);\n        \n        //transfer rewards\n        rewardToken.transfer(msg.sender, rewardAmount);\n        emit RewardWithdrawal(msg.sender, rewardAmount);\n    }\n    \n    //get staking details by user address\n    function getStakingAmount(address _userAddress) external constant returns (uint256 _stakedAmount) {\n        return userTotalStaking[_userAddress].totalStaking;\n    }\n    \n    //get total rewards collected by user\n    function getTotalRewardCollectedByUser(address userAddress) view external returns (uint256 _totalRewardCollected) \n    {\n        return userRewardInfo[userAddress].totalWithdrawn;\n    }\n    \n    //get total SWAP token staked in the contract\n    function getTotalStaked() external constant returns ( uint256 _totalStaked) {\n        return totalStaked;\n    }\n    \n    //get total rewards in the contract\n    function getTotalRewards() external constant returns ( uint256 _totalRewards) {\n        return totalRewards;\n    }\n    \n    //get pool details\n    function getPoolDetails() external view returns (address _baseToken, address _pairedToken, uint256 _totalRewards, uint256 _rewardsWithdrawn, uint256 _poolStartTime, uint256 _poolEndTime) {\n        return (address(tswap),address(rewardToken),totalRewards,rewardsWithdrawn,poolStartTime,poolEndTime);\n    }\n    \n    //get duration of pools\n    function getPoolDuration() external constant returns (uint256 _poolDuration) {\n        return poolDuration;\n    }\n\n    //set duration of pools by owner in seconds\n    function setPoolDuration(uint256 _poolDuration) external onlyOwner {\n        poolDuration = _poolDuration;\n        poolEndTime = poolStartTime + _poolDuration;\n        emit PoolDurationChange(_poolDuration);\n    }\n    \n    //get SWAP token address\n    function getSwapAddress() external constant returns (address _swapAddress) {\n        return address(tswap);\n    }\n    \n    //set tswap address\n    function setTswapAddress(address _address) external onlyOwner {\n        tswap = Ierc20(_address);\n    }\n    \n    //set reward token address\n    function setRewardTokenAddress(address _address) external onlyOwner {\n        rewardToken = Ierc20(_address);\n    }\n    \n}",
        "function": null,
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Hacken-TrustSwap-V1/code/StakingPool.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract StakingPool is Owned {\n    using SafeMath for uint256;\n    \n    Ierc20 public tswap;\n    Ierc20 public rewardToken;\n    uint256 poolDuration;\n    uint256 totalRewards;\n    uint256 rewardsWithdrawn;\n    uint256 poolStartTime;\n    uint256 poolEndTime;\n    uint256 totalStaked;\n    // Represents a single stake for a user. A user may have multiple.\n    struct Stake {\n        uint256 amount;\n        uint256 stakingTime;\n        uint256 lastWithdrawTime;\n    }\n    mapping (address => Stake[]) public userStaking;\n    \n    // Represents total staking of an user\n    struct UserTotals {\n        uint256 totalStaking;\n        uint256 totalStakingTIme;\n    }\n    mapping (address => UserTotals) public userTotalStaking;\n    \n    struct Ris3Rewards {\n        uint256 totalWithdrawn;\n        uint256 lastWithdrawTime;\n    }\n    mapping(address => Ris3Rewards) public userRewardInfo;\n    \n    event OwnerSetReward(uint256 amount);\n    event Staked(address userAddress, uint256 amount);\n    event StakingWithdrawal(address userAddress, uint256 amount);\n    event RewardWithdrawal(address userAddress, uint256 amount);\n    event PoolDurationChange(uint256 poolDuration);\n    \n    /**\n     * Constrctor function\n    */\n    constructor() public {\n        tswap = Ierc20(0xf823eA01D48F7Fb36b4b319f21dae404Ac86Bb8d);\n        rewardToken = Ierc20(0xdE55ea8232e0B1615d762eFCB17Cb2D7df164727);\n        poolDuration = 1 hours;\n    }\n    \n    //Set pool rewards\n    function ownerSetPoolRewards(uint256 _rewardAmount) external onlyOwner {\n        require(poolStartTime == 0, \"Pool rewards already set\");\n        require(_rewardAmount > 0, \"Cannot create pool with zero amount\");\n        \n        //set total rewards value\n        totalRewards = _rewardAmount;\n        \n        poolStartTime = now;\n        poolEndTime = now + poolDuration;\n        \n        //transfer tokens to contract\n        // SWC-104-Unchecked Call Return Value: L132\n        rewardToken.transferFrom(msg.sender, this, _rewardAmount);\n        emit OwnerSetReward(_rewardAmount);\n    }\n    \n    //Stake function for users to stake SWAP token\n    function stake(uint256 amount) external {\n        require(amount > 0, \"Cannot stake 0\");\n        require(now < poolEndTime, \"Staking pool is closed\"); //staking pool is closed for staking\n        \n        //add value in staking\n        userTotalStaking[msg.sender].totalStaking = userTotalStaking[msg.sender].totalStaking.add(amount);\n        \n        //add new stake\n        Stake memory newStake = Stake(amount, now, 0);\n        userStaking[msg.sender].push(newStake);\n        \n        //add to total staked\n        totalStaked = totalStaked.add(amount);\n        \n        tswap.transferFrom(msg.sender, this, amount);\n        emit Staked(msg.sender, amount);\n    }\n    \n    //compute rewards\n    function computeNewReward(uint256 _rewardAmount, uint256 _stakedAmount, uint256 _stakeTimeSec) private view returns (uint256 _reward) {\n        uint256 rewardPerSecond = totalRewards.mul(1 ether);\n        if (rewardPerSecond != 0 ) {\n            rewardPerSecond = rewardPerSecond.div(poolDuration);\n        }\n        \n        if (rewardPerSecond > 0) {\n            uint256 rewardPerSecForEachTokenStaked = rewardPerSecond.div(totalStaked);\n            uint256 userRewards = rewardPerSecForEachTokenStaked.mul(_stakedAmount).mul(_stakeTimeSec);\n                    userRewards = userRewards.div(1 ether);\n            \n            return _rewardAmount.add(userRewards);\n        } else {\n            return 0;\n        }\n    }\n    \n    //calculate your rewards\n    function calculateReward(address _userAddress) public view returns (uint256 _reward) {\n        // all user stakes\n        Stake[] storage accountStakes = userStaking[_userAddress];\n        \n        // Redeem from most recent stake and go backwards in time.\n        uint256 rewardAmount = 0;\n        uint256 i = accountStakes.length;\n        while (i > 0) {\n            Stake storage userStake = accountStakes[i - 1];\n            uint256 stakeTimeSec;\n            \n            //check if current time is more than pool ending time\n            if (now > poolEndTime) {\n                stakeTimeSec = poolEndTime.sub(userStake.stakingTime);\n                if(userStake.lastWithdrawTime != 0){\n                    stakeTimeSec = poolEndTime.sub(userStake.lastWithdrawTime);\n                }\n            } else {\n                stakeTimeSec = now.sub(userStake.stakingTime);\n                if(userStake.lastWithdrawTime != 0){\n                    stakeTimeSec = now.sub(userStake.lastWithdrawTime);\n                }\n            }\n            \n            // fully redeem a past stake\n            rewardAmount = computeNewReward(rewardAmount, userStake.amount, stakeTimeSec);\n            i--;\n        }\n        \n        return rewardAmount;\n    }\n    \n    //Withdraw staking and rewards\n    function withdrawStaking(uint256 amount) external {\n        require(amount > 0, \"Amount can not be zero\");\n        require(userTotalStaking[msg.sender].totalStaking >= amount, \"You are trying to withdaw more than your stake\");\n        \n        // 1. User Accounting\n        Stake[] storage accountStakes = userStaking[msg.sender];\n        \n        // Redeem from most recent stake and go backwards in time.\n        uint256 sharesLeftToBurn = amount;\n        uint256 rewardAmount = 0;\n        while (sharesLeftToBurn > 0) {\n            Stake storage lastStake = accountStakes[accountStakes.length - 1];\n            uint256 stakeTimeSec;\n            //check if current time is more than pool ending time\n            if (now > poolEndTime) {\n                stakeTimeSec = poolEndTime.sub(lastStake.stakingTime);\n                if(lastStake.lastWithdrawTime != 0){\n                    stakeTimeSec = poolEndTime.sub(lastStake.lastWithdrawTime);\n                }\n            } else {\n                stakeTimeSec = now.sub(lastStake.stakingTime);\n                if(lastStake.lastWithdrawTime != 0){\n                    stakeTimeSec = now.sub(lastStake.lastWithdrawTime);\n                }\n            }\n            \n            if (lastStake.amount <= sharesLeftToBurn) {\n                // fully redeem a past stake\n                rewardAmount = computeNewReward(rewardAmount, lastStake.amount, stakeTimeSec);\n                sharesLeftToBurn = sharesLeftToBurn.sub(lastStake.amount);\n                accountStakes.length--;\n            } else {\n                // partially redeem a past stake\n                rewardAmount = computeNewReward(rewardAmount, sharesLeftToBurn, stakeTimeSec);\n                lastStake.amount = lastStake.amount.sub(sharesLeftToBurn);\n                lastStake.lastWithdrawTime = now;\n                sharesLeftToBurn = 0;\n            }\n        }\n        \n        //substract value in staking\n        userTotalStaking[msg.sender].totalStaking = userTotalStaking[msg.sender].totalStaking.sub(amount);\n        \n        //substract from total staked\n        totalStaked = totalStaked.sub(amount);\n        \n        //update user rewards info\n        userRewardInfo[msg.sender].totalWithdrawn = userRewardInfo[msg.sender].totalWithdrawn.add(rewardAmount);\n        userRewardInfo[msg.sender].lastWithdrawTime = now;\n        \n        //update total rewards withdrawn\n        rewardsWithdrawn = rewardsWithdrawn.add(rewardAmount);\n        \n        //transfer rewards and tokens\n        // SWC-104-Unchecked Call Return Value: L262\n        rewardToken.transfer(msg.sender, rewardAmount);\n        tswap.transfer(msg.sender, amount);\n        \n        emit RewardWithdrawal(msg.sender, rewardAmount);\n        emit StakingWithdrawal(msg.sender, amount);\n    }\n    \n    //Withdraw rewards\n    function withdrawRewardsOnly() external {\n        uint256 _rwdAmount = calculateReward(msg.sender);\n        require(_rwdAmount > 0, \"You do not have enough rewards\");\n        \n        // 1. User Accounting\n        Stake[] storage accountStakes = userStaking[msg.sender];\n        \n        // Redeem from most recent stake and go backwards in time.\n        uint256 rewardAmount = 0;\n        uint256 i = accountStakes.length;\n        while (i > 0) {\n            Stake storage userStake = accountStakes[i - 1];\n            uint256 stakeTimeSec;\n            \n            //check if current time is more than pool ending time\n            if (now > poolEndTime) {\n                stakeTimeSec = poolEndTime.sub(userStake.stakingTime);\n                if(userStake.lastWithdrawTime != 0){\n                    stakeTimeSec = poolEndTime.sub(userStake.lastWithdrawTime);\n                }\n            } else {\n                stakeTimeSec = now.sub(userStake.stakingTime);\n                if(userStake.lastWithdrawTime != 0){\n                    stakeTimeSec = now.sub(userStake.lastWithdrawTime);\n                }\n            }\n            \n            // fully redeem a past stake\n            rewardAmount = computeNewReward(rewardAmount, userStake.amount, stakeTimeSec);\n            userStake.lastWithdrawTime = now;\n            i--;\n        }\n        \n        //update user rewards info\n        userRewardInfo[msg.sender].totalWithdrawn = userRewardInfo[msg.sender].totalWithdrawn.add(rewardAmount);\n        userRewardInfo[msg.sender].lastWithdrawTime = now;\n        \n        //update total rewards withdrawn\n        rewardsWithdrawn = rewardsWithdrawn.add(rewardAmount);\n        \n        //transfer rewards\n        rewardToken.transfer(msg.sender, rewardAmount);\n        emit RewardWithdrawal(msg.sender, rewardAmount);\n    }\n    \n    //get staking details by user address\n    function getStakingAmount(address _userAddress) external constant returns (uint256 _stakedAmount) {\n        return userTotalStaking[_userAddress].totalStaking;\n    }\n    \n    //get total rewards collected by user\n    function getTotalRewardCollectedByUser(address userAddress) view external returns (uint256 _totalRewardCollected) \n    {\n        return userRewardInfo[userAddress].totalWithdrawn;\n    }\n    \n    //get total SWAP token staked in the contract\n    function getTotalStaked() external constant returns ( uint256 _totalStaked) {\n        return totalStaked;\n    }\n    \n    //get total rewards in the contract\n    function getTotalRewards() external constant returns ( uint256 _totalRewards) {\n        return totalRewards;\n    }\n    \n    //get pool details\n    function getPoolDetails() external view returns (address _baseToken, address _pairedToken, uint256 _totalRewards, uint256 _rewardsWithdrawn, uint256 _poolStartTime, uint256 _poolEndTime) {\n        return (address(tswap),address(rewardToken),totalRewards,rewardsWithdrawn,poolStartTime,poolEndTime);\n    }\n    \n    //get duration of pools\n    function getPoolDuration() external constant returns (uint256 _poolDuration) {\n        return poolDuration;\n    }\n\n    //set duration of pools by owner in seconds\n    function setPoolDuration(uint256 _poolDuration) external onlyOwner {\n        poolDuration = _poolDuration;\n        poolEndTime = poolStartTime + _poolDuration;\n        emit PoolDurationChange(_poolDuration);\n    }\n    \n    //get SWAP token address\n    function getSwapAddress() external constant returns (address _swapAddress) {\n        return address(tswap);\n    }\n    \n    //set tswap address\n    function setTswapAddress(address _address) external onlyOwner {\n        tswap = Ierc20(_address);\n    }\n    \n    //set reward token address\n    function setRewardTokenAddress(address _address) external onlyOwner {\n        rewardToken = Ierc20(_address);\n    }\n    \n}",
        "function": null,
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Hacken-TrustSwap-V1/code/StakingPool.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract BasicToken is ERC20Basic {\n  using SafeMath for uint256;\n\n  mapping(address => uint256) balances;\n\n  uint256 totalSupply_;\n\n  /**\n  * @dev Total number of tokens in existence\n  */\n  function totalSupply() public view returns (uint256) {\n    return totalSupply_;\n  }\n\n  /**\n  * @dev Transfer token for a specified address\n  * @param _to The address to transfer to.\n  * @param _value The amount to be transferred.\n  */\n  function transfer(address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    // SWC-135-Code With No Effects: L97\n    require(_value <= balances[msg.sender]);\n\n    balances[msg.sender] = balances[msg.sender].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    emit Transfer(msg.sender, _to, _value);\n    return true;\n  }\n\n  /**\n  * @dev Gets the balance of the specified address.\n  * @param _owner The address to query the the balance of.\n  * @return An uint256 representing the amount owned by the passed address.\n  */\n  function balanceOf(address _owner) public view returns (uint256) {\n    return balances[_owner];\n  }\n\n}",
        "function": null,
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Callisto_Network-Jarvis+ Token (JAR) Security Audit/code/JarvisPlusToken_flat.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract JarvisPlusToken is StandardToken, Ownable {\n\n    string public constant name = \"Jarvis+ Token\";\n    string public constant symbol = \"JAR\";\n    uint8 public constant decimals = 18;\n\n    // This is the initial amount of JAR.\n    uint256 private constant initialAmount = 600000000000000000000000000;\n\n    constructor() public {\n\n        // totalSupply_ = initialAmount;\n        // balances[owner].add(initialAmount);\n        // emit Transfer(address(0), owner, initialAmount);\n        owner = msg.sender;\n        if(totalSupply() ==  0) {\n            totalSupply_ = initialAmount;\n            owner = msg.sender;\n            balances[msg.sender] = initialAmount;\n            emit Transfer(address(0), msg.sender, initialAmount);\n        }\n    }\n}",
        "function": null,
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Callisto_Network-Jarvis+ Token (JAR) Security Audit/code/JarvisPlusToken_flat.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract StandardToken is ERC20, BasicToken {\n\n  mapping (address => mapping (address => uint256)) internal allowed;\n\n\n  /**\n   * @dev Transfer tokens from one address to another\n   * @param _from address The address which you want to send tokens from\n   * @param _to address The address which you want to transfer to\n   * @param _value uint256 the amount of tokens to be transferred\n   */\n  function transferFrom(\n    address _from,\n    address _to,\n    uint256 _value\n  )\n    public\n    returns (bool)\n  {\n    require(_to != address(0));\n    // SWC-135-Code With No Effects: L167 - L168\n    require(_value <= balances[_from]);\n    require(_value <= allowed[_from][msg.sender]);\n\n    balances[_from] = balances[_from].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n    emit Transfer(_from, _to, _value);\n    return true;\n  }\n\n  /**\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   * @param _spender The address which will spend the funds.\n   * @param _value The amount of tokens to be spent.\n   */\n  function approve(address _spender, uint256 _value) public returns (bool) {\n    allowed[msg.sender][_spender] = _value;\n    emit Approval(msg.sender, _spender, _value);\n    return true;\n  }\n\n  /**\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n   * @param _owner address The address which owns the funds.\n   * @param _spender address The address which will spend the funds.\n   * @return A uint256 specifying the amount of tokens still available for the spender.\n   */\n  function allowance(\n    address _owner,\n    address _spender\n   )\n    public\n    view\n    returns (uint256)\n  {\n    return allowed[_owner][_spender];\n  }\n\n  /**\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\n   * approve should be called when allowed[_spender] == 0. To increment\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _addedValue The amount of tokens to increase the allowance by.\n   */\n  function increaseApproval(\n    address _spender,\n    uint256 _addedValue\n  )\n    public\n    returns (bool)\n  {\n    allowed[msg.sender][_spender] = (\n      allowed[msg.sender][_spender].add(_addedValue));\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n  /**\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n   * approve should be called when allowed[_spender] == 0. To decrement\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n   */\n  function decreaseApproval(\n    address _spender,\n    uint256 _subtractedValue\n  )\n    public\n    returns (bool)\n  {\n    uint256 oldValue = allowed[msg.sender][_spender];\n    if (_subtractedValue > oldValue) {\n      allowed[msg.sender][_spender] = 0;\n    } else {\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n    }\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n}",
        "function": null,
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Callisto_Network-Jarvis+ Token (JAR) Security Audit/code/JarvisPlusToken_flat.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract BurnableToken is BasicToken {\n\n  event Burn(address indexed burner, uint256 value);\n\n  /**\n   * @dev Burns a specific amount of tokens.\n   * @param _value The amount of token to be burned.\n   */\n  function burn(uint256 _value) public {\n    _burn(msg.sender, _value);\n  }\n\n  function _burn(address _who, uint256 _value) internal {\n    require(_value <= balances[_who]);\n    // no need to require value <= totalSupply, since that would imply the\n    // sender's balance is greater than the totalSupply, which *should* be an assertion failure\n\n    balances[_who] = balances[_who].sub(_value);\n    totalSupply_ = totalSupply_.sub(_value);\n    emit Burn(_who, _value);\n    emit Transfer(_who, address(0), _value);\n  }\n}",
        "function": null,
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/QuillAudits-NomadLand Smart Contract/code/MainToken.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract FreezableMintableToken is FreezableToken, MintableToken {\n    /**\n     * @dev Mint the specified amount of token to the specified address and freeze it until the specified date.\n     *      Be careful, gas usage is not deterministic,\n     *      and depends on how many freezes _to address already has.\n     * @param _to Address to which token will be freeze.\n     * @param _amount Amount of token to mint and freeze.\n     * @param _until Release date, must be in future.\n     * @return A boolean that indicates if the operation was successful.\n     */\n    function mintAndFreeze(address _to, uint _amount, uint64 _until) public onlyOwner canMint returns (bool) {\n        totalSupply_ = totalSupply_.add(_amount);\n\n        bytes32 currentKey = toKey(_to, _until);\n        freezings[currentKey] = freezings[currentKey].add(_amount);\n        freezingBalance[_to] = freezingBalance[_to].add(_amount);\n\n        freeze(_to, _until);\n        emit Mint(_to, _amount);\n        emit Freezed(_to, _until, _amount);\n        emit Transfer(msg.sender, _to, _amount);\n        return true;\n    }\n}",
        "function": null,
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/QuillAudits-NomadLand Smart Contract/code/MainToken.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract FreezableToken is StandardToken {\n    // freezing chains\n    mapping (bytes32 => uint64) internal chains;\n    // freezing amounts for each chain\n    mapping (bytes32 => uint) internal freezings;\n    // total freezing balance per address\n    mapping (address => uint) internal freezingBalance;\n\n    event Freezed(address indexed to, uint64 release, uint amount);\n    event Released(address indexed owner, uint amount);\n\n    /**\n     * @dev Gets the balance of the specified address include freezing tokens.\n     * @param _owner The address to query the the balance of.\n     * @return An uint256 representing the amount owned by the passed address.\n     */\n    function balanceOf(address _owner) public view returns (uint256 balance) {\n        return super.balanceOf(_owner) + freezingBalance[_owner];\n    }\n//SWC-101-Integer Overflow and Underflow:L408\n    /**\n     * @dev Gets the balance of the specified address without freezing tokens.\n     * @param _owner The address to query the the balance of.\n     * @return An uint256 representing the amount owned by the passed address.\n     */\n    function actualBalanceOf(address _owner) public view returns (uint256 balance) {\n        return super.balanceOf(_owner);\n    }\n\n    function freezingBalanceOf(address _owner) public view returns (uint256 balance) {\n        return freezingBalance[_owner];\n    }\n\n    /**\n     * @dev gets freezing count\n     * @param _addr Address of freeze tokens owner.\n     */\n    function freezingCount(address _addr) public view returns (uint count) {\n        uint64 release = chains[toKey(_addr, 0)];\n        while (release != 0) {\n            count++;\n            release = chains[toKey(_addr, release)];\n        }\n    }\n\n    /**\n     * @dev gets freezing end date and freezing balance for the freezing portion specified by index.\n     * @param _addr Address of freeze tokens owner.\n     * @param _index Freezing portion index. It ordered by release date descending.\n     */\n    function getFreezing(address _addr, uint _index) public view returns (uint64 _release, uint _balance) {\n        for (uint i = 0; i < _index + 1; i++) {\n            _release = chains[toKey(_addr, _release)];\n            if (_release == 0) {\n                return;\n            }\n        }\n        _balance = freezings[toKey(_addr, _release)];\n    }\n\n    /**\n     * @dev freeze your tokens to the specified address.\n     *      Be careful, gas usage is not deterministic,\n     *      and depends on how many freezes _to address already has.\n     * @param _to Address to which token will be freeze.\n     * @param _amount Amount of token to freeze.\n     * @param _until Release date, must be in future.\n     */\n    function freezeTo(address _to, uint _amount, uint64 _until) public {\n        require(_to != address(0));\n        require(_amount <= balances[msg.sender]);\n\n        balances[msg.sender] = balances[msg.sender].sub(_amount);\n\n        bytes32 currentKey = toKey(_to, _until);\n        freezings[currentKey] = freezings[currentKey].add(_amount);\n        freezingBalance[_to] = freezingBalance[_to].add(_amount);\n\n        freeze(_to, _until);\n        emit Transfer(msg.sender, _to, _amount);\n        emit Freezed(_to, _until, _amount);\n    }\n\n    /**\n     * @dev release first available freezing tokens.\n     */\n    function releaseOnce() public {\n        bytes32 headKey = toKey(msg.sender, 0);\n        uint64 head = chains[headKey];\n        require(head != 0);\n        require(uint64(block.timestamp) > head);\n        bytes32 currentKey = toKey(msg.sender, head);\n//SWC-116-Block values as a proxy for time:L481\n        uint64 next = chains[currentKey];\n\n        uint amount = freezings[currentKey];\n        delete freezings[currentKey];\n\n        balances[msg.sender] = balances[msg.sender].add(amount);\n        freezingBalance[msg.sender] = freezingBalance[msg.sender].sub(amount);\n\n        if (next == 0) {\n            delete chains[headKey];\n        } else {\n            chains[headKey] = next;\n            delete chains[currentKey];\n        }\n        emit Released(msg.sender, amount);\n    }\n//SWC-116-Block values as a proxy for time:L509\n    /**\n     * @dev release all available for release freezing tokens. Gas usage is not deterministic!\n     * @return how many tokens was released\n     */\n    function releaseAll() public returns (uint tokens) {\n        uint release;\n        uint balance;\n        (release, balance) = getFreezing(msg.sender, 0);\n        while (release != 0 && block.timestamp > release) {\n            releaseOnce();\n            tokens += balance;\n            (release, balance) = getFreezing(msg.sender, 0);\n        }\n    }\n//SWC-101-Integer Overflow and Underflow:L511\n    function toKey(address _addr, uint _release) internal pure returns (bytes32 result) {\n        // WISH masc to increase entropy\n        result = 0x5749534800000000000000000000000000000000000000000000000000000000;\n        assembly {\n            result := or(result, mul(_addr, 0x10000000000000000))\n            result := or(result, and(_release, 0xffffffffffffffff))\n        }\n    }\n//SWC-116-Block values as a proxy for time:L526\n    function freeze(address _to, uint64 _until) internal {\n        require(_until > block.timestamp);\n        bytes32 key = toKey(_to, _until);\n        bytes32 parentKey = toKey(_to, uint64(0));\n        uint64 next = chains[parentKey];\n\n        if (next == 0) {\n            chains[parentKey] = _until;\n            return;\n        }\n\n        bytes32 nextKey = toKey(_to, next);\n        uint parent;\n\n        while (next != 0 && _until > next) {\n            parent = next;\n            parentKey = nextKey;\n\n            next = chains[nextKey];\n            nextKey = toKey(_to, next);\n        }\n\n        if (_until == next) {\n            return;\n        }\n\n        if (next != 0) {\n            chains[key] = next;\n        }\n\n        chains[parentKey] = _until;\n    }\n}",
        "function": null,
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/QuillAudits-NomadLand Smart Contract/code/MainToken.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract MainToken is Consts, FreezableMintableToken, BurnableToken, Pausable {\n    \n    event Initialized();\n    bool public initialized = false;\n\n    constructor() public {\n        init();\n        transferOwnership(TARGET_USER);\n    }\n    \n\n    function name() public pure returns (string _name) {\n        return TOKEN_NAME;\n    }\n\n    function symbol() public pure returns (string _symbol) {\n        return TOKEN_SYMBOL;\n    }\n\n    function decimals() public pure returns (uint8 _decimals) {\n        return TOKEN_DECIMALS_UINT8;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool _success) {\n        require(!paused);\n        return super.transferFrom(_from, _to, _value);\n    }\n\n    function transfer(address _to, uint256 _value) public returns (bool _success) {\n        require(!paused);\n        return super.transfer(_to, _value);\n    }\n\n    \n    function init() private {\n        require(!initialized);\n        initialized = true;\n\n        if (PAUSED) {\n            pause();\n        }\n\n        \n        address[1] memory addresses = [address(0x1e57f50778fc34dae64d7f16ad120193f8631464)];\n        uint[1] memory amounts = [uint(10000000000000000)];\n        uint64[1] memory freezes = [uint64(0)];\n\n        for (uint i = 0; i < addresses.length; i++) {\n            if (freezes[i] == 0) {\n                mint(addresses[i], amounts[i]);\n            } else {\n                mintAndFreeze(addresses[i], amounts[i], freezes[i]);\n            }\n        }\n        \n\n        if (!CONTINUE_MINTING) {\n            finishMinting();\n        }\n\n        emit Initialized();\n    }\n    \n}",
        "function": null,
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/QuillAudits-NomadLand Smart Contract/code/MainToken.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract MintableToken is StandardToken, Ownable {\n  event Mint(address indexed to, uint256 amount);\n  event MintFinished();\n\n  bool public mintingFinished = false;\n\n\n  modifier canMint() {\n    require(!mintingFinished);\n    _;\n  }\n\n  modifier hasMintPermission() {\n    require(msg.sender == owner);\n    _;\n  }\n\n  /**\n   * @dev Function to mint tokens\n   * @param _to The address that will receive the minted tokens.\n   * @param _amount The amount of tokens to mint.\n   * @return A boolean that indicates if the operation was successful.\n   */\n  function mint(\n    address _to,\n    uint256 _amount\n  )\n    hasMintPermission\n    canMint\n    public\n    returns (bool)\n  {\n    totalSupply_ = totalSupply_.add(_amount);\n    balances[_to] = balances[_to].add(_amount);\n    emit Mint(_to, _amount);\n    emit Transfer(address(0), _to, _amount);\n    return true;\n  }\n\n  /**\n   * @dev Function to stop minting new tokens.\n   * @return True if the operation was successful.\n   */\n  function finishMinting() onlyOwner canMint public returns (bool) {\n    mintingFinished = true;\n    emit MintFinished();\n    return true;\n  }\n}",
        "function": null,
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/QuillAudits-NomadLand Smart Contract/code/MainToken.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract StandardToken is BEP20, BasicToken {\n\n  mapping (address => mapping (address => uint256)) internal allowed;\n\n\n  /**\n   * @dev Transfer tokens from one address to another\n   * @param _from address The address which you want to send tokens from\n   * @param _to address The address which you want to transfer to\n   * @param _value uint256 the amount of tokens to be transferred\n   */\n  function transferFrom(\n    address _from,\n    address _to,\n    uint256 _value\n  )\n    public\n    returns (bool)\n  {\n    require(_to != address(0));\n    require(_value <= balances[_from]);\n    require(_value <= allowed[_from][msg.sender]);\n\n    balances[_from] = balances[_from].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n    emit Transfer(_from, _to, _value);\n    return true;\n  }\n\n  /**\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n   *\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n   * @param _spender The address which will spend the funds.\n   * @param _value The amount of tokens to be spent.\n   */\n  function approve(address _spender, uint256 _value) public returns (bool) {\n    allowed[msg.sender][_spender] = _value;\n    emit Approval(msg.sender, _spender, _value);\n    return true;\n  }\n\n  /**\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n   * @param _owner address The address which owns the funds.\n   * @param _spender address The address which will spend the funds.\n   * @return A uint256 specifying the amount of tokens still available for the spender.\n   */\n  function allowance(\n    address _owner,\n    address _spender\n   )\n    public\n    view\n    returns (uint256)\n  {\n    return allowed[_owner][_spender];\n  }\n\n  /**\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\n   *\n   * approve should be called when allowed[_spender] == 0. To increment\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _addedValue The amount of tokens to increase the allowance by.\n   */\n  function increaseApproval(\n    address _spender,\n    uint _addedValue\n  )\n    public\n    returns (bool)\n  {\n    allowed[msg.sender][_spender] = (\n      allowed[msg.sender][_spender].add(_addedValue));\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n  /**\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n   *\n   * approve should be called when allowed[_spender] == 0. To decrement\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n   */\n  function decreaseApproval(\n    address _spender,\n    uint _subtractedValue\n  )\n    public\n    returns (bool)\n  {\n    uint oldValue = allowed[msg.sender][_spender];\n    if (_subtractedValue > oldValue) {\n      allowed[msg.sender][_spender] = 0;\n    } else {\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n    }\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n}",
        "function": null,
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/QuillAudits-NomadLand Smart Contract/code/MainToken.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract BridgeValidators is IBridgeValidators, EternalStorage, Ownable {\n    using SafeMath for uint256;\n    event ValidatorAdded (address validator);\n    event ValidatorRemoved (address validator);\n    event RequiredSignaturesChanged (uint256 requiredSignatures);\n\n    function initialize(uint256 _requiredSignatures, address[] _initialValidators, address _owner)\n      public returns(bool)\n    {\n        require(!isInitialized());\n        require(_owner != address(0));\n        setOwner(_owner);\n        require(_requiredSignatures != 0);\n        require(_initialValidators.length >= _requiredSignatures);\n        for (uint256 i = 0; i < _initialValidators.length; i++) {\n            require(_initialValidators[i] != address(0));\n            assert(validators(_initialValidators[i]) != true);\n            setValidatorCount(validatorCount().add(1));\n            setValidator(_initialValidators[i], true);\n            emit ValidatorAdded(_initialValidators[i]);\n        }\n        //SWC-135-Code With No Effects: L31\n        require(validatorCount() >= _requiredSignatures);\n        uintStorage[keccak256(abi.encodePacked(\"requiredSignatures\"))] = _requiredSignatures;\n        setInitialize(true);\n        return isInitialized();\n    }\n\n    function addValidator(address _validator) external onlyOwner {\n        require(_validator != address(0));\n        require(!isValidator(_validator));\n        setValidatorCount(validatorCount().add(1));\n        setValidator(_validator, true);\n        emit ValidatorAdded(_validator);\n    }\n\n    function removeValidator(address _validator) external onlyOwner {\n        require(validatorCount() > requiredSignatures());\n        require(isValidator(_validator));\n        setValidator(_validator, false);\n        setValidatorCount(validatorCount().sub(1));\n        emit ValidatorRemoved(_validator);\n    }\n\n    function setRequiredSignatures(uint256 _requiredSignatures) external onlyOwner {\n        require(validatorCount() >= _requiredSignatures);\n        require(_requiredSignatures != 0);\n        uintStorage[keccak256(abi.encodePacked(\"requiredSignatures\"))] = _requiredSignatures;\n        emit RequiredSignaturesChanged(_requiredSignatures);\n    }\n\n    function requiredSignatures() public view returns(uint256) {\n        return uintStorage[keccak256(abi.encodePacked(\"requiredSignatures\"))];\n    }\n\n    function validatorCount() public view returns(uint256) {\n        return uintStorage[keccak256(abi.encodePacked(\"validatorCount\"))];\n    }\n\n    function validators(address _validator) public view returns(bool) {\n        return boolStorage[keccak256(abi.encodePacked(\"validators\", _validator))];\n    }\n\n    function isValidator(address _validator) public view returns(bool) {\n        return validators(_validator) == true;\n    }\n\n    function isInitialized() public view returns(bool) {\n        return boolStorage[keccak256(abi.encodePacked(\"isInitialized\"))];\n    }\n\n    function setValidatorCount(uint256 _validatorCount) private {\n        uintStorage[keccak256(abi.encodePacked(\"validatorCount\"))] = _validatorCount;\n    }\n\n    function setValidator(address _validator, bool _status) private {\n        boolStorage[keccak256(abi.encodePacked(\"validators\", _validator))] = _status;\n    }\n\n    function setInitialize(bool _status) private {\n        boolStorage[keccak256(abi.encodePacked(\"isInitialized\"))] = _status;\n    }\n}",
        "function": null,
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/PepperSec-POA-Network-Bridge/tokenbridge-contracts-2bf70c7e9fd42968aec2dc352017618907834401/contracts/upgradeable_contracts/BridgeValidators.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract BridgeValidators is IBridgeValidators, EternalStorage, Ownable {\n    using SafeMath for uint256;\n    event ValidatorAdded (address validator);\n    event ValidatorRemoved (address validator);\n    event RequiredSignaturesChanged (uint256 requiredSignatures);\n\n    function initialize(uint256 _requiredSignatures, address[] _initialValidators, address _owner)\n      public returns(bool)\n    {\n        require(!isInitialized());\n        require(_owner != address(0));\n        setOwner(_owner);\n        require(_requiredSignatures != 0);\n        require(_initialValidators.length >= _requiredSignatures);\n        for (uint256 i = 0; i < _initialValidators.length; i++) {\n            require(_initialValidators[i] != address(0));\n            assert(validators(_initialValidators[i]) != true);\n            setValidatorCount(validatorCount().add(1));\n            setValidator(_initialValidators[i], true);\n            emit ValidatorAdded(_initialValidators[i]);\n        }\n        //SWC-135-Code With No Effects: L31\n        require(validatorCount() >= _requiredSignatures);\n        uintStorage[keccak256(abi.encodePacked(\"requiredSignatures\"))] = _requiredSignatures;\n        setInitialize(true);\n        return isInitialized();\n    }\n\n    function addValidator(address _validator) external onlyOwner {\n        require(_validator != address(0));\n        require(!isValidator(_validator));\n        setValidatorCount(validatorCount().add(1));\n        setValidator(_validator, true);\n        emit ValidatorAdded(_validator);\n    }\n\n    function removeValidator(address _validator) external onlyOwner {\n        require(validatorCount() > requiredSignatures());\n        require(isValidator(_validator));\n        setValidator(_validator, false);\n        setValidatorCount(validatorCount().sub(1));\n        emit ValidatorRemoved(_validator);\n    }\n\n    function setRequiredSignatures(uint256 _requiredSignatures) external onlyOwner {\n        require(validatorCount() >= _requiredSignatures);\n        require(_requiredSignatures != 0);\n        uintStorage[keccak256(abi.encodePacked(\"requiredSignatures\"))] = _requiredSignatures;\n        emit RequiredSignaturesChanged(_requiredSignatures);\n    }\n\n    function requiredSignatures() public view returns(uint256) {\n        return uintStorage[keccak256(abi.encodePacked(\"requiredSignatures\"))];\n    }\n\n    function validatorCount() public view returns(uint256) {\n        return uintStorage[keccak256(abi.encodePacked(\"validatorCount\"))];\n    }\n\n    function validators(address _validator) public view returns(bool) {\n        return boolStorage[keccak256(abi.encodePacked(\"validators\", _validator))];\n    }\n\n    function isValidator(address _validator) public view returns(bool) {\n        return validators(_validator) == true;\n    }\n\n    function isInitialized() public view returns(bool) {\n        return boolStorage[keccak256(abi.encodePacked(\"isInitialized\"))];\n    }\n\n    function setValidatorCount(uint256 _validatorCount) private {\n        uintStorage[keccak256(abi.encodePacked(\"validatorCount\"))] = _validatorCount;\n    }\n\n    function setValidator(address _validator, bool _status) private {\n        boolStorage[keccak256(abi.encodePacked(\"validators\", _validator))] = _status;\n    }\n\n    function setInitialize(bool _status) private {\n        boolStorage[keccak256(abi.encodePacked(\"isInitialized\"))] = _status;\n    }\n}",
        "function": null,
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/PepperSec-POA-Network-Bridge/tokenbridge-contracts-2bf70c7e9fd42968aec2dc352017618907834401/contracts/upgradeable_contracts/BridgeValidators.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract Ownable is EternalStorage {\n    /**\n    * @dev Event to show ownership has been transferred\n    * @param previousOwner representing the address of the previous owner\n    * @param newOwner representing the address of the new owner\n    */\n    event OwnershipTransferred(address previousOwner, address newOwner);\n\n    /**\n    * @dev Throws if called by any account other than the owner.\n    */\n    modifier onlyOwner() {\n        require(msg.sender == owner());\n        _;\n    }\n\n    /**\n    * @dev Tells the address of the owner\n    * @return the address of the owner\n    */\n    function owner() public view returns (address) {\n        return addressStorage[keccak256(abi.encodePacked(\"owner\"))];\n    }\n\n    /**\n    * @dev Allows the current owner to transfer control of the contract to a newOwner.\n    * @param newOwner the address to transfer ownership to.\n    */\n    function transferOwnership(address newOwner) public onlyOwner {\n        require(newOwner != address(0));\n        setOwner(newOwner);\n    }\n\n    /**\n    * @dev Sets a new owner address\n    */\n    function setOwner(address newOwner) internal {\n        emit OwnershipTransferred(owner(), newOwner);\n        addressStorage[keccak256(abi.encodePacked(\"owner\"))] = newOwner;\n    }\n}",
        "function": null,
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/PepperSec-POA-Network-Bridge/tokenbridge-contracts-2bf70c7e9fd42968aec2dc352017618907834401/contracts/upgradeable_contracts/BridgeValidators.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract Ownable is EternalStorage {\n    /**\n    * @dev Event to show ownership has been transferred\n    * @param previousOwner representing the address of the previous owner\n    * @param newOwner representing the address of the new owner\n    */\n    event OwnershipTransferred(address previousOwner, address newOwner);\n\n    /**\n    * @dev Throws if called by any account other than the owner.\n    */\n    modifier onlyOwner() {\n        require(msg.sender == owner());\n        _;\n    }\n\n    /**\n    * @dev Tells the address of the owner\n    * @return the address of the owner\n    */\n    function owner() public view returns (address) {\n        return addressStorage[keccak256(abi.encodePacked(\"owner\"))];\n    }\n\n    /**\n    * @dev Allows the current owner to transfer control of the contract to a newOwner.\n    * @param newOwner the address to transfer ownership to.\n    */\n    function transferOwnership(address newOwner) public onlyOwner {\n        require(newOwner != address(0));\n        setOwner(newOwner);\n    }\n\n    /**\n    * @dev Sets a new owner address\n    */\n    function setOwner(address newOwner) internal {\n        emit OwnershipTransferred(owner(), newOwner);\n        addressStorage[keccak256(abi.encodePacked(\"owner\"))] = newOwner;\n    }\n}",
        "function": null,
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/PepperSec-POA-Network-Bridge/tokenbridge-contracts-2bf70c7e9fd42968aec2dc352017618907834401/contracts/upgradeable_contracts/BridgeValidators.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract MainContract is ApproverRole, ReentrancyGuard {\n    using SafeMath for uint256;\n    struct AccountData {\n        uint8 accountType; // 0 => Freelancer, 1 => Approver, 2 => Customer\n        address personWalletAddress;\n        uint256 personWorkCount;\n        uint256[] personPuan; // Rate x/5\n        address[] WorkAddresses; // All work addresses\n        string personInfoData;\n    }\n\n    mapping(address => AccountData) accounts;\n    mapping(address => bool) personsAddress;\n    mapping(address => uint8) public feeRates;\n    mapping(address => bool) public availableTokens;\n    mapping(address => uint256) public approverLockBalances;\n    mapping(address => bool) public isDeployedWorks;\n\n    uint8 public bnbFeeRate;\n    uint256 public remainingArgonToken;\n    uint256 public approverMinArgonLimit;\n    address[] public deployedWorks;\n    address[] public allPersons;\n    address public feeAddress;\n    address public argonTokenContractAddress;\n    bool public isActive;\n    IERC20 public argonToken; // ArgonToken Contract Address\n\n    modifier isInAccounts() {\n        require(personsAddress[msg.sender]);\n        _;\n    }\n\n    modifier mustApprover() {\n        require(personsAddress[msg.sender]);\n        AccountData storage data = accounts[msg.sender];\n        require(data.accountType == 1);\n        _;\n    }\n\n    modifier mustActive() {\n        require(isActive);\n        _;\n    }\n\n    constructor(\n        address _argonTokenAddress,\n        uint8 _bnbFeeRate,\n        address _feeAddress\n    ) public {\n        argonToken = IERC20(_argonTokenAddress);\n        bnbFeeRate = _bnbFeeRate;\n        remainingArgonToken = 5e6 ether;\n        approverMinArgonLimit = 20000 * 10**18;\n        feeAddress = _feeAddress;\n        argonTokenContractAddress = _argonTokenAddress;\n    }\n\n    function changeActive(bool _active) external onlyApprover {\n        isActive = _active;\n    }\n\n    function changeAvailableTokenFee(\n        address _tokenAddress,\n        uint8 _feeRate,\n        bool _available\n    ) external onlyApprover {\n        feeRates[_tokenAddress] = _feeRate;\n        availableTokens[_tokenAddress] = _available;\n    }\n\n    function changeSettings(\n        uint256 _approverMinArgonLimit,\n        uint8 _bnbFeeRate,\n        address _feeAddress\n    ) external onlyApprover {\n        approverMinArgonLimit = _approverMinArgonLimit;\n        bnbFeeRate = _bnbFeeRate;\n        feeAddress = _feeAddress;\n    }\n\n    function sendArgonTokenAdmin(address _address, uint256 amount)\n        external\n        onlyApprover\n        nonReentrant\n    {\n        argonToken.transfer(_address, amount);\n    }\n\n    function unLock() external mustApprover nonReentrant {\n        require(approverLockBalances[msg.sender] > 0);\n        AccountData storage data = accounts[msg.sender];\n        require(data.WorkAddresses.length == 0);\n        delete accounts[msg.sender];\n        personsAddress[msg.sender] = false;\n        for (uint256 x = 0; x < allPersons.length; x++) {\n            if (allPersons[x] == msg.sender) {\n                delete allPersons[x];\n            }\n        }\n        argonToken.transfer(msg.sender, approverLockBalances[msg.sender]);\n        approverLockBalances[msg.sender] = 0;\n    }\n\n    function getAllPersons() external view returns (address[]) {\n        return allPersons;\n    }\n\n    function addPerson(uint8 _accountType, string _personInfoData)\n        external\n        mustActive\n        nonReentrant\n    {\n        if (_accountType == 1) {\n            approverLockBalances[msg.sender] = approverLockBalances[msg.sender]\n                .safeAdd(approverMinArgonLimit);\n            require(\n                argonToken.transferFrom(\n                    msg.sender,\n                    address(this),\n                    approverMinArgonLimit\n                )\n            );\n        }\n        require(!personsAddress[msg.sender]);\n        AccountData memory newAccount =\n            AccountData({\n                accountType: _accountType,\n                personWalletAddress: msg.sender,\n                personWorkCount: 0,\n                personPuan: new uint256[](0),\n                WorkAddresses: new address[](0),\n                personInfoData: _personInfoData\n            });\n\n        accounts[msg.sender] = newAccount; // Adding a new account\n        allPersons.push(msg.sender); // Adding a new account\n        personsAddress[msg.sender] = true;\n    }\n\n    function getPersonInfoData(address _personAddress)\n        external\n        view\n        returns (\n            uint8,\n            uint256,\n            uint256[],\n            address[],\n            string\n        )\n    {\n        AccountData storage data = accounts[_personAddress];\n        return (\n            data.accountType,\n            data.personWorkCount,\n            data.personPuan,\n            data.WorkAddresses,\n            data.personInfoData\n        );\n    }\n\n    function getPersonAccountType(address _personAddress)\n        public\n        view\n        returns (uint8)\n    {\n        AccountData storage data = accounts[_personAddress];\n        return data.accountType;\n    }\n\n    function updatePerson(string _personInfoData)\n        external\n        isInAccounts\n        mustActive\n    {\n        AccountData storage data = accounts[msg.sender];\n        data.personInfoData = _personInfoData;\n    }\n\n    function createWork(\n        string _workTitle,\n        string _workCategory,\n        string _workDescription,\n        string _workAvarageBudget\n    ) external mustActive {\n        AccountData storage data = accounts[msg.sender];\n        require(getPersonAccountType(msg.sender) == 2);\n        address newWork =\n            new WorkContract(\n                _workTitle,\n                _workCategory,\n                _workDescription,\n                _workAvarageBudget,\n                msg.sender,\n                this\n            );\n        data.WorkAddresses.push(newWork); // Adding Person Works\n        deployedWorks.push(newWork); // Adding All Works\n        isDeployedWorks[newWork] = true;\n    }\n\n    function getWorks() external view returns (address[]) {\n        return deployedWorks;\n    }\n\n    function setPuan(uint256 _puan, address _freelancerAddress) external {\n        require(isDeployedWorks[msg.sender]);\n        AccountData storage data = accounts[_freelancerAddress];\n        data.personPuan.push(_puan);\n    }\n\n    function setApproverWorkAddress(\n        address _workAddress,\n        address _approveraddress\n    ) external {\n        require(isDeployedWorks[msg.sender]);\n\n        AccountData storage data = accounts[_approveraddress];\n        data.WorkAddresses.push(_workAddress);\n    }\n\n    function _removeApproverWorkAddressArray(\n        uint256 index,\n        address _approveraddress\n    ) private {\n        AccountData storage data = accounts[_approveraddress];\n\n        if (index >= data.WorkAddresses.length) return;\n\n        for (uint256 i = index; i < data.WorkAddresses.length - 1; i++) {\n            data.WorkAddresses[i] = data.WorkAddresses[i + 1];\n        }\n        delete data.WorkAddresses[data.WorkAddresses.length - 1];\n        data.WorkAddresses.length--;\n    }\n\n    function deleteApproverWorkAddress(\n        address _workAddress,\n        address _approveraddress\n    ) external {\n        require(isDeployedWorks[msg.sender]);\n\n        AccountData storage data = accounts[_approveraddress];\n        for (uint256 i = 0; i < data.WorkAddresses.length; i++) {\n            if (data.WorkAddresses[i] == _workAddress) {\n                _removeApproverWorkAddressArray(i, _approveraddress);\n            }\n        }\n    }\n\n    function checkDeadline(address _workAddress)\n        external\n        view\n        returns (bool, address)\n    {\n        WorkContract deployedWork;\n        deployedWork = WorkContract(_workAddress);\n        if (now > deployedWork.deadLine() && deployedWork.deadLine() != 0) {\n            return (true, _workAddress);\n        } else {\n            return (false, _workAddress);\n        }\n    }\n\n    function sendApproverArgonCoin(address _approveraddress) external {\n        require(isDeployedWorks[msg.sender]);\n\n        uint256 amount = (remainingArgonToken.safeMul(3)).safeDiv(1e5);\n        argonToken.transfer(_approveraddress, amount);\n        remainingArgonToken = remainingArgonToken.safeSub(amount);\n    }\n}",
        "function": null,
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Hacken-Argon Foundation/platform-contracts-8996d21499ede3f2eb36320ded9563f5467a0fa6/ArgonFreelancers.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract MainContract is ApproverRole, ReentrancyGuard {\n    using SafeMath for uint256;\n    struct AccountData {\n        uint8 accountType; // 0 => Freelancer, 1 => Approver, 2 => Customer\n        address personWalletAddress;\n        uint256 personWorkCount;\n        uint256[] personPuan; // Rate x/5\n        address[] WorkAddresses; // All work addresses\n        string personInfoData;\n    }\n\n    mapping(address => AccountData) accounts;\n    mapping(address => bool) personsAddress;\n    mapping(address => uint8) public feeRates;\n    mapping(address => bool) public availableTokens;\n    mapping(address => uint256) public approverLockBalances;\n    mapping(address => bool) public isDeployedWorks;\n\n    uint8 public bnbFeeRate;\n    uint256 public remainingArgonToken;\n    uint256 public approverMinArgonLimit;\n    address[] public deployedWorks;\n    address[] public allPersons;\n    address public feeAddress;\n    address public argonTokenContractAddress;\n    bool public isActive;\n    IERC20 public argonToken; // ArgonToken Contract Address\n\n    modifier isInAccounts() {\n        require(personsAddress[msg.sender]);\n        _;\n    }\n\n    modifier mustApprover() {\n        require(personsAddress[msg.sender]);\n        AccountData storage data = accounts[msg.sender];\n        require(data.accountType == 1);\n        _;\n    }\n\n    modifier mustActive() {\n        require(isActive);\n        _;\n    }\n\n    constructor(\n        address _argonTokenAddress,\n        uint8 _bnbFeeRate,\n        address _feeAddress\n    ) public {\n        argonToken = IERC20(_argonTokenAddress);\n        bnbFeeRate = _bnbFeeRate;\n        remainingArgonToken = 5e6 ether;\n        approverMinArgonLimit = 20000 * 10**18;\n        feeAddress = _feeAddress;\n        argonTokenContractAddress = _argonTokenAddress;\n    }\n\n    function changeActive(bool _active) external onlyApprover {\n        isActive = _active;\n    }\n\n    function changeAvailableTokenFee(\n        address _tokenAddress,\n        uint8 _feeRate,\n        bool _available\n    ) external onlyApprover {\n        feeRates[_tokenAddress] = _feeRate;\n        availableTokens[_tokenAddress] = _available;\n    }\n\n    function changeSettings(\n        uint256 _approverMinArgonLimit,\n        uint8 _bnbFeeRate,\n        address _feeAddress\n    ) external onlyApprover {\n        approverMinArgonLimit = _approverMinArgonLimit;\n        bnbFeeRate = _bnbFeeRate;\n        feeAddress = _feeAddress;\n    }\n\n    function sendArgonTokenAdmin(address _address, uint256 amount)\n        external\n        onlyApprover\n        nonReentrant\n    {\n        argonToken.transfer(_address, amount);\n    }\n\n    function unLock() external mustApprover nonReentrant {\n        require(approverLockBalances[msg.sender] > 0);\n        AccountData storage data = accounts[msg.sender];\n        require(data.WorkAddresses.length == 0);\n        delete accounts[msg.sender];\n        personsAddress[msg.sender] = false;\n        for (uint256 x = 0; x < allPersons.length; x++) {\n            if (allPersons[x] == msg.sender) {\n                delete allPersons[x];\n            }\n        }\n        argonToken.transfer(msg.sender, approverLockBalances[msg.sender]);\n        approverLockBalances[msg.sender] = 0;\n    }\n\n    function getAllPersons() external view returns (address[]) {\n        return allPersons;\n    }\n\n    function addPerson(uint8 _accountType, string _personInfoData)\n        external\n        mustActive\n        nonReentrant\n    {\n        if (_accountType == 1) {\n            approverLockBalances[msg.sender] = approverLockBalances[msg.sender]\n                .safeAdd(approverMinArgonLimit);\n            require(\n                argonToken.transferFrom(\n                    msg.sender,\n                    address(this),\n                    approverMinArgonLimit\n                )\n            );\n        }\n        require(!personsAddress[msg.sender]);\n        AccountData memory newAccount =\n            AccountData({\n                accountType: _accountType,\n                personWalletAddress: msg.sender,\n                personWorkCount: 0,\n                personPuan: new uint256[](0),\n                WorkAddresses: new address[](0),\n                personInfoData: _personInfoData\n            });\n\n        accounts[msg.sender] = newAccount; // Adding a new account\n        allPersons.push(msg.sender); // Adding a new account\n        personsAddress[msg.sender] = true;\n    }\n\n    function getPersonInfoData(address _personAddress)\n        external\n        view\n        returns (\n            uint8,\n            uint256,\n            uint256[],\n            address[],\n            string\n        )\n    {\n        AccountData storage data = accounts[_personAddress];\n        return (\n            data.accountType,\n            data.personWorkCount,\n            data.personPuan,\n            data.WorkAddresses,\n            data.personInfoData\n        );\n    }\n\n    function getPersonAccountType(address _personAddress)\n        public\n        view\n        returns (uint8)\n    {\n        AccountData storage data = accounts[_personAddress];\n        return data.accountType;\n    }\n\n    function updatePerson(string _personInfoData)\n        external\n        isInAccounts\n        mustActive\n    {\n        AccountData storage data = accounts[msg.sender];\n        data.personInfoData = _personInfoData;\n    }\n\n    function createWork(\n        string _workTitle,\n        string _workCategory,\n        string _workDescription,\n        string _workAvarageBudget\n    ) external mustActive {\n        AccountData storage data = accounts[msg.sender];\n        require(getPersonAccountType(msg.sender) == 2);\n        address newWork =\n            new WorkContract(\n                _workTitle,\n                _workCategory,\n                _workDescription,\n                _workAvarageBudget,\n                msg.sender,\n                this\n            );\n        data.WorkAddresses.push(newWork); // Adding Person Works\n        deployedWorks.push(newWork); // Adding All Works\n        isDeployedWorks[newWork] = true;\n    }\n\n    function getWorks() external view returns (address[]) {\n        return deployedWorks;\n    }\n\n    function setPuan(uint256 _puan, address _freelancerAddress) external {\n        require(isDeployedWorks[msg.sender]);\n        AccountData storage data = accounts[_freelancerAddress];\n        data.personPuan.push(_puan);\n    }\n\n    function setApproverWorkAddress(\n        address _workAddress,\n        address _approveraddress\n    ) external {\n        require(isDeployedWorks[msg.sender]);\n\n        AccountData storage data = accounts[_approveraddress];\n        data.WorkAddresses.push(_workAddress);\n    }\n\n    function _removeApproverWorkAddressArray(\n        uint256 index,\n        address _approveraddress\n    ) private {\n        AccountData storage data = accounts[_approveraddress];\n\n        if (index >= data.WorkAddresses.length) return;\n\n        for (uint256 i = index; i < data.WorkAddresses.length - 1; i++) {\n            data.WorkAddresses[i] = data.WorkAddresses[i + 1];\n        }\n        delete data.WorkAddresses[data.WorkAddresses.length - 1];\n        data.WorkAddresses.length--;\n    }\n\n    function deleteApproverWorkAddress(\n        address _workAddress,\n        address _approveraddress\n    ) external {\n        require(isDeployedWorks[msg.sender]);\n\n        AccountData storage data = accounts[_approveraddress];\n        for (uint256 i = 0; i < data.WorkAddresses.length; i++) {\n            if (data.WorkAddresses[i] == _workAddress) {\n                _removeApproverWorkAddressArray(i, _approveraddress);\n            }\n        }\n    }\n\n    function checkDeadline(address _workAddress)\n        external\n        view\n        returns (bool, address)\n    {\n        WorkContract deployedWork;\n        deployedWork = WorkContract(_workAddress);\n        if (now > deployedWork.deadLine() && deployedWork.deadLine() != 0) {\n            return (true, _workAddress);\n        } else {\n            return (false, _workAddress);\n        }\n    }\n\n    function sendApproverArgonCoin(address _approveraddress) external {\n        require(isDeployedWorks[msg.sender]);\n\n        uint256 amount = (remainingArgonToken.safeMul(3)).safeDiv(1e5);\n        argonToken.transfer(_approveraddress, amount);\n        remainingArgonToken = remainingArgonToken.safeSub(amount);\n    }\n}",
        "function": null,
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Hacken-Argon Foundation/platform-contracts-8996d21499ede3f2eb36320ded9563f5467a0fa6/ArgonFreelancers.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract WorkContract is ApproverRole, ReentrancyGuard {\n    using SafeMath for uint256;\n\n    MainContract deployedFromContract;\n    struct Offer {\n        uint256 offerPrice;\n        address freelancerAddress;\n        string description;\n        string title;\n        uint256 deadline;\n        address offerTokenContract;\n        bool tokenContractIsBNB;\n        bool ArgonShield;\n    }\n\n    string public workTitle;\n    string public workCategory;\n    string public workDescription;\n    string public workAvarageBudget;\n    string public workFilesLink;\n    string public employerCancelDescription;\n    string public approverReport;\n    string public employerRemark;\n\n    uint256 public workCreateTime;\n    uint256 public deadLine;\n    uint256 public freelancerSendFilesDate;\n    uint256 public workStartDate;\n    uint256 public workEndDate;\n    uint256 public approverConfirmStatus;\n    uint256 public approverStartDate;\n    uint256 public workPrice;\n    uint256 public workOfferCount;\n\n    bool public workStatus;\n    bool public isBNB;\n    bool public argonShield;\n    bool public freelancerSendFiles;\n    bool public employerReceiveFiles;\n\n    address public employerAddress;\n    address public approverAddress;\n    address public tokenContractAddress;\n    address public freelancerAddress;\n    address[] public allFreelancerAddress;\n\n    IERC20 public argonToken; // ***ArgonToken Contract***\n    mapping(address => Offer) offers;\n\n    modifier mustActive() {\n        require(deployedFromContract.isActive());\n        _;\n    }\n\n    modifier requireForApprover() {\n        require(approverConfirmStatus == 0 && approverStartDate > 0);\n        require(argonShield);\n        _;\n    }\n\n    constructor(\n        string _workTitle,\n        string _workCategory,\n        string _workDescription,\n        string _workAvarageBudget,\n        address _employerAddress,\n        address _t\n    ) public {\n        require(MainContract(_t).isActive());\n        require(MainContract(_t).getPersonAccountType(_employerAddress) == 2);\n        workTitle = _workTitle;\n        workCategory = _workCategory;\n        workDescription = _workDescription;\n        workCreateTime = now;\n        workAvarageBudget = _workAvarageBudget;\n        workOfferCount = 0;\n        workStatus = false;\n        employerAddress = _employerAddress;\n        freelancerSendFiles = false;\n        employerReceiveFiles = false;\n        deployedFromContract = MainContract(_t);\n        argonToken = IERC20(MainContract(_t).argonTokenContractAddress());\n    }\n\n    function getAllFreelancers() external view returns (address[]) {\n        return allFreelancerAddress;\n    }\n\n    function updateWork(\n        string _workTitle,\n        string _workCategory,\n        string _workDescription,\n        string _workAvarageBudget,\n        address _workaddress\n    ) external mustActive {\n        require(this == _workaddress);\n        require(msg.sender == employerAddress);\n        workTitle = _workTitle;\n        workCategory = _workCategory;\n        workDescription = _workDescription;\n        workAvarageBudget = _workAvarageBudget;\n    }\n\n    function createOffer(\n        uint256 _offerPrice,\n        string _description,\n        uint256 _deadline,\n        string _title,\n        address _tokenContract,\n        bool _isBNB,\n        bool _ArgonShield\n    ) external mustActive {\n        require(deployedFromContract.getPersonAccountType(msg.sender) == 0);\n        if (!_isBNB) {\n            require(_tokenContract != address(0));\n            require(deployedFromContract.availableTokens(_tokenContract));\n        }\n        Offer memory newOffer =\n            Offer({\n                offerPrice: _offerPrice,\n                freelancerAddress: msg.sender,\n                description: _description,\n                deadline: _deadline,\n                title: _title,\n                offerTokenContract: _tokenContract,\n                tokenContractIsBNB: _isBNB,\n                ArgonShield: _ArgonShield\n            });\n        offers[msg.sender] = newOffer;\n        allFreelancerAddress.push(msg.sender);\n        workOfferCount++;\n    }\n\n    function deleteOffer() external mustActive {\n        delete offers[msg.sender];\n        workOfferCount--;\n    }\n\n    function updateOffer(\n        uint256 _offerPrice,\n        string _description,\n        string _title,\n        bool _ArgonShield\n    ) external mustActive {\n        Offer storage data = offers[msg.sender];\n        data.offerPrice = _offerPrice;\n        data.description = _description;\n        data.title = _title;\n        data.ArgonShield = _ArgonShield;\n    }\n\n    function getOfferData(address _freelancerAddress)\n        external\n        view\n        returns (\n            uint256,\n            address,\n            string,\n            string,\n            uint256,\n            address,\n            bool,\n            bool\n        )\n    {\n        Offer storage data = offers[_freelancerAddress];\n        return (\n            data.offerPrice,\n            data.freelancerAddress,\n            data.description,\n            data.title,\n            data.deadline,\n            data.offerTokenContract,\n            data.tokenContractIsBNB,\n            data.ArgonShield\n        );\n    }\n\n    function selectOffer(address _freelancerAddress, address _approveraddress)\n        external\n        payable\n        mustActive\n    {\n        require(msg.sender == employerAddress);\n        Offer storage data = offers[_freelancerAddress];\n        require(data.tokenContractIsBNB);\n        if (data.ArgonShield) {\n            require(\n                deployedFromContract.approverLockBalances(_approveraddress) >=\n                    deployedFromContract.approverMinArgonLimit()\n            );\n            approverAddress = _approveraddress;\n            deployedFromContract.setApproverWorkAddress(this, _approveraddress);\n        }\n\n        require(msg.value >= data.offerPrice);\n        freelancerAddress = data.freelancerAddress;\n        workStatus = true;\n        workStartDate = now;\n        deadLine = data.deadline;\n        workPrice = data.offerPrice;\n        isBNB = true;\n        argonShield = data.ArgonShield;\n    }\n\n    function selectOfferWithToken(\n        address _freelancerAddress,\n        address _approveraddress\n    ) external mustActive {\n        require(msg.sender == employerAddress);\n        Offer storage data = offers[_freelancerAddress];\n        require(!data.tokenContractIsBNB);\n        if (data.ArgonShield) {\n            require(\n                deployedFromContract.approverLockBalances(_approveraddress) >=\n                    deployedFromContract.approverMinArgonLimit()\n            );\n\n            approverAddress = _approveraddress;\n            deployedFromContract.setApproverWorkAddress(this, _approveraddress);\n        }\n        freelancerAddress = data.freelancerAddress;\n        workStatus = true;\n        workStartDate = now;\n        deadLine = data.deadline;\n        workPrice = data.offerPrice;\n        isBNB = false;\n        tokenContractAddress = data.offerTokenContract;\n        require(\n            IERC20(data.offerTokenContract).transferFrom(\n                msg.sender,\n                address(this),\n                data.offerPrice\n            )\n        );\n        argonShield = data.ArgonShield;\n    }\n\n    function freelancerSendFile(string _workFilesLink) external {\n        require(msg.sender == freelancerAddress);\n        require(!freelancerSendFiles);\n        freelancerSendFiles = true;\n        workFilesLink = _workFilesLink;\n        freelancerSendFilesDate = now;\n    }\n\n    function _payFreelancer() private {\n        uint256 amount;\n\n        if (isBNB) {\n            amount = workPrice.safeSub(\n                (workPrice.safeMul(deployedFromContract.bnbFeeRate())).safeDiv(\n                    1e6\n                )\n            );\n            freelancerAddress.transfer(amount);\n            deployedFromContract.feeAddress().transfer(\n                workPrice.safeSub(amount)\n            );\n        } else {\n            amount = workPrice.safeSub(\n                (\n                    workPrice.safeMul(\n                        deployedFromContract.feeRates(tokenContractAddress)\n                    )\n                )\n                    .safeDiv(1e6)\n            );\n\n            IERC20(tokenContractAddress).transfer(freelancerAddress, amount);\n            IERC20(tokenContractAddress).transfer(\n                deployedFromContract.feeAddress(),\n                workPrice.safeSub(amount)\n            );\n        }\n    }\n\n    function _payEmployer() private {\n        if (isBNB) {\n            employerAddress.transfer(workPrice);\n        } else {\n            IERC20(tokenContractAddress).transfer(employerAddress, workPrice);\n        }\n    }\n\n    function employerReceiveFile(uint256 _puan, string _remark)\n        external\n        nonReentrant\n    {\n        require(msg.sender == employerAddress);\n        require(freelancerSendFiles, \"freelancer must be sent files\");\n        require(!employerReceiveFiles);\n        _payFreelancer();\n        deployedFromContract.setPuan(_puan, freelancerAddress);\n        employerRemark = _remark;\n        employerReceiveFiles = true;\n        workEndDate = now;\n    }\n\n    function employerCancel(string _depscription) external {\n        require(msg.sender == employerAddress);\n        require(argonShield);\n        require(approverStartDate == 0);\n        require(!employerReceiveFiles);\n        require(freelancerSendFiles, \"freelancer must be sent files\");\n\n        approverConfirmStatus = 0;\n        employerCancelDescription = _depscription;\n        approverStartDate = now;\n    }\n\n    function confirmApprover(string _description)\n        external\n        nonReentrant\n        requireForApprover\n    {\n        if (now > approverStartDate.safeAdd(5 days)) {\n            require(isApprover(msg.sender));\n        } else {\n            require(msg.sender == approverAddress);\n\n            deployedFromContract.deleteApproverWorkAddress(\n                this,\n                approverAddress\n            );\n\n            deployedFromContract.sendApproverArgonCoin(approverAddress);\n        }\n\n        approverConfirmStatus = 1;\n        _payFreelancer();\n        approverReport = _description;\n        workEndDate = now;\n    }\n\n    function cancelApprover(string _description)\n        external\n        nonReentrant\n        requireForApprover\n    {\n        if (now > approverStartDate.safeAdd(5 days)) {\n            require(isApprover(msg.sender));\n        } else {\n            require(msg.sender == approverAddress);\n            deployedFromContract.deleteApproverWorkAddress(\n                this,\n                approverAddress\n            );\n            deployedFromContract.sendApproverArgonCoin(approverAddress);\n        }\n        approverConfirmStatus = 2;\n        approverReport = _description;\n        _payEmployer();\n    }\n\n    function autoConfirm() external nonReentrant {\n        require(now > freelancerSendFilesDate.safeAdd(5 days));\n        require(!employerReceiveFiles);\n        require(freelancerSendFiles);\n        _payFreelancer();\n        deployedFromContract.setPuan(5, freelancerAddress);\n        employerRemark = \"Auto Confirmed By Smart Contract\";\n        workEndDate = now;\n    }\n\n    function sendDeadline() external nonReentrant {\n        require(now > deadLine);\n        require(!freelancerSendFiles);\n        _payEmployer();\n    }\n}",
        "function": null,
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Hacken-Argon Foundation/platform-contracts-8996d21499ede3f2eb36320ded9563f5467a0fa6/ArgonFreelancers.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract WorkContract is ApproverRole, ReentrancyGuard {\n    using SafeMath for uint256;\n\n    MainContract deployedFromContract;\n    struct Offer {\n        uint256 offerPrice;\n        address freelancerAddress;\n        string description;\n        string title;\n        uint256 deadline;\n        address offerTokenContract;\n        bool tokenContractIsBNB;\n        bool ArgonShield;\n    }\n\n    string public workTitle;\n    string public workCategory;\n    string public workDescription;\n    string public workAvarageBudget;\n    string public workFilesLink;\n    string public employerCancelDescription;\n    string public approverReport;\n    string public employerRemark;\n\n    uint256 public workCreateTime;\n    uint256 public deadLine;\n    uint256 public freelancerSendFilesDate;\n    uint256 public workStartDate;\n    uint256 public workEndDate;\n    uint256 public approverConfirmStatus;\n    uint256 public approverStartDate;\n    uint256 public workPrice;\n    uint256 public workOfferCount;\n\n    bool public workStatus;\n    bool public isBNB;\n    bool public argonShield;\n    bool public freelancerSendFiles;\n    bool public employerReceiveFiles;\n\n    address public employerAddress;\n    address public approverAddress;\n    address public tokenContractAddress;\n    address public freelancerAddress;\n    address[] public allFreelancerAddress;\n\n    IERC20 public argonToken; // ***ArgonToken Contract***\n    mapping(address => Offer) offers;\n\n    modifier mustActive() {\n        require(deployedFromContract.isActive());\n        _;\n    }\n\n    modifier requireForApprover() {\n        require(approverConfirmStatus == 0 && approverStartDate > 0);\n        require(argonShield);\n        _;\n    }\n\n    constructor(\n        string _workTitle,\n        string _workCategory,\n        string _workDescription,\n        string _workAvarageBudget,\n        address _employerAddress,\n        address _t\n    ) public {\n        require(MainContract(_t).isActive());\n        require(MainContract(_t).getPersonAccountType(_employerAddress) == 2);\n        workTitle = _workTitle;\n        workCategory = _workCategory;\n        workDescription = _workDescription;\n        workCreateTime = now;\n        workAvarageBudget = _workAvarageBudget;\n        workOfferCount = 0;\n        workStatus = false;\n        employerAddress = _employerAddress;\n        freelancerSendFiles = false;\n        employerReceiveFiles = false;\n        deployedFromContract = MainContract(_t);\n        argonToken = IERC20(MainContract(_t).argonTokenContractAddress());\n    }\n\n    function getAllFreelancers() external view returns (address[]) {\n        return allFreelancerAddress;\n    }\n\n    function updateWork(\n        string _workTitle,\n        string _workCategory,\n        string _workDescription,\n        string _workAvarageBudget,\n        address _workaddress\n    ) external mustActive {\n        require(this == _workaddress);\n        require(msg.sender == employerAddress);\n        workTitle = _workTitle;\n        workCategory = _workCategory;\n        workDescription = _workDescription;\n        workAvarageBudget = _workAvarageBudget;\n    }\n\n    function createOffer(\n        uint256 _offerPrice,\n        string _description,\n        uint256 _deadline,\n        string _title,\n        address _tokenContract,\n        bool _isBNB,\n        bool _ArgonShield\n    ) external mustActive {\n        require(deployedFromContract.getPersonAccountType(msg.sender) == 0);\n        if (!_isBNB) {\n            require(_tokenContract != address(0));\n            require(deployedFromContract.availableTokens(_tokenContract));\n        }\n        Offer memory newOffer =\n            Offer({\n                offerPrice: _offerPrice,\n                freelancerAddress: msg.sender,\n                description: _description,\n                deadline: _deadline,\n                title: _title,\n                offerTokenContract: _tokenContract,\n                tokenContractIsBNB: _isBNB,\n                ArgonShield: _ArgonShield\n            });\n        offers[msg.sender] = newOffer;\n        allFreelancerAddress.push(msg.sender);\n        workOfferCount++;\n    }\n\n    function deleteOffer() external mustActive {\n        delete offers[msg.sender];\n        workOfferCount--;\n    }\n\n    function updateOffer(\n        uint256 _offerPrice,\n        string _description,\n        string _title,\n        bool _ArgonShield\n    ) external mustActive {\n        Offer storage data = offers[msg.sender];\n        data.offerPrice = _offerPrice;\n        data.description = _description;\n        data.title = _title;\n        data.ArgonShield = _ArgonShield;\n    }\n\n    function getOfferData(address _freelancerAddress)\n        external\n        view\n        returns (\n            uint256,\n            address,\n            string,\n            string,\n            uint256,\n            address,\n            bool,\n            bool\n        )\n    {\n        Offer storage data = offers[_freelancerAddress];\n        return (\n            data.offerPrice,\n            data.freelancerAddress,\n            data.description,\n            data.title,\n            data.deadline,\n            data.offerTokenContract,\n            data.tokenContractIsBNB,\n            data.ArgonShield\n        );\n    }\n\n    function selectOffer(address _freelancerAddress, address _approveraddress)\n        external\n        payable\n        mustActive\n    {\n        require(msg.sender == employerAddress);\n        Offer storage data = offers[_freelancerAddress];\n        require(data.tokenContractIsBNB);\n        if (data.ArgonShield) {\n            require(\n                deployedFromContract.approverLockBalances(_approveraddress) >=\n                    deployedFromContract.approverMinArgonLimit()\n            );\n            approverAddress = _approveraddress;\n            deployedFromContract.setApproverWorkAddress(this, _approveraddress);\n        }\n\n        require(msg.value >= data.offerPrice);\n        freelancerAddress = data.freelancerAddress;\n        workStatus = true;\n        workStartDate = now;\n        deadLine = data.deadline;\n        workPrice = data.offerPrice;\n        isBNB = true;\n        argonShield = data.ArgonShield;\n    }\n\n    function selectOfferWithToken(\n        address _freelancerAddress,\n        address _approveraddress\n    ) external mustActive {\n        require(msg.sender == employerAddress);\n        Offer storage data = offers[_freelancerAddress];\n        require(!data.tokenContractIsBNB);\n        if (data.ArgonShield) {\n            require(\n                deployedFromContract.approverLockBalances(_approveraddress) >=\n                    deployedFromContract.approverMinArgonLimit()\n            );\n\n            approverAddress = _approveraddress;\n            deployedFromContract.setApproverWorkAddress(this, _approveraddress);\n        }\n        freelancerAddress = data.freelancerAddress;\n        workStatus = true;\n        workStartDate = now;\n        deadLine = data.deadline;\n        workPrice = data.offerPrice;\n        isBNB = false;\n        tokenContractAddress = data.offerTokenContract;\n        require(\n            IERC20(data.offerTokenContract).transferFrom(\n                msg.sender,\n                address(this),\n                data.offerPrice\n            )\n        );\n        argonShield = data.ArgonShield;\n    }\n\n    function freelancerSendFile(string _workFilesLink) external {\n        require(msg.sender == freelancerAddress);\n        require(!freelancerSendFiles);\n        freelancerSendFiles = true;\n        workFilesLink = _workFilesLink;\n        freelancerSendFilesDate = now;\n    }\n\n    function _payFreelancer() private {\n        uint256 amount;\n\n        if (isBNB) {\n            amount = workPrice.safeSub(\n                (workPrice.safeMul(deployedFromContract.bnbFeeRate())).safeDiv(\n                    1e6\n                )\n            );\n            freelancerAddress.transfer(amount);\n            deployedFromContract.feeAddress().transfer(\n                workPrice.safeSub(amount)\n            );\n        } else {\n            amount = workPrice.safeSub(\n                (\n                    workPrice.safeMul(\n                        deployedFromContract.feeRates(tokenContractAddress)\n                    )\n                )\n                    .safeDiv(1e6)\n            );\n\n            IERC20(tokenContractAddress).transfer(freelancerAddress, amount);\n            IERC20(tokenContractAddress).transfer(\n                deployedFromContract.feeAddress(),\n                workPrice.safeSub(amount)\n            );\n        }\n    }\n\n    function _payEmployer() private {\n        if (isBNB) {\n            employerAddress.transfer(workPrice);\n        } else {\n            IERC20(tokenContractAddress).transfer(employerAddress, workPrice);\n        }\n    }\n\n    function employerReceiveFile(uint256 _puan, string _remark)\n        external\n        nonReentrant\n    {\n        require(msg.sender == employerAddress);\n        require(freelancerSendFiles, \"freelancer must be sent files\");\n        require(!employerReceiveFiles);\n        _payFreelancer();\n        deployedFromContract.setPuan(_puan, freelancerAddress);\n        employerRemark = _remark;\n        employerReceiveFiles = true;\n        workEndDate = now;\n    }\n\n    function employerCancel(string _depscription) external {\n        require(msg.sender == employerAddress);\n        require(argonShield);\n        require(approverStartDate == 0);\n        require(!employerReceiveFiles);\n        require(freelancerSendFiles, \"freelancer must be sent files\");\n\n        approverConfirmStatus = 0;\n        employerCancelDescription = _depscription;\n        approverStartDate = now;\n    }\n\n    function confirmApprover(string _description)\n        external\n        nonReentrant\n        requireForApprover\n    {\n        if (now > approverStartDate.safeAdd(5 days)) {\n            require(isApprover(msg.sender));\n        } else {\n            require(msg.sender == approverAddress);\n\n            deployedFromContract.deleteApproverWorkAddress(\n                this,\n                approverAddress\n            );\n\n            deployedFromContract.sendApproverArgonCoin(approverAddress);\n        }\n\n        approverConfirmStatus = 1;\n        _payFreelancer();\n        approverReport = _description;\n        workEndDate = now;\n    }\n\n    function cancelApprover(string _description)\n        external\n        nonReentrant\n        requireForApprover\n    {\n        if (now > approverStartDate.safeAdd(5 days)) {\n            require(isApprover(msg.sender));\n        } else {\n            require(msg.sender == approverAddress);\n            deployedFromContract.deleteApproverWorkAddress(\n                this,\n                approverAddress\n            );\n            deployedFromContract.sendApproverArgonCoin(approverAddress);\n        }\n        approverConfirmStatus = 2;\n        approverReport = _description;\n        _payEmployer();\n    }\n\n    function autoConfirm() external nonReentrant {\n        require(now > freelancerSendFilesDate.safeAdd(5 days));\n        require(!employerReceiveFiles);\n        require(freelancerSendFiles);\n        _payFreelancer();\n        deployedFromContract.setPuan(5, freelancerAddress);\n        employerRemark = \"Auto Confirmed By Smart Contract\";\n        workEndDate = now;\n    }\n\n    function sendDeadline() external nonReentrant {\n        require(now > deadLine);\n        require(!freelancerSendFiles);\n        _payEmployer();\n    }\n}",
        "function": null,
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Hacken-Argon Foundation/platform-contracts-8996d21499ede3f2eb36320ded9563f5467a0fa6/ArgonFreelancers.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract WorkContract is ApproverRole, ReentrancyGuard {\n    using SafeMath for uint256;\n\n    MainContract deployedFromContract;\n    struct Offer {\n        uint256 offerPrice;\n        address freelancerAddress;\n        string description;\n        string title;\n        uint256 deadline;\n        address offerTokenContract;\n        bool tokenContractIsBNB;\n        bool ArgonShield;\n    }\n\n    string public workTitle;\n    string public workCategory;\n    string public workDescription;\n    string public workAvarageBudget;\n    string public workFilesLink;\n    string public employerCancelDescription;\n    string public approverReport;\n    string public employerRemark;\n\n    uint256 public workCreateTime;\n    uint256 public deadLine;\n    uint256 public freelancerSendFilesDate;\n    uint256 public workStartDate;\n    uint256 public workEndDate;\n    uint256 public approverConfirmStatus;\n    uint256 public approverStartDate;\n    uint256 public workPrice;\n    uint256 public workOfferCount;\n\n    bool public workStatus;\n    bool public isBNB;\n    bool public argonShield;\n    bool public freelancerSendFiles;\n    bool public employerReceiveFiles;\n\n    address public employerAddress;\n    address public approverAddress;\n    address public tokenContractAddress;\n    address public freelancerAddress;\n    address[] public allFreelancerAddress;\n\n    IERC20 public argonToken; // ***ArgonToken Contract***\n    mapping(address => Offer) offers;\n\n    modifier mustActive() {\n        require(deployedFromContract.isActive());\n        _;\n    }\n\n    modifier requireForApprover() {\n        require(approverConfirmStatus == 0 && approverStartDate > 0);\n        require(argonShield);\n        _;\n    }\n\n    constructor(\n        string _workTitle,\n        string _workCategory,\n        string _workDescription,\n        string _workAvarageBudget,\n        address _employerAddress,\n        address _t\n    ) public {\n        require(MainContract(_t).isActive());\n        require(MainContract(_t).getPersonAccountType(_employerAddress) == 2);\n        workTitle = _workTitle;\n        workCategory = _workCategory;\n        workDescription = _workDescription;\n        workCreateTime = now;\n        workAvarageBudget = _workAvarageBudget;\n        workOfferCount = 0;\n        workStatus = false;\n        employerAddress = _employerAddress;\n        freelancerSendFiles = false;\n        employerReceiveFiles = false;\n        deployedFromContract = MainContract(_t);\n        argonToken = IERC20(MainContract(_t).argonTokenContractAddress());\n    }\n\n    function getAllFreelancers() external view returns (address[]) {\n        return allFreelancerAddress;\n    }\n\n    function updateWork(\n        string _workTitle,\n        string _workCategory,\n        string _workDescription,\n        string _workAvarageBudget,\n        address _workaddress\n    ) external mustActive {\n        require(this == _workaddress);\n        require(msg.sender == employerAddress);\n        workTitle = _workTitle;\n        workCategory = _workCategory;\n        workDescription = _workDescription;\n        workAvarageBudget = _workAvarageBudget;\n    }\n\n    function createOffer(\n        uint256 _offerPrice,\n        string _description,\n        uint256 _deadline,\n        string _title,\n        address _tokenContract,\n        bool _isBNB,\n        bool _ArgonShield\n    ) external mustActive {\n        require(deployedFromContract.getPersonAccountType(msg.sender) == 0);\n        if (!_isBNB) {\n            require(_tokenContract != address(0));\n            require(deployedFromContract.availableTokens(_tokenContract));\n        }\n        Offer memory newOffer =\n            Offer({\n                offerPrice: _offerPrice,\n                freelancerAddress: msg.sender,\n                description: _description,\n                deadline: _deadline,\n                title: _title,\n                offerTokenContract: _tokenContract,\n                tokenContractIsBNB: _isBNB,\n                ArgonShield: _ArgonShield\n            });\n        offers[msg.sender] = newOffer;\n        allFreelancerAddress.push(msg.sender);\n        workOfferCount++;\n    }\n\n    function deleteOffer() external mustActive {\n        delete offers[msg.sender];\n        workOfferCount--;\n    }\n\n    function updateOffer(\n        uint256 _offerPrice,\n        string _description,\n        string _title,\n        bool _ArgonShield\n    ) external mustActive {\n        Offer storage data = offers[msg.sender];\n        data.offerPrice = _offerPrice;\n        data.description = _description;\n        data.title = _title;\n        data.ArgonShield = _ArgonShield;\n    }\n\n    function getOfferData(address _freelancerAddress)\n        external\n        view\n        returns (\n            uint256,\n            address,\n            string,\n            string,\n            uint256,\n            address,\n            bool,\n            bool\n        )\n    {\n        Offer storage data = offers[_freelancerAddress];\n        return (\n            data.offerPrice,\n            data.freelancerAddress,\n            data.description,\n            data.title,\n            data.deadline,\n            data.offerTokenContract,\n            data.tokenContractIsBNB,\n            data.ArgonShield\n        );\n    }\n\n    function selectOffer(address _freelancerAddress, address _approveraddress)\n        external\n        payable\n        mustActive\n    {\n        require(msg.sender == employerAddress);\n        Offer storage data = offers[_freelancerAddress];\n        require(data.tokenContractIsBNB);\n        if (data.ArgonShield) {\n            require(\n                deployedFromContract.approverLockBalances(_approveraddress) >=\n                    deployedFromContract.approverMinArgonLimit()\n            );\n            approverAddress = _approveraddress;\n            deployedFromContract.setApproverWorkAddress(this, _approveraddress);\n        }\n\n        require(msg.value >= data.offerPrice);\n        freelancerAddress = data.freelancerAddress;\n        workStatus = true;\n        workStartDate = now;\n        deadLine = data.deadline;\n        workPrice = data.offerPrice;\n        isBNB = true;\n        argonShield = data.ArgonShield;\n    }\n\n    function selectOfferWithToken(\n        address _freelancerAddress,\n        address _approveraddress\n    ) external mustActive {\n        require(msg.sender == employerAddress);\n        Offer storage data = offers[_freelancerAddress];\n        require(!data.tokenContractIsBNB);\n        if (data.ArgonShield) {\n            require(\n                deployedFromContract.approverLockBalances(_approveraddress) >=\n                    deployedFromContract.approverMinArgonLimit()\n            );\n\n            approverAddress = _approveraddress;\n            deployedFromContract.setApproverWorkAddress(this, _approveraddress);\n        }\n        freelancerAddress = data.freelancerAddress;\n        workStatus = true;\n        workStartDate = now;\n        deadLine = data.deadline;\n        workPrice = data.offerPrice;\n        isBNB = false;\n        tokenContractAddress = data.offerTokenContract;\n        require(\n            IERC20(data.offerTokenContract).transferFrom(\n                msg.sender,\n                address(this),\n                data.offerPrice\n            )\n        );\n        argonShield = data.ArgonShield;\n    }\n\n    function freelancerSendFile(string _workFilesLink) external {\n        require(msg.sender == freelancerAddress);\n        require(!freelancerSendFiles);\n        freelancerSendFiles = true;\n        workFilesLink = _workFilesLink;\n        freelancerSendFilesDate = now;\n    }\n\n    function _payFreelancer() private {\n        uint256 amount;\n\n        if (isBNB) {\n            amount = workPrice.safeSub(\n                (workPrice.safeMul(deployedFromContract.bnbFeeRate())).safeDiv(\n                    1e6\n                )\n            );\n            freelancerAddress.transfer(amount);\n            deployedFromContract.feeAddress().transfer(\n                workPrice.safeSub(amount)\n            );\n        } else {\n            amount = workPrice.safeSub(\n                (\n                    workPrice.safeMul(\n                        deployedFromContract.feeRates(tokenContractAddress)\n                    )\n                )\n                    .safeDiv(1e6)\n            );\n\n            IERC20(tokenContractAddress).transfer(freelancerAddress, amount);\n            IERC20(tokenContractAddress).transfer(\n                deployedFromContract.feeAddress(),\n                workPrice.safeSub(amount)\n            );\n        }\n    }\n\n    function _payEmployer() private {\n        if (isBNB) {\n            employerAddress.transfer(workPrice);\n        } else {\n            IERC20(tokenContractAddress).transfer(employerAddress, workPrice);\n        }\n    }\n\n    function employerReceiveFile(uint256 _puan, string _remark)\n        external\n        nonReentrant\n    {\n        require(msg.sender == employerAddress);\n        require(freelancerSendFiles, \"freelancer must be sent files\");\n        require(!employerReceiveFiles);\n        _payFreelancer();\n        deployedFromContract.setPuan(_puan, freelancerAddress);\n        employerRemark = _remark;\n        employerReceiveFiles = true;\n        workEndDate = now;\n    }\n\n    function employerCancel(string _depscription) external {\n        require(msg.sender == employerAddress);\n        require(argonShield);\n        require(approverStartDate == 0);\n        require(!employerReceiveFiles);\n        require(freelancerSendFiles, \"freelancer must be sent files\");\n\n        approverConfirmStatus = 0;\n        employerCancelDescription = _depscription;\n        approverStartDate = now;\n    }\n\n    function confirmApprover(string _description)\n        external\n        nonReentrant\n        requireForApprover\n    {\n        if (now > approverStartDate.safeAdd(5 days)) {\n            require(isApprover(msg.sender));\n        } else {\n            require(msg.sender == approverAddress);\n\n            deployedFromContract.deleteApproverWorkAddress(\n                this,\n                approverAddress\n            );\n\n            deployedFromContract.sendApproverArgonCoin(approverAddress);\n        }\n\n        approverConfirmStatus = 1;\n        _payFreelancer();\n        approverReport = _description;\n        workEndDate = now;\n    }\n\n    function cancelApprover(string _description)\n        external\n        nonReentrant\n        requireForApprover\n    {\n        if (now > approverStartDate.safeAdd(5 days)) {\n            require(isApprover(msg.sender));\n        } else {\n            require(msg.sender == approverAddress);\n            deployedFromContract.deleteApproverWorkAddress(\n                this,\n                approverAddress\n            );\n            deployedFromContract.sendApproverArgonCoin(approverAddress);\n        }\n        approverConfirmStatus = 2;\n        approverReport = _description;\n        _payEmployer();\n    }\n\n    function autoConfirm() external nonReentrant {\n        require(now > freelancerSendFilesDate.safeAdd(5 days));\n        require(!employerReceiveFiles);\n        require(freelancerSendFiles);\n        _payFreelancer();\n        deployedFromContract.setPuan(5, freelancerAddress);\n        employerRemark = \"Auto Confirmed By Smart Contract\";\n        workEndDate = now;\n    }\n\n    function sendDeadline() external nonReentrant {\n        require(now > deadLine);\n        require(!freelancerSendFiles);\n        _payEmployer();\n    }\n}",
        "function": null,
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Hacken-Argon Foundation/platform-contracts-8996d21499ede3f2eb36320ded9563f5467a0fa6/ArgonFreelancers.sol",
        "vulnerability": "Timestamp Dependency",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract WorkContract is ApproverRole, ReentrancyGuard {\n    using SafeMath for uint256;\n\n    MainContract deployedFromContract;\n    struct Offer {\n        uint256 offerPrice;\n        address freelancerAddress;\n        string description;\n        string title;\n        uint256 deadline;\n        address offerTokenContract;\n        bool tokenContractIsBNB;\n        bool ArgonShield;\n    }\n\n    string public workTitle;\n    string public workCategory;\n    string public workDescription;\n    string public workAvarageBudget;\n    string public workFilesLink;\n    string public employerCancelDescription;\n    string public approverReport;\n    string public employerRemark;\n\n    uint256 public workCreateTime;\n    uint256 public deadLine;\n    uint256 public freelancerSendFilesDate;\n    uint256 public workStartDate;\n    uint256 public workEndDate;\n    uint256 public approverConfirmStatus;\n    uint256 public approverStartDate;\n    uint256 public workPrice;\n    uint256 public workOfferCount;\n\n    bool public workStatus;\n    bool public isBNB;\n    bool public argonShield;\n    bool public freelancerSendFiles;\n    bool public employerReceiveFiles;\n\n    address public employerAddress;\n    address public approverAddress;\n    address public tokenContractAddress;\n    address public freelancerAddress;\n    address[] public allFreelancerAddress;\n\n    IERC20 public argonToken; // ***ArgonToken Contract***\n    mapping(address => Offer) offers;\n\n    modifier mustActive() {\n        require(deployedFromContract.isActive());\n        _;\n    }\n\n    modifier requireForApprover() {\n        require(approverConfirmStatus == 0 && approverStartDate > 0);\n        require(argonShield);\n        _;\n    }\n\n    constructor(\n        string _workTitle,\n        string _workCategory,\n        string _workDescription,\n        string _workAvarageBudget,\n        address _employerAddress,\n        address _t\n    ) public {\n        require(MainContract(_t).isActive());\n        require(MainContract(_t).getPersonAccountType(_employerAddress) == 2);\n        workTitle = _workTitle;\n        workCategory = _workCategory;\n        workDescription = _workDescription;\n        workCreateTime = now;\n        workAvarageBudget = _workAvarageBudget;\n        workOfferCount = 0;\n        workStatus = false;\n        employerAddress = _employerAddress;\n        freelancerSendFiles = false;\n        employerReceiveFiles = false;\n        deployedFromContract = MainContract(_t);\n        argonToken = IERC20(MainContract(_t).argonTokenContractAddress());\n    }\n\n    function getAllFreelancers() external view returns (address[]) {\n        return allFreelancerAddress;\n    }\n\n    function updateWork(\n        string _workTitle,\n        string _workCategory,\n        string _workDescription,\n        string _workAvarageBudget,\n        address _workaddress\n    ) external mustActive {\n        require(this == _workaddress);\n        require(msg.sender == employerAddress);\n        workTitle = _workTitle;\n        workCategory = _workCategory;\n        workDescription = _workDescription;\n        workAvarageBudget = _workAvarageBudget;\n    }\n\n    function createOffer(\n        uint256 _offerPrice,\n        string _description,\n        uint256 _deadline,\n        string _title,\n        address _tokenContract,\n        bool _isBNB,\n        bool _ArgonShield\n    ) external mustActive {\n        require(deployedFromContract.getPersonAccountType(msg.sender) == 0);\n        if (!_isBNB) {\n            require(_tokenContract != address(0));\n            require(deployedFromContract.availableTokens(_tokenContract));\n        }\n        Offer memory newOffer =\n            Offer({\n                offerPrice: _offerPrice,\n                freelancerAddress: msg.sender,\n                description: _description,\n                deadline: _deadline,\n                title: _title,\n                offerTokenContract: _tokenContract,\n                tokenContractIsBNB: _isBNB,\n                ArgonShield: _ArgonShield\n            });\n        offers[msg.sender] = newOffer;\n        allFreelancerAddress.push(msg.sender);\n        workOfferCount++;\n    }\n\n    function deleteOffer() external mustActive {\n        delete offers[msg.sender];\n        workOfferCount--;\n    }\n\n    function updateOffer(\n        uint256 _offerPrice,\n        string _description,\n        string _title,\n        bool _ArgonShield\n    ) external mustActive {\n        Offer storage data = offers[msg.sender];\n        data.offerPrice = _offerPrice;\n        data.description = _description;\n        data.title = _title;\n        data.ArgonShield = _ArgonShield;\n    }\n\n    function getOfferData(address _freelancerAddress)\n        external\n        view\n        returns (\n            uint256,\n            address,\n            string,\n            string,\n            uint256,\n            address,\n            bool,\n            bool\n        )\n    {\n        Offer storage data = offers[_freelancerAddress];\n        return (\n            data.offerPrice,\n            data.freelancerAddress,\n            data.description,\n            data.title,\n            data.deadline,\n            data.offerTokenContract,\n            data.tokenContractIsBNB,\n            data.ArgonShield\n        );\n    }\n\n    function selectOffer(address _freelancerAddress, address _approveraddress)\n        external\n        payable\n        mustActive\n    {\n        require(msg.sender == employerAddress);\n        Offer storage data = offers[_freelancerAddress];\n        require(data.tokenContractIsBNB);\n        if (data.ArgonShield) {\n            require(\n                deployedFromContract.approverLockBalances(_approveraddress) >=\n                    deployedFromContract.approverMinArgonLimit()\n            );\n            approverAddress = _approveraddress;\n            deployedFromContract.setApproverWorkAddress(this, _approveraddress);\n        }\n\n        require(msg.value >= data.offerPrice);\n        freelancerAddress = data.freelancerAddress;\n        workStatus = true;\n        workStartDate = now;\n        deadLine = data.deadline;\n        workPrice = data.offerPrice;\n        isBNB = true;\n        argonShield = data.ArgonShield;\n    }\n\n    function selectOfferWithToken(\n        address _freelancerAddress,\n        address _approveraddress\n    ) external mustActive {\n        require(msg.sender == employerAddress);\n        Offer storage data = offers[_freelancerAddress];\n        require(!data.tokenContractIsBNB);\n        if (data.ArgonShield) {\n            require(\n                deployedFromContract.approverLockBalances(_approveraddress) >=\n                    deployedFromContract.approverMinArgonLimit()\n            );\n\n            approverAddress = _approveraddress;\n            deployedFromContract.setApproverWorkAddress(this, _approveraddress);\n        }\n        freelancerAddress = data.freelancerAddress;\n        workStatus = true;\n        workStartDate = now;\n        deadLine = data.deadline;\n        workPrice = data.offerPrice;\n        isBNB = false;\n        tokenContractAddress = data.offerTokenContract;\n        require(\n            IERC20(data.offerTokenContract).transferFrom(\n                msg.sender,\n                address(this),\n                data.offerPrice\n            )\n        );\n        argonShield = data.ArgonShield;\n    }\n\n    function freelancerSendFile(string _workFilesLink) external {\n        require(msg.sender == freelancerAddress);\n        require(!freelancerSendFiles);\n        freelancerSendFiles = true;\n        workFilesLink = _workFilesLink;\n        freelancerSendFilesDate = now;\n    }\n\n    function _payFreelancer() private {\n        uint256 amount;\n\n        if (isBNB) {\n            amount = workPrice.safeSub(\n                (workPrice.safeMul(deployedFromContract.bnbFeeRate())).safeDiv(\n                    1e6\n                )\n            );\n            freelancerAddress.transfer(amount);\n            deployedFromContract.feeAddress().transfer(\n                workPrice.safeSub(amount)\n            );\n        } else {\n            amount = workPrice.safeSub(\n                (\n                    workPrice.safeMul(\n                        deployedFromContract.feeRates(tokenContractAddress)\n                    )\n                )\n                    .safeDiv(1e6)\n            );\n\n            IERC20(tokenContractAddress).transfer(freelancerAddress, amount);\n            IERC20(tokenContractAddress).transfer(\n                deployedFromContract.feeAddress(),\n                workPrice.safeSub(amount)\n            );\n        }\n    }\n\n    function _payEmployer() private {\n        if (isBNB) {\n            employerAddress.transfer(workPrice);\n        } else {\n            IERC20(tokenContractAddress).transfer(employerAddress, workPrice);\n        }\n    }\n\n    function employerReceiveFile(uint256 _puan, string _remark)\n        external\n        nonReentrant\n    {\n        require(msg.sender == employerAddress);\n        require(freelancerSendFiles, \"freelancer must be sent files\");\n        require(!employerReceiveFiles);\n        _payFreelancer();\n        deployedFromContract.setPuan(_puan, freelancerAddress);\n        employerRemark = _remark;\n        employerReceiveFiles = true;\n        workEndDate = now;\n    }\n\n    function employerCancel(string _depscription) external {\n        require(msg.sender == employerAddress);\n        require(argonShield);\n        require(approverStartDate == 0);\n        require(!employerReceiveFiles);\n        require(freelancerSendFiles, \"freelancer must be sent files\");\n\n        approverConfirmStatus = 0;\n        employerCancelDescription = _depscription;\n        approverStartDate = now;\n    }\n\n    function confirmApprover(string _description)\n        external\n        nonReentrant\n        requireForApprover\n    {\n        if (now > approverStartDate.safeAdd(5 days)) {\n            require(isApprover(msg.sender));\n        } else {\n            require(msg.sender == approverAddress);\n\n            deployedFromContract.deleteApproverWorkAddress(\n                this,\n                approverAddress\n            );\n\n            deployedFromContract.sendApproverArgonCoin(approverAddress);\n        }\n\n        approverConfirmStatus = 1;\n        _payFreelancer();\n        approverReport = _description;\n        workEndDate = now;\n    }\n\n    function cancelApprover(string _description)\n        external\n        nonReentrant\n        requireForApprover\n    {\n        if (now > approverStartDate.safeAdd(5 days)) {\n            require(isApprover(msg.sender));\n        } else {\n            require(msg.sender == approverAddress);\n            deployedFromContract.deleteApproverWorkAddress(\n                this,\n                approverAddress\n            );\n            deployedFromContract.sendApproverArgonCoin(approverAddress);\n        }\n        approverConfirmStatus = 2;\n        approverReport = _description;\n        _payEmployer();\n    }\n\n    function autoConfirm() external nonReentrant {\n        require(now > freelancerSendFilesDate.safeAdd(5 days));\n        require(!employerReceiveFiles);\n        require(freelancerSendFiles);\n        _payFreelancer();\n        deployedFromContract.setPuan(5, freelancerAddress);\n        employerRemark = \"Auto Confirmed By Smart Contract\";\n        workEndDate = now;\n    }\n\n    function sendDeadline() external nonReentrant {\n        require(now > deadLine);\n        require(!freelancerSendFiles);\n        _payEmployer();\n    }\n}",
        "function": null,
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Hacken-Argon Foundation/platform-contracts-8996d21499ede3f2eb36320ded9563f5467a0fa6/ArgonFreelancers.sol",
        "vulnerability": "Transaction-Ordering Dependence (TOD)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "library SafeMathLib {\n\n  function times(uint a, uint b) returns (uint) {\n    uint c = a * b;\n    assert(a == 0 || c / a == b);\n    return c;\n  }\n\n  function minus(uint a, uint b) returns (uint) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  function plus(uint a, uint b) returns (uint) {\n    uint c = a + b;\n    assert(c>=a);\n    return c;\n  }\n\n}",
        "function": null,
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinfabrik-Security Audit for Patientory (PTOY) Token ICO/smart-contracts-master/contracts/SafeMathLib.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract ProjectKudos {\n    \n    // votes limit for judge\n    uint KUDOS_LIMIT_JUDGE = 1000;\n\n    // votes limit for regular user\n    uint KUDOS_LIMIT_USER  = 10;\n\n    // enumerates reasons \n    // which additional votes can be granted for\n    enum GrantReason {\n        Facebook,\n        Twitter, \n        Fake\n    }\n//    SWC-135-Code With No Effects:L20-24,281-303,313-320\n    // keeps project votes data\n    struct ProjectInfo {\n        mapping(address => uint) kudosByUser;\n        uint kudosTotal;\n    }\n\n    // keeps user votes data\n    struct UserInfo {\n        uint kudosLimit;\n        uint kudosGiven;\n        bool isJudge;\n        mapping(uint => bool) grant;\n    }\n\n    // keeps links between user's votes \n    // and projects he voted for\n    struct UserIndex {\n        bytes32[] projects;\n        uint[] kudos;\n        mapping(bytes32 => uint) kudosIdx;\n    }\n    \n    // keeps time frames for vote period \n    struct VotePeriod {\n        uint start;\n        uint end;\n    }\n    \n    // contract creator's address\n    address owner;\n    \n    // vote period\n    VotePeriod votePeriod;\n\n    // user votes mapping\n    mapping(address => UserInfo) users;\n\n    // user index, \n    // helps to get votes given by one user for every project\n    mapping(address => UserIndex) usersIndex;\n\n    // project votes mapping\n    mapping(bytes32 => ProjectInfo) projects;\n    \n    // emitted when vote is done\n    event Vote(\n        // address of voter\n        address indexed voter,\n        // sha3 of project code\n        bytes32 indexed projectCode,\n        // votes given\n        uint indexed count\n    );\n    \n    /**\n     * @dev Contract's constructor.\n     * Stores contract's owner and sets up vote period\n     */\n    function ProjectKudos() {\n        \n        owner = msg.sender;\n        \n        votePeriod = VotePeriod(\n            1479996000,     // GMT: 24-Nov-2016 14:00, Voting starts, 1st week passed\n            1482415200      // GMT: 22-Dec-2016 14:00, Voting ends, Hackathon ends\n        );\n    }\n\n    /**\n     * @dev Registers voter to the event.\n     * Executable only by contract's owner.\n     *\n     * @param userAddres address of the user to register\n     * @param isJudge should be true if user is judge, false otherwise\n     */\n    function register(address userAddres, bool isJudge) onlyOwner {\n                            \n        UserInfo user = users[userAddres];\n\n        if (user.kudosLimit > 0) throw;\n\n        if (isJudge)\n            user.kudosLimit = KUDOS_LIMIT_JUDGE;\n        else \n            user.kudosLimit = KUDOS_LIMIT_USER;\n        \n        user.isJudge = isJudge;\n        \n        users[userAddres] = user;\n    }\n    \n    /**\n     *  @dev Gives votes to the project.\n     *  Can only be executed within vote period.\n     *  User signed the Tx becomes votes giver.\n     *\n     *  @param projectCode code of the project, must be less than or equal to 32 bytes\n     *  @param kudos - votes to be given\n     */\n    function giveKudos(string projectCode, uint kudos) duringVote {\n        \n        UserInfo giver = users[msg.sender];\n\n        if (giver.kudosGiven + kudos > giver.kudosLimit) throw;\n        \n        bytes32 code = strToBytes(projectCode);\n        ProjectInfo project = projects[code];\n\n        giver.kudosGiven += kudos;\n        project.kudosTotal += kudos;\n        project.kudosByUser[msg.sender] += kudos;\n\n        // save index of user voting history\n        updateUsersIndex(code, project.kudosByUser[msg.sender]);\n        \n        Vote(msg.sender, sha3(projectCode), kudos);\n    }\n\n    /**\n     * @dev Grants extra kudos for identity proof.\n     *\n     * @param userToGrant address of user to grant additional \n     * votes for social proof\n     * \n     * @param reason granting reason, \n     * possible reasons are listed in GrantReason enum\n     */         \n    function grantKudos(address userToGrant, uint reason) onlyOwner {\n    \n        UserInfo user = users[userToGrant];\n    \n        GrantReason grantReason = grantUintToReason(reason);\n        \n        if (grantReason != GrantReason.Facebook &&\n            grantReason != GrantReason.Twitter) throw;\n    \n        // if user is judge his identity is known\n        // not reasonble to grant more kudos for social \n        // proof.\n        if (user.isJudge) throw;\n        \n        // if not granted for that reason yet\n        if (user.grant[reason]) throw;\n        \n        // grant 100 votes\n        user.kudosLimit += 100;\n        \n        // mark reason \n        user.grant[reason] = true;\n    }\n    \n    \n    // ********************* //\n    // *   Constant Calls  * //\n    // ********************* //\n    \n    /**\n     * @dev Returns total votes given to the project\n     * \n     * @param projectCode project's code\n     * \n     * @return number of give votes\n     */\n    function getProjectKudos(string projectCode) constant returns(uint) {\n        bytes32 code = strToBytes(projectCode);\n        ProjectInfo project = projects[code];\n        return project.kudosTotal;\n    }\n\n    /**\n     * @dev Returns an array of votes given to the project\n     * corresponding to array of users passed in function call\n     * \n     * @param projectCode project's code\n     * @param users array of user addresses\n     * \n     * @return array of votes given by passed users\n     */\n    function getProjectKudosByUsers(string projectCode, address[] users) constant returns(uint[]) {\n        bytes32 code = strToBytes(projectCode);\n        ProjectInfo project = projects[code];\n        mapping(address => uint) kudosByUser = project.kudosByUser;\n        uint[] memory userKudos = new uint[](users.length);\n        for (uint i = 0; i < users.length; i++) {\n            userKudos[i] = kudosByUser[users[i]];    \n       }\n       \n       return userKudos;\n    }\n\n    /**\n     * @dev Returns votes given by speicified user \n     * to the list of projects ever voted by that user\n     * \n     * @param giver user's address\n     * @return projects array of project codes represented by bytes32 array\n     * @return kudos array of votes given by user, \n     *         index of vote corresponds to index of project from projects array\n     */\n    function getKudosPerProject(address giver) constant returns (bytes32[] projects, uint[] kudos) {\n        UserIndex idx = usersIndex[giver];\n        projects = idx.projects;\n        kudos = idx.kudos;\n    }\n\n    /**\n     * @dev Returns votes allowed to be given by user\n     * \n     * @param addr user's address\n     * @return number of votes left\n     */\n    function getKudosLeft(address addr) constant returns(uint) {\n        UserInfo user = users[addr];\n        return user.kudosLimit - user.kudosGiven;\n    }\n\n    /**\n     * @dev Returns votes given by user\n     * \n     * @param addr user's address\n     * @return number of votes given\n     */\n    function getKudosGiven(address addr) constant returns(uint) {\n        UserInfo user = users[addr];\n        return user.kudosGiven;\n    }\n\n   \n    // ********************* //\n    // *   Private Calls   * //\n    // ********************* //\n    \n    /**\n     * @dev Private function. Updates users index\n     * \n     * @param code project code represented by bytes32 array\n     * @param kudos votes total given to the project by sender\n     */\n    function updateUsersIndex(bytes32 code, uint kudos) private {\n        \n        UserIndex idx = usersIndex[msg.sender];\n        uint i = idx.kudosIdx[code];\n        \n        // add new entry to index\n        if (i == 0) {\n            i = idx.projects.length + 1;\n            idx.projects.length += 1;\n            idx.kudos.length += 1;\n            idx.projects[i - 1] = code;\n            idx.kudosIdx[code] = i;\n        }\n\n        idx.kudos[i - 1] = kudos;\n    }\n    \n    /**\n     * @dev Translates GrantReason code to GrantReason\n     * \n     * @param reason the code of the reason\n     * @return GrantReason corresponding to the code\n     */\n    function grantUintToReason(uint reason) private returns (GrantReason result) {\n        if (reason == 0)  return GrantReason.Facebook;\n        if (reason == 1)  return GrantReason.Twitter;\n        return GrantReason.Fake;\n    }\n    \n    /**\n     * @dev Translates GrantReason to its code\n     * \n     * @param reason GrantReason instance\n     * @return corresponding reason code\n     */\n    function grantReasonToUint(GrantReason reason) private returns (uint result) {\n        if (reason == GrantReason.Facebook) return 0;\n        if (reason == GrantReason.Twitter)  return 1;\n        return 3;\n    }\n    \n    /**\n     * @dev Low level function.\n     * Converts string to bytes32 array.\n     * Throws if string length is more than 32 bytes\n     * \n     * @param str string\n     * @return bytes32 representation of str\n     */\n    function strToBytes(string str) private returns (bytes32 ret) {\n        \n        if (bytes(str).length > 32) throw;\n        \n        assembly {\n            ret := mload(add(str, 32))\n        }\n    } \n\n    \n    // ********************* //\n    // *     Modifiers     * //\n    // ********************* //\n//    SWC-135-Code With No Effects:L330-334\n    /**\n     * @dev Throws if called not during the vote period\n     */\n    modifier duringVote() {\n        if (now < votePeriod.start) throw;\n        if (now >= votePeriod.end) throw;\n        _;\n    }\n//    SWC-116-Block values as a proxy for time:L331,332\n    /**\n     * @dev Throws if called not by contract's owner\n     */\n    modifier onlyOwner() { \n        if (msg.sender != owner) throw;\n        _;\n    }\n}",
        "function": null,
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/openzeppelin-EtherCamp_ProjectKudos_public_code/virtual-accelerator-6665fdd4b71088443a74d1ed9fda52c6a8c8b975/ProjectKudos.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract ProjectKudos {\n    \n    // votes limit for judge\n    uint KUDOS_LIMIT_JUDGE = 1000;\n\n    // votes limit for regular user\n    uint KUDOS_LIMIT_USER  = 10;\n\n    // enumerates reasons \n    // which additional votes can be granted for\n    enum GrantReason {\n        Facebook,\n        Twitter, \n        Fake\n    }\n//    SWC-135-Code With No Effects:L20-24,281-303,313-320\n    // keeps project votes data\n    struct ProjectInfo {\n        mapping(address => uint) kudosByUser;\n        uint kudosTotal;\n    }\n\n    // keeps user votes data\n    struct UserInfo {\n        uint kudosLimit;\n        uint kudosGiven;\n        bool isJudge;\n        mapping(uint => bool) grant;\n    }\n\n    // keeps links between user's votes \n    // and projects he voted for\n    struct UserIndex {\n        bytes32[] projects;\n        uint[] kudos;\n        mapping(bytes32 => uint) kudosIdx;\n    }\n    \n    // keeps time frames for vote period \n    struct VotePeriod {\n        uint start;\n        uint end;\n    }\n    \n    // contract creator's address\n    address owner;\n    \n    // vote period\n    VotePeriod votePeriod;\n\n    // user votes mapping\n    mapping(address => UserInfo) users;\n\n    // user index, \n    // helps to get votes given by one user for every project\n    mapping(address => UserIndex) usersIndex;\n\n    // project votes mapping\n    mapping(bytes32 => ProjectInfo) projects;\n    \n    // emitted when vote is done\n    event Vote(\n        // address of voter\n        address indexed voter,\n        // sha3 of project code\n        bytes32 indexed projectCode,\n        // votes given\n        uint indexed count\n    );\n    \n    /**\n     * @dev Contract's constructor.\n     * Stores contract's owner and sets up vote period\n     */\n    function ProjectKudos() {\n        \n        owner = msg.sender;\n        \n        votePeriod = VotePeriod(\n            1479996000,     // GMT: 24-Nov-2016 14:00, Voting starts, 1st week passed\n            1482415200      // GMT: 22-Dec-2016 14:00, Voting ends, Hackathon ends\n        );\n    }\n\n    /**\n     * @dev Registers voter to the event.\n     * Executable only by contract's owner.\n     *\n     * @param userAddres address of the user to register\n     * @param isJudge should be true if user is judge, false otherwise\n     */\n    function register(address userAddres, bool isJudge) onlyOwner {\n                            \n        UserInfo user = users[userAddres];\n\n        if (user.kudosLimit > 0) throw;\n\n        if (isJudge)\n            user.kudosLimit = KUDOS_LIMIT_JUDGE;\n        else \n            user.kudosLimit = KUDOS_LIMIT_USER;\n        \n        user.isJudge = isJudge;\n        \n        users[userAddres] = user;\n    }\n    \n    /**\n     *  @dev Gives votes to the project.\n     *  Can only be executed within vote period.\n     *  User signed the Tx becomes votes giver.\n     *\n     *  @param projectCode code of the project, must be less than or equal to 32 bytes\n     *  @param kudos - votes to be given\n     */\n    function giveKudos(string projectCode, uint kudos) duringVote {\n        \n        UserInfo giver = users[msg.sender];\n\n        if (giver.kudosGiven + kudos > giver.kudosLimit) throw;\n        \n        bytes32 code = strToBytes(projectCode);\n        ProjectInfo project = projects[code];\n\n        giver.kudosGiven += kudos;\n        project.kudosTotal += kudos;\n        project.kudosByUser[msg.sender] += kudos;\n\n        // save index of user voting history\n        updateUsersIndex(code, project.kudosByUser[msg.sender]);\n        \n        Vote(msg.sender, sha3(projectCode), kudos);\n    }\n\n    /**\n     * @dev Grants extra kudos for identity proof.\n     *\n     * @param userToGrant address of user to grant additional \n     * votes for social proof\n     * \n     * @param reason granting reason, \n     * possible reasons are listed in GrantReason enum\n     */         \n    function grantKudos(address userToGrant, uint reason) onlyOwner {\n    \n        UserInfo user = users[userToGrant];\n    \n        GrantReason grantReason = grantUintToReason(reason);\n        \n        if (grantReason != GrantReason.Facebook &&\n            grantReason != GrantReason.Twitter) throw;\n    \n        // if user is judge his identity is known\n        // not reasonble to grant more kudos for social \n        // proof.\n        if (user.isJudge) throw;\n        \n        // if not granted for that reason yet\n        if (user.grant[reason]) throw;\n        \n        // grant 100 votes\n        user.kudosLimit += 100;\n        \n        // mark reason \n        user.grant[reason] = true;\n    }\n    \n    \n    // ********************* //\n    // *   Constant Calls  * //\n    // ********************* //\n    \n    /**\n     * @dev Returns total votes given to the project\n     * \n     * @param projectCode project's code\n     * \n     * @return number of give votes\n     */\n    function getProjectKudos(string projectCode) constant returns(uint) {\n        bytes32 code = strToBytes(projectCode);\n        ProjectInfo project = projects[code];\n        return project.kudosTotal;\n    }\n\n    /**\n     * @dev Returns an array of votes given to the project\n     * corresponding to array of users passed in function call\n     * \n     * @param projectCode project's code\n     * @param users array of user addresses\n     * \n     * @return array of votes given by passed users\n     */\n    function getProjectKudosByUsers(string projectCode, address[] users) constant returns(uint[]) {\n        bytes32 code = strToBytes(projectCode);\n        ProjectInfo project = projects[code];\n        mapping(address => uint) kudosByUser = project.kudosByUser;\n        uint[] memory userKudos = new uint[](users.length);\n        for (uint i = 0; i < users.length; i++) {\n            userKudos[i] = kudosByUser[users[i]];    \n       }\n       \n       return userKudos;\n    }\n\n    /**\n     * @dev Returns votes given by speicified user \n     * to the list of projects ever voted by that user\n     * \n     * @param giver user's address\n     * @return projects array of project codes represented by bytes32 array\n     * @return kudos array of votes given by user, \n     *         index of vote corresponds to index of project from projects array\n     */\n    function getKudosPerProject(address giver) constant returns (bytes32[] projects, uint[] kudos) {\n        UserIndex idx = usersIndex[giver];\n        projects = idx.projects;\n        kudos = idx.kudos;\n    }\n\n    /**\n     * @dev Returns votes allowed to be given by user\n     * \n     * @param addr user's address\n     * @return number of votes left\n     */\n    function getKudosLeft(address addr) constant returns(uint) {\n        UserInfo user = users[addr];\n        return user.kudosLimit - user.kudosGiven;\n    }\n\n    /**\n     * @dev Returns votes given by user\n     * \n     * @param addr user's address\n     * @return number of votes given\n     */\n    function getKudosGiven(address addr) constant returns(uint) {\n        UserInfo user = users[addr];\n        return user.kudosGiven;\n    }\n\n   \n    // ********************* //\n    // *   Private Calls   * //\n    // ********************* //\n    \n    /**\n     * @dev Private function. Updates users index\n     * \n     * @param code project code represented by bytes32 array\n     * @param kudos votes total given to the project by sender\n     */\n    function updateUsersIndex(bytes32 code, uint kudos) private {\n        \n        UserIndex idx = usersIndex[msg.sender];\n        uint i = idx.kudosIdx[code];\n        \n        // add new entry to index\n        if (i == 0) {\n            i = idx.projects.length + 1;\n            idx.projects.length += 1;\n            idx.kudos.length += 1;\n            idx.projects[i - 1] = code;\n            idx.kudosIdx[code] = i;\n        }\n\n        idx.kudos[i - 1] = kudos;\n    }\n    \n    /**\n     * @dev Translates GrantReason code to GrantReason\n     * \n     * @param reason the code of the reason\n     * @return GrantReason corresponding to the code\n     */\n    function grantUintToReason(uint reason) private returns (GrantReason result) {\n        if (reason == 0)  return GrantReason.Facebook;\n        if (reason == 1)  return GrantReason.Twitter;\n        return GrantReason.Fake;\n    }\n    \n    /**\n     * @dev Translates GrantReason to its code\n     * \n     * @param reason GrantReason instance\n     * @return corresponding reason code\n     */\n    function grantReasonToUint(GrantReason reason) private returns (uint result) {\n        if (reason == GrantReason.Facebook) return 0;\n        if (reason == GrantReason.Twitter)  return 1;\n        return 3;\n    }\n    \n    /**\n     * @dev Low level function.\n     * Converts string to bytes32 array.\n     * Throws if string length is more than 32 bytes\n     * \n     * @param str string\n     * @return bytes32 representation of str\n     */\n    function strToBytes(string str) private returns (bytes32 ret) {\n        \n        if (bytes(str).length > 32) throw;\n        \n        assembly {\n            ret := mload(add(str, 32))\n        }\n    } \n\n    \n    // ********************* //\n    // *     Modifiers     * //\n    // ********************* //\n//    SWC-135-Code With No Effects:L330-334\n    /**\n     * @dev Throws if called not during the vote period\n     */\n    modifier duringVote() {\n        if (now < votePeriod.start) throw;\n        if (now >= votePeriod.end) throw;\n        _;\n    }\n//    SWC-116-Block values as a proxy for time:L331,332\n    /**\n     * @dev Throws if called not by contract's owner\n     */\n    modifier onlyOwner() { \n        if (msg.sender != owner) throw;\n        _;\n    }\n}",
        "function": null,
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/openzeppelin-EtherCamp_ProjectKudos_public_code/virtual-accelerator-6665fdd4b71088443a74d1ed9fda52c6a8c8b975/ProjectKudos.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract KOK_Contract is ERC20Interface, Owned {\n\tstring public constant symbol = \"KOK\";\n\tstring public constant name = \"KOK Coin\";\n\tuint8 public constant decimals = 18;\n\tuint256 public constant totalSupply = 5000000000000000000000000000;\n\n\tbool public stopped;\n\n\tmapping (address => int8) public blackList;\n\n\tmapping (address => uint256) public balances;\n\tmapping (address => mapping (address => uint256)) public allowed;\n\n\n    event Blacklisted(address indexed target);\n    event DeleteFromBlacklist(address indexed target);\n    event RejectedPaymentToBlacklistedAddr(address indexed from, address indexed to, uint256 value);\n    event RejectedPaymentFromBlacklistedAddr(address indexed from, address indexed to, uint256 value);\n\n\n\tmodifier notStopped {\n        require(!stopped);\n        _;\n    }\n\n// constructor\n// SWC-118-Incorrect Constructor Name: L63\n\tfunction KOKContract() public {\n\t\tbalances[msg.sender] = totalSupply;\n\t}\n\t\n// function made for airdrop\n\tfunction airdrop(address[] _to, uint256[] _value) onlyOwner notStopped public {\n\t    for(uint256 i = 0; i < _to.length; i++){\n\t        if(balances[_to[i]] > 0){\n\t            continue;\n\t        }\n\t        transfer(_to[i], _value[i]);\n\t    }\n\t}\n\n// blacklist management\n    function blacklisting(address _addr) onlyOwner public {\n        blackList[_addr] = 1;\n        emit Blacklisted(_addr);\n    }\n    function deleteFromBlacklist(address _addr) onlyOwner public {\n        blackList[_addr] = -1;\n        emit DeleteFromBlacklist(_addr);\n    }\n\n// stop the contract\n// SWC-100-Function Default Visibility: L88\n\tfunction stop() onlyOwner {\n        stopped = true;\n    }\n// SWC-100-Function Default Visibility: L92\n    function start() onlyOwner {\n        stopped = false;\n    }\n\t\n// ERC20 functions\n\tfunction balanceOf(address _owner) public constant returns (uint256 balance){\n\t\treturn balances[_owner];\n\t}\n\tfunction transfer(address _to, uint256 _value) notStopped public returns (bool success){\n\t\trequire(balances[msg.sender] >= _value);\n\n\t\tif(blackList[msg.sender] > 0){\n\t\t\temit RejectedPaymentFromBlacklistedAddr(msg.sender, _to, _value);\n\t\t\treturn false;\n\t\t}\n\t\tif(blackList[_to] > 0){\n\t\t\temit RejectedPaymentToBlacklistedAddr(msg.sender, _to, _value);\n\t\t\treturn false;\n\t\t}\n\n\t\tbalances[msg.sender] -= _value;\n\t\tbalances[_to] += _value;\n\t\temit Transfer(msg.sender, _to, _value);\n\t\treturn true;\n\t}\n\tfunction transferFrom(address _from, address _to, uint256 _value) notStopped public returns (bool success){\n\t\trequire(balances[_from] >= _value\n\t\t\t&& allowed[_from][msg.sender] >= _value);\n\n\t\tif(blackList[_from] > 0){\n\t\t\temit RejectedPaymentFromBlacklistedAddr(_from, _to, _value);\n\t\t\treturn false;\n\t\t}\n\t\tif(blackList[_to] > 0){\n\t\t\temit RejectedPaymentToBlacklistedAddr(_from, _to, _value);\n\t\t\treturn false;\n\t\t}\n\n\t\tbalances[_from] -= _value;\n\t\tallowed[_from][msg.sender] -= _value;\n\t\tbalances[_to] += _value;\n\t\temit Transfer(_from, _to, _value);\n\t\treturn true;\n\t}\n\tfunction approve(address _spender, uint256 _value) notStopped public returns (bool success){\n\t\tallowed[msg.sender][_spender] = _value;\n\t\temit Approval(msg.sender, _spender, _value);\n\t\treturn true;\n\t}\n\tfunction allowance(address _owner, address _spender) public constant returns (uint256 remaining){\n\t\treturn allowed[_owner][_spender];\n\t}\n}",
        "function": null,
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Iosiro-KOK Token Smart Contract Audit/ERC-20-55a501fde12e782b99fe9d5756388c0de82f45ba/contract.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract DTT {\n\n    string public name;\n    string public symbol;\n    uint8 public decimals = 6; // Makes JavaScript able to handle precise calculations (until totalSupply < 9 milliards)\n    uint256 public totalSupply;\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n    mapping(address => mapping(uint => bool)) public usedSigIds; // Used in *ViaSignature(..)\n    address public tokenDistributor; // Account authorized to distribute tokens only during the token distribution event\n    address public rescueAccount; // Account authorized to withdraw tokens accidentally sent to this contract\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    bytes public ethSignedMessagePrefix = \"\\x19Ethereum Signed Message:\\n\";\n    enum sigStandard { typed, personal, stringHex }\n    enum sigDestination { transfer, approve, approveAndCall, transferFrom }\n    bytes32 public sigDestinationTransfer = keccak256(\n        \"address Token Contract Address\",\n        \"address Sender's Address\",\n        \"address Recipient's Address\",\n        \"uint256 Amount to Transfer (last six digits are decimals)\",\n        \"uint256 Fee in Tokens Paid to Executor (last six digits are decimals)\",\n        \"uint256 Signature Expiration Timestamp (unix timestamp)\",\n        \"uint256 Signature ID\"\n    ); // `transferViaSignature`: keccak256(address(this), from, to, value, fee, deadline, sigId)\n    bytes32 public sigDestinationTransferFrom = keccak256(\n        \"address Token Contract Address\",\n        \"address Address Approved for Withdraw\",\n        \"address Account to Withdraw From\",\n        \"address Withdrawal Recipient Address\",\n        \"uint256 Amount to Transfer (last six digits are decimals)\",\n        \"uint256 Fee in Tokens Paid to Executor (last six digits are decimals)\",\n        \"uint256 Signature Expiration Timestamp (unix timestamp)\",\n        \"uint256 Signature ID\"\n    ); // `transferFromViaSignature`: keccak256(address(this), signer, from, to, value, fee, deadline, sigId)\n    bytes32 public sigDestinationApprove = keccak256(\n        \"address Token Contract Address\",\n        \"address Withdrawal Approval Address\",\n        \"address Withdrawal Recipient Address\",\n        \"uint256 Amount to Transfer (last six digits are decimals)\",\n        \"uint256 Fee in Tokens Paid to Executor (last six digits are decimals)\",\n        \"uint256 Signature Expiration Timestamp (unix timestamp)\",\n        \"uint256 Signature ID\"\n    ); // `approveViaSignature`: keccak256(address(this), from, spender, value, fee, deadline, sigId)\n    bytes32 public sigDestinationApproveAndCall = keccak256( // `approveAndCallViaSignature`\n        \"address Token Contract Address\",\n        \"address Withdrawal Approval Address\",\n        \"address Withdrawal Recipient Address\",\n        \"uint256 Amount to Transfer (last six digits are decimals)\",\n        \"bytes Data to Transfer\",\n        \"uint256 Fee in Tokens Paid to Executor (last six digits are decimals)\",\n        \"uint256 Signature Expiration Timestamp (unix timestamp)\",\n        \"uint256 Signature ID\"\n    ); // `approveAndCallViaSignature`: keccak256(address(this), from, spender, value, extraData, fee, deadline, sigId)\n\n    constructor (string tokenName, string tokenSymbol) public {\n        name = tokenName;\n        symbol = tokenSymbol;\n        rescueAccount = tokenDistributor = msg.sender;\n    }\n\n    /**\n     * Utility internal function used to safely transfer `value` tokens `from` -> `to`. Throws if transfer is impossible.\n     */\n    function internalTransfer (address from, address to, uint value) internal {\n        // Prevent people from accidentally burning their tokens + uint256 wrap prevention\n        require(to != 0x0 && balanceOf[from] >= value && balanceOf[to] + value >= balanceOf[to]);\n        balanceOf[from] -= value;\n        balanceOf[to] += value;\n        emit Transfer(from, to, value);\n    }\n\n    /**\n     * Utility internal function used to safely transfer `value1` tokens `from` -> `to1`, and `value2` tokens\n     * `from` -> `to2`, minimizing gas usage (calling `internalTransfer` twice is more expensive). Throws if\n     * transfers are impossible.\n     */\n    function internalDoubleTransfer (address from, address to1, uint value1, address to2, uint value2) internal {\n        require( // Prevent people from accidentally burning their tokens + uint256 wrap prevention\n            to1 != 0x0 && to2 != 0x0 && value1 + value2 >= value1 && balanceOf[from] >= value1 + value2\n            && balanceOf[to1] + value1 >= balanceOf[to1] && balanceOf[to2] + value2 >= balanceOf[to2]\n        );\n        balanceOf[from] -= value1 + value2;\n        balanceOf[to1] += value1;\n        emit Transfer(from, to1, value1);\n        if (value2 > 0) {\n            balanceOf[to2] += value2;\n            emit Transfer(from, to2, value2);\n        }\n    }\n\n    /**\n     * Internal method that makes sure that the given signature corresponds to a given data and is made by `signer`.\n     * It utilizes three (four) standards of message signing in Ethereum, as at the moment of this smart contract\n     * development there is no single signing standard defined. For example, Metamask and Geth both support\n     * personal_sign standard, SignTypedData is only supported by Matamask, Trezor does not support \"widely adopted\"\n     * Ethereum personal_sign but rather personal_sign with fixed prefix and so on.\n     * Note that it is always possible to forge any of these signatures using the private key, the problem is that\n     * third-party wallets must adopt a single standard for signing messages.\n     */\n    function requireSignature (\n        bytes32 data, address signer, uint256 deadline, uint256 sigId, bytes sig, sigStandard std, sigDestination signDest\n    ) internal {\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n        assembly { // solium-disable-line security/no-inline-assembly\n            r := mload(add(sig, 32))\n            s := mload(add(sig, 64))\n            v := byte(0, mload(add(sig, 96)))\n        }\n        if (v < 27)\n            v += 27;\n        require(block.timestamp <= deadline && !usedSigIds[signer][sigId]); // solium-disable-line security/no-block-members\n        if (std == sigStandard.typed) { // Typed signature. This is the most likely scenario to be used and accepted\n            require(\n                signer == ecrecover(\n                    keccak256(\n                        signDest == sigDestination.transfer\n                            ? sigDestinationTransfer\n                            : signDest == sigDestination.approve\n                                ? sigDestinationApprove\n                                : signDest == sigDestination.approveAndCall\n                                    ? sigDestinationApproveAndCall\n                                    : sigDestinationTransferFrom,\n                        data\n                    ),\n                    v, r, s\n                )\n            );\n        } else if (std == sigStandard.personal) { // Ethereum signed message signature (Geth and Trezor)\n            require(\n                signer == ecrecover(keccak256(ethSignedMessagePrefix, \"32\", data), v, r, s) // Geth-adopted\n                ||\n                signer == ecrecover(keccak256(ethSignedMessagePrefix, \"\\x20\", data), v, r, s) // Trezor-adopted\n            );\n        } else { // == 2; Signed string hash signature (the most expensive but universal)\n            require(\n                signer == ecrecover(keccak256(ethSignedMessagePrefix, \"64\", hexToString(data)), v, r, s) // Geth\n                ||\n                signer == ecrecover(keccak256(ethSignedMessagePrefix, \"\\x40\", hexToString(data)), v, r, s) // Trezor\n            );\n        }\n        usedSigIds[signer][sigId] = true;\n    }\n\n    /**\n     * Utility costly function to encode bytes HEX representation as string.\n     * @param sig - signature to encode.\n     */\n    function hexToString (bytes32 sig) internal pure returns (bytes) { // /to-try/ convert to two uint256 and test gas\n        bytes memory str = new bytes(64);\n        for (uint8 i = 0; i < 32; ++i) {\n            str[2 * i] = byte((uint8(sig[i]) / 16 < 10 ? 48 : 87) + uint8(sig[i]) / 16);\n            str[2 * i + 1] = byte((uint8(sig[i]) % 16 < 10 ? 48 : 87) + (uint8(sig[i]) % 16));\n        }\n        return str;\n    }\n\n    /**\n     * Transfer `value` tokens to `to` address from the account of sender.\n     * @param to - the address of the recipient\n     * @param value - the amount to send\n     */\n    function transfer (address to, uint256 value) public returns (bool) {\n        internalTransfer(msg.sender, to, value);\n        return true;\n    }\n\n    /**\n     * This function distincts transaction signer from transaction executor. It allows anyone to transfer tokens\n     * from the `from` account by providing a valid signature, which can only be obtained from the `from` account\n     * owner.\n     * Note that passed parameter sigId is unique and cannot be passed twice (prevents replay attacks). When there's\n     * a need to make signature once again (because the first on is lost or whatever), user should sign the message\n     * with the same sigId, thus ensuring that the previous signature won't be used if the new one passes.\n     * Use case: the user wants to send some tokens to other user or smart contract, but don't have ether to do so.\n     * @param from - the account giving its signature to transfer `value` tokens to `to` address\n     * @param to - the account receiving `value` tokens\n     * @param value - the value in tokens to transfer\n     * @param fee - a fee to pay to transaction executor (`msg.sender`)\n     * @param deadline - until when the signature is valid\n     * @param sigId - signature unique ID. Signatures made with the same signature ID cannot be submitted twice\n     * @param sig - signature made by `from`, which is the proof of `from`'s agreement with the above parameters\n     * @param sigStd - chosen standard for signature validation. The signer must explicitly tell which standard they use\n     */\n    function transferViaSignature (\n        address     from,\n        address     to,\n        uint256     value,\n        uint256     fee,\n        uint256     deadline,\n        uint256     sigId,\n        bytes       sig,\n        sigStandard sigStd\n    ) external returns (bool) {\n        requireSignature(\n            keccak256(address(this), from, to, value, fee, deadline, sigId),\n            from, deadline, sigId, sig, sigStd, sigDestination.transfer\n        );\n        internalDoubleTransfer(from, to, value, msg.sender, fee);\n        return true;\n    }\n\n    /**\n     * Allow `spender` to take `value` tokens from the transaction sender's account.\n     * Beware that changing an allowance with this method brings the risk that `spender` may use both the old\n     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     * @param spender - the address authorized to spend\n     * @param value - the maximum amount they can spend\n     */\n    function approve (address spender, uint256 value) public returns (bool) {\n        allowance[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n        return true;\n    }\n\n    /**\n     * Same as `transferViaSignature`, but for `approve`.\n     * Use case: the user wants to set an allowance for the smart contract or another user without having ether on their\n     * balance.\n     * @param from - the account to approve withdrawal from, which signed all below parameters\n     * @param spender - the account allowed to withdraw tokens from `from` address\n     * @param value - the value in tokens to approve to withdraw\n     * @param fee - a fee to pay to transaction executor (`msg.sender`)\n     * @param deadline - until when the signature is valid\n     * @param sigId - signature unique ID. Signatures made with the same signature ID cannot be submitted twice\n     * @param sig - signature made by `from`, which is the proof of `from`'s agreement with the above parameters\n     * @param sigStd - chosen standard for signature validation. The signer must explicitely tell which standard they use\n     */\n    function approveViaSignature (\n        address     from,\n        address     spender,\n        uint256     value,\n        uint256     fee,\n        uint256     deadline,\n        uint256     sigId,\n        bytes       sig,\n        sigStandard sigStd\n    ) external returns (bool) {\n        requireSignature(\n            keccak256(address(this), from, spender, value, fee, deadline, sigId),\n            from, deadline, sigId, sig, sigStd, sigDestination.approve\n        );\n        allowance[from][spender] = value;\n        emit Approval(from, spender, value);\n        internalTransfer(from, msg.sender, fee);\n        return true;\n    }\n\n    /**\n     * Transfer `value` tokens to `to` address from the `from` account, using the previously set allowance.\n     * @param from - the address to transfer tokens from\n     * @param to - the address of the recipient\n     * @param value - the amount to send\n     */\n    function transferFrom (address from, address to, uint256 value) public returns (bool) {\n        require(value <= allowance[from][msg.sender]); // Test whether allowance was set\n        allowance[from][msg.sender] -= value;\n        internalTransfer(from, to, value);\n        return true;\n    }\n\n    /**\n     * Same as `transferViaSignature`, but for `transferFrom`.\n     * Use case: the user wants to withdraw tokens from a smart contract or another user who allowed the user to do so.\n     * Important note: fee is subtracted from `value` before it reaches `to`.\n     * @param from - the address to transfer tokens from\n     * @param to - the address of the recipient\n     * @param value - the amount to send\n     */\n    function transferFromViaSignature (\n        address     signer,\n        address     from,\n        address     to,\n        uint256     value,\n        uint256     fee,\n        uint256     deadline,\n        uint256     sigId,\n        bytes       sig,\n        sigStandard sigStd\n    ) external returns (bool) {\n        requireSignature(\n            keccak256(address(this), signer, from, to, value, fee, deadline, sigId),\n            signer, deadline, sigId, sig, sigStd, sigDestination.transferFrom\n        );\n        require(value <= allowance[from][signer] && value >= fee);\n        allowance[from][signer] -= value;\n        internalDoubleTransfer(from, to, value - fee, msg.sender, fee);\n        return true;\n    }\n\n    /**\n     * Utility function, which acts the same as approve(...) does, but also calls `receiveApproval` function on a\n     * `spender` address, which is usually the address of the smart contract. In the same call, smart contract can\n     * withdraw tokens from the sender's account and receive additional `extraData` for processing.\n     * @param spender - the address to be authorized to spend tokens\n     * @param value - the max amount the `spender` can withdraw\n     * @param extraData - some extra information to send to the approved contract\n     */\n    function approveAndCall (address spender, uint256 value, bytes extraData) public returns (bool) {\n        approve(spender, value);\n        tokenRecipient(spender).receiveApproval(msg.sender, value, this, extraData);\n        return true;\n    }\n\n    /**\n     * Same as `approveViaSignature`, but for `approveAndCall`.\n     * Use case: the user wants to send tokens to the smart contract and pass additional data within one transaction.\n     * @param from - the account to approve withdrawal from, which signed all below parameters\n     * @param spender - the account allowed to withdraw tokens from `from` address (in this case, smart contract only)\n     * @param value - the value in tokens to approve to withdraw\n     * @param extraData - additional data to pass to the `spender` smart contract\n     * @param fee - a fee to pay to transaction executor (`msg.sender`)\n     * @param deadline - until when the signature is valid\n     * @param sigId - signature unique ID. Signatures made with the same signature ID cannot be submitted twice\n     * @param sig - signature made by `from`, which is the proof of `from`'s agreement with the above parameters\n     * @param sigStd - chosen standard for signature validation. The signer must explicitely tell which standard they use\n     */\n    function approveAndCallViaSignature (\n        address     from,\n        address     spender,\n        uint256     value,\n        bytes       extraData,\n        uint256     fee,\n        uint256     deadline,\n        uint256     sigId,\n        bytes       sig,\n        sigStandard sigStd\n    ) external returns (bool) {\n        requireSignature(\n            keccak256(address(this), from, spender, value, extraData, fee, deadline, sigId),\n            from, deadline, sigId, sig, sigStd, sigDestination.approveAndCall\n        );\n        allowance[from][spender] = value;\n        emit Approval(from, spender, value);\n        tokenRecipient(spender).receiveApproval(from, value, this, extraData);\n        internalTransfer(from, msg.sender, fee);\n        return true;\n    }\n\n    /**\n     * `tokenDistributor` is authorized to distribute tokens to the parties who participated in the token sale by the\n     * time the `lastMint` function is triggered, which closes the ability to mint any new tokens forever.\n     * @param recipients - Addresses of token recipients\n     * @param amounts - Corresponding amount of each token recipient in `recipients`\n     */\n    function multiMint (address[] recipients, uint256[] amounts) external {\n        \n        // Once the token distribution ends, tokenDistributor will become 0x0 and multiMint will never work\n        require(tokenDistributor != 0x0 && tokenDistributor == msg.sender && recipients.length == amounts.length);\n\n        uint total = 0;\n        // SWC-101-Integer Overflow and Underflow: L375-376\n        for (uint i = 0; i < recipients.length; ++i) {\n            balanceOf[recipients[i]] += amounts[i];\n            total += amounts[i];\n            emit Transfer(0x0, recipients[i], amounts[i]);\n        }\n\n        totalSupply += total;\n        \n    }\n\n    /**\n     * The last mint that will ever happen. Disables the multiMint function and mints remaining 40% of tokens (in\n     * regard of 60% tokens minted before) to a `tokenDistributor` address.\n     */\n    function lastMint () external {\n\n        require(tokenDistributor != 0x0 && tokenDistributor == msg.sender && totalSupply > 0);\n\n        uint256 remaining = totalSupply * 40 / 60; // Portion of tokens for DreamTeam (40%)\n        // SWC-101-Integer Overflow and Underflow: L399\n        // To make the total supply rounded (no fractional part), subtract the fractional part from DreamTeam's balance\n        uint256 fractionalPart = (remaining + totalSupply) % (uint256(10) ** decimals);\n        if (fractionalPart <= remaining)\n            remaining -= fractionalPart; // Remove the fractional part to round the totalSupply\n\n        balanceOf[tokenDistributor] += remaining;\n        emit Transfer(0x0, tokenDistributor, remaining);\n\n        totalSupply += remaining;\n        tokenDistributor = 0x0; // Disable multiMint and lastMint functions forever\n\n    }\n\n    /**\n     * ERC20 token is not designed to hold any tokens itself. This function allows to rescue tokens accidentally sent\n     * to the address of this smart contract.\n     * @param tokenContract - ERC-20 compatible token\n     * @param value - amount to rescue\n     */\n    function rescueTokens (DTT tokenContract, uint256 value) public {\n        require(msg.sender == rescueAccount);\n        tokenContract.approve(rescueAccount, value);\n    }\n\n    /**\n     * Utility function that allows to change the rescueAccount address.\n     * @param newRescueAccount - account which will be authorized to rescue tokens.\n     */\n    function changeRescueAccount (address newRescueAccount) public {\n        require(msg.sender == rescueAccount);\n        rescueAccount = newRescueAccount;\n    }\n\n}",
        "function": null,
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinfabrik-DreamTeam Token Audit/smart-contracts-616ed2538526001d25b75680e4d3bd8f3c4deac2/contracts/token/DTT.sol",
        "vulnerability": "Integer Overflow",
        "check": "TP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract DTT {\n\n    string public name;\n    string public symbol;\n    uint8 public decimals = 6; // Makes JavaScript able to handle precise calculations (until totalSupply < 9 milliards)\n    uint256 public totalSupply;\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n    mapping(address => mapping(uint => bool)) public usedSigIds; // Used in *ViaSignature(..)\n    address public tokenDistributor; // Account authorized to distribute tokens only during the token distribution event\n    address public rescueAccount; // Account authorized to withdraw tokens accidentally sent to this contract\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    bytes public ethSignedMessagePrefix = \"\\x19Ethereum Signed Message:\\n\";\n    enum sigStandard { typed, personal, stringHex }\n    enum sigDestination { transfer, approve, approveAndCall, transferFrom }\n    bytes32 public sigDestinationTransfer = keccak256(\n        \"address Token Contract Address\",\n        \"address Sender's Address\",\n        \"address Recipient's Address\",\n        \"uint256 Amount to Transfer (last six digits are decimals)\",\n        \"uint256 Fee in Tokens Paid to Executor (last six digits are decimals)\",\n        \"uint256 Signature Expiration Timestamp (unix timestamp)\",\n        \"uint256 Signature ID\"\n    ); // `transferViaSignature`: keccak256(address(this), from, to, value, fee, deadline, sigId)\n    bytes32 public sigDestinationTransferFrom = keccak256(\n        \"address Token Contract Address\",\n        \"address Address Approved for Withdraw\",\n        \"address Account to Withdraw From\",\n        \"address Withdrawal Recipient Address\",\n        \"uint256 Amount to Transfer (last six digits are decimals)\",\n        \"uint256 Fee in Tokens Paid to Executor (last six digits are decimals)\",\n        \"uint256 Signature Expiration Timestamp (unix timestamp)\",\n        \"uint256 Signature ID\"\n    ); // `transferFromViaSignature`: keccak256(address(this), signer, from, to, value, fee, deadline, sigId)\n    bytes32 public sigDestinationApprove = keccak256(\n        \"address Token Contract Address\",\n        \"address Withdrawal Approval Address\",\n        \"address Withdrawal Recipient Address\",\n        \"uint256 Amount to Transfer (last six digits are decimals)\",\n        \"uint256 Fee in Tokens Paid to Executor (last six digits are decimals)\",\n        \"uint256 Signature Expiration Timestamp (unix timestamp)\",\n        \"uint256 Signature ID\"\n    ); // `approveViaSignature`: keccak256(address(this), from, spender, value, fee, deadline, sigId)\n    bytes32 public sigDestinationApproveAndCall = keccak256( // `approveAndCallViaSignature`\n        \"address Token Contract Address\",\n        \"address Withdrawal Approval Address\",\n        \"address Withdrawal Recipient Address\",\n        \"uint256 Amount to Transfer (last six digits are decimals)\",\n        \"bytes Data to Transfer\",\n        \"uint256 Fee in Tokens Paid to Executor (last six digits are decimals)\",\n        \"uint256 Signature Expiration Timestamp (unix timestamp)\",\n        \"uint256 Signature ID\"\n    ); // `approveAndCallViaSignature`: keccak256(address(this), from, spender, value, extraData, fee, deadline, sigId)\n\n    constructor (string tokenName, string tokenSymbol) public {\n        name = tokenName;\n        symbol = tokenSymbol;\n        rescueAccount = tokenDistributor = msg.sender;\n    }\n\n    /**\n     * Utility internal function used to safely transfer `value` tokens `from` -> `to`. Throws if transfer is impossible.\n     */\n    function internalTransfer (address from, address to, uint value) internal {\n        // Prevent people from accidentally burning their tokens + uint256 wrap prevention\n        require(to != 0x0 && balanceOf[from] >= value && balanceOf[to] + value >= balanceOf[to]);\n        balanceOf[from] -= value;\n        balanceOf[to] += value;\n        emit Transfer(from, to, value);\n    }\n\n    /**\n     * Utility internal function used to safely transfer `value1` tokens `from` -> `to1`, and `value2` tokens\n     * `from` -> `to2`, minimizing gas usage (calling `internalTransfer` twice is more expensive). Throws if\n     * transfers are impossible.\n     */\n    function internalDoubleTransfer (address from, address to1, uint value1, address to2, uint value2) internal {\n        require( // Prevent people from accidentally burning their tokens + uint256 wrap prevention\n            to1 != 0x0 && to2 != 0x0 && value1 + value2 >= value1 && balanceOf[from] >= value1 + value2\n            && balanceOf[to1] + value1 >= balanceOf[to1] && balanceOf[to2] + value2 >= balanceOf[to2]\n        );\n        balanceOf[from] -= value1 + value2;\n        balanceOf[to1] += value1;\n        emit Transfer(from, to1, value1);\n        if (value2 > 0) {\n            balanceOf[to2] += value2;\n            emit Transfer(from, to2, value2);\n        }\n    }\n\n    /**\n     * Internal method that makes sure that the given signature corresponds to a given data and is made by `signer`.\n     * It utilizes three (four) standards of message signing in Ethereum, as at the moment of this smart contract\n     * development there is no single signing standard defined. For example, Metamask and Geth both support\n     * personal_sign standard, SignTypedData is only supported by Matamask, Trezor does not support \"widely adopted\"\n     * Ethereum personal_sign but rather personal_sign with fixed prefix and so on.\n     * Note that it is always possible to forge any of these signatures using the private key, the problem is that\n     * third-party wallets must adopt a single standard for signing messages.\n     */\n    function requireSignature (\n        bytes32 data, address signer, uint256 deadline, uint256 sigId, bytes sig, sigStandard std, sigDestination signDest\n    ) internal {\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n        assembly { // solium-disable-line security/no-inline-assembly\n            r := mload(add(sig, 32))\n            s := mload(add(sig, 64))\n            v := byte(0, mload(add(sig, 96)))\n        }\n        if (v < 27)\n            v += 27;\n        require(block.timestamp <= deadline && !usedSigIds[signer][sigId]); // solium-disable-line security/no-block-members\n        if (std == sigStandard.typed) { // Typed signature. This is the most likely scenario to be used and accepted\n            require(\n                signer == ecrecover(\n                    keccak256(\n                        signDest == sigDestination.transfer\n                            ? sigDestinationTransfer\n                            : signDest == sigDestination.approve\n                                ? sigDestinationApprove\n                                : signDest == sigDestination.approveAndCall\n                                    ? sigDestinationApproveAndCall\n                                    : sigDestinationTransferFrom,\n                        data\n                    ),\n                    v, r, s\n                )\n            );\n        } else if (std == sigStandard.personal) { // Ethereum signed message signature (Geth and Trezor)\n            require(\n                signer == ecrecover(keccak256(ethSignedMessagePrefix, \"32\", data), v, r, s) // Geth-adopted\n                ||\n                signer == ecrecover(keccak256(ethSignedMessagePrefix, \"\\x20\", data), v, r, s) // Trezor-adopted\n            );\n        } else { // == 2; Signed string hash signature (the most expensive but universal)\n            require(\n                signer == ecrecover(keccak256(ethSignedMessagePrefix, \"64\", hexToString(data)), v, r, s) // Geth\n                ||\n                signer == ecrecover(keccak256(ethSignedMessagePrefix, \"\\x40\", hexToString(data)), v, r, s) // Trezor\n            );\n        }\n        usedSigIds[signer][sigId] = true;\n    }\n\n    /**\n     * Utility costly function to encode bytes HEX representation as string.\n     * @param sig - signature to encode.\n     */\n    function hexToString (bytes32 sig) internal pure returns (bytes) { // /to-try/ convert to two uint256 and test gas\n        bytes memory str = new bytes(64);\n        for (uint8 i = 0; i < 32; ++i) {\n            str[2 * i] = byte((uint8(sig[i]) / 16 < 10 ? 48 : 87) + uint8(sig[i]) / 16);\n            str[2 * i + 1] = byte((uint8(sig[i]) % 16 < 10 ? 48 : 87) + (uint8(sig[i]) % 16));\n        }\n        return str;\n    }\n\n    /**\n     * Transfer `value` tokens to `to` address from the account of sender.\n     * @param to - the address of the recipient\n     * @param value - the amount to send\n     */\n    function transfer (address to, uint256 value) public returns (bool) {\n        internalTransfer(msg.sender, to, value);\n        return true;\n    }\n\n    /**\n     * This function distincts transaction signer from transaction executor. It allows anyone to transfer tokens\n     * from the `from` account by providing a valid signature, which can only be obtained from the `from` account\n     * owner.\n     * Note that passed parameter sigId is unique and cannot be passed twice (prevents replay attacks). When there's\n     * a need to make signature once again (because the first on is lost or whatever), user should sign the message\n     * with the same sigId, thus ensuring that the previous signature won't be used if the new one passes.\n     * Use case: the user wants to send some tokens to other user or smart contract, but don't have ether to do so.\n     * @param from - the account giving its signature to transfer `value` tokens to `to` address\n     * @param to - the account receiving `value` tokens\n     * @param value - the value in tokens to transfer\n     * @param fee - a fee to pay to transaction executor (`msg.sender`)\n     * @param deadline - until when the signature is valid\n     * @param sigId - signature unique ID. Signatures made with the same signature ID cannot be submitted twice\n     * @param sig - signature made by `from`, which is the proof of `from`'s agreement with the above parameters\n     * @param sigStd - chosen standard for signature validation. The signer must explicitly tell which standard they use\n     */\n    function transferViaSignature (\n        address     from,\n        address     to,\n        uint256     value,\n        uint256     fee,\n        uint256     deadline,\n        uint256     sigId,\n        bytes       sig,\n        sigStandard sigStd\n    ) external returns (bool) {\n        requireSignature(\n            keccak256(address(this), from, to, value, fee, deadline, sigId),\n            from, deadline, sigId, sig, sigStd, sigDestination.transfer\n        );\n        internalDoubleTransfer(from, to, value, msg.sender, fee);\n        return true;\n    }\n\n    /**\n     * Allow `spender` to take `value` tokens from the transaction sender's account.\n     * Beware that changing an allowance with this method brings the risk that `spender` may use both the old\n     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     * @param spender - the address authorized to spend\n     * @param value - the maximum amount they can spend\n     */\n    function approve (address spender, uint256 value) public returns (bool) {\n        allowance[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n        return true;\n    }\n\n    /**\n     * Same as `transferViaSignature`, but for `approve`.\n     * Use case: the user wants to set an allowance for the smart contract or another user without having ether on their\n     * balance.\n     * @param from - the account to approve withdrawal from, which signed all below parameters\n     * @param spender - the account allowed to withdraw tokens from `from` address\n     * @param value - the value in tokens to approve to withdraw\n     * @param fee - a fee to pay to transaction executor (`msg.sender`)\n     * @param deadline - until when the signature is valid\n     * @param sigId - signature unique ID. Signatures made with the same signature ID cannot be submitted twice\n     * @param sig - signature made by `from`, which is the proof of `from`'s agreement with the above parameters\n     * @param sigStd - chosen standard for signature validation. The signer must explicitely tell which standard they use\n     */\n    function approveViaSignature (\n        address     from,\n        address     spender,\n        uint256     value,\n        uint256     fee,\n        uint256     deadline,\n        uint256     sigId,\n        bytes       sig,\n        sigStandard sigStd\n    ) external returns (bool) {\n        requireSignature(\n            keccak256(address(this), from, spender, value, fee, deadline, sigId),\n            from, deadline, sigId, sig, sigStd, sigDestination.approve\n        );\n        allowance[from][spender] = value;\n        emit Approval(from, spender, value);\n        internalTransfer(from, msg.sender, fee);\n        return true;\n    }\n\n    /**\n     * Transfer `value` tokens to `to` address from the `from` account, using the previously set allowance.\n     * @param from - the address to transfer tokens from\n     * @param to - the address of the recipient\n     * @param value - the amount to send\n     */\n    function transferFrom (address from, address to, uint256 value) public returns (bool) {\n        require(value <= allowance[from][msg.sender]); // Test whether allowance was set\n        allowance[from][msg.sender] -= value;\n        internalTransfer(from, to, value);\n        return true;\n    }\n\n    /**\n     * Same as `transferViaSignature`, but for `transferFrom`.\n     * Use case: the user wants to withdraw tokens from a smart contract or another user who allowed the user to do so.\n     * Important note: fee is subtracted from `value` before it reaches `to`.\n     * @param from - the address to transfer tokens from\n     * @param to - the address of the recipient\n     * @param value - the amount to send\n     */\n    function transferFromViaSignature (\n        address     signer,\n        address     from,\n        address     to,\n        uint256     value,\n        uint256     fee,\n        uint256     deadline,\n        uint256     sigId,\n        bytes       sig,\n        sigStandard sigStd\n    ) external returns (bool) {\n        requireSignature(\n            keccak256(address(this), signer, from, to, value, fee, deadline, sigId),\n            signer, deadline, sigId, sig, sigStd, sigDestination.transferFrom\n        );\n        require(value <= allowance[from][signer] && value >= fee);\n        allowance[from][signer] -= value;\n        internalDoubleTransfer(from, to, value - fee, msg.sender, fee);\n        return true;\n    }\n\n    /**\n     * Utility function, which acts the same as approve(...) does, but also calls `receiveApproval` function on a\n     * `spender` address, which is usually the address of the smart contract. In the same call, smart contract can\n     * withdraw tokens from the sender's account and receive additional `extraData` for processing.\n     * @param spender - the address to be authorized to spend tokens\n     * @param value - the max amount the `spender` can withdraw\n     * @param extraData - some extra information to send to the approved contract\n     */\n    function approveAndCall (address spender, uint256 value, bytes extraData) public returns (bool) {\n        approve(spender, value);\n        tokenRecipient(spender).receiveApproval(msg.sender, value, this, extraData);\n        return true;\n    }\n\n    /**\n     * Same as `approveViaSignature`, but for `approveAndCall`.\n     * Use case: the user wants to send tokens to the smart contract and pass additional data within one transaction.\n     * @param from - the account to approve withdrawal from, which signed all below parameters\n     * @param spender - the account allowed to withdraw tokens from `from` address (in this case, smart contract only)\n     * @param value - the value in tokens to approve to withdraw\n     * @param extraData - additional data to pass to the `spender` smart contract\n     * @param fee - a fee to pay to transaction executor (`msg.sender`)\n     * @param deadline - until when the signature is valid\n     * @param sigId - signature unique ID. Signatures made with the same signature ID cannot be submitted twice\n     * @param sig - signature made by `from`, which is the proof of `from`'s agreement with the above parameters\n     * @param sigStd - chosen standard for signature validation. The signer must explicitely tell which standard they use\n     */\n    function approveAndCallViaSignature (\n        address     from,\n        address     spender,\n        uint256     value,\n        bytes       extraData,\n        uint256     fee,\n        uint256     deadline,\n        uint256     sigId,\n        bytes       sig,\n        sigStandard sigStd\n    ) external returns (bool) {\n        requireSignature(\n            keccak256(address(this), from, spender, value, extraData, fee, deadline, sigId),\n            from, deadline, sigId, sig, sigStd, sigDestination.approveAndCall\n        );\n        allowance[from][spender] = value;\n        emit Approval(from, spender, value);\n        tokenRecipient(spender).receiveApproval(from, value, this, extraData);\n        internalTransfer(from, msg.sender, fee);\n        return true;\n    }\n\n    /**\n     * `tokenDistributor` is authorized to distribute tokens to the parties who participated in the token sale by the\n     * time the `lastMint` function is triggered, which closes the ability to mint any new tokens forever.\n     * @param recipients - Addresses of token recipients\n     * @param amounts - Corresponding amount of each token recipient in `recipients`\n     */\n    function multiMint (address[] recipients, uint256[] amounts) external {\n        \n        // Once the token distribution ends, tokenDistributor will become 0x0 and multiMint will never work\n        require(tokenDistributor != 0x0 && tokenDistributor == msg.sender && recipients.length == amounts.length);\n\n        uint total = 0;\n        // SWC-101-Integer Overflow and Underflow: L375-376\n        for (uint i = 0; i < recipients.length; ++i) {\n            balanceOf[recipients[i]] += amounts[i];\n            total += amounts[i];\n            emit Transfer(0x0, recipients[i], amounts[i]);\n        }\n\n        totalSupply += total;\n        \n    }\n\n    /**\n     * The last mint that will ever happen. Disables the multiMint function and mints remaining 40% of tokens (in\n     * regard of 60% tokens minted before) to a `tokenDistributor` address.\n     */\n    function lastMint () external {\n\n        require(tokenDistributor != 0x0 && tokenDistributor == msg.sender && totalSupply > 0);\n\n        uint256 remaining = totalSupply * 40 / 60; // Portion of tokens for DreamTeam (40%)\n        // SWC-101-Integer Overflow and Underflow: L399\n        // To make the total supply rounded (no fractional part), subtract the fractional part from DreamTeam's balance\n        uint256 fractionalPart = (remaining + totalSupply) % (uint256(10) ** decimals);\n        if (fractionalPart <= remaining)\n            remaining -= fractionalPart; // Remove the fractional part to round the totalSupply\n\n        balanceOf[tokenDistributor] += remaining;\n        emit Transfer(0x0, tokenDistributor, remaining);\n\n        totalSupply += remaining;\n        tokenDistributor = 0x0; // Disable multiMint and lastMint functions forever\n\n    }\n\n    /**\n     * ERC20 token is not designed to hold any tokens itself. This function allows to rescue tokens accidentally sent\n     * to the address of this smart contract.\n     * @param tokenContract - ERC-20 compatible token\n     * @param value - amount to rescue\n     */\n    function rescueTokens (DTT tokenContract, uint256 value) public {\n        require(msg.sender == rescueAccount);\n        tokenContract.approve(rescueAccount, value);\n    }\n\n    /**\n     * Utility function that allows to change the rescueAccount address.\n     * @param newRescueAccount - account which will be authorized to rescue tokens.\n     */\n    function changeRescueAccount (address newRescueAccount) public {\n        require(msg.sender == rescueAccount);\n        rescueAccount = newRescueAccount;\n    }\n\n}",
        "function": null,
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinfabrik-DreamTeam Token Audit/smart-contracts-616ed2538526001d25b75680e4d3bd8f3c4deac2/contracts/token/DTT.sol",
        "vulnerability": "Integer Underflow",
        "check": "TP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract BasicToken is ERC20Basic {\n\tusing SafeMath for uint256;\n\n\tmapping(address => uint256) balances;\n\n\tuint256 totalSupply_;\n\n\t/**\n\t* @dev total number of tokens in existence\n\t*/\n\tfunction totalSupply() public view returns (uint256) {\n\t\treturn totalSupply_;\n\t}\n\n\t/**\n\t* @dev transfer token for a specified address\n\t* @param _to The address to transfer to.\n\t* @param _value The amount to be transferred.\n\t*/\n\tfunction transfer(address _to, uint256 _value) public returns (bool) {\n\t\trequire(_to != address(0));\n\t\trequire(_value <= balances[msg.sender]);\n\n\t\tbalances[msg.sender] = balances[msg.sender].sub(_value);\n\t\tbalances[_to] = balances[_to].add(_value);\n\t\temit Transfer(msg.sender, _to, _value);\n\t\treturn true;\n\t}\n\n\t/**\n\t* @dev Gets the balance of the specified address.\n\t* @param _owner The address to query the the balance of.\n\t* @return An uint256 representing the amount owned by the passed address.\n\t*/\n\tfunction balanceOf(address _owner) public view returns (uint256) {\n\t\treturn balances[_owner];\n\t}\n\n}",
        "function": null,
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Chainsulting-FIN/FinToken/FinToken.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract FinToken is StandardToken {\n\taddress public owner;\n\t\n\tstring public constant name = \"FIN Token\"; \n\tstring public constant symbol = \"FIN\";\n\tuint8 public constant decimals = 18;\n\n// SWC-101-Integer Overflow and Underflow: L225\n\tuint256 public constant INITIAL_SUPPLY = 2623304 * (10 ** uint256(decimals));\n\t\n\tmapping (address => bool) internal verificatorAddresses;\n\tmapping (address => bool) internal verifiedAddresses;\n\t\n\tevent AddVerificator(address indexed verificator);\n\tevent RemoveVerificator(address indexed verificator);\n\t\n\tevent AddVerified(address indexed verificatorAddress, address indexed verified);\n\tevent RemoveVerified(address indexed verificatorAddress, address indexed verified);\n\t\n\tevent Mint(address indexed to, uint256 amount);\n\t\n\tmodifier onlyOwner() {\n\t\trequire(msg.sender == owner);\n\t\t_;\n\t}\n\t\n\tmodifier onlyVerificator() {\n\t\trequire(isVerificator(msg.sender));\n\t\t_;\n\t}\n\t\n\tmodifier onlyVerified(address _from, address _to) {\n\t\trequire(isVerified(_from));\n\t\trequire(isVerified(_to));\n\t\t_;\n\t}\n\n\tfunction FinToken() public {\n\t\towner = msg.sender;\n\t\ttotalSupply_ = INITIAL_SUPPLY;\n\t\tbalances[msg.sender] = INITIAL_SUPPLY;\n\t\temit Transfer(0x0, msg.sender, INITIAL_SUPPLY);\n\t}\n\t\n\tfunction addVerificatorAddress(address addr) public onlyOwner {\n\t\tverificatorAddresses[addr] = true;\n\t\temit AddVerificator(addr);\n\t}\n\t\n\tfunction removeVerificatorAddress(address addr) public onlyOwner {\n\t\tdelete verificatorAddresses[addr];\n\t\temit RemoveVerificator(addr);\n\t}\n\t\n\tfunction isVerificator(address addr) public constant returns (bool) {\n\t\treturn verificatorAddresses[addr];\n\t}\n\t\t\n\tfunction addVerifiedAddress(address addr) public onlyVerificator {\n\t\tverifiedAddresses[addr] = true;\n\t\temit AddVerified(msg.sender, addr);\n\t}\n\t\n\tfunction removeVerifiedAddress(address addr) public onlyVerificator {\n\t\tdelete verifiedAddresses[addr];\n\t\temit RemoveVerified(msg.sender, addr);\n\t}\n\t\n\tfunction isVerified(address addr) public constant returns (bool) {\n\t\treturn verifiedAddresses[addr];\n\t}\n\t\n\tfunction transfer(address _to, uint256 _value) public onlyVerified(msg.sender, _to) returns (bool) {\n\t\tsuper.transfer(_to, _value);\n\t}\n\t\n\tfunction transferFrom(address _from, address _to, uint256 _value) public onlyVerified(_from, _to) returns (bool) {\n\t    super.transferFrom(_from, _to, _value);\n\t}\n}",
        "function": null,
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Chainsulting-FIN/FinToken/FinToken.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract StandardToken is ERC20, BasicToken {\n\n\tmapping (address => mapping (address => uint256)) internal allowed;\n\n\n\t/**\n\t * @dev Transfer tokens from one address to another\n\t * @param _from address The address which you want to send tokens from\n\t * @param _to address The address which you want to transfer to\n\t * @param _value uint256 the amount of tokens to be transferred\n\t */\n\tfunction transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n\t\trequire(_to != address(0));\n\t\trequire(_value <= balances[_from]);\n\t\trequire(_value <= allowed[_from][msg.sender]);\n\n\t\tbalances[_from] = balances[_from].sub(_value);\n\t\tbalances[_to] = balances[_to].add(_value);\n\t\tallowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n\t\temit Transfer(_from, _to, _value);\n\t\treturn true;\n\t}\n\n\t/**\n\t * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n\t *\n\t * Beware that changing an allowance with this method brings the risk that someone may use both the old\n\t * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n\t * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n\t * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n\t * @param _spender The address which will spend the funds.\n\t * @param _value The amount of tokens to be spent.\n\t */\n\tfunction approve(address _spender, uint256 _value) public returns (bool) {\n\t\tallowed[msg.sender][_spender] = _value;\n\t\temit Approval(msg.sender, _spender, _value);\n\t\treturn true;\n\t}\n\n\t/**\n\t * @dev Function to check the amount of tokens that an owner allowed to a spender.\n\t * @param _owner address The address which owns the funds.\n\t * @param _spender address The address which will spend the funds.\n\t * @return A uint256 specifying the amount of tokens still available for the spender.\n\t */\n\tfunction allowance(address _owner, address _spender) public view returns (uint256) {\n\t\treturn allowed[_owner][_spender];\n\t}\n\n\t/**\n\t * @dev Increase the amount of tokens that an owner allowed to a spender.\n\t *\n\t * approve should be called when allowed[_spender] == 0. To increment\n\t * allowed value is better to use this function to avoid 2 calls (and wait until\n\t * the first transaction is mined)\n\t * From MonolithDAO Token.sol\n\t * @param _spender The address which will spend the funds.\n\t * @param _addedValue The amount of tokens to increase the allowance by.\n\t */\n\tfunction increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n\t\tallowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n\t\temit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n\t\treturn true;\n\t}\n\n\t/**\n\t * @dev Decrease the amount of tokens that an owner allowed to a spender.\n\t *\n\t * approve should be called when allowed[_spender] == 0. To decrement\n\t * allowed value is better to use this function to avoid 2 calls (and wait until\n\t * the first transaction is mined)\n\t * From MonolithDAO Token.sol\n\t * @param _spender The address which will spend the funds.\n\t * @param _subtractedValue The amount of tokens to decrease the allowance by.\n\t */\n\tfunction decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n\t\tuint oldValue = allowed[msg.sender][_spender];\n\t\tif (_subtractedValue > oldValue) {\n\t\t\tallowed[msg.sender][_spender] = 0;\n\t\t} else {\n\t\t\tallowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n\t\t}\n\t\temit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n\t\treturn true;\n\t}\n\n}",
        "function": null,
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Chainsulting-FIN/FinToken/FinToken.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract TMC_Contract is ERC20Interface, Owned {\n\tstring public constant symbol = \"TMC\";\n\tstring public constant name = \"TMC Token\";\n\tuint8 public constant decimals = 18;\n\tuint256 public constant totalSupply = 500000000000000000000000000;\n\n\tbool public stopped;\n\n\tmapping (address => int8) public blackList;\n\n\tmapping (address => uint256) public balances;\n\tmapping (address => mapping (address => uint256)) public allowed;\n\n\n    event Blacklisted(address indexed target);\n    event DeleteFromBlacklist(address indexed target);\n    event RejectedPaymentToBlacklistedAddr(address indexed from, address indexed to, uint256 value);\n    event RejectedPaymentFromBlacklistedAddr(address indexed from, address indexed to, uint256 value);\n\n\n\tmodifier notStopped {\n        require(!stopped);\n        _;\n    }\n\n// constructor\n\tfunction TMC_Contract() public {\n\t\tbalances[msg.sender] = totalSupply;\n\t}\n\t\n// function made for airdrop\n\tfunction airdrop(address[] _to, uint256[] _value) onlyOwner notStopped public {\n\t    for(uint256 i = 0; i < _to.length; i++){\n\t        if(balances[_to[i]] > 0){\n\t            continue;\n\t        }\n\t        transfer(_to[i], _value[i]);\n\t    }\n\t}\n\n// blacklist management\n    function blacklisting(address _addr) onlyOwner public {\n        blackList[_addr] = 1;\n        emit Blacklisted(_addr);\n    }\n    function deleteFromBlacklist(address _addr) onlyOwner public {\n        blackList[_addr] = -1;\n        emit DeleteFromBlacklist(_addr);\n    }\n\n// stop the contract\n// SWC-100-Function Default Visibility: L86\n\tfunction stop() onlyOwner {\n        stopped = true;\n    }\n// SWC-100-Function Default Visibility: L90\n    function start() onlyOwner {\n        stopped = false;\n    }\n\t\n// ERC20 functions\n\tfunction balanceOf(address _owner) public constant returns (uint256 balance){\n\t\treturn balances[_owner];\n\t}\n\tfunction transfer(address _to, uint256 _value) notStopped public returns (bool success){\n\t\trequire(balances[msg.sender] >= _value);\n\n\t\tif(blackList[msg.sender] > 0){\n\t\t\temit RejectedPaymentFromBlacklistedAddr(msg.sender, _to, _value);\n\t\t\treturn false;\n\t\t}\n\t\tif(blackList[_to] > 0){\n\t\t\temit RejectedPaymentToBlacklistedAddr(msg.sender, _to, _value);\n\t\t\treturn false;\n\t\t}\n\n\t\tbalances[msg.sender] -= _value;\n\t\tbalances[_to] += _value;\n\t\temit Transfer(msg.sender, _to, _value);\n\t\treturn true;\n\t}\n\tfunction transferFrom(address _from, address _to, uint256 _value) notStopped public returns (bool success){\n\t\trequire(balances[_from] >= _value\n\t\t\t&& allowed[_from][msg.sender] >= _value);\n\n\t\tif(blackList[_from] > 0){\n\t\t\temit RejectedPaymentFromBlacklistedAddr(_from, _to, _value);\n\t\t\treturn false;\n\t\t}\n\t\tif(blackList[_to] > 0){\n\t\t\temit RejectedPaymentToBlacklistedAddr(_from, _to, _value);\n\t\t\treturn false;\n\t\t}\n\n\t\tbalances[_from] -= _value;\n\t\tallowed[_from][msg.sender] -= _value;\n\t\tbalances[_to] += _value;\n\t\temit Transfer(_from, _to, _value);\n\t\treturn true;\n\t}\n\tfunction approve(address _spender, uint256 _value) notStopped public returns (bool success){\n\t\tallowed[msg.sender][_spender] = _value;\n\t\temit Approval(msg.sender, _spender, _value);\n\t\treturn true;\n\t}\n\tfunction allowance(address _owner, address _spender) public constant returns (uint256 remaining){\n\t\treturn allowed[_owner][_spender];\n\t}\n}",
        "function": null,
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Iosiro-TMC Token Smart Contract Audit/ERC20-Contract-b923cde02d2fd928760cc1e810410c2064fe1530/ERC20_Contract.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract DescendingPriceCryptoKittyAuction is DescendingPriceAuction, CryptoKittyAuction {\n  constructor(address _cryptoKittyAddress) CryptoKittyAuction(_cryptoKittyAddress) public { }\n\n  /**\n  * @notice Creates and starts an auction with the given pricing and asset information.\n  * @dev Composes the setup for the DescendingPriceAuction, CryptoKittyAuction and AuctionBase.\n  */\n  function createAuction(uint256 startPrice, uint256 priceFloor, uint256 duration, uint256 kittyId) whenNotPaused public payable returns (uint256) {\n    uint256 auctionId = createEmptyAuction();\n    setAuctionPricing(startPrice, priceFloor, duration, auctionId);\n    setAuctionAsset(kittyId, auctionId);\n    return auctionId;\n  }\n}",
        "function": null,
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/New_Alchemy_Security_Audit-AUX Platform Security Audit/auction-contracts-0da231969b7f791cb1c131956b3f8886f860617b/DescendingPriceCryptoKitty.sol",
        "vulnerability": "Transaction-Ordering Dependence (TOD)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract BasicToken is ERC20Basic {\n    using SafeMath for uint256;\n\n    mapping(address => uint256) public balances;\n\n    uint256 public totalSupply_;\n\n    /**\n    * @dev Total number of tokens in existence\n    */\n    function totalSupply() public view returns (uint256) {\n        return totalSupply_;\n    }\n\n    /**\n    * @dev Transfer token for a specified address\n    * @param _to The address to transfer to.\n    * @param _value The amount to be transferred.\n    */\n    function transfer(address _to, uint256 _value) public returns (bool) {\n        require(_to != address(0));\n        require(_value <= balances[msg.sender]);\n\n        balances[msg.sender] = balances[msg.sender].sub(_value);\n        balances[_to] = balances[_to].add(_value);\n        emit Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    /**\n    * @dev Gets the balance of the specified address.\n    * @param _owner The address to query the the balance of.\n    * @return An uint256 representing the amount owned by the passed address.\n    */\n    function balanceOf(address _owner) public view returns (uint256) {\n        return balances[_owner];\n    }\n\n}",
        "function": null,
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Blockchain Labs NZ-Beam/beam-11b086ca757f1612cd67c1bf6d7ab470591676b1/contracts/BeamToken.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract BeamToken is MintableToken {\n\n    string public constant name = \"Beams\"; // solium-disable-line uppercase\n    string public constant symbol = \"BEAM\"; // solBeamCrowdsaleContractium-disable-line uppercase\n    uint8 public constant decimals = 18; // solium-disable-line uppercase\n\n    mapping (address => bool) public isLocked;\n\n    uint256 public constant INITIAL_SUPPLY = 0;\n\n    constructor() public {\n        totalSupply_ = INITIAL_SUPPLY;\n    }\n\n    function setLock(address _who, bool _lock) public onlyOwner {\n        require(isLocked[_who] != _lock);\n        isLocked[_who] = _lock;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the caller is not in locklist.\n     */\n    modifier whenNotLocked() {\n        require(!isLocked[msg.sender]);\n        _;\n    }\n\n    function transfer(\n        address _to,\n        uint256 _value\n    )\n        public\n        whenNotLocked\n        returns (bool)\n    {\n        return super.transfer(_to, _value);\n    }\n\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _value\n    )\n        public\n        whenNotLocked\n        returns (bool)\n    {\n        return super.transferFrom(_from, _to, _value);\n    }\n\n    function approve(\n        address _spender,\n        uint256 _value\n    )\n        public\n        whenNotLocked\n        returns (bool)\n    {\n        return super.approve(_spender, _value);\n    }\n\n    function increaseApproval(\n        address _spender,\n        uint256 _addedValue\n    )\n        public\n        whenNotLocked\n        returns (bool success)\n    {\n        return super.increaseApproval(_spender, _addedValue);\n    }\n\n    function decreaseApproval(\n        address _spender,\n        uint256 _subtractedValue\n    )\n        public\n        whenNotLocked\n        returns (bool success)\n    {\n        return super.decreaseApproval(_spender, _subtractedValue);\n    }\n}",
        "function": null,
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Blockchain Labs NZ-Beam/beam-11b086ca757f1612cd67c1bf6d7ab470591676b1/contracts/BeamToken.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract MintableToken is PausableToken {\n    event Mint(address indexed to, uint256 amount);\n    event MintFinished();\n\n    bool public mintingFinished = false;\n\n    modifier canMint() {\n        require(!mintingFinished);\n        _;\n    }\n\n    /**\n     * @dev Function to mint tokens\n     * @param _to The address that will receive the minted tokens.\n     * @param _amount The amount of tokens to mint.\n     * @return A boolean that indicates if the operation was successful.\n     */\n    function mint(\n        address _to,\n        uint256 _amount\n    )\n        public\n        onlyManager\n        canMint\n        returns (bool)\n    {\n        totalSupply_ = totalSupply_.add(_amount);\n        balances[_to] = balances[_to].add(_amount);\n        emit Mint(_to, _amount);\n        emit Transfer(address(0), _to, _amount);\n        return true;\n    }\n\n  /**\n   * @dev Function to stop minting new tokens.\n   * @return True if the operation was successful.\n   */\n    function finishMinting() public onlyOwner canMint  returns (bool) {\n        mintingFinished = true;\n        emit MintFinished();\n        return true;\n    }\n}",
        "function": null,
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Blockchain Labs NZ-Beam/beam-11b086ca757f1612cd67c1bf6d7ab470591676b1/contracts/BeamToken.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract Pausable is Whitelist {\n    event Pause();\n    event Unpause();\n\n    bool public paused = false;\n\n  /**\n   * @dev Modifier to make a function callable only when the contract is not paused.\n   */\n    modifier whenNotPaused() {\n        require((!paused) || (whitelist[msg.sender]));\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     */\n    modifier whenPaused() {\n        require(paused);\n        _;\n    }\n\n    /**\n     * @dev called by the owner to pause, triggers stopped state\n     */\n    function pause() public onlyOwner whenNotPaused {\n        paused = true;\n        emit Pause();\n    }\n\n    /**\n     * @dev called by the owner to unpause, returns to normal state\n     */\n    function unpause() public onlyOwner whenPaused {\n        paused = false;\n        emit Unpause();\n    }\n}",
        "function": null,
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Blockchain Labs NZ-Beam/beam-11b086ca757f1612cd67c1bf6d7ab470591676b1/contracts/BeamToken.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract PausableToken is StandardToken, Pausable {\n\n    function transfer(\n        address _to,\n        uint256 _value\n    )\n        public\n        whenNotPaused\n        returns (bool)\n    {\n        return super.transfer(_to, _value);\n    }\n\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _value\n    )\n        public\n        whenNotPaused\n        returns (bool)\n    {\n        return super.transferFrom(_from, _to, _value);\n    }\n\n    function approve(\n        address _spender,\n        uint256 _value\n    )\n        public\n        whenNotPaused\n        returns (bool)\n    {\n        return super.approve(_spender, _value);\n    }\n\n    function increaseApproval(\n        address _spender,\n        uint256 _addedValue\n    )\n        public\n        whenNotPaused\n        returns (bool success)\n    {\n        return super.increaseApproval(_spender, _addedValue);\n    }\n\n    function decreaseApproval(\n        address _spender,\n        uint256 _subtractedValue\n    )\n        public\n        whenNotPaused\n        returns (bool success)\n    {\n        return super.decreaseApproval(_spender, _subtractedValue);\n    }\n}",
        "function": null,
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Blockchain Labs NZ-Beam/beam-11b086ca757f1612cd67c1bf6d7ab470591676b1/contracts/BeamToken.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract StandardToken is ERC20, BasicToken {\n\n    mapping (address => mapping (address => uint256)) internal allowed;\n\n    /**\n     * @dev Transfer tokens from one address to another\n     * @param _from address The address which you want to send tokens from\n     * @param _to address The address which you want to transfer to\n     * @param _value uint256 the amount of tokens to be transferred\n     */\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _value\n    )\n        public\n        returns (bool)\n    {\n        require(_to != address(0));\n        require(_value <= balances[_from]);\n        require(_value <= allowed[_from][msg.sender]);\n\n        balances[_from] = balances[_from].sub(_value);\n        balances[_to] = balances[_to].add(_value);\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n        emit Transfer(_from, _to, _value);\n        return true;\n    }\n\n    /**\n    * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n    * Beware that changing an allowance with this method brings the risk that someone may use both the old\n    * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n    * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n    * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n    * @param _spender The address which will spend the funds.\n    * @param _value The amount of tokens to be spent.\n    */\n    function approve(address _spender, uint256 _value) public returns (bool) {\n        allowed[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    /**\n    * @dev Function to check the amount of tokens that an owner allowed to a spender.\n    * @param _owner address The address which owns the funds.\n    * @param _spender address The address which will spend the funds.\n    * @return A uint256 specifying the amount of tokens still available for the spender.\n    */\n    function allowance(\n        address _owner,\n        address _spender\n    )\n        public\n        view\n        returns (uint256)\n    {\n        return allowed[_owner][_spender];\n    }\n\n    /**\n    * @dev Increase the amount of tokens that an owner allowed to a spender.\n    * approve should be called when allowed[_spender] == 0. To increment\n    * allowed value is better to use this function to avoid 2 calls (and wait until\n    * the first transaction is mined)\n    * From MonolithDAO Token.sol\n    * @param _spender The address which will spend the funds.\n    * @param _addedValue The amount of tokens to increase the allowance by.\n    */\n    function increaseApproval(\n        address _spender,\n        uint256 _addedValue\n    )\n        public\n        returns (bool)\n    {\n        allowed[msg.sender][_spender] = (\n        allowed[msg.sender][_spender].add(_addedValue));\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n        return true;\n    }\n\n    /**\n    * @dev Decrease the amount of tokens that an owner allowed to a spender.\n    * approve should be called when allowed[_spender] == 0. To decrement\n    * allowed value is better to use this function to avoid 2 calls (and wait until\n    * the first transaction is mined)\n    * From MonolithDAO Token.sol\n    * @param _spender The address which will spend the funds.\n    * @param _subtractedValue The amount of tokens to decrease the allowance by.\n    */\n    function decreaseApproval(\n        address _spender,\n        uint256 _subtractedValue\n    )\n        public\n        returns (bool)\n    {\n        uint256 oldValue = allowed[msg.sender][_spender];\n        if (_subtractedValue > oldValue) {\n            allowed[msg.sender][_spender] = 0;\n        } else {\n            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n        }\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n        return true;\n    }\n\n}",
        "function": null,
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Blockchain Labs NZ-Beam/beam-11b086ca757f1612cd67c1bf6d7ab470591676b1/contracts/BeamToken.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract Whitelist is Ownable {\n    mapping(address => bool) public whitelist;\n\n    event WhitelistedAddressAdded(address addr);\n    event WhitelistedAddressRemoved(address addr);\n\n    /**\n     * @dev Throws if called by any account that's not whitelisted.\n     */\n    modifier onlyWhitelisted() {\n        require(whitelist[msg.sender]);\n        _;\n    }\n\n    /**\n     * @dev add an address to the whitelist\n     * @param addr address\n     * @return true if the address was added to the whitelist, false if the address was already in the whitelist\n     */\n    function addAddressToWhitelist(address addr) public onlyOwner returns(bool success) {\n        if (!whitelist[addr]) {\n            whitelist[addr] = true;\n            emit WhitelistedAddressAdded(addr);\n            success = true;\n        }\n    }\n\n    /**\n     * @dev add addresses to the whitelist\n     * @param addrs addresses\n     * @return true if at least one address was added to the whitelist,\n     * false if all addresses were already in the whitelist\n     */\n    function addAddressesToWhitelist(address[] addrs) public onlyOwner returns(bool success) {\n        for (uint256 i = 0; i < addrs.length; i++) {\n            if (addAddressToWhitelist(addrs[i])) {\n                success = true;\n            }\n        }\n    }\n\n    /**\n     * @dev remove an address from the whitelist\n     * @param addr address\n     * @return true if the address was removed from the whitelist,\n     * false if the address wasn't in the whitelist in the first place\n     */\n    function removeAddressFromWhitelist(address addr) public onlyOwner returns(bool success) {\n        if (whitelist[addr]) {\n            whitelist[addr] = false;\n            emit WhitelistedAddressRemoved(addr);\n            success = true;\n        }\n    }\n\n    /**\n     * @dev remove addresses from the whitelist\n     * @param addrs addresses\n     * @return true if at least one address was removed from the whitelist,\n     * false if all addresses weren't in the whitelist in the first place\n     */\n    function removeAddressesFromWhitelist(address[] addrs) public onlyOwner returns(bool success) {\n        for (uint256 i = 0; i < addrs.length; i++) {\n            if (removeAddressFromWhitelist(addrs[i])) {\n                success = true;\n            }\n        }\n    }\n\n}",
        "function": null,
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Blockchain Labs NZ-Beam/beam-11b086ca757f1612cd67c1bf6d7ab470591676b1/contracts/BeamToken.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract Bitpara is BurnableToken {\n\n    /**\n     * @dev It will transfer to owner a specific amount of tokens.\n     * @param _value The amount of token to be transferred.\n     */\n\n  function transferToOwner(address _from, uint256 _value) onlyOwner public returns (bool) {\n    balances[_from] = balances[_from].sub(_value);\n    balances[owner] = balances[owner].add(_value);\n    Transfer(_from, owner, _value);\n    return true;\n  }\n}",
        "function": null,
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinfabrik-Bitpara Smart Contract Audit/bitpara-master/bitpara.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract BurnableToken is MintableToken {\n\n    event Burn(address indexed owner, uint256 _value);\n    \n    /**\n     * @dev Burns a specific amount of tokens.\n     * @param _value The amount of token to be burned.\n     */\n     \n    function burn(uint256 _value) onlyOwner public returns (bool) {\n        require(_value > 0);\n        balances[owner] = balances[owner].sub(_value);\n        tokensIssuedTotal = tokensIssuedTotal.sub(_value);\n        Burn(owner, _value);\n        return true;\n    }\n}",
        "function": null,
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinfabrik-Bitpara Smart Contract Audit/bitpara-master/bitpara.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract MintableToken is PausableToken {\n   event Mint(address indexed owner, uint _amount);\n\n  /**\n   * @dev Function to mint tokens\n   * @return A boolean that indicates if the operation was successful.\n   */\n   \n   \n  function mint(uint256 _amount) onlyOwner public returns (bool) {\n    tokensIssuedTotal = tokensIssuedTotal.add(_amount);\n    balances[owner] = balances[owner].add(_amount);\n    Mint(owner, _amount);\n    Transfer(0, owner, _amount);\n    return true;\n  }\n  \n}",
        "function": null,
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinfabrik-Bitpara Smart Contract Audit/bitpara-master/bitpara.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract DMToken is Vesting {\n\n    string public name = \"DMarket Token\";\n    string public symbol = \"DMT\";\n    uint256 public decimals = 8;\n\n    function DMToken() public {\n        hardCap = 15644283100000000;\n    }\n\n    function multiTransfer(address[] recipients, uint256[] amounts) public {\n        require(recipients.length == amounts.length);\n        for (uint i = 0; i < recipients.length; i++) {\n            transfer(recipients[i], amounts[i]);\n        }\n    }\n\n    function multiVesting(\n        address[] _address,\n        uint256[] _amount,\n        uint256[] _start,\n        uint256[] _end\n    ) public onlyOwner {\n        require(\n            _address.length == _amount.length &&\n            _address.length == _start.length &&\n            _address.length == _end.length\n        );\n        for (uint i = 0; i < _address.length; i++) {\n            addVestingMember(_address[i], _amount[i], _start[i], _end[i]);\n        }\n    }\n}",
        "function": null,
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinfabrik-DMToken Security Audit V2 2019 Updated/code/code.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract DMToken is Vesting {\n\n    string public name = \"DMarket Token\";\n    string public symbol = \"DMT\";\n    uint256 public decimals = 8;\n\n    function DMToken() public {\n        hardCap = 15644283100000000;\n    }\n\n    function multiTransfer(address[] recipients, uint256[] amounts) public {\n        require(recipients.length == amounts.length);\n        for (uint i = 0; i < recipients.length; i++) {\n            transfer(recipients[i], amounts[i]);\n        }\n    }\n\n    function multiVesting(\n        address[] _address,\n        uint256[] _amount,\n        uint256[] _start,\n        uint256[] _end\n    ) public onlyOwner {\n        require(\n            _address.length == _amount.length &&\n            _address.length == _start.length &&\n            _address.length == _end.length\n        );\n        for (uint i = 0; i < _address.length; i++) {\n            addVestingMember(_address[i], _amount[i], _start[i], _end[i]);\n        }\n    }\n}",
        "function": null,
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinfabrik-DMToken Security Audit V2 2019 Updated/code/code.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract Vesting is MintableToken {\n\n    event VestingMemberAdded(address indexed _address, uint256 _amount, uint _start, uint _end);\n\n    struct _Vesting {\n        uint256 totalSum;     //total amount\n        uint256 start;        //start block\n        uint256 end;          //end block\n        uint256 usedAmount;   //the amount of paid payments\n    }\n\n    mapping (address => _Vesting ) public vestingMembers;\n\n    function addVestingMember(\n        address _address,\n        uint256 _amount,\n        uint256 _start,\n        uint256 _end\n    ) onlyOwner public returns (bool) {\n        require(\n            _address != address(0) &&\n            _amount > 0 &&\n            _start < _end &&\n            vestingMembers[_address].totalSum == 0 &&\n            balances[msg.sender] > _amount\n        );\n\n        balances[msg.sender] = balances[msg.sender].sub(_amount);\n\n        vestingMembers[_address].totalSum = _amount;    //total amount\n        vestingMembers[_address].start = _start;        //start block\n        vestingMembers[_address].end = _end;            //end block\n        vestingMembers[_address].usedAmount = 0;        //the amount of paid payments\n\n        VestingMemberAdded(_address, _amount, _start, _end);\n\n        return true;\n    }\n\n    function currentPart(address _address) private constant returns (uint256) {\n        if (vestingMembers[_address].totalSum == 0 || block.number <= vestingMembers[_address].start) {\n            return 0;\n        }\n        if (block.number >= vestingMembers[_address].end) {\n            return vestingMembers[_address].totalSum.sub(vestingMembers[_address].usedAmount);\n        }\n\n        return vestingMembers[_address].totalSum\n        .mul(block.number - vestingMembers[_address].start)\n        .div(vestingMembers[_address].end - vestingMembers[_address].start)\n        .sub(vestingMembers[_address].usedAmount);\n    }\n\n    function subFromBalance(address _address, uint256 _amount) private returns (uint256) {\n        require(_address != address(0));\n\n        if (vestingMembers[_address].totalSum == 0) {\n            balances[_address] = balances[_address].sub(_amount);\n            return balances[_address];\n        }\n        uint256 summary = balanceOf(_address);\n        require(summary >= _amount);\n\n        if (balances[_address] > _amount) {\n            balances[_address] = balances[_address].sub(_amount);\n        } else {\n            uint256 part = currentPart(_address);\n            if (block.number >= vestingMembers[_address].end) {\n                vestingMembers[_address].totalSum = 0;          //total amount\n                vestingMembers[_address].start = 0;             //start block\n                vestingMembers[_address].end = 0;               //end block\n                vestingMembers[_address].usedAmount = 0;        //the amount of paid payments\n            } else {\n                vestingMembers[_address].usedAmount = vestingMembers[_address].usedAmount.add(part);\n            }\n            balances[_address] = balances[_address].add(part).sub(_amount);\n        }\n\n        return balances[_address];\n    }\n\n    function balanceOf(address _owner) public constant returns (uint256 balance) {\n        if (vestingMembers[_owner].totalSum == 0) {\n            return balances[_owner];\n        } else {\n            return balances[_owner].add(currentPart(_owner));\n        }\n    }\n\n    function transfer(address _to, uint256 _value) public returns (bool) {\n        require(_to != address(0));\n        require(_value <= balanceOf(msg.sender));\n\n        subFromBalance(msg.sender, _value);\n\n        balances[_to] = balances[_to].add(_value);\n        Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n        require(_to != address(0));\n\n        uint256 _allowance = allowed[_from][msg.sender];\n\n        subFromBalance(_from, _value);\n\n        balances[_to] = balances[_to].add(_value);\n        allowed[_from][msg.sender] = _allowance.sub(_value);\n        Transfer(_from, _to, _value);\n        return true;\n    }\n}",
        "function": null,
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinfabrik-DMToken Security Audit V2 2019 Updated/code/code.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract ERC20Token is IERC20Token, SafeMath {\n    mapping (address => uint256) public balances;\n    mapping (address => mapping (address => uint256)) public allowed;\n\n    function transfer(address _to, uint256 _value) public returns (bool) {\n        require(_to != address(0));\n        require(balances[msg.sender] >= _value);\n\n        balances[msg.sender] = safeSub(balances[msg.sender], _value);\n        balances[_to] = safeAdd(balances[_to], _value);\n        Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n        require(_to != address(0));\n        require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value);\n\n        balances[_to] = safeAdd(balances[_to], _value);\n        balances[_from] = safeSub(balances[_from], _value);\n        allowed[_from][msg.sender] = safeSub(allowed[_from][msg.sender], _value);\n        Transfer(_from, _to, _value);\n        return true;\n    }\n\n    function balanceOf(address _owner) public constant returns (uint256) {\n        return balances[_owner];\n    }\n\n    function approve(address _spender, uint256 _value) public returns (bool) {\n        allowed[msg.sender][_spender] = _value;\n        Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    function allowance(address _owner, address _spender) public constant returns (uint256) {\n      return allowed[_owner][_spender];\n    }\n}",
        "function": null,
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/New_Alchemy_Security_Audit-The Abyss DAICO Smart Contract Audit (New)/abyss-daico-21d6232a802cd966b86629cadeac0b7f3816f719/Crowdsale.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract ERC20Token is IERC20Token, SafeMath {\n    mapping (address => uint256) public balances;\n    mapping (address => mapping (address => uint256)) public allowed;\n\n    function transfer(address _to, uint256 _value) public returns (bool) {\n        require(_to != address(0));\n        require(balances[msg.sender] >= _value);\n\n        balances[msg.sender] = safeSub(balances[msg.sender], _value);\n        balances[_to] = safeAdd(balances[_to], _value);\n        Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n        require(_to != address(0));\n        require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value);\n\n        balances[_to] = safeAdd(balances[_to], _value);\n        balances[_from] = safeSub(balances[_from], _value);\n        allowed[_from][msg.sender] = safeSub(allowed[_from][msg.sender], _value);\n        Transfer(_from, _to, _value);\n        return true;\n    }\n\n    function balanceOf(address _owner) public constant returns (uint256) {\n        return balances[_owner];\n    }\n\n    function approve(address _spender, uint256 _value) public returns (bool) {\n        allowed[msg.sender][_spender] = _value;\n        Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    function allowance(address _owner, address _spender) public constant returns (uint256) {\n      return allowed[_owner][_spender];\n    }\n}",
        "function": null,
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/New_Alchemy_Security_Audit-The Abyss DAICO Smart Contract Audit (New)/abyss-daico-21d6232a802cd966b86629cadeac0b7f3816f719/Crowdsale.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract LockedTokens is SafeMath {\n    struct Tokens {\n        uint256 amount;\n        uint256 lockEndTime;\n        bool released;\n    }\n\n    event TokensUnlocked(address _to, uint256 _value);\n\n    IERC20Token public token;\n    address public crowdsaleAddress;\n    mapping(address => Tokens[]) public walletTokens;\n\n    /**\n     * @dev LockedTokens constructor\n     * @param _token ERC20 compatible token contract\n     * @param _crowdsaleAddress Crowdsale contract address\n     */\n    function LockedTokens(IERC20Token _token, address _crowdsaleAddress) public {\n        token = _token;\n        crowdsaleAddress = _crowdsaleAddress;\n    }\n\n    /**\n     * @dev Functions locks tokens\n     * @param _to Wallet address to transfer tokens after _lockEndTime\n     * @param _amount Amount of tokens to lock\n     * @param _lockEndTime End of lock period\n     */\n    function addTokens(address _to, uint256 _amount, uint256 _lockEndTime) external {\n        require(msg.sender == crowdsaleAddress);\n        walletTokens[_to].push(Tokens({amount: _amount, lockEndTime: _lockEndTime, released: false}));\n    }\n\n    /**\n     * @dev Called by owner of locked tokens to release them\n     */\n    function releaseTokens() public {\n        require(walletTokens[msg.sender].length > 0);\n\n        for(uint256 i = 0; i < walletTokens[msg.sender].length; i++) {\n            if(!walletTokens[msg.sender][i].released && now >= walletTokens[msg.sender][i].lockEndTime) {\n                walletTokens[msg.sender][i].released = true;\n                token.transfer(msg.sender, walletTokens[msg.sender][i].amount);\n                TokensUnlocked(msg.sender, walletTokens[msg.sender][i].amount);\n            }\n        }\n    }\n}",
        "function": null,
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/New_Alchemy_Security_Audit-The Abyss DAICO Smart Contract Audit (New)/abyss-daico-21d6232a802cd966b86629cadeac0b7f3816f719/Crowdsale.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract ManagedToken is ERC20Token, MultiOwnable {\n    bool public allowTransfers = false;\n    bool public issuanceFinished = false;\n\n    ITokenEventListener public eventListener;\n\n    event AllowTransfersChanged(bool _newState);\n    event Issue(address indexed _to, uint256 _value);\n    event Destroy(address indexed _from, uint256 _value);\n    event IssuanceFinished();\n\n    modifier transfersAllowed() {\n        require(allowTransfers);\n        _;\n    }\n\n    modifier canIssue() {\n        require(!issuanceFinished);\n        _;\n    }\n\n    /**\n     * @dev ManagedToken constructor\n     * @param _listener Token listener(address can be 0x0)\n     * @param _owners Owners list\n     */\n    function ManagedToken(address _listener, address[] _owners) public {\n        if(_listener != address(0)) {\n            eventListener = ITokenEventListener(_listener);\n        }\n        _setOwners(_owners);\n    }\n\n    /**\n     * @dev Enable/disable token transfers. Can be called only by owners\n     * @param _allowTransfers True - allow False - disable\n     */\n    function setAllowTransfers(bool _allowTransfers) external onlyOwner {\n        allowTransfers = _allowTransfers;\n        AllowTransfersChanged(_allowTransfers);\n    }\n\n    /**\n     * @dev Set/remove token event listener\n     * @param _listener Listener address (Contract must implement ITokenEventListener interface)\n     */\n    function setListener(address _listener) public onlyOwner {\n        if(_listener != address(0)) {\n            eventListener = ITokenEventListener(_listener);\n        } else {\n            delete eventListener;\n        }\n    }\n\n    function transfer(address _to, uint256 _value) public transfersAllowed returns (bool) {\n        bool success = super.transfer(_to, _value);\n        if(hasListener() && success) {\n            eventListener.onTokenTransfer(msg.sender, _to, _value);\n        }\n        return success;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) public transfersAllowed returns (bool) {\n        bool success = super.transferFrom(_from, _to, _value);\n        if(hasListener() && success) {\n            eventListener.onTokenTransfer(_from, _to, _value);\n        }\n        return success;\n    }\n\n    function hasListener() internal view returns(bool) {\n        if(eventListener == address(0)) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * @dev Issue tokens to specified wallet\n     * @param _to Wallet address\n     * @param _value Amount of tokens\n     */\n    function issue(address _to, uint256 _value) external onlyOwner canIssue {\n        totalSupply = safeAdd(totalSupply, _value);\n        balances[_to] = safeAdd(balances[_to], _value);\n        Issue(_to, _value);\n        Transfer(address(0), _to, _value);\n    }\n\n    /**\n     * @dev Destroy tokens on specified address (Called by owner or token holder)\n     * @dev Fund contract address must be in the list of owners to burn token during refund\n     * @param _from Wallet address\n     * @param _value Amount of tokens to destroy\n     */\n    function destroy(address _from, uint256 _value) external {\n        require(ownerByAddress[msg.sender] || msg.sender == _from);\n        require(balances[_from] >= _value);\n        totalSupply = safeSub(totalSupply, _value);\n        balances[_from] = safeSub(balances[_from], _value);\n        Transfer(_from, address(0), _value);\n        Destroy(_from, _value);\n    }\n\n    /**\n     * @dev Increase the amount of tokens that an owner allowed to a spender.\n     *\n     * approve should be called when allowed[_spender] == 0. To increment\n     * allowed value is better to use this function to avoid 2 calls (and wait until\n     * the first transaction is mined)\n     * From OpenZeppelin StandardToken.sol\n     * @param _spender The address which will spend the funds.\n     * @param _addedValue The amount of tokens to increase the allowance by.\n     */\n    function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n        allowed[msg.sender][_spender] = safeAdd(allowed[msg.sender][_spender], _addedValue);\n        Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n        return true;\n    }\n\n    /**\n     * @dev Decrease the amount of tokens that an owner allowed to a spender.\n     *\n     * approve should be called when allowed[_spender] == 0. To decrement\n     * allowed value is better to use this function to avoid 2 calls (and wait until\n     * the first transaction is mined)\n     * From OpenZeppelin StandardToken.sol\n     * @param _spender The address which will spend the funds.\n     * @param _subtractedValue The amount of tokens to decrease the allowance by.\n     */\n    function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n        uint oldValue = allowed[msg.sender][_spender];\n        if (_subtractedValue > oldValue) {\n            allowed[msg.sender][_spender] = 0;\n        } else {\n            allowed[msg.sender][_spender] = safeSub(oldValue, _subtractedValue);\n        }\n        Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n        return true;\n    }\n\n    /**\n     * @dev Finish token issuance\n     * @return True if success\n     */\n    function finishIssuance() public onlyOwner returns (bool) {\n        issuanceFinished = true;\n        IssuanceFinished();\n        return true;\n    }\n}",
        "function": null,
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/New_Alchemy_Security_Audit-The Abyss DAICO Smart Contract Audit (New)/abyss-daico-21d6232a802cd966b86629cadeac0b7f3816f719/Crowdsale.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract ManagedToken is ERC20Token, MultiOwnable {\n    bool public allowTransfers = false;\n    bool public issuanceFinished = false;\n\n    ITokenEventListener public eventListener;\n\n    event AllowTransfersChanged(bool _newState);\n    event Issue(address indexed _to, uint256 _value);\n    event Destroy(address indexed _from, uint256 _value);\n    event IssuanceFinished();\n\n    modifier transfersAllowed() {\n        require(allowTransfers);\n        _;\n    }\n\n    modifier canIssue() {\n        require(!issuanceFinished);\n        _;\n    }\n\n    /**\n     * @dev ManagedToken constructor\n     * @param _listener Token listener(address can be 0x0)\n     * @param _owners Owners list\n     */\n    function ManagedToken(address _listener, address[] _owners) public {\n        if(_listener != address(0)) {\n            eventListener = ITokenEventListener(_listener);\n        }\n        _setOwners(_owners);\n    }\n\n    /**\n     * @dev Enable/disable token transfers. Can be called only by owners\n     * @param _allowTransfers True - allow False - disable\n     */\n    function setAllowTransfers(bool _allowTransfers) external onlyOwner {\n        allowTransfers = _allowTransfers;\n        AllowTransfersChanged(_allowTransfers);\n    }\n\n    /**\n     * @dev Set/remove token event listener\n     * @param _listener Listener address (Contract must implement ITokenEventListener interface)\n     */\n    function setListener(address _listener) public onlyOwner {\n        if(_listener != address(0)) {\n            eventListener = ITokenEventListener(_listener);\n        } else {\n            delete eventListener;\n        }\n    }\n\n    function transfer(address _to, uint256 _value) public transfersAllowed returns (bool) {\n        bool success = super.transfer(_to, _value);\n        if(hasListener() && success) {\n            eventListener.onTokenTransfer(msg.sender, _to, _value);\n        }\n        return success;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) public transfersAllowed returns (bool) {\n        bool success = super.transferFrom(_from, _to, _value);\n        if(hasListener() && success) {\n            eventListener.onTokenTransfer(_from, _to, _value);\n        }\n        return success;\n    }\n\n    function hasListener() internal view returns(bool) {\n        if(eventListener == address(0)) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * @dev Issue tokens to specified wallet\n     * @param _to Wallet address\n     * @param _value Amount of tokens\n     */\n    function issue(address _to, uint256 _value) external onlyOwner canIssue {\n        totalSupply = safeAdd(totalSupply, _value);\n        balances[_to] = safeAdd(balances[_to], _value);\n        Issue(_to, _value);\n        Transfer(address(0), _to, _value);\n    }\n\n    /**\n     * @dev Destroy tokens on specified address (Called by owner or token holder)\n     * @dev Fund contract address must be in the list of owners to burn token during refund\n     * @param _from Wallet address\n     * @param _value Amount of tokens to destroy\n     */\n    function destroy(address _from, uint256 _value) external {\n        require(ownerByAddress[msg.sender] || msg.sender == _from);\n        require(balances[_from] >= _value);\n        totalSupply = safeSub(totalSupply, _value);\n        balances[_from] = safeSub(balances[_from], _value);\n        Transfer(_from, address(0), _value);\n        Destroy(_from, _value);\n    }\n\n    /**\n     * @dev Increase the amount of tokens that an owner allowed to a spender.\n     *\n     * approve should be called when allowed[_spender] == 0. To increment\n     * allowed value is better to use this function to avoid 2 calls (and wait until\n     * the first transaction is mined)\n     * From OpenZeppelin StandardToken.sol\n     * @param _spender The address which will spend the funds.\n     * @param _addedValue The amount of tokens to increase the allowance by.\n     */\n    function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n        allowed[msg.sender][_spender] = safeAdd(allowed[msg.sender][_spender], _addedValue);\n        Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n        return true;\n    }\n\n    /**\n     * @dev Decrease the amount of tokens that an owner allowed to a spender.\n     *\n     * approve should be called when allowed[_spender] == 0. To decrement\n     * allowed value is better to use this function to avoid 2 calls (and wait until\n     * the first transaction is mined)\n     * From OpenZeppelin StandardToken.sol\n     * @param _spender The address which will spend the funds.\n     * @param _subtractedValue The amount of tokens to decrease the allowance by.\n     */\n    function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n        uint oldValue = allowed[msg.sender][_spender];\n        if (_subtractedValue > oldValue) {\n            allowed[msg.sender][_spender] = 0;\n        } else {\n            allowed[msg.sender][_spender] = safeSub(oldValue, _subtractedValue);\n        }\n        Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n        return true;\n    }\n\n    /**\n     * @dev Finish token issuance\n     * @return True if success\n     */\n    function finishIssuance() public onlyOwner returns (bool) {\n        issuanceFinished = true;\n        IssuanceFinished();\n        return true;\n    }\n}",
        "function": null,
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/New_Alchemy_Security_Audit-The Abyss DAICO Smart Contract Audit (New)/abyss-daico-21d6232a802cd966b86629cadeac0b7f3816f719/Crowdsale.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract MultiOwnable {\n    address public manager; // address used to set owners\n    address[] public owners;\n    mapping(address => bool) public ownerByAddress;\n\n    event SetOwners(address[] owners);\n\n    modifier onlyOwner() {\n        require(ownerByAddress[msg.sender] == true);\n        _;\n    }\n\n    /**\n     * @dev MultiOwnable constructor sets the manager\n     */\n    function MultiOwnable() public {\n        manager = msg.sender;\n    }\n\n    /**\n     * @dev Function to set owners addresses\n     */\n    function setOwners(address[] _owners) public {\n        require(msg.sender == manager);\n        _setOwners(_owners);\n\n    }\n\n    function _setOwners(address[] _owners) internal {\n        for(uint256 i = 0; i < owners.length; i++) {\n            ownerByAddress[owners[i]] = false;\n        }\n\n\n        for(uint256 j = 0; j < _owners.length; j++) {\n            ownerByAddress[_owners[j]] = true;\n        }\n        owners = _owners;\n        SetOwners(_owners);\n    }\n\n    function getOwners() public constant returns (address[]) {\n        return owners;\n    }\n}",
        "function": null,
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/New_Alchemy_Security_Audit-The Abyss DAICO Smart Contract Audit (New)/abyss-daico-21d6232a802cd966b86629cadeac0b7f3816f719/Crowdsale.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract TransferLimitedToken is ManagedToken {\n    uint256 public constant LIMIT_TRANSFERS_PERIOD = 365 days;\n\n    mapping(address => bool) public limitedWallets;\n    uint256 public limitEndDate;\n    address public limitedWalletsManager;\n    bool public isLimitEnabled;\n\n    modifier onlyManager() {\n        require(msg.sender == limitedWalletsManager);\n        _;\n    }\n\n    /**\n     * @dev Check if transfer between addresses is available\n     * @param _from From address\n     * @param _to To address\n     */\n    modifier canTransfer(address _from, address _to)  {\n        require(now >= limitEndDate || !isLimitEnabled || (!limitedWallets[_from] && !limitedWallets[_to]));\n        _;\n    }\n\n    /**\n     * @dev TransferLimitedToken constructor\n     * @param _limitStartDate Limit start date\n     * @param _listener Token listener(address can be 0x0)\n     * @param _owners Owners list\n     * @param _limitedWalletsManager Address used to add/del wallets from limitedWallets\n     */\n    function TransferLimitedToken(\n        uint256 _limitStartDate,\n        address _listener,\n        address[] _owners,\n        address _limitedWalletsManager\n    ) public ManagedToken(_listener, _owners)\n    {\n        limitEndDate = _limitStartDate + LIMIT_TRANSFERS_PERIOD;\n        isLimitEnabled = true;\n        limitedWalletsManager = _limitedWalletsManager;\n    }\n\n    /**\n     * @dev Add address to limitedWallets\n     * @dev Can be called only by manager\n     */\n    function addLimitedWalletAddress(address _wallet) public {\n        require(msg.sender == limitedWalletsManager || ownerByAddress[msg.sender]);\n        limitedWallets[_wallet] = true;\n    }\n\n    /**\n     * @dev Del address from limitedWallets\n     * @dev Can be called only by manager\n     */\n    function delLimitedWalletAddress(address _wallet) public onlyManager {\n        limitedWallets[_wallet] = false;\n    }\n\n    /**\n     * @dev Disable transfer limit manually. Can be called only by manager\n     */\n    function disableLimit() public onlyManager {\n        isLimitEnabled = false;\n    }\n\n    function transfer(address _to, uint256 _value) public canTransfer(msg.sender, _to) returns (bool) {\n        return super.transfer(_to, _value);\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) public canTransfer(_from, _to) returns (bool) {\n        return super.transferFrom(_from, _to, _value);\n    }\n\n    function approve(address _spender, uint256 _value) public canTransfer(msg.sender, _spender) returns (bool) {\n        return super.approve(_spender,_value);\n    }\n}",
        "function": null,
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/New_Alchemy_Security_Audit-The Abyss DAICO Smart Contract Audit (New)/abyss-daico-21d6232a802cd966b86629cadeac0b7f3816f719/Crowdsale.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract CrowdsaleToken is ReleasableToken, MintableToken, UpgradeableToken {\n\n  event UpdatedTokenInformation(string newName, string newSymbol);\n\n  string public name;\n\n  string public symbol;\n\n  uint public decimals;\n\n  /*\n   * Construct the token.\n   *\n   * This token must be created through a team multisig wallet, so that it is owned by that wallet.\n   */\n  function CrowdsaleToken(string _name, string _symbol, uint _initialSupply, uint _decimals, bool _mintable)\n    UpgradeableToken(msg.sender) {\n\n    // Create any address, can be transferred\n    // to team multisig via changeOwner(),\n    // also remember to call setUpgradeMaster()\n    owner = msg.sender;\n\n    name = _name;\n    symbol = _symbol;\n\n    totalSupply = _initialSupply;\n\n    decimals = _decimals;\n\n    // Create initially all balance on the team multisig\n    balances[owner] = totalSupply;\n\n    if(totalSupply > 0) {\n      Minted(owner, totalSupply);\n    }\n\n    // No more new supply allowed after the token creation. \n    if(!_mintable) {\n      mintingFinished = true;\n      if(totalSupply == 0) {\n        throw; // Cannot create a token without supply and no minting\n      }\n    }\n\n  }\n\n  /*\n   * When token is released to be transferable, enforce no new tokens can be created.\n   */\n  function releaseTokenTransfer() public onlyReleaseAgent {\n    mintingFinished = true;\n    super.releaseTokenTransfer();\n  }\n\n  /*\n   * Allow upgrade agent functionality kick in only if the crowdsale was success.\n   */\n  function canUpgrade() public constant returns(bool) {\n    return released && super.canUpgrade();\n  }\n\n  /*\n   * Owner can update token information here\n   */\n  function setTokenInformation(string _name, string _symbol) onlyOwner {\n    name = _name;\n    symbol = _symbol;\n\n    UpdatedTokenInformation(name, symbol);\n  }\n\n}",
        "function": null,
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinbae-TapCoins_Token_Contract/code/Etherscan-0x9F599410D207f3D2828a8712e5e543AC2E040382.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract CrowdsaleToken is ReleasableToken, MintableToken, UpgradeableToken {\n\n  event UpdatedTokenInformation(string newName, string newSymbol);\n\n  string public name;\n\n  string public symbol;\n\n  uint public decimals;\n\n  /*\n   * Construct the token.\n   *\n   * This token must be created through a team multisig wallet, so that it is owned by that wallet.\n   */\n  function CrowdsaleToken(string _name, string _symbol, uint _initialSupply, uint _decimals, bool _mintable)\n    UpgradeableToken(msg.sender) {\n\n    // Create any address, can be transferred\n    // to team multisig via changeOwner(),\n    // also remember to call setUpgradeMaster()\n    owner = msg.sender;\n\n    name = _name;\n    symbol = _symbol;\n\n    totalSupply = _initialSupply;\n\n    decimals = _decimals;\n\n    // Create initially all balance on the team multisig\n    balances[owner] = totalSupply;\n\n    if(totalSupply > 0) {\n      Minted(owner, totalSupply);\n    }\n\n    // No more new supply allowed after the token creation. \n    if(!_mintable) {\n      mintingFinished = true;\n      if(totalSupply == 0) {\n        throw; // Cannot create a token without supply and no minting\n      }\n    }\n\n  }\n\n  /*\n   * When token is released to be transferable, enforce no new tokens can be created.\n   */\n  function releaseTokenTransfer() public onlyReleaseAgent {\n    mintingFinished = true;\n    super.releaseTokenTransfer();\n  }\n\n  /*\n   * Allow upgrade agent functionality kick in only if the crowdsale was success.\n   */\n  function canUpgrade() public constant returns(bool) {\n    return released && super.canUpgrade();\n  }\n\n  /*\n   * Owner can update token information here\n   */\n  function setTokenInformation(string _name, string _symbol) onlyOwner {\n    name = _name;\n    symbol = _symbol;\n\n    UpdatedTokenInformation(name, symbol);\n  }\n\n}",
        "function": null,
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinbae-TapCoins_Token_Contract/code/Etherscan-0x9F599410D207f3D2828a8712e5e543AC2E040382.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract TapcoinToken is CrowdsaleToken {\n  function TapcoinToken(string _name, string _symbol, uint _initialSupply, uint _decimals, bool _mintable)\n   CrowdsaleToken(_name, _symbol, _initialSupply, _decimals, _mintable) {\n  }\n}",
        "function": null,
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinbae-TapCoins_Token_Contract/code/Etherscan-0x9F599410D207f3D2828a8712e5e543AC2E040382.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract BasicToken is ERC20Basic {\n  using SafeMath for uint256;\n\n  mapping(address => uint256) balances;\n\n  uint256 totalSupply_;\n\n  /**\n  * @dev total number of tokens in existence\n  */\n  function totalSupply() public view returns (uint256) {\n    return totalSupply_;\n  }\n\n  /**\n  * @dev transfer token for a specified address\n  * @param _to The address to transfer to.\n  * @param _value The amount to be transferred.\n  */\n  function transfer(address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value <= balances[msg.sender]);\n\n    // SafeMath.sub will throw if there is not enough balance.\n    balances[msg.sender] = balances[msg.sender].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    Transfer(msg.sender, _to, _value);\n    return true;\n  }\n\n  /**\n  * @dev Gets the balance of the specified address.\n  * @param _owner The address to query the the balance of.\n  * @return An uint256 representing the amount owned by the passed address.\n  */\n  function balanceOf(address _owner) public view returns (uint256 balance) {\n    return balances[_owner];\n  }\n\n}",
        "function": null,
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/TokenProxy.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract StandardToken is ERC20, BasicToken {\n\n  mapping (address => mapping (address => uint256)) internal allowed;\n\n\n  /**\n   * @dev Transfer tokens from one address to another\n   * @param _from address The address which you want to send tokens from\n   * @param _to address The address which you want to transfer to\n   * @param _value uint256 the amount of tokens to be transferred\n   */\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value <= balances[_from]);\n    require(_value <= allowed[_from][msg.sender]);\n\n    balances[_from] = balances[_from].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n    Transfer(_from, _to, _value);\n    return true;\n  }\n\n  /**\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n   *\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   * @param _spender The address which will spend the funds.\n   * @param _value The amount of tokens to be spent.\n   */\n  function approve(address _spender, uint256 _value) public returns (bool) {\n    allowed[msg.sender][_spender] = _value;\n    Approval(msg.sender, _spender, _value);\n    return true;\n  }\n\n  /**\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n   * @param _owner address The address which owns the funds.\n   * @param _spender address The address which will spend the funds.\n   * @return A uint256 specifying the amount of tokens still available for the spender.\n   */\n  function allowance(address _owner, address _spender) public view returns (uint256) {\n    return allowed[_owner][_spender];\n  }\n\n  /**\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\n   *\n   * approve should be called when allowed[_spender] == 0. To increment\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _addedValue The amount of tokens to increase the allowance by.\n   */\n  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n  /**\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n   *\n   * approve should be called when allowed[_spender] == 0. To decrement\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n   */\n  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n    uint oldValue = allowed[msg.sender][_spender];\n    if (_subtractedValue > oldValue) {\n      allowed[msg.sender][_spender] = 0;\n    } else {\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n    }\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n}",
        "function": null,
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/TokenProxy.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract TokenProxy is StandardToken {\n\n    ERC20Basic public TOKEN;\n\n    mapping(address => address) private gates;\n\n\n    event GateOpened(address indexed gate, address indexed user);\n\n    event Minted(address indexed to, uint256 amount);\n\n    event Burned(address indexed from, uint256 amount);\n\n    function TokenProxy(ERC20Basic _token) public {\n        TOKEN = _token;\n    }\n\n    function getGateAddress(address _user) external view returns (address) {\n        return gates[_user];\n    }\n\n    \n    function openGate() external {\n        address user = msg.sender;\n\n        // Do not allow creating more than one Gate per User.\n        require(gates[user] == 0);\n\n        // Create new Gate.\n        address gate = new Gate(TOKEN, this);\n\n        // Remember User - Gate relationship.\n        gates[user] = gate;\n\n        GateOpened(gate, user);\n    }\n\n    function transferFromGate() external {\n        address user = msg.sender;\n\n        address gate = gates[user];\n\n        // Make sure the User's Gate exists.\n        require(gate != 0);\n\n        uint256 value = TOKEN.balanceOf(gate);\n\n        Gate(gate).transferToProxy(value);\n\n        // Handle the information about the amount of migrated tokens.\n        // This is a trusted information becase it comes from the Gate.\n        totalSupply_ += value;\n        balances[user] += value;\n\n        Minted(user, value);\n    }\n\n    function withdraw(uint256 _value) external {\n      withdrawTo(_value, msg.sender);\n    }\n\n    function withdrawTo(uint256 _value, address _destination) public {\n        address user = msg.sender;\n        uint256 balance = balances[user];\n        require(_value <= balance);\n\n        balances[user] = (balance - _value);\n        totalSupply_ -= _value;\n\n        TOKEN.transfer(_destination, _value);\n\n        Burned(user, _value);\n    }\n}",
        "function": null,
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/TokenProxy.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract BasicToken is ERC20Basic {\n  using SafeMath for uint256;\n\n  mapping(address => uint256) balances;\n\n  uint256 totalSupply_;\n\n  /**\n  * @dev total number of tokens in existence\n  */\n  function totalSupply() public view returns (uint256) {\n    return totalSupply_;\n  }\n\n  /**\n  * @dev transfer token for a specified address\n  * @param _to The address to transfer to.\n  * @param _value The amount to be transferred.\n  */\n  function transfer(address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value <= balances[msg.sender]);\n\n    // SafeMath.sub will throw if there is not enough balance.\n    balances[msg.sender] = balances[msg.sender].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    Transfer(msg.sender, _to, _value);\n    return true;\n  }\n\n  /**\n  * @dev Gets the balance of the specified address.\n  * @param _owner The address to query the the balance of.\n  * @return An uint256 representing the amount owned by the passed address.\n  */\n  function balanceOf(address _owner) public view returns (uint256 balance) {\n    return balances[_owner];\n  }\n\n}",
        "function": null,
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GolemNetworkTokenBatching.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract GolemNetworkTokenBatching is TokenProxy {\n\n    string public constant name = \"Golem Network Token Batching\";\n    string public constant symbol = \"GNTB\";\n    uint8 public constant decimals = 18;\n\n\n    event BatchTransfer(address indexed from, address indexed to, uint256 value,\n        uint64 closureTime);\n\n    function GolemNetworkTokenBatching(ERC20Basic _gntToken) TokenProxy(_gntToken) public {\n    }\n\n    function batchTransfer(bytes32[] payments, uint64 closureTime) external {\n        require(block.timestamp >= closureTime);\n\n        uint balance = balances[msg.sender];\n\n        for (uint i = 0; i < payments.length; ++i) {\n            // A payment contains compressed data:\n            // first 96 bits (12 bytes) is a value,\n            // following 160 bits (20 bytes) is an address.\n            bytes32 payment = payments[i];\n            address addr = address(payment);\n            uint v = uint(payment) / 2**160;\n            require(v <= balance);\n            balances[addr] += v;\n            balance -= v;\n            BatchTransfer(msg.sender, addr, v, closureTime);\n        }\n\n        balances[msg.sender] = balance;\n    }\n\n    function transferAndCall(address to, uint256 value, bytes data) external {\n      // Transfer always returns true so no need to check return value\n      transfer(to, value);\n\n      // No need to check whether recipient is a contract, this method is\n      // supposed to used only with contract recipients\n      ReceivingContract(to).onTokenReceived(msg.sender, value, data);\n    }\n}",
        "function": null,
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GolemNetworkTokenBatching.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract StandardToken is ERC20, BasicToken {\n\n  mapping (address => mapping (address => uint256)) internal allowed;\n\n\n  /**\n   * @dev Transfer tokens from one address to another\n   * @param _from address The address which you want to send tokens from\n   * @param _to address The address which you want to transfer to\n   * @param _value uint256 the amount of tokens to be transferred\n   */\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value <= balances[_from]);\n    require(_value <= allowed[_from][msg.sender]);\n\n    balances[_from] = balances[_from].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n    Transfer(_from, _to, _value);\n    return true;\n  }\n\n  /**\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n   *\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   * @param _spender The address which will spend the funds.\n   * @param _value The amount of tokens to be spent.\n   */\n  function approve(address _spender, uint256 _value) public returns (bool) {\n    allowed[msg.sender][_spender] = _value;\n    Approval(msg.sender, _spender, _value);\n    return true;\n  }\n\n  /**\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n   * @param _owner address The address which owns the funds.\n   * @param _spender address The address which will spend the funds.\n   * @return A uint256 specifying the amount of tokens still available for the spender.\n   */\n  function allowance(address _owner, address _spender) public view returns (uint256) {\n    return allowed[_owner][_spender];\n  }\n\n  /**\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\n   *\n   * approve should be called when allowed[_spender] == 0. To increment\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _addedValue The amount of tokens to increase the allowance by.\n   */\n  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n  /**\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n   *\n   * approve should be called when allowed[_spender] == 0. To decrement\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n   */\n  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n    uint oldValue = allowed[msg.sender][_spender];\n    if (_subtractedValue > oldValue) {\n      allowed[msg.sender][_spender] = 0;\n    } else {\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n    }\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n}",
        "function": null,
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GolemNetworkTokenBatching.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract TokenProxy is StandardToken {\n\n    ERC20Basic public TOKEN;\n\n    mapping(address => address) private gates;\n\n\n    event GateOpened(address indexed gate, address indexed user);\n\n    event Minted(address indexed to, uint256 amount);\n\n    event Burned(address indexed from, uint256 amount);\n\n    function TokenProxy(ERC20Basic _token) public {\n        TOKEN = _token;\n    }\n\n    function getGateAddress(address _user) external view returns (address) {\n        return gates[_user];\n    }\n\n    \n    function openGate() external {\n        address user = msg.sender;\n\n        // Do not allow creating more than one Gate per User.\n        require(gates[user] == 0);\n\n        // Create new Gate.\n        address gate = new Gate(TOKEN, this);\n\n        // Remember User - Gate relationship.\n        gates[user] = gate;\n\n        GateOpened(gate, user);\n    }\n\n    function transferFromGate() external {\n        address user = msg.sender;\n\n        address gate = gates[user];\n\n        // Make sure the User's Gate exists.\n        require(gate != 0);\n\n        uint256 value = TOKEN.balanceOf(gate);\n\n        Gate(gate).transferToProxy(value);\n\n        // Handle the information about the amount of migrated tokens.\n        // This is a trusted information becase it comes from the Gate.\n        totalSupply_ += value;\n        balances[user] += value;\n\n        Minted(user, value);\n    }\n\n    function withdraw(uint256 _value) external {\n      withdrawTo(_value, msg.sender);\n    }\n\n    function withdrawTo(uint256 _value, address _destination) public {\n        address user = msg.sender;\n        uint256 balance = balances[user];\n        require(_value <= balance);\n\n        balances[user] = (balance - _value);\n        totalSupply_ -= _value;\n\n        TOKEN.transfer(_destination, _value);\n\n        Burned(user, _value);\n    }\n}",
        "function": null,
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GolemNetworkTokenBatching.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract GNTDeposit is ReceivingContract {\n    address public concent;\n    address public coldwallet;\n    uint256 public withdrawal_delay;\n\n    ERC20 public token;\n    // owner => amount\n    mapping (address => uint256) public balances;\n    // owner => timestamp after which withdraw is possible\n    //        | 0 if locked\n    mapping (address => uint256) public locked_until;\n\n    event Deposit(address indexed _owner, uint256 _amount);\n    event Withdraw(address indexed _from, address indexed _to, uint256 _amount);\n    event Lock(address indexed _owner);\n    event Unlock(address indexed _owner);\n    event Burn(address indexed _who, uint256 _amount);\n    event ReimburseForSubtask(address indexed _requestor, address indexed _provider, uint256 _amount, bytes32 _subtask_id);\n    event ReimburseForNoPayment(address indexed _requestor, address indexed _provider, uint256 _amount, uint256 _closure_time);\n    event ReimburseForVerificationCosts(address indexed _from, uint256 _amount, bytes32 _subtask_id);\n\n    function GNTDeposit(\n        ERC20 _token,\n        address _concent,\n        address _coldwallet,\n        uint256 _withdrawal_delay\n    )\n        public\n    {\n        token = _token;\n        concent = _concent;\n        coldwallet = _coldwallet;\n        withdrawal_delay = _withdrawal_delay;\n    }\n\n    // modifiers\n\n    modifier onlyUnlocked() {\n        require(isUnlocked(msg.sender));\n        _;\n    }\n\n    modifier onlyConcent() {\n        require(msg.sender == concent);\n        _;\n    }\n\n    modifier onlyToken() {\n        require(msg.sender == address(token));\n        _;\n    }\n\n    // views\n\n    function balanceOf(address _owner) external view returns (uint256) {\n        return balances[_owner];\n    }\n\n    function isLocked(address _owner) external view returns (bool) {\n        return locked_until[_owner] == 0;\n    }\n\n    function isTimeLocked(address _owner) external view returns (bool) {\n        return locked_until[_owner] > block.timestamp;\n    }\n\n    function isUnlocked(address _owner) public view returns (bool) {\n        return locked_until[_owner] != 0 && locked_until[_owner] < block.timestamp;\n    }\n\n    function getTimelock(address _owner) external view returns (uint256) {\n        return locked_until[_owner];\n    }\n\n    // deposit API\n\n    function unlock() external {\n        locked_until[msg.sender] = block.timestamp + withdrawal_delay;\n        Unlock(msg.sender);\n    }\n\n    function lock() external {\n        locked_until[msg.sender] = 0;\n        Lock(msg.sender);\n    }\n\n    function onTokenReceived(address _from, uint _amount, bytes /* _data */) public onlyToken {\n        balances[_from] += _amount;\n        Deposit(_from, _amount);\n    }\n\n    function withdraw(address _to) onlyUnlocked external {\n        var _amount = balances[msg.sender];\n        balances[msg.sender] = 0;\n        locked_until[msg.sender] = 0;\n        require(token.transfer(_to, _amount));\n        Withdraw(msg.sender, _to, _amount);\n    }\n\n    function burn(address _whom, uint256 _burn) onlyConcent external {\n        _reimburse(_whom, 0xdeadbeef, _burn);\n        Burn(_whom, _burn);\n    }\n\n    function reimburseForSubtask(\n        address _requestor,\n        address _provider,\n        uint256 _amount,\n        bytes32 _subtask_id\n    )\n        onlyConcent\n        external\n    {\n        _reimburse(_requestor, _provider, _amount);\n        ReimburseForSubtask(_requestor, _provider, _amount, _subtask_id);\n    }\n\n    function reimburseForNoPayment(\n        address _requestor,\n        address _provider,\n        uint256 _amount,\n        uint256 _closure_time\n    )\n        onlyConcent\n        external\n    {\n        _reimburse(_requestor, _provider, _amount);\n        ReimburseForNoPayment(_requestor, _provider, _amount, _closure_time);\n    }\n\n    function reimburseForVerificationCosts(\n        address _from,\n        uint256 _amount,\n        bytes32 _subtask_id\n    )\n        onlyConcent\n        external\n    {\n        _reimburse(_from, coldwallet, _amount);\n        ReimburseForVerificationCosts(_from, _amount, _subtask_id);\n    }\n\n    // internals\n\n    function _reimburse(address _from, address _to, uint256 _amount) private {\n        require(balances[_from] >= _amount);\n        balances[_from] -= _amount;\n        if (balances[_from] == 0) {\n            locked_until[_from] = 0;\n        }\n        require(token.transfer(_to, _amount));\n    }\n\n}",
        "function": null,
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GNTDeposit.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract BasicToken is ERC20Basic {\n  using SafeMath for uint256;\n\n  mapping(address => uint256) balances;\n\n  uint256 totalSupply_;\n\n  /**\n  * @dev total number of tokens in existence\n  */\n  function totalSupply() public view returns (uint256) {\n    return totalSupply_;\n  }\n\n  /**\n  * @dev transfer token for a specified address\n  * @param _to The address to transfer to.\n  * @param _value The amount to be transferred.\n  */\n  function transfer(address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value <= balances[msg.sender]);\n\n    // SafeMath.sub will throw if there is not enough balance.\n    balances[msg.sender] = balances[msg.sender].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    Transfer(msg.sender, _to, _value);\n    return true;\n  }\n\n  /**\n  * @dev Gets the balance of the specified address.\n  * @param _owner The address to query the the balance of.\n  * @return An uint256 representing the amount owned by the passed address.\n  */\n  function balanceOf(address _owner) public view returns (uint256 balance) {\n    return balances[_owner];\n  }\n\n}",
        "function": null,
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GNTPaymentChannels.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract GNTPaymentChannels is ReceivingContract {\n\n    GolemNetworkTokenBatching public token;\n\n    struct PaymentChannel {\n        address owner;\n        address receiver;\n        uint256 deposited;\n        // withdrawn <= deposited (less or equal)\n        uint256 withdrawn;\n        //   0, if locked\n        // | timestamp, after which withdraw is possible\n        uint256 locked_until;\n    }\n\n    uint256 id;\n    mapping (bytes32 => PaymentChannel) public channels;\n    uint256 close_delay;\n\n    event NewChannel(address indexed _owner, address indexed _receiver, bytes32 _channel);\n    event Fund(address indexed _receiver, bytes32 indexed _channel, uint256 amount);\n    event Withdraw(address indexed _owner, address indexed _receiver);\n    event TimeLocked(address indexed _owner, address indexed _receiver, bytes32 _channel);\n    event Close(address indexed _owner, address indexed _receiver, bytes32 _channel);\n    event ForceClose(address indexed _owner, address indexed _receiver, bytes32 _channel);\n\n    function GNTPaymentChannels(address _token, uint256 _close_delay)\n        public {\n        token = GolemNetworkTokenBatching(_token);\n        id = 0;\n        close_delay = _close_delay;\n    }\n\n    modifier onlyToken() {\n        require(msg.sender == address(token));\n        _;\n    }\n\n    modifier onlyValidSig(bytes32 _ch, uint _value,\n                      uint8 _v, bytes32 _r, bytes32 _s) {\n        require(isValidSig(_ch, _value, _v, _r, _s));\n        _;\n    }\n\n    modifier onlyOwner(bytes32 _channel) {\n        require(msg.sender == channels[_channel].owner);\n        _;\n    }\n\n    modifier unlocked(bytes32 _channel) {\n        require(isUnlocked(_channel));\n        _;\n    }\n\n    // helpers: check channel status\n\n    function getDeposited(bytes32 _channel)\n        external\n        view\n        returns (uint256) {\n        PaymentChannel ch = channels[_channel];\n        return ch.deposited;\n    }\n\n    function getWithdrawn(bytes32 _channel)\n        external\n        view\n        returns (uint256) {\n        return channels[_channel].withdrawn;\n    }\n\n    function getOwner(bytes32 _channel)\n        external\n        view\n        returns (address) {\n        return channels[_channel].owner;\n    }\n\n    function getReceiver(bytes32 _channel)\n        external\n        view\n        returns (address) {\n        return channels[_channel].receiver;\n    }\n\n    function isLocked(bytes32 _channel) public returns (bool) {\n        return channels[_channel].locked_until == 0;\n    }\n\n    function isTimeLocked(bytes32 _channel) public view returns (bool) {\n        return channels[_channel].locked_until >= block.timestamp;\n    }\n\n    function isUnlocked(bytes32 _channel) public view returns (bool) {\n        return ((channels[_channel].locked_until != 0) &&\n                (channels[_channel].locked_until < block.timestamp));\n    }\n\n    function isValidSig(bytes32 _ch, uint _value,\n                        uint8 _v, bytes32 _r, bytes32 _s) view returns (bool) {\n        return (channels[_ch].owner) == (ecrecover(sha3(_ch, _value), _v, _r, _s));\n    }\n\n    // functions that modify state\n\n    // FIXME: Channel needs to be created before it can be funded.\n    function createChannel(address _receiver)\n        external {\n        bytes32 channel = sha3(id++);\n        channels[channel] = PaymentChannel(msg.sender, _receiver, 0, 0, 0);\n        NewChannel(msg.sender, _receiver, channel); // event\n    }\n\n    // Fund existing channel; can be done multiple times.\n    function onTokenReceived(address _from, uint _value, bytes _data) {\n        bytes32 channel;\n        assembly {\n          channel := mload(add(_data, 32))\n        }\n        PaymentChannel ch = channels[channel];\n        require(_from == ch.owner);\n        ch.deposited += _value;\n        Fund(ch.receiver, channel, _value);\n    }\n\n    // Fund existing channel; can be done multiple times.\n    // Uses ERC20 token API\n    function fund(bytes32 _channel, uint256 _amount)\n        returns (bool) {\n        PaymentChannel ch = channels[_channel];\n        // check if channel exists\n        // this prevents fund loss\n        require(ch.receiver != address(0));\n        if (token.transferFrom(msg.sender, address(this), _amount)) {\n            ch.deposited += _amount;\n            ch.locked_until = 0;\n            Fund(ch.receiver, _channel, _amount); // event\n            return true;\n        }\n        return false;\n    }\n\n    // Receiver can withdraw multiple times without closing the channel\n    function withdraw(bytes32 _channel, uint256 _value,\n                      uint8 _v, bytes32 _r, bytes32 _s)\n        external\n        onlyValidSig(_channel, _value, _v, _r, _s)\n        returns (bool) {\n        PaymentChannel ch = channels[_channel];\n        require(ch.withdrawn < _value); // <- STRICT less than!\n        var amount = _value - ch.withdrawn;\n        // Receiver has been cheated! Withdraw as much as possible.\n        if (ch.deposited - ch.withdrawn < amount)\n            amount = ch.deposited - ch.withdrawn;\n        return _do_withdraw(_channel, amount);\n    }\n\n    // If receiver does not want to close channel, owner can do that\n    // by calling unlock and waiting for grace period (close_delay).\n    function unlock(bytes32 _channel)\n        external\n        onlyOwner(_channel) {\n        PaymentChannel ch = channels[_channel];\n        ch.locked_until = block.timestamp + close_delay;\n        TimeLocked(ch.owner, ch.receiver, _channel);\n    }\n\n    // Owner can close channel to reclaim its money.\n    function close(bytes32 _channel)\n        external\n        onlyOwner(_channel)\n        unlocked(_channel)\n        returns (bool) {\n        return _do_close(_channel, false);\n    }\n\n    // Receiver can close channel and return owner all of the funds.\n    // Receiver should `withdraw` its own funds first!\n    function forceClose(bytes32 _channel)\n        external\n        returns (bool) {\n        require(msg.sender == channels[_channel].receiver);\n        return _do_close(_channel, true);\n    }\n\n    // internals\n\n    function _do_withdraw(bytes32 _channel, uint256 _amount)\n        private\n        returns (bool) {\n\n        PaymentChannel ch = channels[_channel];\n        if (token.transfer(ch.receiver, _amount)) {\n            ch.withdrawn += _amount;\n            Withdraw(ch.owner, ch.receiver);\n            return true;\n        }\n        return false;\n    }\n\n    function _do_close(bytes32 _channel, bool force)\n        private\n        returns (bool) {\n\n        PaymentChannel ch = channels[_channel];\n        var amount = ch.deposited - ch.withdrawn;\n        if (token.transfer(ch.owner, amount)) {\n            if (force)\n                { ForceClose(ch.owner, ch.receiver, _channel); }\n            else\n                { Close(ch.owner, ch.receiver, _channel); }\n            delete channels[_channel];\n            return true;\n        }\n        return false;\n    }\n}",
        "function": null,
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GNTPaymentChannels.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract GolemNetworkTokenBatching is TokenProxy {\n\n    string public constant name = \"Golem Network Token Batching\";\n    string public constant symbol = \"GNTB\";\n    uint8 public constant decimals = 18;\n\n\n    event BatchTransfer(address indexed from, address indexed to, uint256 value,\n        uint64 closureTime);\n\n    function GolemNetworkTokenBatching(ERC20Basic _gntToken) TokenProxy(_gntToken) public {\n    }\n\n    function batchTransfer(bytes32[] payments, uint64 closureTime) external {\n        require(block.timestamp >= closureTime);\n\n        uint balance = balances[msg.sender];\n\n        for (uint i = 0; i < payments.length; ++i) {\n            // A payment contains compressed data:\n            // first 96 bits (12 bytes) is a value,\n            // following 160 bits (20 bytes) is an address.\n            bytes32 payment = payments[i];\n            address addr = address(payment);\n            uint v = uint(payment) / 2**160;\n            require(v <= balance);\n            balances[addr] += v;\n            balance -= v;\n            BatchTransfer(msg.sender, addr, v, closureTime);\n        }\n\n        balances[msg.sender] = balance;\n    }\n\n    function transferAndCall(address to, uint256 value, bytes data) external {\n      // Transfer always returns true so no need to check return value\n      transfer(to, value);\n\n      // No need to check whether recipient is a contract, this method is\n      // supposed to used only with contract recipients\n      ReceivingContract(to).onTokenReceived(msg.sender, value, data);\n    }\n}",
        "function": null,
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GNTPaymentChannels.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract StandardToken is ERC20, BasicToken {\n\n  mapping (address => mapping (address => uint256)) internal allowed;\n\n\n  /**\n   * @dev Transfer tokens from one address to another\n   * @param _from address The address which you want to send tokens from\n   * @param _to address The address which you want to transfer to\n   * @param _value uint256 the amount of tokens to be transferred\n   */\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value <= balances[_from]);\n    require(_value <= allowed[_from][msg.sender]);\n\n    balances[_from] = balances[_from].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n    Transfer(_from, _to, _value);\n    return true;\n  }\n\n  /**\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n   *\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   * @param _spender The address which will spend the funds.\n   * @param _value The amount of tokens to be spent.\n   */\n  function approve(address _spender, uint256 _value) public returns (bool) {\n    allowed[msg.sender][_spender] = _value;\n    Approval(msg.sender, _spender, _value);\n    return true;\n  }\n\n  /**\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n   * @param _owner address The address which owns the funds.\n   * @param _spender address The address which will spend the funds.\n   * @return A uint256 specifying the amount of tokens still available for the spender.\n   */\n  function allowance(address _owner, address _spender) public view returns (uint256) {\n    return allowed[_owner][_spender];\n  }\n\n  /**\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\n   *\n   * approve should be called when allowed[_spender] == 0. To increment\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _addedValue The amount of tokens to increase the allowance by.\n   */\n  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n  /**\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n   *\n   * approve should be called when allowed[_spender] == 0. To decrement\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n   */\n  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n    uint oldValue = allowed[msg.sender][_spender];\n    if (_subtractedValue > oldValue) {\n      allowed[msg.sender][_spender] = 0;\n    } else {\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n    }\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n}",
        "function": null,
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GNTPaymentChannels.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract TokenProxy is StandardToken {\n\n    ERC20Basic public TOKEN;\n\n    mapping(address => address) private gates;\n\n\n    event GateOpened(address indexed gate, address indexed user);\n\n    event Minted(address indexed to, uint256 amount);\n\n    event Burned(address indexed from, uint256 amount);\n\n    function TokenProxy(ERC20Basic _token) public {\n        TOKEN = _token;\n    }\n\n    function getGateAddress(address _user) external view returns (address) {\n        return gates[_user];\n    }\n\n    \n    function openGate() external {\n        address user = msg.sender;\n\n        // Do not allow creating more than one Gate per User.\n        require(gates[user] == 0);\n\n        // Create new Gate.\n        address gate = new Gate(TOKEN, this);\n\n        // Remember User - Gate relationship.\n        gates[user] = gate;\n\n        GateOpened(gate, user);\n    }\n\n    function transferFromGate() external {\n        address user = msg.sender;\n\n        address gate = gates[user];\n\n        // Make sure the User's Gate exists.\n        require(gate != 0);\n\n        uint256 value = TOKEN.balanceOf(gate);\n\n        Gate(gate).transferToProxy(value);\n\n        // Handle the information about the amount of migrated tokens.\n        // This is a trusted information becase it comes from the Gate.\n        totalSupply_ += value;\n        balances[user] += value;\n\n        Minted(user, value);\n    }\n\n    function withdraw(uint256 _value) external {\n      withdrawTo(_value, msg.sender);\n    }\n\n    function withdrawTo(uint256 _value, address _destination) public {\n        address user = msg.sender;\n        uint256 balance = balances[user];\n        require(_value <= balance);\n\n        balances[user] = (balance - _value);\n        totalSupply_ -= _value;\n\n        TOKEN.transfer(_destination, _value);\n\n        Burned(user, _value);\n    }\n}",
        "function": null,
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GNTPaymentChannels.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract PolyDistribution is Ownable {\n  using SafeMath for uint256;\n\n  PolyToken public POLY;\n\n  uint256 private constant decimalFactor = 10**uint256(18);\n  enum AllocationType { PRESALE, FOUNDER, AIRDROP, ADVISOR, RESERVE, BONUS1, BONUS2, BONUS3 }\n  uint256 public constant INITIAL_SUPPLY   = 1000000000 * decimalFactor;\n  uint256 public AVAILABLE_TOTAL_SUPPLY    = 1000000000 * decimalFactor;\n  uint256 public AVAILABLE_PRESALE_SUPPLY  =  240000000 * decimalFactor; // 100% Released at Token Distribution (TD)\n  uint256 public AVAILABLE_FOUNDER_SUPPLY  =  150000000 * decimalFactor; // 25% Released at TD +1 year -> 100% at TD +4 years\n  uint256 public AVAILABLE_AIRDROP_SUPPLY  =   10000000 * decimalFactor; // 100% Released at TD\n  uint256 public AVAILABLE_ADVISOR_SUPPLY  =   25000000 * decimalFactor; // 100% Released at TD +7 months\n  uint256 public AVAILABLE_RESERVE_SUPPLY  =  495000000 * decimalFactor; // 12.5% Released at TD +6 months -> 100% at TD +4 years\n\n  uint256 public AVAILABLE_BONUS1_SUPPLY  =    20000000 * decimalFactor;\n  uint256 public AVAILABLE_BONUS2_SUPPLY  =    30000000 * decimalFactor;\n  uint256 public AVAILABLE_BONUS3_SUPPLY  =    30000000 * decimalFactor;\n\n  uint256 public grandTotalClaimed = 0;\n  uint256 public startTime;\n\n  // Allocation with vesting information\n  struct Allocation {\n    uint8 AllocationSupply; // Type of allocation\n    uint256 endCliff;       // Tokens are locked until\n    uint256 endVesting;     // This is when the tokens are fully unvested\n    uint256 totalAllocated; // Total tokens allocated\n    uint256 amountClaimed;  // Total tokens claimed\n  }\n  mapping (address => Allocation) public allocations;\n\n  // List of admins\n  mapping (address => bool) public airdropAdmins;\n\n  // Keeps track of whether or not a 250 POLY airdrop has been made to a particular address\n  mapping (address => bool) public airdrops;\n\n  modifier onlyOwnerOrAdmin() {\n    require(msg.sender == owner || airdropAdmins[msg.sender]);\n    _;\n  }\n\n  event LogNewAllocation(address indexed _recipient, AllocationType indexed _fromSupply, uint256 _totalAllocated, uint256 _grandTotalAllocated);\n  event LogPolyClaimed(address indexed _recipient, uint8 indexed _fromSupply, uint256 _amountClaimed, uint256 _totalAllocated, uint256 _grandTotalClaimed);\n\n  /**\n    * @dev Constructor function - Set the poly token address\n    * @param _startTime The time when PolyDistribution goes live\n    */\n    function PolyDistribution(uint256 _startTime) public {\n      require(_startTime >= now);\n      require(AVAILABLE_TOTAL_SUPPLY == AVAILABLE_PRESALE_SUPPLY.add(AVAILABLE_FOUNDER_SUPPLY).add(AVAILABLE_AIRDROP_SUPPLY).add(AVAILABLE_ADVISOR_SUPPLY).add(AVAILABLE_BONUS1_SUPPLY).add(AVAILABLE_BONUS2_SUPPLY).add(AVAILABLE_BONUS3_SUPPLY).add(AVAILABLE_RESERVE_SUPPLY));\n      startTime = _startTime;\n      POLY = new PolyToken(this);\n    }\n\n  /**\n    * @dev Allow the owner of the contract to assign a new allocation\n    * @param _recipient The recipient of the allocation\n    * @param _totalAllocated The total amount of POLY available to the receipient (after vesting)\n    * @param _supply The POLY supply the allocation will be taken from\n    */\n  function setAllocation (address _recipient, uint256 _totalAllocated, AllocationType _supply) onlyOwner public {\n    require(allocations[_recipient].totalAllocated == 0 && _totalAllocated > 0);\n    require(_supply >= AllocationType.PRESALE && _supply <= AllocationType.BONUS3);\n    require(_recipient != address(0));\n    if (_supply == AllocationType.PRESALE) {\n      AVAILABLE_PRESALE_SUPPLY = AVAILABLE_PRESALE_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.PRESALE), 0, 0, _totalAllocated, 0);\n    } else if (_supply == AllocationType.FOUNDER) {\n      AVAILABLE_FOUNDER_SUPPLY = AVAILABLE_FOUNDER_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.FOUNDER), startTime + 1 years, startTime + 4 years, _totalAllocated, 0);\n    } else if (_supply == AllocationType.ADVISOR) {\n      AVAILABLE_ADVISOR_SUPPLY = AVAILABLE_ADVISOR_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.ADVISOR), startTime + 212 days, 0, _totalAllocated, 0);\n    } else if (_supply == AllocationType.RESERVE) {\n      AVAILABLE_RESERVE_SUPPLY = AVAILABLE_RESERVE_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.RESERVE), startTime + 182 days, startTime + 4 years, _totalAllocated, 0);\n    } else if (_supply == AllocationType.BONUS1) {\n      AVAILABLE_BONUS1_SUPPLY = AVAILABLE_BONUS1_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.BONUS1), startTime + 1 years, startTime + 1 years, _totalAllocated, 0);\n    } else if (_supply == AllocationType.BONUS2) {\n      AVAILABLE_BONUS2_SUPPLY = AVAILABLE_BONUS2_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.BONUS2), startTime + 2 years, startTime + 2 years, _totalAllocated, 0);\n    } else if (_supply == AllocationType.BONUS3) {\n      AVAILABLE_BONUS3_SUPPLY = AVAILABLE_BONUS3_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.BONUS3), startTime + 3 years, startTime + 3 years, _totalAllocated, 0);\n    }\n    AVAILABLE_TOTAL_SUPPLY = AVAILABLE_TOTAL_SUPPLY.sub(_totalAllocated);\n    LogNewAllocation(_recipient, _supply, _totalAllocated, grandTotalAllocated());\n  }\n\n  /**\n    * @dev Add an airdrop admin\n    */\n  function setAirdropAdmin(address _admin, bool _isAdmin) public onlyOwner {\n    airdropAdmins[_admin] = _isAdmin;\n  }\n\n  /**\n    * @dev perform a transfer of allocations\n    * @param _recipient is a list of recipients\n    */\n  function airdropTokens(address[] _recipient) public onlyOwnerOrAdmin {\n    require(now >= startTime);\n    uint airdropped;\n    //SWC-101-Integer Overflow and Underflow: L121\n    for(uint8 i = 0; i< _recipient.length; i++)\n    {\n        if (!airdrops[_recipient[i]]) {\n          airdrops[_recipient[i]] = true;\n          require(POLY.transfer(_recipient[i], 250 * decimalFactor));\n          airdropped = airdropped.add(250 * decimalFactor);\n        }\n    }\n    AVAILABLE_AIRDROP_SUPPLY = AVAILABLE_AIRDROP_SUPPLY.sub(airdropped);\n    AVAILABLE_TOTAL_SUPPLY = AVAILABLE_TOTAL_SUPPLY.sub(airdropped);\n    grandTotalClaimed = grandTotalClaimed.add(airdropped);\n  }\n\n  /**\n    * @dev Transfer a recipients available allocation to their address\n    * @param _recipient The address to withdraw tokens for\n    */\n  function transferTokens (address _recipient) public {\n    require(allocations[_recipient].amountClaimed < allocations[_recipient].totalAllocated);\n    require(now >= allocations[_recipient].endCliff);\n    require(now >= startTime);\n    uint256 newAmountClaimed;\n    if (allocations[_recipient].endVesting > now) {\n      // Transfer available amount based on vesting schedule and allocation\n      newAmountClaimed = allocations[_recipient].totalAllocated.mul(now.sub(startTime)).div(allocations[_recipient].endVesting.sub(startTime));\n    } else {\n      // Transfer total allocated (minus previously claimed tokens)\n      newAmountClaimed = allocations[_recipient].totalAllocated;\n    }\n    uint256 tokensToTransfer = newAmountClaimed.sub(allocations[_recipient].amountClaimed);\n    allocations[_recipient].amountClaimed = newAmountClaimed;\n    POLY.transfer(_recipient, tokensToTransfer);\n    grandTotalClaimed = grandTotalClaimed.add(tokensToTransfer);\n    LogPolyClaimed(_recipient, allocations[_recipient].AllocationSupply, tokensToTransfer, newAmountClaimed, grandTotalClaimed);\n  }\n\n  // Returns the amount of POLY allocated\n  function grandTotalAllocated() public view returns (uint256) {\n    return INITIAL_SUPPLY - AVAILABLE_TOTAL_SUPPLY;\n  }\n\n  // Allow transfer of accidentally sent ERC20 tokens\n  function refundTokens(address _recipient, address _token) public onlyOwner {\n    require(_token != address(POLY));\n    IERC20 token = IERC20(_token);\n    uint256 balance = token.balanceOf(this);\n    token.transfer(_recipient, balance);\n  }\n}",
        "function": null,
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/openzeppelin-Polymath/polymath-token-672fabe081e8f90ea025252d92c2eb247d60010e/contracts/PolyDistribution.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract PolyDistribution is Ownable {\n  using SafeMath for uint256;\n\n  PolyToken public POLY;\n\n  uint256 private constant decimalFactor = 10**uint256(18);\n  enum AllocationType { PRESALE, FOUNDER, AIRDROP, ADVISOR, RESERVE, BONUS1, BONUS2, BONUS3 }\n  uint256 public constant INITIAL_SUPPLY   = 1000000000 * decimalFactor;\n  uint256 public AVAILABLE_TOTAL_SUPPLY    = 1000000000 * decimalFactor;\n  uint256 public AVAILABLE_PRESALE_SUPPLY  =  240000000 * decimalFactor; // 100% Released at Token Distribution (TD)\n  uint256 public AVAILABLE_FOUNDER_SUPPLY  =  150000000 * decimalFactor; // 25% Released at TD +1 year -> 100% at TD +4 years\n  uint256 public AVAILABLE_AIRDROP_SUPPLY  =   10000000 * decimalFactor; // 100% Released at TD\n  uint256 public AVAILABLE_ADVISOR_SUPPLY  =   25000000 * decimalFactor; // 100% Released at TD +7 months\n  uint256 public AVAILABLE_RESERVE_SUPPLY  =  495000000 * decimalFactor; // 12.5% Released at TD +6 months -> 100% at TD +4 years\n\n  uint256 public AVAILABLE_BONUS1_SUPPLY  =    20000000 * decimalFactor;\n  uint256 public AVAILABLE_BONUS2_SUPPLY  =    30000000 * decimalFactor;\n  uint256 public AVAILABLE_BONUS3_SUPPLY  =    30000000 * decimalFactor;\n\n  uint256 public grandTotalClaimed = 0;\n  uint256 public startTime;\n\n  // Allocation with vesting information\n  struct Allocation {\n    uint8 AllocationSupply; // Type of allocation\n    uint256 endCliff;       // Tokens are locked until\n    uint256 endVesting;     // This is when the tokens are fully unvested\n    uint256 totalAllocated; // Total tokens allocated\n    uint256 amountClaimed;  // Total tokens claimed\n  }\n  mapping (address => Allocation) public allocations;\n\n  // List of admins\n  mapping (address => bool) public airdropAdmins;\n\n  // Keeps track of whether or not a 250 POLY airdrop has been made to a particular address\n  mapping (address => bool) public airdrops;\n\n  modifier onlyOwnerOrAdmin() {\n    require(msg.sender == owner || airdropAdmins[msg.sender]);\n    _;\n  }\n\n  event LogNewAllocation(address indexed _recipient, AllocationType indexed _fromSupply, uint256 _totalAllocated, uint256 _grandTotalAllocated);\n  event LogPolyClaimed(address indexed _recipient, uint8 indexed _fromSupply, uint256 _amountClaimed, uint256 _totalAllocated, uint256 _grandTotalClaimed);\n\n  /**\n    * @dev Constructor function - Set the poly token address\n    * @param _startTime The time when PolyDistribution goes live\n    */\n    function PolyDistribution(uint256 _startTime) public {\n      require(_startTime >= now);\n      require(AVAILABLE_TOTAL_SUPPLY == AVAILABLE_PRESALE_SUPPLY.add(AVAILABLE_FOUNDER_SUPPLY).add(AVAILABLE_AIRDROP_SUPPLY).add(AVAILABLE_ADVISOR_SUPPLY).add(AVAILABLE_BONUS1_SUPPLY).add(AVAILABLE_BONUS2_SUPPLY).add(AVAILABLE_BONUS3_SUPPLY).add(AVAILABLE_RESERVE_SUPPLY));\n      startTime = _startTime;\n      POLY = new PolyToken(this);\n    }\n\n  /**\n    * @dev Allow the owner of the contract to assign a new allocation\n    * @param _recipient The recipient of the allocation\n    * @param _totalAllocated The total amount of POLY available to the receipient (after vesting)\n    * @param _supply The POLY supply the allocation will be taken from\n    */\n  function setAllocation (address _recipient, uint256 _totalAllocated, AllocationType _supply) onlyOwner public {\n    require(allocations[_recipient].totalAllocated == 0 && _totalAllocated > 0);\n    require(_supply >= AllocationType.PRESALE && _supply <= AllocationType.BONUS3);\n    require(_recipient != address(0));\n    if (_supply == AllocationType.PRESALE) {\n      AVAILABLE_PRESALE_SUPPLY = AVAILABLE_PRESALE_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.PRESALE), 0, 0, _totalAllocated, 0);\n    } else if (_supply == AllocationType.FOUNDER) {\n      AVAILABLE_FOUNDER_SUPPLY = AVAILABLE_FOUNDER_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.FOUNDER), startTime + 1 years, startTime + 4 years, _totalAllocated, 0);\n    } else if (_supply == AllocationType.ADVISOR) {\n      AVAILABLE_ADVISOR_SUPPLY = AVAILABLE_ADVISOR_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.ADVISOR), startTime + 212 days, 0, _totalAllocated, 0);\n    } else if (_supply == AllocationType.RESERVE) {\n      AVAILABLE_RESERVE_SUPPLY = AVAILABLE_RESERVE_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.RESERVE), startTime + 182 days, startTime + 4 years, _totalAllocated, 0);\n    } else if (_supply == AllocationType.BONUS1) {\n      AVAILABLE_BONUS1_SUPPLY = AVAILABLE_BONUS1_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.BONUS1), startTime + 1 years, startTime + 1 years, _totalAllocated, 0);\n    } else if (_supply == AllocationType.BONUS2) {\n      AVAILABLE_BONUS2_SUPPLY = AVAILABLE_BONUS2_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.BONUS2), startTime + 2 years, startTime + 2 years, _totalAllocated, 0);\n    } else if (_supply == AllocationType.BONUS3) {\n      AVAILABLE_BONUS3_SUPPLY = AVAILABLE_BONUS3_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.BONUS3), startTime + 3 years, startTime + 3 years, _totalAllocated, 0);\n    }\n    AVAILABLE_TOTAL_SUPPLY = AVAILABLE_TOTAL_SUPPLY.sub(_totalAllocated);\n    LogNewAllocation(_recipient, _supply, _totalAllocated, grandTotalAllocated());\n  }\n\n  /**\n    * @dev Add an airdrop admin\n    */\n  function setAirdropAdmin(address _admin, bool _isAdmin) public onlyOwner {\n    airdropAdmins[_admin] = _isAdmin;\n  }\n\n  /**\n    * @dev perform a transfer of allocations\n    * @param _recipient is a list of recipients\n    */\n  function airdropTokens(address[] _recipient) public onlyOwnerOrAdmin {\n    require(now >= startTime);\n    uint airdropped;\n    //SWC-101-Integer Overflow and Underflow: L121\n    for(uint8 i = 0; i< _recipient.length; i++)\n    {\n        if (!airdrops[_recipient[i]]) {\n          airdrops[_recipient[i]] = true;\n          require(POLY.transfer(_recipient[i], 250 * decimalFactor));\n          airdropped = airdropped.add(250 * decimalFactor);\n        }\n    }\n    AVAILABLE_AIRDROP_SUPPLY = AVAILABLE_AIRDROP_SUPPLY.sub(airdropped);\n    AVAILABLE_TOTAL_SUPPLY = AVAILABLE_TOTAL_SUPPLY.sub(airdropped);\n    grandTotalClaimed = grandTotalClaimed.add(airdropped);\n  }\n\n  /**\n    * @dev Transfer a recipients available allocation to their address\n    * @param _recipient The address to withdraw tokens for\n    */\n  function transferTokens (address _recipient) public {\n    require(allocations[_recipient].amountClaimed < allocations[_recipient].totalAllocated);\n    require(now >= allocations[_recipient].endCliff);\n    require(now >= startTime);\n    uint256 newAmountClaimed;\n    if (allocations[_recipient].endVesting > now) {\n      // Transfer available amount based on vesting schedule and allocation\n      newAmountClaimed = allocations[_recipient].totalAllocated.mul(now.sub(startTime)).div(allocations[_recipient].endVesting.sub(startTime));\n    } else {\n      // Transfer total allocated (minus previously claimed tokens)\n      newAmountClaimed = allocations[_recipient].totalAllocated;\n    }\n    uint256 tokensToTransfer = newAmountClaimed.sub(allocations[_recipient].amountClaimed);\n    allocations[_recipient].amountClaimed = newAmountClaimed;\n    POLY.transfer(_recipient, tokensToTransfer);\n    grandTotalClaimed = grandTotalClaimed.add(tokensToTransfer);\n    LogPolyClaimed(_recipient, allocations[_recipient].AllocationSupply, tokensToTransfer, newAmountClaimed, grandTotalClaimed);\n  }\n\n  // Returns the amount of POLY allocated\n  function grandTotalAllocated() public view returns (uint256) {\n    return INITIAL_SUPPLY - AVAILABLE_TOTAL_SUPPLY;\n  }\n\n  // Allow transfer of accidentally sent ERC20 tokens\n  function refundTokens(address _recipient, address _token) public onlyOwner {\n    require(_token != address(POLY));\n    IERC20 token = IERC20(_token);\n    uint256 balance = token.balanceOf(this);\n    token.transfer(_recipient, balance);\n  }\n}",
        "function": null,
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/openzeppelin-Polymath/polymath-token-672fabe081e8f90ea025252d92c2eb247d60010e/contracts/PolyDistribution.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract PolyToken is IERC20 {\n  using SafeMath for uint256;\n\n  // Poly Token parameters\n  string public name = 'Polymath';\n  string public symbol = 'POLY';\n  uint8 public constant decimals = 18;\n  uint256 public constant decimalFactor = 10 ** uint256(decimals);\n  uint256 public totalSupply = 1000000000 * decimalFactor;\n  mapping (address => uint256) balances;\n  mapping (address => mapping (address => uint256)) internal allowed;\n\n  /**\n  * @dev Constructor for Poly creation\n  * @dev Assigns the totalSupply to the PolyDistribution contract\n  */\n  function PolyToken(address _polyDistributionContractAddress) public {\n    balances[_polyDistributionContractAddress] = totalSupply;\n  }\n\n  /**\n  * @dev Gets the balance of the specified address.\n  * @param _owner The address to query the the balance of.\n  * @return An uint256 representing the amount owned by the passed address.\n  */\n  function balanceOf(address _owner) public view returns (uint256 balance) {\n    return balances[_owner];\n  }\n\n  /**\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n   * @param _owner address The address which owns the funds.\n   * @param _spender address The address which will spend the funds.\n   * @return A uint256 specifying the amount of tokens still available for the spender.\n   */\n  function allowance(address _owner, address _spender) public view returns (uint256) {\n    return allowed[_owner][_spender];\n  }\n\n  /**\n  * @dev transfer token for a specified address\n  * @param _to The address to transfer to.\n  * @param _value The amount to be transferred.\n  */\n  function transfer(address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value <= balances[msg.sender]);\n\n    // SafeMath.sub will throw if there is not enough balance.\n    balances[msg.sender] = balances[msg.sender].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    Transfer(msg.sender, _to, _value);\n    return true;\n  }\n\n  /**\n   * @dev Transfer tokens from one address to another\n   * @param _from address The address which you want to send tokens from\n   * @param _to address The address which you want to transfer to\n   * @param _value uint256 the amount of tokens to be transferred\n   */\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value <= balances[_from]);\n    require(_value <= allowed[_from][msg.sender]);\n\n    balances[_from] = balances[_from].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n    Transfer(_from, _to, _value);\n    return true;\n  }\n\n  /**\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n   *\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   * @param _spender The address which will spend the funds.\n   * @param _value The amount of tokens to be spent.\n   */\n  function approve(address _spender, uint256 _value) public returns (bool) {\n    allowed[msg.sender][_spender] = _value;\n    Approval(msg.sender, _spender, _value);\n    return true;\n  }\n\n  /**\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\n   *\n   * approve should be called when allowed[_spender] == 0. To increment\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _addedValue The amount of tokens to increase the allowance by.\n   */\n  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n  /**\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n   *\n   * approve should be called when allowed[_spender] == 0. To decrement\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n   */\n  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n    uint oldValue = allowed[msg.sender][_spender];\n    if (_subtractedValue > oldValue) {\n      allowed[msg.sender][_spender] = 0;\n    } else {\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n    }\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n}",
        "function": null,
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/openzeppelin-Polymath/polymath-token-672fabe081e8f90ea025252d92c2eb247d60010e/contracts/PolyDistribution.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract PolyToken is IERC20 {\n  using SafeMath for uint256;\n\n  // Poly Token parameters\n  string public name = 'Polymath';\n  string public symbol = 'POLY';\n  uint8 public constant decimals = 18;\n  uint256 public constant decimalFactor = 10 ** uint256(decimals);\n  uint256 public totalSupply = 1000000000 * decimalFactor;\n  mapping (address => uint256) balances;\n  mapping (address => mapping (address => uint256)) internal allowed;\n\n  /**\n  * @dev Constructor for Poly creation\n  * @dev Assigns the totalSupply to the PolyDistribution contract\n  */\n  function PolyToken(address _polyDistributionContractAddress) public {\n    balances[_polyDistributionContractAddress] = totalSupply;\n  }\n\n  /**\n  * @dev Gets the balance of the specified address.\n  * @param _owner The address to query the the balance of.\n  * @return An uint256 representing the amount owned by the passed address.\n  */\n  function balanceOf(address _owner) public view returns (uint256 balance) {\n    return balances[_owner];\n  }\n\n  /**\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n   * @param _owner address The address which owns the funds.\n   * @param _spender address The address which will spend the funds.\n   * @return A uint256 specifying the amount of tokens still available for the spender.\n   */\n  function allowance(address _owner, address _spender) public view returns (uint256) {\n    return allowed[_owner][_spender];\n  }\n\n  /**\n  * @dev transfer token for a specified address\n  * @param _to The address to transfer to.\n  * @param _value The amount to be transferred.\n  */\n  function transfer(address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value <= balances[msg.sender]);\n\n    // SafeMath.sub will throw if there is not enough balance.\n    balances[msg.sender] = balances[msg.sender].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    Transfer(msg.sender, _to, _value);\n    return true;\n  }\n\n  /**\n   * @dev Transfer tokens from one address to another\n   * @param _from address The address which you want to send tokens from\n   * @param _to address The address which you want to transfer to\n   * @param _value uint256 the amount of tokens to be transferred\n   */\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value <= balances[_from]);\n    require(_value <= allowed[_from][msg.sender]);\n\n    balances[_from] = balances[_from].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n    Transfer(_from, _to, _value);\n    return true;\n  }\n\n  /**\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n   *\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   * @param _spender The address which will spend the funds.\n   * @param _value The amount of tokens to be spent.\n   */\n  function approve(address _spender, uint256 _value) public returns (bool) {\n    allowed[msg.sender][_spender] = _value;\n    Approval(msg.sender, _spender, _value);\n    return true;\n  }\n\n  /**\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\n   *\n   * approve should be called when allowed[_spender] == 0. To increment\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _addedValue The amount of tokens to increase the allowance by.\n   */\n  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n  /**\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n   *\n   * approve should be called when allowed[_spender] == 0. To decrement\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n   */\n  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n    uint oldValue = allowed[msg.sender][_spender];\n    if (_subtractedValue > oldValue) {\n      allowed[msg.sender][_spender] = 0;\n    } else {\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n    }\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n}",
        "function": null,
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/openzeppelin-Polymath/polymath-token-672fabe081e8f90ea025252d92c2eb247d60010e/contracts/PolyDistribution.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract ROSCA {\n\n  \n  // CONSTANTS\n  \n  uint64 constant internal MIN_CONTRIBUTION_SIZE = 1 finney;  // 1e-3 ether\n  uint128 constant internal MAX_CONTRIBUTION_SIZE = 10 ether;\n\n  // Maximum fee (in 1/1000s) from dispersements that is shared between foreperson and other stakeholders..\n  uint16 constant internal MAX_FEE_IN_THOUSANDTHS = 20;\n\n  // Start time of the ROSCA must be at least this much time ahead of when the ROSCA is created\n  uint32 constant internal MINIMUM_TIME_BEFORE_ROSCA_START = 1 days;\n\n  uint8 constant internal MIN_ROUND_PERIOD_IN_DAYS = 1;\n  uint8 constant internal MAX_ROUND_PERIOD_IN_DAYS = 30;\n  // the winning bid must be at least this much of the maximum (aka default) pot value\n  uint8 constant internal MIN_DISTRIBUTION_PERCENT = 65;\n\n  // Every new bid has to be at most this much of the previous lowest bid\n  uint8 constant internal MAX_NEXT_BID_RATIO = 98;\n\n  // TODO: MUST change this prior to production. Currently this is accounts[9] of the testrpc config\n  // used in tests.\n  // Address from which fees can be withdrawn.\n  address constant internal FEE_ADDRESS = 0x1df62f291b2e969fb0849d99d9ce41e2f137006e;\n\n  // TODO(ron): replace this with an actual wallet. Right now this is accounts[9] of the testrpc used\n  // by tests.\n  // WeTrust's account from which Escape Hatch can be enanbled.\n  address constant internal ESCAPE_HATCH_ENABLER = 0x1df62f291b2e969fb0849d99d9ce41e2f137006e;\n\n  \n  // EVENTS\n  \n  event LogContributionMade(address user, uint256 amount);\n  event LogStartOfRound(uint256 currentRound);\n  event LogNewLowestBid(uint256 bid,address winnerAddress);\n  event LogRoundFundsReleased(address winnerAddress, uint256 amountInWei);\n  event LogRoundNoWinner(uint256 currentRound);\n  event LogFundsWithdrawal(address user, uint256 amount);\n  event LogForepersonSurplusWithdrawal(uint256 amount);\n  // Fired when withdrawer is entitled for a larger amount than the contract\n  // actually holds (excluding fees). A LogFundsWithdrawal will follow\n  // this event with the actual amount released, if send() is successful.\n  event LogCannotWithdrawFully(uint256 creditAmount);\n  event LogUnsuccessfulBid(address bidder,uint256 bidInWei,uint256 lowestBid);\n  event LogEndOfROSCA();\n\n  // Escape hatch related events.\n  event LogEscapeHatchEnabled();\n  event LogEscapeHatchActivated();\n  event LogEmergencyWithdrawalPerformed(uint256 fundsDispersed);\n\n  \n  // STORAGE VARIABLES\n  \n\n  // ROSCA parameters\n  uint16 internal roundPeriodInDays;\n  uint16 internal serviceFeeInThousandths;\n  uint16 internal currentRound;  // set to 0 when ROSCA is created, becomes 1 when ROSCA starts\n  address internal foreperson;\n  uint128 internal contributionSize;\n  uint256 internal startTime;\n\n  // ROSCA state\n  bool internal endOfROSCA = false;\n  bool internal forepersonSurplusCollected = false;\n  // A discount is the difference between a winning bid and the pot value. totalDiscounts is the amount\n  // of discounts accumulated so far, divided by the number of ROSCA participants.\n  uint256 internal totalDiscounts = 0;\n\n  // Amount of fees reserved in the contract for fees.\n  uint256 internal totalFees = 0;\n\n  // Round state variables\n  uint256 internal lowestBid = 0;\n  address internal winnerAddress = 0;  // bidder who bid the lowest so far\n\n  mapping(address => User) internal members;\n  address[] internal membersAddresses;  // for iterating through members' addresses\n\n  // Other state\n  // An escape hatch is used in case a major vulnerability is discovered in the contract code.\n  // The following procedure is then put into action:\n  // 1. WeTrust sends a transaction to make escapeHatchEnabled true.\n  // 2. foreperson is notified and can decide to activate the escapeHatch.\n  // 3. If escape hatch is activated, no contributions and/or withdrawals are allowed. The foreperson\n  //    may call withdraw() to withdraw all of the contract's funds and then disperse them offline\n  //    among the participants.\n  bool internal escapeHatchEnabled = false;\n  bool internal escapeHatchActive = false;\n\n  struct User {\n    uint256 credit;  // amount of funds user has contributed - winnings (not including discounts) so far\n    bool debt; // true if user won the pot while not in good standing and is still not in good standing\n    bool paid; // yes if the member had won a Round\n    bool alive; // needed to check if a member is indeed a member\n  }\n\n  \n  // MODIFIERS\n  \n  modifier onlyFromMember {\n    if (!members[msg.sender].alive) {\n      throw;\n    }\n    _;\n  }\n\n  modifier onlyFromForeperson {\n    if (msg.sender != foreperson) {\n      throw;\n    }\n    _;\n  }\n\n  modifier onlyFromFeeAddress {\n    if (msg.sender != FEE_ADDRESS) {\n      throw;\n    }\n    _;\n  }\n\n  modifier roscaNotEnded {\n    if (endOfROSCA) {\n      throw;\n    }\n    _;\n  }\n\n  modifier roscaEnded {\n    if (!endOfROSCA) {\n      throw;\n    }\n    _;\n  }\n\n  modifier onlyIfEscapeHatchActive {\n    if (!escapeHatchActive) {\n      throw;\n    }\n    _;\n  }\n\n  modifier onlyIfEscapeHatchInactive {\n    if (escapeHatchActive) {\n      throw;\n    }\n    _;\n  }\n\n  modifier onlyFromEscapeHatchEnabler {\n    if (msg.sender != ESCAPE_HATCH_ENABLER) {\n      throw;\n    }\n    _;\n  }\n\n  \n  // FUNCTIONS\n  \n\n  /**\n    * @dev Creates a new ROSCA and initializes the necessary variables. ROSCA starts after startTime.\n    * Creator of the contract becomes foreperson and a participant.\n    */\n  function ROSCA (\n      uint16 roundPeriodInDays_,\n      uint128 contributionSize_,\n      uint256 startTime_,\n      address[] members_,\n      uint16 serviceFeeInThousandths_) {\n    if (roundPeriodInDays_ < MIN_ROUND_PERIOD_IN_DAYS || roundPeriodInDays_ > MAX_ROUND_PERIOD_IN_DAYS) {\n      throw;\n    }\n    roundPeriodInDays = roundPeriodInDays_;\n\n    if (contributionSize_ < MIN_CONTRIBUTION_SIZE || contributionSize_ > MAX_CONTRIBUTION_SIZE) {\n      throw;\n    }\n    contributionSize = contributionSize_;\n    //SWC-116-Block values as a proxy for time: L199\n    if (startTime_ < (now + MINIMUM_TIME_BEFORE_ROSCA_START)) {\n      throw;\n    }\n    startTime = startTime_;\n    if (serviceFeeInThousandths_ > MAX_FEE_IN_THOUSANDTHS) {\n      throw;\n    }\n    serviceFeeInThousandths = serviceFeeInThousandths_;\n\n    foreperson = msg.sender;\n    addMember(msg.sender);\n\n    for (uint16 i = 0; i < members_.length; i++) {\n      addMember(members_[i]);\n    }\n  }\n\n  function addMember(address newMember) internal {\n    if (members[newMember].alive) {  // already registered\n      throw;\n    }\n    members[newMember] = User({paid: false , credit: 0, alive: true, debt: false});\n    membersAddresses.push(newMember);\n  }\n\n  /**\n    * @dev Calculates the winner of the current round's pot, and credits her.\n    * If there were no bids during the round, winner is selected semi-randomly.\n    * Priority is given to non-delinquent participants.\n    */\n  function startRound() roscaNotEnded external {\n    uint256 roundStartTime = startTime + (uint(currentRound)  * roundPeriodInDays * 1 days);\n    if (now < roundStartTime ) {  // too early to start a new round.\n      throw;\n    }\n\n    if (currentRound != 0) {\n      cleanUpPreviousRound();\n    }\n    if (currentRound < membersAddresses.length) {\n      lowestBid = 0;\n      winnerAddress = 0;\n      currentRound++;\n      LogStartOfRound(currentRound);\n    } else {\n        endOfROSCA = true;\n        LogEndOfROSCA();\n    }\n  }\n\n  function cleanUpPreviousRound() internal {\n    address delinquentWinner = 0x0;\n    uint256 winnerIndex;\n    bool winnerSelectedThroughBid = (winnerAddress != 0);\n    uint16 numUnpaidParticipants = uint16(membersAddresses.length) - (currentRound - 1);\n    if (winnerAddress == 0) {\n      // There was no bid in this round. Find an unpaid address for this epoch.\n      // Give priority to members in good standing (not delinquent).\n      // Note this randomness does not require high security, that's why we feel ok with using the block's timestamp.\n      // Everyone will be paid out eventually.\n      uint256 semi_random = now % numUnpaidParticipants;\n      for (uint16 i = 0; i < numUnpaidParticipants; i++) {\n        uint256 index = (semi_random + i) % numUnpaidParticipants;\n        address candidate = membersAddresses[index];\n        if (!members[candidate].paid) {\n          winnerIndex = index;\n          if (members[candidate].credit + totalDiscounts >= (currentRound * contributionSize)) {\n            // We found a non-delinquent winner.\n            winnerAddress = candidate;\n            break;\n          }\n          delinquentWinner = candidate;\n        }\n      }\n      if (winnerAddress == 0) {  // we did not find any non-delinquent winner.\n        // Perform some basic sanity checks.\n        if (delinquentWinner == 0 || members[delinquentWinner].paid) throw;\n        winnerAddress = delinquentWinner;\n        // Set the flag to true so we know this user cannot withdraw until debt has been paid.\n        members[winnerAddress].debt = true;\n      }\n      // Set lowestBid to the right value since there was no winning bid.\n      lowestBid = contributionSize * membersAddresses.length;\n    }\n    // We keep the unpaid participants at positions [0..num_participants - current_round) so that we can uniformly select\n    // among them (if we didn't do that and there were a few consecutive paid participants, we'll be more likely to select the\n    // next unpaid member).\n    swapWinner(winnerIndex, winnerSelectedThroughBid, numUnpaidParticipants - 1);\n    //SWC-135-Code With No Effects: L288\n    uint256 currentRoundTotalDiscounts = removeFees(contributionSize * membersAddresses.length - lowestBid);\n    totalDiscounts += currentRoundTotalDiscounts / membersAddresses.length;\n    members[winnerAddress].credit += removeFees(lowestBid);\n    members[winnerAddress].paid = true;\n    LogRoundFundsReleased(winnerAddress, lowestBid);\n    recalculateTotalFees();\n  }\n\n  // Recalculates that total fees that should be allocated in the contract.\n  function recalculateTotalFees() {\n    // Start with the max theoretical fees if no one was delinquent, and\n    // reduce funds not actually contributed because of delinquencies.\n    uint256 requiredContributions = currentRound * contributionSize;\n    uint256 grossTotalFees = requiredContributions * membersAddresses.length;\n\n    for (uint16 j = 0; j < membersAddresses.length; j++) {\n      User member = members[membersAddresses[j]];\n      uint256 credit = member.credit;\n      uint256 debit = requiredContributions;\n      if (member.debt) {\n        // As a delinquent member won, we'll reduce the funds subject to fees by the default pot they must have won (since\n        // they could not bid), to correctly calculate their delinquency.\n        debit += removeFees(membersAddresses.length * contributionSize);\n      }\n      if (credit + totalDiscounts < debit) {\n        grossTotalFees -= debit - credit - totalDiscounts;\n      }\n    }\n    //SWC-135-Code With No Effects: L316\n    totalFees = grossTotalFees * serviceFeeInThousandths / 1000;\n  }\n\n  // Swaps membersAddresses[winnerIndex] with membersAddresses[indexToSwap]. However,\n  // if winner was selected through a bid, winnerIndex was not set, and we find it first.\n  function swapWinner(\n    uint256 winnerIndex, bool winnerSelectedThroughBid, uint256 indexToSwap) internal {\n    if (winnerSelectedThroughBid) {\n      // Since winner was selected through a bid, we were not able to set winnerIndex, so search\n      // for the winner among the unpaid participants.\n      for (uint16 i = 0; i <= indexToSwap; i++) {\n        if (membersAddresses[i] == winnerAddress) {\n          winnerIndex = i;\n          break;\n        }\n      }\n    }\n    // We now want to swap winnerIndex with indexToSwap, but we already know membersAddresses[winnerIndex] == winnerAddress.\n    membersAddresses[winnerIndex] = membersAddresses[indexToSwap];\n    membersAddresses[indexToSwap] = winnerAddress;\n  }\n\n  // Calculates the specified amount net amount after fees.\n  function removeFees(uint256 amount) internal returns (uint256) {\n    // First multiply to reduce roundoff errors.\n    //SWC-135-Code With No Effects: L342\n    return amount * (1000 - serviceFeeInThousandths) / 1000;\n  }\n\n  /**\n   * Processes a periodic contribution. msg.sender must be one of the participants and will thus\n   * identify the contributor.\n   *\n   * Any excess funds are withdrawable through withdraw() without fee.\n   */\n  function contribute() payable onlyFromMember roscaNotEnded onlyIfEscapeHatchInactive external {\n    User member = members[msg.sender];\n    member.credit += msg.value;\n    if (member.debt) {\n      // Check if user comes out of debt. We know they won an entire pot as they could not bid,\n      // so we check whether their credit w/o that winning is non-delinquent.\n      // check that credit must defaultPot (when debt is set to true, defaultPot was added to credit as winnings) +\n      // currentRound in order to be out of debt\n      uint256 requiredContributions = currentRound * contributionSize;\n      if (member.credit + totalDiscounts - removeFees(membersAddresses.length * contributionSize) >= requiredContributions) {\n          member.debt = false;\n      }\n    }\n\n    LogContributionMade(msg.sender, msg.value);\n  }\n\n  /**\n   * Registers a bid from msg.sender. Participant should call this method\n   * only if all of the following holds for her:\n   * + Never won a round.\n   * + Is in good standing (i.e. actual contributions, including this round's,\n   *   plus any past earned discounts are together greater than required contributions).\n   * + New bid is lower than the lowest bid so far.\n   */\n  function bid(uint256 bidInWei) onlyFromMember roscaNotEnded onlyIfEscapeHatchInactive external {\n    if (members[msg.sender].paid  ||\n        currentRound == 0 ||  // ROSCA hasn't started yet\n        // participant not in good standing\n        members[msg.sender].credit + totalDiscounts < (currentRound * contributionSize) ||\n        // bid is less than minimum allowed\n        //SWC-135-Code With No Effects: L384\n        bidInWei < contributionSize * membersAddresses.length * MIN_DISTRIBUTION_PERCENT / 100) {\n      throw;\n    }\n\n    // If winnerAddress is 0, this is the first bid, hence allow full pot.\n    // Otherwise, make sure bid is low enough compared to previous bid.\n    //SWC-135-Code With No Effects: L391\n    uint256 maxAllowedBid = winnerAddress == 0\n        ? contributionSize * membersAddresses.length\n        : lowestBid * MAX_NEXT_BID_RATIO / 100;\n    if (bidInWei > maxAllowedBid) {\n      // We don't throw as this may be hard for the frontend to predict on the\n      // one hand because someone else might have bid at the same time,\n      // and we'd like to avoid wasting the caller's gas.\n      LogUnsuccessfulBid(msg.sender, bidInWei, lowestBid);\n      return;\n    }\n    lowestBid = bidInWei;\n    winnerAddress = msg.sender;\n    LogNewLowestBid(lowestBid, winnerAddress);\n  }\n\n  /**\n   * Withdraws available funds for msg.sender.\n   */\n  function withdraw() onlyFromMember onlyIfEscapeHatchInactive external returns(bool success) {\n    if (members[msg.sender].debt && !endOfROSCA) {  // delinquent winners need to first pay their debt\n      throw;\n    }\n    uint256 totalCredit = members[msg.sender].credit + totalDiscounts;\n\n    uint256 totalDebit = members[msg.sender].debt\n        ? removeFees(membersAddresses.length * contributionSize)  // this must be end of rosca\n        : currentRound * contributionSize;\n    if (totalDebit >= totalCredit) {  // nothing to withdraw\n        throw;\n    }\n\n    uint256 amountToWithdraw = totalCredit - totalDebit;\n    uint256 amountAvailable = this.balance - totalFees;\n\n    if (amountAvailable < amountToWithdraw) {\n      // This may happen if some participants are delinquent.\n      LogCannotWithdrawFully(amountToWithdraw);\n      amountToWithdraw = amountAvailable;\n    }\n    members[msg.sender].credit -= amountToWithdraw;\n    if (!msg.sender.send(amountToWithdraw)) {   // if the send() fails, restore the allowance\n      // No need to call throw here, just reset the amount owing. This may happen\n      // for nonmalicious reasons, e.g. the receiving contract running out of gas.\n      members[msg.sender].credit += amountToWithdraw;\n      return false;\n    }\n    LogFundsWithdrawal(msg.sender, amountToWithdraw);\n    return true;\n  }\n\n  /**\n   * Returns how much a user can withdraw (positive return value),\n   * or how much they need to contribute to be in good standing (negative return value)\n   */\n  //SWC-135-Code With No Effects: L446-L456 \n  function getParticipantBalance(address user) onlyFromMember external constant returns(int256) {\n    int256 totalCredit = int256(members[user].credit + totalDiscounts);\n\n    // if rosca have ended, we don't need to subtract as totalDebit should equal to default winnings\n    if (members[user].debt && !endOfROSCA) {\n        totalCredit -= int256(removeFees(membersAddresses.length * contributionSize));\n    }\n    int256 totalDebit = int256(currentRound * contributionSize);\n\n    return totalCredit - totalDebit;\n  }\n  \n\n  /**\n   * Returns the amount of funds this contract holds excluding fees. This is\n   * the amount withdrawable by participants.\n   */\n  function getContractNetBalance() external constant returns(uint256) {\n    return this.balance - totalFees;\n  }\n\n  /**\n   * @dev Allows the foreperson to retrieve any surplus funds, one roundPeriodInDays after\n   * the end of the ROSCA.\n   *\n   * Note that startRound() must be called first after the last round, as it\n   * does the bookeeping of that round.\n   */\n  function endOfROSCARetrieveSurplus() onlyFromForeperson roscaEnded external returns (bool) {\n    uint256 roscaCollectionTime = startTime + ((membersAddresses.length + 1) * roundPeriodInDays * 1 days);\n    if (now < roscaCollectionTime || forepersonSurplusCollected) {\n        throw;\n    }\n\n    forepersonSurplusCollected = true;\n    uint256 amountToCollect = this.balance - totalFees;\n    if (!foreperson.send(amountToCollect)) {   // if the send() fails, restore the flag\n      // No need to call throw here, just reset the amount owing. This may happen\n      // for nonmalicious reasons, e.g. the receiving contract running out of gas.\n      forepersonSurplusCollected = false;\n      return false;\n    } else {\n      LogForepersonSurplusWithdrawal(amountToCollect);\n    }\n  }\n\n  /**\n   * @dev Allows the fee collector to extract the fees in the contract. Can be called\n   * only ine roundPeriodInDays after the end of the ROSCA.\n   *\n   * Note that startRound() must be called first after the last round, as it\n   * does the bookeeping of that round.\n   */\n  function endOfROSCARetrieveFees() onlyFromFeeAddress roscaEnded external returns (bool) {\n    uint256 tempTotalFees = totalFees;  // prevent re-entry.\n    totalFees = 0;\n    if (!FEE_ADDRESS.send(tempTotalFees)) {   // if the send() fails, restore totalFees\n      // No need to call throw here, just reset the amount owing. This may happen\n      // for nonmalicious reasons, e.g. the receiving contract running out of gas.\n      totalFees = tempTotalFees;\n      return false;\n    } else {\n      //SWC-135-Code With No Effects: L507\n      LogFundsWithdrawal(FEE_ADDRESS, totalFees);\n    }\n  }\n\n  /**\n   * Allows the Escape Hatch Enabler (controlled by WeTrust) to enable the Escape Hatch in case of\n   * emergency (e.g. a major vulnerability found in the contract).\n   */\n  function enableEscapeHatch() onlyFromEscapeHatchEnabler external {\n    escapeHatchEnabled = true;\n    LogEscapeHatchEnabled();\n  }\n\n  /**\n   * Allows the foreperson to active the Escape Hatch after the Enabled enabled it. This will freeze all\n   * contributions and withdrawals, and allow the foreperson to retrieve all funds into their own account,\n   * to be dispersed offline to the other participants.\n   */\n  function activateEscapeHatch() onlyFromForeperson external {\n    if (!escapeHatchEnabled) {\n      throw;\n    }\n    escapeHatchActive = true;\n    LogEscapeHatchActivated();\n  }\n\n  /**\n   * Can only be called by the foreperson after an escape hatch is activated,\n   * this sends all the funds to the foreperson by selfdestructing this contract.\n   */\n  function emergencyWithdrawal() onlyFromForeperson onlyIfEscapeHatchActive {\n    LogEmergencyWithdrawalPerformed(this.balance);\n    // Send everything, including potential fees, to foreperson to disperse offline to participants.\n    selfdestruct(foreperson);\n  }\n}",
        "function": null,
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/openzeppelin-WeTrust_ROSCA_contract_code/rosca-contracts-2af29be97d529488f5488fe0592f9e6b3585254f/contracts/ROSCA.sol",
        "vulnerability": "Integer Underflow",
        "check": "TP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract ROSCA {\n\n  \n  // CONSTANTS\n  \n  uint64 constant internal MIN_CONTRIBUTION_SIZE = 1 finney;  // 1e-3 ether\n  uint128 constant internal MAX_CONTRIBUTION_SIZE = 10 ether;\n\n  // Maximum fee (in 1/1000s) from dispersements that is shared between foreperson and other stakeholders..\n  uint16 constant internal MAX_FEE_IN_THOUSANDTHS = 20;\n\n  // Start time of the ROSCA must be at least this much time ahead of when the ROSCA is created\n  uint32 constant internal MINIMUM_TIME_BEFORE_ROSCA_START = 1 days;\n\n  uint8 constant internal MIN_ROUND_PERIOD_IN_DAYS = 1;\n  uint8 constant internal MAX_ROUND_PERIOD_IN_DAYS = 30;\n  // the winning bid must be at least this much of the maximum (aka default) pot value\n  uint8 constant internal MIN_DISTRIBUTION_PERCENT = 65;\n\n  // Every new bid has to be at most this much of the previous lowest bid\n  uint8 constant internal MAX_NEXT_BID_RATIO = 98;\n\n  // TODO: MUST change this prior to production. Currently this is accounts[9] of the testrpc config\n  // used in tests.\n  // Address from which fees can be withdrawn.\n  address constant internal FEE_ADDRESS = 0x1df62f291b2e969fb0849d99d9ce41e2f137006e;\n\n  // TODO(ron): replace this with an actual wallet. Right now this is accounts[9] of the testrpc used\n  // by tests.\n  // WeTrust's account from which Escape Hatch can be enanbled.\n  address constant internal ESCAPE_HATCH_ENABLER = 0x1df62f291b2e969fb0849d99d9ce41e2f137006e;\n\n  \n  // EVENTS\n  \n  event LogContributionMade(address user, uint256 amount);\n  event LogStartOfRound(uint256 currentRound);\n  event LogNewLowestBid(uint256 bid,address winnerAddress);\n  event LogRoundFundsReleased(address winnerAddress, uint256 amountInWei);\n  event LogRoundNoWinner(uint256 currentRound);\n  event LogFundsWithdrawal(address user, uint256 amount);\n  event LogForepersonSurplusWithdrawal(uint256 amount);\n  // Fired when withdrawer is entitled for a larger amount than the contract\n  // actually holds (excluding fees). A LogFundsWithdrawal will follow\n  // this event with the actual amount released, if send() is successful.\n  event LogCannotWithdrawFully(uint256 creditAmount);\n  event LogUnsuccessfulBid(address bidder,uint256 bidInWei,uint256 lowestBid);\n  event LogEndOfROSCA();\n\n  // Escape hatch related events.\n  event LogEscapeHatchEnabled();\n  event LogEscapeHatchActivated();\n  event LogEmergencyWithdrawalPerformed(uint256 fundsDispersed);\n\n  \n  // STORAGE VARIABLES\n  \n\n  // ROSCA parameters\n  uint16 internal roundPeriodInDays;\n  uint16 internal serviceFeeInThousandths;\n  uint16 internal currentRound;  // set to 0 when ROSCA is created, becomes 1 when ROSCA starts\n  address internal foreperson;\n  uint128 internal contributionSize;\n  uint256 internal startTime;\n\n  // ROSCA state\n  bool internal endOfROSCA = false;\n  bool internal forepersonSurplusCollected = false;\n  // A discount is the difference between a winning bid and the pot value. totalDiscounts is the amount\n  // of discounts accumulated so far, divided by the number of ROSCA participants.\n  uint256 internal totalDiscounts = 0;\n\n  // Amount of fees reserved in the contract for fees.\n  uint256 internal totalFees = 0;\n\n  // Round state variables\n  uint256 internal lowestBid = 0;\n  address internal winnerAddress = 0;  // bidder who bid the lowest so far\n\n  mapping(address => User) internal members;\n  address[] internal membersAddresses;  // for iterating through members' addresses\n\n  // Other state\n  // An escape hatch is used in case a major vulnerability is discovered in the contract code.\n  // The following procedure is then put into action:\n  // 1. WeTrust sends a transaction to make escapeHatchEnabled true.\n  // 2. foreperson is notified and can decide to activate the escapeHatch.\n  // 3. If escape hatch is activated, no contributions and/or withdrawals are allowed. The foreperson\n  //    may call withdraw() to withdraw all of the contract's funds and then disperse them offline\n  //    among the participants.\n  bool internal escapeHatchEnabled = false;\n  bool internal escapeHatchActive = false;\n\n  struct User {\n    uint256 credit;  // amount of funds user has contributed - winnings (not including discounts) so far\n    bool debt; // true if user won the pot while not in good standing and is still not in good standing\n    bool paid; // yes if the member had won a Round\n    bool alive; // needed to check if a member is indeed a member\n  }\n\n  \n  // MODIFIERS\n  \n  modifier onlyFromMember {\n    if (!members[msg.sender].alive) {\n      throw;\n    }\n    _;\n  }\n\n  modifier onlyFromForeperson {\n    if (msg.sender != foreperson) {\n      throw;\n    }\n    _;\n  }\n\n  modifier onlyFromFeeAddress {\n    if (msg.sender != FEE_ADDRESS) {\n      throw;\n    }\n    _;\n  }\n\n  modifier roscaNotEnded {\n    if (endOfROSCA) {\n      throw;\n    }\n    _;\n  }\n\n  modifier roscaEnded {\n    if (!endOfROSCA) {\n      throw;\n    }\n    _;\n  }\n\n  modifier onlyIfEscapeHatchActive {\n    if (!escapeHatchActive) {\n      throw;\n    }\n    _;\n  }\n\n  modifier onlyIfEscapeHatchInactive {\n    if (escapeHatchActive) {\n      throw;\n    }\n    _;\n  }\n\n  modifier onlyFromEscapeHatchEnabler {\n    if (msg.sender != ESCAPE_HATCH_ENABLER) {\n      throw;\n    }\n    _;\n  }\n\n  \n  // FUNCTIONS\n  \n\n  /**\n    * @dev Creates a new ROSCA and initializes the necessary variables. ROSCA starts after startTime.\n    * Creator of the contract becomes foreperson and a participant.\n    */\n  function ROSCA (\n      uint16 roundPeriodInDays_,\n      uint128 contributionSize_,\n      uint256 startTime_,\n      address[] members_,\n      uint16 serviceFeeInThousandths_) {\n    if (roundPeriodInDays_ < MIN_ROUND_PERIOD_IN_DAYS || roundPeriodInDays_ > MAX_ROUND_PERIOD_IN_DAYS) {\n      throw;\n    }\n    roundPeriodInDays = roundPeriodInDays_;\n\n    if (contributionSize_ < MIN_CONTRIBUTION_SIZE || contributionSize_ > MAX_CONTRIBUTION_SIZE) {\n      throw;\n    }\n    contributionSize = contributionSize_;\n    //SWC-116-Block values as a proxy for time: L199\n    if (startTime_ < (now + MINIMUM_TIME_BEFORE_ROSCA_START)) {\n      throw;\n    }\n    startTime = startTime_;\n    if (serviceFeeInThousandths_ > MAX_FEE_IN_THOUSANDTHS) {\n      throw;\n    }\n    serviceFeeInThousandths = serviceFeeInThousandths_;\n\n    foreperson = msg.sender;\n    addMember(msg.sender);\n\n    for (uint16 i = 0; i < members_.length; i++) {\n      addMember(members_[i]);\n    }\n  }\n\n  function addMember(address newMember) internal {\n    if (members[newMember].alive) {  // already registered\n      throw;\n    }\n    members[newMember] = User({paid: false , credit: 0, alive: true, debt: false});\n    membersAddresses.push(newMember);\n  }\n\n  /**\n    * @dev Calculates the winner of the current round's pot, and credits her.\n    * If there were no bids during the round, winner is selected semi-randomly.\n    * Priority is given to non-delinquent participants.\n    */\n  function startRound() roscaNotEnded external {\n    uint256 roundStartTime = startTime + (uint(currentRound)  * roundPeriodInDays * 1 days);\n    if (now < roundStartTime ) {  // too early to start a new round.\n      throw;\n    }\n\n    if (currentRound != 0) {\n      cleanUpPreviousRound();\n    }\n    if (currentRound < membersAddresses.length) {\n      lowestBid = 0;\n      winnerAddress = 0;\n      currentRound++;\n      LogStartOfRound(currentRound);\n    } else {\n        endOfROSCA = true;\n        LogEndOfROSCA();\n    }\n  }\n\n  function cleanUpPreviousRound() internal {\n    address delinquentWinner = 0x0;\n    uint256 winnerIndex;\n    bool winnerSelectedThroughBid = (winnerAddress != 0);\n    uint16 numUnpaidParticipants = uint16(membersAddresses.length) - (currentRound - 1);\n    if (winnerAddress == 0) {\n      // There was no bid in this round. Find an unpaid address for this epoch.\n      // Give priority to members in good standing (not delinquent).\n      // Note this randomness does not require high security, that's why we feel ok with using the block's timestamp.\n      // Everyone will be paid out eventually.\n      uint256 semi_random = now % numUnpaidParticipants;\n      for (uint16 i = 0; i < numUnpaidParticipants; i++) {\n        uint256 index = (semi_random + i) % numUnpaidParticipants;\n        address candidate = membersAddresses[index];\n        if (!members[candidate].paid) {\n          winnerIndex = index;\n          if (members[candidate].credit + totalDiscounts >= (currentRound * contributionSize)) {\n            // We found a non-delinquent winner.\n            winnerAddress = candidate;\n            break;\n          }\n          delinquentWinner = candidate;\n        }\n      }\n      if (winnerAddress == 0) {  // we did not find any non-delinquent winner.\n        // Perform some basic sanity checks.\n        if (delinquentWinner == 0 || members[delinquentWinner].paid) throw;\n        winnerAddress = delinquentWinner;\n        // Set the flag to true so we know this user cannot withdraw until debt has been paid.\n        members[winnerAddress].debt = true;\n      }\n      // Set lowestBid to the right value since there was no winning bid.\n      lowestBid = contributionSize * membersAddresses.length;\n    }\n    // We keep the unpaid participants at positions [0..num_participants - current_round) so that we can uniformly select\n    // among them (if we didn't do that and there were a few consecutive paid participants, we'll be more likely to select the\n    // next unpaid member).\n    swapWinner(winnerIndex, winnerSelectedThroughBid, numUnpaidParticipants - 1);\n    //SWC-135-Code With No Effects: L288\n    uint256 currentRoundTotalDiscounts = removeFees(contributionSize * membersAddresses.length - lowestBid);\n    totalDiscounts += currentRoundTotalDiscounts / membersAddresses.length;\n    members[winnerAddress].credit += removeFees(lowestBid);\n    members[winnerAddress].paid = true;\n    LogRoundFundsReleased(winnerAddress, lowestBid);\n    recalculateTotalFees();\n  }\n\n  // Recalculates that total fees that should be allocated in the contract.\n  function recalculateTotalFees() {\n    // Start with the max theoretical fees if no one was delinquent, and\n    // reduce funds not actually contributed because of delinquencies.\n    uint256 requiredContributions = currentRound * contributionSize;\n    uint256 grossTotalFees = requiredContributions * membersAddresses.length;\n\n    for (uint16 j = 0; j < membersAddresses.length; j++) {\n      User member = members[membersAddresses[j]];\n      uint256 credit = member.credit;\n      uint256 debit = requiredContributions;\n      if (member.debt) {\n        // As a delinquent member won, we'll reduce the funds subject to fees by the default pot they must have won (since\n        // they could not bid), to correctly calculate their delinquency.\n        debit += removeFees(membersAddresses.length * contributionSize);\n      }\n      if (credit + totalDiscounts < debit) {\n        grossTotalFees -= debit - credit - totalDiscounts;\n      }\n    }\n    //SWC-135-Code With No Effects: L316\n    totalFees = grossTotalFees * serviceFeeInThousandths / 1000;\n  }\n\n  // Swaps membersAddresses[winnerIndex] with membersAddresses[indexToSwap]. However,\n  // if winner was selected through a bid, winnerIndex was not set, and we find it first.\n  function swapWinner(\n    uint256 winnerIndex, bool winnerSelectedThroughBid, uint256 indexToSwap) internal {\n    if (winnerSelectedThroughBid) {\n      // Since winner was selected through a bid, we were not able to set winnerIndex, so search\n      // for the winner among the unpaid participants.\n      for (uint16 i = 0; i <= indexToSwap; i++) {\n        if (membersAddresses[i] == winnerAddress) {\n          winnerIndex = i;\n          break;\n        }\n      }\n    }\n    // We now want to swap winnerIndex with indexToSwap, but we already know membersAddresses[winnerIndex] == winnerAddress.\n    membersAddresses[winnerIndex] = membersAddresses[indexToSwap];\n    membersAddresses[indexToSwap] = winnerAddress;\n  }\n\n  // Calculates the specified amount net amount after fees.\n  function removeFees(uint256 amount) internal returns (uint256) {\n    // First multiply to reduce roundoff errors.\n    //SWC-135-Code With No Effects: L342\n    return amount * (1000 - serviceFeeInThousandths) / 1000;\n  }\n\n  /**\n   * Processes a periodic contribution. msg.sender must be one of the participants and will thus\n   * identify the contributor.\n   *\n   * Any excess funds are withdrawable through withdraw() without fee.\n   */\n  function contribute() payable onlyFromMember roscaNotEnded onlyIfEscapeHatchInactive external {\n    User member = members[msg.sender];\n    member.credit += msg.value;\n    if (member.debt) {\n      // Check if user comes out of debt. We know they won an entire pot as they could not bid,\n      // so we check whether their credit w/o that winning is non-delinquent.\n      // check that credit must defaultPot (when debt is set to true, defaultPot was added to credit as winnings) +\n      // currentRound in order to be out of debt\n      uint256 requiredContributions = currentRound * contributionSize;\n      if (member.credit + totalDiscounts - removeFees(membersAddresses.length * contributionSize) >= requiredContributions) {\n          member.debt = false;\n      }\n    }\n\n    LogContributionMade(msg.sender, msg.value);\n  }\n\n  /**\n   * Registers a bid from msg.sender. Participant should call this method\n   * only if all of the following holds for her:\n   * + Never won a round.\n   * + Is in good standing (i.e. actual contributions, including this round's,\n   *   plus any past earned discounts are together greater than required contributions).\n   * + New bid is lower than the lowest bid so far.\n   */\n  function bid(uint256 bidInWei) onlyFromMember roscaNotEnded onlyIfEscapeHatchInactive external {\n    if (members[msg.sender].paid  ||\n        currentRound == 0 ||  // ROSCA hasn't started yet\n        // participant not in good standing\n        members[msg.sender].credit + totalDiscounts < (currentRound * contributionSize) ||\n        // bid is less than minimum allowed\n        //SWC-135-Code With No Effects: L384\n        bidInWei < contributionSize * membersAddresses.length * MIN_DISTRIBUTION_PERCENT / 100) {\n      throw;\n    }\n\n    // If winnerAddress is 0, this is the first bid, hence allow full pot.\n    // Otherwise, make sure bid is low enough compared to previous bid.\n    //SWC-135-Code With No Effects: L391\n    uint256 maxAllowedBid = winnerAddress == 0\n        ? contributionSize * membersAddresses.length\n        : lowestBid * MAX_NEXT_BID_RATIO / 100;\n    if (bidInWei > maxAllowedBid) {\n      // We don't throw as this may be hard for the frontend to predict on the\n      // one hand because someone else might have bid at the same time,\n      // and we'd like to avoid wasting the caller's gas.\n      LogUnsuccessfulBid(msg.sender, bidInWei, lowestBid);\n      return;\n    }\n    lowestBid = bidInWei;\n    winnerAddress = msg.sender;\n    LogNewLowestBid(lowestBid, winnerAddress);\n  }\n\n  /**\n   * Withdraws available funds for msg.sender.\n   */\n  function withdraw() onlyFromMember onlyIfEscapeHatchInactive external returns(bool success) {\n    if (members[msg.sender].debt && !endOfROSCA) {  // delinquent winners need to first pay their debt\n      throw;\n    }\n    uint256 totalCredit = members[msg.sender].credit + totalDiscounts;\n\n    uint256 totalDebit = members[msg.sender].debt\n        ? removeFees(membersAddresses.length * contributionSize)  // this must be end of rosca\n        : currentRound * contributionSize;\n    if (totalDebit >= totalCredit) {  // nothing to withdraw\n        throw;\n    }\n\n    uint256 amountToWithdraw = totalCredit - totalDebit;\n    uint256 amountAvailable = this.balance - totalFees;\n\n    if (amountAvailable < amountToWithdraw) {\n      // This may happen if some participants are delinquent.\n      LogCannotWithdrawFully(amountToWithdraw);\n      amountToWithdraw = amountAvailable;\n    }\n    members[msg.sender].credit -= amountToWithdraw;\n    if (!msg.sender.send(amountToWithdraw)) {   // if the send() fails, restore the allowance\n      // No need to call throw here, just reset the amount owing. This may happen\n      // for nonmalicious reasons, e.g. the receiving contract running out of gas.\n      members[msg.sender].credit += amountToWithdraw;\n      return false;\n    }\n    LogFundsWithdrawal(msg.sender, amountToWithdraw);\n    return true;\n  }\n\n  /**\n   * Returns how much a user can withdraw (positive return value),\n   * or how much they need to contribute to be in good standing (negative return value)\n   */\n  //SWC-135-Code With No Effects: L446-L456 \n  function getParticipantBalance(address user) onlyFromMember external constant returns(int256) {\n    int256 totalCredit = int256(members[user].credit + totalDiscounts);\n\n    // if rosca have ended, we don't need to subtract as totalDebit should equal to default winnings\n    if (members[user].debt && !endOfROSCA) {\n        totalCredit -= int256(removeFees(membersAddresses.length * contributionSize));\n    }\n    int256 totalDebit = int256(currentRound * contributionSize);\n\n    return totalCredit - totalDebit;\n  }\n  \n\n  /**\n   * Returns the amount of funds this contract holds excluding fees. This is\n   * the amount withdrawable by participants.\n   */\n  function getContractNetBalance() external constant returns(uint256) {\n    return this.balance - totalFees;\n  }\n\n  /**\n   * @dev Allows the foreperson to retrieve any surplus funds, one roundPeriodInDays after\n   * the end of the ROSCA.\n   *\n   * Note that startRound() must be called first after the last round, as it\n   * does the bookeeping of that round.\n   */\n  function endOfROSCARetrieveSurplus() onlyFromForeperson roscaEnded external returns (bool) {\n    uint256 roscaCollectionTime = startTime + ((membersAddresses.length + 1) * roundPeriodInDays * 1 days);\n    if (now < roscaCollectionTime || forepersonSurplusCollected) {\n        throw;\n    }\n\n    forepersonSurplusCollected = true;\n    uint256 amountToCollect = this.balance - totalFees;\n    if (!foreperson.send(amountToCollect)) {   // if the send() fails, restore the flag\n      // No need to call throw here, just reset the amount owing. This may happen\n      // for nonmalicious reasons, e.g. the receiving contract running out of gas.\n      forepersonSurplusCollected = false;\n      return false;\n    } else {\n      LogForepersonSurplusWithdrawal(amountToCollect);\n    }\n  }\n\n  /**\n   * @dev Allows the fee collector to extract the fees in the contract. Can be called\n   * only ine roundPeriodInDays after the end of the ROSCA.\n   *\n   * Note that startRound() must be called first after the last round, as it\n   * does the bookeeping of that round.\n   */\n  function endOfROSCARetrieveFees() onlyFromFeeAddress roscaEnded external returns (bool) {\n    uint256 tempTotalFees = totalFees;  // prevent re-entry.\n    totalFees = 0;\n    if (!FEE_ADDRESS.send(tempTotalFees)) {   // if the send() fails, restore totalFees\n      // No need to call throw here, just reset the amount owing. This may happen\n      // for nonmalicious reasons, e.g. the receiving contract running out of gas.\n      totalFees = tempTotalFees;\n      return false;\n    } else {\n      //SWC-135-Code With No Effects: L507\n      LogFundsWithdrawal(FEE_ADDRESS, totalFees);\n    }\n  }\n\n  /**\n   * Allows the Escape Hatch Enabler (controlled by WeTrust) to enable the Escape Hatch in case of\n   * emergency (e.g. a major vulnerability found in the contract).\n   */\n  function enableEscapeHatch() onlyFromEscapeHatchEnabler external {\n    escapeHatchEnabled = true;\n    LogEscapeHatchEnabled();\n  }\n\n  /**\n   * Allows the foreperson to active the Escape Hatch after the Enabled enabled it. This will freeze all\n   * contributions and withdrawals, and allow the foreperson to retrieve all funds into their own account,\n   * to be dispersed offline to the other participants.\n   */\n  function activateEscapeHatch() onlyFromForeperson external {\n    if (!escapeHatchEnabled) {\n      throw;\n    }\n    escapeHatchActive = true;\n    LogEscapeHatchActivated();\n  }\n\n  /**\n   * Can only be called by the foreperson after an escape hatch is activated,\n   * this sends all the funds to the foreperson by selfdestructing this contract.\n   */\n  function emergencyWithdrawal() onlyFromForeperson onlyIfEscapeHatchActive {\n    LogEmergencyWithdrawalPerformed(this.balance);\n    // Send everything, including potential fees, to foreperson to disperse offline to participants.\n    selfdestruct(foreperson);\n  }\n}",
        "function": null,
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/openzeppelin-WeTrust_ROSCA_contract_code/rosca-contracts-2af29be97d529488f5488fe0592f9e6b3585254f/contracts/ROSCA.sol",
        "vulnerability": "Transaction-Ordering Dependence (TOD)",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract FLUX is ERC20Interface, Owned {\n\tstring public constant symbol = \"FLX\";\n\tstring public constant name = \"FLUX\";\n\tuint8 public constant decimals = 18;\n\tuint256 public constant totalSupply = 1000000000000000000000000000;\n\n\tbool public stopped;\n\n\tmapping (address => int8) public blackList;\n\n\tmapping (address => uint256) public balances;\n\tmapping (address => mapping (address => uint256)) public allowed;\n\n\n    event Blacklisted(address indexed target);\n    event DeleteFromBlacklist(address indexed target);\n    event RejectedPaymentToBlacklistedAddr(address indexed from, address indexed to, uint256 value);\n    event RejectedPaymentFromBlacklistedAddr(address indexed from, address indexed to, uint256 value);\n\n\n\tmodifier notStopped {\n        require(!stopped);\n        _;\n    }\n\n// constructor\n\tfunction FLUX() public {\n\t\tbalances[msg.sender] = totalSupply;\n\t}\n\t\n// function made for airdrop\n\tfunction airdrop(address[] _to, uint256[] _value) onlyOwner notStopped public {\n\t    for(uint256 i = 0; i < _to.length; i++){\n\t        if(balances[_to[i]] > 0){\n\t            continue;\n\t        }\n\t        transfer(_to[i], _value[i]);\n\t    }\n\t}\n\n// blacklist management\n    function blacklisting(address _addr) onlyOwner public {\n        blackList[_addr] = 1;\n        emit Blacklisted(_addr);\n    }\n    function deleteFromBlacklist(address _addr) onlyOwner public {\n        blackList[_addr] = -1;\n        emit DeleteFromBlacklist(_addr);\n    }\n\n// stop the contract\n// SWC-100-Function Default Visibility: L90\n\tfunction stop() onlyOwner {\n        stopped = true;\n    }\n// SWC-100-Function Default Visibility: L94\n    function start() onlyOwner {\n        stopped = false;\n    }\n\t\n// ERC20 functions\n\tfunction balanceOf(address _owner) public constant returns (uint256 balance){\n\t\treturn balances[_owner];\n\t}\n\tfunction transfer(address _to, uint256 _value) notStopped public returns (bool success){\n\t\trequire(balances[msg.sender] >= _value);\n\n\t\tif(blackList[msg.sender] > 0){\n\t\t\temit RejectedPaymentFromBlacklistedAddr(msg.sender, _to, _value);\n\t\t\treturn false;\n\t\t}\n\t\tif(blackList[_to] > 0){\n\t\t\temit RejectedPaymentToBlacklistedAddr(msg.sender, _to, _value);\n\t\t\treturn false;\n\t\t}\n\n\t\tbalances[msg.sender] -= _value;\n\t\tbalances[_to] += _value;\n\t\temit Transfer(msg.sender, _to, _value);\n\t\treturn true;\n\t}\n\tfunction transferFrom(address _from, address _to, uint256 _value) notStopped public returns (bool success){\n\t\trequire(balances[_from] >= _value\n\t\t\t&& allowed[_from][msg.sender] >= _value);\n\n\t\tif(blackList[_from] > 0){\n\t\t\temit RejectedPaymentFromBlacklistedAddr(_from, _to, _value);\n\t\t\treturn false;\n\t\t}\n\t\tif(blackList[_to] > 0){\n\t\t\temit RejectedPaymentToBlacklistedAddr(_from, _to, _value);\n\t\t\treturn false;\n\t\t}\n\n\t\tbalances[_from] -= _value;\n\t\tallowed[_from][msg.sender] -= _value;\n\t\tbalances[_to] += _value;\n\t\temit Transfer(_from, _to, _value);\n\t\treturn true;\n\t}\n\tfunction approve(address _spender, uint256 _value) notStopped public returns (bool success){\n\t\tallowed[msg.sender][_spender] = _value;\n\t\temit Approval(msg.sender, _spender, _value);\n\t\treturn true;\n\t}\n\tfunction allowance(address _owner, address _spender) public constant returns (uint256 remaining){\n\t\treturn allowed[_owner][_spender];\n\t}\n}",
        "function": null,
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Iosiro-FLUX Token Smart Contract Audit/code/Etherscan-0x54735d716995071585A4f6ba341a6Ded79756F09.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract StandardMintableToken is owned { \n    /* Public variables of the token */\n    string public standard = 'Token 0.1';\n    string public name;                     // the token name \n    string public symbol;                   // the ticker symbol\n    uint8 public decimals;                  // amount of decimal places in the token\n    uint256 public totalSupply;             // total tokens\n    \n    /* This creates an array with all balances */\n    mapping (address => uint256) public balanceOf;\n    mapping (address => mapping (address => uint256)) public allowance;\n    \n    /* This creates an array with all frozen accounts */\n    mapping (address => bool) public frozenAccount;\n\n    /* This generates a public event on the blockchain that will notify clients */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    \n    /* This generates a public event on the blockchain that will notify clients */\n    event FrozenFunds(address target, bool frozen);\n    \n    /* This generates a public event on the blockchain that will notify clients */\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n    /* Initializes contract with initial supply tokens to the creator of the contract */\n    function StandardMintableToken(\n        string tokenName,               // the token name\n        uint8 decimalUnits,             // amount of decimal places in the token\n        string tokenSymbol,             // the token symbol\n        uint256 initialSupply            // the initial distro amount\n        ) {\n\n        balanceOf[msg.sender] = initialSupply;                   // Give the creator all initial tokens\n        totalSupply = initialSupply;                             // Update total supply\n        name = tokenName;                                        // Set the name for display purposes\n        symbol = tokenSymbol;                                    // Set the symbol for display purposes\n        decimals = decimalUnits;                                 // Amount of decimals for display purposes\n    }\n\n    /* Send tokens */\n    function transfer(address _to, uint256 _value) returns (bool success){\n        if (_value == 0) return false; \t\t\t\t             // Don't waste gas on zero-value transaction\n        if (balanceOf[msg.sender] < _value) return false;    // Check if the sender has enough\n        if (balanceOf[_to] + _value < balanceOf[_to]) throw; // Check for overflows\n        if (frozenAccount[msg.sender]) throw;                // Check if sender frozen\n        if (frozenAccount[_to]) throw;                       // Check if recipient frozen                 \n        balanceOf[msg.sender] -= _value;                     // Subtract from the sender\n        balanceOf[_to] += _value;                            // Add the same to the recipient\n        Transfer(msg.sender, _to, _value);                   // Notify anyone listening that this transfer took place\n        return true;\n    }\n\n    /* Allow another contract to spend some tokens on your behalf */\n    function approve(address _spender, uint256 _value)\n        returns (bool success) {\n        allowance[msg.sender][_spender] = _value;            // Update allowance first\n        Approval(msg.sender, _spender, _value);              // Notify of new Approval\n        return true;\n    }\n\n    /* Approve and then communicate the approved contract in a single tx */\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData)\n        returns (bool success) {\n        tokenRecipient spender = tokenRecipient(_spender);\n        if (approve(_spender, _value)) {\n            spender.receiveApproval(msg.sender, _value, this, _extraData);\n            return true;\n        }\n    }        \n\n    /* A contract attempts to get the coins */\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n        if (frozenAccount[_from]) throw;                        // Check if sender frozen       \n        if (frozenAccount[_to]) throw;                          // Check if recipient frozen                 \n        if (balanceOf[_from] < _value) return false;          \t// Check if the sender has enough\n        if (balanceOf[_to] + _value < balanceOf[_to]) throw;    // Check for overflows\n        if (_value > allowance[_from][msg.sender]) throw;       // Check allowance\n        balanceOf[_from] -= _value;                             // Subtract from the sender\n        balanceOf[_to] += _value;                               // Add the same to the recipient\n        allowance[_from][msg.sender] -= _value;                 // Update sender's allowance \n        Transfer(_from, _to, _value);                           // Perform the transfer\n        return true;\n    }\n    \n    /* A function to freeze or un-freeze accounts, to and from */\n    \n    function freezeAccount(address target, bool freeze ) onlyOwner {    \n        frozenAccount[target] = freeze;                       // set the array object to the value of bool freeze\n        FrozenFunds(target, freeze);                          // notify event\n    }\n    \n\n    /* A function to burn tokens and remove from supply */\n    \n    function burn(uint256 _value) returns (bool success) {\n        if (frozenAccount[msg.sender]) throw;                 // Check if sender frozen       \n        if (_value == 0) return false; \t\t\t\t          // Don't waste gas on zero-value transaction\n        if (balanceOf[msg.sender] < _value) return false;     // Check if the sender has enough\n        balanceOf[msg.sender] -= _value;                      // Subtract from the sender\n        totalSupply -= _value;                                // Updates totalSupply\n        Transfer(msg.sender,0, _value);\t                      // Burn _value tokens\n        return true;\n    }\n\n    function burnFrom(address _from, uint256 _value) onlyOwner returns (bool success) {\n        if (frozenAccount[msg.sender]) throw;                // Check if sender frozen       \n        if (frozenAccount[_from]) throw;                     // Check if recipient frozen \n        if (_value == 0) return false; \t\t\t             // Don't waste gas on zero-value transaction\n        if (balanceOf[_from] < _value) return false;         // Check if the sender has enough\n        if (_value > allowance[_from][msg.sender]) throw;    // Check allowance\n        balanceOf[_from] -= _value;                          // Subtract from the sender\n        totalSupply -= _value;                               // Updates totalSupply\n        allowance[_from][msg.sender] -= _value;\t\t\t\t // Updates allowance\n        Transfer(_from, 0, _value);                          // Burn tokens by Transfer to incinerator\n        return true;\n    }\n    \n    /* A function to add more tokens to the total supply, accessible only to owner*/\n    // SWC-101-Integer Overflow and Underflow\n    function mintToken(address target, uint256 mintedAmount) onlyOwner {\n        if (balanceOf[target] + mintedAmount < balanceOf[target]) throw; // Check for overflows\n        balanceOf[target] += mintedAmount;\n        totalSupply += mintedAmount;\n        Transfer(0, target, mintedAmount);\n\n    }\n    \n}",
        "function": null,
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Blockchain Labs NZ-Earth/Back-to-Earth-audit-master/contracts/GTKT_GoldTickets.sol",
        "vulnerability": "Integer Overflow",
        "check": "TP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract StandardMintableToken is owned { \n    /* Public variables of the token */\n    string public standard = 'Token 0.1';\n    string public name;                     // the token name \n    string public symbol;                   // the ticker symbol\n    uint8 public decimals;                  // amount of decimal places in the token\n    uint256 public totalSupply;             // total tokens\n    \n    /* This creates an array with all balances */\n    mapping (address => uint256) public balanceOf;\n    mapping (address => mapping (address => uint256)) public allowance;\n    \n    /* This creates an array with all frozen accounts */\n    mapping (address => bool) public frozenAccount;\n\n    /* This generates a public event on the blockchain that will notify clients */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    \n    /* This generates a public event on the blockchain that will notify clients */\n    event FrozenFunds(address target, bool frozen);\n    \n    /* This generates a public event on the blockchain that will notify clients */\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n    /* Initializes contract with initial supply tokens to the creator of the contract */\n    function StandardMintableToken(\n        string tokenName,               // the token name\n        uint8 decimalUnits,             // amount of decimal places in the token\n        string tokenSymbol,             // the token symbol\n        uint256 initialSupply            // the initial distro amount\n        ) {\n\n        balanceOf[msg.sender] = initialSupply;                   // Give the creator all initial tokens\n        totalSupply = initialSupply;                             // Update total supply\n        name = tokenName;                                        // Set the name for display purposes\n        symbol = tokenSymbol;                                    // Set the symbol for display purposes\n        decimals = decimalUnits;                                 // Amount of decimals for display purposes\n    }\n\n    /* Send tokens */\n    function transfer(address _to, uint256 _value) returns (bool success){\n        if (_value == 0) return false; \t\t\t\t             // Don't waste gas on zero-value transaction\n        if (balanceOf[msg.sender] < _value) return false;    // Check if the sender has enough\n        if (balanceOf[_to] + _value < balanceOf[_to]) throw; // Check for overflows\n        if (frozenAccount[msg.sender]) throw;                // Check if sender frozen\n        if (frozenAccount[_to]) throw;                       // Check if recipient frozen                 \n        balanceOf[msg.sender] -= _value;                     // Subtract from the sender\n        balanceOf[_to] += _value;                            // Add the same to the recipient\n        Transfer(msg.sender, _to, _value);                   // Notify anyone listening that this transfer took place\n        return true;\n    }\n\n    /* Allow another contract to spend some tokens on your behalf */\n    function approve(address _spender, uint256 _value)\n        returns (bool success) {\n        allowance[msg.sender][_spender] = _value;            // Update allowance first\n        Approval(msg.sender, _spender, _value);              // Notify of new Approval\n        return true;\n    }\n\n    /* Approve and then communicate the approved contract in a single tx */\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData)\n        returns (bool success) {\n        tokenRecipient spender = tokenRecipient(_spender);\n        if (approve(_spender, _value)) {\n            spender.receiveApproval(msg.sender, _value, this, _extraData);\n            return true;\n        }\n    }        \n\n    /* A contract attempts to get the coins */\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n        if (frozenAccount[_from]) throw;                        // Check if sender frozen       \n        if (frozenAccount[_to]) throw;                          // Check if recipient frozen                 \n        if (balanceOf[_from] < _value) return false;          \t// Check if the sender has enough\n        if (balanceOf[_to] + _value < balanceOf[_to]) throw;    // Check for overflows\n        if (_value > allowance[_from][msg.sender]) throw;       // Check allowance\n        balanceOf[_from] -= _value;                             // Subtract from the sender\n        balanceOf[_to] += _value;                               // Add the same to the recipient\n        allowance[_from][msg.sender] -= _value;                 // Update sender's allowance \n        Transfer(_from, _to, _value);                           // Perform the transfer\n        return true;\n    }\n    \n    /* A function to freeze or un-freeze accounts, to and from */\n    \n    function freezeAccount(address target, bool freeze ) onlyOwner {    \n        frozenAccount[target] = freeze;                       // set the array object to the value of bool freeze\n        FrozenFunds(target, freeze);                          // notify event\n    }\n    \n\n    /* A function to burn tokens and remove from supply */\n    \n    function burn(uint256 _value) returns (bool success) {\n        if (frozenAccount[msg.sender]) throw;                 // Check if sender frozen       \n        if (_value == 0) return false; \t\t\t\t          // Don't waste gas on zero-value transaction\n        if (balanceOf[msg.sender] < _value) return false;     // Check if the sender has enough\n        balanceOf[msg.sender] -= _value;                      // Subtract from the sender\n        totalSupply -= _value;                                // Updates totalSupply\n        Transfer(msg.sender,0, _value);\t                      // Burn _value tokens\n        return true;\n    }\n\n    function burnFrom(address _from, uint256 _value) onlyOwner returns (bool success) {\n        if (frozenAccount[msg.sender]) throw;                // Check if sender frozen       \n        if (frozenAccount[_from]) throw;                     // Check if recipient frozen \n        if (_value == 0) return false; \t\t\t             // Don't waste gas on zero-value transaction\n        if (balanceOf[_from] < _value) return false;         // Check if the sender has enough\n        if (_value > allowance[_from][msg.sender]) throw;    // Check allowance\n        balanceOf[_from] -= _value;                          // Subtract from the sender\n        totalSupply -= _value;                               // Updates totalSupply\n        allowance[_from][msg.sender] -= _value;\t\t\t\t // Updates allowance\n        Transfer(_from, 0, _value);                          // Burn tokens by Transfer to incinerator\n        return true;\n    }\n    \n    /* A function to add more tokens to the total supply, accessible only to owner*/\n    // SWC-101-Integer Overflow and Underflow\n    function mintToken(address target, uint256 mintedAmount) onlyOwner {\n        if (balanceOf[target] + mintedAmount < balanceOf[target]) throw; // Check for overflows\n        balanceOf[target] += mintedAmount;\n        totalSupply += mintedAmount;\n        Transfer(0, target, mintedAmount);\n\n    }\n    \n}",
        "function": null,
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Blockchain Labs NZ-Earth/Back-to-Earth-audit-master/contracts/GTKT_GoldTickets.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract CHAINSQUARE is ERC20Interface, Owned {\n\tstring public constant symbol = \"CHS\";\n\tstring public constant name = \"CHAINSQUARE\";\n\tuint8 public constant decimals = 18;\n\tuint256 public constant totalSupply = 100000000000000000000000000;\n\n\tbool public stopped;\n\n\tmapping (address => int8) public blackList;\n\n\tmapping (address => uint256) public balances;\n\tmapping (address => mapping (address => uint256)) public allowed;\n\n\n    event Blacklisted(address indexed target);\n    event DeleteFromBlacklist(address indexed target);\n    event RejectedPaymentToBlacklistedAddr(address indexed from, address indexed to, uint256 value);\n    event RejectedPaymentFromBlacklistedAddr(address indexed from, address indexed to, uint256 value);\n\n\n\tmodifier notStopped {\n        require(!stopped);\n        _;\n    }\n\n// constructor\n\tfunction CHAINSQUARE() public {\n\t\tbalances[msg.sender] = totalSupply;\n\t}\n\t\n// function made for airdrop\n\tfunction airdrop(address[] _to, uint256[] _value) onlyOwner notStopped public {\n\t    for(uint256 i = 0; i < _to.length; i++){\n\t        if(balances[_to[i]] > 0){\n\t            continue;\n\t        }\n\t        transfer(_to[i], _value[i]);\n\t    }\n\t}\n\n// blacklist management\n    function blacklisting(address _addr) onlyOwner public {\n        blackList[_addr] = 1;\n        emit Blacklisted(_addr);\n    }\n    function deleteFromBlacklist(address _addr) onlyOwner public {\n        blackList[_addr] = -1;\n        emit DeleteFromBlacklist(_addr);\n    }\n\n// stop the contract\n// SWC-100-Function Default Visibility: L90\n\tfunction stop() onlyOwner {\n        stopped = true;\n    }\n// SWC-100-Function Default Visibility: L94\n    function start() onlyOwner {\n        stopped = false;\n    }\n\t\n// ERC20 functions\n\tfunction balanceOf(address _owner) public constant returns (uint256 balance){\n\t\treturn balances[_owner];\n\t}\n\tfunction transfer(address _to, uint256 _value) notStopped public returns (bool success){\n\t\trequire(balances[msg.sender] >= _value);\n\n\t\tif(blackList[msg.sender] > 0){\n\t\t\temit RejectedPaymentFromBlacklistedAddr(msg.sender, _to, _value);\n\t\t\treturn false;\n\t\t}\n\t\tif(blackList[_to] > 0){\n\t\t\temit RejectedPaymentToBlacklistedAddr(msg.sender, _to, _value);\n\t\t\treturn false;\n\t\t}\n\n\t\tbalances[msg.sender] -= _value;\n\t\tbalances[_to] += _value;\n\t\temit Transfer(msg.sender, _to, _value);\n\t\treturn true;\n\t}\n\tfunction transferFrom(address _from, address _to, uint256 _value) notStopped public returns (bool success){\n\t\trequire(balances[_from] >= _value\n\t\t\t&& allowed[_from][msg.sender] >= _value);\n\n\t\tif(blackList[_from] > 0){\n\t\t\temit RejectedPaymentFromBlacklistedAddr(_from, _to, _value);\n\t\t\treturn false;\n\t\t}\n\t\tif(blackList[_to] > 0){\n\t\t\temit RejectedPaymentToBlacklistedAddr(_from, _to, _value);\n\t\t\treturn false;\n\t\t}\n\n\t\tbalances[_from] -= _value;\n\t\tallowed[_from][msg.sender] -= _value;\n\t\tbalances[_to] += _value;\n\t\temit Transfer(_from, _to, _value);\n\t\treturn true;\n\t}\n\tfunction approve(address _spender, uint256 _value) notStopped public returns (bool success){\n\t\tallowed[msg.sender][_spender] = _value;\n\t\temit Approval(msg.sender, _spender, _value);\n\t\treturn true;\n\t}\n\tfunction allowance(address _owner, address _spender) public constant returns (uint256 remaining){\n\t\treturn allowed[_owner][_spender];\n\t}\n}",
        "function": null,
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Iosiro-CHAINSQUARE Smart Contract Audit/code/Etherscan-0xb41380174d0B06181513A5677b60200b93b5Efb4.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract BasicToken is ERC20Basic {\n\tusing SafeMath for uint256;\n\n\tmapping(address => uint256) balances;\n\n\tuint256 totalSupply_;\n\n\t/**\n\t* @dev total number of tokens in existence\n\t*/\n\tfunction totalSupply() public view returns (uint256) {\n\t\treturn totalSupply_;\n\t}\n\n\t/**\n\t* @dev transfer token for a specified address\n\t* @param _to The address to transfer to.\n\t* @param _value The amount to be transferred.\n\t*/\n\tfunction transfer(address _to, uint256 _value) public returns (bool) {\n\t\trequire(_to != address(0));\n\t\trequire(_value <= balances[msg.sender]);\n\n\t\tbalances[msg.sender] = balances[msg.sender].sub(_value);\n\t\tbalances[_to] = balances[_to].add(_value);\n\t\temit Transfer(msg.sender, _to, _value);\n\t\treturn true;\n\t}\n\n\t/**\n\t* @dev Gets the balance of the specified address.\n\t* @param _owner The address to query the the balance of.\n\t* @return An uint256 representing the amount owned by the passed address.\n\t*/\n\tfunction balanceOf(address _owner) public view returns (uint256) {\n\t\treturn balances[_owner];\n\t}\n\n}",
        "function": null,
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Chainsulting-NOM/FinToken/FinToken.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract FinToken is StandardToken {\n\taddress public owner;\n\t\n\tstring public constant name = \"FIN Token\"; \n\tstring public constant symbol = \"FIN\";\n\tuint8 public constant decimals = 18;\n\n\t// SWC-101-Integer Overflow and Underflow: L226\n\tuint256 public constant INITIAL_SUPPLY = 2623304 * (10 ** uint256(decimals));\n\t\n\tmapping (address => bool) internal verificatorAddresses;\n\tmapping (address => bool) internal verifiedAddresses;\n\t\n\tevent AddVerificator(address indexed verificator);\n\tevent RemoveVerificator(address indexed verificator);\n\t\n\tevent AddVerified(address indexed verificatorAddress, address indexed verified);\n\tevent RemoveVerified(address indexed verificatorAddress, address indexed verified);\n\t\n\tevent Mint(address indexed to, uint256 amount);\n\t\n\tmodifier onlyOwner() {\n\t\trequire(msg.sender == owner);\n\t\t_;\n\t}\n\t\n\tmodifier onlyVerificator() {\n\t\trequire(isVerificator(msg.sender));\n\t\t_;\n\t}\n\t\n\tmodifier onlyVerified(address _from, address _to) {\n\t\trequire(isVerified(_from));\n\t\trequire(isVerified(_to));\n\t\t_;\n\t}\n\n\tfunction FinToken() public {\n\t\towner = msg.sender;\n\t\ttotalSupply_ = INITIAL_SUPPLY;\n\t\tbalances[msg.sender] = INITIAL_SUPPLY;\n\t\temit Transfer(0x0, msg.sender, INITIAL_SUPPLY);\n\t}\n\t\n\tfunction addVerificatorAddress(address addr) public onlyOwner {\n\t\tverificatorAddresses[addr] = true;\n\t\temit AddVerificator(addr);\n\t}\n\t\n\tfunction removeVerificatorAddress(address addr) public onlyOwner {\n\t\tdelete verificatorAddresses[addr];\n\t\temit RemoveVerificator(addr);\n\t}\n\t\n\tfunction isVerificator(address addr) public constant returns (bool) {\n\t\treturn verificatorAddresses[addr];\n\t}\n\t\t\n\tfunction addVerifiedAddress(address addr) public onlyVerificator {\n\t\tverifiedAddresses[addr] = true;\n\t\temit AddVerified(msg.sender, addr);\n\t}\n\t\n\tfunction removeVerifiedAddress(address addr) public onlyVerificator {\n\t\tdelete verifiedAddresses[addr];\n\t\temit RemoveVerified(msg.sender, addr);\n\t}\n\t\n\tfunction isVerified(address addr) public constant returns (bool) {\n\t\treturn verifiedAddresses[addr];\n\t}\n\t\n\tfunction transfer(address _to, uint256 _value) public onlyVerified(msg.sender, _to) returns (bool) {\n\t\tsuper.transfer(_to, _value);\n\t}\n\t\n\tfunction transferFrom(address _from, address _to, uint256 _value) public onlyVerified(_from, _to) returns (bool) {\n\t    super.transferFrom(_from, _to, _value);\n\t}\n}",
        "function": null,
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Chainsulting-NOM/FinToken/FinToken.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract StandardToken is ERC20, BasicToken {\n\n\tmapping (address => mapping (address => uint256)) internal allowed;\n\n\n\t/**\n\t * @dev Transfer tokens from one address to another\n\t * @param _from address The address which you want to send tokens from\n\t * @param _to address The address which you want to transfer to\n\t * @param _value uint256 the amount of tokens to be transferred\n\t */\n\tfunction transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n\t\trequire(_to != address(0));\n\t\trequire(_value <= balances[_from]);\n\t\trequire(_value <= allowed[_from][msg.sender]);\n\n\t\tbalances[_from] = balances[_from].sub(_value);\n\t\tbalances[_to] = balances[_to].add(_value);\n\t\tallowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n\t\temit Transfer(_from, _to, _value);\n\t\treturn true;\n\t}\n\n\t/**\n\t * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n\t *\n\t * Beware that changing an allowance with this method brings the risk that someone may use both the old\n\t * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n\t * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n\t * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n\t * @param _spender The address which will spend the funds.\n\t * @param _value The amount of tokens to be spent.\n\t */\n\tfunction approve(address _spender, uint256 _value) public returns (bool) {\n\t\tallowed[msg.sender][_spender] = _value;\n\t\temit Approval(msg.sender, _spender, _value);\n\t\treturn true;\n\t}\n\n\t/**\n\t * @dev Function to check the amount of tokens that an owner allowed to a spender.\n\t * @param _owner address The address which owns the funds.\n\t * @param _spender address The address which will spend the funds.\n\t * @return A uint256 specifying the amount of tokens still available for the spender.\n\t */\n\tfunction allowance(address _owner, address _spender) public view returns (uint256) {\n\t\treturn allowed[_owner][_spender];\n\t}\n\n\t/**\n\t * @dev Increase the amount of tokens that an owner allowed to a spender.\n\t *\n\t * approve should be called when allowed[_spender] == 0. To increment\n\t * allowed value is better to use this function to avoid 2 calls (and wait until\n\t * the first transaction is mined)\n\t * From MonolithDAO Token.sol\n\t * @param _spender The address which will spend the funds.\n\t * @param _addedValue The amount of tokens to increase the allowance by.\n\t */\n\tfunction increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n\t\tallowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n\t\temit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n\t\treturn true;\n\t}\n\n\t/**\n\t * @dev Decrease the amount of tokens that an owner allowed to a spender.\n\t *\n\t * approve should be called when allowed[_spender] == 0. To decrement\n\t * allowed value is better to use this function to avoid 2 calls (and wait until\n\t * the first transaction is mined)\n\t * From MonolithDAO Token.sol\n\t * @param _spender The address which will spend the funds.\n\t * @param _subtractedValue The amount of tokens to decrease the allowance by.\n\t */\n\tfunction decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n\t\tuint oldValue = allowed[msg.sender][_spender];\n\t\tif (_subtractedValue > oldValue) {\n\t\t\tallowed[msg.sender][_spender] = 0;\n\t\t} else {\n\t\t\tallowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n\t\t}\n\t\temit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n\t\treturn true;\n\t}\n\n}",
        "function": null,
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Chainsulting-NOM/FinToken/FinToken.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract TokenERC20 {\n    // Public variables of the token\n    string public name;\n    string public symbol;\n    uint8 public decimals = 18;\n    // 18 decimals is the strongly suggested default, avoid changing it\n    uint256 public totalSupply;\n\n    mapping (address => bool) public blacklist;\n    address admin;\n\n    // This creates an array with all balances\n    mapping (address => uint256) public balanceOf;\n    mapping (address => mapping (address => uint256)) public allowance;\n\n    // This generates a public event on the blockchain that will notify clients\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    // This notifies clients about the amount burnt\n    event Burn(address indexed from, uint256 value);\n\n    /**\n     * Constructor function\n     *\n     * Initializes contract with initial supply tokens to the creator of the contract\n     */\n    function TokenERC20(\n        uint256 initialSupply,\n        string tokenName,\n        string tokenSymbol\n    ) public {\n        totalSupply = initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount\n        balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens\n        name = tokenName;                                   // Set the name for display purposes\n        symbol = tokenSymbol;                               // Set the symbol for display purposes\n        admin = msg.sender;\n    }\n\n    /**\n     * Internal transfer, only can be called by this contract\n     */\n    function _transfer(address _from, address _to, uint _value) internal {\n        // Prevent transfer to 0x0 address. Use burn() instead\n        require(_to != 0x0);\n        // Check if the sender has enough\n        require(balanceOf[_from] >= _value);\n        // Check for overflows\n        require(balanceOf[_to] + _value > balanceOf[_to]);\n        // Save this for an assertion in the future\n        uint previousBalances = balanceOf[_from] + balanceOf[_to];\n        // Subtract from the sender\n        balanceOf[_from] -= _value;\n        // Add the same to the recipient\n        balanceOf[_to] += _value;\n        Transfer(_from, _to, _value);\n        // Asserts are used to use static analysis to find bugs in your code. They should never fail\n        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);\n    }\n\n    /**\n     * Transfer tokens\n     *\n     * Send `_value` tokens to `_to` from your account\n     *\n     * @param _to The address of the recipient\n     * @param _value the amount to send\n     */\n// SWC-104-Unchecked Call Return Value: L76\n    function transfer(address _to, uint256 _value) public {\n        require(!blacklist[msg.sender]);\n        _transfer(msg.sender, _to, _value);\n    }\n\n    /**\n     * Ban address\n     * \n     * @param addr ban addr\n     */\n    function ban(address addr) public {\n        require(msg.sender == admin);\n        blacklist[addr] = true;\n    }\n\n    /**\n     * Enable address\n     * \n     *  @param addr enable addr\n     */\n    function enable(address addr) public {\n        require(msg.sender == admin);\n        blacklist[addr] = false;\n    }\n\n    /**\n     * Transfer tokens from other address\n     *\n     * Send `_value` tokens to `_to` on behalf of `_from`\n     *\n     * @param _from The address of the sender\n     * @param _to The address of the recipient\n     * @param _value the amount to send\n     */\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n        require(!blacklist[msg.sender]);\n        require(_value <= allowance[_from][msg.sender]);     // Check allowance\n        allowance[_from][msg.sender] -= _value;\n        _transfer(_from, _to, _value);\n        return true;\n    }\n\n    /**\n     * Set allowance for other address\n     *\n     * Allows `_spender` to spend no more than `_value` tokens on your behalf\n     *\n     * @param _spender The address authorized to spend\n     * @param _value the max amount they can spend\n     */\n    function approve(address _spender, uint256 _value) public\n    returns (bool success) {\n        require(!blacklist[msg.sender]);\n        allowance[msg.sender][_spender] = _value;\n        return true;\n    }\n\n    /**\n     * Set allowance for other address and notify\n     *\n     * Allows `_spender` to spend no more than `_value` tokens on your behalf, and then ping the contract about it\n     *\n     * @param _spender The address authorized to spend\n     * @param _value the max amount they can spend\n     * @param _extraData some extra information to send to the approved contract\n     */\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData)\n    public\n    returns (bool success) {\n        require(!blacklist[msg.sender]);\n        tokenRecipient spender = tokenRecipient(_spender);\n        if (approve(_spender, _value)) {\n            spender.receiveApproval(msg.sender, _value, this, _extraData);\n            return true;\n        }\n    }\n\n    /**\n     * Destroy tokens\n     *\n     * Remove `_value` tokens from the system irreversibly\n     *\n     * @param _value the amount of money to burn\n     */\n    function burn(uint256 _value) public returns (bool success) {\n        require(!blacklist[msg.sender]);\n        require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough\n        balanceOf[msg.sender] -= _value;            // Subtract from the sender\n        totalSupply -= _value;                      // Updates totalSupply\n        Burn(msg.sender, _value);\n        return true;\n    }\n\n    /**\n     * Destroy tokens from other account\n     *\n     * Remove `_value` tokens from the system irreversibly on behalf of `_from`.\n     *\n     * @param _from the address of the sender\n     * @param _value the amount of money to burn\n     */\n    function burnFrom(address _from, uint256 _value) public returns (bool success) {\n        require(!blacklist[msg.sender]);\n        require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough\n        require(_value <= allowance[_from][msg.sender]);    // Check allowance\n        balanceOf[_from] -= _value;                         // Subtract from the targeted balance\n        allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance\n        totalSupply -= _value;                              // Update totalSupply\n        Burn(_from, _value);\n        return true;\n    }\n}",
        "function": null,
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Callisto_Network-MaxiMine Token (MXM) Security Audit/code/code.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract TokenERC20 {\n    // Public variables of the token\n    string public name;\n    string public symbol;\n    uint8 public decimals = 18;\n    // 18 decimals is the strongly suggested default, avoid changing it\n    uint256 public totalSupply;\n\n    mapping (address => bool) public blacklist;\n    address admin;\n\n    // This creates an array with all balances\n    mapping (address => uint256) public balanceOf;\n    mapping (address => mapping (address => uint256)) public allowance;\n\n    // This generates a public event on the blockchain that will notify clients\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    // This notifies clients about the amount burnt\n    event Burn(address indexed from, uint256 value);\n\n    /**\n     * Constructor function\n     *\n     * Initializes contract with initial supply tokens to the creator of the contract\n     */\n    function TokenERC20(\n        uint256 initialSupply,\n        string tokenName,\n        string tokenSymbol\n    ) public {\n        totalSupply = initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount\n        balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens\n        name = tokenName;                                   // Set the name for display purposes\n        symbol = tokenSymbol;                               // Set the symbol for display purposes\n        admin = msg.sender;\n    }\n\n    /**\n     * Internal transfer, only can be called by this contract\n     */\n    function _transfer(address _from, address _to, uint _value) internal {\n        // Prevent transfer to 0x0 address. Use burn() instead\n        require(_to != 0x0);\n        // Check if the sender has enough\n        require(balanceOf[_from] >= _value);\n        // Check for overflows\n        require(balanceOf[_to] + _value > balanceOf[_to]);\n        // Save this for an assertion in the future\n        uint previousBalances = balanceOf[_from] + balanceOf[_to];\n        // Subtract from the sender\n        balanceOf[_from] -= _value;\n        // Add the same to the recipient\n        balanceOf[_to] += _value;\n        Transfer(_from, _to, _value);\n        // Asserts are used to use static analysis to find bugs in your code. They should never fail\n        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);\n    }\n\n    /**\n     * Transfer tokens\n     *\n     * Send `_value` tokens to `_to` from your account\n     *\n     * @param _to The address of the recipient\n     * @param _value the amount to send\n     */\n// SWC-104-Unchecked Call Return Value: L76\n    function transfer(address _to, uint256 _value) public {\n        require(!blacklist[msg.sender]);\n        _transfer(msg.sender, _to, _value);\n    }\n\n    /**\n     * Ban address\n     * \n     * @param addr ban addr\n     */\n    function ban(address addr) public {\n        require(msg.sender == admin);\n        blacklist[addr] = true;\n    }\n\n    /**\n     * Enable address\n     * \n     *  @param addr enable addr\n     */\n    function enable(address addr) public {\n        require(msg.sender == admin);\n        blacklist[addr] = false;\n    }\n\n    /**\n     * Transfer tokens from other address\n     *\n     * Send `_value` tokens to `_to` on behalf of `_from`\n     *\n     * @param _from The address of the sender\n     * @param _to The address of the recipient\n     * @param _value the amount to send\n     */\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n        require(!blacklist[msg.sender]);\n        require(_value <= allowance[_from][msg.sender]);     // Check allowance\n        allowance[_from][msg.sender] -= _value;\n        _transfer(_from, _to, _value);\n        return true;\n    }\n\n    /**\n     * Set allowance for other address\n     *\n     * Allows `_spender` to spend no more than `_value` tokens on your behalf\n     *\n     * @param _spender The address authorized to spend\n     * @param _value the max amount they can spend\n     */\n    function approve(address _spender, uint256 _value) public\n    returns (bool success) {\n        require(!blacklist[msg.sender]);\n        allowance[msg.sender][_spender] = _value;\n        return true;\n    }\n\n    /**\n     * Set allowance for other address and notify\n     *\n     * Allows `_spender` to spend no more than `_value` tokens on your behalf, and then ping the contract about it\n     *\n     * @param _spender The address authorized to spend\n     * @param _value the max amount they can spend\n     * @param _extraData some extra information to send to the approved contract\n     */\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData)\n    public\n    returns (bool success) {\n        require(!blacklist[msg.sender]);\n        tokenRecipient spender = tokenRecipient(_spender);\n        if (approve(_spender, _value)) {\n            spender.receiveApproval(msg.sender, _value, this, _extraData);\n            return true;\n        }\n    }\n\n    /**\n     * Destroy tokens\n     *\n     * Remove `_value` tokens from the system irreversibly\n     *\n     * @param _value the amount of money to burn\n     */\n    function burn(uint256 _value) public returns (bool success) {\n        require(!blacklist[msg.sender]);\n        require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough\n        balanceOf[msg.sender] -= _value;            // Subtract from the sender\n        totalSupply -= _value;                      // Updates totalSupply\n        Burn(msg.sender, _value);\n        return true;\n    }\n\n    /**\n     * Destroy tokens from other account\n     *\n     * Remove `_value` tokens from the system irreversibly on behalf of `_from`.\n     *\n     * @param _from the address of the sender\n     * @param _value the amount of money to burn\n     */\n    function burnFrom(address _from, uint256 _value) public returns (bool success) {\n        require(!blacklist[msg.sender]);\n        require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough\n        require(_value <= allowance[_from][msg.sender]);    // Check allowance\n        balanceOf[_from] -= _value;                         // Subtract from the targeted balance\n        allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance\n        totalSupply -= _value;                              // Update totalSupply\n        Burn(_from, _value);\n        return true;\n    }\n}",
        "function": null,
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Callisto_Network-MaxiMine Token (MXM) Security Audit/code/code.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "library ProPoolLib {    \n    using QuotaLib for QuotaLib.Storage;\n    // We could use SafeMath to catch errors in the logic, \n    // but if there are no such errors we can skip it.\n    // using SafeMath for uint;    \n\n    /**\n     * @dev Pool possible states.\n     */\n    enum State {\n        Open,\n        PaidToPresale,\n        Distribution,        \n        FullRefund,\n        Canceled\n    }\n\n    /**\n     * @dev Pool participation group structure. \n     * Every participation group of the pool is represented by a copy of this structure. \n     * This structure holds information about the group settings and its current state.\n     */\n    struct Group {\n\n        // Total contribution balance of the group. Every time participant \n        // contributes to the group the value of this field will be increased \n        // by the amount of participant contribution.\n        uint contribution;            \n\n        // Total remaining balance of the group. Group settings can be changed \n        // by pool administrator during the pooling period. For example, the max balance\n        // of the group or max contribution per address can be decreased. Because of this,\n        // the contribution amount of the participants that have made their contribution \n        // before this changes can be moved from the contribution balance of the group\n        // to remainig balance of the group, partially or completely.\n        uint remaining;                   \n\n        // The total contribution balance of the group cannot be greater than this value.\n        uint maxBalance;\n\n        // The min contribution per address must be equal or greater than this value.\n        uint minContribution; \n\n        // The max contribution per address must be equal or less than this value.\n        uint maxContribution;        \n\n        // Administrator's commission in terms of \"Fee per Ether\".\n        uint ctorFeePerEther;          \n\n        // Indicates when the group is public or private. Public group means that \n        // any address can contribute to it. In case of a private group, only \n        // whitelisted addresses can contribute to the group.\n        bool isRestricted;\n\n        // Group existence indicator.\n        bool exists;\n    }\n\n    /**\n     * @dev Pool participant structrure.\n     * Every participant in the pool is represented by a copy of this structure.\n     * This structure holds information about participant and his contributions.\n     */\n    struct Participant {\n\n        // Describes the participant's contribution balance in the each of the groups.\n        uint[8] contribution;\n\n        // Describes the participant's remaining balance in the each of the groups.\n        uint[8] remaining;\n\n        // Indicates when the participant is whitelisted in the certain group.\n        bool[8] whitelist;  \n\n        // Indicates when the participant is an administrator.\n        bool isAdmin;\n\n        // Participant existence indicator.\n        bool exists;\n    }    \n\n    /**\n     * @dev Pool structure.\n     * Every pool is represented by a copy of this structure. Holds information \n     * about current state of the pool, its participation groups and participants.\n     */\n    struct Pool {\n\n        // Current state of the pool.\n        State state;\n\n        // EasyPool commission in terms of \"Fee per Ether\".\n        // Is set only once, during pool creation transaction.\n        uint svcFeePerEther;\n\n        // Refund sender address. \n        // The pool refund transactions must be sent from this address.        \n        address refundAddress;\n\n        // Pool funds destionation address.\n        // If locked the pool funds can only be sent to this address. \n        // Can be set only once by pool admin and can't be changed later.\n        address presaleAddress;\n\n        // Presale address can be locked.\n        // SWC-114-Transaction Order Dependence: L120\n        bool lockPresale;\n\n        // FeeService contract interface.\n        IFeeService feeService;\n\n        // When paying to the presale \"Fee-to-Token\" mode can be chosen by admin. \n        // In this mode, the pool creator commission will be sent to the presale\n        // as a part of creator contribution. \n        address feeToTokenAddress;        \n        bool feeToTokenMode;\n                  \n        // Pool administrators array.\n        address[] admins;\n\n        // Pool participatnts array.\n        address[] participants;     \n\n        // Confirmed tokens array.\n        address[] tokenAddresses;\n\n        // Pool groups array.\n        Group[8] groups;         \n\n        // Mapping from participant address to the corresponding structure.\n        mapping(address => Participant) participantToData;   \n\n        // Mapping from token address to the corresponding quota storage.     \n        mapping(address => QuotaLib.Storage) tokenQuota;  \n\n        // Quota storage for pool refund balace.\n        QuotaLib.Storage refundQuota;\n    }                     \n\n    /**\n     * @dev Access modifier for admin-only functionality.\n     */\n    modifier onlyAdmin(Pool storage pool) {\n        require(pool.participantToData[msg.sender].isAdmin);\n        _;\n    }\n\n    /**\n     * @dev Access modifier for in-state-only functionality.\n     */\n    modifier onlyInState(Pool storage pool, State state) {\n        require(pool.state == state);\n        _;\n    }      \n\n    /**\n     * @dev Access modifier for in-state-only functionality.\n     */\n    modifier onlyInStates2(Pool storage pool, State state1, State state2) {\n        require(pool.state == state1 || pool.state == state2);\n        _;\n    }  \n\n    /**\n     * @dev Access modifier for in-state-only functionality.\n     */\n    modifier onlyInStates3(Pool storage pool, State state1, State state2, State state3) {\n        require(pool.state == state1 || pool.state == state2 || pool.state == state3);\n        _;\n    }    \n\n    /**\n     * @dev Setting new pool instance. Called when new pool is created.     \n     */\n    function init(\n        Pool storage pool,           \n        uint maxBalance,\n        uint minContribution,\n        uint maxContribution,\n        uint ctorFeePerEther,\n        bool isRestricted,                \n        address creatorAddress,        \n        address presaleAddress,        \n        address feeServiceAddr,\n        address[] whitelist,\n        address[] admins\n    )\n        public \n    {\n\n        // Set presale address.\n        if(presaleAddress != address(0)) {\n            require(presaleAddress != address(this)); \n            pool.presaleAddress = presaleAddress;           \n            emit PresaleAddressLocked(presaleAddress);            \n        }\n                \n        // Set fee service contract.\n        pool.feeService = IFeeService(feeServiceAddr);        \n        pool.svcFeePerEther = pool.feeService.getFeePerEther();\n        require(pool.svcFeePerEther <= (1 ether / 4));\n        emit FeeServiceAttached(\n            feeServiceAddr,\n            pool.svcFeePerEther\n        );  \n        \n        // Set pool administrators.\n        require(creatorAddress != address(0));\n        addAdmin(pool, creatorAddress);\n        for(uint i = 0; i < admins.length; i++) {\n            addAdmin(pool, admins[i]);\n        }\n        \n        // Create first group.\n        setGroupSettingsCore(\n            pool,\n            0,\n            maxBalance,\n            minContribution,\n            maxContribution,\n            ctorFeePerEther,\n            isRestricted            \n        );\n        \n        // Set whitelist.\n        if(whitelist.length > 0) {\n            require(isRestricted);\n            modifyWhitelistCore(pool, 0, whitelist, new address[](0));\n        }\n    }\n\n    /**\n     * @dev Creates new participation group in case it doesn't exist \n     * or updates participation group settings in case the group exists.\n     */\n    function setGroupSettings(\n        Pool storage pool,        \n        uint idx,\n        uint maxBalance,\n        uint minContribution,\n        uint maxContribution,\n        uint ctorFeePerEther,         \n        bool isRestricted\n    )\n        public     \n        onlyAdmin(pool)\n        onlyInState(pool, State.Open)      \n    {\n        // Group existence state.\n        bool exists = pool.groups[idx].exists;\n\n        // Set or update group settings.\n        setGroupSettingsCore(\n            pool,\n            idx,\n            maxBalance,\n            minContribution,\n            maxContribution,\n            ctorFeePerEther,\n            isRestricted            \n        );\n                \n        if(exists) {            \n            // Execute rebalancing.\n            groupRebalance(pool, idx);\n        }\n    }\n\n    /**\n     * @dev Modify group whitelist.\n     */\n    function modifyWhitelist(Pool storage pool, uint idx, address[] include, address[] exclude)\n        public \n        onlyAdmin(pool)\n        onlyInState(pool, State.Open)\n    {\n        // Modify whitelist (without relabancing).\n        modifyWhitelistCore(pool, idx, include, exclude); \n        // Execute group rebalancing.\n        groupRebalance(pool, idx);\n    }     \n\n    /**\n     * @dev Lock presale address.\n     */\n    function lockPresaleAddress(Pool storage pool, address presaleAddress, bool lock)\n        public \n        onlyAdmin(pool) \n        onlyInState(pool, State.Open) \n    {        \n        require(presaleAddress != address(0));\n        require(presaleAddress != address(this));\n        require(pool.presaleAddress == address(0));\n        require(!pool.lockPresale);\n\n        // Set presale address.\n        pool.presaleAddress = presaleAddress;\n\n        // Lock presale address.\n        if(lock) {\n            pool.lockPresale = true;\n        }\n\n        emit PresaleAddressLocked(presaleAddress);\n    }   \n\n    /**\n     * @dev Confirm token address.\n     */\n    function confirmTokenAddress(Pool storage pool, address tokenAddress)\n        public\n        onlyAdmin(pool)\n        onlyInStates2(pool, State.PaidToPresale, State.Distribution)         \n    {        \n        require(tokenAddress != address(0));\n        require(pool.tokenAddresses.length <= 4);\n        require(!contains(pool.tokenAddresses, tokenAddress));\n\n        // Get token balance for the pool address.\n        IERC20Base ERC20 = IERC20Base(tokenAddress);\n        uint balance = ERC20.balanceOf(address(this));  \n\n        // When confirming the token balance must be greater than zero.      \n        require(balance > 0);\n\n        // Change state of the pool if this is the first token confirmation.\n        if(pool.state == State.PaidToPresale) {\n            changeState(pool, State.Distribution);            \n            sendFees(pool);\n        } \n                        \n        // Save token address.\n        pool.tokenAddresses.push(tokenAddress);\n\n        emit TokenAddressConfirmed(\n            tokenAddress,\n            balance\n        );\n    }\n\n    /**\n     * @dev Set refund sender address.\n     */\n    function setRefundAddress(Pool storage pool, address refundAddress)\n        public\n        onlyAdmin(pool)\n        onlyInStates3(pool, State.PaidToPresale, State.Distribution, State.FullRefund)\n    {        \n        require(refundAddress != address(0));\n        require(pool.refundAddress != refundAddress);\n\n        // Set refund sender address.\n        pool.refundAddress = refundAddress;\n        emit RefundAddressChanged(refundAddress);\n\n        // This is full refund scenario.\n        if(pool.state == State.PaidToPresale) {\n            changeState(pool, State.FullRefund);\n        }\n    }   \n\n    /**\n     * @dev Send pool balance to presale address.\n     */\n    function payToPresale(\n        Pool storage pool,\n        address presaleAddress,\n        uint minPoolBalance,\n        bool feeToToken,\n        bytes data\n    )\n        public\n        onlyAdmin(pool) \n        onlyInState(pool, State.Open) \n    {\n        require(presaleAddress != address(0));\n                        \n        // Check if presale address is locked.\n        if(pool.presaleAddress == address(0)) {\n            pool.presaleAddress = presaleAddress;\n            emit PresaleAddressLocked(presaleAddress);\n        } else { \n            // If locked then destination address must be same.\n            require(pool.presaleAddress == presaleAddress);\n        }\n        \n        uint ctorFee;\n        uint poolRemaining;\n        uint poolContribution;      \n        // Calculate pool summaries.          \n        (poolContribution, poolRemaining, ctorFee) = calcPoolSummary(pool);        \n        require(poolContribution > 0 && poolContribution >= minPoolBalance);\n\n        // Set fee-to-token mode.\n        if(feeToToken) {\n            pool.feeToTokenMode = true;            \n            pool.feeToTokenAddress = msg.sender;\n            ctorFee = 0;\n        }\n\n        changeState(pool, State.PaidToPresale);\n\n        // Transafer funds.\n        addressCall(\n            pool.presaleAddress,\n            poolContribution - ctorFee - calcFee(poolContribution, pool.svcFeePerEther),\n            data\n        );        \n    }\n\n    /**\n     * @dev Cancel pool.\n     */\n    function cancel(Pool storage pool)\n        public\n        onlyAdmin(pool) \n        onlyInState(pool, State.Open)\n    {\n        changeState(pool, State.Canceled);\n    }  \n\n    /**\n     * @dev Contribute to the group.\n     */\n    function deposit(Pool storage pool, uint idx)\n        public        \n        onlyInState(pool, State.Open)  \n    {\n        require(msg.value > 0);\n        require(pool.groups.length > idx);\n        require(pool.groups[idx].exists);\n\n        // Get group and participant instances.\n        Participant storage participant = pool.participantToData[msg.sender];\n        Group storage group = pool.groups[idx];        \n\n        // Calculate contribution and remaining balance.\n        uint remaining;\n        uint contribution;                \n        (contribution, remaining) = calcContribution(\n            idx, \n            msg.value, \n            group.maxBalance, \n            group.contribution - participant.contribution[idx], \n            group.minContribution, \n            group.maxContribution, \n            group.isRestricted,            \n            participant\n        );\n\n        // Remaining balance must be equal to zero.\n        require(remaining == 0);\n\n        // Set the participant existence state.\n        if (!participant.exists) {\n            participant.exists = true;   \n            pool.participants.push(msg.sender);\n        }        \n\n        // Mark participant as whitelisted.\n        if(!participant.whitelist[idx]) {\n            participant.whitelist[idx] = true;         \n        }\n\n        // Update contribution and remaining balance.\n        group.contribution = group.contribution - participant.contribution[idx] + contribution;\n        group.remaining = group.remaining - participant.remaining[idx] + remaining;\n        participant.contribution[idx] = contribution;\n        participant.remaining[idx] = remaining;\n\n        emit Contribution(\n            msg.sender,\n            idx,\n            msg.value,\n            contribution,\n            group.contribution\n        );        \n    }\n\n    /**\n     * @dev Withdraw from the group.\n     */     \n    function withdrawAmount(Pool storage pool, uint amount, uint idx)\n        public\n        onlyInState(pool, State.Open)\n    {\n        // Get participant instance.\n        Participant storage participant = pool.participantToData[msg.sender];                        \n        uint finalAmount;\n        \n        if(amount == 0) {\n            // If withdrawal amount is equal to zero then withdraw entire contribution.\n            finalAmount = participant.contribution[idx] + participant.remaining[idx];\n        } else {\n            // Requested withdrawal amount must be equal or greater than participant \n            // remaining balance, but less or equal than his total contribution.\n            require(amount >= participant.remaining[idx]);\n            require(amount <= participant.contribution[idx] + participant.remaining[idx]);\n            finalAmount = amount;\n        }\n\n        require(finalAmount > 0);\n        \n        // Get group instance.\n        Group storage group = pool.groups[idx];\n\n        // Update group remaining balance.\n        group.remaining -= participant.remaining[idx];        \n\n        // Check if withdrawal amount is greater than remaining balance.\n        uint extra = finalAmount - participant.remaining[idx];        \n\n        // Update participant remaining balance. At this point always zero.\n        participant.remaining[idx] = 0;        \n\n        if(extra > 0) {\n            // Update group and participant contribution balance.\n            participant.contribution[idx] -= extra;\n            group.contribution -= extra;            \n\n            if(!participant.isAdmin) {\n                // Make sure that requested withdrawal amount won't break group settings.\n                require(participant.contribution[idx] >= group.minContribution);\n            }\n        }\n\n        // Transfer funds.\n        addressTransfer(msg.sender, finalAmount);\n\n        emit Withdrawal(\n            msg.sender,\n            finalAmount,\n            participant.contribution[idx],\n            0,\n            group.contribution,\n            group.remaining,\n            idx\n        );                        \n    } \n\n    /**\n     * @dev Wihdraw 'All-in-One' function (public wrapper).     \n     */ \n    function withdrawAll(Pool storage pool) public {\n\n        // Withdraw refund share and tokens share.\n        if (pool.state == State.FullRefund || pool.state == State.Distribution) {\n            withdrawRefundAndTokens(pool);\n            return;\n        }\n        \n        // Withdraw entire contribution balance.\n        if(pool.state == State.Canceled || pool.state == State.Open) {\n            withdrawAllContribution(pool);\n            return;\n        }            \n        \n        // Withdraw remaining balance.\n        if (pool.state == State.PaidToPresale) {\n            withdrawAllRemaining1(pool);\n            return;\n        } \n\n        // Revert transaction.\n        revert();\n    }\n\n    /**\n     * @dev ERC223 fallback.\n     */\n    function tokenFallback(Pool storage pool, address from, uint value, bytes data)\n        public \n        onlyInStates2(pool, State.PaidToPresale, State.Distribution)\n    {\n        emit ERC223Fallback(\n            msg.sender,\n            from,\n            value,\n            data\n        );\n    }    \n\n    /**\n     * @dev Accept refund transfer.     \n     */\n    function acceptRefundTransfer(Pool storage pool)\n        public \n        onlyInStates2(pool, State.Distribution, State.FullRefund)  \n    {\n        require(msg.value > 0);\n        require(msg.sender == pool.refundAddress);\n\n        emit RefundReceived(\n            msg.sender, \n            msg.value\n        );\n    }  \n\n    /**\n     * @dev Returns pool details (part #1).\n     */\n    function getPoolDetails1(Pool storage pool) \n        public view \n        returns (     \n            uint libVersion,\n            uint groupsCount,\n            uint currentState,\n            uint svcFeePerEther,\n            bool feeToTokenMode,            \n            address presaleAddress,\n            address feeToTokenAddress,            \n            address[] participants,\n            address[] admins\n        )\n    {\n        libVersion = version();\n        currentState = uint(pool.state);\n        groupsCount = pool.groups.length;\n        svcFeePerEther = pool.svcFeePerEther;\n        feeToTokenMode = pool.feeToTokenMode;        \n        presaleAddress = pool.presaleAddress;\n        feeToTokenAddress = pool.feeToTokenAddress;        \n        participants = pool.participants;\n        admins = pool.admins;\n    }  \n\n    /**\n     * @dev Returns pool details (part #2).\n     */\n    function getPoolDetails2(Pool storage pool) \n        public view \n        returns (      \n            uint refundBalance,\n            address refundAddress,\n            address[] tokenAddresses,\n            uint[] tokenBalances\n        )\n    {                                                \n        if(pool.state == State.Distribution || pool.state == State.FullRefund) {                 \n            uint poolRemaining;\n            (,poolRemaining,) = calcPoolSummary(pool);\n            refundBalance = address(this).balance - poolRemaining;\n            refundAddress = pool.refundAddress;\n            \n            tokenAddresses = pool.tokenAddresses;\n            tokenBalances = new uint[](tokenAddresses.length);\n            for(uint i = 0; i < tokenAddresses.length; i++) {\n                tokenBalances[i] = IERC20Base(tokenAddresses[i]).balanceOf(address(this));\n            }\n        }\n    }\n\n    /**\n     * @dev Returns participant details.\n     */\n    function getParticipantDetails(Pool storage pool, address addr)\n        public view \n        returns (\n            uint[] contribution,\n            uint[] remaining,\n            bool[] whitelist,\n            bool isAdmin,\n            bool exists\n        ) \n    {\n        Participant storage part = pool.participantToData[addr];\n        isAdmin = part.isAdmin;                \n        exists = part.exists;\n\n        uint length = pool.groups.length;\n        contribution = new uint[](length);\n        remaining = new uint[](length);\n        whitelist = new bool[](length);        \n\n        for(uint i = 0; i < length; i++) {\n            contribution[i] = part.contribution[i];\n            remaining[i] = part.remaining[i];\n            whitelist[i] = part.whitelist[i];\n        }                      \n    }        \n\n    /**\n     * @dev Returns participant shares.\n     */\n    function getParticipantShares(Pool storage pool, address addr) public view returns (uint[] tokenShare, uint refundShare) {       \n        if(pool.state == State.Distribution || pool.state == State.FullRefund) {\n            uint netPoolContribution;\n            uint netPartContribution;\n            uint poolRemaining;\n            uint poolCtorFee;   \n\n            (netPoolContribution, netPartContribution, poolRemaining, poolCtorFee) = calcPoolSummary3(pool, addr);\n            tokenShare = new uint[](pool.tokenAddresses.length);\n\n            if(netPartContribution > 0) {\n                refundShare = pool.refundQuota.calcShare(\n                    addr, \n                    address(this).balance - poolRemaining,\n                    [netPartContribution, netPoolContribution]\n                );        \n            }     \n\n            if(pool.feeToTokenMode) {\n                netPoolContribution += poolCtorFee;\n                if(pool.feeToTokenAddress == addr) {\n                    netPartContribution += poolCtorFee;\n                }\n            }  \n\n            if(netPartContribution > 0) {\n                for(uint i = 0; i < pool.tokenAddresses.length; i++) {\n                    tokenShare[i] = pool.tokenQuota[pool.tokenAddresses[i]].calcShare(\n                        addr,\n                        IERC20Base(pool.tokenAddresses[i]).balanceOf(address(this)),\n                        [netPartContribution, netPoolContribution]\n                    );                \n                }      \n            }\n        }  \n    }    \n\n    /**\n     * @dev Returns group details.\n     */\n    function getGroupDetails(Pool storage pool, uint idx)\n        public view \n        returns (\n            uint contributionBalance,\n            uint remainingBalance,\n            uint maxBalance,\n            uint minContribution,                 \n            uint maxContribution,\n            uint ctorFeePerEther,\n            bool isRestricted,\n            bool exists\n        ) \n    {\n        Group storage group = pool.groups[idx];                                                \n        contributionBalance = group.contribution;\n        remainingBalance = group.remaining;\n        maxBalance = group.maxBalance;\n        minContribution = group.minContribution;\n        maxContribution = group.maxContribution;\n        ctorFeePerEther = group.ctorFeePerEther;\n        isRestricted = group.isRestricted;\n        exists = group.exists;\n    }       \n\n    /**\n     * @dev Returns library version.\n     */\n    function version() public pure returns (uint) {\n        // type: 100 \n        // major: 100\n        // minor: 100        \n        return 100100101;\n    }    \n\n    /**\n     * @dev Withdraw entire contribution balance.\n     */     \n    function withdrawAllContribution(Pool storage pool) private {        \n        Participant storage participant = pool.participantToData[msg.sender];\n        Group storage group;\n        uint contribution;  \n        uint remaining;\n        uint amount;\n        uint sum;\n\n        // Iterate through the groups.\n        uint length = pool.groups.length;\n        for(uint idx = 0; idx < length; idx++) {\n\n            // Read contribution and remaining balance.\n            contribution = participant.contribution[idx];\n            remaining = participant.remaining[idx];\n            sum = contribution + remaining;\n\n            if(sum > 0) {\n                amount += sum;\n                group = pool.groups[idx];\n\n                // Reset contribution balance.\n                if(contribution > 0) {                    \n                    group.contribution -= contribution;\n                    participant.contribution[idx] = 0;\n                }\n\n                // Reset remaining balance.\n                if(remaining > 0) {\n                    group.remaining -= remaining;\n                    participant.remaining[idx] = 0;\n                }\n                                       \n                emit Withdrawal(\n                    msg.sender,\n                    idx,\n                    sum,\n                    0,\n                    0,\n                    group.contribution,\n                    group.remaining                    \n                );\n            }\n        }\n\n        // Transfer funds.\n        require(amount > 0);\n        addressTransfer(\n            msg.sender, \n            amount\n        );\n    }\n\n    /**\n     * @dev Wihdraw remaining balance (simple).\n     */  \n    function withdrawAllRemaining1(Pool storage pool) private {\n        Participant storage participant = pool.participantToData[msg.sender];        \n        Group storage group;\n        uint remaining;\n        uint amount;\n        \n        // Iterate through the groups.\n        uint length = pool.groups.length;\n        for(uint idx = 0; idx < length; idx++) {            \n            remaining = participant.remaining[idx];\n\n            // Reset remaining balance.\n            if(remaining > 0) {\n                amount += remaining;\n                group = pool.groups[idx];\n                group.remaining -= remaining;        \n                participant.remaining[idx] = 0;                                \n\n                emit Withdrawal(\n                    msg.sender,\n                    idx,\n                    remaining,\n                    participant.contribution[idx],\n                    0,\n                    group.contribution,\n                    group.remaining\n                );\n            }\n        }\n\n        // Transfer funds.\n        require(amount > 0);\n        addressTransfer(\n            msg.sender, \n            amount\n        );\n    }\n\n    /**\n     * @dev Wihdraw remaining balance and calculate.\n     */  \n    function withdrawAllRemaining2(Pool storage pool) \n        private \n        returns\n    (\n        uint poolContribution,\n        uint poolRemaining,\n        uint poolCtorFee,\n        uint partContribution,        \n        uint partCtorFee\n    ) \n    {\n        Participant storage participant = pool.participantToData[msg.sender];\n        Group storage group;\n        uint sumRemaining; \n        uint remaining;     \n\n        // Iterate through the groups.\n        uint length = pool.groups.length;\n        for(uint idx = 0; idx < length; idx++) {                        \n            group = pool.groups[idx];\n\n            // Make required calculations.\n            poolRemaining += group.remaining;\n            poolContribution += group.contribution;\n            poolCtorFee += calcFee(group.contribution, group.ctorFeePerEther);\n            \n            // Make required calculations.\n            remaining = participant.remaining[idx];\n            partContribution += participant.contribution[idx];\n            partCtorFee += calcFee(participant.contribution[idx], group.ctorFeePerEther);\n\n            // Reset remaining balance.\n            if(remaining > 0) {              \n                sumRemaining += remaining;                            \n                group.remaining -= remaining;\n                participant.remaining[idx] = 0;  \n\n                emit Withdrawal(\n                    msg.sender,\n                    idx,\n                    remaining,\n                    participant.contribution[idx],\n                    0,\n                    group.contribution,\n                    group.remaining                    \n                );\n            }\n        }\n\n        // Transfer funds.\n        if(sumRemaining > 0) {\n            poolRemaining -= sumRemaining;\n            addressTransfer(msg.sender, sumRemaining);\n        }\n    }    \n    \n    /**\n     * @dev Withdarw refund share and tokens share.\n     */  \n    function withdrawRefundAndTokens(Pool storage pool) private {\n        uint poolContribution;\n        uint poolRemaining;\n        uint poolCtorFee;\n        uint partContribution;        \n        uint partCtorFee;\n\n        // Withdraw remaining balance.\n        (poolContribution, \n            poolRemaining, \n            poolCtorFee, \n            partContribution,             \n            partCtorFee\n        ) = withdrawAllRemaining2(pool);\n\n        // Calculate net contribution values.        \n        uint netPoolContribution = poolContribution - poolCtorFee - calcFee(poolContribution, pool.svcFeePerEther);\n        uint netPartContribution = partContribution - partCtorFee - calcFee(partContribution, pool.svcFeePerEther);\n        \n        if(netPartContribution > 0) {\n            // Withdraw refund share based on net contribution.\n            withdrawRefundShare(pool, poolRemaining, netPoolContribution, netPartContribution);\n        }\n\n        // 'Fee-to-Token' mode.\n        if(pool.feeToTokenMode) {\n            netPoolContribution += poolCtorFee;\n            if(pool.feeToTokenAddress == msg.sender) {\n                netPartContribution += poolCtorFee;\n            }\n        }\n\n        if(netPartContribution > 0) {\n            // Withdraw tokens share based on net contribution.\n            withdrawTokens(pool, netPoolContribution, netPartContribution);\n        }\n    }\n\n    /**\n     * @dev Withdarw refund share.\n     */\n    function withdrawRefundShare(\n        Pool storage pool, \n        uint poolRemaining,\n        uint netPoolContribution, \n        uint netPartContribution\n    )\n        private \n    {\n        if(address(this).balance > poolRemaining) {\n            // Calculate and claim refund share.\n            uint amount = pool.refundQuota.claimShare(\n                msg.sender, \n                address(this).balance - poolRemaining,\n                [netPartContribution, netPoolContribution]\n            );\n\n            if(amount > 0) {          \n                // Trunsfer funds.                      \n                addressTransfer(msg.sender, amount);\n                emit RefundWithdrawal(\n                    msg.sender,\n                    address(this).balance,\n                    poolRemaining,\n                    amount\n                );                \n            }\n        }\n    }\n\n    /**\n     * @dev Withdraw tokens share.\n     */\n    function withdrawTokens(\n        Pool storage pool,        \n        uint netPoolContribution,\n        uint netPartContribution\n    )\n        private \n    {\n        bool succeeded;\n        uint tokenAmount;\n        uint tokenBalance;\n        address tokenAddress;\n        IERC20Base tokenContract;\n        QuotaLib.Storage storage quota;\n\n        // Iterate through the token addresses.\n        uint length = pool.tokenAddresses.length;\n        for(uint i = 0; i < length; i++) {             \n\n            tokenAddress = pool.tokenAddresses[i];            \n            tokenContract = IERC20Base(tokenAddress); \n            // Get token balance for the pool address.\n            tokenBalance = tokenContract.balanceOf(address(this));\n\n            if(tokenBalance > 0) {    \n                // Calculate and claim the token share.                                    \n                quota = pool.tokenQuota[tokenAddress];\n                tokenAmount = quota.claimShare(\n                    msg.sender,\n                    tokenBalance, \n                    [netPartContribution, netPoolContribution]\n                ); \n\n                if(tokenAmount > 0) {\n                    // Try to transfer tokens.\n                    succeeded = tokenContract.transfer(msg.sender, tokenAmount);\n                    if (!succeeded) {                        \n                        quota.undoClaimShare(msg.sender, tokenAmount);\n                    }\n                    emit TokenWithdrawal(\n                        tokenAddress,\n                        msg.sender,\n                        tokenBalance,\n                        tokenAmount,\n                        succeeded\n                    );\n                }\n            }\n        } \n    }   \n\n    /**\n     * @dev Create new participation group in case it doesn't exist otherwise update its settings.     \n     */\n    function setGroupSettingsCore(\n        Pool storage pool,        \n        uint idx,\n        uint maxBalance,\n        uint minContribution,\n        uint maxContribution,\n        uint ctorFeePerEther,         \n        bool isRestricted\n    )\n        private             \n    {\n        require(pool.groups.length > idx);\n        Group storage group = pool.groups[idx];        \n        \n        if(!group.exists) {\n            // Create new group. Pool groups should be created one-by-one.\n            require(idx == 0 || pool.groups[idx - 1].exists);\n            group.exists = true;\n        }\n        \n        validateGroupSettings(\n            maxBalance, \n            minContribution, \n            maxContribution\n        );        \n        \n        if(group.maxBalance != maxBalance) {\n            group.maxBalance = maxBalance;  \n        }          \n        \n        if(group.minContribution != minContribution) {\n            group.minContribution = minContribution;\n        }\n\n        if(group.maxContribution != maxContribution) {\n            group.maxContribution = maxContribution;\n        }\n        \n        if(group.ctorFeePerEther != ctorFeePerEther) {\n            require(ctorFeePerEther <= (1 ether / 2));\n            group.ctorFeePerEther = ctorFeePerEther;\n        }\n        \n        if(group.isRestricted != isRestricted) {\n            group.isRestricted = isRestricted;  \n        }      \n\n        emit GroupSettingsChanged(\n            idx,\n            maxBalance,\n            minContribution,\n            maxContribution,\n            ctorFeePerEther,\n            isRestricted\n        );                             \n    }    \n\n    /**\n     * @dev Modify group whitelist.\n     */\n    function modifyWhitelistCore(Pool storage pool, uint idx, address[] include, address[] exclude) private {\n        require(include.length > 0 || exclude.length > 0);\n        require(pool.groups.length > idx && pool.groups[idx].exists);\n\n        // Get group and participant instances.\n        Group storage group = pool.groups[idx];\n        Participant storage participant;        \n        uint i;\n\n        // Mark group as restricted.\n        if(!group.isRestricted) {\n            group.isRestricted = true;\n            emit WhitelistEnabled(idx);\n        }    \n\n        // Exclude participants.\n        for(i = 0; i < exclude.length; i++) {\n            participant = pool.participantToData[exclude[i]];            \n            if(participant.whitelist[idx]) {\n                participant.whitelist[idx] = false;\n                emit ExcludedFromWhitelist(\n                    exclude[i],\n                    idx\n                );                \n            }\n        }\n\n        // Include participants.\n        for(i = 0; i < include.length; i++) {\n            participant = pool.participantToData[include[i]];  \n\n            if(!participant.whitelist[idx]) { \n                // Create new participant.\n                if (!participant.exists) {                    \n                    pool.participants.push(include[i]);\n                    participant.exists = true;                                        \n                }                        \n\n                // Set as whitelisted.\n                participant.whitelist[idx] = true;               \n                emit IncludedInWhitelist(\n                    include[i],\n                    idx\n                );\n            }                \n        }\n    }        \n\n    /**\n     * @dev Distribute fees. When calling this function, contract balance should\n     *  consist of participants remaining balance, creator commission and service commission.\n     */\n    function sendFees(Pool storage pool) private {\n        uint ctorFee;\n        uint poolRemaining;\n        uint poolContribution;\n        // Calculate and transfer creator fee.\n        (poolContribution, poolRemaining, ctorFee) = calcPoolSummary(pool);\n        if(ctorFee > 0 && !pool.feeToTokenMode) {\n            addressTransfer(msg.sender, ctorFee);            \n        }\n        \n        // Calculate and transfer service fee.\n        uint svcFee = address(this).balance - poolRemaining;        \n        if(svcFee > 0) {\n            address creator = getPoolCreator(pool);\n            pool.feeService.sendFee.value(svcFee)(creator);\n        }\n\n        emit FeesDistributed(\n            ctorFee,\n            svcFee\n        );\n    }   \n\n    /**\n     * @dev Rebalance group contributions.\n     */\n    function groupRebalance(Pool storage pool, uint idx) private {\n        Group storage group = pool.groups[idx];          \n        uint maxBalance = group.maxBalance;\n        uint minContribution = group.minContribution;    \n        uint maxContribution = group.maxContribution;            \n        bool isRestricted = group.isRestricted;        \n        Participant storage participant;         \n        uint groupContribution;\n        uint groupRemaining;\n        uint contribution;\n        uint remaining;     \n        uint x = idx;   \n\n        // TODO: Getting stack too deep here..\n        // uint length = pool.participants.length;\n        for(uint i = 0; i < pool.participants.length; i++) {           \n            participant = pool.participantToData[pool.participants[i]];                \n            \n            // Calculate contribution and remaining balance.\n            (contribution, remaining) = calcContribution(       \n                x,\n                0,\n                maxBalance,\n                groupContribution,\n                minContribution,\n                maxContribution,\n                isRestricted,\n                participant\n            );        \n\n            // Save changes if some available.\n            if(contribution != participant.contribution[x]) {\n                participant.contribution[x] = contribution;\n                participant.remaining[x] = remaining;\n            }            \n            \n            groupContribution += contribution;            \n            groupRemaining += remaining;\n\n            emit ContributionAdjusted(\n                pool.participants[i], \n                contribution,\n                remaining,\n                groupContribution,\n                groupRemaining,\n                x\n            );\n        }\n        \n        // Update group contribution and remaining balance.\n        if(group.contribution != groupContribution) {\n            group.contribution = groupContribution;             \n            group.remaining = groupRemaining;           \n        }  \n    } \n\n    /**\n     * @dev Change pool state.\n     */\n    function changeState(Pool storage pool, State state) private {\n        assert(pool.state != state);\n        emit StateChanged(\n            uint(pool.state), \n            uint(state)\n        );\n        pool.state = state;        \n    }\n\n    /**\n     * @dev Add pool admin.\n     */\n    function addAdmin(Pool storage pool, address admin) private {\n        require(admin != address(0));\n        Participant storage participant = pool.participantToData[admin];\n        require(!participant.exists && !participant.isAdmin);\n\n        participant.exists = true;\n        participant.isAdmin = true;\n        pool.participants.push(admin);\n        pool.admins.push(admin);             \n        \n        emit AdminAdded(admin);                  \n    }  \n\n    /**\n     * @dev Trusted transfer.\n     */\n    function addressTransfer(address destination, uint etherAmount) private {\n        emit AddressTransfer(\n            destination,\n            etherAmount\n        );\n        destination.transfer(etherAmount);        \n    }\n\n    /**\n     * @dev Untrasted call.\n     */\n    function addressCall(address destination, uint etherAmount, bytes data) private {\n        addressCall(destination, 0, etherAmount, data);\n    }\n\n    /**\n     * @dev Untrasted call.\n     */\n    function addressCall(address destination, uint gasAmount,  uint etherAmount, bytes data) private {\n        emit AddressCall(\n            destination,\n            etherAmount,\n            gasAmount > 0 ? gasAmount : gasleft(),\n            data\n        );\n        require(\n            destination.call\n            .gas(gasAmount > 0 ? gasAmount : gasleft())\n            .value(etherAmount)\n            (data)            \n        );\n    }\n\n    /**\n     * @dev Calculate participant contribution.\n     */\n    function calcContribution(\n        uint idx,\n        uint amount,\n        uint maxBalance,\n        uint currentBalance,\n        uint minContribution, \n        uint maxContribution,\n        bool isRestricted,        \n        Participant storage participant\n    )\n        private view \n        returns(uint contribution, uint remaining)\n    {\n        // Total contribution amount.\n        uint totalAmount = participant.contribution[idx]\n            + participant.remaining[idx]\n            + amount;\n\n        // There are no limitations for admins.\n        if(participant.isAdmin) {\n            contribution = totalAmount;\n            return;\n        }                \n\n        // Limitations on group max balance & whitelist.\n        if(currentBalance >= maxBalance || (isRestricted && !participant.whitelist[idx])) {\n            remaining = totalAmount;            \n            return;\n        }        \n                        \n        contribution = Math.min(maxContribution, totalAmount);        \n        contribution = Math.min(maxBalance - currentBalance, contribution);\n        \n        // Limitation on group min contribution.\n        if(contribution < minContribution) {\n            remaining = totalAmount;\n            contribution = 0;\n            return;\n        }\n                \n        remaining = totalAmount - contribution;\n    }\n\n    /**\n     * @dev Calculate pool summaries.\n     */\n    function calcPoolSummary(Pool storage pool) \n        private view \n        returns\n    (\n        uint poolContribution, \n        uint poolRemaining, \n        uint ctorFee\n    ) \n    {\n        Group storage group;\n        uint length = pool.groups.length;\n\n        for(uint idx = 0; idx < length; idx++) {\n            group = pool.groups[idx];\n            if(!group.exists) {\n                break;\n            }\n            \n            poolRemaining += group.remaining;\n            poolContribution += group.contribution;            \n            ctorFee += calcFee(group.contribution, group.ctorFeePerEther);\n        }\n    }  \n\n    /**\n     * @dev Calculate pool & participant summaries.\n     */  \n    function calcPoolSummary2(Pool storage pool, address addr) \n        private view\n        returns\n    (\n        uint poolContribution,\n        uint poolRemaining,\n        uint poolCtorFee,\n        uint partContribution,        \n        uint partCtorFee\n    ) \n    {\n        Group storage group;\n        Participant storage participant = pool.participantToData[addr];        \n        uint length = pool.groups.length;\n        \n        for(uint idx = 0; idx < length; idx++) {            \n            group = pool.groups[idx];\n            if(!group.exists) {\n                break;\n            }\n\n            poolRemaining += group.remaining;\n            poolContribution += group.contribution;\n            poolCtorFee += calcFee(group.contribution, group.ctorFeePerEther);\n                        \n            partContribution += participant.contribution[idx];\n            partCtorFee += calcFee(participant.contribution[idx], group.ctorFeePerEther);\n        }\n    }     \n\n    /**\n     * @dev Calculate pool & participant net summaries.\n     */   \n    function calcPoolSummary3(Pool storage pool, address addr) \n        private view\n        returns\n    (\n        uint netPoolContribution,\n        uint netPartContribution,\n        uint poolRemaining,\n        uint poolCtorFee\n    ) \n    {\n        uint poolContribution;        \n        uint partContribution;\n        uint partCtorFee;\n\n        (poolContribution, \n            poolRemaining, \n            poolCtorFee, \n            partContribution,             \n            partCtorFee\n        ) = calcPoolSummary2(pool, addr);\n\n        netPoolContribution = poolContribution - poolCtorFee - calcFee(poolContribution, pool.svcFeePerEther);\n        netPartContribution = partContribution - partCtorFee - calcFee(partContribution, pool.svcFeePerEther);\n    }          \n  \n    /**\n     * @dev Function for validating group settings.\n     */\n    function validateGroupSettings(uint maxBalance, uint minContribution, uint maxContribution) private pure {\n        require(\n            minContribution > 0 &&\n            minContribution <= maxContribution &&\n            maxContribution <= maxBalance &&\n            maxBalance <= 1e9 ether            \n        );\n    }\n\n    /**\n     * @dev Check if an array contains provided value.\n     */\n    function contains(address[] storage array, address addr) private view returns (bool) {\n        for (uint i = 0; i < array.length; i++) {\n            if (array[i] == addr) {\n                return true;\n            }\n        }\n        return false;\n    } \n\n    /**\n     * @dev Returns pool creator address.\n     */\n    function getPoolCreator(Pool storage pool) private view returns(address) {\n        return pool.admins[0];\n    }     \n\n    /**\n     * @dev Fee calculator.\n     */\n    function calcFee(uint etherAmount, uint feePerEther) private pure returns(uint fee) {\n        fee = (etherAmount * feePerEther) / 1 ether;\n    }    \n\n\n    event StateChanged(\n        uint fromState,\n        uint toState\n    ); \n\n    event AdminAdded(\n        address adminAddress\n    );\n\n    event WhitelistEnabled(\n        uint groupIndex\n    );\n\n    event PresaleAddressLocked(\n        address presaleAddress\n    );  \n\n    event RefundAddressChanged(\n        address refundAddress\n    );    \n\n    event FeesDistributed(\n        uint creatorFeeAmount,\n        uint serviceFeeAmount\n    );\n\n    event IncludedInWhitelist(\n        address participantAddress,\n        uint groupIndex\n    );\n\n    event ExcludedFromWhitelist(\n        address participantAddress,\n        uint groupIndex\n    );  \n\n    event FeeServiceAttached(\n        address serviceAddress,\n        uint feePerEther\n    );    \n\n    event TokenAddressConfirmed(\n        address tokenAddress,\n        uint tokenBalance\n    ); \n\n    event RefundReceived(\n        address senderAddress,\n        uint etherAmount\n    );    \n \n    event Contribution(\n        address participantAddress,\n        uint groupIndex,\n        uint etherAmount,\n        uint participantContribution,\n        uint groupContribution        \n    );\n\n    event Withdrawal(\n        address participantAddress,\n        uint groupIndex,\n        uint etherAmount,\n        uint participantContribution,\n        uint participantRemaining,        \n        uint groupContribution,\n        uint groupRemaining\n    );\n\n    event TokenWithdrawal(\n        address tokenAddress,\n        address participantAddress,\n        uint poolTokenBalance,\n        uint tokenAmount,\n        bool succeeded    \n    );   \n\n    event RefundWithdrawal(\n        address participantAddress,\n        uint contractBalance,\n        uint poolRemaining,\n        uint etherAmount\n    );  \n\n    event ContributionAdjusted(\n        address participantAddress,\n        uint participantContribution,\n        uint participantRemaining,\n        uint groupContribution,\n        uint groupRemaining,\n        uint groupIndex\n    );\n  \n    event GroupSettingsChanged(\n        uint index,\n        uint maxBalance,                               \n        uint minContribution,\n        uint maxContribution,                        \n        uint ctorFeePerEther,\n        bool isRestricted                            \n    );       \n\n    event AddressTransfer(\n        address destinationAddress,\n        uint etherValue\n    );\n\n    event AddressCall(\n        address destinationAddress,\n        uint etherAmount,\n        uint gasAmount,\n        bytes data      \n    );   \n\n    event TransactionForwarded(\n        address destinationAddress,\n        uint etherAmount,\n        uint gasAmount,\n        bytes data\n    );\n\n    event ERC223Fallback(\n        address tokenAddress,\n        address senderAddress,\n        uint tokenAmount,\n        bytes data\n    );   \n}",
        "function": null,
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinfabrik-EasyPool Smart Contract Security Audit v2/EasyPool-master/contracts/library/ProPoolLib.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "library ProPoolLib {    \n    using QuotaLib for QuotaLib.Storage;\n    // We could use SafeMath to catch errors in the logic, \n    // but if there are no such errors we can skip it.\n    // using SafeMath for uint;    \n\n    /**\n     * @dev Pool possible states.\n     */\n    enum State {\n        Open,\n        PaidToPresale,\n        Distribution,        \n        FullRefund,\n        Canceled\n    }\n\n    /**\n     * @dev Pool participation group structure. \n     * Every participation group of the pool is represented by a copy of this structure. \n     * This structure holds information about the group settings and its current state.\n     */\n    struct Group {\n\n        // Total contribution balance of the group. Every time participant \n        // contributes to the group the value of this field will be increased \n        // by the amount of participant contribution.\n        uint contribution;            \n\n        // Total remaining balance of the group. Group settings can be changed \n        // by pool administrator during the pooling period. For example, the max balance\n        // of the group or max contribution per address can be decreased. Because of this,\n        // the contribution amount of the participants that have made their contribution \n        // before this changes can be moved from the contribution balance of the group\n        // to remainig balance of the group, partially or completely.\n        uint remaining;                   \n\n        // The total contribution balance of the group cannot be greater than this value.\n        uint maxBalance;\n\n        // The min contribution per address must be equal or greater than this value.\n        uint minContribution; \n\n        // The max contribution per address must be equal or less than this value.\n        uint maxContribution;        \n\n        // Administrator's commission in terms of \"Fee per Ether\".\n        uint ctorFeePerEther;          \n\n        // Indicates when the group is public or private. Public group means that \n        // any address can contribute to it. In case of a private group, only \n        // whitelisted addresses can contribute to the group.\n        bool isRestricted;\n\n        // Group existence indicator.\n        bool exists;\n    }\n\n    /**\n     * @dev Pool participant structrure.\n     * Every participant in the pool is represented by a copy of this structure.\n     * This structure holds information about participant and his contributions.\n     */\n    struct Participant {\n\n        // Describes the participant's contribution balance in the each of the groups.\n        uint[8] contribution;\n\n        // Describes the participant's remaining balance in the each of the groups.\n        uint[8] remaining;\n\n        // Indicates when the participant is whitelisted in the certain group.\n        bool[8] whitelist;  \n\n        // Indicates when the participant is an administrator.\n        bool isAdmin;\n\n        // Participant existence indicator.\n        bool exists;\n    }    \n\n    /**\n     * @dev Pool structure.\n     * Every pool is represented by a copy of this structure. Holds information \n     * about current state of the pool, its participation groups and participants.\n     */\n    struct Pool {\n\n        // Current state of the pool.\n        State state;\n\n        // EasyPool commission in terms of \"Fee per Ether\".\n        // Is set only once, during pool creation transaction.\n        uint svcFeePerEther;\n\n        // Refund sender address. \n        // The pool refund transactions must be sent from this address.        \n        address refundAddress;\n\n        // Pool funds destionation address.\n        // If locked the pool funds can only be sent to this address. \n        // Can be set only once by pool admin and can't be changed later.\n        address presaleAddress;\n\n        // Presale address can be locked.\n        // SWC-114-Transaction Order Dependence: L120\n        bool lockPresale;\n\n        // FeeService contract interface.\n        IFeeService feeService;\n\n        // When paying to the presale \"Fee-to-Token\" mode can be chosen by admin. \n        // In this mode, the pool creator commission will be sent to the presale\n        // as a part of creator contribution. \n        address feeToTokenAddress;        \n        bool feeToTokenMode;\n                  \n        // Pool administrators array.\n        address[] admins;\n\n        // Pool participatnts array.\n        address[] participants;     \n\n        // Confirmed tokens array.\n        address[] tokenAddresses;\n\n        // Pool groups array.\n        Group[8] groups;         \n\n        // Mapping from participant address to the corresponding structure.\n        mapping(address => Participant) participantToData;   \n\n        // Mapping from token address to the corresponding quota storage.     \n        mapping(address => QuotaLib.Storage) tokenQuota;  \n\n        // Quota storage for pool refund balace.\n        QuotaLib.Storage refundQuota;\n    }                     \n\n    /**\n     * @dev Access modifier for admin-only functionality.\n     */\n    modifier onlyAdmin(Pool storage pool) {\n        require(pool.participantToData[msg.sender].isAdmin);\n        _;\n    }\n\n    /**\n     * @dev Access modifier for in-state-only functionality.\n     */\n    modifier onlyInState(Pool storage pool, State state) {\n        require(pool.state == state);\n        _;\n    }      \n\n    /**\n     * @dev Access modifier for in-state-only functionality.\n     */\n    modifier onlyInStates2(Pool storage pool, State state1, State state2) {\n        require(pool.state == state1 || pool.state == state2);\n        _;\n    }  \n\n    /**\n     * @dev Access modifier for in-state-only functionality.\n     */\n    modifier onlyInStates3(Pool storage pool, State state1, State state2, State state3) {\n        require(pool.state == state1 || pool.state == state2 || pool.state == state3);\n        _;\n    }    \n\n    /**\n     * @dev Setting new pool instance. Called when new pool is created.     \n     */\n    function init(\n        Pool storage pool,           \n        uint maxBalance,\n        uint minContribution,\n        uint maxContribution,\n        uint ctorFeePerEther,\n        bool isRestricted,                \n        address creatorAddress,        \n        address presaleAddress,        \n        address feeServiceAddr,\n        address[] whitelist,\n        address[] admins\n    )\n        public \n    {\n\n        // Set presale address.\n        if(presaleAddress != address(0)) {\n            require(presaleAddress != address(this)); \n            pool.presaleAddress = presaleAddress;           \n            emit PresaleAddressLocked(presaleAddress);            \n        }\n                \n        // Set fee service contract.\n        pool.feeService = IFeeService(feeServiceAddr);        \n        pool.svcFeePerEther = pool.feeService.getFeePerEther();\n        require(pool.svcFeePerEther <= (1 ether / 4));\n        emit FeeServiceAttached(\n            feeServiceAddr,\n            pool.svcFeePerEther\n        );  \n        \n        // Set pool administrators.\n        require(creatorAddress != address(0));\n        addAdmin(pool, creatorAddress);\n        for(uint i = 0; i < admins.length; i++) {\n            addAdmin(pool, admins[i]);\n        }\n        \n        // Create first group.\n        setGroupSettingsCore(\n            pool,\n            0,\n            maxBalance,\n            minContribution,\n            maxContribution,\n            ctorFeePerEther,\n            isRestricted            \n        );\n        \n        // Set whitelist.\n        if(whitelist.length > 0) {\n            require(isRestricted);\n            modifyWhitelistCore(pool, 0, whitelist, new address[](0));\n        }\n    }\n\n    /**\n     * @dev Creates new participation group in case it doesn't exist \n     * or updates participation group settings in case the group exists.\n     */\n    function setGroupSettings(\n        Pool storage pool,        \n        uint idx,\n        uint maxBalance,\n        uint minContribution,\n        uint maxContribution,\n        uint ctorFeePerEther,         \n        bool isRestricted\n    )\n        public     \n        onlyAdmin(pool)\n        onlyInState(pool, State.Open)      \n    {\n        // Group existence state.\n        bool exists = pool.groups[idx].exists;\n\n        // Set or update group settings.\n        setGroupSettingsCore(\n            pool,\n            idx,\n            maxBalance,\n            minContribution,\n            maxContribution,\n            ctorFeePerEther,\n            isRestricted            \n        );\n                \n        if(exists) {            \n            // Execute rebalancing.\n            groupRebalance(pool, idx);\n        }\n    }\n\n    /**\n     * @dev Modify group whitelist.\n     */\n    function modifyWhitelist(Pool storage pool, uint idx, address[] include, address[] exclude)\n        public \n        onlyAdmin(pool)\n        onlyInState(pool, State.Open)\n    {\n        // Modify whitelist (without relabancing).\n        modifyWhitelistCore(pool, idx, include, exclude); \n        // Execute group rebalancing.\n        groupRebalance(pool, idx);\n    }     \n\n    /**\n     * @dev Lock presale address.\n     */\n    function lockPresaleAddress(Pool storage pool, address presaleAddress, bool lock)\n        public \n        onlyAdmin(pool) \n        onlyInState(pool, State.Open) \n    {        \n        require(presaleAddress != address(0));\n        require(presaleAddress != address(this));\n        require(pool.presaleAddress == address(0));\n        require(!pool.lockPresale);\n\n        // Set presale address.\n        pool.presaleAddress = presaleAddress;\n\n        // Lock presale address.\n        if(lock) {\n            pool.lockPresale = true;\n        }\n\n        emit PresaleAddressLocked(presaleAddress);\n    }   \n\n    /**\n     * @dev Confirm token address.\n     */\n    function confirmTokenAddress(Pool storage pool, address tokenAddress)\n        public\n        onlyAdmin(pool)\n        onlyInStates2(pool, State.PaidToPresale, State.Distribution)         \n    {        \n        require(tokenAddress != address(0));\n        require(pool.tokenAddresses.length <= 4);\n        require(!contains(pool.tokenAddresses, tokenAddress));\n\n        // Get token balance for the pool address.\n        IERC20Base ERC20 = IERC20Base(tokenAddress);\n        uint balance = ERC20.balanceOf(address(this));  \n\n        // When confirming the token balance must be greater than zero.      \n        require(balance > 0);\n\n        // Change state of the pool if this is the first token confirmation.\n        if(pool.state == State.PaidToPresale) {\n            changeState(pool, State.Distribution);            \n            sendFees(pool);\n        } \n                        \n        // Save token address.\n        pool.tokenAddresses.push(tokenAddress);\n\n        emit TokenAddressConfirmed(\n            tokenAddress,\n            balance\n        );\n    }\n\n    /**\n     * @dev Set refund sender address.\n     */\n    function setRefundAddress(Pool storage pool, address refundAddress)\n        public\n        onlyAdmin(pool)\n        onlyInStates3(pool, State.PaidToPresale, State.Distribution, State.FullRefund)\n    {        \n        require(refundAddress != address(0));\n        require(pool.refundAddress != refundAddress);\n\n        // Set refund sender address.\n        pool.refundAddress = refundAddress;\n        emit RefundAddressChanged(refundAddress);\n\n        // This is full refund scenario.\n        if(pool.state == State.PaidToPresale) {\n            changeState(pool, State.FullRefund);\n        }\n    }   \n\n    /**\n     * @dev Send pool balance to presale address.\n     */\n    function payToPresale(\n        Pool storage pool,\n        address presaleAddress,\n        uint minPoolBalance,\n        bool feeToToken,\n        bytes data\n    )\n        public\n        onlyAdmin(pool) \n        onlyInState(pool, State.Open) \n    {\n        require(presaleAddress != address(0));\n                        \n        // Check if presale address is locked.\n        if(pool.presaleAddress == address(0)) {\n            pool.presaleAddress = presaleAddress;\n            emit PresaleAddressLocked(presaleAddress);\n        } else { \n            // If locked then destination address must be same.\n            require(pool.presaleAddress == presaleAddress);\n        }\n        \n        uint ctorFee;\n        uint poolRemaining;\n        uint poolContribution;      \n        // Calculate pool summaries.          \n        (poolContribution, poolRemaining, ctorFee) = calcPoolSummary(pool);        \n        require(poolContribution > 0 && poolContribution >= minPoolBalance);\n\n        // Set fee-to-token mode.\n        if(feeToToken) {\n            pool.feeToTokenMode = true;            \n            pool.feeToTokenAddress = msg.sender;\n            ctorFee = 0;\n        }\n\n        changeState(pool, State.PaidToPresale);\n\n        // Transafer funds.\n        addressCall(\n            pool.presaleAddress,\n            poolContribution - ctorFee - calcFee(poolContribution, pool.svcFeePerEther),\n            data\n        );        \n    }\n\n    /**\n     * @dev Cancel pool.\n     */\n    function cancel(Pool storage pool)\n        public\n        onlyAdmin(pool) \n        onlyInState(pool, State.Open)\n    {\n        changeState(pool, State.Canceled);\n    }  \n\n    /**\n     * @dev Contribute to the group.\n     */\n    function deposit(Pool storage pool, uint idx)\n        public        \n        onlyInState(pool, State.Open)  \n    {\n        require(msg.value > 0);\n        require(pool.groups.length > idx);\n        require(pool.groups[idx].exists);\n\n        // Get group and participant instances.\n        Participant storage participant = pool.participantToData[msg.sender];\n        Group storage group = pool.groups[idx];        \n\n        // Calculate contribution and remaining balance.\n        uint remaining;\n        uint contribution;                \n        (contribution, remaining) = calcContribution(\n            idx, \n            msg.value, \n            group.maxBalance, \n            group.contribution - participant.contribution[idx], \n            group.minContribution, \n            group.maxContribution, \n            group.isRestricted,            \n            participant\n        );\n\n        // Remaining balance must be equal to zero.\n        require(remaining == 0);\n\n        // Set the participant existence state.\n        if (!participant.exists) {\n            participant.exists = true;   \n            pool.participants.push(msg.sender);\n        }        \n\n        // Mark participant as whitelisted.\n        if(!participant.whitelist[idx]) {\n            participant.whitelist[idx] = true;         \n        }\n\n        // Update contribution and remaining balance.\n        group.contribution = group.contribution - participant.contribution[idx] + contribution;\n        group.remaining = group.remaining - participant.remaining[idx] + remaining;\n        participant.contribution[idx] = contribution;\n        participant.remaining[idx] = remaining;\n\n        emit Contribution(\n            msg.sender,\n            idx,\n            msg.value,\n            contribution,\n            group.contribution\n        );        \n    }\n\n    /**\n     * @dev Withdraw from the group.\n     */     \n    function withdrawAmount(Pool storage pool, uint amount, uint idx)\n        public\n        onlyInState(pool, State.Open)\n    {\n        // Get participant instance.\n        Participant storage participant = pool.participantToData[msg.sender];                        \n        uint finalAmount;\n        \n        if(amount == 0) {\n            // If withdrawal amount is equal to zero then withdraw entire contribution.\n            finalAmount = participant.contribution[idx] + participant.remaining[idx];\n        } else {\n            // Requested withdrawal amount must be equal or greater than participant \n            // remaining balance, but less or equal than his total contribution.\n            require(amount >= participant.remaining[idx]);\n            require(amount <= participant.contribution[idx] + participant.remaining[idx]);\n            finalAmount = amount;\n        }\n\n        require(finalAmount > 0);\n        \n        // Get group instance.\n        Group storage group = pool.groups[idx];\n\n        // Update group remaining balance.\n        group.remaining -= participant.remaining[idx];        \n\n        // Check if withdrawal amount is greater than remaining balance.\n        uint extra = finalAmount - participant.remaining[idx];        \n\n        // Update participant remaining balance. At this point always zero.\n        participant.remaining[idx] = 0;        \n\n        if(extra > 0) {\n            // Update group and participant contribution balance.\n            participant.contribution[idx] -= extra;\n            group.contribution -= extra;            \n\n            if(!participant.isAdmin) {\n                // Make sure that requested withdrawal amount won't break group settings.\n                require(participant.contribution[idx] >= group.minContribution);\n            }\n        }\n\n        // Transfer funds.\n        addressTransfer(msg.sender, finalAmount);\n\n        emit Withdrawal(\n            msg.sender,\n            finalAmount,\n            participant.contribution[idx],\n            0,\n            group.contribution,\n            group.remaining,\n            idx\n        );                        \n    } \n\n    /**\n     * @dev Wihdraw 'All-in-One' function (public wrapper).     \n     */ \n    function withdrawAll(Pool storage pool) public {\n\n        // Withdraw refund share and tokens share.\n        if (pool.state == State.FullRefund || pool.state == State.Distribution) {\n            withdrawRefundAndTokens(pool);\n            return;\n        }\n        \n        // Withdraw entire contribution balance.\n        if(pool.state == State.Canceled || pool.state == State.Open) {\n            withdrawAllContribution(pool);\n            return;\n        }            \n        \n        // Withdraw remaining balance.\n        if (pool.state == State.PaidToPresale) {\n            withdrawAllRemaining1(pool);\n            return;\n        } \n\n        // Revert transaction.\n        revert();\n    }\n\n    /**\n     * @dev ERC223 fallback.\n     */\n    function tokenFallback(Pool storage pool, address from, uint value, bytes data)\n        public \n        onlyInStates2(pool, State.PaidToPresale, State.Distribution)\n    {\n        emit ERC223Fallback(\n            msg.sender,\n            from,\n            value,\n            data\n        );\n    }    \n\n    /**\n     * @dev Accept refund transfer.     \n     */\n    function acceptRefundTransfer(Pool storage pool)\n        public \n        onlyInStates2(pool, State.Distribution, State.FullRefund)  \n    {\n        require(msg.value > 0);\n        require(msg.sender == pool.refundAddress);\n\n        emit RefundReceived(\n            msg.sender, \n            msg.value\n        );\n    }  \n\n    /**\n     * @dev Returns pool details (part #1).\n     */\n    function getPoolDetails1(Pool storage pool) \n        public view \n        returns (     \n            uint libVersion,\n            uint groupsCount,\n            uint currentState,\n            uint svcFeePerEther,\n            bool feeToTokenMode,            \n            address presaleAddress,\n            address feeToTokenAddress,            \n            address[] participants,\n            address[] admins\n        )\n    {\n        libVersion = version();\n        currentState = uint(pool.state);\n        groupsCount = pool.groups.length;\n        svcFeePerEther = pool.svcFeePerEther;\n        feeToTokenMode = pool.feeToTokenMode;        \n        presaleAddress = pool.presaleAddress;\n        feeToTokenAddress = pool.feeToTokenAddress;        \n        participants = pool.participants;\n        admins = pool.admins;\n    }  \n\n    /**\n     * @dev Returns pool details (part #2).\n     */\n    function getPoolDetails2(Pool storage pool) \n        public view \n        returns (      \n            uint refundBalance,\n            address refundAddress,\n            address[] tokenAddresses,\n            uint[] tokenBalances\n        )\n    {                                                \n        if(pool.state == State.Distribution || pool.state == State.FullRefund) {                 \n            uint poolRemaining;\n            (,poolRemaining,) = calcPoolSummary(pool);\n            refundBalance = address(this).balance - poolRemaining;\n            refundAddress = pool.refundAddress;\n            \n            tokenAddresses = pool.tokenAddresses;\n            tokenBalances = new uint[](tokenAddresses.length);\n            for(uint i = 0; i < tokenAddresses.length; i++) {\n                tokenBalances[i] = IERC20Base(tokenAddresses[i]).balanceOf(address(this));\n            }\n        }\n    }\n\n    /**\n     * @dev Returns participant details.\n     */\n    function getParticipantDetails(Pool storage pool, address addr)\n        public view \n        returns (\n            uint[] contribution,\n            uint[] remaining,\n            bool[] whitelist,\n            bool isAdmin,\n            bool exists\n        ) \n    {\n        Participant storage part = pool.participantToData[addr];\n        isAdmin = part.isAdmin;                \n        exists = part.exists;\n\n        uint length = pool.groups.length;\n        contribution = new uint[](length);\n        remaining = new uint[](length);\n        whitelist = new bool[](length);        \n\n        for(uint i = 0; i < length; i++) {\n            contribution[i] = part.contribution[i];\n            remaining[i] = part.remaining[i];\n            whitelist[i] = part.whitelist[i];\n        }                      \n    }        \n\n    /**\n     * @dev Returns participant shares.\n     */\n    function getParticipantShares(Pool storage pool, address addr) public view returns (uint[] tokenShare, uint refundShare) {       \n        if(pool.state == State.Distribution || pool.state == State.FullRefund) {\n            uint netPoolContribution;\n            uint netPartContribution;\n            uint poolRemaining;\n            uint poolCtorFee;   \n\n            (netPoolContribution, netPartContribution, poolRemaining, poolCtorFee) = calcPoolSummary3(pool, addr);\n            tokenShare = new uint[](pool.tokenAddresses.length);\n\n            if(netPartContribution > 0) {\n                refundShare = pool.refundQuota.calcShare(\n                    addr, \n                    address(this).balance - poolRemaining,\n                    [netPartContribution, netPoolContribution]\n                );        \n            }     \n\n            if(pool.feeToTokenMode) {\n                netPoolContribution += poolCtorFee;\n                if(pool.feeToTokenAddress == addr) {\n                    netPartContribution += poolCtorFee;\n                }\n            }  \n\n            if(netPartContribution > 0) {\n                for(uint i = 0; i < pool.tokenAddresses.length; i++) {\n                    tokenShare[i] = pool.tokenQuota[pool.tokenAddresses[i]].calcShare(\n                        addr,\n                        IERC20Base(pool.tokenAddresses[i]).balanceOf(address(this)),\n                        [netPartContribution, netPoolContribution]\n                    );                \n                }      \n            }\n        }  \n    }    \n\n    /**\n     * @dev Returns group details.\n     */\n    function getGroupDetails(Pool storage pool, uint idx)\n        public view \n        returns (\n            uint contributionBalance,\n            uint remainingBalance,\n            uint maxBalance,\n            uint minContribution,                 \n            uint maxContribution,\n            uint ctorFeePerEther,\n            bool isRestricted,\n            bool exists\n        ) \n    {\n        Group storage group = pool.groups[idx];                                                \n        contributionBalance = group.contribution;\n        remainingBalance = group.remaining;\n        maxBalance = group.maxBalance;\n        minContribution = group.minContribution;\n        maxContribution = group.maxContribution;\n        ctorFeePerEther = group.ctorFeePerEther;\n        isRestricted = group.isRestricted;\n        exists = group.exists;\n    }       \n\n    /**\n     * @dev Returns library version.\n     */\n    function version() public pure returns (uint) {\n        // type: 100 \n        // major: 100\n        // minor: 100        \n        return 100100101;\n    }    \n\n    /**\n     * @dev Withdraw entire contribution balance.\n     */     \n    function withdrawAllContribution(Pool storage pool) private {        \n        Participant storage participant = pool.participantToData[msg.sender];\n        Group storage group;\n        uint contribution;  \n        uint remaining;\n        uint amount;\n        uint sum;\n\n        // Iterate through the groups.\n        uint length = pool.groups.length;\n        for(uint idx = 0; idx < length; idx++) {\n\n            // Read contribution and remaining balance.\n            contribution = participant.contribution[idx];\n            remaining = participant.remaining[idx];\n            sum = contribution + remaining;\n\n            if(sum > 0) {\n                amount += sum;\n                group = pool.groups[idx];\n\n                // Reset contribution balance.\n                if(contribution > 0) {                    \n                    group.contribution -= contribution;\n                    participant.contribution[idx] = 0;\n                }\n\n                // Reset remaining balance.\n                if(remaining > 0) {\n                    group.remaining -= remaining;\n                    participant.remaining[idx] = 0;\n                }\n                                       \n                emit Withdrawal(\n                    msg.sender,\n                    idx,\n                    sum,\n                    0,\n                    0,\n                    group.contribution,\n                    group.remaining                    \n                );\n            }\n        }\n\n        // Transfer funds.\n        require(amount > 0);\n        addressTransfer(\n            msg.sender, \n            amount\n        );\n    }\n\n    /**\n     * @dev Wihdraw remaining balance (simple).\n     */  \n    function withdrawAllRemaining1(Pool storage pool) private {\n        Participant storage participant = pool.participantToData[msg.sender];        \n        Group storage group;\n        uint remaining;\n        uint amount;\n        \n        // Iterate through the groups.\n        uint length = pool.groups.length;\n        for(uint idx = 0; idx < length; idx++) {            \n            remaining = participant.remaining[idx];\n\n            // Reset remaining balance.\n            if(remaining > 0) {\n                amount += remaining;\n                group = pool.groups[idx];\n                group.remaining -= remaining;        \n                participant.remaining[idx] = 0;                                \n\n                emit Withdrawal(\n                    msg.sender,\n                    idx,\n                    remaining,\n                    participant.contribution[idx],\n                    0,\n                    group.contribution,\n                    group.remaining\n                );\n            }\n        }\n\n        // Transfer funds.\n        require(amount > 0);\n        addressTransfer(\n            msg.sender, \n            amount\n        );\n    }\n\n    /**\n     * @dev Wihdraw remaining balance and calculate.\n     */  \n    function withdrawAllRemaining2(Pool storage pool) \n        private \n        returns\n    (\n        uint poolContribution,\n        uint poolRemaining,\n        uint poolCtorFee,\n        uint partContribution,        \n        uint partCtorFee\n    ) \n    {\n        Participant storage participant = pool.participantToData[msg.sender];\n        Group storage group;\n        uint sumRemaining; \n        uint remaining;     \n\n        // Iterate through the groups.\n        uint length = pool.groups.length;\n        for(uint idx = 0; idx < length; idx++) {                        \n            group = pool.groups[idx];\n\n            // Make required calculations.\n            poolRemaining += group.remaining;\n            poolContribution += group.contribution;\n            poolCtorFee += calcFee(group.contribution, group.ctorFeePerEther);\n            \n            // Make required calculations.\n            remaining = participant.remaining[idx];\n            partContribution += participant.contribution[idx];\n            partCtorFee += calcFee(participant.contribution[idx], group.ctorFeePerEther);\n\n            // Reset remaining balance.\n            if(remaining > 0) {              \n                sumRemaining += remaining;                            \n                group.remaining -= remaining;\n                participant.remaining[idx] = 0;  \n\n                emit Withdrawal(\n                    msg.sender,\n                    idx,\n                    remaining,\n                    participant.contribution[idx],\n                    0,\n                    group.contribution,\n                    group.remaining                    \n                );\n            }\n        }\n\n        // Transfer funds.\n        if(sumRemaining > 0) {\n            poolRemaining -= sumRemaining;\n            addressTransfer(msg.sender, sumRemaining);\n        }\n    }    \n    \n    /**\n     * @dev Withdarw refund share and tokens share.\n     */  \n    function withdrawRefundAndTokens(Pool storage pool) private {\n        uint poolContribution;\n        uint poolRemaining;\n        uint poolCtorFee;\n        uint partContribution;        \n        uint partCtorFee;\n\n        // Withdraw remaining balance.\n        (poolContribution, \n            poolRemaining, \n            poolCtorFee, \n            partContribution,             \n            partCtorFee\n        ) = withdrawAllRemaining2(pool);\n\n        // Calculate net contribution values.        \n        uint netPoolContribution = poolContribution - poolCtorFee - calcFee(poolContribution, pool.svcFeePerEther);\n        uint netPartContribution = partContribution - partCtorFee - calcFee(partContribution, pool.svcFeePerEther);\n        \n        if(netPartContribution > 0) {\n            // Withdraw refund share based on net contribution.\n            withdrawRefundShare(pool, poolRemaining, netPoolContribution, netPartContribution);\n        }\n\n        // 'Fee-to-Token' mode.\n        if(pool.feeToTokenMode) {\n            netPoolContribution += poolCtorFee;\n            if(pool.feeToTokenAddress == msg.sender) {\n                netPartContribution += poolCtorFee;\n            }\n        }\n\n        if(netPartContribution > 0) {\n            // Withdraw tokens share based on net contribution.\n            withdrawTokens(pool, netPoolContribution, netPartContribution);\n        }\n    }\n\n    /**\n     * @dev Withdarw refund share.\n     */\n    function withdrawRefundShare(\n        Pool storage pool, \n        uint poolRemaining,\n        uint netPoolContribution, \n        uint netPartContribution\n    )\n        private \n    {\n        if(address(this).balance > poolRemaining) {\n            // Calculate and claim refund share.\n            uint amount = pool.refundQuota.claimShare(\n                msg.sender, \n                address(this).balance - poolRemaining,\n                [netPartContribution, netPoolContribution]\n            );\n\n            if(amount > 0) {          \n                // Trunsfer funds.                      \n                addressTransfer(msg.sender, amount);\n                emit RefundWithdrawal(\n                    msg.sender,\n                    address(this).balance,\n                    poolRemaining,\n                    amount\n                );                \n            }\n        }\n    }\n\n    /**\n     * @dev Withdraw tokens share.\n     */\n    function withdrawTokens(\n        Pool storage pool,        \n        uint netPoolContribution,\n        uint netPartContribution\n    )\n        private \n    {\n        bool succeeded;\n        uint tokenAmount;\n        uint tokenBalance;\n        address tokenAddress;\n        IERC20Base tokenContract;\n        QuotaLib.Storage storage quota;\n\n        // Iterate through the token addresses.\n        uint length = pool.tokenAddresses.length;\n        for(uint i = 0; i < length; i++) {             \n\n            tokenAddress = pool.tokenAddresses[i];            \n            tokenContract = IERC20Base(tokenAddress); \n            // Get token balance for the pool address.\n            tokenBalance = tokenContract.balanceOf(address(this));\n\n            if(tokenBalance > 0) {    \n                // Calculate and claim the token share.                                    \n                quota = pool.tokenQuota[tokenAddress];\n                tokenAmount = quota.claimShare(\n                    msg.sender,\n                    tokenBalance, \n                    [netPartContribution, netPoolContribution]\n                ); \n\n                if(tokenAmount > 0) {\n                    // Try to transfer tokens.\n                    succeeded = tokenContract.transfer(msg.sender, tokenAmount);\n                    if (!succeeded) {                        \n                        quota.undoClaimShare(msg.sender, tokenAmount);\n                    }\n                    emit TokenWithdrawal(\n                        tokenAddress,\n                        msg.sender,\n                        tokenBalance,\n                        tokenAmount,\n                        succeeded\n                    );\n                }\n            }\n        } \n    }   \n\n    /**\n     * @dev Create new participation group in case it doesn't exist otherwise update its settings.     \n     */\n    function setGroupSettingsCore(\n        Pool storage pool,        \n        uint idx,\n        uint maxBalance,\n        uint minContribution,\n        uint maxContribution,\n        uint ctorFeePerEther,         \n        bool isRestricted\n    )\n        private             \n    {\n        require(pool.groups.length > idx);\n        Group storage group = pool.groups[idx];        \n        \n        if(!group.exists) {\n            // Create new group. Pool groups should be created one-by-one.\n            require(idx == 0 || pool.groups[idx - 1].exists);\n            group.exists = true;\n        }\n        \n        validateGroupSettings(\n            maxBalance, \n            minContribution, \n            maxContribution\n        );        \n        \n        if(group.maxBalance != maxBalance) {\n            group.maxBalance = maxBalance;  \n        }          \n        \n        if(group.minContribution != minContribution) {\n            group.minContribution = minContribution;\n        }\n\n        if(group.maxContribution != maxContribution) {\n            group.maxContribution = maxContribution;\n        }\n        \n        if(group.ctorFeePerEther != ctorFeePerEther) {\n            require(ctorFeePerEther <= (1 ether / 2));\n            group.ctorFeePerEther = ctorFeePerEther;\n        }\n        \n        if(group.isRestricted != isRestricted) {\n            group.isRestricted = isRestricted;  \n        }      \n\n        emit GroupSettingsChanged(\n            idx,\n            maxBalance,\n            minContribution,\n            maxContribution,\n            ctorFeePerEther,\n            isRestricted\n        );                             \n    }    \n\n    /**\n     * @dev Modify group whitelist.\n     */\n    function modifyWhitelistCore(Pool storage pool, uint idx, address[] include, address[] exclude) private {\n        require(include.length > 0 || exclude.length > 0);\n        require(pool.groups.length > idx && pool.groups[idx].exists);\n\n        // Get group and participant instances.\n        Group storage group = pool.groups[idx];\n        Participant storage participant;        \n        uint i;\n\n        // Mark group as restricted.\n        if(!group.isRestricted) {\n            group.isRestricted = true;\n            emit WhitelistEnabled(idx);\n        }    \n\n        // Exclude participants.\n        for(i = 0; i < exclude.length; i++) {\n            participant = pool.participantToData[exclude[i]];            \n            if(participant.whitelist[idx]) {\n                participant.whitelist[idx] = false;\n                emit ExcludedFromWhitelist(\n                    exclude[i],\n                    idx\n                );                \n            }\n        }\n\n        // Include participants.\n        for(i = 0; i < include.length; i++) {\n            participant = pool.participantToData[include[i]];  \n\n            if(!participant.whitelist[idx]) { \n                // Create new participant.\n                if (!participant.exists) {                    \n                    pool.participants.push(include[i]);\n                    participant.exists = true;                                        \n                }                        \n\n                // Set as whitelisted.\n                participant.whitelist[idx] = true;               \n                emit IncludedInWhitelist(\n                    include[i],\n                    idx\n                );\n            }                \n        }\n    }        \n\n    /**\n     * @dev Distribute fees. When calling this function, contract balance should\n     *  consist of participants remaining balance, creator commission and service commission.\n     */\n    function sendFees(Pool storage pool) private {\n        uint ctorFee;\n        uint poolRemaining;\n        uint poolContribution;\n        // Calculate and transfer creator fee.\n        (poolContribution, poolRemaining, ctorFee) = calcPoolSummary(pool);\n        if(ctorFee > 0 && !pool.feeToTokenMode) {\n            addressTransfer(msg.sender, ctorFee);            \n        }\n        \n        // Calculate and transfer service fee.\n        uint svcFee = address(this).balance - poolRemaining;        \n        if(svcFee > 0) {\n            address creator = getPoolCreator(pool);\n            pool.feeService.sendFee.value(svcFee)(creator);\n        }\n\n        emit FeesDistributed(\n            ctorFee,\n            svcFee\n        );\n    }   \n\n    /**\n     * @dev Rebalance group contributions.\n     */\n    function groupRebalance(Pool storage pool, uint idx) private {\n        Group storage group = pool.groups[idx];          \n        uint maxBalance = group.maxBalance;\n        uint minContribution = group.minContribution;    \n        uint maxContribution = group.maxContribution;            \n        bool isRestricted = group.isRestricted;        \n        Participant storage participant;         \n        uint groupContribution;\n        uint groupRemaining;\n        uint contribution;\n        uint remaining;     \n        uint x = idx;   \n\n        // TODO: Getting stack too deep here..\n        // uint length = pool.participants.length;\n        for(uint i = 0; i < pool.participants.length; i++) {           \n            participant = pool.participantToData[pool.participants[i]];                \n            \n            // Calculate contribution and remaining balance.\n            (contribution, remaining) = calcContribution(       \n                x,\n                0,\n                maxBalance,\n                groupContribution,\n                minContribution,\n                maxContribution,\n                isRestricted,\n                participant\n            );        \n\n            // Save changes if some available.\n            if(contribution != participant.contribution[x]) {\n                participant.contribution[x] = contribution;\n                participant.remaining[x] = remaining;\n            }            \n            \n            groupContribution += contribution;            \n            groupRemaining += remaining;\n\n            emit ContributionAdjusted(\n                pool.participants[i], \n                contribution,\n                remaining,\n                groupContribution,\n                groupRemaining,\n                x\n            );\n        }\n        \n        // Update group contribution and remaining balance.\n        if(group.contribution != groupContribution) {\n            group.contribution = groupContribution;             \n            group.remaining = groupRemaining;           \n        }  \n    } \n\n    /**\n     * @dev Change pool state.\n     */\n    function changeState(Pool storage pool, State state) private {\n        assert(pool.state != state);\n        emit StateChanged(\n            uint(pool.state), \n            uint(state)\n        );\n        pool.state = state;        \n    }\n\n    /**\n     * @dev Add pool admin.\n     */\n    function addAdmin(Pool storage pool, address admin) private {\n        require(admin != address(0));\n        Participant storage participant = pool.participantToData[admin];\n        require(!participant.exists && !participant.isAdmin);\n\n        participant.exists = true;\n        participant.isAdmin = true;\n        pool.participants.push(admin);\n        pool.admins.push(admin);             \n        \n        emit AdminAdded(admin);                  \n    }  \n\n    /**\n     * @dev Trusted transfer.\n     */\n    function addressTransfer(address destination, uint etherAmount) private {\n        emit AddressTransfer(\n            destination,\n            etherAmount\n        );\n        destination.transfer(etherAmount);        \n    }\n\n    /**\n     * @dev Untrasted call.\n     */\n    function addressCall(address destination, uint etherAmount, bytes data) private {\n        addressCall(destination, 0, etherAmount, data);\n    }\n\n    /**\n     * @dev Untrasted call.\n     */\n    function addressCall(address destination, uint gasAmount,  uint etherAmount, bytes data) private {\n        emit AddressCall(\n            destination,\n            etherAmount,\n            gasAmount > 0 ? gasAmount : gasleft(),\n            data\n        );\n        require(\n            destination.call\n            .gas(gasAmount > 0 ? gasAmount : gasleft())\n            .value(etherAmount)\n            (data)            \n        );\n    }\n\n    /**\n     * @dev Calculate participant contribution.\n     */\n    function calcContribution(\n        uint idx,\n        uint amount,\n        uint maxBalance,\n        uint currentBalance,\n        uint minContribution, \n        uint maxContribution,\n        bool isRestricted,        \n        Participant storage participant\n    )\n        private view \n        returns(uint contribution, uint remaining)\n    {\n        // Total contribution amount.\n        uint totalAmount = participant.contribution[idx]\n            + participant.remaining[idx]\n            + amount;\n\n        // There are no limitations for admins.\n        if(participant.isAdmin) {\n            contribution = totalAmount;\n            return;\n        }                \n\n        // Limitations on group max balance & whitelist.\n        if(currentBalance >= maxBalance || (isRestricted && !participant.whitelist[idx])) {\n            remaining = totalAmount;            \n            return;\n        }        \n                        \n        contribution = Math.min(maxContribution, totalAmount);        \n        contribution = Math.min(maxBalance - currentBalance, contribution);\n        \n        // Limitation on group min contribution.\n        if(contribution < minContribution) {\n            remaining = totalAmount;\n            contribution = 0;\n            return;\n        }\n                \n        remaining = totalAmount - contribution;\n    }\n\n    /**\n     * @dev Calculate pool summaries.\n     */\n    function calcPoolSummary(Pool storage pool) \n        private view \n        returns\n    (\n        uint poolContribution, \n        uint poolRemaining, \n        uint ctorFee\n    ) \n    {\n        Group storage group;\n        uint length = pool.groups.length;\n\n        for(uint idx = 0; idx < length; idx++) {\n            group = pool.groups[idx];\n            if(!group.exists) {\n                break;\n            }\n            \n            poolRemaining += group.remaining;\n            poolContribution += group.contribution;            \n            ctorFee += calcFee(group.contribution, group.ctorFeePerEther);\n        }\n    }  \n\n    /**\n     * @dev Calculate pool & participant summaries.\n     */  \n    function calcPoolSummary2(Pool storage pool, address addr) \n        private view\n        returns\n    (\n        uint poolContribution,\n        uint poolRemaining,\n        uint poolCtorFee,\n        uint partContribution,        \n        uint partCtorFee\n    ) \n    {\n        Group storage group;\n        Participant storage participant = pool.participantToData[addr];        \n        uint length = pool.groups.length;\n        \n        for(uint idx = 0; idx < length; idx++) {            \n            group = pool.groups[idx];\n            if(!group.exists) {\n                break;\n            }\n\n            poolRemaining += group.remaining;\n            poolContribution += group.contribution;\n            poolCtorFee += calcFee(group.contribution, group.ctorFeePerEther);\n                        \n            partContribution += participant.contribution[idx];\n            partCtorFee += calcFee(participant.contribution[idx], group.ctorFeePerEther);\n        }\n    }     \n\n    /**\n     * @dev Calculate pool & participant net summaries.\n     */   \n    function calcPoolSummary3(Pool storage pool, address addr) \n        private view\n        returns\n    (\n        uint netPoolContribution,\n        uint netPartContribution,\n        uint poolRemaining,\n        uint poolCtorFee\n    ) \n    {\n        uint poolContribution;        \n        uint partContribution;\n        uint partCtorFee;\n\n        (poolContribution, \n            poolRemaining, \n            poolCtorFee, \n            partContribution,             \n            partCtorFee\n        ) = calcPoolSummary2(pool, addr);\n\n        netPoolContribution = poolContribution - poolCtorFee - calcFee(poolContribution, pool.svcFeePerEther);\n        netPartContribution = partContribution - partCtorFee - calcFee(partContribution, pool.svcFeePerEther);\n    }          \n  \n    /**\n     * @dev Function for validating group settings.\n     */\n    function validateGroupSettings(uint maxBalance, uint minContribution, uint maxContribution) private pure {\n        require(\n            minContribution > 0 &&\n            minContribution <= maxContribution &&\n            maxContribution <= maxBalance &&\n            maxBalance <= 1e9 ether            \n        );\n    }\n\n    /**\n     * @dev Check if an array contains provided value.\n     */\n    function contains(address[] storage array, address addr) private view returns (bool) {\n        for (uint i = 0; i < array.length; i++) {\n            if (array[i] == addr) {\n                return true;\n            }\n        }\n        return false;\n    } \n\n    /**\n     * @dev Returns pool creator address.\n     */\n    function getPoolCreator(Pool storage pool) private view returns(address) {\n        return pool.admins[0];\n    }     \n\n    /**\n     * @dev Fee calculator.\n     */\n    function calcFee(uint etherAmount, uint feePerEther) private pure returns(uint fee) {\n        fee = (etherAmount * feePerEther) / 1 ether;\n    }    \n\n\n    event StateChanged(\n        uint fromState,\n        uint toState\n    ); \n\n    event AdminAdded(\n        address adminAddress\n    );\n\n    event WhitelistEnabled(\n        uint groupIndex\n    );\n\n    event PresaleAddressLocked(\n        address presaleAddress\n    );  \n\n    event RefundAddressChanged(\n        address refundAddress\n    );    \n\n    event FeesDistributed(\n        uint creatorFeeAmount,\n        uint serviceFeeAmount\n    );\n\n    event IncludedInWhitelist(\n        address participantAddress,\n        uint groupIndex\n    );\n\n    event ExcludedFromWhitelist(\n        address participantAddress,\n        uint groupIndex\n    );  \n\n    event FeeServiceAttached(\n        address serviceAddress,\n        uint feePerEther\n    );    \n\n    event TokenAddressConfirmed(\n        address tokenAddress,\n        uint tokenBalance\n    ); \n\n    event RefundReceived(\n        address senderAddress,\n        uint etherAmount\n    );    \n \n    event Contribution(\n        address participantAddress,\n        uint groupIndex,\n        uint etherAmount,\n        uint participantContribution,\n        uint groupContribution        \n    );\n\n    event Withdrawal(\n        address participantAddress,\n        uint groupIndex,\n        uint etherAmount,\n        uint participantContribution,\n        uint participantRemaining,        \n        uint groupContribution,\n        uint groupRemaining\n    );\n\n    event TokenWithdrawal(\n        address tokenAddress,\n        address participantAddress,\n        uint poolTokenBalance,\n        uint tokenAmount,\n        bool succeeded    \n    );   \n\n    event RefundWithdrawal(\n        address participantAddress,\n        uint contractBalance,\n        uint poolRemaining,\n        uint etherAmount\n    );  \n\n    event ContributionAdjusted(\n        address participantAddress,\n        uint participantContribution,\n        uint participantRemaining,\n        uint groupContribution,\n        uint groupRemaining,\n        uint groupIndex\n    );\n  \n    event GroupSettingsChanged(\n        uint index,\n        uint maxBalance,                               \n        uint minContribution,\n        uint maxContribution,                        \n        uint ctorFeePerEther,\n        bool isRestricted                            \n    );       \n\n    event AddressTransfer(\n        address destinationAddress,\n        uint etherValue\n    );\n\n    event AddressCall(\n        address destinationAddress,\n        uint etherAmount,\n        uint gasAmount,\n        bytes data      \n    );   \n\n    event TransactionForwarded(\n        address destinationAddress,\n        uint etherAmount,\n        uint gasAmount,\n        bytes data\n    );\n\n    event ERC223Fallback(\n        address tokenAddress,\n        address senderAddress,\n        uint tokenAmount,\n        bytes data\n    );   \n}",
        "function": null,
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinfabrik-EasyPool Smart Contract Security Audit v2/EasyPool-master/contracts/library/ProPoolLib.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: Yes"
    }
]