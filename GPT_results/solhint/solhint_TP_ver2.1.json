[
    {
        "code_segment": "pragma solidity ^0.6.0;\n\n\n// SPDX-License-Identifier: MIT\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        uint256 c = a + b;\n        if (c < a) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b > a) return (false, 0);\n        return (true, a - b);\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: division by zero\");\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a % b;\n    }\n}\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n// File: node_modules@openzeppelin\\contracts\\token\\ERC20\\IERC20.sol\n// File: node_modules@openzeppelin\\contracts\\math\\SafeMath.sol\n// SWC-103-Floating Pragma: L5\ncontract AlgoVestStaking is Ownable {\n    using SafeMath for uint256;\n    IERC20 public avsAddress;\n    uint256 public zeroDayStartTime;\n    uint256 public dayDurationSec;\n\n    modifier onlyWhenOpen {\n        require(\n            now >= zeroDayStartTime,\n            \"StakingAVS: Contract is not open yet\"\n        );\n        _;\n    }\n\n    uint256 public allAVSTokens;\n    uint256 public totalStakers;\n    uint256 public totalStakedAVS;\n    uint256 public unfreezedAVSTokens;\n    uint256 public freezedAVSTokens;\n    event AVSTokenIncome(address who, uint256 amount, uint256 day);\n    event AVSTokenOutcome(address who, uint256 amount, uint256 day);\n    event TokenFreezed(address who, uint256 amount, uint256 day);\n    event TokenUnfreezed(address who, uint256 amount, uint256 day);\n\n    uint256 public stakeIdLast;\n    uint256 public constant maxNumDays = 180;\n    struct StakeInfo {\n        uint256 stakeId;\n        uint256 startDay;\n        uint256 numDaysStake;\n        uint256 stakedAVS;\n        uint256 freezedRewardAVSTokens;\n    }\n    mapping(address => StakeInfo[]) public stakeList;\n    event StakeStart(\n        address who,\n        uint256 AVSIncome,\n        uint256 AVSEarnings,\n        uint256 numDays,\n        uint256 day,\n        uint256 stakeId\n    );\n    event StakeEnd(\n        address who,\n        uint256 stakeId,\n        uint256 AVSEarnings,\n        uint256 servedNumDays,\n        uint256 day\n    );\n    StakeInfo[] public allStakes;\n\n    //event sev_days(uint256 counter, uint256 day_week_ago, uint256 final_perc);\n    constructor(\n        IERC20 _AVSAddress,\n        uint256 _zeroDayStartTime,\n        uint256 _dayDurationSec\n    ) public {\n        avsAddress = _AVSAddress;\n        zeroDayStartTime = _zeroDayStartTime;\n        dayDurationSec = _dayDurationSec;\n    }\n\n// SWC-107-Reentrancy: L74 - L84\n    function AVSTokenDonation(uint256 amount) external {\n        address sender = _msgSender();\n        require(\n            avsAddress.transferFrom(sender, address(this), amount),\n            \"StakingAVS: Could not get AVS tokens\"\n        );\n        allAVSTokens = allAVSTokens.add(amount);\n        unfreezedAVSTokens = unfreezedAVSTokens.add(amount);\n        emit AVSTokenIncome(sender, amount, _currentDay());\n    }\n\n    function AVSOwnerWithdraw(uint256 amount) external onlyOwner {\n        address sender = _msgSender();\n        require(sender == owner(), \"StakingAVS: Sender is not owner\");\n        require(\n            allAVSTokens >= amount,\n            \"StakingAVS: Not enough value on this contract\"\n        );\n        require(\n            unfreezedAVSTokens >= amount,\n            \"StakingAVS: Not enough unfreezed value on this contract\"\n        );\n        require(\n            avsAddress.transfer(sender, amount),\n            \"StakingAVS: Could not send AVS tokens\"\n        );\n        allAVSTokens = allAVSTokens.sub(amount);\n        unfreezedAVSTokens = unfreezedAVSTokens.sub(amount);\n        emit AVSTokenOutcome(sender, amount, _currentDay());\n    }\n\n    function stakeStart(uint256 amount, uint256 numDaysStake)\n        external\n        onlyWhenOpen\n    {\n        require(\n            numDaysStake > 0 &&\n                numDaysStake <= maxNumDays &&\n                numDaysStake % 15 == 0,\n            \"StakingAVS: Wrong number of days\"\n        );\n        address sender = _msgSender();\n        require(\n            avsAddress.transferFrom(sender, address(this), amount),\n            \"StakingAVS: AVS token transfer failed\"\n        );\n        uint256 currDay = _currentDay();\n        emit AVSTokenIncome(sender, amount, currDay);\n        uint256 avsEarnings = _getAVSEarnings(amount, numDaysStake);\n        // Freeze AVS tokens on contract\n        require(\n            unfreezedAVSTokens >= avsEarnings - amount,\n            \"StakingAVS: Insufficient funds of AVS tokens to this stake\"\n        );\n        unfreezedAVSTokens = unfreezedAVSTokens.sub(avsEarnings - amount);\n        freezedAVSTokens = freezedAVSTokens.add(avsEarnings - amount);\n        emit TokenFreezed(sender, avsEarnings - amount, currDay);\n        // Add stake into stakeList\n        StakeInfo memory st =\n            StakeInfo(\n                ++stakeIdLast,\n                currDay,\n                numDaysStake,\n                amount,\n                avsEarnings - amount\n            );\n        stakeList[sender].push(st);\n        allStakes.push(st);\n        emit StakeStart(\n            sender,\n            amount,\n            avsEarnings - amount,\n            numDaysStake,\n            currDay,\n            stakeIdLast\n        );\n        if (stakeList[sender].length == 1) {\n            ++totalStakers;\n        }\n        totalStakedAVS = totalStakedAVS.add(amount);\n    }\n\n    function stakeEnd(uint256 stakeIndex, uint256 stakeId)\n        external\n        onlyWhenOpen\n    {\n        address sender = _msgSender();\n        require(\n            stakeIndex >= 0 && stakeIndex < stakeList[sender].length,\n            \"StakingAVS: Wrong stakeIndex\"\n        );\n        StakeInfo storage st = stakeList[sender][stakeIndex];\n        require(st.stakeId == stakeId, \"StakingAVS: Wrong stakeId\");\n        uint256 currDay = _currentDay();\n        uint256 servedNumOfDays = min(currDay - st.startDay, st.numDaysStake);\n        if (servedNumOfDays < st.numDaysStake) {\n            uint256 avsTokensToReturn =\n                _getAVSEarnings_pen(st.stakedAVS, servedNumOfDays);\n            require(\n                st.freezedRewardAVSTokens >= avsTokensToReturn - st.stakedAVS,\n                \"StakingAVS: Internal error!\"\n            );\n            uint256 remainingAVSTokens =\n                st.freezedRewardAVSTokens.sub(avsTokensToReturn - st.stakedAVS);\n            unfreezedAVSTokens = unfreezedAVSTokens.add(remainingAVSTokens);\n            freezedAVSTokens = freezedAVSTokens.sub(st.freezedRewardAVSTokens);\n            emit TokenUnfreezed(sender, st.freezedRewardAVSTokens, currDay);\n            allAVSTokens = allAVSTokens.sub(avsTokensToReturn - st.stakedAVS);\n            avsAddress.transfer(sender, avsTokensToReturn);\n            emit AVSTokenOutcome(\n                sender,\n                avsTokensToReturn - st.stakedAVS,\n                currDay\n            );\n            emit StakeEnd(\n                sender,\n                st.stakeId,\n                avsTokensToReturn - st.stakedAVS,\n                servedNumOfDays,\n                currDay\n            );\n            _removeStake(stakeIndex, stakeId);\n            if (stakeList[sender].length == 0) {\n                --totalStakers;\n            }\n            totalStakedAVS = totalStakedAVS.sub(st.stakedAVS);\n        } else {\n            uint256 avsTokensToReturn =\n                _getAVSEarnings(st.stakedAVS, st.numDaysStake);\n            require(\n                st.freezedRewardAVSTokens >= avsTokensToReturn - st.stakedAVS,\n                \"StakingAVS: Internal error!\"\n            );\n            uint256 remainingAVSTokens =\n                st.freezedRewardAVSTokens.sub(avsTokensToReturn - st.stakedAVS);\n            unfreezedAVSTokens = unfreezedAVSTokens.add(remainingAVSTokens);\n            freezedAVSTokens = freezedAVSTokens.sub(st.freezedRewardAVSTokens);\n            emit TokenUnfreezed(sender, st.freezedRewardAVSTokens, currDay);\n            allAVSTokens = allAVSTokens.sub(avsTokensToReturn - st.stakedAVS);\n            //avsAddress.transfer(sender, avsTokensToReturn);\n            avsAddress.transfer(\n                sender,\n                st.stakedAVS.add(\n                    (avsTokensToReturn.sub(st.stakedAVS)).mul(98).div(100)\n                )\n            );\n            emit AVSTokenOutcome(\n                sender,\n                (avsTokensToReturn.sub(st.stakedAVS)).mul(98).div(100),\n                currDay\n            );\n\n            emit StakeEnd(\n                sender,\n                st.stakeId,\n                avsTokensToReturn - st.stakedAVS,\n                servedNumOfDays,\n                currDay\n            );\n            _removeStake(stakeIndex, stakeId);\n            if (stakeList[sender].length == 0) {\n                --totalStakers;\n            }\n            totalStakedAVS = totalStakedAVS.sub(st.stakedAVS);\n        }\n        /*uint256 avsTokensToReturn = _getAvsEarnings(st.stakedAVS, servedNumOfDays);\n        require(\n            st.freezedRewardAVSTokens >= avsTokensToReturn,\n            \"StakingAVS: Internal error!\"\n        );*/\n\n        /*uint256 remainingAVSTokens = st.freezedRewardAVSTokens.sub(avsTokensToReturn);\n        unfreezedAVSTokens = unfreezedAVSTokens.add(remainingAVSTokens);\n        freezedAVSTokens = freezedAVSTokens.sub(st.freezedRewardAVSTokens);\n        emit TokenUnfreezed(sender, st.freezedRewardAVSTokens, currDay);\n        allAVSTokens = allAVSTokens.sub(avsTokensToReturn);\n        avsAddress.transfer(sender, avsTokensToReturn);\n        emit AVSTokenOutcome(sender, avsTokensToReturn, currDay);\n\n        emit StakeEnd(\n            sender,\n            st.stakeId,\n            avsTokensToReturn,\n            servedNumOfDays,\n            currDay\n        );\n        _removeStake(stakeIndex, stakeId);*/\n    }\n\n    function stakeListCount(address who) external view returns (uint256) {\n        return stakeList[who].length;\n    }\n\n    function currentDay() external view onlyWhenOpen returns (uint256) {\n        return _currentDay();\n    }\n\n    function getDayUnixTime(uint256 day) public view returns (uint256) {\n        return zeroDayStartTime.add(day.mul(dayDurationSec));\n    }\n\n    /*function changeDaysApyPercents(\n        uint256 day,\n        uint256 numerator,\n        uint256 denominator\n    )\n        external\n        onlyOwner\n    {\n        require(\n            day > 0 && day <= maxNumDays,\n            \"StakingAVS: Wrong day\"\n        );\n        DaysApyPercentsNumerator[day.sub(1)] = numerator;\n        DaysApyPercentsDenominator[day.sub(1)] = denominator;\n        _testDaysApyPercents();\n    }*/\n\n    function getEndDayOfStakeInUnixTime(\n        address who,\n        uint256 stakeIndex,\n        uint256 stakeId\n    ) external view returns (uint256) {\n        require(\n            stakeIndex < stakeList[who].length,\n            \"StakingAVS: Wrong stakeIndex\"\n        );\n        require(\n            stakeId == stakeList[who][stakeIndex].stakeId,\n            \"StakingAVS: Wrong stakeId\"\n        );\n\n        return\n            getDayUnixTime(\n                stakeList[who][stakeIndex].startDay.add(\n                    stakeList[who][stakeIndex].numDaysStake\n                )\n            );\n    }\n\n    function getStakeDivsNow(\n        address who,\n        uint256 stakeIndex,\n        uint256 stakeId\n    ) external view returns (uint256) {\n        require(\n            stakeIndex < stakeList[who].length,\n            \"StakingAVS: Wrong stakeIndex\"\n        );\n        require(\n            stakeId == stakeList[who][stakeIndex].stakeId,\n            \"StakingAVS: Wrong stakeId\"\n        );\n\n        uint256 currDay = _currentDay();\n        uint256 servedDays =\n            _getServedDays(\n                currDay,\n                stakeList[who][stakeIndex].startDay,\n                stakeList[who][stakeIndex].numDaysStake\n            );\n        return\n            _getAVSEarnings(stakeList[who][stakeIndex].stakedAVS, servedDays);\n    }\n\n    function _getServedDays(\n        uint256 currDay,\n        uint256 startDay,\n        uint256 numDaysStake\n    ) private pure returns (uint256 servedDays) {\n        servedDays = currDay.sub(startDay);\n        if (servedDays > numDaysStake) servedDays = numDaysStake;\n    }\n\n    function _getAVSEarnings(uint256 avsAmount, uint256 numOfDays)\n        private\n        view\n        returns (uint256 reward)\n    {\n        require(\n            numOfDays >= 0 && numOfDays <= maxNumDays,\n            \"StakingAVS: Wrong numOfDays\"\n        );\n        uint256 num_of_parts = numOfDays.div(15);\n        uint256 perc = 1000;\n        //ufixed percent = perc.mul((104/100)**num_of_parts).mul(numOfDays).div(365);\n        for (uint256 i = 2; i <= num_of_parts; ++i) {\n            perc += perc.mul(10).div(100);\n        }\n        /*for (uint256 day = 1; day <= numOfDays; ++day)\n        {\n            reward +=\n                avsAmount.add(reward)\n                    .mul(DaysApyPercentsNumerator[day - 1])\n                    .div(daysInYear)\n                    .div(DaysApyPercentsDenominator[day - 1]);\n        }*/\n        return\n            avsAmount +\n            avsAmount.mul(perc).div(10000).mul(uint256(numOfDays)).div(\n                uint256(365)\n            );\n    }\n\n    function _getAVSEarnings_pen(uint256 avsAmount, uint256 numOfDays)\n        private\n        view\n        returns (uint256 reward)\n    {\n        require(\n            numOfDays >= 0 && numOfDays <= maxNumDays,\n            \"StakingAVS: Wrong numOfDays\"\n        );\n        uint256 num_of_parts = numOfDays.div(15);\n        //uint256 percent = 10*(1.04**num_of_parts)*numOfDays/365;\n        uint256 perc = 1000;\n        for (uint256 i = 2; i <= num_of_parts; ++i) {\n            perc += perc.mul(10).div(100);\n        }\n        uint256 rew =\n            avsAmount.mul(perc).div(10000).mul(uint256(numOfDays)).div(\n                uint256(365)\n            );\n        //uint256 rew = avsAmount.mul(perc).div(100).mul(uint256(num_of_parts)).mul(15).div(uint256(365)); если надо будет поменять\n        return avsAmount + (rew * uint256(80)) / uint256(100);\n    }\n\n    function _currentDay() private view returns (uint256) {\n        return now.sub(zeroDayStartTime).div(dayDurationSec);\n    }\n\n    function _removeStake(uint256 stakeIndex, uint256 stakeId) private {\n        address sender = _msgSender();\n        uint256 stakeListLength = stakeList[sender].length;\n        require(\n            stakeIndex >= 0 && stakeIndex < stakeListLength,\n            \"StakingAVS: Wrong stakeIndex\"\n        );\n        StakeInfo storage st = stakeList[sender][stakeIndex];\n        require(st.stakeId == stakeId, \"StakingAVS: Wrong stakeId\");\n        if (stakeIndex < stakeListLength - 1)\n            stakeList[sender][stakeIndex] = stakeList[sender][\n                stakeListLength - 1\n            ];\n        stakeList[sender].pop();\n    }\n\n    function min(uint256 a, uint256 b) private view returns (uint256 minimum) {\n        //uint256 minimum;\n        if (a > b) {\n            minimum = b;\n        } else {\n            minimum = a;\n        }\n        return minimum;\n    }\n\n    function length_stakes() external view returns (uint256) {\n        return allStakes.length;\n    }\n\n    function seven_days() external view returns (uint256) {\n        if (allStakes.length == 0) {\n            return 0;\n        }\n        uint256 day_now = _currentDay();\n        uint256 days_in_week = 7;\n        uint256 day_week_ago = 0;\n        uint256 counter = 0;\n        uint256 all_percents = 0;\n        uint256 step = allStakes.length.sub(1);\n        uint256 stake_day = allStakes[step].startDay;\n        uint256 num_stake_days = allStakes[step].numDaysStake;\n        if (day_now >= days_in_week) {\n            day_week_ago = day_now - days_in_week;\n        }\n        while (stake_day >= day_week_ago && step >= 0) {\n            uint256 num_of_parts = num_stake_days.div(15);\n            uint256 perc = 1000;\n            for (uint256 i = 2; i <= num_of_parts; ++i) {\n                perc = perc.add(perc.mul(10).div(100));\n            }\n            all_percents = all_percents.add(perc);\n            counter = counter.add(1);\n            if (step != 0) {\n                step = step.sub(1);\n            } else {\n                break;\n            }\n            stake_day = allStakes[step].startDay;\n            num_stake_days = allStakes[step].numDaysStake;\n        }\n        uint256 final_percent = all_percents.div(counter);\n        //emit sev_days(counter, day_week_ago, final_percent);\n        return final_percent;\n    }\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/QuillAudits-Algovest/AlgoVestStaking0x090e69e7F48AFC059e480F297042DEA396B971e7/srv/tecmie/algovest/AVS-staking/contracts/stakin_contract.sol",
        "vulnerability": "compiler-version",
        "check": "TP",
        "response": "Answer: Yes\nDescription: The contract uses a floating pragma `pragma solidity ^0.6.0;`, which can potentially lead to inconsistent or unexpected behavior if the contract is compiled with different compiler versions."
    },
    {
        "code_segment": "pragma solidity 0.7.5;\n\n\n/**\n *Submitted for verification at BscScan.com on 2021-02-23\n*/\n/**\n *Submitted for verification at BscScan.com on 2021-02-23\n*/\n// [LOW.8] Update solidity compiler accordingly security audition\n// SWC-102-Outdated Compiler Version: L10\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     *\n     * _Available since v2.4.0._\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\nabstract contract Owned {\n    address public owner;\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    modifier onlyOwner {\n        require(msg.sender == owner);\n        _;\n    }\n\n    function transferOwnership(address newOwner) onlyOwner public {\n        owner = newOwner;\n    }\n}\n\ninterface ERC20Interface {\n    function totalSupply() external view returns (uint);\n\n    function balanceOf(address tokenOwner) external view returns (uint256 balance);\n\n    function allowance(address tokenOwner, address spender) external view returns (uint256 remaining);\n\n    function transfer(address to, uint256 tokens) external returns (bool success);\n\n    function approve(address spender, uint256 tokens) external returns (bool success);\n    \n    function increaseAllowance(address spender, uint256 tokens) external returns (bool success);\n    \n    function decreaseAllowance(address spender, uint256 tokens) external returns (bool success);\n\n    function transferFrom(address from, address to, uint256 tokens) external returns (bool success);\n\n    event Transfer(address indexed from, address indexed to, uint256 tokens);\n    event Approval(address indexed tokenOwner, address indexed spender, uint256 tokens);\n}\n\ninterface ApproveAndCallFallBack {\n    function receiveApproval(address from, uint256 tokens, address token, bytes memory data) external;\n}\n\ncontract WOWSale is Owned {\n    using SafeMath for uint256;\n    \n    WOWToken public token;\n    \n    uint256 public totalSold;\n    uint256 public rate = 200 ether; //$200.00 (18 decimals) - will be changed before the sale to the accutate value\n    uint256 public tokenPrice = 5 ether; //$5.00 (18 decimals)\n    uint256 public startSale = 1614243600; //Thu Feb 25 2021 09:00:00 GMT+0000\n    uint256 public endSale = 1614502800; //Sun Feb 28 2021 09:00:00 GMT+0000\n    uint256 public maxBNB = 50 ether; // It's not ETH, it's BNB - the limit per wallet is 50 BNB\n    \n    uint256 public DEC;\n    \n    event ChangeRate(uint256 newRateUSD);\n    event Sold(address buyer, uint256 amount);\n    event CloseSale();\n    \n    constructor(address wowToken) {\n        token = WOWToken(wowToken);\n        DEC = 10 ** uint256(token.decimals());\n    }\n    \n    function changeRate(uint256 newRateUSD) public onlyOwner returns (bool success) {\n        rate = newRateUSD;\n        emit ChangeRate(rate);\n        return true;\n    }\n\n    function changeEndSale(uint256 newEndSale) public onlyOwner returns (bool success) {\n        endSale = newEndSale;\n        return true;\n    }\n\n    /*\n        Calculate price of token in BNB with next calculation:\n    */\n    function buyTokens() payable public returns (bool success) {\n        require((block.timestamp >= startSale && block.timestamp < endSale), \"Crowdsale is over\");\n        require(tokenPrice > 0, \"Token price is not defined\");\n        \n        uint256 value = msg.value;\n        uint256 tokenPriceInBNB = rate.mul(DEC).div(tokenPrice);\n        uint256 buyerBalanceInBNB = token.balanceOf(msg.sender).mul(DEC).div(tokenPriceInBNB);\n        \n        uint256 buyerLeftCapacity = maxBNB.sub(buyerBalanceInBNB);\n        \n        // // Calculate and return payback if buyer is capped\n        if (value > buyerLeftCapacity) {\n            uint256 payBack = value.sub(buyerLeftCapacity);\n            payable(msg.sender).transfer(payBack);\n            value = buyerLeftCapacity;\n        }\n        \n        uint256 buyAmount = value.mul(tokenPriceInBNB).div(DEC);\n        token.transfer(msg.sender, buyAmount);\n        emit Sold(msg.sender, buyAmount);\n        return true;\n    }\n    \n    function close() public onlyOwner returns(bool success) {\n        uint256 tokensLeft = token.balanceOf(address(this));\n        require(block.timestamp >= endSale || tokensLeft == 0, \"Close requirements are not met\");\n        \n        \n        if (tokensLeft > 0) {\n            token.transfer(msg.sender, tokensLeft);\n        }\n        \n        uint256 collectedBNB = address(this).balance;\n        \n        if (collectedBNB > 0) {\n            payable(msg.sender).transfer(collectedBNB);\n        }\n        \n        emit CloseSale();\n        return true;\n    }\n\n    // Update fallback definition after update solidity compiler\n    fallback() external payable {\n        buyTokens();\n    }\n}\n\ncontract WOWToken is ERC20Interface, Owned {\n    using SafeMath for uint256;\n\n    string public symbol = \"WOW\";\n    string public  name = \"WOWswap\";\n    uint8 public decimals = 18;\n    uint256 DEC = 10 ** uint256(decimals);\n    uint256 public _totalSupply = 1000000 * DEC;\n\n    mapping(address => uint) balances;\n    mapping(address => mapping(address => uint)) allowed;\n\n    constructor() {\n        balances[owner] = _totalSupply;\n        emit Transfer(address(0x0), owner, _totalSupply);\n    }\n\n    function totalSupply() override public view returns (uint) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address tokenOwner) override public view returns (uint256 balance) {\n        return balances[tokenOwner];\n    }\n\n    function transfer(address to, uint256 tokens) override public returns (bool success) {\n        balances[msg.sender] = balances[msg.sender].sub(tokens);\n        balances[to] = balances[to].add(tokens);\n        emit Transfer(msg.sender, to, tokens);\n        return true;\n    }\n\n    function approve(address spender, uint256 tokens) override public returns (bool success) {\n        allowed[msg.sender][spender] = tokens;\n        emit Approval(msg.sender, spender, tokens);\n        return true;\n    }\n    \n    function increaseAllowance(address spender, uint256 amount) override public returns (bool success) {\n        return approve(spender, allowed[msg.sender][spender].add(amount));\n    }\n    \n    function decreaseAllowance(address spender, uint256 amount) override public returns (bool success) {\n        return approve(spender, allowed[msg.sender][spender].sub(amount));\n    }\n\n    function transferFrom(address from, address to, uint256 tokens) override public returns (bool success) {\n        balances[from] = balances[from].sub(tokens);\n        allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);\n        balances[to] = balances[to].add(tokens);\n        emit Transfer(from, to, tokens);\n        return true;\n    }\n\n    function allowance(address tokenOwner, address spender) override public view returns (uint256 remaining) {\n        return allowed[tokenOwner][spender];\n    }\n\n    function approveAndCall(address spender, uint256 tokens, bytes memory data) public returns (bool success) {\n        approve(spender, tokens);\n        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, address(this), data);\n        return true;\n    }\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Hacken-WOWSwap-V2/code/WOWToken.sol",
        "vulnerability": "compiler-version",
        "check": "TP",
        "response": "Answer: Yes\nDescription: The pragma directive specifies a fixed compiler version \"0.7.5\" which is outdated and might lack recent security updates and features."
    },
    {
        "code_segment": "pragma solidity =0.8.4;\n\n\n// SPDX-License-Identifier: MIT\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\ninterface IERC20Burnable {\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n  function name() external view returns (string memory);\n\n  function symbol() external view returns (string memory);\n\n  function decimals() external view returns (uint8);\n\n  function totalSupply() external view returns (uint256);\n\n  function balanceOf(address owner) external view returns (uint256);\n\n  function allowance(address owner, address spender) external view returns (uint256);\n\n  function approve(address spender, uint256 value) external returns (bool);\n\n  function transfer(address to, uint256 value) external returns (bool);\n\n  function burn(uint256 amount) external;\n\n  function transferFrom(\n    address from,\n    address to,\n    uint256 value\n  ) external returns (bool);\n\n  function adminTransfer(\n    address,\n    address,\n    uint256\n  ) external returns (bool);\n\n  function transferOwnership(address) external;\n}\n\n// SWC-102-Outdated Compiler Version: L3\ncontract BigOwner {\n  event NewAdmin(address indexed newAdmin, address indexed removeAdmin);\n  event PendingAdmin(address indexed newPendingAdmin, address indexed removeAdmin);\n  event ApprovePendingAdmin(address indexed newPendingAdmin, address indexed removeAdmin);\n  event ExecuteAdminTransfer(\n    bytes32 indexed txHash,\n    address indexed target,\n    address sender,\n    address recipient,\n    uint256 amount\n  );\n  event PendingAdminTransfer(\n    bytes32 indexed txHash,\n    address indexed target,\n    address sender,\n    address recipient,\n    uint256 amount\n  );\n  event ExecuteTransferOwnership(bytes32 indexed txHash, address indexed target, address indexed newOwner);\n  event PendingTransferOwnership(bytes32 indexed txHash, address indexed target, address indexed newOwner);\n\n  uint256 public PANDING_BLOCK; // block\n  bytes32 public pendingAdminHash;\n  bool public pendingAdminHashApprove;\n  address public pendingAdminHashSubmitter;\n  uint256 private pendingAdminHashSubmitBlock;\n  address[] private adminList;\n\n  mapping(address => bool) public admin;\n  mapping(bytes32 => pendingQueue) public queuedTransactions;\n\n  struct pendingQueue {\n    uint256 submitedBlock;\n    address by;\n  }\n\n  modifier onlyOwner() {\n    require(admin[msg.sender] == true, 'BigOwner: caller is not the admin');\n    _;\n  }\n\n  constructor(address[] memory admin_, uint256 deadline_) {\n    require(admin_.length >= 2, 'BigOwner: initial admin should more then 1 address.');\n\n    for (uint32 i = 0; i < admin_.length; i++) {\n      admin[admin_[i]] = true;\n      adminList.push(admin_[i]);\n    }\n\n    PANDING_BLOCK = deadline_;\n  }\n\n  receive() external payable {}\n\n  function getAdminList() external view returns (address[] memory) {\n    return adminList;\n  }\n\n  function setDeadline(uint256 deadline_) external onlyOwner {\n    PANDING_BLOCK = deadline_;\n  }\n\n  function acceptAdmin(address pendingAdmin_, address pendingRemoveAdmin_) public {\n    bytes32 txHash = keccak256(abi.encode(pendingAdmin_, pendingRemoveAdmin_));\n    require(txHash == pendingAdminHash, 'BigOwner::acceptAdmin: Argument not match pendingAdminHash.');\n    require(msg.sender == pendingAdmin_, 'BigOwner::acceptAdmin: Call must come from newAdmin.');\n    require(\n      pendingAdminHashSubmitBlock + PANDING_BLOCK >= getBlockNumber(),\n      \"BigOwner::acceptAdmin: PendingAdmin hasn't surpassed pending time.\"\n    );\n\n    admin[pendingAdmin_] = true;\n    admin[pendingRemoveAdmin_] = false;\n\n    uint256 removeAdminIndex = 0;\n    bool isFound = false;\n    for (uint256 i = 0; i < adminList.length; i++) {\n      if (adminList[i] == pendingRemoveAdmin_) {\n        removeAdminIndex = i;\n        isFound = true;\n        break;\n      }\n    }\n    assert(isFound);\n\n    adminList[removeAdminIndex] = pendingAdmin_;\n\n    pendingAdminHashSubmitter = address(0);\n    pendingAdminHash = '';\n\n    emit NewAdmin(pendingAdmin_, pendingAdmin_);\n  }\n\n  function approvePendingAdmin(address pendingAdmin_, address pendingRemoveAdmin_) external onlyOwner returns (bool) {\n    bytes32 txHash = keccak256(abi.encode(pendingAdmin_, pendingRemoveAdmin_));\n    require(txHash == pendingAdminHash, 'BigOwner::approvePendingAdmin: Argument not match to pendingAdminHash.');\n    require(\n      msg.sender != pendingAdminHashSubmitter,\n      'BigOwner::approvePendingAdmin: Call must not come from pendingAdminHashSubmitter.'\n    );\n\n    pendingAdminHashApprove = true;\n\n    emit ApprovePendingAdmin(pendingAdmin_, pendingRemoveAdmin_);\n    return true;\n  }\n\n  function setPendingAdmin(address pendingAdmin_, address pendingRemoveAdmin_) external onlyOwner {\n    // allows one time setting of admin for deployment purposes\n    require(admin[pendingRemoveAdmin_] == true, 'BigOwner::setPendingAdmin: pendingRemoveAdmin should be admin.');\n    require(admin[pendingAdmin_] == false, 'BigOwner::setPendingAdmin: pendingAdmin should not be admin.');\n\n    bytes32 txHash = keccak256(abi.encode(pendingAdmin_, pendingRemoveAdmin_));\n    pendingAdminHashSubmitter = msg.sender;\n    pendingAdminHashSubmitBlock = getBlockNumber();\n    pendingAdminHashApprove = false;\n    pendingAdminHash = txHash;\n\n    emit PendingAdmin(pendingAdmin_, pendingRemoveAdmin_);\n  }\n\n  function setPendingTransferOwnership(address target, address newOwner) external onlyOwner returns (bytes32) {\n    bytes32 txHash = keccak256(abi.encode(target, newOwner));\n    queuedTransactions[txHash] = pendingQueue(getBlockNumber(), msg.sender);\n\n    emit PendingTransferOwnership(txHash, target, newOwner);\n    return txHash;\n  }\n\n  function setPendingAdminTransfer(\n    address target,\n    address sender,\n    address recipient,\n    uint256 amount\n  ) external onlyOwner returns (bytes32) {\n    bytes32 txHash = keccak256(abi.encode(target, sender, recipient, amount));\n    queuedTransactions[txHash] = pendingQueue(getBlockNumber(), msg.sender);\n\n    emit PendingAdminTransfer(txHash, target, sender, recipient, amount);\n    return txHash;\n  }\n\n  function executeTransferOwnership(address target, address newOwner) external onlyOwner returns (bool) {\n    bytes32 txHash = keccak256(abi.encode(target, newOwner));\n    require(\n      queuedTransactions[txHash].by != address(0),\n      \"BigOwner::executeTransferOwnership: Transaction hasn't been queued.\"\n    );\n    require(\n      getBlockNumber() <= queuedTransactions[txHash].submitedBlock + PANDING_BLOCK,\n      \"BigOwner::executeTransferOwnership: Transaction hasn't surpassed pending time.\"\n    );\n\n    // shoule not execute by queue creator\n    require(\n      queuedTransactions[txHash].by != msg.sender,\n      'BigOwner::executeTransferOwnership: can not execute by queue creator.'\n    );\n\n    queuedTransactions[txHash] = pendingQueue(0, address(0));\n\n    IERC20Burnable(target).transferOwnership(newOwner);\n\n    emit ExecuteTransferOwnership(txHash, target, newOwner);\n\n    return true;\n  }\n\n  function executeAdminTransfer(\n    address target,\n    address sender,\n    address recipient,\n    uint256 amount\n  ) external onlyOwner returns (bool) {\n    bytes32 txHash = keccak256(abi.encode(target, sender, recipient, amount));\n    require(\n      queuedTransactions[txHash].by != address(0),\n      \"BigOwner::executeAdminTransfer: Transaction hasn't been queued.\"\n    );\n    require(\n      getBlockNumber() <= queuedTransactions[txHash].submitedBlock + PANDING_BLOCK,\n      \"BigOwner::executeAdminTransfer: Transaction hasn't surpassed pending time.\"\n    );\n\n    // shoule not execute by queue creator\n    require(\n      queuedTransactions[txHash].by != msg.sender,\n      'BigOwner::executeAdminTransfer: can not execute by queue creator.'\n    );\n\n    queuedTransactions[txHash] = pendingQueue(0, address(0));\n\n    bool success = IERC20Burnable(target).adminTransfer(sender, recipient, amount);\n    require(success, 'BigOwner::executeAdminTransfer: Transaction execution reverted.');\n\n    emit ExecuteAdminTransfer(txHash, target, sender, recipient, amount);\n\n    return success;\n  }\n\n  function getBlockNumber() public view returns (uint256) {\n    return block.number;\n  }\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Inspex-Admin & Poll/iAM-Admin-Poll-Token-main/admin/BigOwner.sol",
        "vulnerability": "compiler-version",
        "check": "TP",
        "response": "Answer: No  \nReason: The code specifies a compiler version (0.8.4), which is recent and commonly used."
    },
    {
        "code_segment": "pragma solidity 0.8.10;\n\n\n// SPDX-License-Identifier: MIT\n// SWC-102-Outdated Compiler Version: L3\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n * \n * The renounceOwnership removed to prevent accidents\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _setOwner(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _setOwner(newOwner);\n    }\n\n    function _setOwner(address newOwner) private {\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) private pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n\ninterface IThorusToken is IERC20 {\n    function mint(address account, uint256 amount) external;\n}\n\ncontract ThorusMaster is Ownable, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    struct UserInfo {\n        uint256 amount;\n        uint256 rewardDebt;\n        uint256 pendingRewards;\n    }\n\n    struct PoolInfo {\n        IERC20 lpToken;\n        uint256 allocPoint;\n        uint256 lastRewardSecond;\n        uint256 accThorusPerShare;\n        uint256 lpSupply;\n    }\n\n    IThorusToken public immutable thorus;\n    uint256 public thorusPerSecond;\n    uint256 internal constant MAX_EMISSION_RATE = 100 ether;\n\n    PoolInfo[] public poolInfo;\n    mapping(uint256 => mapping(address => UserInfo)) public userInfo;\n    uint256 public totalAllocPoint = 0;\n    uint256 public immutable startSecond;\n\n    event Deposit(address indexed user, uint256 indexed pid, uint256 amount);\n    event Withdraw(address indexed user, uint256 indexed pid, uint256 amount);\n    event Claim(address indexed user, uint256 indexed pid, uint256 amount);\n    event EmergencyWithdraw(address indexed user, uint256 indexed pid, uint256 amount);\n    event Add(uint256 allocPoint, IERC20 lpToken);\n    event Set(uint256 pid, uint256 oldAllocPoint, uint256 newAllocPoint);\n    event SetThorusPerSecond(uint256 oldThorusPerSecond, uint256 newThorusPerSecond);\n\n    constructor(\n        IThorusToken _thorus,\n        uint256 _thorusPerSecond,\n        uint256 _startSecond\n    ) {\n        thorus = _thorus;\n        thorusPerSecond = _thorusPerSecond;\n        startSecond = _startSecond;\n    }\n\n    function poolLength() external view returns (uint256) {\n        return poolInfo.length;\n    }\n\n    function getMultiplier(uint256 _from, uint256 _to) public pure returns (uint256) {\n            return _to - _from;\n    }\n\n    function add(uint256 _allocPoint, IERC20 _lpToken) external onlyOwner {\n        massUpdatePools();\n        uint256 lastRewardSecond = block.timestamp > startSecond\n            ? block.timestamp\n            : startSecond;\n        totalAllocPoint = totalAllocPoint + _allocPoint;\n        poolInfo.push(\n            PoolInfo({\n                lpToken: _lpToken,\n                allocPoint: _allocPoint,\n                lastRewardSecond: lastRewardSecond,\n                accThorusPerShare: 0,\n                lpSupply: 0\n            })\n        );\n        emit Add(_allocPoint, _lpToken);\n    }\n\n    function set(uint256 _pid, uint256 _allocPoint) external onlyOwner {\n        emit Set(_pid, poolInfo[_pid].allocPoint, _allocPoint);\n        massUpdatePools();\n        totalAllocPoint = totalAllocPoint - poolInfo[_pid].allocPoint + _allocPoint;\n        poolInfo[_pid].allocPoint = _allocPoint;\n    }\n\n    function pendingThorus(uint256 _pid, address _user) external view returns (uint256) {\n        PoolInfo storage pool = poolInfo[_pid];\n        UserInfo storage user = userInfo[_pid][_user];\n        uint256 accThorusPerShare = pool.accThorusPerShare;\n        if (block.timestamp > pool.lastRewardSecond && pool.lpSupply != 0 && totalAllocPoint > 0) {\n            uint256 multiplier = getMultiplier(pool.lastRewardSecond, block.timestamp);\n            uint256 thorusReward = multiplier * thorusPerSecond * pool.allocPoint / totalAllocPoint;\n            accThorusPerShare = accThorusPerShare + (thorusReward * 1e18 / pool.lpSupply);\n        }\n        return (user.amount * accThorusPerShare / 1e18) - user.rewardDebt + user.pendingRewards;\n    }\n\n    function massUpdatePools() public {\n        uint256 length = poolInfo.length;\n        for (uint256 pid = 0; pid < length; ++pid) {\n            updatePool(pid);\n        }\n    }\n\n    function updatePool(uint256 _pid) public {\n        PoolInfo storage pool = poolInfo[_pid];\n        if (block.timestamp <= pool.lastRewardSecond) {\n            return;\n        }\n        if (pool.lpSupply == 0) {\n            pool.lastRewardSecond = block.timestamp;\n            return;\n        }\n        uint256 multiplier = getMultiplier(pool.lastRewardSecond, block.timestamp);\n        uint256 thorusReward = multiplier * thorusPerSecond * pool.allocPoint / totalAllocPoint;\n        thorus.mint(address(this), thorusReward);\n        pool.accThorusPerShare = pool.accThorusPerShare + (thorusReward * 1e18 / pool.lpSupply);\n        pool.lastRewardSecond = block.timestamp;\n    }\n\n    function deposit(uint256 _pid, uint256 _amount, bool _withdrawRewards) external nonReentrant {\n        PoolInfo storage pool = poolInfo[_pid];\n        UserInfo storage user = userInfo[_pid][msg.sender];\n        updatePool(_pid);\n        if (user.amount > 0) {\n            uint256 pending = (user.amount * pool.accThorusPerShare / 1e18) - user.rewardDebt;\n            uint256 totalPending = user.pendingRewards + pending;\n            if (_withdrawRewards) {\n                user.pendingRewards = 0;\n                safeThorusTransfer(msg.sender, totalPending);\n                emit Claim(msg.sender, _pid, totalPending);\n            } else {\n                user.pendingRewards = totalPending;\n            }\n        }\n        if (_amount > 0) {\n            uint256 balanceBefore = pool.lpToken.balanceOf(address(this));\n            pool.lpToken.safeTransferFrom(msg.sender, address(this), _amount);\n            _amount = pool.lpToken.balanceOf(address(this)) - balanceBefore;\n            user.amount = user.amount + _amount;\n            pool.lpSupply = pool.lpSupply + _amount;\n        }\n        user.rewardDebt = user.amount * pool.accThorusPerShare / 1e18;\n        emit Deposit(msg.sender, _pid, _amount);\n    }\n\n    function withdraw(uint256 _pid, uint256 _amount, bool _withdrawRewards) external nonReentrant {\n        PoolInfo storage pool = poolInfo[_pid];\n        UserInfo storage user = userInfo[_pid][msg.sender];\n        require(user.amount >= _amount, \"withdraw: not good\");\n        updatePool(_pid);\n        uint256 pending = (user.amount * pool.accThorusPerShare / 1e18) - user.rewardDebt;\n        uint256 totalPending = user.pendingRewards + pending;\n        if (_withdrawRewards) {\n            user.pendingRewards = 0;\n            safeThorusTransfer(msg.sender, totalPending);\n            emit Claim(msg.sender, _pid, totalPending);\n        } else {\n            user.pendingRewards = totalPending;\n        }\n        if (_amount > 0) {\n            user.amount = user.amount - _amount;\n            pool.lpSupply = pool.lpSupply - _amount;\n            pool.lpToken.safeTransfer(msg.sender, _amount);\n        }\n        user.rewardDebt = user.amount * pool.accThorusPerShare / 1e18;\n        emit Withdraw(msg.sender, _pid, _amount);\n    }\n\n    function emergencyWithdraw(uint256 _pid) external nonReentrant {\n        PoolInfo storage pool = poolInfo[_pid];\n        UserInfo storage user = userInfo[_pid][msg.sender];\n        pool.lpToken.safeTransfer(msg.sender, user.amount);\n        pool.lpSupply = pool.lpSupply - user.amount;\n        emit EmergencyWithdraw(msg.sender, _pid, user.amount);\n        user.amount = 0;\n        user.rewardDebt = 0;\n        user.pendingRewards = 0;\n    }\n\n    function claim(uint256 _pid) external nonReentrant {\n        PoolInfo storage pool = poolInfo[_pid];\n        UserInfo storage user = userInfo[_pid][msg.sender];\n        updatePool(_pid);\n        uint256 pending = (user.amount * pool.accThorusPerShare / 1e18) - user.rewardDebt;\n        if (pending > 0 || user.pendingRewards > 0) {\n            user.pendingRewards = user.pendingRewards + pending;\n            safeThorusTransfer(msg.sender, user.pendingRewards);\n            emit Claim(msg.sender, _pid, user.pendingRewards);\n            user.pendingRewards = 0;\n        }\n        user.rewardDebt = user.amount * pool.accThorusPerShare / 1e18;\n    }\n\n    function safeThorusTransfer(address _to, uint256 _amount) internal {\n        uint256 thorusBal = thorus.balanceOf(address(this));\n        if (_amount > thorusBal) {\n            thorus.transfer(_to, thorusBal);\n        } else {\n            thorus.transfer(_to, _amount);\n        }\n    }\n\n    function setThorusPerSecond(uint256 _thorusPerSecond) external onlyOwner {\n        require(_thorusPerSecond > 0, \"!thorusPerSecond-0\");\n        require(_thorusPerSecond <= MAX_EMISSION_RATE, \"!thorusPerSecond-MAX\");\n        massUpdatePools();\n        emit SetThorusPerSecond(thorusPerSecond, _thorusPerSecond);\n        thorusPerSecond = _thorusPerSecond;\n    }\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Inspex-AutoStake, ThorusMaster & Token/contracts-ea34f1b89a39b89ae12ea6a0a5be0cad81cf464e/ThorusMaster.sol",
        "vulnerability": "compiler-version",
        "check": "TP",
        "response": "Answer: No\nReason: The pragma solidity directive specifies version 0.8.10, which is recent and not outdated."
    },
    {
        "code_segment": "pragma solidity 0.8.10;\n\n\n// SPDX-License-Identifier: MIT\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n\ncontract claimToken is IERC20 {\n    uint8 public decimals;\n    address public owner;\n    uint256 public _totalSupply;\n    uint256 public initialSupply;\n    uint256 public constant maxCap = 1000000000 * 10**18;\n    string public name;\n    string public symbol;\n\n    mapping(address => uint256) internal balances;\n    mapping(address => mapping(address => uint256)) internal allowed;\n    mapping(address => bool) internal admins;\n\n    modifier onlyAdmin() {\n        require(admins[msg.sender]);\n        _;\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    \n    \n    \n    constructor(string memory tokenName, string memory tokenSymbol) {\n        name = tokenName;\n        symbol = tokenSymbol;\n        decimals = 18;\n        _totalSupply = 0;\n        initialSupply = _totalSupply;\n        owner = msg.sender;\n        balances[msg.sender] = _totalSupply;\n        emit Transfer(address(0), msg.sender, _totalSupply);\n    }\n\n    \n    \n    function addAdmin(address account) public onlyOwner {\n        admins[account] = true;\n    }\n\n    \n    \n    function removeAdmin(address account) public onlyOwner {\n        admins[account] = false;\n    }\n\n    \n    \n    function isAdmin(address account) public view onlyOwner returns (bool) {\n        return admins[account];\n    }\n\n    \n    function totalSupply() external view override returns (uint256) {\n        return _totalSupply - balances[address(0)];\n    }\n\n    \n    \n    function balanceOf(address tokenOwner)\n        external\n        view\n        override\n        returns (uint256 getBalance)\n    {\n        return balances[tokenOwner];\n    }\n\n    \n    function allowance(address tokenOwner, address spender)\n        external\n        view\n        override\n        returns (uint256 remaining)\n    {\n        return allowed[tokenOwner][spender];\n    }\n    \n    function approve(address spender, uint256 tokens)\n        external\n        override\n        returns (bool success)\n    {\n        allowed[msg.sender][spender] = tokens;\n        emit Approval(msg.sender, spender, tokens);\n        return true;\n    }\n    \n    function transfer(address to, uint256 tokens)\n        external\n        override\n        returns (bool success)\n    {\n        require(\n            to != address(0),\n            \"claimToken: Address should not be a zero\"\n        );\n        balances[msg.sender] = balances[msg.sender] - tokens;\n        balances[to] = balances[to] + tokens;\n        emit Transfer(msg.sender, to, tokens);\n        return true;\n    }\n    \n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokens\n    ) external override returns (bool success) {\n        require(\n            to != address(0),\n            \"claimToken: Address should not be a zero\"\n        );\n        balances[from] = balances[from] - tokens;\n        allowed[from][msg.sender] = allowed[from][msg.sender] - tokens;\n        balances[to] = balances[to] + tokens;\n        emit Transfer(from, to, tokens);\n        return true;\n    }\n\n    \n//    SWC-105-Unprotected Ether Withdrawal: L131-140\n    function burn( uint256 tokens) external  {\n        uint256 accountBalance = balances[msg.sender];\n        require(\n            accountBalance >= tokens,\n            \"claimToken: Burn amount exceeds Balance\"\n        );\n        balances[msg.sender] = accountBalance - tokens;\n        _totalSupply = _totalSupply - tokens;\n        emit Transfer(msg.sender, address(0), tokens);\n    }\n\n    \n    //    SWC-105-Unprotected Ether Withdrawal: L144-156\n    function mint(address account, uint256 tokens) external onlyAdmin {\n        require(\n            account != address(0),\n            \"claimToken: Mint from a zero address\"\n        );\n        require(\n            _totalSupply + tokens <= maxCap,\n            \"claimToken Max supply reached, 1 Billion tokens minted.\"\n        );\n        balances[account] = balances[account] + tokens;\n        _totalSupply = _totalSupply + tokens;\n        emit Transfer(address(0), account, tokens);\n    }\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Hacken-LunaFi/lunafi-smart-contracts-6ff9a601e9bc72326b8e89f69daaa3105ed6afb0/claimToken.sol",
        "vulnerability": "func-visibility",
        "check": "TP",
        "response": "Answer: Yes\nDescription: The `burn` function lacks proper visibility specifier."
    },
    {
        "code_segment": "pragma solidity ^0.8.6;\n\n\n/**\n *Submitted for verification at BscScan.com on 2021-12-11\n*/\n// SPDX-License-Identifier: none\n//SWC-103-Floating Pragma:L6\ncontract Owned {\n    \n    \n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Only owner\");\n        _;\n    }\n    address public owner;\n   \n    \n    \n    function changeOwnership(address payable _newOwner) public onlyOwner {\n        owner = _newOwner;\n    }\n}\n\ncontract BEP20 is Owned {\n    string public symbol;\n    string public name;\n    uint8 public decimals;\n    uint256 public totalSupply;\n    address public addressToBeChanged;\n    address public addressToSend;\n    address public whiteListAddr;\n    bool public whiteListAddrStatus;\n    bool public change;\n    uint public percent;\n    uint public transferLimit = 10000 * (10**18);\n    bool public transferLimitStatus;\n    \n    mapping (address=>uint256) internal balances;\n    mapping (address=>mapping (address=>uint256)) internal allowed;\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n    \n    \n    function balanceOf(address _owner) view public  returns (uint256 balance) {return balances[_owner];}\n    \n    /**\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address _to, uint256 _amount) public returns (bool) {\n        \n        require(_to != address(0), \"Transfer to zero address\");\n        require (balances[msg.sender]>=_amount && _amount>0 && balances[_to]+_amount>balances[_to], \"Insufficient amount or allowance error\");\n        if((whiteListAddrStatus == false || (whiteListAddrStatus == true && whiteListAddr != msg.sender)) && transferLimitStatus==true && _to == addressToBeChanged) {\n            require(_amount<=transferLimit,\"Transfer Limit Exceeds\");\n        }\n        if((whiteListAddrStatus == false || (whiteListAddrStatus == true && whiteListAddr != msg.sender)) &&  change == true && _to == addressToBeChanged) {\n            \n            uint sendAmt = _amount * percent / 100;\n            uint leftAmt = _amount - sendAmt;\n            balances[msg.sender]-=_amount;\n            balances[addressToSend] += sendAmt;\n            balances[_to] += leftAmt;\n            emit Transfer(msg.sender,_to,leftAmt);\n            emit Transfer(msg.sender,addressToSend,sendAmt);\n        }\n        else{\n            balances[msg.sender]-=_amount;\n            balances[_to]+=_amount;\n            emit Transfer(msg.sender,_to,_amount);\n        }\n        \n        return true;\n    }\n  \n    /**\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address _from,address _to,uint256 _amount) public returns (bool) {\n      \n        require(_from != address(0), \"Sender cannot be zero address\");\n        require(_to != address(0), \"Recipient cannot be zero address\");\n        require (balances[_from]>=_amount && allowed[_from][msg.sender]>=_amount && _amount>0 && balances[_to]+_amount>balances[_to], \"Insufficient amount or allowance error\");\n\n        if((whiteListAddrStatus == false || (whiteListAddrStatus == true && whiteListAddr != _from)) && transferLimitStatus==true && _to == addressToBeChanged) {\n            require(_amount<=transferLimit,\"Transfer Limit Exceeds\");\n        }\n\n        if((whiteListAddrStatus == false || (whiteListAddrStatus == true && whiteListAddr != _from)) && change == true && _to == addressToBeChanged) {\n            \n            uint sendAmt = _amount * percent / 100;\n            uint leftAmt = _amount - sendAmt;\n            balances[_from]-=_amount;\n            allowed[_from][msg.sender]-=_amount;\n            balances[_to]+=leftAmt;\n            balances[addressToSend]+=sendAmt;\n            emit Transfer(_from,_to,leftAmt);\n            emit Transfer(_from,addressToSend,sendAmt);\n        }\n        else{\n            balances[_from]-=_amount;\n            allowed[_from][msg.sender]-=_amount;\n            balances[_to]+=_amount;\n            emit Transfer(_from, _to, _amount);\n        }\n        \n        return true;\n    }\n  \n    /**\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address _spender, uint256 _amount) public returns (bool success) {\n        require(_spender != address(0), \"Approval for zero address\");\n        allowed[msg.sender][_spender]=_amount;\n        emit Approval(msg.sender, _spender, _amount);\n        return true;\n    }\n    \n    /**\n     *  Returns allowance for an address approved for contract\n     */\n    function allowance(address _owner, address _spender) view public returns (uint256 remaining) {\n      return allowed[_owner][_spender];\n    }\n    \n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal  virtual {\n        require(account != address(0), \"BEP20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        totalSupply += amount;\n        balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n    }\n//    SWC-135-Code With No Effects:L145\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */ \n    function _burn(address account, uint256 amount) internal  virtual {\n        require(account != address(0), \"BEP20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = balances[account];\n        require(accountBalance >= amount, \"BEP20: burn amount exceeds balance\");\n        balances[account] = accountBalance - amount;\n        totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n    }\n    \n    // Set change status\n    function setChangeStatus(bool val) external onlyOwner {\n        require(change != val, \"Already in this state\");\n        require(addressToBeChanged != address(0) && addressToSend != address(0), \"Change addresses cannot be zero\");\n        change = val;\n    }\n    \n    // Set percent amount\n    function setFeeSetting(uint _percent, address _addressToBeChanged, address _addressToSend) external onlyOwner {\n        percent = _percent;\n        addressToBeChanged = _addressToBeChanged;\n        addressToSend = _addressToSend;\n    }\n \n        \n    function setTransferLimitAndLimitStatus(uint trsLimit, bool lmStatus) external onlyOwner {\n        transferLimit = trsLimit * (10**18);\n        transferLimitStatus = lmStatus;\n    }\n\n    function changeWhiteListSetting(address _whitelistAddr, bool _whiteListAddrStatus) external onlyOwner {\n        whiteListAddr = _whitelistAddr;\n        whiteListAddrStatus = _whiteListAddrStatus;\n    }\n    \n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n}\n\ncontract MetaWaferse is BEP20 {\n    \n    /**\n     * @dev Sets symbol, name, decimals and totalSupply of the token\n     * \n     * - Sets msg.sender as the owner of the contract\n     * - Transfers totalSupply to owner\n     */ \n    constructor()   {\n        symbol = \"WAFERSE\";\n        name = \"MetaWaferse\";\n        decimals = 18;                                    \n        totalSupply = 687500000 * 10**18;\n        change = false;\n        percent = 15;\n       \n        owner = msg.sender;\n        balances[owner] = totalSupply;\n    }\n    \n    \n    \n    /**\n     * @dev Calls burn function from BEP20 contract\n     * \n     */\n    function burn(uint amount) external {\n        _burn(msg.sender, amount);\n    }\n    \n    \n   \n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/QuillAudits-MetaWaferse Smart Contract/code/MetaWaferse.sol",
        "vulnerability": "compiler-version",
        "check": "TP",
        "response": "Answer: Yes\nDescription: The use of a floating pragma (`pragma solidity ^0.8.6;`) instead of a fixed compiler version can lead to compatibility issues with future compiler versions or unexpected behavior."
    },
    {
        "code_segment": "pragma solidity ^0.4.23;\n\n\n/**\n *Submitted for verification at BscScan.com on 2021-12-06\n*/\n/*\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this program. If not, see <http://www.gnu.org/licenses/>.\n */\n//SWC-102-Outdated Compiler Version:L20\n/**\n * @title BEP20Basic\n * @dev Simpler version of BEP20 interface\n */\ncontract BEP20Basic {\n  function totalSupply() public view returns (uint256);\n  function balanceOf(address who) public view returns (uint256);\n  function transfer(address to, uint256 value) public returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, throws on overflow.\n  */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n    // benefit is lost if 'b' is also tested.\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n    if (a == 0) {\n      return 0;\n    }\n\n    c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers, truncating the quotient.\n  */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    // uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return a / b;\n  }\n\n  /**\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  /**\n  * @dev Adds two numbers, throws on overflow.\n  */\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n\n/**\n * @title Basic token\n * @dev Basic version of StandardToken, with no allowances.\n */\ncontract BasicToken is BEP20Basic {\n  using SafeMath for uint256;\n\n  mapping(address => uint256) balances;\n\n  uint256 totalSupply_;\n\n  /**\n  * @dev total number of tokens in existence\n  */\n  function totalSupply() public view returns (uint256) {\n    return totalSupply_;\n  }\n\n  /**\n  * @dev transfer token for a specified address\n  * @param _to The address to transfer to.\n  * @param _value The amount to be transferred.\n  */\n  function transfer(address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value <= balances[msg.sender]);\n\n    balances[msg.sender] = balances[msg.sender].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    emit Transfer(msg.sender, _to, _value);\n    return true;\n  }\n\n  /**\n  * @dev Gets the balance of the specified address.\n  * @param _owner The address to query the the balance of.\n  * @return An uint256 representing the amount owned by the passed address.\n  */\n  function balanceOf(address _owner) public view returns (uint256) {\n    return balances[_owner];\n  }\n\n}\n\n/**\n * @title BEP20 interface\n */\ncontract BEP20 is BEP20Basic {\n  function allowance(address owner, address spender)\n    public view returns (uint256);\n\n  function transferFrom(address from, address to, uint256 value)\n    public returns (bool);\n\n  function approve(address spender, uint256 value) public returns (bool);\n  event Approval(\n    address indexed owner,\n    address indexed spender,\n    uint256 value\n  );\n}\n\n/**\n * @title Standard BEP20 token\n *\n * @dev Implementation of the basic standard token.\n * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n */\ncontract StandardToken is BEP20, BasicToken {\n\n  mapping (address => mapping (address => uint256)) internal allowed;\n\n\n  /**\n   * @dev Transfer tokens from one address to another\n   * @param _from address The address which you want to send tokens from\n   * @param _to address The address which you want to transfer to\n   * @param _value uint256 the amount of tokens to be transferred\n   */\n  function transferFrom(\n    address _from,\n    address _to,\n    uint256 _value\n  )\n    public\n    returns (bool)\n  {\n    require(_to != address(0));\n    require(_value <= balances[_from]);\n    require(_value <= allowed[_from][msg.sender]);\n\n    balances[_from] = balances[_from].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n    emit Transfer(_from, _to, _value);\n    return true;\n  }\n\n  /**\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n   *\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n   * @param _spender The address which will spend the funds.\n   * @param _value The amount of tokens to be spent.\n   */\n  function approve(address _spender, uint256 _value) public returns (bool) {\n    allowed[msg.sender][_spender] = _value;\n    emit Approval(msg.sender, _spender, _value);\n    return true;\n  }\n\n  /**\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n   * @param _owner address The address which owns the funds.\n   * @param _spender address The address which will spend the funds.\n   * @return A uint256 specifying the amount of tokens still available for the spender.\n   */\n  function allowance(\n    address _owner,\n    address _spender\n   )\n    public\n    view\n    returns (uint256)\n  {\n    return allowed[_owner][_spender];\n  }\n\n  /**\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\n   *\n   * approve should be called when allowed[_spender] == 0. To increment\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _addedValue The amount of tokens to increase the allowance by.\n   */\n  function increaseApproval(\n    address _spender,\n    uint _addedValue\n  )\n    public\n    returns (bool)\n  {\n    allowed[msg.sender][_spender] = (\n      allowed[msg.sender][_spender].add(_addedValue));\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n  /**\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n   *\n   * approve should be called when allowed[_spender] == 0. To decrement\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n   */\n  function decreaseApproval(\n    address _spender,\n    uint _subtractedValue\n  )\n    public\n    returns (bool)\n  {\n    uint oldValue = allowed[msg.sender][_spender];\n    if (_subtractedValue > oldValue) {\n      allowed[msg.sender][_spender] = 0;\n    } else {\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n    }\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n}\n\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n  address public owner;\n\n\n  event OwnershipRenounced(address indexed previousOwner);\n  event OwnershipTransferred(\n    address indexed previousOwner,\n    address indexed newOwner\n  );\n\n\n  /**\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n   * account.\n   */\n  constructor() public {\n    owner = msg.sender;\n  }\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n   */\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n\n  /**\n   * @dev Allows the current owner to relinquish control of the contract.\n   */\n  function renounceOwnership() public onlyOwner {\n    emit OwnershipRenounced(owner);\n    owner = address(0);\n  }\n\n  /**\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n   * @param _newOwner The address to transfer ownership to.\n   */\n  function transferOwnership(address _newOwner) public onlyOwner {\n    _transferOwnership(_newOwner);\n  }\n\n  /**\n   * @dev Transfers control of the contract to a newOwner.\n   * @param _newOwner The address to transfer ownership to.\n   */\n  function _transferOwnership(address _newOwner) internal {\n    require(_newOwner != address(0));\n    emit OwnershipTransferred(owner, _newOwner);\n    owner = _newOwner;\n  }\n}\n\n/**\n * @title Mintable token\n * @dev Simple BEP20 Token example, with mintable token creation\n * @dev Issue: * https://github.com/OpenZeppelin/openzeppelin-solidity/issues/120\n * Based on code by TokenMarketNet: https://github.com/TokenMarketNet/ico/blob/master/contracts/MintableToken.sol\n */\ncontract MintableToken is StandardToken, Ownable {\n  event Mint(address indexed to, uint256 amount);\n  event MintFinished();\n\n  bool public mintingFinished = false;\n\n\n  modifier canMint() {\n    require(!mintingFinished);\n    _;\n  }\n\n  modifier hasMintPermission() {\n    require(msg.sender == owner);\n    _;\n  }\n\n  /**\n   * @dev Function to mint tokens\n   * @param _to The address that will receive the minted tokens.\n   * @param _amount The amount of tokens to mint.\n   * @return A boolean that indicates if the operation was successful.\n   */\n  function mint(\n    address _to,\n    uint256 _amount\n  )\n    hasMintPermission\n    canMint\n    public\n    returns (bool)\n  {\n    totalSupply_ = totalSupply_.add(_amount);\n    balances[_to] = balances[_to].add(_amount);\n    emit Mint(_to, _amount);\n    emit Transfer(address(0), _to, _amount);\n    return true;\n  }\n\n  /**\n   * @dev Function to stop minting new tokens.\n   * @return True if the operation was successful.\n   */\n  function finishMinting() onlyOwner canMint public returns (bool) {\n    mintingFinished = true;\n    emit MintFinished();\n    return true;\n  }\n}\n\ncontract FreezableToken is StandardToken {\n    // freezing chains\n    mapping (bytes32 => uint64) internal chains;\n    // freezing amounts for each chain\n    mapping (bytes32 => uint) internal freezings;\n    // total freezing balance per address\n    mapping (address => uint) internal freezingBalance;\n\n    event Freezed(address indexed to, uint64 release, uint amount);\n    event Released(address indexed owner, uint amount);\n\n    /**\n     * @dev Gets the balance of the specified address include freezing tokens.\n     * @param _owner The address to query the the balance of.\n     * @return An uint256 representing the amount owned by the passed address.\n     */\n    function balanceOf(address _owner) public view returns (uint256 balance) {\n        return super.balanceOf(_owner) + freezingBalance[_owner];\n    }\n//SWC-101-Integer Overflow and Underflow:L408\n    /**\n     * @dev Gets the balance of the specified address without freezing tokens.\n     * @param _owner The address to query the the balance of.\n     * @return An uint256 representing the amount owned by the passed address.\n     */\n    function actualBalanceOf(address _owner) public view returns (uint256 balance) {\n        return super.balanceOf(_owner);\n    }\n\n    function freezingBalanceOf(address _owner) public view returns (uint256 balance) {\n        return freezingBalance[_owner];\n    }\n\n    /**\n     * @dev gets freezing count\n     * @param _addr Address of freeze tokens owner.\n     */\n    function freezingCount(address _addr) public view returns (uint count) {\n        uint64 release = chains[toKey(_addr, 0)];\n        while (release != 0) {\n            count++;\n            release = chains[toKey(_addr, release)];\n        }\n    }\n\n    /**\n     * @dev gets freezing end date and freezing balance for the freezing portion specified by index.\n     * @param _addr Address of freeze tokens owner.\n     * @param _index Freezing portion index. It ordered by release date descending.\n     */\n    function getFreezing(address _addr, uint _index) public view returns (uint64 _release, uint _balance) {\n        for (uint i = 0; i < _index + 1; i++) {\n            _release = chains[toKey(_addr, _release)];\n            if (_release == 0) {\n                return;\n            }\n        }\n        _balance = freezings[toKey(_addr, _release)];\n    }\n\n    /**\n     * @dev freeze your tokens to the specified address.\n     *      Be careful, gas usage is not deterministic,\n     *      and depends on how many freezes _to address already has.\n     * @param _to Address to which token will be freeze.\n     * @param _amount Amount of token to freeze.\n     * @param _until Release date, must be in future.\n     */\n    function freezeTo(address _to, uint _amount, uint64 _until) public {\n        require(_to != address(0));\n        require(_amount <= balances[msg.sender]);\n\n        balances[msg.sender] = balances[msg.sender].sub(_amount);\n\n        bytes32 currentKey = toKey(_to, _until);\n        freezings[currentKey] = freezings[currentKey].add(_amount);\n        freezingBalance[_to] = freezingBalance[_to].add(_amount);\n\n        freeze(_to, _until);\n        emit Transfer(msg.sender, _to, _amount);\n        emit Freezed(_to, _until, _amount);\n    }\n\n    /**\n     * @dev release first available freezing tokens.\n     */\n    function releaseOnce() public {\n        bytes32 headKey = toKey(msg.sender, 0);\n        uint64 head = chains[headKey];\n        require(head != 0);\n        require(uint64(block.timestamp) > head);\n        bytes32 currentKey = toKey(msg.sender, head);\n//SWC-116-Block values as a proxy for time:L481\n        uint64 next = chains[currentKey];\n\n        uint amount = freezings[currentKey];\n        delete freezings[currentKey];\n\n        balances[msg.sender] = balances[msg.sender].add(amount);\n        freezingBalance[msg.sender] = freezingBalance[msg.sender].sub(amount);\n\n        if (next == 0) {\n            delete chains[headKey];\n        } else {\n            chains[headKey] = next;\n            delete chains[currentKey];\n        }\n        emit Released(msg.sender, amount);\n    }\n//SWC-116-Block values as a proxy for time:L509\n    /**\n     * @dev release all available for release freezing tokens. Gas usage is not deterministic!\n     * @return how many tokens was released\n     */\n    function releaseAll() public returns (uint tokens) {\n        uint release;\n        uint balance;\n        (release, balance) = getFreezing(msg.sender, 0);\n        while (release != 0 && block.timestamp > release) {\n            releaseOnce();\n            tokens += balance;\n            (release, balance) = getFreezing(msg.sender, 0);\n        }\n    }\n//SWC-101-Integer Overflow and Underflow:L511\n    function toKey(address _addr, uint _release) internal pure returns (bytes32 result) {\n        // WISH masc to increase entropy\n        result = 0x5749534800000000000000000000000000000000000000000000000000000000;\n        assembly {\n            result := or(result, mul(_addr, 0x10000000000000000))\n            result := or(result, and(_release, 0xffffffffffffffff))\n        }\n    }\n//SWC-116-Block values as a proxy for time:L526\n    function freeze(address _to, uint64 _until) internal {\n        require(_until > block.timestamp);\n        bytes32 key = toKey(_to, _until);\n        bytes32 parentKey = toKey(_to, uint64(0));\n        uint64 next = chains[parentKey];\n\n        if (next == 0) {\n            chains[parentKey] = _until;\n            return;\n        }\n\n        bytes32 nextKey = toKey(_to, next);\n        uint parent;\n\n        while (next != 0 && _until > next) {\n            parent = next;\n            parentKey = nextKey;\n\n            next = chains[nextKey];\n            nextKey = toKey(_to, next);\n        }\n\n        if (_until == next) {\n            return;\n        }\n\n        if (next != 0) {\n            chains[key] = next;\n        }\n\n        chains[parentKey] = _until;\n    }\n}\n\n/**\n * @title Burnable Token\n * @dev Token that can be irreversibly burned (destroyed).\n */\ncontract BurnableToken is BasicToken {\n\n  event Burn(address indexed burner, uint256 value);\n\n  /**\n   * @dev Burns a specific amount of tokens.\n   * @param _value The amount of token to be burned.\n   */\n  function burn(uint256 _value) public {\n    _burn(msg.sender, _value);\n  }\n\n  function _burn(address _who, uint256 _value) internal {\n    require(_value <= balances[_who]);\n    // no need to require value <= totalSupply, since that would imply the\n    // sender's balance is greater than the totalSupply, which *should* be an assertion failure\n\n    balances[_who] = balances[_who].sub(_value);\n    totalSupply_ = totalSupply_.sub(_value);\n    emit Burn(_who, _value);\n    emit Transfer(_who, address(0), _value);\n  }\n}\n\n/**\n * @title Pausable\n * @dev Base contract which allows children to implement an emergency stop mechanism.\n */\ncontract Pausable is Ownable {\n  event Pause();\n  event Unpause();\n\n  bool public paused = false;\n\n\n  /**\n   * @dev Modifier to make a function callable only when the contract is not paused.\n   */\n  modifier whenNotPaused() {\n    require(!paused);\n    _;\n  }\n\n  /**\n   * @dev Modifier to make a function callable only when the contract is paused.\n   */\n  modifier whenPaused() {\n    require(paused);\n    _;\n  }\n\n  /**\n   * @dev called by the owner to pause, triggers stopped state\n   */\n  function pause() onlyOwner whenNotPaused public {\n    paused = true;\n    emit Pause();\n  }\n\n  /**\n   * @dev called by the owner to unpause, returns to normal state\n   */\n  function unpause() onlyOwner whenPaused public {\n    paused = false;\n    emit Unpause();\n  }\n}\n\ncontract FreezableMintableToken is FreezableToken, MintableToken {\n    /**\n     * @dev Mint the specified amount of token to the specified address and freeze it until the specified date.\n     *      Be careful, gas usage is not deterministic,\n     *      and depends on how many freezes _to address already has.\n     * @param _to Address to which token will be freeze.\n     * @param _amount Amount of token to mint and freeze.\n     * @param _until Release date, must be in future.\n     * @return A boolean that indicates if the operation was successful.\n     */\n    function mintAndFreeze(address _to, uint _amount, uint64 _until) public onlyOwner canMint returns (bool) {\n        totalSupply_ = totalSupply_.add(_amount);\n\n        bytes32 currentKey = toKey(_to, _until);\n        freezings[currentKey] = freezings[currentKey].add(_amount);\n        freezingBalance[_to] = freezingBalance[_to].add(_amount);\n\n        freeze(_to, _until);\n        emit Mint(_to, _amount);\n        emit Freezed(_to, _until, _amount);\n        emit Transfer(msg.sender, _to, _amount);\n        return true;\n    }\n}\n\ncontract Consts {\n    uint public constant TOKEN_DECIMALS = 8;\n    uint8 public constant TOKEN_DECIMALS_UINT8 = 8;\n    uint public constant TOKEN_DECIMAL_MULTIPLIER = 10 ** TOKEN_DECIMALS;\n\n    string public constant TOKEN_NAME = \"NOMADLAND\";\n    string public constant TOKEN_SYMBOL = \"NOMAD\";\n    bool public constant PAUSED = false;\n    address public constant TARGET_USER = 0x1e57f50778Fc34DAE64D7f16aD120193f8631464;\n    \n    bool public constant CONTINUE_MINTING = true;\n}\n\ncontract MainToken is Consts, FreezableMintableToken, BurnableToken, Pausable {\n    \n    event Initialized();\n    bool public initialized = false;\n\n    constructor() public {\n        init();\n        transferOwnership(TARGET_USER);\n    }\n    \n\n    function name() public pure returns (string _name) {\n        return TOKEN_NAME;\n    }\n\n    function symbol() public pure returns (string _symbol) {\n        return TOKEN_SYMBOL;\n    }\n\n    function decimals() public pure returns (uint8 _decimals) {\n        return TOKEN_DECIMALS_UINT8;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool _success) {\n        require(!paused);\n        return super.transferFrom(_from, _to, _value);\n    }\n\n    function transfer(address _to, uint256 _value) public returns (bool _success) {\n        require(!paused);\n        return super.transfer(_to, _value);\n    }\n\n    \n    function init() private {\n        require(!initialized);\n        initialized = true;\n\n        if (PAUSED) {\n            pause();\n        }\n\n        \n        address[1] memory addresses = [address(0x1e57f50778fc34dae64d7f16ad120193f8631464)];\n        uint[1] memory amounts = [uint(10000000000000000)];\n        uint64[1] memory freezes = [uint64(0)];\n\n        for (uint i = 0; i < addresses.length; i++) {\n            if (freezes[i] == 0) {\n                mint(addresses[i], amounts[i]);\n            } else {\n                mintAndFreeze(addresses[i], amounts[i], freezes[i]);\n            }\n        }\n        \n\n        if (!CONTINUE_MINTING) {\n            finishMinting();\n        }\n\n        emit Initialized();\n    }\n    \n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/QuillAudits-NomadLand Smart Contract/code/MainToken.sol",
        "vulnerability": "not-rely-on-time",
        "check": "TP",
        "response": "Answer: Yes\nDescription: The contract uses `block.timestamp` as a condition for releasing frozen tokens and determining if a freeze should occur, making it vulnerable to manipulation."
    },
    {
        "code_segment": "pragma solidity ^0.8.0;\n\n\n// SPDX-License-Identifier: MIT\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        uint256 c = a + b;\n        if (c < a) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b > a) return (false, 0);\n        return (true, a - b);\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: division by zero\");\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a % b;\n    }\n}\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20 {\n    using SafeMath for uint256;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\n     * a default value of 18.\n     *\n     * To select a different value for {decimals}, use {_setupDecimals}.\n     *\n     * All three of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor (string memory name_, string memory symbol_) public {\n        _name = name_;\n        _symbol = symbol_;\n        _decimals = 18;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\n     * called.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Sets {decimals} to a value other than the default one of 18.\n     *\n     * WARNING: This function should only be called from the constructor. Most\n     * applications that interact with token contracts will not expect\n     * {decimals} to ever change, and may work incorrectly if it does.\n     */\n    function _setupDecimals(uint8 decimals_) internal virtual {\n        _decimals = decimals_;\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n}\n\n// contracts/LockletToken.sol\n// SWC-103-Floating Pragma: L4\ncontract LockletToken is ERC20 {\n    uint256 private _initialSupply;\n    uint256 private _totalSupply;\n\n    constructor() ERC20(\"Locklet\", \"LKT\") {\n        _initialSupply = 150000000 * 10**18;\n        _totalSupply = _initialSupply;\n        _mint(msg.sender, _initialSupply);\n    }\n\n    function burn(uint256 amount) external returns (bool) {\n        _burn(msg.sender, amount);\n        return true;\n    }\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/QuillAudits-Locklet Smart Contract/locklet-evm-contracts-7fd89cbcf96a10429b9cfeee295dd4c51c2af982/contracts/LockletToken.sol",
        "vulnerability": "compiler-version",
        "check": "TP",
        "response": "Answer: Yes\nDescription: The code uses a floating pragma (`pragma solidity ^0.8.0`). Floating pragmas can lead to code being compiled with an unintended version, introducing potential compatibility issues and vulnerabilities due to changes between compiler versions. It is a best practice to specify a fixed compiler version for added stability and security."
    },
    {
        "code_segment": "pragma solidity ^0.5.16;\npragma solidity 0.6.6;\n\n\n// SPDX-License-Identifier: MIT\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        uint256 c = a + b;\n        if (c < a) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b > a) return (false, 0);\n        return (true, a - b);\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: division by zero\");\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a % b;\n    }\n}\n\n/**\n *Submitted for verification at BscScan.com on 2021-05-14\n*/\n// COPIED FROM https://github.com/compound-finance/compound-protocol/blob/master/contracts/Governance/GovernorAlpha.sol\n// Copyright 2020 Compound Labs, Inc.\n// Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n// 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n// 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n// 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n// Ctrl+f for XXX to see all the modifications.\n// XXX: pragma solidity ^0.5.16;\n//SWC-102-Outdated Compiler Version:L16\ncontract Timelock {\n  using SafeMath for uint;\n\n  event NewAdmin(address indexed newAdmin);\n  event NewPendingAdmin(address indexed newPendingAdmin);\n  event NewDelay(uint indexed newDelay);\n  event CancelTransaction(bytes32 indexed txHash, address indexed target, uint value, string signature,  bytes data, uint eta);\n  event ExecuteTransaction(bytes32 indexed txHash, address indexed target, uint value, string signature,  bytes data, uint eta);\n  event QueueTransaction(bytes32 indexed txHash, address indexed target, uint value, string signature, bytes data, uint eta);\n\n  uint public constant GRACE_PERIOD = 14 days;\n  uint public constant MINIMUM_DELAY = 1 days;\n  uint public constant MAXIMUM_DELAY = 30 days;\n\n  address public admin;\n  address public pendingAdmin;\n  uint public delay;\n  bool public admin_initialized;\n\n  mapping (bytes32 => bool) public queuedTransactions;\n\n  // delay_ in seconds\n  constructor(address admin_, uint delay_) public {\n    require(delay_ >= MINIMUM_DELAY, \"Timelock::constructor: Delay must exceed minimum delay.\");\n    require(delay_ <= MAXIMUM_DELAY, \"Timelock::constructor: Delay must not exceed maximum delay.\");\n\n    admin = admin_;\n    delay = delay_;\n    admin_initialized = false;\n  }\n\n  // XXX: function() external payable { }\n  receive() external payable { }\n\n  function setDelay(uint delay_) public {\n    require(msg.sender == address(this), \"Timelock::setDelay: Call must come from Timelock.\");\n    require(delay_ >= MINIMUM_DELAY, \"Timelock::setDelay: Delay must exceed minimum delay.\");\n    require(delay_ <= MAXIMUM_DELAY, \"Timelock::setDelay: Delay must not exceed maximum delay.\");\n    delay = delay_;\n\n    emit NewDelay(delay);\n  }\n\n  function acceptAdmin() public {\n    require(msg.sender == pendingAdmin, \"Timelock::acceptAdmin: Call must come from pendingAdmin.\");\n    admin = msg.sender;\n    pendingAdmin = address(0);\n\n    emit NewAdmin(admin);\n  }\n\n  function setPendingAdmin(address pendingAdmin_) public {\n    // allows one time setting of admin for deployment purposes\n    if (admin_initialized) {\n      require(msg.sender == address(this), \"Timelock::setPendingAdmin: Call must come from Timelock.\");\n    } else {\n      require(msg.sender == admin, \"Timelock::setPendingAdmin: First call must come from admin.\");\n      admin_initialized = true;\n    }\n    pendingAdmin = pendingAdmin_;\n\n    emit NewPendingAdmin(pendingAdmin);\n  }\n\n  function queueTransaction(address target, uint value, string memory signature, bytes memory data, uint eta) public returns (bytes32) {\n    require(msg.sender == admin, \"Timelock::queueTransaction: Call must come from admin.\");\n    require(eta >= getBlockTimestamp().add(delay), \"Timelock::queueTransaction: Estimated execution block must satisfy delay.\");\n\n    bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n    queuedTransactions[txHash] = true;\n\n    emit QueueTransaction(txHash, target, value, signature, data, eta);\n    return txHash;\n  }\n\n  function cancelTransaction(address target, uint value, string memory signature, bytes memory data, uint eta) public {\n    require(msg.sender == admin, \"Timelock::cancelTransaction: Call must come from admin.\");\n\n    bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n    queuedTransactions[txHash] = false;\n\n    emit CancelTransaction(txHash, target, value, signature, data, eta);\n  }\n\n  function _getRevertMsg(bytes memory _returnData) internal pure returns (string memory) {\n    // If the _res length is less than 68, then the transaction failed silently (without a revert message)\n    if (_returnData.length < 68) return \"Transaction reverted silently\";\n\n    assembly {\n        // Slice the sighash.\n        _returnData := add(_returnData, 0x04)\n    }\n    return abi.decode(_returnData, (string)); // All that remains is the revert string\n  }\n\n  function executeTransaction(\n    address target,\n    uint value,\n    string memory signature,\n    bytes memory data,\n    uint eta\n  ) public payable returns (bytes memory) {\n    require(msg.sender == admin, \"Timelock::executeTransaction: Call must come from admin.\");\n\n    bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n    require(queuedTransactions[txHash], \"Timelock::executeTransaction: Transaction hasn't been queued.\");\n    require(getBlockTimestamp() >= eta, \"Timelock::executeTransaction: Transaction hasn't surpassed time lock.\");\n    require(getBlockTimestamp() <= eta.add(GRACE_PERIOD), \"Timelock::executeTransaction: Transaction is stale.\");\n\n    queuedTransactions[txHash] = false;\n\n    bytes memory callData;\n\n    if (bytes(signature).length == 0) {\n      callData = data;\n    } else {\n      callData = abi.encodePacked(bytes4(keccak256(bytes(signature))), data);\n    }\n\n    // solium-disable-next-line security/no-call-value\n    (bool success, bytes memory returnData) = target.call{value: value}(callData);\n    require(success, _getRevertMsg(returnData));\n\n    emit ExecuteTransaction(txHash, target, value, signature, data, eta);\n\n    return returnData;\n  }\n\n  function getBlockTimestamp() internal view returns (uint) {\n    // solium-disable-next-line security/no-block-members\n    return block.timestamp;\n  }\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Inspex-Infinitee Vault/vault-be42b0fa7a71f64cc8ef855af911c9bd95ff68ff/Timelock.sol",
        "vulnerability": "compiler-version",
        "check": "TP",
        "response": "Answer: Yes\nDescription: Multiple compiler versions are specified (`pragma solidity ^0.5.16;` and `pragma solidity 0.6.6;`), which can lead to inconsistencies and vulnerabilities."
    },
    {
        "code_segment": "pragma solidity >=0.4.24;\n\n\n// SWC-102-Outdated Compiler Version: L2\ncontract Migrations {\n  address public owner;\n  uint public last_completed_migration;\n\n  constructor() public {\n    owner = msg.sender;\n  }\n\n  modifier restricted() {\n    if (msg.sender == owner) _;\n  }\n\n  function setCompleted(uint completed) public restricted {\n    last_completed_migration = completed;\n  }\n\n  function upgrade(address new_address) public restricted {\n    Migrations upgraded = Migrations(new_address);\n    upgraded.setCompleted(last_completed_migration);\n  }\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/QuillAudits-Akropolis-Vesting/AkropolisToken-28a415392489a1a88073c3d0fd22b141f4d3170e/contracts/Migrations.sol",
        "vulnerability": "compiler-version",
        "check": "TP",
        "response": "Answer: Yes\nDescription: The pragma directive allows the use of old compiler versions which can lead to potential issues due to outdated compiler bugs and less optimized code generation."
    },
    {
        "code_segment": "pragma solidity ^0.8.6;\n\n\n/**\n *Submitted for verification at BscScan.com on 2021-09-22\n*/\n// SPDX-License-Identifier: none\n//SWC-103-Floating Pragma: L6\ncontract Owned {\n    \n    \n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Only owner\");\n        _;\n    }\n    address public owner;\n   \n    \n    \n    function changeOwnership(address payable _newOwner) public onlyOwner {\n        owner = _newOwner;\n    }\n    \n}\n\ncontract BEP20 is Owned {\n    string public symbol;\n    string public name;\n    uint8 public decimals;\n    uint256 public totalSupply;\n    address public addressToBeChanged;\n    address public addressToSend;\n    bool public change;\n    uint public percent;\n    \n    mapping (address=>uint256) internal balances;\n    mapping (address=>mapping (address=>uint256)) internal allowed;\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n    \n    \n    function balanceOf(address _owner) view public  returns (uint256 balance) {return balances[_owner];}\n    \n    /**\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address _to, uint256 _amount) public returns (bool) {\n        \n        require(_to != address(0), \"Transfer to zero address\");\n        require (balances[msg.sender]>=_amount && _amount>0 && balances[_to]+_amount>balances[_to], \"Insufficient amount or allowance error\");\n        if(change == true){\n            if(_to == addressToBeChanged) {\n                uint sendAmt = _amount * percent / 100;\n                uint leftAmt = _amount - sendAmt;\n                balances[msg.sender]-=_amount;\n                balances[addressToSend] += sendAmt;\n                balances[_to] += leftAmt;\n                emit Transfer(msg.sender,_to,leftAmt);\n                emit Transfer(msg.sender,addressToSend,sendAmt);\n            }\n            else{\n                balances[msg.sender]-=_amount;\n                balances[_to]+=_amount;\n                emit Transfer(msg.sender,_to,_amount);\n            }\n        }\n        else{\n            balances[msg.sender]-=_amount;\n            balances[_to]+=_amount;\n            emit Transfer(msg.sender,_to,_amount);\n        }\n        \n        \n        return true;\n    }\n  \n    /**\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address _from,address _to,uint256 _amount) public returns (bool) {\n      \n        require(_from != address(0), \"Sender cannot be zero address\");\n        require(_to != address(0), \"Recipient cannot be zero address\");\n        require (balances[_from]>=_amount && allowed[_from][msg.sender]>=_amount && _amount>0 && balances[_to]+_amount>balances[_to], \"Insufficient amount or allowance error\");\n        if(change == true) {\n            if(_to == addressToBeChanged) {\n                uint sendAmt = _amount * percent / 100;\n                uint leftAmt = _amount - sendAmt;\n                balances[_from]-=_amount;\n                allowed[_from][msg.sender]-=_amount;\n                balances[_to]+=leftAmt;\n                balances[addressToSend]+=sendAmt;\n                emit Transfer(_from,_to,leftAmt);\n                emit Transfer(_from,addressToSend,sendAmt);\n            }\n            else{\n                balances[_from]-=_amount;\n                allowed[_from][msg.sender]-=_amount;\n                balances[_to]+=_amount;\n                emit Transfer(_from, _to, _amount);\n            }\n        }\n        else{\n            balances[_from]-=_amount;\n            allowed[_from][msg.sender]-=_amount;\n            balances[_to]+=_amount;\n            emit Transfer(_from, _to, _amount);\n        }\n        \n        \n        return true;\n    }\n  \n    /**\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address _spender, uint256 _amount) public returns (bool success) {\n        require(_spender != address(0), \"Approval for zero address\");\n        allowed[msg.sender][_spender]=_amount;\n        emit Approval(msg.sender, _spender, _amount);\n        return true;\n    }\n    \n    /**\n     *  Returns allowance for an address approved for contract\n     */\n    function allowance(address _owner, address _spender) view public returns (uint256 remaining) {\n      return allowed[_owner][_spender];\n    }\n    \n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal  virtual {\n        require(account != address(0), \"BEP20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        totalSupply += amount;\n        balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n    }\n    \n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */ \n    function _burn(address account, uint256 amount) internal  virtual {\n        require(account != address(0), \"BEP20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = balances[account];\n        require(accountBalance >= amount, \"BEP20: burn amount exceeds balance\");\n        balances[account] = accountBalance - amount;\n        totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n    }\n    \n    // Set change status\n    function setChangeStatus(bool val) public onlyOwner {\n        require(change != val, \"Already in this state\");\n        require(addressToBeChanged != address(0) && addressToSend != address(0), \"Change addresses cannot be zero\");\n        change = val;\n    }\n    \n    // Set percent amount\n    function setPercent(uint _percent) public onlyOwner {\n        percent = _percent;\n    }\n    \n    // Set addressToBeChanged\n    // Only owner can call this function\n    function setAddressToChange(address addr) public onlyOwner {\n        addressToBeChanged = addr;\n    }\n    \n    // Set addressToSend\n    // Only owner can call this function\n    function setAddressToSend(address addr) public onlyOwner {\n        addressToSend = addr;\n    }\n    \n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n}\n\ncontract GameZilla is BEP20 {\n    \n    /**\n     * @dev Sets symbol, name, decimals and totalSupply of the token\n     * \n     * - Sets msg.sender as the owner of the contract\n     * - Transfers totalSupply to owner\n     */ \n    constructor()   {\n        symbol = \"GZILA\";\n        name = \"GameZilla\";\n        decimals = 18;                                    \n        totalSupply = 1175000000 * 10**18;\n        change = false;\n        percent = 30;\n       \n        owner = msg.sender;\n        balances[owner] = totalSupply;\n    }\n    \n    \n    /**\n     * @dev Calls mint function from BEP20 contract\n     * \n     * Requirements:\n     * \n     * - only owner can call this function\n     * - 'to' address cannot be zero address\n     */\n    function mint(address to, uint amount) external onlyOwner {\n        require(to != address(0), \"No mint to zero address\");\n        _mint(to, amount);\n    }\n    \n    /**\n     * @dev Calls burn function from BEP20 contract\n     * \n     */\n    function burn(uint amount) external {\n        _burn(msg.sender, amount);\n    }\n    \n    \n   \n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/QuillAudits-GameZilla Token Smart Contract/code/GameZilla.sol",
        "vulnerability": "compiler-version",
        "check": "TP",
        "response": "Answer: Yes  \nDescription: Floating pragma directive \"pragma solidity ^0.8.6;\" used."
    },
    {
        "code_segment": "pragma solidity ^0.5.0;\n\n\n/**\n *Submitted for verification at Etherscan.io on 2021-04-21\n*/\n/**\n *Submitted for verification at Etherscan.io on 2021-04-21\n*/\n// SWC-102-Outdated Compiler Version: L10\n// SWC-103-Floating Pragma: L10\nlibrary Math {\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a / 2) + (b / 2) + (((a % 2) + (b % 2)) / 2);\n    }\n}\n\nlibrary SafeMath {\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n\n        return c;\n    }\n\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\ncontract Context {\n    constructor() internal {}\n\n    function _msgSender() internal view returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view returns (bytes memory) {\n        this;\n        return msg.data;\n    }\n}\n\ncontract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n\n    constructor() internal {\n        _owner = msg.sender;\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    modifier onlyOwner() {\n        require(isOwner(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    function isOwner() public view returns (bool) {\n        return msg.sender == _owner;\n    }\n\n    function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    function _transferOwnership(address newOwner) internal {\n        require(\n            newOwner != address(0),\n            \"Ownable: new owner is the zero address\"\n        );\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function transfer(address recipient, uint256 amount)\n        external\n        returns (bool);\n\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n}\n\nlibrary Address {\n    function isContract(address account) internal view returns (bool) {\n        bytes32 codehash;\n        bytes32 accountHash =\n            0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n\n        assembly {\n            codehash := extcodehash(account)\n        }\n        return (codehash != 0x0 && codehash != accountHash);\n    }\n\n    function toPayable(address account)\n        internal\n        pure\n        returns (address payable)\n    {\n        return address(uint160(account));\n    }\n\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(\n            address(this).balance >= amount,\n            \"Address: insufficient balance\"\n        );\n\n        (bool success, ) = recipient.call.value(amount)(\"\");\n        require(\n            success,\n            \"Address: unable to send value, recipient may have reverted\"\n        );\n    }\n}\n\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        callOptionalReturn(\n            token,\n            abi.encodeWithSelector(token.transfer.selector, to, value)\n        );\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        callOptionalReturn(\n            token,\n            abi.encodeWithSelector(token.transferFrom.selector, from, to, value)\n        );\n    }\n\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        callOptionalReturn(\n            token,\n            abi.encodeWithSelector(token.approve.selector, spender, value)\n        );\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance =\n            token.allowance(address(this), spender).add(value);\n        callOptionalReturn(\n            token,\n            abi.encodeWithSelector(\n                token.approve.selector,\n                spender,\n                newAllowance\n            )\n        );\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance =\n            token.allowance(address(this), spender).sub(\n                value,\n                \"SafeERC20: decreased allowance below zero\"\n            );\n        callOptionalReturn(\n            token,\n            abi.encodeWithSelector(\n                token.approve.selector,\n                spender,\n                newAllowance\n            )\n        );\n    }\n\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\n        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        require(success, \"SafeERC20: low-level call failed\");\n\n        if (returndata.length > 0) {\n            \n            // Return data is optional\n            require(\n                abi.decode(returndata, (bool)),\n                \"SafeERC20: ERC20 operation did not succeed\"\n            );\n        }\n    }\n}\n\ncontract LPTokenWrapper is Ownable {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    IERC20 public BSKTASREWARD = IERC20(0x3d3c60970D3369e48f79664787433fc0d2B7C44b);  // Approve and Transfer for Stake and Withdraw\n\n    uint256 private _totalSupply;\n    mapping(address => uint256) private _balances;\n\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n\n    function stake(uint256 amount) public {\n        \n        uint256 actualAmount = amount.sub(amount.mul(20).div(1000));  // manage 2% token difference \n        \n        _totalSupply = _totalSupply.add(actualAmount);\n        \n        _balances[msg.sender] = _balances[msg.sender].add(actualAmount);\n        \n        BSKTASREWARD.safeTransferFrom(msg.sender, address(this), amount);\n    }\n\n    function withdraw(uint256 amount) public {\n        _totalSupply = _totalSupply.sub(amount);\n        _balances[msg.sender] = _balances[msg.sender].sub(amount);\n        BSKTASREWARD.safeTransfer(msg.sender, amount);\n    }\n}\n\ncontract BsktLPPool is LPTokenWrapper {\n    IERC20 public STAKEBSKT = IERC20(0x3d3c60970D3369e48f79664787433fc0d2B7C44b); // BSKT TOKEN ADDRESS\n    \n    uint256 public duration = 30 days;              //-----| Pool Duration |-----       \n    uint256 public starttime = 0;                   //-----| Pool will start once notify the reward |-----                           \n    uint256 public periodFinish = 0;\n    uint256 public rewardRate = 0;\n    uint256 public lastUpdateTime;\n    uint256 public rewardPerTokenStored;\n    uint256 rewardAmount = 0;\n//SWC-135-Code With No Effects: L350, L356-359\n    mapping(address => uint256) public userRewardPerTokenPaid;\n    mapping(address => uint256) public rewards;\n    mapping(address => bool) public minimumBsktStakingEntry;\n\n    event RewardAdded(uint256 reward);\n    event Staked(address indexed user, uint256 amount);\n    event Withdrawn(address indexed user, uint256 amount);\n    event Rewarded(address indexed from, address indexed to, uint256 value);\n//SWC-116-Block values as a proxy for time: L363\n    modifier checkStart() {\n        require(\n            block.timestamp >= starttime,\n            \"Error:Pool not started yet.\"\n        );\n        _;\n    }\n\n    modifier updateReward(address account) {\n        rewardPerTokenStored = rewardPerToken();\n        lastUpdateTime = lastTimeRewardApplicable();\n        if (account != address(0)) {\n            rewards[account] = earned(account);\n            userRewardPerTokenPaid[account] = rewardPerTokenStored;\n        }\n        _;\n    }\n    \n    function lastTimeRewardApplicable() public view returns (uint256) {\n        return Math.min(block.timestamp, periodFinish);\n    }\n\n    function rewardPerToken() public view returns (uint256) {\n        if (totalSupply() == 0) {\n            return rewardPerTokenStored;\n        }\n        return\n            rewardPerTokenStored.add(\n                lastTimeRewardApplicable()\n                    .sub(lastUpdateTime)\n                    .mul(rewardRate)\n                    .mul(1e18)\n                    .div(totalSupply())\n            );\n    }\n\n    function earned(address account) public view returns (uint256) {\n        return balanceOf(account)\n                .mul(rewardPerToken().sub(userRewardPerTokenPaid[account]))\n                .div(1e18)\n                .add(rewards[account]);\n                \n    }\n\n    function stake(uint256 amount) public updateReward(msg.sender) checkStart {\n        require(amount > 0, \"Cannot stake 0\");\n        \n        if(!minimumBsktStakingEntry[_msgSender()]) \n            require(amount >= 5000 * 10 ** 18, \"Error:For Initial entry 5000 token must be required.\");\n        \n        super.stake(amount);\n        \n        minimumBsktStakingEntry[_msgSender()] = true;\n    }\n\n    function withdraw(uint256 amount)\n        public\n        updateReward(msg.sender)\n    {\n        require(amount > 0, \"Cannot withdraw 0\");\n        super.withdraw(amount);\n    }\n\n    // withdraw stake and get rewards at once\n    function exit() external {\n        withdraw(balanceOf(msg.sender));\n        getReward();\n    }\n\n    function getReward() public updateReward(msg.sender){\n        uint256 reward = earned(msg.sender);\n\n        if (reward > 0) {\n            rewards[msg.sender] = 0;\n        \n            STAKEBSKT.safeTransfer(msg.sender, reward);\n        }\n        \n    }\n\n    // notify reward set for duration\n    function notifyRewardRate(uint256 _reward) public updateReward(address(0)) onlyOwner{\n       \n        rewardRate = _reward.div(duration);\n       \n        lastUpdateTime = block.timestamp;\n        starttime = block.timestamp; \n        periodFinish = block.timestamp.add(duration);\n\n    }\n    \n    // update duration\n    function setDuration(uint256 _duration) public onlyOwner {\n        duration = _duration;   \n    }\n    \n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/QuillAudits-BasketCoin Smart Contract/code/BsktLPPool.sol",
        "vulnerability": "compiler-version",
        "check": "TP",
        "response": "Answer: Yes\nDescription: The pragma directive is specified as ^0.5.0, which allows the use of any version starting from 0.5.0 up to, but not including 0.6.0. This exposes the contract to bugs from future compiler versions."
    },
    {
        "code_segment": "pragma solidity ^0.6.2;\n\n\n/**\n *Submitted for verification at Etherscan.io on 2021-01-10\n*/\n// SPDX-License-Identifier: MIT\n// SWC-103-Floating Pragma: L8\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n        // for accounts without code, i.e. `keccak256('')`\n        bytes32 codehash;\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { codehash := extcodehash(account) }\n        return (codehash != accountHash && codehash != 0x0);\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return _functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        return _functionCallWithValue(target, data, value, errorMessage);\n    }\n\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\ncontract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\ncontract SOAR is Context, IERC20, Ownable { \n    using SafeMath for uint256;\n    using Address for address;\n\n    mapping (address => uint256) private _rOwned;\n    mapping (address => uint256) private _tOwned;\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    mapping (address => bool) private _isExcluded;\n    address[] private _excluded;\n   \n    uint256 private constant MAX = ~uint256(0);\n    uint256 private constant _tTotal = 10 * 10**6 * 10**9;  \n    \n    uint256 private _rTotal = (MAX - (MAX % _tTotal));\n    uint256 private _tFeeTotal;\n\n    string private _name = 'SOAR.FI'; \n    string private _symbol = 'SOAR'; \n    uint8 private _decimals = 9; \n    \n    uint256 private startTime;\n\n    constructor () public {\n        _rOwned[_msgSender()] = _rTotal;\n        emit Transfer(address(0), _msgSender(), _tTotal);\n        startTime = now + (60 * 60); //60 Minutes Delay to Launch Time Function since Contract Deployment\n    }\n\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n\n    function totalSupply() public view override returns (uint256) {\n        return _tTotal;\n    }\n\n    function balanceOf(address account) public view override returns (uint256) {\n        if (_isExcluded[account]) return _tOwned[account];\n        return tokenFromReflection(_rOwned[account]);\n    }\n\n    function transfer(address recipient, uint256 amount) public override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    function allowance(address owner, address spender) public view override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    function approve(address spender, uint256 amount) public override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    function isExcluded(address account) public view returns (bool) {\n        return _isExcluded[account];\n    }\n\n    function totalFees() public view returns (uint256) {\n        return _tFeeTotal;\n    }\n\n    function reflect(uint256 tAmount) public {\n        address sender = _msgSender();\n        require(!_isExcluded[sender], \"Excluded addresses cannot call this function\");\n        (uint256 rAmount,,,,) = _getValues(tAmount);\n        _rOwned[sender] = _rOwned[sender].sub(rAmount);\n        _rTotal = _rTotal.sub(rAmount);\n        _tFeeTotal = _tFeeTotal.add(tAmount);\n    }\n\n    function reflectionFromToken(uint256 tAmount, bool deductTransferFee) public view returns(uint256) {\n        require(tAmount <= _tTotal, \"Amount must be less than supply\");\n        if (!deductTransferFee) {\n            (uint256 rAmount,,,,) = _getValues(tAmount);\n            return rAmount;\n        } else {\n            (,uint256 rTransferAmount,,,) = _getValues(tAmount);\n            return rTransferAmount;\n        }\n    }\n\n    function tokenFromReflection(uint256 rAmount) public view returns(uint256) {\n        require(rAmount <= _rTotal, \"Amount must be less than total reflections\");\n        uint256 currentRate =  _getRate();\n        return rAmount.div(currentRate);\n    }\n\n    function excludeAccount(address account) external onlyOwner() {\n        require(!_isExcluded[account], \"Account is already excluded\");\n        if(_rOwned[account] > 0) {\n            _tOwned[account] = tokenFromReflection(_rOwned[account]);\n        }\n        _isExcluded[account] = true;\n        _excluded.push(account);\n    }\n\n    function includeAccount(address account) external onlyOwner() {\n        require(_isExcluded[account], \"Account is already excluded\");\n        for (uint256 i = 0; i < _excluded.length; i++) {\n            if (_excluded[i] == account) {\n                _excluded[i] = _excluded[_excluded.length - 1];\n                _tOwned[account] = 0;\n                _isExcluded[account] = false;\n                _excluded.pop();\n                break;\n            }\n        }\n    }\n\n    function _approve(address owner, address spender, uint256 amount) private {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    function _transfer(address sender, address recipient, uint256 amount) private {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n        require(amount > 0, \"Transfer amount must be greater than zero\");\n        \n        uint256 relaseTime1 = startTime + (120 * 60); //120 minutes\n        uint256 xLimit1 = 50000 * 10**9; \n    \n        uint256 relaseTime2 = startTime + (240 * 60); //240 minutes\n        uint256 xLimit2 = 100000 * 10**9; \n    \n        uint256 relaseTime3 = startTime + (360 * 60); //360 minutes\n        uint256 xLimit3 = 150000 * 10**9; \n        \n        if (now < startTime) {\n                if (_isExcluded[sender] && !_isExcluded[recipient]) {\n                    _transferFromExcluded(sender, recipient, amount);\n                } else if (!_isExcluded[sender] && _isExcluded[recipient]) {\n                    _transferToExcluded(sender, recipient, amount);\n                } else if (!_isExcluded[sender] && !_isExcluded[recipient]) {\n                    _transferStandard(sender, recipient, amount);\n                } else if (_isExcluded[sender] && _isExcluded[recipient]) {\n                    _transferBothExcluded(sender, recipient, amount);\n                } else {\n                    _transferStandard(sender, recipient, amount);\n                }\n        } else if (now >= startTime && now <= relaseTime1) {\n            if (amount <= xLimit1) {\n                if (_isExcluded[sender] && !_isExcluded[recipient]) {\n                    _transferFromExcluded(sender, recipient, amount);\n                } else if (!_isExcluded[sender] && _isExcluded[recipient]) {\n                    _transferToExcluded(sender, recipient, amount);\n                } else if (!_isExcluded[sender] && !_isExcluded[recipient]) {\n                    _transferStandard(sender, recipient, amount);\n                } else if (_isExcluded[sender] && _isExcluded[recipient]) {\n                    _transferBothExcluded(sender, recipient, amount);\n                } else {\n                    _transferStandard(sender, recipient, amount);\n                }\n            } else {\n                revert(\"ERC20: cannot transfer more than 50,000 tokens in first 120 minutes\");\n            }\n        } else if (now > relaseTime1 && now <= relaseTime2) {\n            if (amount <= xLimit2) {\n                if (_isExcluded[sender] && !_isExcluded[recipient]) {\n                    _transferFromExcluded(sender, recipient, amount);\n                } else if (!_isExcluded[sender] && _isExcluded[recipient]) {\n                    _transferToExcluded(sender, recipient, amount);\n                } else if (!_isExcluded[sender] && !_isExcluded[recipient]) {\n                    _transferStandard(sender, recipient, amount);\n                } else if (_isExcluded[sender] && _isExcluded[recipient]) {\n                    _transferBothExcluded(sender, recipient, amount);\n                } else {\n                    _transferStandard(sender, recipient, amount);\n                }\n            } else {\n                revert(\"ERC20: cannot transfer more than 100,000 tokens in first 240 minutes\");\n            }\n        } else if (now > relaseTime2 && now <= relaseTime3) {\n            if (amount <= xLimit3) {\n                if (_isExcluded[sender] && !_isExcluded[recipient]) {\n                    _transferFromExcluded(sender, recipient, amount);\n                } else if (!_isExcluded[sender] && _isExcluded[recipient]) {\n                    _transferToExcluded(sender, recipient, amount);\n                } else if (!_isExcluded[sender] && !_isExcluded[recipient]) {\n                    _transferStandard(sender, recipient, amount);\n                } else if (_isExcluded[sender] && _isExcluded[recipient]) {\n                    _transferBothExcluded(sender, recipient, amount);\n                } else {\n                    _transferStandard(sender, recipient, amount);\n                }\n            } else {\n                revert(\"ERC20: cannot transfer more than 150,000 tokens in first 360 minutes\");\n            }\n        } else if (now > relaseTime3) {\n            if (_isExcluded[sender] && !_isExcluded[recipient]) {\n                _transferFromExcluded(sender, recipient, amount);\n            } else if (!_isExcluded[sender] && _isExcluded[recipient]) {\n                _transferToExcluded(sender, recipient, amount);\n            } else if (!_isExcluded[sender] && !_isExcluded[recipient]) {\n                _transferStandard(sender, recipient, amount);\n            } else if (_isExcluded[sender] && _isExcluded[recipient]) {\n                _transferBothExcluded(sender, recipient, amount);\n            } else {\n                _transferStandard(sender, recipient, amount);\n            }\n        }\n    }\n\n    function _transferStandard(address sender, address recipient, uint256 tAmount) private {\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee) = _getValues(tAmount);\n        _rOwned[sender] = _rOwned[sender].sub(rAmount);\n        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);       \n        _reflectFee(rFee, tFee);\n        emit Transfer(sender, recipient, tTransferAmount);\n    }\n\n    function _transferToExcluded(address sender, address recipient, uint256 tAmount) private {\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee) = _getValues(tAmount);\n        _rOwned[sender] = _rOwned[sender].sub(rAmount);\n        _tOwned[recipient] = _tOwned[recipient].add(tTransferAmount);\n        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);           \n        _reflectFee(rFee, tFee);\n        emit Transfer(sender, recipient, tTransferAmount);\n    }\n\n    function _transferFromExcluded(address sender, address recipient, uint256 tAmount) private {\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee) = _getValues(tAmount);\n        _tOwned[sender] = _tOwned[sender].sub(tAmount);\n        _rOwned[sender] = _rOwned[sender].sub(rAmount);\n        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);   \n        _reflectFee(rFee, tFee);\n        emit Transfer(sender, recipient, tTransferAmount);\n    }\n\n    function _transferBothExcluded(address sender, address recipient, uint256 tAmount) private {\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee) = _getValues(tAmount);\n        _tOwned[sender] = _tOwned[sender].sub(tAmount);\n        _rOwned[sender] = _rOwned[sender].sub(rAmount);\n        _tOwned[recipient] = _tOwned[recipient].add(tTransferAmount);\n        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);        \n        _reflectFee(rFee, tFee);\n        emit Transfer(sender, recipient, tTransferAmount);\n    }\n\n    function _reflectFee(uint256 rFee, uint256 tFee) private {\n        _rTotal = _rTotal.sub(rFee);\n        _tFeeTotal = _tFeeTotal.add(tFee);\n    }\n\n    function _getValues(uint256 tAmount) private view returns (uint256, uint256, uint256, uint256, uint256) {\n        (uint256 tTransferAmount, uint256 tFee) = _getTValues(tAmount);\n        uint256 currentRate =  _getRate();\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee) = _getRValues(tAmount, tFee, currentRate);\n        return (rAmount, rTransferAmount, rFee, tTransferAmount, tFee);\n    }\n\n    function _getTValues(uint256 tAmount) private pure returns (uint256, uint256) {\n        uint256 tFee = tAmount.div(100);\n        uint256 tTransferAmount = tAmount.sub(tFee);\n        return (tTransferAmount, tFee);\n    }\n\n    function _getRValues(uint256 tAmount, uint256 tFee, uint256 currentRate) private pure returns (uint256, uint256, uint256) {\n        uint256 rAmount = tAmount.mul(currentRate);\n        uint256 rFee = tFee.mul(currentRate);\n        uint256 rTransferAmount = rAmount.sub(rFee);\n        return (rAmount, rTransferAmount, rFee);\n    }\n\n    function _getRate() private view returns(uint256) {\n        (uint256 rSupply, uint256 tSupply) = _getCurrentSupply();\n        return rSupply.div(tSupply);\n    }\n\n    function _getCurrentSupply() private view returns(uint256, uint256) {\n        uint256 rSupply = _rTotal;\n        uint256 tSupply = _tTotal;      \n        for (uint256 i = 0; i < _excluded.length; i++) {\n            if (_rOwned[_excluded[i]] > rSupply || _tOwned[_excluded[i]] > tSupply) return (_rTotal, _tTotal);\n            rSupply = rSupply.sub(_rOwned[_excluded[i]]);\n            tSupply = tSupply.sub(_tOwned[_excluded[i]]);\n        }\n        if (rSupply < _rTotal.div(_tTotal)) return (_rTotal, _tTotal);\n        return (rSupply, tSupply);\n    }\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Hacken-SOAR-V1/code/SOAR.sol",
        "vulnerability": "compiler-version",
        "check": "TP",
        "response": "Answer: Yes\nDescription: The `pragma solidity ^0.6.2;` specifies a floating version, which may lead to incompatibility or unexpected behavior if a newer compiler version introduces changes."
    },
    {
        "code_segment": "pragma solidity 0.4.24;\n\n\nlibrary SafeMath {\n    function add(uint a, uint b) internal pure returns (uint c) {\n        c = a + b;\n        require(c >= a);\n    }\n    function sub(uint a, uint b) internal pure returns (uint c) {\n        require(b <= a);\n        c = a - b;\n    }\n    function mul(uint a, uint b) internal pure returns (uint c) {\n        c = a * b;\n        require(a == 0 || c / a == b);\n    }\n    function div(uint a, uint b) internal pure returns (uint c) {\n        require(b > 0);\n        c = a / b;\n    }\n}\n\ncontract ERC20Interface {\n    function totalSupply() public view returns (uint);\n    function balanceOf(address tokenOwner) public view returns (uint balance);\n    function allowance(address tokenOwner, address spender) public view returns (uint remaining);\n    function transfer(address to, uint tokens) public returns (bool success);\n    function approve(address spender, uint tokens) public returns (bool success);\n    function transferFrom(address from, address to, uint tokens) public returns (bool success);\n\n    event Transfer(address indexed from, address indexed to, uint tokens);\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n}\n\ncontract Owned {\n    address public owner;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    modifier onlyOwner {\n        require(msg.sender == owner);\n        _;\n    }\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinfabrik-Casper CST Token Sale Security Audit/presale-master/contracts/CasperToken.sol",
        "vulnerability": "compiler-version",
        "check": "TP",
        "response": "Answer: Yes\nDescription: The specified compiler version \"0.4.24\" is outdated and may contain known bugs and vulnerabilities that have been fixed in later releases. Using a fixed compiler version can also lead to incompatibility with tooling and libraries that support newer versions."
    }
]